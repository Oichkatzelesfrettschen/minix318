/**
 * @file main_unified.c
 * @brief Unified exokernel entry point
 * @details This file is a synthesized/unified implementation combining multiple
 *          legacy MINIX implementations into a single, modern, C23-compliant
 *          implementation for MINIX4.
 *
 * Original sources consolidated:
 * - userspace\minix_commands\devmand\main.c
 * - userspace\commands_legacy\system\devmand\main.c
 * - tar\test\main.c
 * - minix4\microkernel\servers\pm\main.c
 * - minix4\microkernel\servers\ramdiskfs\main.c
 * - minix4\microkernel\servers\rs\main.c
 * - minix4\microkernel\servers\netiso\xebec\main.c
 * - minix4\libos_legacy\ed\main.c
 * - minix4\libos_legacy\fsck_ext2fs\main.c
 * - minix4\libos_legacy\ksh\main.c
 * - ... and 88 more files
 *
 * @version 4.0.0
 * @date 2025-06-13
 * @author MINIX4 Synthesis Engine
 * @copyright Copyright (c) 2025 MINIX Project
 */

#pragma once

#define _POSIX_C_SOURCE 202311L

/* Standard C23 headers */
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <stdatomic.h>

/* MINIX4 system headers */
#include <minix4/kernel_types.h>
#include <minix4/config.h>

/* Architecture-specific headers */
#ifdef ARCH_X86_64
#include <minix4/arch/x86_64/arch.h>
#elif defined(ARCH_I386)
#include <minix4/arch/i386/arch.h>
#elif defined(ARCH_ARM)
#include <minix4/arch/arm/arch.h>
#endif


/* ============================================================================
 * SYNTHESIS NOTE: CAREFUL ANALYSIS REQUIRED
 * ============================================================================
 * This file contains 98 very different implementations that
 * require manual review and careful synthesis. The files have been
 * concatenated for analysis, but manual integration is needed.
 * 
 * TODO: Manual synthesis tasks:
 * 1. Analyze functional differences between implementations
 * 2. Determine best approach for each function
 * 3. Modernize to C23 standards
 * 4. Add proper error handling and security
 * 5. Create comprehensive unit tests
 * ============================================================================ */


/* ============================================================================
 * SOURCE 1/98: userspace\minix_commands\devmand\main.c
 * Size: 24,241 bytes, Lines: 943
 * Hash: 00517f73521c...
 * ============================================================================ */

#include <stdio.h>
#include <stdlib.h>
#include <getopt.h>
#include <errno.h>
#include <string.h>
#include <lib.h>
#include <sys/stat.h>
#include <dirent.h>
#include <assert.h>
#include <signal.h>
#include <minix/dmap.h>
#include <minix/paths.h>
#include "usb_driver.h"
#include "proto.h"

#define DEVMAN_TYPE_NAME "dev_type"
#define PATH_LEN 256
#define INVAL_MAJOR -1
#define MAX_CONFIG_DIRS 4

static void main_loop();
static void handle_event();
static void cleanup();
static void parse_config();
static void display_usage();
static enum dev_type determine_type(char *path);
static int get_major();
static void create_pid_file();
static void put_major(int major);
static struct devmand_usb_driver* match_usb_driver(struct usb_device_id *id);
static struct devmand_driver_instance *find_instance(int dev_id);

#define dbg(fmt, ... ) \
	if (args.verbose) \
	printf("%8s:%4d: %13s()| "fmt"\n", __FILE__, __LINE__, __func__,  ##__VA_ARGS__ )

static LIST_HEAD(usb_driver_head, devmand_usb_driver) drivers =
    LIST_HEAD_INITIALIZER(drivers);
static LIST_HEAD(usb_driver_inst_head, devmand_driver_instance) instances =
    LIST_HEAD_INITIALIZER(instances);


static int _run = 1;
struct global_args {
	char *path;
	char *config_dirs[MAX_CONFIG_DIRS];
	int config_dir_count ;
	int major_offset;
	int verbose;
	int check_config;
};

enum dev_type {
	DEV_TYPE_USB_DEVICE,
	DEV_TYPE_USB_INTF,
	DEV_TYPE_UNKOWN
};

extern FILE *yyin;

static struct global_args args = {
	.path = NULL,
	.config_dirs = {NULL,NULL,NULL,NULL},
	.config_dir_count = 0,
	.major_offset = USB_BASE_MAJOR,
	.verbose = 0,
	.check_config = 0};

static struct option options[] =
{
	{"dir"   ,    required_argument, NULL, 'd'},
	{"path",      required_argument, NULL, 'p'},
	{"verbose",    required_argument, NULL, 'v'},
	{"check-config", no_argument,       NULL, 'x'},
	{0,0,0,0} /* terminating entry */
};

static char major_bitmap[16]; /* can store up to 128 major number states */


/*===========================================================================*
 *             run_upscript                                                  *
 *===========================================================================*/
int run_upscript(struct devmand_driver_instance *inst)
{
	char cmdl[1024];
	cmdl[0] = 0;
	int ret;

	assert(inst->drv->upscript);
	assert(inst->label);

	snprintf(cmdl, 1024, "%s up %s %d %d",
	    inst->drv->upscript, inst->label, inst->major, inst->dev_id);
	dbg("Running Upscript:  \"%s\"", cmdl);
	ret = system(cmdl);
	if (ret != 0) {
		return EINVAL;
	}
	return 0;
}

/*===========================================================================*
 *             run_cleanscript                                               *
 *===========================================================================*/
int run_cleanscript(struct devmand_usb_driver *drv)
{
	char cmdl[1024];
	cmdl[0] = 0;
	int ret;

	assert(drv->upscript);
	assert(drv->devprefix);

	snprintf(cmdl, 1024, "%s clean %s ",
		drv->upscript, drv->devprefix);
	dbg("Running Upscript:  \"%s\"", cmdl);
	ret = system(cmdl);

	if (ret != 0) {
		return EINVAL;
	}

	return 0;
}


/*===========================================================================*
 *             run_downscript                                                *
 *===========================================================================*/
int run_downscript(struct devmand_driver_instance *inst)
{
	char cmdl[1024];
	cmdl[0] = 0;
	int ret;

	assert(inst->drv->downscript);
	assert(inst->label);

	snprintf(cmdl, 1024, "%s down %s %d",
	    inst->drv->downscript, inst->label, inst->major);

	dbg("Running Upscript:  \"%s\"", cmdl);

	ret = system(cmdl);

	if (ret != 0) {
		return EINVAL;
	}

	return 0;
}


/*===========================================================================*
 *             stop_driver                                                   *
 *===========================================================================*/
int stop_driver(struct devmand_driver_instance *inst)
{
	char cmdl[1024];
	cmdl[0] = 0;
	int ret;

	assert(inst->label);

	snprintf(cmdl, 1024, "%s down %s %d",
	    _PATH_MINIX_SERVICE, inst->label, inst->dev_id);
	dbg("executing minix-service: \"%s\"", cmdl);
	ret = system(cmdl);
	if (ret != 0)
	{
		return EINVAL;
	}
	printf("Stopped driver %s with label %s for device %d.\n",
		inst->drv->binary, inst->label, inst->dev_id);

	return 0;
}


/*===========================================================================*
 *             start_driver                                                  *
 *===========================================================================*/
int start_driver(struct devmand_driver_instance *inst)
{
	char cmdl[1024];
	cmdl[0] = 0;
	int ret;

	/* generate label */
	ret = snprintf(inst->label, 32,  "%s%d", inst->drv->devprefix,
		inst->dev_id);
	if (ret < 0 || ret > DEVMAND_DRIVER_LABEL_LEN) {
		dbg("label too long");
		return ENOMEM;
	}

	assert(inst->drv->binary);
	assert(inst->label);

	snprintf(cmdl, 1024, "%s up %s  -major %d -devid %d -label %s",
	    _PATH_MINIX_SERVICE, inst->drv->binary, inst->major, inst->dev_id,
		inst->label);
	dbg("executing minix-service: \"%s\"", cmdl);

	ret = system(cmdl);

	if (ret != 0) {
		return EINVAL;
	}

	printf("Started driver %s with label %s for device %d.\n",
		inst->drv->binary, inst->label, inst->dev_id);

	return 0;
}

/*===========================================================================*
 *             find_instance                                                 *
 *===========================================================================*/
static struct devmand_driver_instance *
find_instance(int dev_id)
{
	struct devmand_driver_instance *inst;

	LIST_FOREACH(inst, &instances, list) {
		if (inst->dev_id == dev_id) {
			return inst;
		}
	}
	return NULL;
}

/*===========================================================================*
 *              match_usb_driver                                             *
 *===========================================================================*/
static int
match_usb_id(struct devmand_usb_match_id *mid, struct usb_device_id *id)
{
	int res = 1;
	unsigned long match = mid->match_flags;
	struct usb_device_id *_id = &mid->match_id;

	if (match & USB_MATCH_ID_VENDOR)
		if (id->idVendor != _id->idVendor) res = 0;
	if (match & USB_MATCH_ID_PRODUCT)
		if (id->idProduct != _id->idProduct) res = 0;
	if (match & USB_MATCH_BCD_DEVICE)
		if (id->bcdDevice != _id->bcdDevice) res = 0;
	if (match & USB_MATCH_DEVICE_PROTOCOL)
		if (id->bDeviceProtocol != _id->bDeviceProtocol) res = 0;
	if (match & USB_MATCH_DEVICE_SUBCLASS)
		if (id->bDeviceSubClass != _id->bDeviceSubClass) res = 0;
	if (match & USB_MATCH_DEVICE_PROTOCOL)
		if (id->bDeviceProtocol != _id->bDeviceProtocol) res = 0;
	if (match & USB_MATCH_INTERFACE_CLASS)
		if (id->bInterfaceClass != _id->bInterfaceClass) res = 0;
	if (match & USB_MATCH_INTERFACE_SUBCLASS)
		if (id->bInterfaceSubClass != _id->bInterfaceSubClass) res = 0;
	if (match & USB_MATCH_INTERFACE_PROTOCOL)
		if (id->bInterfaceProtocol != _id->bInterfaceProtocol) res = 0;

	if (match == 0UL) {
		res = 0;
	}

	return res;
}

/*===========================================================================*
 *              match_usb_driver                                             *
 *===========================================================================*/
static struct devmand_usb_driver*
match_usb_driver(struct usb_device_id *id)
{
	struct devmand_usb_driver *driver;
	struct devmand_usb_match_id *mid;

	LIST_FOREACH(driver, &drivers, list) {
		LIST_FOREACH(mid, &driver->ids, list) {
			if (match_usb_id(mid, id)) {
				return driver;
			}
		}
	}
	return NULL;
}

/*===========================================================================*
 *              add_usb_match_id                                             *
 *===========================================================================*/
struct devmand_usb_driver * add_usb_driver(char *name)
{
	struct devmand_usb_driver *udrv = (struct devmand_usb_driver*)
	    malloc(sizeof(struct devmand_usb_driver));

	LIST_INSERT_HEAD(&drivers, udrv, list);
	LIST_INIT(&udrv->ids);

	udrv->name = name;
	return udrv;
}

/*===========================================================================*
 *              add_usb_match_id                                             *
 *===========================================================================*/
struct devmand_usb_match_id *
add_usb_match_id
(struct devmand_usb_driver *drv)
{
	struct devmand_usb_match_id *id = (struct devmand_usb_match_id*)
	    malloc(sizeof(struct devmand_usb_match_id));

	memset(id, 0, sizeof(struct devmand_usb_match_id));

	LIST_INSERT_HEAD(&drv->ids, id, list);

	return id;
}


/*===========================================================================*
 *           parse_config                                                    *
 *===========================================================================*/
static void parse_config()
{
	int i, status, error;
	struct stat stats;
	char * dirname;

	DIR * dir;
	struct dirent entry;
	struct dirent *result;
	char config_file[PATH_MAX];

	dbg("Parsing configuration directories... ");
	/* Next parse the configuration directories */
	for(i=0; i < args.config_dir_count; i++){
		dirname = args.config_dirs[i];
		dbg("Parsing config dir %s ", dirname);
		status = stat(dirname,&stats);
		if (status == -1){
			error = errno;
			dbg("Failed to read directory '%s':%s (skipping) \n", 
			    dirname,strerror(error));
			continue;
		}
		if (!S_ISDIR(stats.st_mode)){
			dbg("Parse configuration skipping %s "
			    "(not a directory) \n",dirname);
			continue;
		}
		dir = opendir(dirname);
		if (dir == NULL){
			error = errno;
			dbg("Parse configuration failed to read dir '%s'"
			    "(skipping) :%s\n",dirname, strerror(error));
			continue;
		}
		while( (status = readdir_r(dir,&entry,&result)) == 0 ){
			if (result == NULL){ /* last entry */ 
				closedir(dir);
				break;
			}

			/* concatenate dir and file name to open it */
			snprintf(config_file,PATH_MAX, "%s/%s",
				 dirname,entry.d_name);
			status = stat(config_file, &stats);
			if (status == -1){ 
				error = errno;
				dbg("Parse configuration Failed to stat file "
				    "'%s': %s (skipping)\n", config_file,
				    strerror(error));
			}
			if (S_ISREG(stats.st_mode)){
				dbg("Parsing file %s",config_file);
				yyin = fopen(config_file, "r");

				if (yyin == NULL) {
					dbg("Can not open config file:" 
				 	       " %d.\n", errno);
				}
				yyparse();
				dbg("Done.");
				fclose(yyin);
			}
		}
	}
	dbg("Parsing configuration directories done... ");

}

/*===========================================================================*
 *           cleanup                                                        *
 *===========================================================================*/
static void cleanup() {
	struct devmand_driver_instance *inst;
	/* destroy fifo */
	dbg("cleaning up... ");
	/* quit all running drivers */
	LIST_FOREACH(inst, &instances, list) {
		dbg("stopping driver %s", inst->label);
		if(inst->drv->downscript) {
			run_downscript (inst);
		}
		stop_driver(inst);
	}
	unlink("/var/run/devmand.pid");
}

static void sig_int(int sig) {
	dbg("devman: Received SIGINT... cleaning up.");
	_run = 0;
}

/*===========================================================================*
 *           create_pid_file                                                 *
 *===========================================================================*/
void create_pid_file()
{
	FILE *fd;

	fd = fopen("/var/run/devmand.pid", "r");
	if(fd) {
		fprintf(stderr, "devmand: /var/run/devmand.pid exists... "
		                "another devmand running?\n");
		fclose(fd);
		exit(1);
	} else {
		fd = fopen("/var/run/devmand.pid","w");
		fprintf(fd, "%d", getpid());
		fclose(fd);
	}
}

/*===========================================================================*
 *           main                                                            *
 *===========================================================================*/
int main(int argc, char *argv[])
{
	int opt, optindex;
	struct devmand_usb_driver *driver;


	/* get command line arguments */
	while ((opt = getopt_long(argc, argv, "d:p:vxh?", options, &optindex))
			!= -1) {
		switch (opt) {
			case 'd':/* config directory */
				if (args.config_dir_count >= MAX_CONFIG_DIRS){
				 	fprintf(stderr,"Parse arguments: Maximum" 
					        " of %i configuration directories"
						" reached skipping directory '%s'\n" 
						, MAX_CONFIG_DIRS, optarg);
				 	break;
				}
				args.config_dirs[args.config_dir_count] = optarg;
				args.config_dir_count++;
				break;
			case 'p': /* sysfs path */
				args.path = optarg;
				break;
			case 'v': /* verbose */
				args.verbose = 1;
				break;
			case 'x': /* check config */
				args.check_config = 1;
				break;
			case 'h': /* help */
			case '?': /* help */
			default:
				display_usage(argv[0]);
				return 0;
		}
	}


	/* is path set? */
	if (args.path == NULL) {
		args.path = "/sys/";
	}

	/* is the configuration directory set? */
	if (args.config_dir_count == 0) {
		dbg("Using default configuration directory");
		args.config_dirs[0] = "/etc/devmand";
		args.config_dir_count = 1;
	}

	/* If we only check the configuration run and exit imediately */
	if (args.check_config == 1){
		fprintf(stdout, "Only parsing configuration\n");
		parse_config();
		exit(0);
	}

	create_pid_file();

	parse_config();
	LIST_FOREACH(driver, &drivers, list) {
		if (driver->upscript) {
			run_cleanscript(driver);
		}
	}

	signal(SIGINT, sig_int);

	main_loop();

	cleanup();

	return 0;
}

/*===========================================================================*
 *           determine_type                                                  *
 *===========================================================================*/
static enum dev_type determine_type (char *path)
{
	FILE * fd;
	char *mypath;
	char buf[256];
	int res;

	mypath = (char *) calloc(1, strlen(path)+strlen(DEVMAN_TYPE_NAME)+1);

	if (mypath == NULL) {
		fprintf(stderr, "ERROR: out of mem\n");
		cleanup();
		exit(1);
	}

	strcat(mypath, path);
	strcat(mypath, DEVMAN_TYPE_NAME);

	fd = fopen(mypath, "r");
	free(mypath);

	if (fd == NULL) {
		fprintf(stderr, "WARN: could not open %s\n", mypath);
		return DEV_TYPE_UNKOWN;
	}

	res = fscanf(fd , "%255s\n", buf);
	fclose(fd);

	if (res != 1) {
		fprintf(stderr, "WARN: could not parse %s\n", mypath);
		return DEV_TYPE_UNKOWN;
	}

	if (strcmp(buf, "USB_DEV") == 0) {
		return DEV_TYPE_USB_DEVICE;
	} else if (strcmp(buf, "USB_INTF") == 0) {
		return DEV_TYPE_USB_INTF;
	}

	return  DEV_TYPE_UNKOWN;
}

/*===========================================================================*
 *           read_hex_uint                                                   *
 *===========================================================================*/
static int read_hex_uint(char *base_path, char *name, unsigned int* val )
{
	char my_path[PATH_LEN];
	FILE *fd;
	memset(my_path,0,PATH_LEN);
	int ret = 0;

	strcat(my_path, base_path);
	strcat(my_path, name);

	fd = fopen(my_path, "r");

	if (fd == NULL) {
		fprintf(stderr, "WARN: could not open %s\n", my_path);
		return EEXIST;
	} else	if (fscanf(fd, "0x%x\n", val ) != 1) {
		fprintf(stderr, "WARN: could not parse %s\n", my_path);
		ret = EINVAL;
	}
	fclose(fd);

	return ret;
}

/*===========================================================================*
 *               get_major                                                   *
 *===========================================================================*/
static int get_major() {
	int i, ret = args.major_offset;

	for (i=0; i < 16; i++) {
		int j;
		for (j = 0; j < 8; j++ ) {
			if ((major_bitmap[i] & (1 << j))) {
				major_bitmap[i] &= !(1 << j);
				return ret;
			}
			ret++;
		}
	}
	return INVAL_MAJOR;
}

/*===========================================================================*
 *               put_major                                                   *
 *===========================================================================*/
static void put_major(int major) {
	int i;
	major -= args.major_offset;
	assert(major >= 0);

	for (i=0; i < 16; i++) {
		int j;
		for (j = 0; j < 8; j++ ) {
			if (major==0) {
				assert(!(major_bitmap[i] & (1 <<j)));
				major_bitmap[i] |= (1 << j);
				return;
			}
			major--;
		}
	}
}

/*===========================================================================*
 *          generate_usb_device_id                                           *
 *===========================================================================*/
static struct usb_device_id *
generate_usb_device_id(char * path, int is_interface)
{
	struct usb_device_id *ret;
	int res;
	unsigned int val;

	ret = (struct usb_device_id *)
	    calloc(1,sizeof (struct usb_device_id));

	if (is_interface) {

		res = read_hex_uint(path, "../idVendor", &val);
		if (res) goto err;
		ret->idVendor = val;

		res = read_hex_uint(path, "../idProduct", &val);
		if (res) goto err;
		ret->idProduct = val;
#if 0
		res = read_hex_uint(path, "../bcdDevice", &val);
		if (res) goto err;
		ret->bcdDevice = val;
#endif
		res = read_hex_uint(path, "../bDeviceClass", &val);
		if (res) goto err;
		ret->bDeviceClass = val;

		res = read_hex_uint(path, "../bDeviceSubClass", &val);
		if (res) goto err;
		ret->bDeviceSubClass = val;

		res = read_hex_uint(path, "../bDeviceProtocol", &val);
		if (res) goto err;
		ret->bDeviceProtocol = val;

		res = read_hex_uint(path, "/bInterfaceClass", &val);
		if (res) goto err;
		ret->bInterfaceClass = val;

		res = read_hex_uint(path, "/bInterfaceSubClass", &val);
		if (res) goto err;
		ret->bInterfaceSubClass = val;

		res = read_hex_uint(path, "/bInterfaceProtocol", &val);
		if (res) goto err;
		ret->bInterfaceProtocol = val;
	}

	return ret;

err:
	free(ret);
	return NULL;
}

/*===========================================================================*
 *            usb_intf_add_even                                              *
 *===========================================================================*/
static void usb_intf_add_event(char *path, int dev_id)
{
	struct usb_device_id *id;
	struct devmand_usb_driver *drv;
	struct devmand_driver_instance *drv_inst;
	int major, ret;

	/* generate usb_match_id */
	id = generate_usb_device_id(path,TRUE);
	if (id == NULL) {
		fprintf(stderr, "WARN: could not create usb_device id...\n"
		                "      ommiting event\n");
		free(id);
		return;
	}

	/* find suitable driver */
	drv = match_usb_driver(id);
	free (id);

	if (drv == NULL) {
		dbg("INFO: could not find a suitable driver for %s", path);
		return;
	}

	/* create instance */
	drv_inst = (struct devmand_driver_instance *)
	    calloc(1,sizeof(struct devmand_driver_instance));

	if (drv_inst == NULL) {
		fprintf(stderr, "ERROR: out of memory");
		return; /* maybe better quit here. */
	}


	/* allocate inode number, if device files needed */
	major = get_major();
	if (major == INVAL_MAJOR) {
		fprintf(stderr, "WARN: ran out of major numbers\n"
		                "      cannot start driver %s for %s\n",
							   drv->name, path);
		return;
	}

	drv_inst->major  = major;
	drv_inst->drv    = drv;
	drv_inst->dev_id = dev_id;


	/* start driver (invoke minix-service) */
	start_driver(drv_inst);

	/*
	 * run the up action
	 *
	 * An up action can be any executable. Before running it devmand
	 * will set certain environment variables so the script can configure
	 * the device (or generate device files, etc). See up_action() for that.
	 */
	if (drv->upscript) {
		ret = run_upscript(drv_inst);
		if (ret) {
			stop_driver(drv_inst);
			fprintf(stderr, "devmand: warning, could not run up_action\n");
			free(drv_inst);
			return;
		}
	}

	LIST_INSERT_HEAD(&instances,drv_inst,list);
}

/*===========================================================================*
 *            usb_intf_remove_event                                          *
 *===========================================================================*/
static void usb_intf_remove_event(char *path, int dev_id)
{
	struct devmand_driver_instance *inst;
	struct devmand_usb_driver *drv;
	int ret;

	/* find the driver instance */
	inst = find_instance(dev_id);

	if (inst == NULL) {
		dbg("No driver running for id: %d", dev_id);
		return;
	}
	drv = inst->drv;

	/* run the down script */
	if (drv->downscript) {
		ret = run_downscript(inst);
		if (ret) {
			fprintf(stderr, "WARN: error running up_action");
		}
	}

	/* stop the driver */
	stop_driver(inst);

	/* free major */
	put_major(inst->major);

	/* free instance */
	LIST_REMOVE(inst,list);
	free(inst);
}

/*===========================================================================*
 *           handle_event                                                    *
 *===========================================================================*/
static void handle_event(char *event)
{
	enum dev_type type;
	char path[PATH_LEN];
	char tmp_path[PATH_LEN];
	int dev_id, res;

	path[0]=0;

	if (strncmp("ADD ", event, 4) == 0) {

		/* read data from event */
		res = sscanf(event, "ADD %s 0x%x", tmp_path, &dev_id);

		if (res != 2) {
			fprintf(stderr, "WARN: could not parse event: %s", event);
			fprintf(stderr, "WARN: omitting event: %s", event);
		}

		strcpy(path, args.path);
		strcat(path, tmp_path);

		/* what kind of device is added? */
		type = determine_type(path);

		switch (type) {
			case DEV_TYPE_USB_DEVICE:
				dbg("USB device added: ommited....");
				/* ommit usb devices for now */
				break;
			case DEV_TYPE_USB_INTF:
				dbg("USB interface added: (%s, devid: = %d)",path, dev_id);
				usb_intf_add_event(path, dev_id);
				return;
			default:
				dbg("default");
				fprintf(stderr, "WARN: ommiting event\n");
		}
	} else if (strncmp("REMOVE ", event, 7) == 0) {

		/* read data from event */
		res = sscanf(event,"REMOVE %s 0x%x", tmp_path, &dev_id);

		if (res != 2) {
			fprintf(stderr, "WARN: could not parse event: %s", event);
			fprintf(stderr, "WARN: omitting event: %s", event);
		}

		usb_intf_remove_event(path, dev_id);

#if 0
		strcpy(path, args.path);
		strcat(path, tmp_path);

		/* what kind of device is added? */
		type = determine_type(path);

		switch (type) {
			case DEV_TYPE_USB_DEVICE:
				/* ommit usb devices for now */
				break;
			case DEV_TYPE_USB_INTF:
				usb_intf_remove_event(path, dev_id);
				return;
			default:
				fprintf(stderr, "WARN: ommiting event\n");
		}
#endif

	}
}

/*===========================================================================*
 *           main_loop                                                       *
 *===========================================================================*/
static void main_loop()
{
	char ev_path[128];
	char buf[256];
	int len;
	FILE* fd;
	len = strlen(args.path);

	/* init major numbers */

	memset(&major_bitmap, 0xff, 16);

	if (len > 128 - 7 /*len of "events" */) {
		fprintf(stderr, "pathname to long\n");
		cleanup();
		exit(1);
	}

	strcpy(ev_path, args.path);
	strcat(ev_path, "events");


	while (_run) {

		char *res;

		fd = fopen(ev_path, "r");
		if (fd == NULL) {
			/*
			 * ENFILE is a temporary failure, often caused by
			 * running the test set.  Don't die from that..
			 */
			if (errno == ENFILE) {
				usleep(50000);
				continue;
			}

			fprintf(stderr,"devmand error: could not open event "
				"file %s bailing out\n", ev_path);
			cleanup();
			exit(1);
		}

		res = fgets(buf, 256, fd);
		fclose(fd);

		if (res == NULL) {
			usleep(50000);
			continue;
		}
		dbg("handle_event:  %s", buf);
		handle_event(buf);
	}
}

/*===========================================================================*
 *           display_usage                                                   *
 *===========================================================================*/
static void display_usage(const char *name)
{
	printf("Usage: %s [{-p|--pathname} PATH_TO_SYS}"
	       " [{-d|--config-dir} CONFIG_DIR] [-v|--verbose]" 
	       " [[x||--check-config]\n", name);
}




/* ============================================================================
 * SOURCE 2/98: userspace\commands_legacy\system\devmand\main.c
 * Size: 24,241 bytes, Lines: 943
 * Hash: 00517f73521c...
 * ============================================================================ */

#include <stdio.h>
#include <stdlib.h>
#include <getopt.h>
#include <errno.h>
#include <string.h>
#include <lib.h>
#include <sys/stat.h>
#include <dirent.h>
#include <assert.h>
#include <signal.h>
#include <minix/dmap.h>
#include <minix/paths.h>
#include "usb_driver.h"
#include "proto.h"

#define DEVMAN_TYPE_NAME "dev_type"
#define PATH_LEN 256
#define INVAL_MAJOR -1
#define MAX_CONFIG_DIRS 4

static void main_loop();
static void handle_event();
static void cleanup();
static void parse_config();
static void display_usage();
static enum dev_type determine_type(char *path);
static int get_major();
static void create_pid_file();
static void put_major(int major);
static struct devmand_usb_driver* match_usb_driver(struct usb_device_id *id);
static struct devmand_driver_instance *find_instance(int dev_id);

#define dbg(fmt, ... ) \
	if (args.verbose) \
	printf("%8s:%4d: %13s()| "fmt"\n", __FILE__, __LINE__, __func__,  ##__VA_ARGS__ )

static LIST_HEAD(usb_driver_head, devmand_usb_driver) drivers =
    LIST_HEAD_INITIALIZER(drivers);
static LIST_HEAD(usb_driver_inst_head, devmand_driver_instance) instances =
    LIST_HEAD_INITIALIZER(instances);


static int _run = 1;
struct global_args {
	char *path;
	char *config_dirs[MAX_CONFIG_DIRS];
	int config_dir_count ;
	int major_offset;
	int verbose;
	int check_config;
};

enum dev_type {
	DEV_TYPE_USB_DEVICE,
	DEV_TYPE_USB_INTF,
	DEV_TYPE_UNKOWN
};

extern FILE *yyin;

static struct global_args args = {
	.path = NULL,
	.config_dirs = {NULL,NULL,NULL,NULL},
	.config_dir_count = 0,
	.major_offset = USB_BASE_MAJOR,
	.verbose = 0,
	.check_config = 0};

static struct option options[] =
{
	{"dir"   ,    required_argument, NULL, 'd'},
	{"path",      required_argument, NULL, 'p'},
	{"verbose",    required_argument, NULL, 'v'},
	{"check-config", no_argument,       NULL, 'x'},
	{0,0,0,0} /* terminating entry */
};

static char major_bitmap[16]; /* can store up to 128 major number states */


/*===========================================================================*
 *             run_upscript                                                  *
 *===========================================================================*/
int run_upscript(struct devmand_driver_instance *inst)
{
	char cmdl[1024];
	cmdl[0] = 0;
	int ret;

	assert(inst->drv->upscript);
	assert(inst->label);

	snprintf(cmdl, 1024, "%s up %s %d %d",
	    inst->drv->upscript, inst->label, inst->major, inst->dev_id);
	dbg("Running Upscript:  \"%s\"", cmdl);
	ret = system(cmdl);
	if (ret != 0) {
		return EINVAL;
	}
	return 0;
}

/*===========================================================================*
 *             run_cleanscript                                               *
 *===========================================================================*/
int run_cleanscript(struct devmand_usb_driver *drv)
{
	char cmdl[1024];
	cmdl[0] = 0;
	int ret;

	assert(drv->upscript);
	assert(drv->devprefix);

	snprintf(cmdl, 1024, "%s clean %s ",
		drv->upscript, drv->devprefix);
	dbg("Running Upscript:  \"%s\"", cmdl);
	ret = system(cmdl);

	if (ret != 0) {
		return EINVAL;
	}

	return 0;
}


/*===========================================================================*
 *             run_downscript                                                *
 *===========================================================================*/
int run_downscript(struct devmand_driver_instance *inst)
{
	char cmdl[1024];
	cmdl[0] = 0;
	int ret;

	assert(inst->drv->downscript);
	assert(inst->label);

	snprintf(cmdl, 1024, "%s down %s %d",
	    inst->drv->downscript, inst->label, inst->major);

	dbg("Running Upscript:  \"%s\"", cmdl);

	ret = system(cmdl);

	if (ret != 0) {
		return EINVAL;
	}

	return 0;
}


/*===========================================================================*
 *             stop_driver                                                   *
 *===========================================================================*/
int stop_driver(struct devmand_driver_instance *inst)
{
	char cmdl[1024];
	cmdl[0] = 0;
	int ret;

	assert(inst->label);

	snprintf(cmdl, 1024, "%s down %s %d",
	    _PATH_MINIX_SERVICE, inst->label, inst->dev_id);
	dbg("executing minix-service: \"%s\"", cmdl);
	ret = system(cmdl);
	if (ret != 0)
	{
		return EINVAL;
	}
	printf("Stopped driver %s with label %s for device %d.\n",
		inst->drv->binary, inst->label, inst->dev_id);

	return 0;
}


/*===========================================================================*
 *             start_driver                                                  *
 *===========================================================================*/
int start_driver(struct devmand_driver_instance *inst)
{
	char cmdl[1024];
	cmdl[0] = 0;
	int ret;

	/* generate label */
	ret = snprintf(inst->label, 32,  "%s%d", inst->drv->devprefix,
		inst->dev_id);
	if (ret < 0 || ret > DEVMAND_DRIVER_LABEL_LEN) {
		dbg("label too long");
		return ENOMEM;
	}

	assert(inst->drv->binary);
	assert(inst->label);

	snprintf(cmdl, 1024, "%s up %s  -major %d -devid %d -label %s",
	    _PATH_MINIX_SERVICE, inst->drv->binary, inst->major, inst->dev_id,
		inst->label);
	dbg("executing minix-service: \"%s\"", cmdl);

	ret = system(cmdl);

	if (ret != 0) {
		return EINVAL;
	}

	printf("Started driver %s with label %s for device %d.\n",
		inst->drv->binary, inst->label, inst->dev_id);

	return 0;
}

/*===========================================================================*
 *             find_instance                                                 *
 *===========================================================================*/
static struct devmand_driver_instance *
find_instance(int dev_id)
{
	struct devmand_driver_instance *inst;

	LIST_FOREACH(inst, &instances, list) {
		if (inst->dev_id == dev_id) {
			return inst;
		}
	}
	return NULL;
}

/*===========================================================================*
 *              match_usb_driver                                             *
 *===========================================================================*/
static int
match_usb_id(struct devmand_usb_match_id *mid, struct usb_device_id *id)
{
	int res = 1;
	unsigned long match = mid->match_flags;
	struct usb_device_id *_id = &mid->match_id;

	if (match & USB_MATCH_ID_VENDOR)
		if (id->idVendor != _id->idVendor) res = 0;
	if (match & USB_MATCH_ID_PRODUCT)
		if (id->idProduct != _id->idProduct) res = 0;
	if (match & USB_MATCH_BCD_DEVICE)
		if (id->bcdDevice != _id->bcdDevice) res = 0;
	if (match & USB_MATCH_DEVICE_PROTOCOL)
		if (id->bDeviceProtocol != _id->bDeviceProtocol) res = 0;
	if (match & USB_MATCH_DEVICE_SUBCLASS)
		if (id->bDeviceSubClass != _id->bDeviceSubClass) res = 0;
	if (match & USB_MATCH_DEVICE_PROTOCOL)
		if (id->bDeviceProtocol != _id->bDeviceProtocol) res = 0;
	if (match & USB_MATCH_INTERFACE_CLASS)
		if (id->bInterfaceClass != _id->bInterfaceClass) res = 0;
	if (match & USB_MATCH_INTERFACE_SUBCLASS)
		if (id->bInterfaceSubClass != _id->bInterfaceSubClass) res = 0;
	if (match & USB_MATCH_INTERFACE_PROTOCOL)
		if (id->bInterfaceProtocol != _id->bInterfaceProtocol) res = 0;

	if (match == 0UL) {
		res = 0;
	}

	return res;
}

/*===========================================================================*
 *              match_usb_driver                                             *
 *===========================================================================*/
static struct devmand_usb_driver*
match_usb_driver(struct usb_device_id *id)
{
	struct devmand_usb_driver *driver;
	struct devmand_usb_match_id *mid;

	LIST_FOREACH(driver, &drivers, list) {
		LIST_FOREACH(mid, &driver->ids, list) {
			if (match_usb_id(mid, id)) {
				return driver;
			}
		}
	}
	return NULL;
}

/*===========================================================================*
 *              add_usb_match_id                                             *
 *===========================================================================*/
struct devmand_usb_driver * add_usb_driver(char *name)
{
	struct devmand_usb_driver *udrv = (struct devmand_usb_driver*)
	    malloc(sizeof(struct devmand_usb_driver));

	LIST_INSERT_HEAD(&drivers, udrv, list);
	LIST_INIT(&udrv->ids);

	udrv->name = name;
	return udrv;
}

/*===========================================================================*
 *              add_usb_match_id                                             *
 *===========================================================================*/
struct devmand_usb_match_id *
add_usb_match_id
(struct devmand_usb_driver *drv)
{
	struct devmand_usb_match_id *id = (struct devmand_usb_match_id*)
	    malloc(sizeof(struct devmand_usb_match_id));

	memset(id, 0, sizeof(struct devmand_usb_match_id));

	LIST_INSERT_HEAD(&drv->ids, id, list);

	return id;
}


/*===========================================================================*
 *           parse_config                                                    *
 *===========================================================================*/
static void parse_config()
{
	int i, status, error;
	struct stat stats;
	char * dirname;

	DIR * dir;
	struct dirent entry;
	struct dirent *result;
	char config_file[PATH_MAX];

	dbg("Parsing configuration directories... ");
	/* Next parse the configuration directories */
	for(i=0; i < args.config_dir_count; i++){
		dirname = args.config_dirs[i];
		dbg("Parsing config dir %s ", dirname);
		status = stat(dirname,&stats);
		if (status == -1){
			error = errno;
			dbg("Failed to read directory '%s':%s (skipping) \n", 
			    dirname,strerror(error));
			continue;
		}
		if (!S_ISDIR(stats.st_mode)){
			dbg("Parse configuration skipping %s "
			    "(not a directory) \n",dirname);
			continue;
		}
		dir = opendir(dirname);
		if (dir == NULL){
			error = errno;
			dbg("Parse configuration failed to read dir '%s'"
			    "(skipping) :%s\n",dirname, strerror(error));
			continue;
		}
		while( (status = readdir_r(dir,&entry,&result)) == 0 ){
			if (result == NULL){ /* last entry */ 
				closedir(dir);
				break;
			}

			/* concatenate dir and file name to open it */
			snprintf(config_file,PATH_MAX, "%s/%s",
				 dirname,entry.d_name);
			status = stat(config_file, &stats);
			if (status == -1){ 
				error = errno;
				dbg("Parse configuration Failed to stat file "
				    "'%s': %s (skipping)\n", config_file,
				    strerror(error));
			}
			if (S_ISREG(stats.st_mode)){
				dbg("Parsing file %s",config_file);
				yyin = fopen(config_file, "r");

				if (yyin == NULL) {
					dbg("Can not open config file:" 
				 	       " %d.\n", errno);
				}
				yyparse();
				dbg("Done.");
				fclose(yyin);
			}
		}
	}
	dbg("Parsing configuration directories done... ");

}

/*===========================================================================*
 *           cleanup                                                        *
 *===========================================================================*/
static void cleanup() {
	struct devmand_driver_instance *inst;
	/* destroy fifo */
	dbg("cleaning up... ");
	/* quit all running drivers */
	LIST_FOREACH(inst, &instances, list) {
		dbg("stopping driver %s", inst->label);
		if(inst->drv->downscript) {
			run_downscript (inst);
		}
		stop_driver(inst);
	}
	unlink("/var/run/devmand.pid");
}

static void sig_int(int sig) {
	dbg("devman: Received SIGINT... cleaning up.");
	_run = 0;
}

/*===========================================================================*
 *           create_pid_file                                                 *
 *===========================================================================*/
void create_pid_file()
{
	FILE *fd;

	fd = fopen("/var/run/devmand.pid", "r");
	if(fd) {
		fprintf(stderr, "devmand: /var/run/devmand.pid exists... "
		                "another devmand running?\n");
		fclose(fd);
		exit(1);
	} else {
		fd = fopen("/var/run/devmand.pid","w");
		fprintf(fd, "%d", getpid());
		fclose(fd);
	}
}

/*===========================================================================*
 *           main                                                            *
 *===========================================================================*/
int main(int argc, char *argv[])
{
	int opt, optindex;
	struct devmand_usb_driver *driver;


	/* get command line arguments */
	while ((opt = getopt_long(argc, argv, "d:p:vxh?", options, &optindex))
			!= -1) {
		switch (opt) {
			case 'd':/* config directory */
				if (args.config_dir_count >= MAX_CONFIG_DIRS){
				 	fprintf(stderr,"Parse arguments: Maximum" 
					        " of %i configuration directories"
						" reached skipping directory '%s'\n" 
						, MAX_CONFIG_DIRS, optarg);
				 	break;
				}
				args.config_dirs[args.config_dir_count] = optarg;
				args.config_dir_count++;
				break;
			case 'p': /* sysfs path */
				args.path = optarg;
				break;
			case 'v': /* verbose */
				args.verbose = 1;
				break;
			case 'x': /* check config */
				args.check_config = 1;
				break;
			case 'h': /* help */
			case '?': /* help */
			default:
				display_usage(argv[0]);
				return 0;
		}
	}


	/* is path set? */
	if (args.path == NULL) {
		args.path = "/sys/";
	}

	/* is the configuration directory set? */
	if (args.config_dir_count == 0) {
		dbg("Using default configuration directory");
		args.config_dirs[0] = "/etc/devmand";
		args.config_dir_count = 1;
	}

	/* If we only check the configuration run and exit imediately */
	if (args.check_config == 1){
		fprintf(stdout, "Only parsing configuration\n");
		parse_config();
		exit(0);
	}

	create_pid_file();

	parse_config();
	LIST_FOREACH(driver, &drivers, list) {
		if (driver->upscript) {
			run_cleanscript(driver);
		}
	}

	signal(SIGINT, sig_int);

	main_loop();

	cleanup();

	return 0;
}

/*===========================================================================*
 *           determine_type                                                  *
 *===========================================================================*/
static enum dev_type determine_type (char *path)
{
	FILE * fd;
	char *mypath;
	char buf[256];
	int res;

	mypath = (char *) calloc(1, strlen(path)+strlen(DEVMAN_TYPE_NAME)+1);

	if (mypath == NULL) {
		fprintf(stderr, "ERROR: out of mem\n");
		cleanup();
		exit(1);
	}

	strcat(mypath, path);
	strcat(mypath, DEVMAN_TYPE_NAME);

	fd = fopen(mypath, "r");
	free(mypath);

	if (fd == NULL) {
		fprintf(stderr, "WARN: could not open %s\n", mypath);
		return DEV_TYPE_UNKOWN;
	}

	res = fscanf(fd , "%255s\n", buf);
	fclose(fd);

	if (res != 1) {
		fprintf(stderr, "WARN: could not parse %s\n", mypath);
		return DEV_TYPE_UNKOWN;
	}

	if (strcmp(buf, "USB_DEV") == 0) {
		return DEV_TYPE_USB_DEVICE;
	} else if (strcmp(buf, "USB_INTF") == 0) {
		return DEV_TYPE_USB_INTF;
	}

	return  DEV_TYPE_UNKOWN;
}

/*===========================================================================*
 *           read_hex_uint                                                   *
 *===========================================================================*/
static int read_hex_uint(char *base_path, char *name, unsigned int* val )
{
	char my_path[PATH_LEN];
	FILE *fd;
	memset(my_path,0,PATH_LEN);
	int ret = 0;

	strcat(my_path, base_path);
	strcat(my_path, name);

	fd = fopen(my_path, "r");

	if (fd == NULL) {
		fprintf(stderr, "WARN: could not open %s\n", my_path);
		return EEXIST;
	} else	if (fscanf(fd, "0x%x\n", val ) != 1) {
		fprintf(stderr, "WARN: could not parse %s\n", my_path);
		ret = EINVAL;
	}
	fclose(fd);

	return ret;
}

/*===========================================================================*
 *               get_major                                                   *
 *===========================================================================*/
static int get_major() {
	int i, ret = args.major_offset;

	for (i=0; i < 16; i++) {
		int j;
		for (j = 0; j < 8; j++ ) {
			if ((major_bitmap[i] & (1 << j))) {
				major_bitmap[i] &= !(1 << j);
				return ret;
			}
			ret++;
		}
	}
	return INVAL_MAJOR;
}

/*===========================================================================*
 *               put_major                                                   *
 *===========================================================================*/
static void put_major(int major) {
	int i;
	major -= args.major_offset;
	assert(major >= 0);

	for (i=0; i < 16; i++) {
		int j;
		for (j = 0; j < 8; j++ ) {
			if (major==0) {
				assert(!(major_bitmap[i] & (1 <<j)));
				major_bitmap[i] |= (1 << j);
				return;
			}
			major--;
		}
	}
}

/*===========================================================================*
 *          generate_usb_device_id                                           *
 *===========================================================================*/
static struct usb_device_id *
generate_usb_device_id(char * path, int is_interface)
{
	struct usb_device_id *ret;
	int res;
	unsigned int val;

	ret = (struct usb_device_id *)
	    calloc(1,sizeof (struct usb_device_id));

	if (is_interface) {

		res = read_hex_uint(path, "../idVendor", &val);
		if (res) goto err;
		ret->idVendor = val;

		res = read_hex_uint(path, "../idProduct", &val);
		if (res) goto err;
		ret->idProduct = val;
#if 0
		res = read_hex_uint(path, "../bcdDevice", &val);
		if (res) goto err;
		ret->bcdDevice = val;
#endif
		res = read_hex_uint(path, "../bDeviceClass", &val);
		if (res) goto err;
		ret->bDeviceClass = val;

		res = read_hex_uint(path, "../bDeviceSubClass", &val);
		if (res) goto err;
		ret->bDeviceSubClass = val;

		res = read_hex_uint(path, "../bDeviceProtocol", &val);
		if (res) goto err;
		ret->bDeviceProtocol = val;

		res = read_hex_uint(path, "/bInterfaceClass", &val);
		if (res) goto err;
		ret->bInterfaceClass = val;

		res = read_hex_uint(path, "/bInterfaceSubClass", &val);
		if (res) goto err;
		ret->bInterfaceSubClass = val;

		res = read_hex_uint(path, "/bInterfaceProtocol", &val);
		if (res) goto err;
		ret->bInterfaceProtocol = val;
	}

	return ret;

err:
	free(ret);
	return NULL;
}

/*===========================================================================*
 *            usb_intf_add_even                                              *
 *===========================================================================*/
static void usb_intf_add_event(char *path, int dev_id)
{
	struct usb_device_id *id;
	struct devmand_usb_driver *drv;
	struct devmand_driver_instance *drv_inst;
	int major, ret;

	/* generate usb_match_id */
	id = generate_usb_device_id(path,TRUE);
	if (id == NULL) {
		fprintf(stderr, "WARN: could not create usb_device id...\n"
		                "      ommiting event\n");
		free(id);
		return;
	}

	/* find suitable driver */
	drv = match_usb_driver(id);
	free (id);

	if (drv == NULL) {
		dbg("INFO: could not find a suitable driver for %s", path);
		return;
	}

	/* create instance */
	drv_inst = (struct devmand_driver_instance *)
	    calloc(1,sizeof(struct devmand_driver_instance));

	if (drv_inst == NULL) {
		fprintf(stderr, "ERROR: out of memory");
		return; /* maybe better quit here. */
	}


	/* allocate inode number, if device files needed */
	major = get_major();
	if (major == INVAL_MAJOR) {
		fprintf(stderr, "WARN: ran out of major numbers\n"
		                "      cannot start driver %s for %s\n",
							   drv->name, path);
		return;
	}

	drv_inst->major  = major;
	drv_inst->drv    = drv;
	drv_inst->dev_id = dev_id;


	/* start driver (invoke minix-service) */
	start_driver(drv_inst);

	/*
	 * run the up action
	 *
	 * An up action can be any executable. Before running it devmand
	 * will set certain environment variables so the script can configure
	 * the device (or generate device files, etc). See up_action() for that.
	 */
	if (drv->upscript) {
		ret = run_upscript(drv_inst);
		if (ret) {
			stop_driver(drv_inst);
			fprintf(stderr, "devmand: warning, could not run up_action\n");
			free(drv_inst);
			return;
		}
	}

	LIST_INSERT_HEAD(&instances,drv_inst,list);
}

/*===========================================================================*
 *            usb_intf_remove_event                                          *
 *===========================================================================*/
static void usb_intf_remove_event(char *path, int dev_id)
{
	struct devmand_driver_instance *inst;
	struct devmand_usb_driver *drv;
	int ret;

	/* find the driver instance */
	inst = find_instance(dev_id);

	if (inst == NULL) {
		dbg("No driver running for id: %d", dev_id);
		return;
	}
	drv = inst->drv;

	/* run the down script */
	if (drv->downscript) {
		ret = run_downscript(inst);
		if (ret) {
			fprintf(stderr, "WARN: error running up_action");
		}
	}

	/* stop the driver */
	stop_driver(inst);

	/* free major */
	put_major(inst->major);

	/* free instance */
	LIST_REMOVE(inst,list);
	free(inst);
}

/*===========================================================================*
 *           handle_event                                                    *
 *===========================================================================*/
static void handle_event(char *event)
{
	enum dev_type type;
	char path[PATH_LEN];
	char tmp_path[PATH_LEN];
	int dev_id, res;

	path[0]=0;

	if (strncmp("ADD ", event, 4) == 0) {

		/* read data from event */
		res = sscanf(event, "ADD %s 0x%x", tmp_path, &dev_id);

		if (res != 2) {
			fprintf(stderr, "WARN: could not parse event: %s", event);
			fprintf(stderr, "WARN: omitting event: %s", event);
		}

		strcpy(path, args.path);
		strcat(path, tmp_path);

		/* what kind of device is added? */
		type = determine_type(path);

		switch (type) {
			case DEV_TYPE_USB_DEVICE:
				dbg("USB device added: ommited....");
				/* ommit usb devices for now */
				break;
			case DEV_TYPE_USB_INTF:
				dbg("USB interface added: (%s, devid: = %d)",path, dev_id);
				usb_intf_add_event(path, dev_id);
				return;
			default:
				dbg("default");
				fprintf(stderr, "WARN: ommiting event\n");
		}
	} else if (strncmp("REMOVE ", event, 7) == 0) {

		/* read data from event */
		res = sscanf(event,"REMOVE %s 0x%x", tmp_path, &dev_id);

		if (res != 2) {
			fprintf(stderr, "WARN: could not parse event: %s", event);
			fprintf(stderr, "WARN: omitting event: %s", event);
		}

		usb_intf_remove_event(path, dev_id);

#if 0
		strcpy(path, args.path);
		strcat(path, tmp_path);

		/* what kind of device is added? */
		type = determine_type(path);

		switch (type) {
			case DEV_TYPE_USB_DEVICE:
				/* ommit usb devices for now */
				break;
			case DEV_TYPE_USB_INTF:
				usb_intf_remove_event(path, dev_id);
				return;
			default:
				fprintf(stderr, "WARN: ommiting event\n");
		}
#endif

	}
}

/*===========================================================================*
 *           main_loop                                                       *
 *===========================================================================*/
static void main_loop()
{
	char ev_path[128];
	char buf[256];
	int len;
	FILE* fd;
	len = strlen(args.path);

	/* init major numbers */

	memset(&major_bitmap, 0xff, 16);

	if (len > 128 - 7 /*len of "events" */) {
		fprintf(stderr, "pathname to long\n");
		cleanup();
		exit(1);
	}

	strcpy(ev_path, args.path);
	strcat(ev_path, "events");


	while (_run) {

		char *res;

		fd = fopen(ev_path, "r");
		if (fd == NULL) {
			/*
			 * ENFILE is a temporary failure, often caused by
			 * running the test set.  Don't die from that..
			 */
			if (errno == ENFILE) {
				usleep(50000);
				continue;
			}

			fprintf(stderr,"devmand error: could not open event "
				"file %s bailing out\n", ev_path);
			cleanup();
			exit(1);
		}

		res = fgets(buf, 256, fd);
		fclose(fd);

		if (res == NULL) {
			usleep(50000);
			continue;
		}
		dbg("handle_event:  %s", buf);
		handle_event(buf);
	}
}

/*===========================================================================*
 *           display_usage                                                   *
 *===========================================================================*/
static void display_usage(const char *name)
{
	printf("Usage: %s [{-p|--pathname} PATH_TO_SYS}"
	       " [{-d|--config-dir} CONFIG_DIR] [-v|--verbose]" 
	       " [[x||--check-config]\n", name);
}




/* ============================================================================
 * SOURCE 3/98: tar\test\main.c
 * Size: 56,430 bytes, Lines: 2,243
 * Hash: 225091636d16...
 * ============================================================================ */

/*
 * Copyright (c) 2003-2009 Tim Kientzle
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "test.h"
#include <errno.h>
#include <locale.h>
#include <stdarg.h>
#include <time.h>

/*
 * This same file is used pretty much verbatim for all test harnesses.
 *
 * The next few lines are the only differences.
 * TODO: Move this into a separate configuration header, have all test
 * suites share one copy of this file.
 */
__FBSDID("$FreeBSD: src/usr.bin/tar/test/main.c,v 1.6 2008/11/05 06:40:53 kientzle Exp $");
#define KNOWNREF	"test_patterns_2.tar.uu"
#define ENVBASE "BSDTAR"  /* Prefix for environment variables. */
#define	PROGRAM "bsdtar"  /* Name of program being tested. */
#undef LIBRARY		  /* Not testing a library. */
#undef	EXTRA_DUMP	     /* How to dump extra data */
/* How to generate extra version info. */
#define	EXTRA_VERSION    (systemf("%s --version", testprog) ? "" : "")

/*
 *
 * Windows support routines
 *
 * Note: Configuration is a tricky issue.  Using HAVE_* feature macros
 * in the test harness is dangerous because they cover up
 * configuration errors.  The classic example of this is omitting a
 * configure check.  If libarchive and libarchive_test both look for
 * the same feature macro, such errors are hard to detect.  Platform
 * macros (e.g., _WIN32 or __GNUC__) are a little better, but can
 * easily lead to very messy code.  It's best to limit yourself
 * to only the most generic programming techniques in the test harness
 * and thus avoid conditionals altogether.  Where that's not possible,
 * try to minimize conditionals by grouping platform-specific tests in
 * one place (e.g., test_acl_freebsd) or by adding new assert()
 * functions (e.g., assertMakeHardlink()) to cover up platform
 * differences.  Platform-specific coding in libarchive_test is often
 * a symptom that some capability is missing from libarchive itself.
 */
#if defined(_WIN32) && !defined(__CYGWIN__)
#include <io.h>
#include <windows.h>
#ifndef F_OK
#define F_OK (0)
#endif
#ifndef S_ISDIR
#define S_ISDIR(m)  ((m) & _S_IFDIR)
#endif
#ifndef S_ISREG
#define S_ISREG(m)  ((m) & _S_IFREG)
#endif
#if !defined(__BORLANDC__)
#define access _access
#undef chdir
#define chdir _chdir
#endif
#ifndef fileno
#define fileno _fileno
#endif
/*#define fstat _fstat64*/
#if !defined(__BORLANDC__)
#define getcwd _getcwd
#endif
#define lstat stat
/*#define lstat _stat64*/
/*#define stat _stat64*/
#define rmdir _rmdir
#if !defined(__BORLANDC__)
#define strdup _strdup
#define umask _umask
#endif
#define int64_t __int64
#endif

#if defined(HAVE__CrtSetReportMode)
# include <crtdbg.h>
#endif

#if defined(_WIN32) && !defined(__CYGWIN__)
void *GetFunctionKernel32(const char *name)
{
	static HINSTANCE lib;
	static int set;
	if (!set) {
		set = 1;
		lib = LoadLibrary("kernel32.dll");
	}
	if (lib == NULL) {
		fprintf(stderr, "Can't load kernel32.dll?!\n");
		exit(1);
	}
	return (void *)GetProcAddress(lib, name);
}

static int
my_CreateSymbolicLinkA(const char *linkname, const char *target, int flags)
{
	static BOOLEAN (WINAPI *f)(LPCSTR, LPCSTR, DWORD);
	static int set;
	if (!set) {
		set = 1;
		f = GetFunctionKernel32("CreateSymbolicLinkA");
	}
	return f == NULL ? 0 : (*f)(linkname, target, flags);
}

static int
my_CreateHardLinkA(const char *linkname, const char *target)
{
	static BOOLEAN (WINAPI *f)(LPCSTR, LPCSTR, LPSECURITY_ATTRIBUTES);
	static int set;
	if (!set) {
		set = 1;
		f = GetFunctionKernel32("CreateHardLinkA");
	}
	return f == NULL ? 0 : (*f)(linkname, target, NULL);
}

int
my_GetFileInformationByName(const char *path, BY_HANDLE_FILE_INFORMATION *bhfi)
{
	HANDLE h;
	int r;

	memset(bhfi, 0, sizeof(*bhfi));
	h = CreateFile(path, FILE_READ_ATTRIBUTES, 0, NULL,
		OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (h == INVALID_HANDLE_VALUE)
		return (0);
	r = GetFileInformationByHandle(h, bhfi);
	CloseHandle(h);
	return (r);
}
#endif

#if defined(HAVE__CrtSetReportMode)
static void
invalid_parameter_handler(const wchar_t * expression,
    const wchar_t * function, const wchar_t * file,
    unsigned int line, uintptr_t pReserved)
{
	/* nop */
}
#endif

/*
 *
 * OPTIONS FLAGS
 *
 */

/* Enable core dump on failure. */
static int dump_on_failure = 0;
/* Default is to remove temp dirs and log data for successful tests. */
static int keep_temp_files = 0;
/* Default is to just report pass/fail for each test. */
static int verbosity = 0;
#define	VERBOSITY_SUMMARY_ONLY -1 /* -q */
#define VERBOSITY_PASSFAIL 0   /* Default */
#define VERBOSITY_LIGHT_REPORT 1 /* -v */
#define VERBOSITY_FULL 2 /* -vv */
/* A few places generate even more output for verbosity > VERBOSITY_FULL,
 * mostly for debugging the test harness itself. */
/* Cumulative count of assertion failures. */
static int failures = 0;
/* Cumulative count of reported skips. */
static int skips = 0;
/* Cumulative count of assertions checked. */
static int assertions = 0;

/* Directory where uuencoded reference files can be found. */
static const char *refdir;

/*
 * Report log information selectively to console and/or disk log.
 */
static int log_console = 0;
static FILE *logfile;
static void
vlogprintf(const char *fmt, va_list ap)
{
#ifdef va_copy
	va_list lfap;
	va_copy(lfap, ap);
#endif
	if (log_console)
		vfprintf(stdout, fmt, ap);
	if (logfile != NULL)
#ifdef va_copy
		vfprintf(logfile, fmt, lfap);
	va_end(lfap);
#else
		vfprintf(logfile, fmt, ap);
#endif
}

static void
logprintf(const char *fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);
	vlogprintf(fmt, ap);
	va_end(ap);
}

/* Set up a message to display only if next assertion fails. */
static char msgbuff[4096];
static const char *msg, *nextmsg;
void
failure(const char *fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);
	vsprintf(msgbuff, fmt, ap);
	va_end(ap);
	nextmsg = msgbuff;
}

/*
 * Copy arguments into file-local variables.
 * This was added to permit vararg assert() functions without needing
 * variadic wrapper macros.  Turns out that the vararg capability is almost
 * never used, so almost all of the vararg assertions can be simplified
 * by removing the vararg capability and reworking the wrapper macro to
 * pass __FILE__, __LINE__ directly into the function instead of using
 * this hook.  I suspect this machinery is used so rarely that we
 * would be better off just removing it entirely.  That would simplify
 * the code here noticably.
 */
static const char *test_filename;
static int test_line;
static void *test_extra;
void assertion_setup(const char *filename, int line)
{
	test_filename = filename;
	test_line = line;
}

/* Called at the beginning of each assert() function. */
static void
assertion_count(const char *file, int line)
{
	(void)file; /* UNUSED */
	(void)line; /* UNUSED */
	++assertions;
	/* Proper handling of "failure()" message. */
	msg = nextmsg;
	nextmsg = NULL;
	/* Uncomment to print file:line after every assertion.
	 * Verbose, but occasionally useful in tracking down crashes. */
	/* printf("Checked %s:%d\n", file, line); */
}

/*
 * For each test source file, we remember how many times each
 * assertion was reported.  Cleared before each new test,
 * used by test_summarize().
 */
static struct line {
	int count;
	int skip;
}  failed_lines[10000];

/* Count this failure, setup up log destination and handle initial report. */
static void
failure_start(const char *filename, int line, const char *fmt, ...)
{
	va_list ap;

	/* Record another failure for this line. */
	++failures;
	/* test_filename = filename; */
	failed_lines[line].count++;

	/* Determine whether to log header to console. */
	switch (verbosity) {
	case VERBOSITY_FULL:
		log_console = 1;
		break;
	case VERBOSITY_LIGHT_REPORT:
		log_console = (failed_lines[line].count < 2);
		break;
	default:
		log_console = 0;
	}

	/* Log file:line header for this failure */
	va_start(ap, fmt);
#if _MSC_VER
	logprintf("%s(%d): ", filename, line);
#else
	logprintf("%s:%d: ", filename, line);
#endif
	vlogprintf(fmt, ap);
	va_end(ap);
	logprintf("\n");

	if (msg != NULL && msg[0] != '\0') {
		logprintf("   Description: %s\n", msg);
		msg = NULL;
	}

	/* Determine whether to log details to console. */
	if (verbosity == VERBOSITY_LIGHT_REPORT)
		log_console = 0;
}

/* Complete reporting of failed tests. */
/*
 * The 'extra' hook here is used by libarchive to include libarchive
 * error messages with assertion failures.  It could also be used
 * to add strerror() output, for example.  Just define the EXTRA_DUMP()
 * macro appropriately.
 */
static void
failure_finish(void *extra)
{
	(void)extra; /* UNUSED (maybe) */
#ifdef EXTRA_DUMP
	if (extra != NULL)
		logprintf("   detail: %s\n", EXTRA_DUMP(extra));
#endif

	if (dump_on_failure) {
		fprintf(stderr,
		    " *** forcing core dump so failure can be debugged ***\n");
		*(char *)(NULL) = 0;
		exit(1);
	}
}

/* Inform user that we're skipping some checks. */
void
test_skipping(const char *fmt, ...)
{
	char buff[1024];
	va_list ap;

	va_start(ap, fmt);
	vsprintf(buff, fmt, ap);
	va_end(ap);
	/* failure_start() isn't quite right, but is awfully convenient. */
	failure_start(test_filename, test_line, "SKIPPING: %s", buff);
	--failures; /* Undo failures++ in failure_start() */
	/* Don't failure_finish() here. */
	/* Mark as skip, so doesn't count as failed test. */
	failed_lines[test_line].skip = 1;
	++skips;
}

/*
 *
 * ASSERTIONS
 *
 */

/* Generic assert() just displays the failed condition. */
int
assertion_assert(const char *file, int line, int value,
    const char *condition, void *extra)
{
	assertion_count(file, line);
	if (!value) {
		failure_start(file, line, "Assertion failed: %s", condition);
		failure_finish(extra);
	}
	return (value);
}

/* chdir() and report any errors */
int
assertion_chdir(const char *file, int line, const char *pathname)
{
	assertion_count(file, line);
	if (chdir(pathname) == 0)
		return (1);
	failure_start(file, line, "chdir(\"%s\")", pathname);
	failure_finish(NULL);
	return (0);

}

/* Verify two integers are equal. */
int
assertion_equal_int(const char *file, int line,
    long long v1, const char *e1, long long v2, const char *e2, void *extra)
{
	assertion_count(file, line);
	if (v1 == v2)
		return (1);
	failure_start(file, line, "%s != %s", e1, e2);
	logprintf("      %s=%lld (0x%llx, 0%llo)\n", e1, v1, v1, v1);
	logprintf("      %s=%lld (0x%llx, 0%llo)\n", e2, v2, v2, v2);
	failure_finish(extra);
	return (0);
}

static void strdump(const char *e, const char *p)
{
	const char *q = p;

	logprintf("      %s = ", e);
	if (p == NULL) {
		logprintf("NULL");
		return;
	}
	logprintf("\"");
	while (*p != '\0') {
		unsigned int c = 0xff & *p++;
		switch (c) {
		case '\a': printf("\a"); break;
		case '\b': printf("\b"); break;
		case '\n': printf("\n"); break;
		case '\r': printf("\r"); break;
		default:
			if (c >= 32 && c < 127)
				logprintf("%c", c);
			else
				logprintf("\\x%02X", c);
		}
	}
	logprintf("\"");
	logprintf(" (length %d)\n", q == NULL ? -1 : (int)strlen(q));
}

/* Verify two strings are equal, dump them if not. */
int
assertion_equal_string(const char *file, int line,
    const char *v1, const char *e1,
    const char *v2, const char *e2,
    void *extra)
{
	assertion_count(file, line);
	if (v1 == v2 || (v1 != NULL && v2 != NULL && strcmp(v1, v2) == 0))
		return (1);
	failure_start(file, line, "%s != %s", e1, e2);
	strdump(e1, v1);
	strdump(e2, v2);
	failure_finish(extra);
	return (0);
}

static void
wcsdump(const char *e, const wchar_t *w)
{
	logprintf("      %s = ", e);
	if (w == NULL) {
		logprintf("(null)");
		return;
	}
	logprintf("\"");
	while (*w != L'\0') {
		unsigned int c = *w++;
		if (c >= 32 && c < 127)
			logprintf("%c", c);
		else if (c < 256)
			logprintf("\\x%02X", c);
		else if (c < 0x10000)
			logprintf("\\u%04X", c);
		else
			logprintf("\\U%08X", c);
	}
	logprintf("\"\n");
}

#ifndef HAVE_WCSCMP
static int
wcscmp(const wchar_t *s1, const wchar_t *s2)
{

	while (*s1 == *s2++) {
		if (*s1++ == L'\0')
			return 0;
	}
	if (*s1 > *--s2)
		return 1;
	else
		return -1;
}
#endif

/* Verify that two wide strings are equal, dump them if not. */
int
assertion_equal_wstring(const char *file, int line,
    const wchar_t *v1, const char *e1,
    const wchar_t *v2, const char *e2,
    void *extra)
{
	assertion_count(file, line);
	if (v1 == v2 || wcscmp(v1, v2) == 0)
		return (1);
	failure_start(file, line, "%s != %s", e1, e2);
	wcsdump(e1, v1);
	wcsdump(e2, v2);
	failure_finish(extra);
	return (0);
}

/*
 * Pretty standard hexdump routine.  As a bonus, if ref != NULL, then
 * any bytes in p that differ from ref will be highlighted with '_'
 * before and after the hex value.
 */
static void
hexdump(const char *p, const char *ref, size_t l, size_t offset)
{
	size_t i, j;
	char sep;

	if (p == NULL) {
		logprintf("(null)\n");
		return;
	}
	for(i=0; i < l; i+=16) {
		logprintf("%04x", (unsigned)(i + offset));
		sep = ' ';
		for (j = 0; j < 16 && i + j < l; j++) {
			if (ref != NULL && p[i + j] != ref[i + j])
				sep = '_';
			logprintf("%c%02x", sep, 0xff & (int)p[i+j]);
			if (ref != NULL && p[i + j] == ref[i + j])
				sep = ' ';
		}
		for (; j < 16; j++) {
			logprintf("%c  ", sep);
			sep = ' ';
		}
		logprintf("%c", sep);
		for (j=0; j < 16 && i + j < l; j++) {
			int c = p[i + j];
			if (c >= ' ' && c <= 126)
				logprintf("%c", c);
			else
				logprintf(".");
		}
		logprintf("\n");
	}
}

/* Verify that two blocks of memory are the same, display the first
 * block of differences if they're not. */
int
assertion_equal_mem(const char *file, int line,
    const void *_v1, const char *e1,
    const void *_v2, const char *e2,
    size_t l, const char *ld, void *extra)
{
	const char *v1 = (const char *)_v1;
	const char *v2 = (const char *)_v2;
	size_t offset;

	assertion_count(file, line);
	if (v1 == v2 || (v1 != NULL && v2 != NULL && memcmp(v1, v2, l) == 0))
		return (1);

	failure_start(file, line, "%s != %s", e1, e2);
	logprintf("      size %s = %d\n", ld, (int)l);
	/* Dump 48 bytes (3 lines) so that the first difference is
	 * in the second line. */
	offset = 0;
	while (l > 64 && memcmp(v1, v2, 32) == 0) {
		/* Two lines agree, so step forward one line. */
		v1 += 16;
		v2 += 16;
		l -= 16;
		offset += 16;
	}
	logprintf("      Dump of %s\n", e1);
	hexdump(v1, v2, l < 64 ? l : 64, offset);
	logprintf("      Dump of %s\n", e2);
	hexdump(v2, v1, l < 64 ? l : 64, offset);
	logprintf("\n");
	failure_finish(extra);
	return (0);
}

/* Verify that the named file exists and is empty. */
int
assertion_empty_file(const char *f1fmt, ...)
{
	char buff[1024];
	char f1[1024];
	struct stat st;
	va_list ap;
	ssize_t s;
	FILE *f;

	assertion_count(test_filename, test_line);
	va_start(ap, f1fmt);
	vsprintf(f1, f1fmt, ap);
	va_end(ap);

	if (stat(f1, &st) != 0) {
		failure_start(test_filename, test_line, "Stat failed: %s", f1);
		failure_finish(NULL);
		return (0);
	}
	if (st.st_size == 0)
		return (1);

	failure_start(test_filename, test_line, "File should be empty: %s", f1);
	logprintf("    File size: %d\n", (int)st.st_size);
	logprintf("    Contents:\n");
	f = fopen(f1, "rb");
	if (f == NULL) {
		logprintf("    Unable to open %s\n", f1);
	} else {
		s = ((off_t)sizeof(buff) < st.st_size) ?
		    (ssize_t)sizeof(buff) : (ssize_t)st.st_size;
		s = fread(buff, 1, s, f);
		hexdump(buff, NULL, s, 0);
		fclose(f);
	}
	failure_finish(NULL);
	return (0);
}

/* Verify that the named file exists and is not empty. */
int
assertion_non_empty_file(const char *f1fmt, ...)
{
	char f1[1024];
	struct stat st;
	va_list ap;

	assertion_count(test_filename, test_line);
	va_start(ap, f1fmt);
	vsprintf(f1, f1fmt, ap);
	va_end(ap);

	if (stat(f1, &st) != 0) {
		failure_start(test_filename, test_line, "Stat failed: %s", f1);
		failure_finish(NULL);
		return (0);
	}
	if (st.st_size == 0) {
		failure_start(test_filename, test_line, "File empty: %s", f1);
		failure_finish(NULL);
		return (0);
	}
	return (1);
}

/* Verify that two files have the same contents. */
/* TODO: hexdump the first bytes that actually differ. */
int
assertion_equal_file(const char *fn1, const char *f2pattern, ...)
{
	char fn2[1024];
	va_list ap;
	char buff1[1024];
	char buff2[1024];
	FILE *f1, *f2;
	int n1, n2;

	assertion_count(test_filename, test_line);
	va_start(ap, f2pattern);
	vsprintf(fn2, f2pattern, ap);
	va_end(ap);

	f1 = fopen(fn1, "rb");
	f2 = fopen(fn2, "rb");
	for (;;) {
		n1 = fread(buff1, 1, sizeof(buff1), f1);
		n2 = fread(buff2, 1, sizeof(buff2), f2);
		if (n1 != n2)
			break;
		if (n1 == 0 && n2 == 0) {
			fclose(f1);
			fclose(f2);
			return (1);
		}
		if (memcmp(buff1, buff2, n1) != 0)
			break;
	}
	fclose(f1);
	fclose(f2);
	failure_start(test_filename, test_line, "Files not identical");
	logprintf("  file1=\"%s\"\n", fn1);
	logprintf("  file2=\"%s\"\n", fn2);
	failure_finish(test_extra);
	return (0);
}

/* Verify that the named file does exist. */
int
assertion_file_exists(const char *fpattern, ...)
{
	char f[1024];
	va_list ap;

	assertion_count(test_filename, test_line);
	va_start(ap, fpattern);
	vsprintf(f, fpattern, ap);
	va_end(ap);

#if defined(_WIN32) && !defined(__CYGWIN__)
	if (!_access(f, 0))
		return (1);
#else
	if (!access(f, F_OK))
		return (1);
#endif
	failure_start(test_filename, test_line, "File should exist: %s", f);
	failure_finish(test_extra);
	return (0);
}

/* Verify that the named file doesn't exist. */
int
assertion_file_not_exists(const char *fpattern, ...)
{
	char f[1024];
	va_list ap;

	assertion_count(test_filename, test_line);
	va_start(ap, fpattern);
	vsprintf(f, fpattern, ap);
	va_end(ap);

#if defined(_WIN32) && !defined(__CYGWIN__)
	if (_access(f, 0))
		return (1);
#else
	if (access(f, F_OK))
		return (1);
#endif
	failure_start(test_filename, test_line, "File should not exist: %s", f);
	failure_finish(test_extra);
	return (0);
}

/* Compare the contents of a file to a block of memory. */
int
assertion_file_contents(const void *buff, int s, const char *fpattern, ...)
{
	char fn[1024];
	va_list ap;
	char *contents;
	FILE *f;
	int n;

	assertion_count(test_filename, test_line);
	va_start(ap, fpattern);
	vsprintf(fn, fpattern, ap);
	va_end(ap);

	f = fopen(fn, "rb");
	if (f == NULL) {
		failure_start(test_filename, test_line,
		    "File should exist: %s", fn);
		failure_finish(test_extra);
		return (0);
	}
	contents = malloc(s * 2);
	n = fread(contents, 1, s * 2, f);
	fclose(f);
	if (n == s && memcmp(buff, contents, s) == 0) {
		free(contents);
		return (1);
	}
	failure_start(test_filename, test_line, "File contents don't match");
	logprintf("  file=\"%s\"\n", fn);
	if (n > 0)
		hexdump(contents, buff, n > 512 ? 512 : n, 0);
	else {
		logprintf("  File empty, contents should be:\n");
		hexdump(buff, NULL, s > 512 ? 512 : s, 0);
	}
	failure_finish(test_extra);
	free(contents);
	return (0);
}

/* Check the contents of a text file, being tolerant of line endings. */
int
assertion_text_file_contents(const char *buff, const char *fn)
{
	char *contents;
	const char *btxt, *ftxt;
	FILE *f;
	int n, s;

	assertion_count(test_filename, test_line);
	f = fopen(fn, "r");
	s = strlen(buff);
	contents = malloc(s * 2 + 128);
	n = fread(contents, 1, s * 2 + 128 - 1, f);
	if (n >= 0)
		contents[n] = '\0';
	fclose(f);
	/* Compare texts. */
	btxt = buff;
	ftxt = (const char *)contents;
	while (*btxt != '\0' && *ftxt != '\0') {
		if (*btxt == *ftxt) {
			++btxt;
			++ftxt;
			continue;
		}
		if (btxt[0] == '\n' && ftxt[0] == '\r' && ftxt[1] == '\n') {
			/* Pass over different new line characters. */
			++btxt;
			ftxt += 2;
			continue;
		}
		break;
	}
	if (*btxt == '\0' && *ftxt == '\0') {
		free(contents);
		return (1);
	}
	failure_start(test_filename, test_line, "Contents don't match");
	logprintf("  file=\"%s\"\n", fn);
	if (n > 0)
		hexdump(contents, buff, n, 0);
	else {
		logprintf("  File empty, contents should be:\n");
		hexdump(buff, NULL, s, 0);
	}
	failure_finish(test_extra);
	free(contents);
	return (0);
}

/* Verify that a text file contains the specified lines, regardless of order */
/* This could be more efficient if we sorted both sets of lines, etc, but
 * since this is used only for testing and only ever deals with a dozen or so
 * lines at a time, this relatively crude approach is just fine. */
int
assertion_file_contains_lines_any_order(const char *file, int line,
    const char *pathname, const char *lines[])
{
	char *buff;
	size_t buff_size;
	size_t expected_count, actual_count, i, j;
	char **expected;
	char *p, **actual;
	char c;
	int expected_failure = 0, actual_failure = 0;

	assertion_count(file, line);

	buff = slurpfile(&buff_size, "%s", pathname);
	if (buff == NULL) {
		failure_start(pathname, line, "Can't read file: %s", pathname);
		failure_finish(NULL);
		return (0);
	}

	// Make a copy of the provided lines and count up the expected file size.
	expected_count = 0;
	for (i = 0; lines[i] != NULL; ++i) {
	}
	expected_count = i;
	expected = malloc(sizeof(char *) * expected_count);
	for (i = 0; lines[i] != NULL; ++i) {
		expected[i] = strdup(lines[i]);
	}

	// Break the file into lines
	actual_count = 0;
	for (c = '\0', p = buff; p < buff + buff_size; ++p) {
		if (*p == '\x0d' || *p == '\x0a')
			*p = '\0';
		if (c == '\0' && *p != '\0')
			++actual_count;
		c = *p;
	}
	actual = malloc(sizeof(char *) * actual_count);
	for (j = 0, p = buff; p < buff + buff_size; p += 1 + strlen(p)) {
		if (*p != '\0') {
			actual[j] = p;
			++j;
		}
	}

	// Erase matching lines from both lists
	for (i = 0; i < expected_count; ++i) {
		if (expected[i] == NULL)
			continue;
		for (j = 0; j < actual_count; ++j) {
			if (actual[j] == NULL)
				continue;
			if (strcmp(expected[i], actual[j]) == 0) {
				free(expected[i]);
				expected[i] = NULL;
				actual[j] = NULL;
				break;
			}
		}
	}

	// If there's anything left, it's a failure
	for (i = 0; i < expected_count; ++i) {
		if (expected[i] != NULL)
			++expected_failure;
	}
	for (j = 0; j < actual_count; ++j) {
		if (actual[j] != NULL)
			++actual_failure;
	}
	if (expected_failure == 0 && actual_failure == 0) {
		free(buff);
		free(expected);
		free(actual);
		return (1);
	}
	failure_start(file, line, "File doesn't match: %s", pathname);
	for (i = 0; i < expected_count; ++i) {
		if (expected[i] != NULL) {
			logprintf("  Expected but not present: %s\n", expected[i]);
			free(expected[i]);
		}
	}
	for (j = 0; j < actual_count; ++j) {
		if (actual[j] != NULL)
			logprintf("  Present but not expected: %s\n", actual[j]);
	}
	failure_finish(NULL);
	free(buff);
	free(expected);
	free(actual);
	return (0);
}

/* Test that two paths point to the same file. */
/* As a side-effect, asserts that both files exist. */
static int
is_hardlink(const char *file, int line,
    const char *path1, const char *path2)
{
#if defined(_WIN32) && !defined(__CYGWIN__)
	BY_HANDLE_FILE_INFORMATION bhfi1, bhfi2;
	int r;

	assertion_count(file, line);
	r = my_GetFileInformationByName(path1, &bhfi1);
	if (r == 0) {
		failure_start(file, line, "File %s can't be inspected?", path1);
		failure_finish(NULL);
		return (0);
	}
	r = my_GetFileInformationByName(path2, &bhfi2);
	if (r == 0) {
		failure_start(file, line, "File %s can't be inspected?", path2);
		failure_finish(NULL);
		return (0);
	}
	return (bhfi1.dwVolumeSerialNumber == bhfi2.dwVolumeSerialNumber
		&& bhfi1.nFileIndexHigh == bhfi2.nFileIndexHigh
		&& bhfi1.nFileIndexLow == bhfi2.nFileIndexLow);
#else
	struct stat st1, st2;
	int r;

	assertion_count(file, line);
	r = lstat(path1, &st1);
	if (r != 0) {
		failure_start(file, line, "File should exist: %s", path1);
		failure_finish(NULL);
		return (0);
	}
	r = lstat(path2, &st2);
	if (r != 0) {
		failure_start(file, line, "File should exist: %s", path2);
		failure_finish(NULL);
		return (0);
	}
	return (st1.st_ino == st2.st_ino && st1.st_dev == st2.st_dev);
#endif
}

int
assertion_is_hardlink(const char *file, int line,
    const char *path1, const char *path2)
{
	if (is_hardlink(file, line, path1, path2))
		return (1);
	failure_start(file, line,
	    "Files %s and %s are not hardlinked", path1, path2);
	failure_finish(NULL);
	return (0);
}

int
assertion_is_not_hardlink(const char *file, int line,
    const char *path1, const char *path2)
{
	if (!is_hardlink(file, line, path1, path2))
		return (1);
	failure_start(file, line,
	    "Files %s and %s should not be hardlinked", path1, path2);
	failure_finish(NULL);
	return (0);
}

/* Verify a/b/mtime of 'pathname'. */
/* If 'recent', verify that it's within last 10 seconds. */
static int
assertion_file_time(const char *file, int line,
    const char *pathname, long t, long nsec, char type, int recent)
{
	long long filet, filet_nsec;
	int r;

#if defined(_WIN32) && !defined(__CYGWIN__)
#define EPOC_TIME	(116444736000000000ULL)
	FILETIME ftime, fbirthtime, fatime, fmtime;
	ULARGE_INTEGER wintm;
	HANDLE h;
	ftime.dwLowDateTime = 0;
	ftime.dwHighDateTime = 0;

	assertion_count(file, line);
	h = CreateFile(pathname, FILE_READ_ATTRIBUTES, 0, NULL,
	    OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (h == INVALID_HANDLE_VALUE) {
		failure_start(file, line, "Can't access %s\n", pathname);
		failure_finish(NULL);
		return (0);
	}
	r = GetFileTime(h, &fbirthtime, &fatime, &fmtime);
	switch (type) {
	case 'a': ftime = fatime; break;
	case 'b': ftime = fbirthtime; break;
	case 'm': ftime = fmtime; break;
	}
	CloseHandle(h);
	if (r == 0) {
		failure_start(file, line, "Can't GetFileTime %s\n", pathname);
		failure_finish(NULL);
		return (0);
	}
	wintm.LowPart = ftime.dwLowDateTime;
	wintm.HighPart = ftime.dwHighDateTime;
	filet = (wintm.QuadPart - EPOC_TIME) / 10000000;
	filet_nsec = ((wintm.QuadPart - EPOC_TIME) % 10000000) * 100;
	nsec = (nsec / 100) * 100; /* Round the request */
#else
	struct stat st;

	assertion_count(file, line);
	r = lstat(pathname, &st);
	if (r != 0) {
		failure_start(file, line, "Can't stat %s\n", pathname);
		failure_finish(NULL);
		return (0);
	}
	switch (type) {
	case 'a': filet = st.st_atime; break;
	case 'm': filet = st.st_mtime; break;
	case 'b': filet = 0; break;
	default: fprintf(stderr, "INTERNAL: Bad type %c for file time", type);
		exit(1);
	}
#if defined(__FreeBSD__)
	switch (type) {
	case 'a': filet_nsec = st.st_atimespec.tv_nsec; break;
	case 'b': filet = st.st_birthtime;
		filet_nsec = st.st_birthtimespec.tv_nsec; break;
	case 'm': filet_nsec = st.st_mtimespec.tv_nsec; break;
	default: fprintf(stderr, "INTERNAL: Bad type %c for file time", type);
		exit(1);
	}
	/* FreeBSD generally only stores to microsecond res, so round. */
	filet_nsec = (filet_nsec / 1000) * 1000;
	nsec = (nsec / 1000) * 1000;
#else
	filet_nsec = nsec = 0;	/* Generic POSIX only has whole seconds. */
	if (type == 'b') return (1); /* Generic POSIX doesn't have birthtime */
#if defined(__HAIKU__)
	if (type == 'a') return (1); /* Haiku doesn't have atime. */
#endif
#endif
#endif
	if (recent) {
		/* Check that requested time is up-to-date. */
		time_t now = time(NULL);
		if (filet < now - 10 || filet > now + 1) {
			failure_start(file, line,
			    "File %s has %ctime %ld, %ld seconds ago\n",
			    pathname, type, filet, now - filet);
			failure_finish(NULL);
			return (0);
		}
	} else if (filet != t || filet_nsec != nsec) {
		failure_start(file, line,
		    "File %s has %ctime %ld.%09ld, expected %ld.%09ld",
		    pathname, type, filet, filet_nsec, t, nsec);
		failure_finish(NULL);
		return (0);
	}
	return (1);
}

/* Verify atime of 'pathname'. */
int
assertion_file_atime(const char *file, int line,
    const char *pathname, long t, long nsec)
{
	return assertion_file_time(file, line, pathname, t, nsec, 'a', 0);
}

/* Verify atime of 'pathname' is up-to-date. */
int
assertion_file_atime_recent(const char *file, int line, const char *pathname)
{
	return assertion_file_time(file, line, pathname, 0, 0, 'a', 1);
}

/* Verify birthtime of 'pathname'. */
int
assertion_file_birthtime(const char *file, int line,
    const char *pathname, long t, long nsec)
{
	return assertion_file_time(file, line, pathname, t, nsec, 'b', 0);
}

/* Verify birthtime of 'pathname' is up-to-date. */
int
assertion_file_birthtime_recent(const char *file, int line,
    const char *pathname)
{
	return assertion_file_time(file, line, pathname, 0, 0, 'b', 1);
}

/* Verify mtime of 'pathname'. */
int
assertion_file_mtime(const char *file, int line,
    const char *pathname, long t, long nsec)
{
	return assertion_file_time(file, line, pathname, t, nsec, 'm', 0);
}

/* Verify mtime of 'pathname' is up-to-date. */
int
assertion_file_mtime_recent(const char *file, int line, const char *pathname)
{
	return assertion_file_time(file, line, pathname, 0, 0, 'm', 1);
}

/* Verify number of links to 'pathname'. */
int
assertion_file_nlinks(const char *file, int line,
    const char *pathname, int nlinks)
{
#if defined(_WIN32) && !defined(__CYGWIN__)
	BY_HANDLE_FILE_INFORMATION bhfi;
	int r;

	assertion_count(file, line);
	r = my_GetFileInformationByName(pathname, &bhfi);
	if (r != 0 && bhfi.nNumberOfLinks == (DWORD)nlinks)
		return (1);
	failure_start(file, line, "File %s has %d links, expected %d",
	    pathname, bhfi.nNumberOfLinks, nlinks);
	failure_finish(NULL);
	return (0);
#else
	struct stat st;
	int r;

	assertion_count(file, line);
	r = lstat(pathname, &st);
	if (r == 0 && st.st_nlink == nlinks)
			return (1);
	failure_start(file, line, "File %s has %d links, expected %d",
	    pathname, st.st_nlink, nlinks);
	failure_finish(NULL);
	return (0);
#endif
}

/* Verify size of 'pathname'. */
int
assertion_file_size(const char *file, int line, const char *pathname, long size)
{
	int64_t filesize;
	int r;

	assertion_count(file, line);
#if defined(_WIN32) && !defined(__CYGWIN__)
	{
		BY_HANDLE_FILE_INFORMATION bhfi;
		r = !my_GetFileInformationByName(pathname, &bhfi);
		filesize = ((int64_t)bhfi.nFileSizeHigh << 32) + bhfi.nFileSizeLow;
	}
#else
	{
		struct stat st;
		r = lstat(pathname, &st);
		filesize = st.st_size;
	}
#endif
	if (r == 0 && filesize == size)
			return (1);
	failure_start(file, line, "File %s has size %ld, expected %ld",
	    pathname, (long)filesize, (long)size);
	failure_finish(NULL);
	return (0);
}

/* Assert that 'pathname' is a dir.  If mode >= 0, verify that too. */
int
assertion_is_dir(const char *file, int line, const char *pathname, int mode)
{
	struct stat st;
	int r;

#if defined(_WIN32) && !defined(__CYGWIN__)
	(void)mode; /* UNUSED */
#endif
	assertion_count(file, line);
	r = lstat(pathname, &st);
	if (r != 0) {
		failure_start(file, line, "Dir should exist: %s", pathname);
		failure_finish(NULL);
		return (0);
	}
	if (!S_ISDIR(st.st_mode)) {
		failure_start(file, line, "%s is not a dir", pathname);
		failure_finish(NULL);
		return (0);
	}
#if !defined(_WIN32) || defined(__CYGWIN__)
	/* Windows doesn't handle permissions the same way as POSIX,
	 * so just ignore the mode tests. */
	/* TODO: Can we do better here? */
	if (mode >= 0 && mode != (st.st_mode & 07777)) {
		failure_start(file, line, "Dir %s has wrong mode", pathname);
		logprintf("  Expected: 0%3o\n", mode);
		logprintf("  Found: 0%3o\n", st.st_mode & 07777);
		failure_finish(NULL);
		return (0);
	}
#endif
	return (1);
}

/* Verify that 'pathname' is a regular file.  If 'mode' is >= 0,
 * verify that too. */
int
assertion_is_reg(const char *file, int line, const char *pathname, int mode)
{
	struct stat st;
	int r;

#if defined(_WIN32) && !defined(__CYGWIN__)
	(void)mode; /* UNUSED */
#endif
	assertion_count(file, line);
	r = lstat(pathname, &st);
	if (r != 0 || !S_ISREG(st.st_mode)) {
		failure_start(file, line, "File should exist: %s", pathname);
		failure_finish(NULL);
		return (0);
	}
#if !defined(_WIN32) || defined(__CYGWIN__)
	/* Windows doesn't handle permissions the same way as POSIX,
	 * so just ignore the mode tests. */
	/* TODO: Can we do better here? */
	if (mode >= 0 && mode != (st.st_mode & 07777)) {
		failure_start(file, line, "File %s has wrong mode", pathname);
		logprintf("  Expected: 0%3o\n", mode);
		logprintf("  Found: 0%3o\n", st.st_mode & 07777);
		failure_finish(NULL);
		return (0);
	}
#endif
	return (1);
}

/* Check whether 'pathname' is a symbolic link.  If 'contents' is
 * non-NULL, verify that the symlink has those contents. */
static int
is_symlink(const char *file, int line,
    const char *pathname, const char *contents)
{
#if defined(_WIN32) && !defined(__CYGWIN__)
	(void)pathname; /* UNUSED */
	(void)contents; /* UNUSED */
	assertion_count(file, line);
	/* Windows sort-of has real symlinks, but they're only usable
	 * by privileged users and are crippled even then, so there's
	 * really not much point in bothering with this. */
	return (0);
#else
	char buff[300];
	struct stat st;
	ssize_t linklen;
	int r;

	assertion_count(file, line);
	r = lstat(pathname, &st);
	if (r != 0) {
		failure_start(file, line,
		    "Symlink should exist: %s", pathname);
		failure_finish(NULL);
		return (0);
	}
	if (!S_ISLNK(st.st_mode))
		return (0);
	if (contents == NULL)
		return (1);
	linklen = readlink(pathname, buff, sizeof(buff));
	if (linklen < 0) {
		failure_start(file, line, "Can't read symlink %s", pathname);
		failure_finish(NULL);
		return (0);
	}
	buff[linklen] = '\0';
	if (strcmp(buff, contents) != 0)
		return (0);
	return (1);
#endif
}

/* Assert that path is a symlink that (optionally) contains contents. */
int
assertion_is_symlink(const char *file, int line,
    const char *path, const char *contents)
{
	if (is_symlink(file, line, path, contents))
		return (1);
	if (contents)
		failure_start(file, line, "File %s is not a symlink to %s",
		    path, contents);
	else
		failure_start(file, line, "File %s is not a symlink", path);
	failure_finish(NULL);
	return (0);
}


/* Create a directory and report any errors. */
int
assertion_make_dir(const char *file, int line, const char *dirname, int mode)
{
	assertion_count(file, line);
#if defined(_WIN32) && !defined(__CYGWIN__)
	(void)mode; /* UNUSED */
	if (0 == _mkdir(dirname))
		return (1);
#else
	if (0 == mkdir(dirname, mode))
		return (1);
#endif
	failure_start(file, line, "Could not create directory %s", dirname);
	failure_finish(NULL);
	return(0);
}

/* Create a file with the specified contents and report any failures. */
int
assertion_make_file(const char *file, int line,
    const char *path, int mode, const char *contents)
{
#if defined(_WIN32) && !defined(__CYGWIN__)
	/* TODO: Rework this to set file mode as well. */
	FILE *f;
	(void)mode; /* UNUSED */
	assertion_count(file, line);
	f = fopen(path, "wb");
	if (f == NULL) {
		failure_start(file, line, "Could not create file %s", path);
		failure_finish(NULL);
		return (0);
	}
	if (contents != NULL) {
		if (strlen(contents)
		    != fwrite(contents, 1, strlen(contents), f)) {
			fclose(f);
			failure_start(file, line,
			    "Could not write file %s", path);
			failure_finish(NULL);
			return (0);
		}
	}
	fclose(f);
	return (1);
#else
	int fd;
	assertion_count(file, line);
	fd = open(path, O_CREAT | O_WRONLY, mode >= 0 ? mode : 0644);
	if (fd < 0) {
		failure_start(file, line, "Could not create %s", path);
		failure_finish(NULL);
		return (0);
	}
	if (contents != NULL) {
		if ((ssize_t)strlen(contents)
		    != write(fd, contents, strlen(contents))) {
			close(fd);
			failure_start(file, line, "Could not write to %s", path);
			failure_finish(NULL);
			return (0);
		}
	}
	close(fd);
	return (1);
#endif
}

/* Create a hardlink and report any failures. */
int
assertion_make_hardlink(const char *file, int line,
    const char *newpath, const char *linkto)
{
	int succeeded;

	assertion_count(file, line);
#if defined(_WIN32) && !defined(__CYGWIN__)
	succeeded = my_CreateHardLinkA(newpath, linkto);
#elif HAVE_LINK
	succeeded = !link(linkto, newpath);
#else
	succeeded = 0;
#endif
	if (succeeded)
		return (1);
	failure_start(file, line, "Could not create hardlink");
	logprintf("   New link: %s\n", newpath);
	logprintf("   Old name: %s\n", linkto);
	failure_finish(NULL);
	return(0);
}

/* Create a symlink and report any failures. */
int
assertion_make_symlink(const char *file, int line,
    const char *newpath, const char *linkto)
{
#if defined(_WIN32) && !defined(__CYGWIN__)
	int targetIsDir = 0;  /* TODO: Fix this */
	assertion_count(file, line);
	if (my_CreateSymbolicLinkA(newpath, linkto, targetIsDir))
		return (1);
#elif HAVE_SYMLINK
	assertion_count(file, line);
	if (0 == symlink(linkto, newpath))
		return (1);
#endif
	failure_start(file, line, "Could not create symlink");
	logprintf("   New link: %s\n", newpath);
	logprintf("   Old name: %s\n", linkto);
	failure_finish(NULL);
	return(0);
}

/* Set umask, report failures. */
int
assertion_umask(const char *file, int line, int mask)
{
	assertion_count(file, line);
	(void)file; /* UNUSED */
	(void)line; /* UNUSED */
	umask(mask);
	return (1);
}

/*
 *
 *  UTILITIES for use by tests.
 *
 */

/*
 * Check whether platform supports symlinks.  This is intended
 * for tests to use in deciding whether to bother testing symlink
 * support; if the platform doesn't support symlinks, there's no point
 * in checking whether the program being tested can create them.
 *
 * Note that the first time this test is called, we actually go out to
 * disk to create and verify a symlink.  This is necessary because
 * symlink support is actually a property of a particular filesystem
 * and can thus vary between directories on a single system.  After
 * the first call, this returns the cached result from memory, so it's
 * safe to call it as often as you wish.
 */
int
canSymlink(void)
{
	/* Remember the test result */
	static int value = 0, tested = 0;
	if (tested)
		return (value);

	++tested;
	assertion_make_file(__FILE__, __LINE__, "canSymlink.0", 0644, "a");
	/* Note: Cygwin has its own symlink() emulation that does not
	 * use the Win32 CreateSymbolicLink() function. */
#if defined(_WIN32) && !defined(__CYGWIN__)
	value = my_CreateSymbolicLinkA("canSymlink.1", "canSymlink.0", 0)
	    && is_symlink(__FILE__, __LINE__, "canSymlink.1", "canSymlink.0");
#elif HAVE_SYMLINK
	value = (0 == symlink("canSymlink.0", "canSymlink.1"))
	    && is_symlink(__FILE__, __LINE__, "canSymlink.1","canSymlink.0");
#endif
	return (value);
}

/*
 * Can this platform run the gzip program?
 */
/* Platform-dependent options for hiding the output of a subcommand. */
#if defined(_WIN32) && !defined(__CYGWIN__)
static const char *redirectArgs = ">NUL 2>NUL"; /* Win32 cmd.exe */
#else
static const char *redirectArgs = ">/dev/null 2>/dev/null"; /* POSIX 'sh' */
#endif
int
canGzip(void)
{
	static int tested = 0, value = 0;
	if (!tested) {
		tested = 1;
		if (systemf("gzip -V %s", redirectArgs) == 0)
			value = 1;
	}
	return (value);
}

/*
 * Can this platform run the gunzip program?
 */
int
canGunzip(void)
{
	static int tested = 0, value = 0;
	if (!tested) {
		tested = 1;
		if (systemf("gunzip -V %s", redirectArgs) == 0)
			value = 1;
	}
	return (value);
}

/*
 * Sleep as needed; useful for verifying disk timestamp changes by
 * ensuring that the wall-clock time has actually changed before we
 * go back to re-read something from disk.
 */
void
sleepUntilAfter(time_t t)
{
	while (t >= time(NULL))
#if defined(_WIN32) && !defined(__CYGWIN__)
		Sleep(500);
#else
		sleep(1);
#endif
}

/*
 * Call standard system() call, but build up the command line using
 * sprintf() conventions.
 */
int
systemf(const char *fmt, ...)
{
	char buff[8192];
	va_list ap;
	int r;

	va_start(ap, fmt);
	vsprintf(buff, fmt, ap);
	if (verbosity > VERBOSITY_FULL)
		logprintf("Cmd: %s\n", buff);
	r = system(buff);
	va_end(ap);
	return (r);
}

/*
 * Slurp a file into memory for ease of comparison and testing.
 * Returns size of file in 'sizep' if non-NULL, null-terminates
 * data in memory for ease of use.
 */
char *
slurpfile(size_t * sizep, const char *fmt, ...)
{
	char filename[8192];
	struct stat st;
	va_list ap;
	char *p;
	ssize_t bytes_read;
	FILE *f;
	int r;

	va_start(ap, fmt);
	vsprintf(filename, fmt, ap);
	va_end(ap);

	f = fopen(filename, "rb");
	if (f == NULL) {
		/* Note: No error; non-existent file is okay here. */
		return (NULL);
	}
	r = fstat(fileno(f), &st);
	if (r != 0) {
		logprintf("Can't stat file %s\n", filename);
		fclose(f);
		return (NULL);
	}
	p = malloc((size_t)st.st_size + 1);
	if (p == NULL) {
		logprintf("Can't allocate %ld bytes of memory to read file %s\n",
		    (long int)st.st_size, filename);
		fclose(f);
		return (NULL);
	}
	bytes_read = fread(p, 1, (size_t)st.st_size, f);
	if (bytes_read < st.st_size) {
		logprintf("Can't read file %s\n", filename);
		fclose(f);
		free(p);
		return (NULL);
	}
	p[st.st_size] = '\0';
	if (sizep != NULL)
		*sizep = (size_t)st.st_size;
	fclose(f);
	return (p);
}

/* Read a uuencoded file from the reference directory, decode, and
 * write the result into the current directory. */
#define	UUDECODE(c) (((c) - 0x20) & 0x3f)
void
extract_reference_file(const char *name)
{
	char buff[1024];
	FILE *in, *out;

	sprintf(buff, "%s/%s.uu", refdir, name);
	in = fopen(buff, "r");
	failure("Couldn't open reference file %s", buff);
	assert(in != NULL);
	if (in == NULL)
		return;
	/* Read up to and including the 'begin' line. */
	for (;;) {
		if (fgets(buff, sizeof(buff), in) == NULL) {
			/* TODO: This is a failure. */
			return;
		}
		if (memcmp(buff, "begin ", 6) == 0)
			break;
	}
	/* Now, decode the rest and write it. */
	/* Not a lot of error checking here; the input better be right. */
	out = fopen(name, "wb");
	while (fgets(buff, sizeof(buff), in) != NULL) {
		char *p = buff;
		int bytes;

		if (memcmp(buff, "end", 3) == 0)
			break;

		bytes = UUDECODE(*p++);
		while (bytes > 0) {
			int n = 0;
			/* Write out 1-3 bytes from that. */
			if (bytes > 0) {
				n = UUDECODE(*p++) << 18;
				n |= UUDECODE(*p++) << 12;
				fputc(n >> 16, out);
				--bytes;
			}
			if (bytes > 0) {
				n |= UUDECODE(*p++) << 6;
				fputc((n >> 8) & 0xFF, out);
				--bytes;
			}
			if (bytes > 0) {
				n |= UUDECODE(*p++);
				fputc(n & 0xFF, out);
				--bytes;
			}
		}
	}
	fclose(out);
	fclose(in);
}

/*
 *
 * TEST management
 *
 */

/*
 * "list.h" is simply created by "grep DEFINE_TEST test_*.c"; it has
 * a line like
 *      DEFINE_TEST(test_function)
 * for each test.
 */

/* Use "list.h" to declare all of the test functions. */
#undef DEFINE_TEST
#define	DEFINE_TEST(name) void name(void);
#include "list.h"

/* Use "list.h" to create a list of all tests (functions and names). */
#undef DEFINE_TEST
#define	DEFINE_TEST(n) { n, #n, 0 },
struct { void (*func)(void); const char *name; int failures; } tests[] = {
	#include "list.h"
};

/*
 * Summarize repeated failures in the just-completed test.
 */
static void
test_summarize(const char *filename, int failed)
{
	unsigned int i;

	switch (verbosity) {
	case VERBOSITY_SUMMARY_ONLY:
		printf(failed ? "E" : ".");
		fflush(stdout);
		break;
	case VERBOSITY_PASSFAIL:
		printf(failed ? "FAIL\n" : "ok\n");
		break;
	}

	log_console = (verbosity == VERBOSITY_LIGHT_REPORT);

	for (i = 0; i < sizeof(failed_lines)/sizeof(failed_lines[0]); i++) {
		if (failed_lines[i].count > 1 && !failed_lines[i].skip)
			logprintf("%s:%d: Summary: Failed %d times\n",
			    filename, i, failed_lines[i].count);
	}
	/* Clear the failure history for the next file. */
	memset(failed_lines, 0, sizeof(failed_lines));
}

/*
 * Actually run a single test, with appropriate setup and cleanup.
 */
static int
test_run(int i, const char *tmpdir)
{
	char logfilename[64];
	int failures_before = failures;
	int oldumask;

	switch (verbosity) {
	case VERBOSITY_SUMMARY_ONLY: /* No per-test reports at all */
		break;
	case VERBOSITY_PASSFAIL: /* rest of line will include ok/FAIL marker */
		printf("%3d: %-50s", i, tests[i].name);
		fflush(stdout);
		break;
	default: /* Title of test, details will follow */
		printf("%3d: %s\n", i, tests[i].name);
	}

	/* Chdir to the top-level work directory. */
	if (!assertChdir(tmpdir)) {
		fprintf(stderr,
		    "ERROR: Can't chdir to top work dir %s\n", tmpdir);
		exit(1);
	}
	/* Create a log file for this test. */
	sprintf(logfilename, "%s.log", tests[i].name);
	logfile = fopen(logfilename, "w");
	fprintf(logfile, "%s\n\n", tests[i].name);
	/* Chdir() to a work dir for this specific test. */
	if (!assertMakeDir(tests[i].name, 0755)
	    || !assertChdir(tests[i].name)) {
		fprintf(stderr,
		    "ERROR: Can't chdir to work dir %s/%s\n",
		    tmpdir, tests[i].name);
		exit(1);
	}
	/* Explicitly reset the locale before each test. */
	setlocale(LC_ALL, "C");
	/* Record the umask before we run the test. */
	umask(oldumask = umask(0));
	/*
	 * Run the actual test.
	 */
	(*tests[i].func)();
	/*
	 * Clean up and report afterwards.
	 */
	/* Restore umask */
	umask(oldumask);
	/* Reset locale. */
	setlocale(LC_ALL, "C");
	/* Reset directory. */
	if (!assertChdir(tmpdir)) {
		fprintf(stderr, "ERROR: Couldn't chdir to temp dir %s\n",
		    tmpdir);
		exit(1);
	}
	/* Report per-test summaries. */
	tests[i].failures = failures - failures_before;
	test_summarize(test_filename, tests[i].failures);
	/* Close the per-test log file. */
	fclose(logfile);
	logfile = NULL;
	/* If there were no failures, we can remove the work dir and logfile. */
	if (tests[i].failures == 0) {
		if (!keep_temp_files && assertChdir(tmpdir)) {
#if defined(_WIN32) && !defined(__CYGWIN__)
			/* Make sure not to leave empty directories.
			 * Sometimes a processing of closing files used by tests
			 * is not done, then rmdir will be failed and it will
			 * leave a empty test directory. So we should wait a few
			 * seconds and retry rmdir. */
			int r, t;
			for (t = 0; t < 10; t++) {
				if (t > 0)
					Sleep(1000);
				r = systemf("rmdir /S /Q %s", tests[i].name);
				if (r == 0)
					break;
			}
			systemf("del %s", logfilename);
#else
			systemf("rm -rf %s", tests[i].name);
			systemf("rm %s", logfilename);
#endif
		}
	}
	/* Return appropriate status. */
	return (tests[i].failures);
}

/*
 *
 *
 * MAIN and support routines.
 *
 *
 */

static void
usage(const char *program)
{
	static const int limit = sizeof(tests) / sizeof(tests[0]);
	int i;

	printf("Usage: %s [options] <test> <test> ...\n", program);
	printf("Default is to run all tests.\n");
	printf("Otherwise, specify the numbers of the tests you wish to run.\n");
	printf("Options:\n");
	printf("  -d  Dump core after any failure, for debugging.\n");
	printf("  -k  Keep all temp files.\n");
	printf("      Default: temp files for successful tests deleted.\n");
#ifdef PROGRAM
	printf("  -p <path>  Path to executable to be tested.\n");
	printf("      Default: path taken from " ENVBASE " environment variable.\n");
#endif
	printf("  -q  Quiet.\n");
	printf("  -r <dir>   Path to dir containing reference files.\n");
	printf("      Default: Current directory.\n");
	printf("  -v  Verbose.\n");
	printf("Available tests:\n");
	for (i = 0; i < limit; i++)
		printf("  %d: %s\n", i, tests[i].name);
	exit(1);
}

static char *
get_refdir(const char *d)
{
	char tried[512] = { '\0' };
	char buff[128];
	char *pwd, *p;

	/* If a dir was specified, try that */
	if (d != NULL) {
		pwd = NULL;
		snprintf(buff, sizeof(buff), "%s", d);
		p = slurpfile(NULL, "%s/%s", buff, KNOWNREF);
		if (p != NULL) goto success;
		strncat(tried, buff, sizeof(tried) - strlen(tried) - 1);
		strncat(tried, "\n", sizeof(tried) - strlen(tried) - 1);
		goto failure;
	}

	/* Get the current dir. */
	pwd = getcwd(NULL, 0);
	while (pwd[strlen(pwd) - 1] == '\n')
		pwd[strlen(pwd) - 1] = '\0';

	/* Look for a known file. */
	snprintf(buff, sizeof(buff), "%s", pwd);
	p = slurpfile(NULL, "%s/%s", buff, KNOWNREF);
	if (p != NULL) goto success;
	strncat(tried, buff, sizeof(tried) - strlen(tried) - 1);
	strncat(tried, "\n", sizeof(tried) - strlen(tried) - 1);

	snprintf(buff, sizeof(buff), "%s/test", pwd);
	p = slurpfile(NULL, "%s/%s", buff, KNOWNREF);
	if (p != NULL) goto success;
	strncat(tried, buff, sizeof(tried) - strlen(tried) - 1);
	strncat(tried, "\n", sizeof(tried) - strlen(tried) - 1);

#if defined(LIBRARY)
	snprintf(buff, sizeof(buff), "%s/%s/test", pwd, LIBRARY);
#else
	snprintf(buff, sizeof(buff), "%s/%s/test", pwd, PROGRAM);
#endif
	p = slurpfile(NULL, "%s/%s", buff, KNOWNREF);
	if (p != NULL) goto success;
	strncat(tried, buff, sizeof(tried) - strlen(tried) - 1);
	strncat(tried, "\n", sizeof(tried) - strlen(tried) - 1);

	if (memcmp(pwd, "/usr/obj", 8) == 0) {
		snprintf(buff, sizeof(buff), "%s", pwd + 8);
		p = slurpfile(NULL, "%s/%s", buff, KNOWNREF);
		if (p != NULL) goto success;
		strncat(tried, buff, sizeof(tried) - strlen(tried) - 1);
		strncat(tried, "\n", sizeof(tried) - strlen(tried) - 1);

		snprintf(buff, sizeof(buff), "%s/test", pwd + 8);
		p = slurpfile(NULL, "%s/%s", buff, KNOWNREF);
		if (p != NULL) goto success;
		strncat(tried, buff, sizeof(tried) - strlen(tried) - 1);
		strncat(tried, "\n", sizeof(tried) - strlen(tried) - 1);
	}

failure:
	printf("Unable to locate known reference file %s\n", KNOWNREF);
	printf("  Checked following directories:\n%s\n", tried);
#if defined(_WIN32) && !defined(__CYGWIN__) && defined(_DEBUG)
	DebugBreak();
#endif
	exit(1);

success:
	free(p);
	free(pwd);
	return strdup(buff);
}

int
main(int argc, char **argv)
{
	static const int limit = sizeof(tests) / sizeof(tests[0]);
	int i, tests_run = 0, tests_failed = 0, option;
	time_t now;
	char *refdir_alloc = NULL;
	const char *progname;
	const char *tmp, *option_arg, *p;
	char tmpdir[256];
	char tmpdir_timestamp[256];

	(void)argc; /* UNUSED */

#if defined(HAVE__CrtSetReportMode)
	/* To stop to run the default invalid parameter handler. */
	_set_invalid_parameter_handler(invalid_parameter_handler);
	/* Disable annoying assertion message box. */
	_CrtSetReportMode(_CRT_ASSERT, 0);
#endif

	/*
	 * Name of this program, used to build root of our temp directory
	 * tree.
	 */
	progname = p = argv[0];
	while (*p != '\0') {
		/* Support \ or / dir separators for Windows compat. */
		if (*p == '/' || *p == '\\')
			progname = p + 1;
		++p;
	}

#ifdef PROGRAM
	/* Get the target program from environment, if available. */
	testprogfile = getenv(ENVBASE);
#endif

	if (getenv("TMPDIR") != NULL)
		tmp = getenv("TMPDIR");
	else if (getenv("TMP") != NULL)
		tmp = getenv("TMP");
	else if (getenv("TEMP") != NULL)
		tmp = getenv("TEMP");
	else if (getenv("TEMPDIR") != NULL)
		tmp = getenv("TEMPDIR");
	else
		tmp = "/tmp";

	/* Allow -d to be controlled through the environment. */
	if (getenv(ENVBASE "_DEBUG") != NULL)
		dump_on_failure = 1;

	/* Get the directory holding test files from environment. */
	refdir = getenv(ENVBASE "_TEST_FILES");

	/*
	 * Parse options, without using getopt(), which isn't available
	 * on all platforms.
	 */
	++argv; /* Skip program name */
	while (*argv != NULL) {
		if (**argv != '-')
			break;
		p = *argv++;
		++p; /* Skip '-' */
		while (*p != '\0') {
			option = *p++;
			option_arg = NULL;
			/* If 'opt' takes an argument, parse that. */
			if (option == 'p' || option == 'r') {
				if (*p != '\0')
					option_arg = p;
				else if (*argv == NULL) {
					fprintf(stderr,
					    "Option -%c requires argument.\n",
					    option);
					usage(progname);
				} else
					option_arg = *argv++;
				p = ""; /* End of this option word. */
			}

			/* Now, handle the option. */
			switch (option) {
			case 'd':
				dump_on_failure = 1;
				break;
			case 'k':
				keep_temp_files = 1;
				break;
			case 'p':
#ifdef PROGRAM
				testprogfile = option_arg;
#else
				fprintf(stderr, "-p option not permitted\n");
				usage(progname);
#endif
				break;
			case 'q':
				verbosity--;
				break;
			case 'r':
				refdir = option_arg;
				break;
			case 'v':
				verbosity++;
				break;
			default:
				fprintf(stderr, "Unrecognized option '%c'\n",
				    option);
				usage(progname);
			}
		}
	}

	/*
	 * Sanity-check that our options make sense.
	 */
#ifdef PROGRAM
	if (testprogfile == NULL) {
		fprintf(stderr, "Program executable required\n");
		usage(progname);
	}

	{
		char *testprg;
#if defined(_WIN32) && !defined(__CYGWIN__)
		/* Command.com sometimes rejects '/' separators. */
		testprg = strdup(testprogfile);
		for (i = 0; testprg[i] != '\0'; i++) {
			if (testprg[i] == '/')
				testprg[i] = '\\';
		}
		testprogfile = testprg;
#endif
		/* Quote the name that gets put into shell command lines. */
		testprg = malloc(strlen(testprogfile) + 3);
		strcpy(testprg, "\"");
		strcat(testprg, testprogfile);
		strcat(testprg, "\"");
		testprog = testprg;
	}
#endif

	/*
	 * Create a temp directory for the following tests.
	 * Include the time the tests started as part of the name,
	 * to make it easier to track the results of multiple tests.
	 */
	now = time(NULL);
	for (i = 0; ; i++) {
		strftime(tmpdir_timestamp, sizeof(tmpdir_timestamp),
		    "%Y-%m-%dT%H.%M.%S",
		    localtime(&now));
		sprintf(tmpdir, "%s/%s.%s-%03d", tmp, progname,
		    tmpdir_timestamp, i);
		if (assertMakeDir(tmpdir,0755))
			break;
		if (i >= 999) {
			fprintf(stderr,
			    "ERROR: Unable to create temp directory %s\n",
			    tmpdir);
			exit(1);
		}
	}

	/*
	 * If the user didn't specify a directory for locating
	 * reference files, try to find the reference files in
	 * the "usual places."
	 */
	refdir = refdir_alloc = get_refdir(refdir);

	/*
	 * Banner with basic information.
	 */
	printf("\n");
	printf("If tests fail or crash, details will be in:\n");
	printf("   %s\n", tmpdir);
	printf("\n");
	if (verbosity > VERBOSITY_SUMMARY_ONLY) {
		printf("Reference files will be read from: %s\n", refdir);
#ifdef PROGRAM
		printf("Running tests on: %s\n", testprog);
#endif
		printf("Exercising: ");
		fflush(stdout);
		printf("%s\n", EXTRA_VERSION);
	} else {
		printf("Running ");
		fflush(stdout);
	}

	/*
	 * Run some or all of the individual tests.
	 */
	if (*argv == NULL) {
		/* Default: Run all tests. */
		for (i = 0; i < limit; i++) {
			if (test_run(i, tmpdir))
				tests_failed++;
			tests_run++;
		}
	} else {
		while (*(argv) != NULL) {
			if (**argv >= '0' && **argv <= '9') {
				i = atoi(*argv);
				if (i < 0 || i >= limit) {
					printf("*** INVALID Test %s\n", *argv);
					free(refdir_alloc);
					usage(progname);
					/* usage() never returns */
				}
			} else {
				for (i = 0; i < limit; ++i) {
					if (strcmp(*argv, tests[i].name) == 0)
						break;
				}
				if (i >= limit) {
					printf("*** INVALID Test ``%s''\n",
					       *argv);
					free(refdir_alloc);
					usage(progname);
					/* usage() never returns */
				}
			}
			if (test_run(i, tmpdir))
				tests_failed++;
			tests_run++;
			argv++;
		}
	}

	/*
	 * Report summary statistics.
	 */
	if (verbosity > VERBOSITY_SUMMARY_ONLY) {
		printf("\n");
		printf("Totals:\n");
		printf("  Tests run:         %8d\n", tests_run);
		printf("  Tests failed:      %8d\n", tests_failed);
		printf("  Assertions checked:%8d\n", assertions);
		printf("  Assertions failed: %8d\n", failures);
		printf("  Skips reported:    %8d\n", skips);
	}
	if (failures) {
		printf("\n");
		printf("Failing tests:\n");
		for (i = 0; i < limit; ++i) {
			if (tests[i].failures)
				printf("  %d: %s (%d failures)\n", i,
				    tests[i].name, tests[i].failures);
		}
		printf("\n");
		printf("Details for failing tests: %s\n", tmpdir);
		printf("\n");
	} else {
		if (verbosity == VERBOSITY_SUMMARY_ONLY)
			printf("\n");
		printf("%d tests passed, no failures\n", tests_run);
	}

	free(refdir_alloc);

	/* If the final tmpdir is empty, we can remove it. */
	/* This should be the usual case when all tests succeed. */
	assertChdir("..");
	rmdir(tmpdir);

	return (tests_failed ? 1 : 0);
}



/* ============================================================================
 * SOURCE 4/98: minix4\microkernel\servers\pm\main.c
 * Size: 13,326 bytes, Lines: 437
 * Hash: 82166d4ff2a9...
 * ============================================================================ */

/* This file contains the main program of the process manager and some related
 * procedures.  When MINIX starts up, the kernel runs for a little while,
 * initializing itself and its tasks, and then it runs PM and VFS.  Both PM
 * and VFS initialize themselves as far as they can. PM asks the kernel for
 * all free memory and starts serving requests.
 *
 * The entry points into this file are:
 *   main:	starts PM running
 *   reply:	send a reply to a process making a PM system call
 */

#include "pm.h"
#include <minix/callnr.h>
#include <minix/com.h>
#include <minix/ds.h>
#include <minix/endpoint.h>
#include <minix/minlib.h>
#include <minix/type.h>
#include <minix/vm.h>
#include <signal.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/resource.h>
#include <sys/utsname.h>
#include <sys/wait.h>
#include <machine/archtypes.h>
#include <assert.h>
#include "mproc.h"
#include <minix/ipc_pmsyscalls.h> // For new message types/macros

#include "kernel/const.h"
#include "kernel/config.h"
#include "kernel/proc.h"

#if ENABLE_SYSCALL_STATS
EXTERN unsigned long calls_stats[NR_PM_CALLS];
#endif

static int get_nice_value(int queue);
static void handle_vfs_reply(void);

/* SEF functions and variables. */
static void sef_local_startup(void);
static int sef_cb_init_fresh(int type, sef_init_info_t *info);

/*===========================================================================*
 *				main					     *
 *===========================================================================*/
int
main(void)
{
/* Main routine of the process manager. */
  unsigned int call_index;
  int ipc_status, result;

  /* SEF local startup. */
  sef_local_startup();

  /* This is PM's main loop-  get work and do it, forever and forever. */
  while (TRUE) {
	/* Wait for the next message. */
	if (sef_receive_status(ANY, &m_in, &ipc_status) != OK)
		panic("PM sef_receive_status error");

	/* Check for system notifications first. Special cases. */
	if (is_ipc_notify(ipc_status)) {
		if (_ENDPOINT_P(m_in.m_source) == CLOCK)
			expire_timers(m_in.m_notify.timestamp);

		/* done, continue */
		continue;
	}

	/* Extract useful information from the message. */
	who_e = m_in.m_source;	/* who sent the message */
	if (pm_isokendpt(who_e, &who_p) != OK)
		panic("PM got message from invalid endpoint: %d", who_e);
	mp = &mproc[who_p];	/* process slot of caller */
	call_nr = m_in.m_type;	/* system call number */

	/* Drop delayed calls from exiting processes. */
	if (mp->mp_flags & EXITING)
		continue;

	if (IS_VFS_PM_RS(call_nr) && who_e == VFS_PROC_NR) {
		handle_vfs_reply();

		result = SUSPEND;		/* don't reply */
	} else if (call_nr == PROC_EVENT_REPLY) {
		result = do_proc_event_reply();
	} else if (call_nr == PM_GETPID_CAP) { /* Handle new PM_GETPID_CAP call */
		result = do_getpid_cap(); /* New handler function */
	} else if (IS_PM_CALL(call_nr)) {
		/* If the system call number is valid, perform the call. */
        if (call_nr == PM_GETPID_CAP_RQ) {
            // Handle PM_GETPID_CAP_RQ directly
            // Kernel IPC path should have validated capability.
            mp->mp_reply.m_type = PM_GETPID_CAP_RS;
            mp->mp_reply.m_pm_getpid_cap_rs_pid = mp->mp_pid;
            result = OK;
        } else {
            // Existing call vector handling
            call_index = (unsigned int) (call_nr - PM_BASE);

            if (call_index < NR_PM_CALLS && call_vec[call_index] != NULL) {
#if ENABLE_SYSCALL_STATS
                calls_stats[call_index]++;
#endif

                result = (*call_vec[call_index])();
            } else
                result = ENOSYS;
        }
	} else
		result = ENOSYS;

	/* Send reply. */
	if (result != SUSPEND) reply(who_p, result);
  }
  return(OK);
}

/*===========================================================================*
 *			       sef_local_startup			     *
 *===========================================================================*/
static void
sef_local_startup(void)
{
  /* Register init callbacks. */
  sef_setcb_init_fresh(sef_cb_init_fresh);
  sef_setcb_init_restart(SEF_CB_INIT_RESTART_STATEFUL);

  /* Register signal callbacks. */
  sef_setcb_signal_manager(process_ksig);

  /* Let SEF perform startup. */
  sef_startup();
}

/*===========================================================================*
 *		            sef_cb_init_fresh                                *
 *===========================================================================*/
static int sef_cb_init_fresh(int UNUSED(type), sef_init_info_t *UNUSED(info))
{
/* Initialize the process manager. */
  int s;
  static struct boot_image image[NR_BOOT_PROCS];
  register struct boot_image *ip;
  static char core_sigs[] = { SIGQUIT, SIGILL, SIGTRAP, SIGABRT,
				SIGEMT, SIGFPE, SIGBUS, SIGSEGV };
  static char ign_sigs[] = { SIGCHLD, SIGWINCH, SIGCONT, SIGINFO };
  static char noign_sigs[] = { SIGILL, SIGTRAP, SIGEMT, SIGFPE,
				SIGBUS, SIGSEGV };
  register struct mproc *rmp;
  register char *sig_ptr;
  message mess;

  /* Initialize process table, including timers. */
  for (rmp=&mproc[0]; rmp<&mproc[NR_PROCS]; rmp++) {
	init_timer(&rmp->mp_timer);
	rmp->mp_magic = MP_MAGIC;
	rmp->mp_sigact = mpsigact[rmp - mproc];
	rmp->mp_eventsub = NO_EVENTSUB;
  }

  /* Build the set of signals which cause core dumps, and the set of signals
   * that are by default ignored.
   */
  sigemptyset(&core_sset);
  for (sig_ptr = core_sigs; sig_ptr < core_sigs+sizeof(core_sigs); sig_ptr++)
	sigaddset(&core_sset, *sig_ptr);
  sigemptyset(&ign_sset);
  for (sig_ptr = ign_sigs; sig_ptr < ign_sigs+sizeof(ign_sigs); sig_ptr++)
	sigaddset(&ign_sset, *sig_ptr);
  sigemptyset(&noign_sset);
  for (sig_ptr = noign_sigs; sig_ptr < noign_sigs+sizeof(noign_sigs); sig_ptr++)
	sigaddset(&noign_sset, *sig_ptr);

  /* Obtain a copy of the boot monitor parameters.
   */
  if ((s=sys_getmonparams(monitor_params, sizeof(monitor_params))) != OK)
      panic("get monitor params failed: %d", s);

  /* Initialize PM's process table. Request a copy of the system image table
   * that is defined at the kernel level to see which slots to fill in.
   */
  if (OK != (s=sys_getimage(image)))
  	panic("couldn't get image table: %d", s);
  procs_in_use = 0;				/* start populating table */
  for (ip = &image[0]; ip < &image[NR_BOOT_PROCS]; ip++) {
  	if (ip->proc_nr >= 0) {			/* task have negative nrs */
  		procs_in_use += 1;		/* found user process */

		/* Set process details found in the image table. */
		rmp = &mproc[ip->proc_nr];
  		strlcpy(rmp->mp_name, ip->proc_name, PROC_NAME_LEN);
  		(void) sigemptyset(&rmp->mp_ignore);
  		(void) sigemptyset(&rmp->mp_sigmask);
  		(void) sigemptyset(&rmp->mp_catch);
		if (ip->proc_nr == INIT_PROC_NR) {	/* user process */
  			/* INIT is root, we make it father of itself. This is
  			 * not really OK, INIT should have no father, i.e.
  			 * a father with pid NO_PID. But PM currently assumes
  			 * that mp_parent always points to a valid slot number.
  			 */
  			rmp->mp_parent = INIT_PROC_NR;
  			rmp->mp_procgrp = rmp->mp_pid = INIT_PID;
			rmp->mp_flags |= IN_USE;

			/* Set scheduling info */
			rmp->mp_scheduler = KERNEL;
			rmp->mp_nice = get_nice_value(USR_Q);
		}
		else {					/* system process */
  			if(ip->proc_nr == RS_PROC_NR) {
  				rmp->mp_parent = INIT_PROC_NR;
  			}
  			else {
  				rmp->mp_parent = RS_PROC_NR;
  			}
  			rmp->mp_pid = get_free_pid();
			rmp->mp_flags |= IN_USE | PRIV_PROC;

			/* RS schedules this process */
			rmp->mp_scheduler = NONE;
			rmp->mp_nice = get_nice_value(SRV_Q);
		}

		/* Get kernel endpoint identifier. */
		rmp->mp_endpoint = ip->endpoint;

		/* Tell VFS about this system process. */
		memset(&mess, 0, sizeof(mess));
		mess.m_type = VFS_PM_INIT;
		mess.VFS_PM_SLOT = ip->proc_nr;
		mess.VFS_PM_PID = rmp->mp_pid;
		mess.VFS_PM_ENDPT = rmp->mp_endpoint;
  		if (OK != (s=ipc_send(VFS_PROC_NR, &mess)))
			panic("can't sync up with VFS: %d", s);
  	}
  }

  /* Tell VFS that no more system processes follow and synchronize. */
  memset(&mess, 0, sizeof(mess));
  mess.m_type = VFS_PM_INIT;
  mess.VFS_PM_ENDPT = NONE;
  if (ipc_sendrec(VFS_PROC_NR, &mess) != OK || mess.m_type != OK)
	panic("can't sync up with VFS");

 system_hz = sys_hz();

  /* Initialize user-space scheduling. */
  sched_init();

  return(OK);
}

/*===========================================================================*
 *				reply					     *
 *===========================================================================*/
void
reply(
	int proc_nr,			/* process to reply to */
	int result			/* result of call (usually OK or error #) */
)
{
/* Send a reply to a user process.  System calls may occasionally fill in other
 * fields, this is only for the main return value and for sending the reply.
 */
  struct mproc *rmp;
  int r;

  if(proc_nr < 0 || proc_nr >= NR_PROCS)
      panic("reply arg out of range: %d", proc_nr);

  rmp = &mproc[proc_nr];
  rmp->mp_reply.m_type = result;

  if ((r = ipc_sendnb(rmp->mp_endpoint, &rmp->mp_reply)) != OK)
	printf("PM can't reply to %d (%s): %d\n", rmp->mp_endpoint,
		rmp->mp_name, r);
}

/*===========================================================================*
 *				get_nice_value				     *
 *===========================================================================*/
static int
get_nice_value(
	int queue				/* store mem chunks here */
)
{
/* Processes in the boot image have a priority assigned. The PM doesn't know
 * about priorities, but uses 'nice' values instead. The priority is between
 * MIN_USER_Q and MAX_USER_Q. We have to scale between PRIO_MIN and PRIO_MAX.
 */
  int nice_val = (queue - USER_Q) * (PRIO_MAX-PRIO_MIN+1) /
      (MIN_USER_Q-MAX_USER_Q+1);
  if (nice_val > PRIO_MAX) nice_val = PRIO_MAX;	/* shouldn't happen */
  if (nice_val < PRIO_MIN) nice_val = PRIO_MIN;	/* shouldn't happen */
  return nice_val;
}

/*===========================================================================*
 *				handle_vfs_reply       			     *
 *===========================================================================*/
static void
handle_vfs_reply(void)
{
  struct mproc *rmp;
  endpoint_t proc_e;
  int r, proc_n, new_parent;

  /* VFS_PM_REBOOT is the only request not associated with a process.
   * Handle its reply first.
   */
  if (call_nr == VFS_PM_REBOOT_REPLY) {
	/* Ask the kernel to abort. All system services, including
	 * the PM, will get a HARD_STOP notification. Await the
	 * notification in the main loop.
	 */
	sys_abort(abort_flag);

	return;
  }

  /* Get the process associated with this call */
  proc_e = m_in.VFS_PM_ENDPT;

  if (pm_isokendpt(proc_e, &proc_n) != OK) {
	panic("handle_vfs_reply: got bad endpoint from VFS: %d", proc_e);
  }

  rmp = &mproc[proc_n];

  /* Now that VFS replied, mark the process as VFS-idle again */
  if (!(rmp->mp_flags & VFS_CALL))
	panic("handle_vfs_reply: reply without request: %d", call_nr);

  new_parent = rmp->mp_flags & NEW_PARENT;
  rmp->mp_flags &= ~(VFS_CALL | NEW_PARENT);

  if (rmp->mp_flags & UNPAUSED)
  	panic("handle_vfs_reply: UNPAUSED set on entry: %d", call_nr);

  /* Call-specific handler code */
  switch (call_nr) {
  case VFS_PM_SETUID_REPLY:
  case VFS_PM_SETGID_REPLY:
  case VFS_PM_SETGROUPS_REPLY:
	/* Wake up the original caller */
	reply(rmp-mproc, OK);

	break;

  case VFS_PM_SETSID_REPLY:
	/* Wake up the original caller */
	reply(rmp-mproc, rmp->mp_procgrp);

	break;

  case VFS_PM_EXEC_REPLY:
	exec_restart(rmp, m_in.VFS_PM_STATUS, (vir_bytes)m_in.VFS_PM_PC,
		(vir_bytes)m_in.VFS_PM_NEWSP,
		(vir_bytes)m_in.VFS_PM_NEWPS_STR);

	break;

  case VFS_PM_CORE_REPLY:
	if (m_in.VFS_PM_STATUS == OK)
		rmp->mp_sigstatus |= WCOREFLAG;

	/* FALLTHROUGH */
  case VFS_PM_EXIT_REPLY:
	assert(rmp->mp_flags & EXITING);

	/* Publish the exit event. Continue exiting the process after that. */
	publish_event(rmp);

	return; /* do not take the default action */

  case VFS_PM_FORK_REPLY:
	/* Schedule the newly created process ... */
	r = OK;
	if (rmp->mp_scheduler != KERNEL && rmp->mp_scheduler != NONE) {
		r = sched_start_user(rmp->mp_scheduler, rmp);
	}

	/* If scheduling the process failed, we want to tear down the process
	 * and fail the fork */
	if (r != OK) {
		/* Tear down the newly created process */
		rmp->mp_scheduler = NONE; /* don't try to stop scheduling */
		exit_proc(rmp, -1, FALSE /*dump_core*/);

		/* Wake up the parent with a failed fork (unless dead) */
		if (!new_parent)
			reply(rmp->mp_parent, -1);
	}
	else {
		/* Wake up the child */
		reply(proc_n, OK);

		/* Wake up the parent, unless the parent is already dead */
		if (!new_parent)
			reply(rmp->mp_parent, rmp->mp_pid);
	}

	break;

  case VFS_PM_SRV_FORK_REPLY:
	/* Nothing to do */

	break;

  case VFS_PM_UNPAUSE_REPLY:
	/* The target process must always be stopped while unpausing; otherwise
	 * it could just end up pausing itself on a new call afterwards.
	 */
	assert(rmp->mp_flags & PROC_STOPPED);

	/* Process is now unpaused */
	rmp->mp_flags |= UNPAUSED;

	/* Publish the signal event. Continue with signals only after that. */
	publish_event(rmp);

	return; /* do not take the default action */

  default:
	panic("handle_vfs_reply: unknown reply code: %d", call_nr);
  }

  /* Now that the process is idle again, look at pending signals */
  if ((rmp->mp_flags & (IN_USE | EXITING)) == IN_USE)
	  restart_sigs(rmp);
}



/* ============================================================================
 * SOURCE 5/98: minix4\microkernel\servers\ramdiskfs\main.c
 * Size: 4,330 bytes, Lines: 119
 * Hash: 42fa63d82739...
 * ============================================================================ */

#define _SYSTEM 1 // For libsys
#include "ramdiskfs.h"

ramdisk_file_t open_files[MAX_RAMDISK_FILES];
message m_in;
message m_out; // Defined as extern in ramdiskfs.h, so provide storage here
endpoint_t who_e;
int call_nr;

// Forward declaration for SEF startup
static void sef_local_startup(void);
static int sef_cb_init_fresh(int type, sef_init_info_t *info);
static int sef_cb_lu_state_save(int);
static int sef_cb_signal_handler(int signo, sigset_t *new_set);


int main(void) {
    sef_local_startup(); // Initialize with SEF

    printf("RamdiskFS: Starting up.\n");

    for(int i=0; i < MAX_RAMDISK_FILES; ++i) {
        open_files[i].in_use = 0;
        open_files[i].data_ptr = NULL;
        open_files[i].allocated_size = 0;
        open_files[i].current_size = 0;
        memset(open_files[i].name, 0, MAX_FILENAME_LEN);
    }

    while(1) {
        int r;
        if ((r = sef_receive_status(ANY, &m_in, &r)) != OK) { // Use sef_receive_status
            printf("RamdiskFS: sef_receive_status failed (%d)\n", r);
            continue;
        }
        who_e = m_in.m_source;
        call_nr = m_in.m_type;

        // Clear m_out before handling, to avoid stale data from previous replies
        memset(&m_out, 0, sizeof(m_out));
        m_out.m_source = SELF; // Set our endpoint as the source of the reply


        printf("RamdiskFS: Received message type %d from %d\n", call_nr, who_e);

        int result = ENOSYS; // Default error
        switch(call_nr) {
            case RAMDISKFS_OPEN:
                result = handle_open();
                break;
            case RAMDISKFS_READ:
            case RAMDISKFS_WRITE:
                result = handle_readwrite();
                break;
            case RAMDISKFS_CLOSE:
                result = handle_close();
                break;
            default:
                printf("RamdiskFS: Unknown call_nr %d\n", call_nr);
                result = EBADREQUEST; // Or ENOSYS
        }

        if (result != SUSPEND) { // SUSPEND means handler will reply later
            m_out.m_type = result; // Handler sets result (e.g. OK, EIO, or bytes_read/written)
                                   // For OPEN, OK means success, cap_idx is in m_out fields.
                                   // For READ/WRITE, result is bytes transferred or error.
                                   // For CLOSE, result is OK or error.
            if (sef_sendnb(who_e, &m_out) != OK) {
                printf("RamdiskFS: sef_sendnb to %d failed!\n", who_e);
            }
        }
    }
    return 0; // Should not reach here
}

static void sef_local_startup(void) {
    sef_setcb_init_fresh(sef_cb_init_fresh);
    sef_setcb_init_lu(sef_cb_init_fresh); // Simple restart for LU for now
    sef_setcb_init_restart(sef_cb_init_fresh);

    sef_setcb_lu_state_save(sef_cb_lu_state_save);
    sef_setcb_signal_handler(sef_cb_signal_handler);

    sef_startup();
}

static int sef_cb_init_fresh(int type, sef_init_info_t *info) {
    (void)type; (void)info;
    // Nothing special for RamdiskFS init for now beyond main() zeroing
    // and global variable initialization.
    printf("RamdiskFS: SEF Initialized (type %d)\n", type);
    return OK;
}

static int sef_cb_lu_state_save(int UNUSED(state)) {
    // RamdiskFS is stateless beyond its in-memory file representation for now.
    // No specific state saving needed for live update beyond what SEF does.
    // If we had persistent state or needed complex cleanup/reinit, it'd go here.
    return OK;
}

static int sef_cb_signal_handler(int signo, sigset_t *UNUSED(new_set)) {
    printf("RamdiskFS: Received signal %d\n", signo);
    if (signo == SIGTERM) {
        // Perform cleanup if necessary, e.g., free allocated memory
        for(int i=0; i < MAX_RAMDISK_FILES; ++i) {
            if (open_files[i].in_use && open_files[i].data_ptr != NULL) {
                // FIXME TODO: Replace with Exokernel memory free call
                // exo_free_mem_pages_placeholder(open_files[i].data_ptr, open_files[i].allocated_size);
                free(open_files[i].data_ptr); // Placeholder for Phase 0.5
                open_files[i].in_use = 0;
            }
        }
        printf("RamdiskFS: Terminating on SIGTERM.\n");
        sef_exit(0); // Graceful exit
    }
    return OK; // Other signals ignored for now
}



/* ============================================================================
 * SOURCE 6/98: minix4\microkernel\servers\rs\main.c
 * Size: 33,627 bytes, Lines: 919
 * Hash: 90c0571b9003...
 * ============================================================================ */

/* Reincarnation Server.  This servers starts new system services and detects
 * they are exiting.   In case of errors, system services can be restarted.  
 * The RS server periodically checks the status of all registered services
 * services to see whether they are still alive.   The system services are 
 * expected to periodically send a heartbeat message. 
 * 
 * Changes:
 *   Nov 22, 2009: rewrite of boot process (Cristiano Giuffrida)
 *   Jul 22, 2005: Created  (Jorrit N. Herder)
 */
#include "inc.h"
#include <fcntl.h>
#include "kernel/const.h"
#include "kernel/type.h"
#include "kernel/proc.h"

/* Declare some local functions. */
static void boot_image_info_lookup( endpoint_t endpoint, struct
	boot_image *image, struct boot_image **ip, struct boot_image_priv **pp,
	struct boot_image_sys **sp, struct boot_image_dev **dp);
static void catch_boot_init_ready(endpoint_t endpoint);
static void get_work(message *m_ptr, int *status_ptr);

/* SEF functions and variables. */
static void sef_local_startup(void);
static int sef_cb_init_fresh(int type, sef_init_info_t *info);
static int sef_cb_init_restart(int type, sef_init_info_t *info);
static int sef_cb_init_lu(int type, sef_init_info_t *info);
static int sef_cb_init_response(message *m_ptr);
static int sef_cb_lu_response(message *m_ptr);
static void sef_cb_signal_handler(int signo);
static int sef_cb_signal_manager(endpoint_t target, int signo);


/*===========================================================================*
 *				main                                         *
 *===========================================================================*/
int main(void)
{
/* This is the main routine of this service. The main loop consists of 
 * three major activities: getting new work, processing the work, and
 * sending the reply. The loop never terminates, unless a panic occurs.
 */
  message m;					/* request message */
  int ipc_status;				/* status code */
  int call_nr, who_e,who_p;			/* call number and caller */
  int result;                 			/* result to return */
  int s;

  /* SEF local startup. */
  sef_local_startup();
  
  if (OK != (s=sys_getmachine(&machine)))
	  panic("couldn't get machine info: %d", s);

  /* Main loop - get work and do it, forever. */         
  while (TRUE) {              
      /* Perform sensitive background operations when RS is idle. */
      rs_idle_period();

      /* Wait for request message. */
      get_work(&m, &ipc_status);
      who_e = m.m_source;
      if(rs_isokendpt(who_e, &who_p) != OK) {
          panic("message from bogus source: %d", who_e);
      }

      call_nr = m.m_type;

      /* Now determine what to do.  Four types of requests are expected:
       * - Heartbeat messages (notifications from registered system services)
       * - System notifications (synchronous alarm)
       * - User requests (control messages to manage system services)
       * - Ready messages (reply messages from registered services)
       */

      /* Notification messages are control messages and do not need a reply.
       * These include heartbeat messages and system notifications.
       */
      if (is_ipc_notify(ipc_status)) {
          switch (who_p) {
          case CLOCK:
	      do_period(&m);			/* check services status */
	      continue;
	  default:				/* heartbeat notification */
	      if (rproc_ptr[who_p] != NULL) {	/* mark heartbeat time */ 
		  rproc_ptr[who_p]->r_alive_tm = m.m_notify.timestamp;
            // ADDED FOR PHASE 0.25 DEMO:
            if (rproc_ptr[who_p]->r_pub->endpoint == PM_PROC_NR) {
                printf("RS: Heartbeat from PM (PID %d, EP %d). Current PM Epoch in RS: %u\n",
                       rproc_ptr[who_p]->r_pid, PM_PROC_NR, rproc_ptr[who_p]->r_epoch);
            }
	      } else {
		  printf("RS: warning: got unexpected notify message from %d\n",
		      m.m_source);
	      }
	  }
      }

      /* If we get this far, this is a normal request.
       * Handle the request and send a reply to the caller. 
       */
      else {
          /* Handler functions are responsible for permission checking. */
          switch(call_nr) {
          /* User requests. */
	  case RS_UP:		result = do_up(&m);		break;
          case RS_DOWN: 	result = do_down(&m); 		break;
          case RS_REFRESH: 	result = do_refresh(&m); 	break;
          case RS_RESTART: 	result = do_restart(&m); 	break;
          case RS_SHUTDOWN: 	result = do_shutdown(&m); 	break;
          case RS_UPDATE: 	result = do_update(&m); 	break;
          case RS_CLONE: 	result = do_clone(&m); 		break;
	  case RS_UNCLONE: 	result = do_unclone(&m);	break;
          case RS_EDIT: 	result = do_edit(&m); 		break;
	  case RS_SYSCTL:	result = do_sysctl(&m);		break;
	  case RS_FI:	result = do_fi(&m);		break;
          case RS_GETSYSINFO:  result = do_getsysinfo(&m);     break;
	  case RS_LOOKUP:	result = do_lookup(&m);		break;
	  /* Ready messages. */
	  case RS_INIT: 	result = do_init_ready(&m); 	break;
	  case RS_LU_PREPARE: 	result = do_upd_ready(&m); 	break;
      case RS_DEBUG_RESTART_SERVICE_RQ: {
            // This message comes from the KERNEL, triggered by SYS_DEBUG_RS_RESTART_PM
            // m_in.m1_i1 contains the endpoint of the service to "restart" (PM_PROC_NR)
            endpoint_t service_to_restart_ep = m_in.m1_i1;
            int service_to_restart_p = _ENDPOINT_P(service_to_restart_ep);
            struct rproc *rp_to_restart = NULL;

            if (rs_isokendpt(service_to_restart_ep, &service_to_restart_p) == OK) {
                rp_to_restart = rproc_ptr[service_to_restart_p];
            }

            if (rp_to_restart != NULL && (rp_to_restart->r_flags & RS_IN_USE)) {
                // Increment epoch
                rp_to_restart->r_epoch++;
                if (rp_to_restart->r_epoch == 0) rp_to_restart->r_epoch = 1; // Handle wrap

                printf("RS: DEBUG: Simulating restart for %s (EP %d), new epoch %u.\n",
                       rp_to_restart->r_pub->label, service_to_restart_ep, rp_to_restart->r_epoch);

                // Call the function to notify kernel of new epoch
                // rs_kernel_update_epoch() was defined in manager.c
                rs_kernel_update_epoch(rp_to_restart->r_pub->endpoint, rp_to_restart->r_epoch);

                result = OK;
            } else {
                printf("RS: DEBUG: Service EP %d not found or not in use for simulated restart.\n",
                       service_to_restart_ep);
                result = ESRCH;
            }
            // This is a request from KERNEL (SYSTEM), reply to it.
            // The kernel's do_debug_rs_restart_pm used mini_send (asynchronous from KERNEL's perspective),
            // so RS should not reply to KERNEL for this specific debug message type,
            // as KERNEL is not blocked waiting for a reply on this path.
            // If KERNEL had used a true sendrec, a reply would be needed.
            // For now, we assume KERNEL is not waiting. So, set result to EDONTREPLY.
            result = EDONTREPLY; // Kernel (SYSTEM task) typically doesn't expect replies for such notifies.
                                 // If it did a sendrec_kern, this would be different.
            break;
      }
          default: 
              printf("RS: warning: got unexpected request %d from %d\n",
                  m.m_type, m_in.m_source); // Corrected to use m_in.m_source
              result = ENOSYS;
          }

          /* Finally send reply message, unless disabled. */
          if (result != EDONTREPLY) {
	      m.m_type = result;
              reply(who_e, NULL, &m);
          }
      }
  }
}

/*===========================================================================*
 *			       sef_local_startup			     *
 *===========================================================================*/
static void sef_local_startup()
{
  /* Register init callbacks. */
  sef_setcb_init_fresh(sef_cb_init_fresh);
  sef_setcb_init_restart(sef_cb_init_restart);
  sef_setcb_init_lu(sef_cb_init_lu);

  /* Register response callbacks. */
  sef_setcb_init_response(sef_cb_init_response);
  sef_setcb_lu_response(sef_cb_lu_response);

  /* Register signal callbacks. */
  sef_setcb_signal_handler(sef_cb_signal_handler);
  sef_setcb_signal_manager(sef_cb_signal_manager);

  /* Let SEF perform startup. */
  sef_startup();
}

/*===========================================================================*
 *		            sef_cb_init_fresh                                *
 *===========================================================================*/
static int sef_cb_init_fresh(int UNUSED(type), sef_init_info_t *UNUSED(info))
{
/* Initialize the reincarnation server. */
  struct boot_image *ip;
  int s,i;
  int nr_image_srvs, nr_image_priv_srvs, nr_uncaught_init_srvs;
  struct rproc *rp;
  struct rproc *replica_rp;
  struct rprocpub *rpub;
  struct boot_image image[NR_BOOT_PROCS];
  struct boot_image_priv *boot_image_priv;
  struct boot_image_sys *boot_image_sys;
  struct boot_image_dev *boot_image_dev;
  int pid, replica_pid;
  endpoint_t replica_endpoint;
  int ipc_to;
  int *calls;
  int all_c[] = { ALL_C, NULL_C };
  int no_c[] = {  NULL_C };

  /* See if we run in verbose mode. */
  env_parse("rs_verbose", "d", 0, &rs_verbose, 0, 1);

  if ((s = sys_getinfo(GET_HZ, &system_hz, sizeof(system_hz), 0, 0)) != OK)
	  panic("Cannot get system timer frequency\n");

  /* Initialize the global init descriptor. */
  rinit.rproctab_gid = cpf_grant_direct(ANY, (vir_bytes) rprocpub,
      sizeof(rprocpub), CPF_READ);
  if(!GRANT_VALID(rinit.rproctab_gid)) {
      panic("unable to create rprocpub table grant: %d", rinit.rproctab_gid);
  }

  /* Initialize some global variables. */
  RUPDATE_INIT();
  shutting_down = FALSE;

  /* Get a copy of the boot image table. */
  if ((s = sys_getimage(image)) != OK) {
      panic("unable to get copy of boot image table: %d", s);
  }

  /* Determine the number of system services in the boot image table. */
  nr_image_srvs = 0;
  for(i=0;i<NR_BOOT_PROCS;i++) {
      ip = &image[i];

      /* System services only. */
      if(iskerneln(_ENDPOINT_P(ip->endpoint))) {
          continue;
      }
      nr_image_srvs++;
  }

  /* Determine the number of entries in the boot image priv table and make sure
   * it matches the number of system services in the boot image table.
   */
  nr_image_priv_srvs = 0;
  for (i=0; boot_image_priv_table[i].endpoint != NULL_BOOT_NR; i++) {
      boot_image_priv = &boot_image_priv_table[i];

      /* System services only. */
      if(iskerneln(_ENDPOINT_P(boot_image_priv->endpoint))) {
          continue;
      }
      nr_image_priv_srvs++;
  }
  if(nr_image_srvs != nr_image_priv_srvs) {
	panic("boot image table and boot image priv table mismatch");
  }

  /* Reset the system process table. */
  for (rp=BEG_RPROC_ADDR; rp<END_RPROC_ADDR; rp++) {
      rp->r_flags = 0;
      rp->r_init_err = ERESTART;
      rp->r_pub = &rprocpub[rp - rproc];
      rp->r_pub->in_use = FALSE;
      rp->r_pub->old_endpoint = NONE;
      rp->r_pub->new_endpoint = NONE;
  }

  /* Initialize the system process table in 4 steps, each of them following
   * the appearance of system services in the boot image priv table.
   * - Step 1: set priviliges, sys properties, and dev properties (if any)
   * for every system service.
   */
  for (i=0; boot_image_priv_table[i].endpoint != NULL_BOOT_NR; i++) {
      boot_image_priv = &boot_image_priv_table[i];

      /* System services only. */
      if(iskerneln(_ENDPOINT_P(boot_image_priv->endpoint))) {
          continue;
      }

      /* Lookup the corresponding entries in other tables. */
      boot_image_info_lookup(boot_image_priv->endpoint, image,
          &ip, NULL, &boot_image_sys, &boot_image_dev);
      rp = &rproc[boot_image_priv - boot_image_priv_table];
      rpub = rp->r_pub;

      /*
       * Set privileges.
       */
      /* Get label. */
      strcpy(rpub->label, boot_image_priv->label);

      /* Force a static priv id for system services in the boot image. */
      rp->r_priv.s_id = static_priv_id(
          _ENDPOINT_P(boot_image_priv->endpoint));
      
      /* Initialize privilege bitmaps and signal manager. */
      rp->r_priv.s_flags = boot_image_priv->flags;          /* priv flags */
      rp->r_priv.s_init_flags = SRV_OR_USR(rp, SRV_I, USR_I); /* init flags */
      rp->r_priv.s_trap_mask= SRV_OR_USR(rp, SRV_T, USR_T); /* traps */
      ipc_to = SRV_OR_USR(rp, SRV_M, USR_M);                /* targets */
      fill_send_mask(&rp->r_priv.s_ipc_to, ipc_to == ALL_M);
      rp->r_priv.s_sig_mgr= SRV_OR_USR(rp, SRV_SM, USR_SM); /* sig mgr */
      rp->r_priv.s_bak_sig_mgr = NONE;                      /* backup sig mgr */
      
      /* Initialize kernel call mask bitmap. */
      calls = SRV_OR_USR(rp, SRV_KC, USR_KC) == ALL_C ? all_c : no_c;
      fill_call_mask(calls, NR_SYS_CALLS,
          rp->r_priv.s_k_call_mask, KERNEL_CALL, TRUE);

      /* Set the privilege structure. RS and VM are exceptions and are already
       * running.
       */
      if(boot_image_priv->endpoint != RS_PROC_NR &&
         boot_image_priv->endpoint != VM_PROC_NR) {
          if ((s = sys_privctl(ip->endpoint, SYS_PRIV_SET_SYS, &(rp->r_priv)))
              != OK) {
              panic("unable to set privilege structure: %d", s);
          }
      }

      /* Synch the privilege structure with the kernel. */
      if ((s = sys_getpriv(&(rp->r_priv), ip->endpoint)) != OK) {
          panic("unable to synch privilege structure: %d", s);
      }

      /*
       * Set sys properties.
       */
      rpub->sys_flags = boot_image_sys->flags;        /* sys flags */

      /*
       * Set dev properties.
       */
      rpub->dev_nr = boot_image_dev->dev_nr;          /* major device number */

      /* Build command settings. Also set the process name. */
      strlcpy(rp->r_cmd, ip->proc_name, sizeof(rp->r_cmd));
      rp->r_script[0]= '\0';
      build_cmd_dep(rp);

      strlcpy(rpub->proc_name, ip->proc_name, sizeof(rpub->proc_name));

      /* Initialize vm call mask bitmap. */
      calls = SRV_OR_USR(rp, SRV_VC, USR_VC) == ALL_C ? all_c : no_c;
      fill_call_mask(calls, NR_VM_CALLS, rpub->vm_call_mask, VM_RQ_BASE, TRUE);

      /* Scheduling parameters. */
      rp->r_scheduler = SRV_OR_USR(rp, SRV_SCH, USR_SCH);
      rp->r_priority = SRV_OR_USR(rp, SRV_Q, USR_Q);
      rp->r_quantum = SRV_OR_USR(rp, SRV_QT, USR_QT);

      /* Get some settings from the boot image table. */
      rpub->endpoint = ip->endpoint;

      /* Set some defaults. */
      rp->r_old_rp = NULL;                     /* no old version yet */
      rp->r_new_rp = NULL;                     /* no new version yet */
      rp->r_prev_rp = NULL;                    /* no prev replica yet */
      rp->r_next_rp = NULL;                    /* no next replica yet */
      rp->r_uid = 0;                           /* root */
      rp->r_check_tm = 0;                      /* not checked yet */
      rp->r_alive_tm = getticks();             /* currently alive */
      rp->r_stop_tm = 0;                       /* not exiting yet */
      rp->r_asr_count = 0;                     /* no ASR updates yet */
      rp->r_restarts = 0;                      /* no restarts so far */
      rp->r_period = 0;                        /* no period yet */
      rp->r_exec = NULL;                       /* no in-memory copy yet */
      rp->r_exec_len = 0;

      /* Mark as in use and active. */
      rp->r_flags = RS_IN_USE | RS_ACTIVE;
      rproc_ptr[_ENDPOINT_P(rpub->endpoint)]= rp;
      rpub->in_use = TRUE;
  }

  /* - Step 2: allow every system service in the boot image to run. */
  nr_uncaught_init_srvs = 0;
  for (i=0; boot_image_priv_table[i].endpoint != NULL_BOOT_NR; i++) {
      boot_image_priv = &boot_image_priv_table[i];

      /* System services only. */
      if(iskerneln(_ENDPOINT_P(boot_image_priv->endpoint))) {
          continue;
      }

      /* Lookup the corresponding slot in the system process table. */
      rp = &rproc[boot_image_priv - boot_image_priv_table];
      rpub = rp->r_pub;

      /* RS/VM are already running as we speak. */
      if(boot_image_priv->endpoint == RS_PROC_NR ||
         boot_image_priv->endpoint == VM_PROC_NR) {
          if ((s = init_service(rp, SEF_INIT_FRESH, rp->r_priv.s_init_flags)) != OK) {
              panic("unable to initialize %d: %d", boot_image_priv->endpoint, s);
          }
          /* VM will still send an RS_INIT message, though. */
          if (boot_image_priv->endpoint != RS_PROC_NR) {
              nr_uncaught_init_srvs++;
          }
          continue;
      }

      /* Allow the service to run. */
      if ((s = sched_init_proc(rp)) != OK) {
          panic("unable to initialize scheduling: %d", s);
      }
      if ((s = sys_privctl(rpub->endpoint, SYS_PRIV_ALLOW, NULL)) != OK) {
          panic("unable to initialize privileges: %d", s);
      }

      /* Initialize service. We assume every service will always get
       * back to us here at boot time.
       */
      if(boot_image_priv->flags & SYS_PROC) {
          if ((s = init_service(rp, SEF_INIT_FRESH, rp->r_priv.s_init_flags)) != OK) {
              panic("unable to initialize service: %d", s);
          }
          if(rpub->sys_flags & SF_SYNCH_BOOT) {
              /* Catch init ready message now to synchronize. */
              catch_boot_init_ready(rpub->endpoint);
          }
          else {
              /* Catch init ready message later. */
              nr_uncaught_init_srvs++;
          }
      }
  }

  /* - Step 3: let every system service complete initialization by
   * catching all the init ready messages left.
   */
  while(nr_uncaught_init_srvs) {
      catch_boot_init_ready(ANY);
      nr_uncaught_init_srvs--;
  }

  /* - Step 4: all the system services in the boot image are now running.
   * Complete the initialization of the system process table in collaboration
   * with other system services.
   */
  for (i=0; boot_image_priv_table[i].endpoint != NULL_BOOT_NR; i++) {
      boot_image_priv = &boot_image_priv_table[i];

      /* System services only. */
      if(iskerneln(_ENDPOINT_P(boot_image_priv->endpoint))) {
          continue;
      }

      /* Lookup the corresponding slot in the system process table. */
      rp = &rproc[boot_image_priv - boot_image_priv_table];
      rpub = rp->r_pub;

      /* Get pid from PM. */
      rp->r_pid = getnpid(rpub->endpoint);
      if(rp->r_pid < 0) {
          panic("unable to get pid: %d", rp->r_pid);
      }
  }

  /* Set alarm to periodically check service status. */
  if (OK != (s=sys_setalarm(RS_DELTA_T, 0)))
      panic("couldn't set alarm: %d", s);

  /* Phase 0.25, Step 3 Integration: Ensure PM's initial epoch (1) is registered with the kernel. */
  struct rproc *pm_rp = rproc_ptr[_ENDPOINT_P(PM_PROC_NR)];
  if (pm_rp && (pm_rp->r_flags & RS_IN_USE)) {
      if (pm_rp->r_epoch == 0) {
          // This case should ideally not be hit if alloc_slot correctly set it to 1.
          // If r_epoch is 0 here, it means it wasn't initialized to 1 by alloc_slot
          // or init_slot for some reason for PM.
          printf("RS: WARNING: PM's initial r_epoch was 0 in sef_cb_init_fresh, forcing to 1 before kernel update.\n");
          pm_rp->r_epoch = 1;
      }
      // Now call rs_kernel_update_epoch, which is defined in manager.c
      // The first argument to rs_kernel_update_epoch is the service endpoint,
      // which is PM_PROC_NR. The second is the epoch.
      printf("RS: INFO: Registering PM's (EP %d) initial epoch %u with kernel via rs_kernel_update_epoch.\n",
             PM_PROC_NR, pm_rp->r_epoch);
      rs_kernel_update_epoch(PM_PROC_NR, pm_rp->r_epoch);
  } else {
      // This would be a critical failure, as PM is essential.
      panic("RS: PM process (EP %d) not found or not in use at the end of sef_cb_init_fresh when trying to update its epoch with kernel!", PM_PROC_NR);
  }

  // Phase 0.5, Step 6 Integration: Ensure RamdiskFS's initial epoch is registered with the kernel.
  // This assumes RAMDISKFS_PROC_NR is defined and RamdiskFS might be a boot service.
  // If it's started dynamically via RS_UP, its epoch will be handled by start_service/clone_slot.
  struct rproc *ramdiskfs_rp = rproc_ptr[_ENDPOINT_P(RAMDISKFS_PROC_NR)];
  if (ramdiskfs_rp && (ramdiskfs_rp->r_flags & RS_IN_USE) &&
      (ramdiskfs_rp->r_pub->endpoint == RAMDISKFS_PROC_NR)) { // Double check endpoint match
      if (ramdiskfs_rp->r_epoch == 0) {
          ramdiskfs_rp->r_epoch = 1;
          printf("RS: WARNING: RamdiskFS's (EP %d) r_epoch was 0, forcing to 1 for initial kernel update.\n", RAMDISKFS_PROC_NR);
      }
      printf("RS: INFO: Calling rs_kernel_update_epoch for RamdiskFS (EP %d) with initial epoch %u.\n",
             RAMDISKFS_PROC_NR, ramdiskfs_rp->r_epoch);
      rs_kernel_update_epoch(RAMDISKFS_PROC_NR, ramdiskfs_rp->r_epoch);
  } else {
      // If RamdiskFS is not a static boot service, this is not an error here.
      // It would be started by RS_UP later, and its epoch handled there.
      printf("RS: INFO: RamdiskFS (EP %d) not found as a static boot service, will be managed dynamically if started by RS_UP.\n", RAMDISKFS_PROC_NR);
  }

#if USE_LIVEUPDATE
  /* Now create a new RS instance and let the current
   * instance live update into the replica. Clone RS' own slot first.
   */
  rp = rproc_ptr[_ENDPOINT_P(RS_PROC_NR)];
  if((s = clone_slot(rp, &replica_rp)) != OK) {
      panic("unable to clone current RS instance: %d", s);
  }

  /* Fork a new RS instance with root:wheel. */
  pid = srv_fork(0, 0);
  if(pid < 0) {
      panic("unable to fork a new RS instance: %d", pid);
  }
  replica_pid = pid ? pid : getpid();
  if ((s = getprocnr(replica_pid, &replica_endpoint)) != 0)
	panic("unable to get replica endpoint: %d", s);
  replica_rp->r_pid = replica_pid;
  replica_rp->r_pub->endpoint = replica_endpoint;

  if(pid == 0) {
      /* New RS instance running. */

      /* Live update the old instance into the new one. */
      s = update_service(&rp, &replica_rp, RS_SWAP, 0);
      if(s != OK) {
          panic("unable to live update RS: %d", s);
      }
      cpf_reload();

      /* Clean up the old RS instance, the new instance will take over. */
      cleanup_service(rp);

      /* Ask VM to pin memory for the new RS instance. */
      if((s = vm_memctl(RS_PROC_NR, VM_RS_MEM_PIN, 0, 0)) != OK) {
          panic("unable to pin memory for the new RS instance: %d", s);
      }
  }
  else {
      /* Old RS instance running. */

      /* Set up privileges for the new instance and let it run. */
      s = sys_privctl(replica_endpoint, SYS_PRIV_SET_SYS, &(replica_rp->r_priv));
      if(s != OK) {
          panic("unable to set privileges for the new RS instance: %d", s);
      }
      if ((s = sched_init_proc(replica_rp)) != OK) {
          panic("unable to initialize RS replica scheduling: %d", s);
      }
      s = sys_privctl(replica_endpoint, SYS_PRIV_YIELD, NULL);
      if(s != OK) {
          panic("unable to yield control to the new RS instance: %d", s);
      }
      NOT_REACHABLE;
  }
#endif /* USE_LIVEUPDATE */

  return(OK);
}

/*===========================================================================*
 *		            sef_cb_init_restart                              *
 *===========================================================================*/
static int sef_cb_init_restart(int type, sef_init_info_t *info)
{
/* Restart the reincarnation server. */
  int r;
  struct rproc *old_rs_rp, *new_rs_rp;

  assert(info->endpoint == RS_PROC_NR);

  /* Perform default state transfer first. */
  r = SEF_CB_INIT_RESTART_STATEFUL(type, info);
  if(r != OK) {
      printf("SEF_CB_INIT_RESTART_STATEFUL failed: %d\n", r);
      return r;
  }

  /* New RS takes over. */
  old_rs_rp = rproc_ptr[_ENDPOINT_P(RS_PROC_NR)];
  new_rs_rp = rproc_ptr[_ENDPOINT_P(info->old_endpoint)];
  if(rs_verbose)
      printf("RS: %s is the new RS after restart\n", srv_to_string(new_rs_rp));

  /* If an update was in progress, end it. */
  if(SRV_IS_UPDATING(old_rs_rp)) {
      end_update(ERESTART, RS_REPLY);
  }

  /* Update the service into the replica. */
  r = update_service(&old_rs_rp, &new_rs_rp, RS_DONTSWAP, 0);
  if(r != OK) {
      printf("update_service failed: %d\n", r);
      return r;
  }

  /* Initialize the new RS instance. */
  r = init_service(new_rs_rp, SEF_INIT_RESTART, 0);
  if(r != OK) {
      printf("init_service failed: %d\n", r);
      return r;
  }

  /* Reschedule a synchronous alarm for the next period. */
  if (OK != (r=sys_setalarm(RS_DELTA_T, 0)))
      panic("couldn't set alarm: %d", r);

  return OK;
}

/*===========================================================================*
 *		              sef_cb_init_lu                                 *
 *===========================================================================*/
static int sef_cb_init_lu(int type, sef_init_info_t *info)
{
/* Start a new version of the reincarnation server. */
  int r;
  struct rproc *old_rs_rp, *new_rs_rp;

  assert(info->endpoint == RS_PROC_NR);

  /* Perform default state transfer first. */
  sef_setcb_init_restart(SEF_CB_INIT_RESTART_STATEFUL);
  r = SEF_CB_INIT_LU_DEFAULT(type, info);
  if(r != OK) {
      printf("SEF_CB_INIT_LU_DEFAULT failed: %d\n", r);
      return r;
  }

  /* New RS takes over. */
  old_rs_rp = rproc_ptr[_ENDPOINT_P(RS_PROC_NR)];
  new_rs_rp = rproc_ptr[_ENDPOINT_P(info->old_endpoint)];
  if(rs_verbose)
      printf("RS: %s is the new RS after live update\n",
          srv_to_string(new_rs_rp));

  /* Update the service into the replica. */
  r = update_service(&old_rs_rp, &new_rs_rp, RS_DONTSWAP, 0);
  if(r != OK) {
      printf("update_service failed: %d\n", r);
      return r;
  }

  /* Check if everything is as expected. */
  assert(RUPDATE_IS_UPDATING());
  assert(RUPDATE_IS_INITIALIZING());
  assert(rupdate.num_rpupds > 0);
  assert(rupdate.num_init_ready_pending > 0);

  return OK;
}

/*===========================================================================*
*			    sef_cb_init_response			     *
 *===========================================================================*/
int sef_cb_init_response(message *m_ptr)
{
  int r;

  /* Return now if RS initialization failed. */
  r = m_ptr->m_rs_init.result;
  if(r != OK) {
      return r;
  }

  /* Simulate an RS-to-RS init message. */
  r = do_init_ready(m_ptr);

  /* Assume everything is OK if EDONTREPLY was returned. */
  if(r == EDONTREPLY) {
      r = OK;
  }
  return r;
}

/*===========================================================================*
*			     sef_cb_lu_response				     *
 *===========================================================================*/
int sef_cb_lu_response(message *m_ptr)
{
  int r;

  /* Simulate an RS-to-RS update ready message. */
  r = do_upd_ready(m_ptr);

  /* If we get this far, we didn't get updated for some reason. Report error. */
  if(r == EDONTREPLY) {
      r = EGENERIC;
  }
  return r;
}

/*===========================================================================*
 *		            sef_cb_signal_handler                            *
 *===========================================================================*/
static void sef_cb_signal_handler(int signo)
{
  /* Check for known signals, ignore anything else. */
  switch(signo) {
      case SIGCHLD:
          do_sigchld();
      break;
      case SIGTERM:
          do_shutdown(NULL);
      break;
  }
}

/*===========================================================================*
 *		            sef_cb_signal_manager                            *
 *===========================================================================*/
static int sef_cb_signal_manager(endpoint_t target, int signo)
{
/* Process system signal on behalf of the kernel. */
  int target_p;
  struct rproc *rp;
  message m;

  /* Lookup slot. */
  if(rs_isokendpt(target, &target_p) != OK || rproc_ptr[target_p] == NULL) {
      if(rs_verbose)
          printf("RS: ignoring spurious signal %d for process %d\n",
              signo, target);
      return OK; /* clear the signal */
  }
  rp = rproc_ptr[target_p];

  /* Don't bother if a termination signal has already been processed. */
  if((rp->r_flags & RS_TERMINATED) && !(rp->r_flags & RS_EXITING)) {
      return EDEADEPT; /* process is gone */
  }

  /* Ignore external signals for inactive service instances. */
  if( !(rp->r_flags & RS_ACTIVE) && !(rp->r_flags & RS_EXITING)) {
      if(rs_verbose)
          printf("RS: ignoring signal %d for inactive %s\n",
              signo, srv_to_string(rp));
      return OK; /* clear the signal */
  }

  if(rs_verbose)
      printf("RS: %s got %s signal %d\n", srv_to_string(rp),
          SIGS_IS_TERMINATION(signo) ? "termination" : "non-termination",signo);

  /* Print stacktrace if necessary. */
  if(SIGS_IS_STACKTRACE(signo)) {
       sys_diagctl_stacktrace(target);
  }

  /* In case of termination signal handle the event. */
  if(SIGS_IS_TERMINATION(signo)) {
      rp->r_flags |= RS_TERMINATED;
      terminate_service(rp);
      rs_idle_period();

      return EDEADEPT; /* process is now gone */
  }
  /* Never deliver signals to VM. */
  if (rp->r_pub->endpoint == VM_PROC_NR) {
      return OK;
  }

  /* Translate every non-termination signal into a message. */
  m.m_type = SIGS_SIGNAL_RECEIVED;
  m.m_pm_lsys_sigs_signal.num = signo;
  rs_asynsend(rp, &m, 1);

  return OK; /* signal has been delivered */
}

/*===========================================================================*
 *                         boot_image_info_lookup                            *
 *===========================================================================*/
static void boot_image_info_lookup(endpoint, image, ip, pp, sp, dp)
endpoint_t endpoint;
struct boot_image *image;
struct boot_image **ip;
struct boot_image_priv **pp;
struct boot_image_sys **sp;
struct boot_image_dev **dp;
{
/* Lookup entries in boot image tables. */
  int i;

  /* When requested, locate the corresponding entry in the boot image table
   * or panic if not found.
   */
  if(ip) {
      for (i=0; i < NR_BOOT_PROCS; i++) {
          if(image[i].endpoint == endpoint) {
              *ip = &image[i];
              break;
          }
      }
      if(i == NR_BOOT_PROCS) {
          panic("boot image table lookup failed");
      }
  }

  /* When requested, locate the corresponding entry in the boot image priv table
   * or panic if not found.
   */
  if(pp) {
      for (i=0; boot_image_priv_table[i].endpoint != NULL_BOOT_NR; i++) {
          if(boot_image_priv_table[i].endpoint == endpoint) {
              *pp = &boot_image_priv_table[i];
              break;
          }
      }
      if(i == NULL_BOOT_NR) {
          panic("boot image priv table lookup failed");
      }
  }

  /* When requested, locate the corresponding entry in the boot image sys table
   * or resort to the default entry if not found.
   */
  if(sp) {
      for (i=0; boot_image_sys_table[i].endpoint != DEFAULT_BOOT_NR; i++) {
          if(boot_image_sys_table[i].endpoint == endpoint) {
              *sp = &boot_image_sys_table[i];
              break;
          }
      }
      if(boot_image_sys_table[i].endpoint == DEFAULT_BOOT_NR) {
          *sp = &boot_image_sys_table[i];         /* accept the default entry */
      }
  }

  /* When requested, locate the corresponding entry in the boot image dev table
   * or resort to the default entry if not found.
   */
  if(dp) {
      for (i=0; boot_image_dev_table[i].endpoint != DEFAULT_BOOT_NR; i++) {
          if(boot_image_dev_table[i].endpoint == endpoint) {
              *dp = &boot_image_dev_table[i];
              break;
          }
      }
      if(boot_image_dev_table[i].endpoint == DEFAULT_BOOT_NR) {
          *dp = &boot_image_dev_table[i];         /* accept the default entry */
      }
  }
}

/*===========================================================================*
 *			      catch_boot_init_ready                          *
 *===========================================================================*/
static void catch_boot_init_ready(endpoint)
endpoint_t endpoint;
{
/* Block and catch an init ready message from the given source. */
  int r;
  int ipc_status;
  message m;
  struct rproc *rp;
  int result;

  /* Receive init ready message. */
  if ((r = sef_receive_status(endpoint, &m, &ipc_status)) != OK) {
      panic("unable to receive init reply: %d", r);
  }
  if(m.m_type != RS_INIT) {
      panic("unexpected reply from service: %d", m.m_source);
  }
  result = m.m_rs_init.result;
  rp = rproc_ptr[_ENDPOINT_P(m.m_source)];

  /* Check result. */
  if(result != OK) {
      panic("unable to complete init for service: %d", m.m_source);
  }

  /* Send a reply to unblock the service, except to VM, which sent the reply
   * asynchronously.  Synchronous replies could lead to deadlocks there.
   */
  if (m.m_source != VM_PROC_NR) {
      m.m_type = OK;
      reply(m.m_source, rp, &m);
  }

  /* Mark the slot as no longer initializing. */
  rp->r_flags &= ~RS_INITIALIZING;
  rp->r_check_tm = 0;
  rp->r_alive_tm = getticks();
}

/*===========================================================================*
 *				get_work                                     *
 *===========================================================================*/
static void get_work(m_ptr, status_ptr)
message *m_ptr;				/* pointer to message */
int *status_ptr;			/* pointer to status */
{
    int r;
    if (OK != (r=sef_receive_status(ANY, m_ptr, status_ptr)))
        panic("sef_receive_status failed: %d", r);
}




/* ============================================================================
 * SOURCE 7/98: minix4\microkernel\servers\netiso\xebec\main.c
 * Size: 9,571 bytes, Lines: 411
 * Hash: fe9e410a42c2...
 * ============================================================================ */

/* $Header: /n/fast/usr/lsrc/mach/CVS/lites/server/netiso/xebec/main.c,v 1.1.1.1 1995/03/02 21:49:58 mike Exp $ */
/* $Source: /n/fast/usr/lsrc/mach/CVS/lites/server/netiso/xebec/main.c,v $ */
/*
 * TODO:
 * rewrite the command line stuff altogether - it's kludged beyond
 * belief (as is the rest of the code...)
 *
 * DISCLAIMER DISCLAIMER DISCLAIMER
 * This code is such a kludge that I don't want to put my name on it.
 * It was a ridiculously fast hack and needs rewriting.
 * However it does work...
 */

#include <stdio.h>
#include <strings.h>
#include "malloc.h"
#include "debug.h"
#include "main.h"

int	debug[128];

int lineno = 1;

FILE *statefile, *actfile, *eventfile_h, *statevalfile;
FILE *infile, *astringfile;
char *Transfilename;
char *astringfile_name = DEBUGFILE;
char *actfile_name = ACTFILE;
char *statefile_name = STATEFILE;
char *statevalfile_name = STATEVALFILE;
char *eventfile_h_name = EVENTFILE_H;
int print_trans = 0;
int print_protoerrs = 0;
int pgoption = 0;
char kerneldirname[50] = "\0";

char protocol[50];

char *synonyms[] = {
	"EVENT",
	"PCB",
	0
};

usage(a)
char *a;
{
	fprintf(stderr, 
	"usage: %s <transition file> {-D<debug options>} <other options>\n",
		a);
	fprintf(stderr, "\t<other options> is any combination of:\n");
	fprintf(stderr, "\t\t-A<action file name>\n");
	fprintf(stderr, "\t\t-E<event file name>\n");
	fprintf(stderr, "\t\t-S<state file name>\n");
	fprintf(stderr, "\t\t-I<initial values file name>\n");
	fprintf(stderr, "\t\t-X<debugging file name>\n");
	fprintf(stderr, "\t\t-K<directory name>\n");
	fprintf(stderr, 
	"\tThese names do NOT include the suffices (.c, .h)\n");
	fprintf(stderr, 
	"\t\t-D<options> to turn on debug options for xebec itself\n");
	fprintf(stderr, "\t-<nn> for levels of debugging output\n");
	fprintf(stderr, "\t\t<nn> ranges from 1 to 3, 1 is default(everything)\n");
	fprintf(stderr, "\t\t-T to print transitions\n");
	fprintf(stderr, "\t\t-e to print list of combinations of\n");
	fprintf(stderr, "\t\t\t [event,old_state] that produce protocol errors\n");
	fprintf(stderr, "\t\t-g include profiling code in driver\n");
	Exit(-1);
}

openfiles(proto)
register char *proto;
{
	register char *junk;
	register int lenp = strlen(proto);

	IFDEBUG(b)
		fprintf(OUT, "openfiles %s\n",proto);
	ENDDEBUG

#define HEADER Header
#define SOURCE Source
#define DOIT(X)\
	/* GAG */\
	junk = Malloc( 2 + lenp + strlen(X/**/_name) );\
	(void) sprintf(junk, "%s_", proto);\
	X/**/_name = strcat(junk, X/**/_name);\
	X = fopen(X/**/_name, "w");\
	if((X)==(FILE *)0)\
	{ fprintf(stderr,"Open failed: %s\n", "X"); Exit(-1); }\
	fprintf(X, "/* %cHeader%c */\n",'$', '$' );\
	fprintf(X, "/* %cSource%c */\n",'$', '$' );

	DOIT(eventfile_h);

	IFDEBUG(X)
#ifdef DEBUG
		DOIT(astringfile);
#endif DEBUG
		fprintf(astringfile, 
				"#ifndef _NFILE\n#include <stdio.h>\n#endif _NFILE\n" );
	ENDDEBUG

	DOIT(statevalfile);
	DOIT(statefile);
	DOIT(actfile);
	fprintf(actfile,
		"#ifndef lint\nstatic char *rcsid = \"$Header/**/$\";\n#endif lint\n");

	if(pgoption)
		putdriver(actfile, 15);
	else 
		putdriver(actfile, 14);

	FakeFilename(actfile, Transfilename, lineno);
	putdriver(actfile, 1);
	FakeFilename(actfile, Transfilename, lineno);
	putdriver(actfile, 12);
	fprintf(actfile, "#include \"%s%s\"\n", kerneldirname, statevalfile_name);
	FakeFilename(actfile, Transfilename, lineno);
	putdriver(actfile, 2);

	initsets(eventfile_h, statefile);
}

includecode(file, f)
FILE *file;
register char *f;
{
	register int count=1;
	static char o='{';
	static char c='}';
	register char *g;

	IFDEBUG(a)
		fprintf(stdout, "including: %s, f=0x%x", f,f);
	ENDDEBUG
	g = ++f;
	while(count>0) {
		if(*g == o) count++;
		if(*g == c) count--;
		g++;
	}
	*(--g) = '\0';
	IFDEBUG(a)
		fprintf(stdout, "derived: %s", f);
	ENDDEBUG
	fprintf(file, "%s", f);
	FakeFilename(file, Transfilename, lineno);
}

putincludes()
{
	FakeFilename(actfile, Transfilename, lineno);
	fprintf(actfile, "\n#include \"%s%s\"\n", kerneldirname, eventfile_h_name);
	IFDEBUG(X)
		if( !debug['K'] )
			fprintf(actfile, "\n#include \"%s\"\n", astringfile_name);
			/* not in kernel mode */
	ENDDEBUG
	FakeFilename(actfile, Transfilename, lineno);
}

main(argc, argv)
int argc;
char *argv[];
{
	register int i = 2;
	extern char *strcpy();
	int start, finish;
	extern int FirstEventAttribute;
	extern int Nevents, Nstates;

	start = time(0);
	if(argc < 2) {
		usage(argv[0]);
	}
	IFDEBUG(a)
		fprintf(stdout, "infile = %s\n",argv[1]);
	ENDDEBUG
	Transfilename = argv[1];
	infile = fopen(argv[1], "r");

	if(argc > 2) while(i < argc) {
		register int j=0;
		char c;
		char *name;

		if(argv[i][j] == '-') j++;
		switch(c = argv[i][j]) {

		/* GROT */
		case 'A':
			name = &argv[i][++j];
			actfile_name = Malloc( strlen(name)+4);
			actfile_name =  (char *)strcpy(actfile_name,name);
#ifdef LINT
			name =
#endif LINT
			strcat(actfile_name, ".c");
			fprintf(stdout, "debugging file is %s\n",actfile_name);
			break;
		case 'K':
			debug[c]=1;
			fprintf(OUT, "option %c file %s\n",c, &argv[i][j+1]);
			(void) strcpy(kerneldirname,&argv[i][++j]);
			break;
		case 'X':
			debug[c]=1;
			name = &argv[i][++j];
			astringfile_name = Malloc( strlen(name)+4);
			astringfile_name =  (char *)strcpy(astringfile_name,name);
#ifdef LINT
			name =
#endif LINT
			strcat(astringfile_name, ".c");
			fprintf(OUT, "option %c, astringfile name %s\n",c, name);
			break;
		case 'E':
			name = &argv[i][++j];
			eventfile_h_name = Malloc( strlen(name)+4);
			eventfile_h_name =  (char *)strcpy(eventfile_h_name,name);
#ifdef LINT
			name =
#endif LINT
			strcat(eventfile_h_name, ".h");
			fprintf(stdout, "event files is %s\n",eventfile_h_name);
			break;
		case 'I':
			name = &argv[i][++j];
			statevalfile_name = Malloc( strlen(name)+4 );
			statevalfile_name =  (char *)strcpy(statevalfile_name,name);
#ifdef LINT
			name =
#endif LINT
			strcat(statevalfile_name, ".init");
			fprintf(stdout, "state table initial values file is %s\n",statevalfile_name);
			break;
		case 'S':
			name = &argv[i][++j];
			statefile_name = Malloc( strlen(name)+4);
			statefile_name =  (char *)strcpy(statefile_name,name);
#ifdef LINT
			name =
#endif LINT
			strcat(statefile_name, ".h");
			fprintf(stdout, "state file is %s\n",statefile_name);
			break;
		/* END GROT */
		case '1':
		case '2':
		case '3':
			debug['X']= (int)argv[i][j] - (int) '0';
			fprintf(OUT, "value of debug['X'] is 0x%x,%d\n", debug['X'],
				debug['X']);
			break;
		case 'D':
			while( c = argv[i][++j] ) {
				if(c ==  'X') {
					fprintf(OUT, "debugging on");
					if(debug['X']) fprintf(OUT,
						" - overrides any -%d flags used\n", debug['X']);
				}
				debug[c]=1;
				fprintf(OUT, "debug %c\n",c);
			}
			break;
		case 'g':
			pgoption = 1;
			fprintf(stdout, "Profiling\n");
			break;
		case 'e':
			print_protoerrs = 1;
			fprintf(stdout, "Protocol error table:\n");
			break;

		case 'T':
			print_trans = 1;
			fprintf(stdout, "Transitions:\n");
			break;
		default:
			usage(argv[0]);
			break;
		}
		i++;
	}
	if(kerneldirname[0]) {
		char *c;
#ifdef notdef
		if(debug['X']) {
			fprintf(OUT, "Option K overrides option X\n");
			debug['X'] = 0;
		}
#endif notdef
		if(strlen(kerneldirname)<1) {
			fprintf(OUT, "K option: dir name too short!\n");
			exit(-1);
		}
		/* add ../name/ */
		c = (char *) Malloc(strlen(kerneldirname)+6) ;
		if(c <= (char *)0) {
			fprintf(OUT, "Cannot allocate %d bytes for kerneldirname\n",
				strlen(kerneldirname + 6) );
			fprintf(OUT, "kerneldirname is %s\n", kerneldirname  );
			exit(-1);
		}
		*c = '.';
		*(c+1) = '.';
		*(c+2) = '/';
		(void) strcat(c, kerneldirname);
		(void) strcat(c, "/\0");
		strcpy(kerneldirname, c);
	}

	init_alloc();

	(void) llparse();

	/* {{ */
	if( !FirstEventAttribute )
		fprintf(eventfile_h, "\t}ev_union;\n");
	fprintf(eventfile_h, "};/* end struct event */\n");
	fprintf(eventfile_h, "\n#define %s_NEVENTS 0x%x\n", protocol, Nevents);
	fprintf(eventfile_h,
		"\n#define ATTR(X)ev_union.%s/**/X/**/\n",EV_PREFIX);
	(void) fclose(eventfile_h);

	/* {{ */ fprintf(actfile, "\t}\nreturn 0;\n}\n"); /* end switch; end action() */
	dump_predtable(actfile);

	putdriver(actfile, 3);
	IFDEBUG(X)
		if(!debug['K'])
			putdriver(actfile, 4);
	ENDDEBUG
	putdriver(actfile, 6);
	IFDEBUG(X)
		/*
		putdriver(actfile, 10);
		*/
		if(debug['K']) { 
			putdriver(actfile, 11);
		} else {
			switch(debug['X']) {
			case 1:
			default:
				putdriver(actfile, 7);
				break;
			case 2:
				putdriver(actfile, 13);
				break;
			case 3:
				break;
			}
		}
	ENDDEBUG
	putdriver(actfile, 8);
	(void) fclose(actfile);
	IFDEBUG(X) 
		/* { */ 
		fprintf(astringfile, "};\n");
		(void) fclose(astringfile);
	ENDDEBUG

	(void) fclose(statevalfile);

	fprintf(statefile, "\n#define %s_NSTATES 0x%x\n", protocol, Nstates);
	(void) fclose(statefile);

	finish = time(0);
	fprintf(stdout, "%d seconds\n", finish - start);
	if( print_protoerrs ) 
		printprotoerrs();
}

int transno = 0;

Exit(n)
{
	fprintf(stderr, "Error at line %d\n",lineno);
	if(transno) fprintf(stderr, "Transition number %d\n",transno);
	(void) fflush(stdout);
	(void) fflush(statefile);
	(void) fflush(eventfile_h);
	(void) fflush(actfile);
	exit(n);
}

syntax() 
{
	static char *synt[] = {
		"*PROTOCOL <string>\n",
		"*PCB <string> <optional: SYNONYM synonymstring>\n",
		"<optional: *INCLUDE {\n<C source>\n} >\n",
		"*STATES <string>\n",
		"*EVENTS <string>\n",
		"*TRANSITIONS <string>\n",
	};
}
	
FakeFilename(outfile, name, l)
FILE *outfile;
char *name;
int l;
{
	/*
	doesn't work
	fprintf(outfile, "\n\n\n\n# line %d \"%s\"\n", l, name);
	*/
}



/* ============================================================================
 * SOURCE 8/98: minix4\libos_legacy\ed\main.c
 * Size: 32,493 bytes, Lines: 1,434
 * Hash: 01339fc04ec8...
 * ============================================================================ */

/*	$NetBSD: main.c,v 1.30 2018/06/18 14:56:24 christos Exp $	*/

/* main.c: This file contains the main control and user-interface routines
   for the ed line editor. */
/*-
 * Copyright (c) 1993 Andrew Moore, Talke Studio.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/cdefs.h>
#ifndef lint
__COPYRIGHT(
"@(#) Copyright (c) 1993 Andrew Moore, Talke Studio.\
 All rights reserved.");
#endif /* not lint */

#ifndef lint
#if 0
static char *rcsid = "@(#)main.c,v 1.1 1994/02/01 00:34:42 alm Exp";
#else
__RCSID("$NetBSD: main.c,v 1.30 2018/06/18 14:56:24 christos Exp $");
#endif
#endif /* not lint */

/*
 * CREDITS
 *
 *	This program is based on the editor algorithm described in
 *	Brian W. Kernighan and P. J. Plauger's book "Software Tools 
 *	in Pascal," Addison-Wesley, 1981.
 *
 *	The buffering algorithm is attributed to Rodney Ruddock of
 *	the University of Guelph, Guelph, Ontario.
 *
 *	The cbc.c encryption code is adapted from
 *	the bdes program by Matt Bishop of Dartmouth College,
 *	Hanover, NH.
 *
 */

#include <sys/ioctl.h>
#include <sys/wait.h>
#include <termios.h>
#include <ctype.h>
#include <setjmp.h>
#include <pwd.h>

#include "ed.h"


#ifdef _POSIX_SOURCE
sigjmp_buf env;
#else
jmp_buf env;
#endif

/* static buffers */
char stdinbuf[1];		/* stdin buffer */
char *shcmd;			/* shell command buffer */
int shcmdsz;			/* shell command buffer size */
int shcmdi;			/* shell command buffer index */
char *ibuf;			/* ed command-line buffer */
int ibufsz;			/* ed command-line buffer size */
char *ibufp;			/* pointer to ed command-line buffer */

/* global flags */
int des = 0;			/* if set, use crypt(3) for i/o */
int garrulous = 0;		/* if set, print all error messages */
int isbinary;			/* if set, buffer contains ASCII NULs */
int isglobal;			/* if set, doing a global command */
int modified;			/* if set, buffer modified since last write */
int mutex = 0;			/* if set, signals set "sigflags" */
int red = 0;			/* if set, restrict shell/directory access */
int ere = 0;			/* if set, use extended regexes */
int scripted = 0;		/* if set, suppress diagnostics */
int secure = 0;			/* is set, ! is not allowed */
int sigflags = 0;		/* if set, signals received while mutex set */
int sigactive = 0;		/* if set, signal handlers are enabled */

char old_filename[MAXPATHLEN + 1] = "";	/* default filename */
long current_addr;		/* current address in editor buffer */
long addr_last;			/* last address in editor buffer */
int lineno;			/* script line number */
const char *prompt;			/* command-line prompt */
const char *dps = "*";		/* default command-line prompt */


static const char usage[] = "Usage: %s [-] [-ESsx] [-p string] [name]\n";

/* ed: line editor */
int
main(int ac, char *av[])
{
	int c, n;
	long status = 0;
	volatile int argc = ac;
	char ** volatile argv = av;

	red = (n = strlen(argv[0])) > 2 && argv[0][n - 3] == 'r';
top:
	while ((c = getopt(argc, argv, "p:sxES")) != -1)
		switch(c) {
		case 'p':				/* set prompt */
			prompt = optarg;
			break;
		case 's':				/* run script */
			scripted = 1;
			break;
		case 'x':				/* use crypt */
#ifdef DES
			des = get_keyword();
#else
			fprintf(stderr, "crypt unavailable\n?\n");
#endif
			break;

		case 'E':
			ere = REG_EXTENDED;
			break;
		case 'S':				/* ! is not allowed */
			secure = 1;
			break;
		default:
			fprintf(stderr, usage, getprogname());
			exit(1);
			/* NOTREACHED */
		}
	argv += optind;
	argc -= optind;
	if (argc && **argv == '-') {
		scripted = 1;
		if (argc > 1) {
			optind = 1;
			goto top;
		}
		argv++;
		argc--;
	}
	/* assert: reliable signals! */
#ifdef SIGWINCH
	handle_winch(SIGWINCH);
	if (isatty(0)) signal(SIGWINCH, handle_winch);
#endif
	signal(SIGHUP, signal_hup);
	signal(SIGQUIT, SIG_IGN);
	signal(SIGINT, signal_int);
#ifdef _POSIX_SOURCE
	if ((status = sigsetjmp(env, 1)) != 0)
#else
	if ((status = setjmp(env)) != 0)
#endif
	{
		fputs("\n?\n", stderr);
		seterrmsg("interrupt");
	} else {
		init_buffers();
		sigactive = 1;			/* enable signal handlers */
		if (argc && **argv && is_legal_filename(*argv)) {
			if (read_file(*argv, 0) < 0 && !isatty(0))
				quit(2);
			else if (**argv != '!')
				strlcpy(old_filename, *argv,
				    sizeof(old_filename) - 2);
		} else if (argc) {
			fputs("?\n", stderr);
			if (**argv == '\0')
				seterrmsg("invalid filename");
			if (!isatty(0))
				quit(2);
		}
	}
	for (;;) {
		if (status < 0 && garrulous)
			fprintf(stderr, "%s\n", errmsg);
		if (prompt) {
			printf("%s", prompt);
			fflush(stdout);
		}
		if ((n = get_tty_line()) < 0) {
			status = ERR;
			continue;
		} else if (n == 0) {
			if (modified && !scripted) {
				fputs("?\n", stderr);
				seterrmsg("warning: file modified");
				if (!isatty(0)) {
					if (garrulous) {
						fprintf(stderr,
						    "script, line %d: %s\n",
						    lineno, errmsg);
					}
					quit(2);
				}
				clearerr(stdin);
				modified = 0;
				status = EMOD;
				continue;
			} else
				quit(0);
		} else if (ibuf[n - 1] != '\n') {
			/* discard line */
			seterrmsg("unexpected end-of-file");
			clearerr(stdin);
			status = ERR;
			continue;
		}
		isglobal = 0;
		if ((status = extract_addr_range()) >= 0 &&
		    (status = exec_command()) >= 0) {
			if (status == 0)
				continue;
			status = display_lines(current_addr, current_addr,
			    status);
			if (status >= 0)
				continue;
		}
		switch (status) {
		case EOF:
			quit(0);
		case EMOD:
			modified = 0;
			fputs("?\n", stderr);		/* give warning */
			seterrmsg("warning: file modified");
			if (!isatty(0)) {
				if (garrulous) {
					fprintf(stderr,
					    "script, line %d: %s\n",
					    lineno, errmsg);
				}
				quit(2);
			}
			break;
		case FATAL:
			if (garrulous) {
				if (!isatty(0)) {
					fprintf(stderr,
					    "script, line %d: %s\n",
					    lineno, errmsg);
				} else {
					fprintf(stderr, "%s\n", errmsg);
				}
			}
			quit(3);
		default:
			fputs("?\n", stderr);
			if (!isatty(0)) {
				if (garrulous) {
					fprintf(stderr, "script, line %d: %s\n",
					    lineno, errmsg);
				}
				quit(2);
			}
			break;
		}
	}
	/* NOTREACHED */
}

long first_addr, second_addr, addr_cnt;

/* extract_addr_range: get line addresses from the command buffer until an 
   illegal address is seen; return status */
int
extract_addr_range(void)
{
	long addr;

	addr_cnt = 0;
	first_addr = second_addr = current_addr;
	while ((addr = next_addr()) >= 0) {
		addr_cnt++;
		first_addr = second_addr;
		second_addr = addr;
		if (*ibufp != ',' && *ibufp != ';')
			break;
		else if (*ibufp++ == ';')
			current_addr = addr;
	}
	if ((addr_cnt = min(addr_cnt, 2)) == 1 || second_addr != addr)
		first_addr = second_addr;
	return (addr == ERR) ? ERR : 0;
}


#define	SKIP_BLANKS() while (isspace((unsigned char)*ibufp) && *ibufp != '\n') \
	ibufp++

#define MUST_BE_FIRST() \
	if (!first) { seterrmsg("invalid address"); return ERR; }

/*  next_addr: return the next line address in the command buffer */
long
next_addr(void)
{
	char *hd;
	long addr = current_addr;
	long n;
	int first = 1;
	int c;

	SKIP_BLANKS();
	for (hd = ibufp;; first = 0)
		switch (c = *ibufp) {
		case '+':
		case '\t':
		case ' ':
		case '-':
		case '^':
			ibufp++;
			SKIP_BLANKS();
			if (isdigit((unsigned char)*ibufp)) {
				STRTOL(n, ibufp);
				addr += (c == '-' || c == '^') ? -n : n;
			} else if (!isspace((unsigned char)c))
				addr += (c == '-' || c == '^') ? -1 : 1;
			break;
		case '0': case '1': case '2':
		case '3': case '4': case '5':
		case '6': case '7': case '8': case '9':
			MUST_BE_FIRST();
			STRTOL(addr, ibufp);
			break;
		case '.':
		case '$':
			MUST_BE_FIRST();
			ibufp++;
			addr = (c == '.') ? current_addr : addr_last;
			break;
		case '/':
		case '?':
			MUST_BE_FIRST();
			if ((addr = get_matching_node_addr(
			    get_compiled_pattern(), c == '/')) < 0)
				return ERR;
			else if (c == *ibufp)
				ibufp++;
			break;
		case '\'':
			MUST_BE_FIRST();
			ibufp++;
			if ((addr = get_marked_node_addr((unsigned char)*ibufp++)) < 0)
				return ERR;
			break;
		case '%':
		case ',':
		case ';':
			if (first) {
				ibufp++;
				addr_cnt++;
				second_addr = (c == ';') ? current_addr : 1;
				addr = addr_last;
				break;
			}
			/* FALL THROUGH */
		default:
			if (ibufp == hd)
				return EOF;
			else if (addr < 0 || addr_last < addr) {
				seterrmsg("invalid address");
				return ERR;
			} else
				return addr;
		}
	/* NOTREACHED */
}


#ifdef BACKWARDS
/* GET_THIRD_ADDR: get a legal address from the command buffer */
#define GET_THIRD_ADDR(addr) \
{ \
	long ol1, ol2; \
\
	ol1 = first_addr, ol2 = second_addr; \
	if (extract_addr_range() < 0) \
		return ERR; \
	else if (addr_cnt == 0) { \
		seterrmsg("destination expected"); \
		return ERR; \
	} else if (second_addr < 0 || addr_last < second_addr) { \
		seterrmsg("invalid address"); \
		return ERR; \
	} \
	addr = second_addr; \
	first_addr = ol1, second_addr = ol2; \
}
#else	/* BACKWARDS */
/* GET_THIRD_ADDR: get a legal address from the command buffer */
#define GET_THIRD_ADDR(addr) \
{ \
	long ol1, ol2; \
\
	ol1 = first_addr, ol2 = second_addr; \
	if (extract_addr_range() < 0) \
		return ERR; \
	if (second_addr < 0 || addr_last < second_addr) { \
		seterrmsg("invalid address"); \
		return ERR; \
	} \
	addr = second_addr; \
	first_addr = ol1, second_addr = ol2; \
}
#endif


/* GET_COMMAND_SUFFIX: verify the command suffix in the command buffer */
#define GET_COMMAND_SUFFIX() { \
	int done = 0; \
	do { \
		switch(*ibufp) { \
		case 'p': \
			gflag |= GPR, ibufp++; \
			break; \
		case 'l': \
			gflag |= GLS, ibufp++; \
			break; \
		case 'n': \
			gflag |= GNP, ibufp++; \
			break; \
		default: \
			done++; \
		} \
	} while (!done); \
	if (*ibufp++ != '\n') { \
		seterrmsg("invalid command suffix"); \
		return ERR; \
	} \
}


/* sflags */
#define SGG 001		/* complement previous global substitute suffix */
#define SGP 002		/* complement previous print suffix */
#define SGR 004		/* use last regex instead of last pat */
#define SGF 010		/* repeat last substitution */

int patlock = 0;	/* if set, pattern not freed by get_compiled_pattern() */

long rows = 22;		/* scroll length: ws_row - 2 */

/* exec_command: execute the next command in command buffer; return print
   request, if any */
int
exec_command(void)
{
	static pattern_t *pat = NULL;
	static int sgflag = 0;
	static long sgnum = 0;

	pattern_t *tpat;
	char *fnp;
	int gflag = 0;
	int sflags = 0;
	long addr = 0;
	int n = 0;
	int c;

	SKIP_BLANKS();
	switch(c = *ibufp++) {
	case 'a':
		GET_COMMAND_SUFFIX();
		if (!isglobal) clear_undo_stack();
		if (append_lines(second_addr) < 0)
			return ERR;
		break;
	case 'c':
		if (check_addr_range(current_addr, current_addr) < 0)
			return ERR;
		GET_COMMAND_SUFFIX();
		if (!isglobal) clear_undo_stack();
		if (delete_lines(first_addr, second_addr) < 0 ||
		    append_lines(current_addr) < 0)
			return ERR;
		break;
	case 'd':
		if (check_addr_range(current_addr, current_addr) < 0)
			return ERR;
		GET_COMMAND_SUFFIX();
		if (!isglobal) clear_undo_stack();
		if (delete_lines(first_addr, second_addr) < 0)
			return ERR;
		else if ((addr = INC_MOD(current_addr, addr_last)) != 0)
			current_addr = addr;
		break;
	case 'e':
		if (modified && !scripted)
			return EMOD;
		/* fall through */
	case 'E':
		if (addr_cnt > 0) {
			seterrmsg("unexpected address");
			return ERR;
		} else if (!isspace((unsigned char)*ibufp)) {
			seterrmsg("unexpected command suffix");
			return ERR;
		} else if ((fnp = get_filename()) == NULL)
			return ERR;
		GET_COMMAND_SUFFIX();
		if (delete_lines(1, addr_last) < 0)
			return ERR;
		clear_undo_stack();
		if (close_sbuf() < 0)
			return ERR;
		else if (open_sbuf() < 0)
			return FATAL;
		if (*fnp && *fnp != '!') strlcpy(old_filename, fnp,
			sizeof(old_filename) - 2);
#ifdef BACKWARDS
		if (*fnp == '\0' && *old_filename == '\0') {
			seterrmsg("no current filename");
			return ERR;
		}
#endif
		if (read_file(*fnp ? fnp : old_filename, 0) < 0)
			return ERR;
		clear_undo_stack();
		modified = 0;
		u_current_addr = u_addr_last = -1;
		break;
	case 'f':
		if (addr_cnt > 0) {
			seterrmsg("unexpected address");
			return ERR;
		} else if (!isspace((unsigned char)*ibufp)) {
			seterrmsg("unexpected command suffix");
			return ERR;
		} else if ((fnp = get_filename()) == NULL)
			return ERR;
		else if (*fnp == '!') {
			seterrmsg("invalid redirection");
			return ERR;
		}
		GET_COMMAND_SUFFIX();
		if (*fnp) strlcpy(old_filename, fnp, sizeof(old_filename) - 2);
		printf("%s\n", strip_escapes(old_filename));
		break;
	case 'g':
	case 'v':
	case 'G':
	case 'V':
		if (isglobal) {
			seterrmsg("cannot nest global commands");
			return ERR;
		} else if (check_addr_range(1, addr_last) < 0)
			return ERR;
		else if (build_active_list(c == 'g' || c == 'G') < 0)
			return ERR;
		else if ((n = (c == 'G' || c == 'V')) != 0)
			GET_COMMAND_SUFFIX();
		isglobal++;
		if (exec_global(n, gflag) < 0)
			return ERR; 
		break;
	case 'h':
		if (addr_cnt > 0) {
			seterrmsg("unexpected address");
			return ERR;
		}
		GET_COMMAND_SUFFIX();
		if (*errmsg) fprintf(stderr, "%s\n", errmsg);
		break;
	case 'H':
		if (addr_cnt > 0) {
			seterrmsg("unexpected address");
			return ERR;
		}
		GET_COMMAND_SUFFIX();
		if ((garrulous = 1 - garrulous) && *errmsg)
			fprintf(stderr, "%s\n", errmsg);
		break;
	case 'i':
		if (second_addr == 0) {
			seterrmsg("invalid address");
			return ERR;
		}
		GET_COMMAND_SUFFIX();
		if (!isglobal) clear_undo_stack();
		if (append_lines(second_addr - 1) < 0)
			return ERR;
		break;
	case 'j':
		if (check_addr_range(current_addr, current_addr + 1) < 0)
			return ERR;
		GET_COMMAND_SUFFIX();
		if (!isglobal) clear_undo_stack();
		if (first_addr != second_addr &&
		    join_lines(first_addr, second_addr) < 0)
			return ERR;
		break;
	case 'k':
		c = *ibufp++;
		if (second_addr == 0) {
			seterrmsg("invalid address");
			return ERR;
		}
		GET_COMMAND_SUFFIX();
		if (mark_line_node(get_addressed_line_node(second_addr), (unsigned char)c) < 0)
			return ERR;
		break;
	case 'l':
		if (check_addr_range(current_addr, current_addr) < 0)
			return ERR;
		GET_COMMAND_SUFFIX();
		if (display_lines(first_addr, second_addr, gflag | GLS) < 0)
			return ERR;
		gflag = 0;
		break;
	case 'm':
		if (check_addr_range(current_addr, current_addr) < 0)
			return ERR;
		GET_THIRD_ADDR(addr);
		if (first_addr <= addr && addr < second_addr) {
			seterrmsg("invalid destination");
			return ERR;
		}
		GET_COMMAND_SUFFIX();
		if (!isglobal) clear_undo_stack();
		if (move_lines(addr) < 0)
			return ERR;
		break;
	case 'n':
		if (check_addr_range(current_addr, current_addr) < 0)
			return ERR;
		GET_COMMAND_SUFFIX();
		if (display_lines(first_addr, second_addr, gflag | GNP) < 0)
			return ERR;
		gflag = 0;
		break;
	case 'p':
		if (check_addr_range(current_addr, current_addr) < 0)
			return ERR;
		GET_COMMAND_SUFFIX();
		if (display_lines(first_addr, second_addr, gflag | GPR) < 0)
			return ERR;
		gflag = 0;
		break;
	case 'P':
		if (addr_cnt > 0) {
			seterrmsg("unexpected address");
			return ERR;
		}
		GET_COMMAND_SUFFIX();
		prompt = prompt ? NULL : optarg ? optarg : dps;
		break;
	case 'q':
	case 'Q':
		if (addr_cnt > 0) {
			seterrmsg("unexpected address");
			return ERR;
		}
		GET_COMMAND_SUFFIX();
		gflag =  (modified && !scripted && c == 'q') ? EMOD : EOF;
		break;
	case 'r':
		if (!isspace((unsigned char)*ibufp)) {
			seterrmsg("unexpected command suffix");
			return ERR;
		} else if (addr_cnt == 0)
			second_addr = addr_last;
		if ((fnp = get_filename()) == NULL)
			return ERR;
		GET_COMMAND_SUFFIX();
		if (!isglobal) clear_undo_stack();
		if (*old_filename == '\0' && *fnp != '!')
			strlcpy(old_filename, fnp, sizeof(old_filename) - 2);
#ifdef BACKWARDS
		if (*fnp == '\0' && *old_filename == '\0') {
			seterrmsg("no current filename");
			return ERR;
		}
#endif
		if ((addr = read_file(*fnp ? fnp : old_filename, second_addr)) < 0)
			return ERR;
		else if (addr && addr != addr_last)
			modified = 1;
		break;
	case 's':
		do {
			switch(*ibufp) {
			case '\n':
				sflags |=SGF;
				break;
			case 'g':
				sflags |= SGG;
				ibufp++;
				break;
			case 'p':
				sflags |= SGP;
				ibufp++;
				break;
			case 'r':
				sflags |= SGR;
				ibufp++;
				break;
			case '0': case '1': case '2': case '3': case '4': 
			case '5': case '6': case '7': case '8': case '9':
				STRTOL(sgnum, ibufp);
				sflags |= SGF;
				sgflag &= ~GSG;		/* override GSG */
				break;
			default:
				if (sflags) {
					seterrmsg("invalid command suffix");
					return ERR;
				}
			}
		} while (sflags && *ibufp != '\n');
		if (sflags && !pat) {
			seterrmsg("no previous substitution");
			return ERR;
		} else if (sflags & SGG)
			sgnum = 0;		/* override numeric arg */
		if (*ibufp != '\n' && *(ibufp + 1) == '\n') {
			seterrmsg("invalid pattern delimiter");
			return ERR;
		}
		tpat = pat;
		SPL1();
		if ((!sflags || (sflags & SGR)) &&
		    (tpat = get_compiled_pattern()) == NULL) {
		 	SPL0();
			return ERR;
		} else if (tpat != pat) {
			if (pat) {
				regfree(pat);
				free(pat);
			}
			pat = tpat;
			patlock = 1;		/* reserve pattern */
		}
		SPL0();
		if (!sflags && extract_subst_tail(&sgflag, &sgnum) < 0)
			return ERR;
		else if (isglobal)
			sgflag |= GLB;
		else
			sgflag &= ~GLB;
		if (sflags & SGG)
			sgflag ^= GSG;
		if (sflags & SGP)
			sgflag ^= GPR, sgflag &= ~(GLS | GNP);
		do {
			switch(*ibufp) {
			case 'p':
				sgflag |= GPR, ibufp++;
				break;
			case 'l':
				sgflag |= GLS, ibufp++;
				break;
			case 'n':
				sgflag |= GNP, ibufp++;
				break;
			default:
				n++;
			}
		} while (!n);
		if (check_addr_range(current_addr, current_addr) < 0)
			return ERR;
		GET_COMMAND_SUFFIX();
		if (!isglobal) clear_undo_stack();
		if (search_and_replace(pat, sgflag, sgnum) < 0)
			return ERR;
		break;
	case 't':
		if (check_addr_range(current_addr, current_addr) < 0)
			return ERR;
		GET_THIRD_ADDR(addr);
		GET_COMMAND_SUFFIX();
		if (!isglobal) clear_undo_stack();
		if (copy_lines(addr) < 0)
			return ERR;
		break;
	case 'u':
		if (addr_cnt > 0) {
			seterrmsg("unexpected address");
			return ERR;
		}
		GET_COMMAND_SUFFIX();
		if (pop_undo_stack() < 0)
			return ERR;
		break;
	case 'w':
	case 'W':
		if ((n = *ibufp) == 'q' || n == 'Q') {
			gflag = EOF;
			ibufp++;
		}
		if (!isspace((unsigned char)*ibufp)) {
			seterrmsg("unexpected command suffix");
			return ERR;
		} else if ((fnp = get_filename()) == NULL)
			return ERR;
		if (addr_cnt == 0 && !addr_last)
			first_addr = second_addr = 0;
		else if (check_addr_range(1, addr_last) < 0)
			return ERR;
		GET_COMMAND_SUFFIX();
		if (*old_filename == '\0' && *fnp != '!')
			strlcpy(old_filename, fnp, sizeof(old_filename) - 2);
#ifdef BACKWARDS
		if (*fnp == '\0' && *old_filename == '\0') {
			seterrmsg("no current filename");
			return ERR;
		}
#endif
		if ((addr = write_file(*fnp ? fnp : old_filename, 
		    (c == 'W') ? "a" : "w", first_addr, second_addr)) < 0)
			return ERR;
		else if (addr == addr_last)
			modified = 0;
		else if (modified && !scripted && n == 'q')
			gflag = EMOD;
		break;
	case 'x':
		if (addr_cnt > 0) {
			seterrmsg("unexpected address");
			return ERR;
		}
		GET_COMMAND_SUFFIX();
#ifdef DES
		des = get_keyword();
#else
		seterrmsg("crypt unavailable");
		return ERR;
#endif
		break;
	case 'z':
#ifdef BACKWARDS
		if (check_addr_range(first_addr = 1, current_addr + 1) < 0)
#else
		if (check_addr_range(first_addr = 1, current_addr + !isglobal) < 0)
#endif
			return ERR;
		else if ('0' < *ibufp && *ibufp <= '9')
			STRTOL(rows, ibufp);
		GET_COMMAND_SUFFIX();
		if (display_lines(second_addr, min(addr_last,
		    second_addr + rows), gflag) < 0)
			return ERR;
		gflag = 0;
		break;
	case '=':
		GET_COMMAND_SUFFIX();
		printf("%ld\n", addr_cnt ? second_addr : addr_last);
		break;
	case '!':
		if (addr_cnt > 0) {
			seterrmsg("unexpected address");
			return ERR;
		}
		if ((sflags = get_shell_command()) < 0)
			return ERR;
		GET_COMMAND_SUFFIX();
		if (sflags) printf("%s\n", shcmd + 1);
		system(shcmd + 1);
		if (!scripted) printf("!\n");
		break;
	case '\n':
#ifdef BACKWARDS
		if (check_addr_range(first_addr = 1, current_addr + 1) < 0
#else
		if (check_addr_range(first_addr = 1, current_addr + !isglobal) < 0
#endif
		 || display_lines(second_addr, second_addr, 0) < 0)
			return ERR;
		break;
	default:
		seterrmsg("unknown command");
		return ERR;
	}
	return gflag;
}


/* check_addr_range: return status of address range check */
int
check_addr_range(long n, long m)
{
	if (addr_cnt == 0) {
		first_addr = n;
		second_addr = m;
	}
	if (first_addr > second_addr || 1 > first_addr ||
	    second_addr > addr_last) {
		seterrmsg("invalid address");
		return ERR;
	}
	return 0;
}


/* get_matching_node_addr: return the address of the next line matching a 
   pattern in a given direction.  wrap around begin/end of editor buffer if
   necessary */
long
get_matching_node_addr(pattern_t *pat, int dir)
{
	char *s;
	long n = current_addr;
	line_t *lp;

	if (!pat) return ERR;
	do {
		if ((n = dir ? INC_MOD(n, addr_last) :
		    DEC_MOD(n, addr_last)) != 0) {
			lp = get_addressed_line_node(n);
			if ((s = get_sbuf_line(lp)) == NULL)
				return ERR;
			if (isbinary)
				NUL_TO_NEWLINE(s, lp->len);
			if (!regexec(pat, s, 0, NULL, 0))
				return n;
		}
	} while (n != current_addr);
	seterrmsg("no match");
	return  ERR;
}


/* get_filename: return pointer to copy of filename in the command buffer */
char *
get_filename(void)
{
	static char *file = NULL;
	static int filesz = 0;

	int n;

	if (*ibufp != '\n') {
		SKIP_BLANKS();
		if (*ibufp == '\n') {
			seterrmsg("invalid filename");
			return NULL;
		} else if ((ibufp = get_extended_line(&n, 1)) == NULL)
			return NULL;
		else if (*ibufp == '!') {
			ibufp++;
			if ((n = get_shell_command()) < 0)
				return NULL;
			if (n) printf("%s\n", shcmd + 1);
			return shcmd;
		} else if (n - 1 > MAXPATHLEN) {
			seterrmsg("filename too long");
			return  NULL;
		}
	}
#ifndef BACKWARDS
	else if (*old_filename == '\0') {
		seterrmsg("no current filename");
		return  NULL;
	}
#endif
	REALLOC(file, filesz, MAXPATHLEN + 1, NULL);
	for (n = 0; *ibufp != '\n';)
		file[n++] = *ibufp++;
	file[n] = '\0';
	return is_legal_filename(file) ? file : NULL;
}


/* get_shell_command: read a shell command from stdin; return substitution
   status */
int
get_shell_command(void)
{
	static char *buf = NULL;
	static int n = 0;

	char *s;			/* substitution char pointer */
	int i = 0;
	int j = 0;

	if (red || secure) {
		seterrmsg("shell access restricted");
		return ERR;
	} else if ((s = ibufp = get_extended_line(&j, 1)) == NULL)
		return ERR;
	REALLOC(buf, n, j + 1, ERR);
	buf[i++] = '!';			/* prefix command w/ bang */
	while (*ibufp != '\n')
		switch (*ibufp) {
		default:
			REALLOC(buf, n, i + 2, ERR);
			buf[i++] = *ibufp;
			if (*ibufp++ == '\\')
				buf[i++] = *ibufp++;
			break;
		case '!':
			if (s != ibufp) {
				REALLOC(buf, n, i + 1, ERR);
				buf[i++] = *ibufp++;
			}
#ifdef BACKWARDS
			else if (shcmd == NULL || *(shcmd + 1) == '\0')
#else
			else if (shcmd == NULL)
#endif
			{
				seterrmsg("no previous command");
				return ERR;
			} else {
				REALLOC(buf, n, i + shcmdi, ERR);
				for (s = shcmd + 1; s < shcmd + shcmdi;)
					buf[i++] = *s++;
				s = ibufp++;
			}
			break;
		case '%':
			if (*old_filename  == '\0') {
				seterrmsg("no current filename");
				return ERR;
			}
			j = strlen(s = strip_escapes(old_filename));
			REALLOC(buf, n, i + j, ERR);
			while (j--)
				buf[i++] = *s++;
			s = ibufp++;
			break;
		}
	REALLOC(shcmd, shcmdsz, i + 1, ERR);
	memcpy(shcmd, buf, i);
	shcmd[shcmdi = i] = '\0';
	return *s == '!' || *s == '%';
}


/* append_lines: insert text from stdin to after line n; stop when either a
   single period is read or EOF; return status */
int
append_lines(long n)
{
	int l;
	char *lp = ibuf;
	char *eot;
	undo_t *up = NULL;

	for (current_addr = n;;) {
		if (!isglobal) {
			if ((l = get_tty_line()) < 0)
				return ERR;
			else if (l == 0 || ibuf[l - 1] != '\n') {
				clearerr(stdin);
				return  l ? EOF : 0;
			}
			lp = ibuf;
		} else if (*(lp = ibufp) == '\0')
			return 0;
		else {
			while (*ibufp++ != '\n')
				;
			l = ibufp - lp;
		}
		if (l == 2 && lp[0] == '.' && lp[1] == '\n') {
			return 0;
		}
		eot = lp + l;
		SPL1();
		do {
			if ((lp = put_sbuf_line(lp)) == NULL) {
				SPL0();
				return ERR;
			} else if (up)
				up->t = get_addressed_line_node(current_addr);
			else if ((up = push_undo_stack(UADD, current_addr,
			    current_addr)) == NULL) {
				SPL0();
				return ERR;
			}
		} while (lp != eot);
		modified = 1;
		SPL0();
	}
	/* NOTREACHED */
}


/* join_lines: replace a range of lines with the joined text of those lines */
int
join_lines(long from, long to)
{
	static char *buf = NULL;
	static int n;

	char *s;
	int size = 0;
	line_t *bp, *ep;

	ep = get_addressed_line_node(INC_MOD(to, addr_last));
	bp = get_addressed_line_node(from);
	for (; bp != ep; bp = bp->q_forw) {
		if ((s = get_sbuf_line(bp)) == NULL)
			return ERR;
		REALLOC(buf, n, size + bp->len, ERR);
		memcpy(buf + size, s, bp->len);
		size += bp->len;
	}
	REALLOC(buf, n, size + 2, ERR);
	memcpy(buf + size, "\n", 2);
	if (delete_lines(from, to) < 0)
		return ERR;
	current_addr = from - 1;
	SPL1();
	if (put_sbuf_line(buf) == NULL ||
	    push_undo_stack(UADD, current_addr, current_addr) == NULL) {
		SPL0();
		return ERR;
	}
	modified = 1;
	SPL0();
	return 0;
}


/* move_lines: move a range of lines */
int
move_lines(long addr)
{
	line_t *b1, *a1, *b2, *a2;
	long n = INC_MOD(second_addr, addr_last);
	long p = first_addr - 1;
	int done = (addr == first_addr - 1 || addr == second_addr);

	SPL1();
	if (done) {
		a2 = get_addressed_line_node(n);
		b2 = get_addressed_line_node(p);
		current_addr = second_addr;
	} else if (push_undo_stack(UMOV, p, n) == NULL ||
	    push_undo_stack(UMOV, addr, INC_MOD(addr, addr_last)) == NULL) {
		SPL0();
		return ERR;
	} else {
		a1 = get_addressed_line_node(n);
		if (addr < first_addr) {
			b1 = get_addressed_line_node(p);
			b2 = get_addressed_line_node(addr);
					/* this get_addressed_line_node last! */
		} else {
			b2 = get_addressed_line_node(addr);
			b1 = get_addressed_line_node(p);
					/* this get_addressed_line_node last! */
		}
		a2 = b2->q_forw;
		REQUE(b2, b1->q_forw);
		REQUE(a1->q_back, a2);
		REQUE(b1, a1);
		current_addr = addr + ((addr < first_addr) ? 
		    second_addr - first_addr + 1 : 0);
	}
	if (isglobal)
		unset_active_nodes(b2->q_forw, a2);
	modified = 1;
	SPL0();
	return 0;
}


/* copy_lines: copy a range of lines; return status */
int
copy_lines(long addr)
{
	line_t *lp, *np = get_addressed_line_node(first_addr);
	undo_t *up = NULL;
	long n = second_addr - first_addr + 1;
	long m = 0;

	current_addr = addr;
	if (first_addr <= addr && addr < second_addr) {
		n =  addr - first_addr + 1;
		m = second_addr - addr;
	}
	for (; n > 0; n=m, m=0, np = get_addressed_line_node(current_addr + 1))
		for (; n-- > 0; np = np->q_forw) {
			SPL1();
			if ((lp = dup_line_node(np)) == NULL) {
				SPL0();
				return ERR;
			}
			add_line_node(lp);
			if (up)
				up->t = lp;
			else if ((up = push_undo_stack(UADD, current_addr,
			    current_addr)) == NULL) {
				SPL0();
				return ERR;
			}
			modified = 1;
			SPL0();
		}
	return 0;
}


/* delete_lines: delete a range of lines */
int
delete_lines(long from, long to)
{
	line_t *n, *p;

	SPL1();
	if (push_undo_stack(UDEL, from, to) == NULL) {
		SPL0();
		return ERR;
	}
	n = get_addressed_line_node(INC_MOD(to, addr_last));
	p = get_addressed_line_node(from - 1);
					/* this get_addressed_line_node last! */
	if (isglobal)
		unset_active_nodes(p->q_forw, n);
	REQUE(p, n);
	addr_last -= to - from + 1;
	current_addr = from - 1;
	modified = 1;
	SPL0();
	return 0;
}


/* display_lines: print a range of lines to stdout */
int
display_lines(long from, long to, int gflag)
{
	line_t *bp;
	line_t *ep;
	char *s;

	if (!from) {
		seterrmsg("invalid address");
		return ERR;
	}
	ep = get_addressed_line_node(INC_MOD(to, addr_last));
	bp = get_addressed_line_node(from);
	for (; bp != ep; bp = bp->q_forw) {
		if ((s = get_sbuf_line(bp)) == NULL)
			return ERR;
		if (put_tty_line(s, bp->len, current_addr = from++, gflag) < 0)
			return ERR;
	}
	return 0;
}


#define MAXMARK 26			/* max number of marks */

line_t	*mark[MAXMARK];			/* line markers */
int markno;				/* line marker count */

/* mark_line_node: set a line node mark */
int
mark_line_node(line_t *lp, int n)
{
	if (!islower(n)) {
		seterrmsg("invalid mark character");
		return ERR;
	} else if (mark[n - 'a'] == NULL)
		markno++;
	mark[n - 'a'] = lp;
	return 0;
}


/* get_marked_node_addr: return address of a marked line */
long
get_marked_node_addr(int n)
{
	if (!islower(n)) {
		seterrmsg("invalid mark character");
		return ERR;
	}
	return get_line_node_addr(mark[n - 'a']);
}


/* unmark_line_node: clear line node mark */
void
unmark_line_node(line_t *lp)
{
	int i;

	for (i = 0; markno && i < MAXMARK; i++)
		if (mark[i] == lp) {
			mark[i] = NULL;
			markno--;
		}
}


/* dup_line_node: return a pointer to a copy of a line node */
line_t *
dup_line_node(line_t *lp)
{
	line_t *np;

	if ((np = (line_t *) malloc(sizeof(line_t))) == NULL) {
		fprintf(stderr, "%s\n", strerror(errno));
		seterrmsg("out of memory");
		return NULL;
	}
	np->seek = lp->seek;
	np->len = lp->len;
	return np;
}


/* has_trailing_escape:  return the parity of escapes preceding a character
   in a string */
int
has_trailing_escape(char *s, char *t)
{
    return (s == t || *(t - 1) != '\\') ? 0 : !has_trailing_escape(s, t - 1);
}


/* strip_escapes: return copy of escaped string of at most length MAXPATHLEN */
char *
strip_escapes(const char *s)
{
	static char *file = NULL;
	static int filesz = 0;

	int i = 0;

	REALLOC(file, filesz, MAXPATHLEN + 1, NULL);
	while ((i < (filesz - 1)) &&
	       (file[i++] = (*s == '\\') != '\0' ? *++s : *s))
		s++;
	file[filesz - 1] = '\0';
	return file;
}


void
signal_hup(int signo)
{
	if (mutex)
		sigflags |= (1 << (signo - 1));
	else	handle_hup(signo);
}


void
signal_int(int signo)
{
	if (mutex)
		sigflags |= (1 << (signo - 1));
	else	handle_int(signo);
}


void
handle_hup(int signo)
{
	char *hup = NULL;		/* hup filename */
	char *s;
	int n;

	if (!sigactive)
		quit(1);
	sigflags &= ~(1 << (signo - 1));
	if (addr_last && write_file("ed.hup", "w", 1, addr_last) < 0 &&
	    (s = getenv("HOME")) != NULL &&
	    (n = strlen(s)) + 8 <= MAXPATHLEN &&	/* "ed.hup" + '/' */
	    (hup = (char *) malloc(n + 10)) != NULL) {
		strcpy(hup, s);
		if (hup[n - 1] != '/')
			hup[n] = '/', hup[n+1] = '\0';
		strcat(hup, "ed.hup");
		write_file(hup, "w", 1, addr_last);
	}
	quit(2);
}


void
handle_int(int signo)
{
	if (!sigactive)
		quit(1);
	sigflags &= ~(1 << (signo - 1));
#ifdef _POSIX_SOURCE
	siglongjmp(env, -1);
#else
	longjmp(env, -1);
#endif
}


int cols = 72;				/* wrap column */

void
handle_winch(int signo)
{
	struct winsize ws;		/* window size structure */

	sigflags &= ~(1 << (signo - 1));
	if (ioctl(0, TIOCGWINSZ, (char *) &ws) >= 0) {
		if (ws.ws_row > 2) rows = ws.ws_row - 2;
		if (ws.ws_col > 8) cols = ws.ws_col - 8;
	}
}


/* is_legal_filename: return a legal filename */
int
is_legal_filename(char *s)
{
	if (red && (*s == '!' || !strcmp(s, "..") || strchr(s, '/'))) {
		seterrmsg("shell access restricted");
		return 0;
	}
	return 1;
}



/* ============================================================================
 * SOURCE 9/98: minix4\libos_legacy\fsck_ext2fs\main.c
 * Size: 9,896 bytes, Lines: 394
 * Hash: 6cf80415bc8f...
 * ============================================================================ */

/*	$NetBSD: main.c,v 1.41 2020/04/05 15:25:39 joerg Exp $	*/

/*
 * Copyright (c) 1980, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 1997 Manuel Bouyer.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/cdefs.h>
#ifndef lint
__COPYRIGHT("@(#) Copyright (c) 1980, 1986, 1993\
 The Regents of the University of California.  All rights reserved.");
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@(#)main.c	8.2 (Berkeley) 1/23/94";
#else
__RCSID("$NetBSD: main.c,v 1.41 2020/04/05 15:25:39 joerg Exp $");
#endif
#endif /* not lint */

#include <sys/param.h>
#include <sys/time.h>
#include <sys/mount.h>
#include <ufs/ufs/ufsmount.h>
#include <ufs/ext2fs/ext2fs_dinode.h>
#include <ufs/ext2fs/ext2fs.h>
#include <fstab.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdio.h>
#include <time.h>
#include <unistd.h>
#include <signal.h>

#include "fsck.h"
#include "extern.h"
#include "fsutil.h"
#include "exitvalues.h"

struct bufarea bufhead;
struct bufarea sblk;
struct bufarea asblk;
struct bufarea *pdirbp;
struct bufarea *pbp;
struct bufarea *getdatablk(daddr_t, long);
struct m_ext2fs sblock;
struct dups *duplist;
struct dups *muldup;
struct zlncnt *zlnhead;
struct inoinfo **inphead, **inpsort;
long numdirs, listmax, inplast;
long	dev_bsize;
long	secsize;
char	nflag;
char	yflag;
int	bflag;
int	Uflag;
int	debug;
int	preen;
char	havesb;
char	skipclean;
int	fsmodified;
int	fsreadfd;
int	fswritefd;
int	rerun;
daddr_t	maxfsblock;
char	*blockmap;
ino_t	maxino;
ino_t	lastino;
char	*statemap;
u_char	*typemap;
int16_t	*lncntp;
ino_t	lfdir;
daddr_t	n_blks;
daddr_t	n_files;
struct	ext2fs_dinode zino;

static int	argtoi(int, const char *, const char *, int);
static int	checkfilesys(const char *, char *, long, int);
static void	usage(void) __dead;

int
main(int argc, char *argv[])
{
	int ch;
	int ret = FSCK_EXIT_OK;

	ckfinish = ckfini;
	sync();
	skipclean = 1;
	while ((ch = getopt(argc, argv, "b:dfm:npPqUy")) != -1) {
		switch (ch) {
		case 'b':
			skipclean = 0;
			bflag = argtoi('b', "number", optarg, 10);
			printf("Alternate super block location: %d\n", bflag);
			break;

		case 'd':
			debug++;
			break;

		case 'f':
			skipclean = 0;
			break;

		case 'm':
			lfmode = argtoi('m', "mode", optarg, 8);
			if (lfmode &~ 07777)
				errexit("bad mode to -m: %o", lfmode);
			printf("** lost+found creation mode %o\n", lfmode);
			break;

		case 'n':
			nflag++;
			yflag = 0;
			break;

		case 'p':
			preen++;
			break;

		case 'P':
			/* Progress meter not implemented. */
			break;

		case 'q':		/* Quiet not implemented */
			break;

#ifndef SMALL
		case 'U':
			Uflag++;
			break;
#endif

		case 'y':
			yflag++;
			nflag = 0;
			break;

		default:
			usage();
		}
	}

	argc -= optind;
	argv += optind;

	if (!argc)
		usage();

	if (signal(SIGINT, SIG_IGN) != SIG_IGN)
		(void)signal(SIGINT, catch);
	if (preen)
		(void)signal(SIGQUIT, catchquit);

	while (argc-- > 0) {
		int nret = checkfilesys(blockcheck(*argv++), 0, 0L, 0);
		if (ret < nret)
			ret = nret;
	}

	return returntosingle ? FSCK_EXIT_UNRESOLVED : ret;
}

static int
argtoi(int flag, const char *req, const char *str, int base)
{
	char *cp;
	int ret;

	ret = (int)strtol(str, &cp, base);
	if (cp == str || *cp)
		errexit("-%c flag requires a %s", flag, req);
	return (ret);
}

/*
 * Check the specified filesystem.
 */
/* ARGSUSED */
static int
checkfilesys(const char *filesys, char *mntpt, long auxdata, int child)
{
	daddr_t n_bfree;
	struct dups *dp;
	struct zlncnt *zlnp;
	int i;

	if (preen && child)
		(void)signal(SIGQUIT, voidquit);
	setcdevname(filesys, preen);
	if (debug && preen)
		pwarn("starting\n");
	switch (setup(filesys)) {
	case 0:
		if (preen)
			pfatal("CAN'T CHECK FILE SYSTEM.");
		/* FALLTHROUGH */
	case -1:
		return FSCK_EXIT_OK;
	}
	/*
	 * 1: scan inodes tallying blocks used
	 */
	if (preen == 0) {
		if (sblock.e2fs.e2fs_rev > E2FS_REV0) {
			printf("** Last Mounted on %s\n",
			    sblock.e2fs.e2fs_fsmnt);
		}
		if (hotroot())
			printf("** Root file system\n");
		printf("** Phase 1 - Check Blocks and Sizes\n");
	}
	pass1();

	/*
	 * 1b: locate first references to duplicates, if any
	 */
	if (duplist) {
		if (preen)
			pfatal("INTERNAL ERROR: dups with -p");
		printf("** Phase 1b - Rescan For More DUPS\n");
		pass1b();
	}

	/*
	 * 2: traverse directories from root to mark all connected directories
	 */
	if (preen == 0)
		printf("** Phase 2 - Check Pathnames\n");
	pass2();

	/*
	 * 3: scan inodes looking for disconnected directories
	 */
	if (preen == 0)
		printf("** Phase 3 - Check Connectivity\n");
	pass3();

	/*
	 * 4: scan inodes looking for disconnected files; check reference counts
	 */
	if (preen == 0)
		printf("** Phase 4 - Check Reference Counts\n");
	pass4();

	/*
	 * 5: check and repair resource counts in cylinder groups
	 */
	if (preen == 0)
		printf("** Phase 5 - Check Cyl groups\n");
	pass5();

	/*
	 * print out summary statistics
	 */
	n_bfree = sblock.e2fs.e2fs_fbcount;
		
	pwarn("%lld files, %lld used, %lld free\n",
	    (long long)n_files, (long long)n_blks, (long long)n_bfree);
	if (debug &&
		/* 9 reserved and unused inodes in FS */
	    (n_files -= maxino - 9 - sblock.e2fs.e2fs_ficount))
		printf("%lld files missing\n", (long long)n_files);
	if (debug) {
		for (i = 0; i < sblock.e2fs_ncg; i++)
			n_blks +=  cgoverhead(i);
		n_blks += sblock.e2fs.e2fs_first_dblock;
		if (n_blks -= maxfsblock - n_bfree)
			printf("%lld blocks missing\n", (long long)n_blks);
		if (duplist != NULL) {
			printf("The following duplicate blocks remain:");
			for (dp = duplist; dp; dp = dp->next)
				printf(" %lld,", (long long)dp->dup);
			printf("\n");
		}
		if (zlnhead != NULL) {
			printf("The following zero link count inodes remain:");
			for (zlnp = zlnhead; zlnp; zlnp = zlnp->next)
				printf(" %llu,",
				    (unsigned long long)zlnp->zlncnt);
			printf("\n");
		}
	}
	zlnhead = (struct zlncnt *)0;
	duplist = (struct dups *)0;
	muldup = (struct dups *)0;
	inocleanup();
	if (fsmodified) {
		time_t t;
		(void)time(&t);
		sblock.e2fs.e2fs_wtime = t;
		sblock.e2fs.e2fs_lastfsck = t;
		sbdirty();
	}
	ckfini(1);
	free(blockmap);
	free(statemap);
	free((char *)lncntp);
	if (!fsmodified)
		return FSCK_EXIT_OK;
	if (!preen)
		printf("\n***** FILE SYSTEM WAS MODIFIED *****\n");
	if (rerun)
		printf("\n***** PLEASE RERUN FSCK *****\n");
#if !defined(__minix)
	if (hotroot()) {
		struct statvfs stfs_buf;
		/*
		 * We modified the root.  Do a mount update on
		 * it, unless it is read-write, so we can continue.
		 */
		if (statvfs("/", &stfs_buf) == 0) {
			long flags = stfs_buf.f_flag;
			struct ufs_args args;

			if (flags & MNT_RDONLY) {
				args.fspec = 0;
				flags |= MNT_UPDATE | MNT_RELOAD;
				if (mount(MOUNT_EXT2FS, "/", flags,
				    &args, sizeof args) == 0)
					return FSCK_EXIT_OK;
			}
		}
		if (!preen)
			printf("\n***** REBOOT NOW *****\n");
		sync();
		return FSCK_EXIT_ROOT_CHANGED;
	}
#endif /* !defined(__minix) */
	return FSCK_EXIT_OK;
}

static void
usage(void)
{

	(void) fprintf(stderr,
	    "usage: %s [-dfnpUy] [-b block] [-m mode] filesystem ...\n",
	    getprogname());
	exit(FSCK_EXIT_USAGE);
}



/* ============================================================================
 * SOURCE 10/98: minix4\libos_legacy\ksh\main.c
 * Size: 17,700 bytes, Lines: 793
 * Hash: 5c4cdf5fa9da...
 * ============================================================================ */

/*	$NetBSD: main.c,v 1.23 2018/05/08 16:37:59 kamil Exp $	*/

/*
 * startup, main loop, environments and error handling
 */
#include <sys/cdefs.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <locale.h>
#include <time.h>

#ifndef lint
__RCSID("$NetBSD: main.c,v 1.23 2018/05/08 16:37:59 kamil Exp $");
#endif


#define	EXTERN				/* define EXTERNs in sh.h */

#include "sh.h"

extern char **environ;

/*
 * global data
 */

static void	reclaim ARGS((void));
static void	remove_temps ARGS((struct temp *tp));
static int	is_restricted ARGS((char *name));

/*
 * shell initialization
 */

static const char initifs[] = "IFS= \t\n";

static const char initsubs[] = "${PS2=> } ${PS3=#? } ${PS4=+ }";

static const char version_param[] =
#ifdef KSH
	"KSH_VERSION"
#else /* KSH */
	"SH_VERSION"
#endif /* KSH */
	;

static const char *const initcoms [] = {
	"typeset", "-x", "SHELL", "PATH", "HOME", NULL,
	"typeset", "-r", version_param, NULL,
	"typeset", "-i", "PPID", NULL,
	"typeset", "-i", "OPTIND=1", NULL,
#ifdef KSH
	"eval", "typeset -i RANDOM MAILCHECK=\"${MAILCHECK-600}\" SECONDS=\"${SECONDS-0}\" TMOUT=\"${TMOUT-0}\"", NULL,
#endif /* KSH */
	"alias",
	 /* Standard ksh aliases */
	  "hash=alias -t",	/* not "alias -t --": hash -r needs to work */
	  "type=whence -v",
#ifdef JOBS
	  "stop=kill -STOP",
	  "suspend=kill -STOP $$",
#endif
#ifdef KSH
	  "autoload=typeset -fu",
	  "functions=typeset -f",
# ifdef HISTORY
	  "history=fc -l",
# endif /* HISTORY */
	  "integer=typeset -i",
	  "nohup=nohup ",
	  "local=typeset",
	  "r=fc -e -",
#endif /* KSH */
#ifdef KSH
	 /* Aliases that are builtin commands in at&t */
	  "login=exec login",
#ifndef __NetBSD__
	  "newgrp=exec newgrp",
#endif /* __NetBSD__ */
#endif /* KSH */
	  NULL,
	/* this is what at&t ksh seems to track, with the addition of emacs */
	"alias", "-tU",
	  "cat", "cc", "chmod", "cp", "date", "ed", "emacs", "grep", "ls",
	  "mail", "make", "mv", "pr", "rm", "sed", "sh", "vi", "who",
	  NULL,
#ifdef EXTRA_INITCOMS
	EXTRA_INITCOMS, NULL,
#endif /* EXTRA_INITCOMS */
	NULL
};

int
main(int argc, char *argv[])
{
	int i;
	int argi;
	Source *s;
	struct block *l;
	int restricted, errexit;
	char **wp;
	struct env env;
	pid_t ppid;

	/* make sure argv[] is sane */
	if (!*argv) {
		static const char	*empty_argv[] = {
					    "pdksh", (char *) 0
					};

		argv = (char **)__UNCONST(empty_argv);
		argc = 1;
	}
	kshname = *argv;

	ainit(&aperm);		/* initialize permanent Area */

	/* set up base environment */
	memset(&env, 0, sizeof(env));
	env.type = E_NONE;
	ainit(&env.area);
	e = &env;
	newblock();		/* set up global l->vars and l->funs */

	/* Do this first so output routines (eg, errorf, shellf) can work */
	initio();

	initvar();

	initctypes();

	inittraps();

#ifdef KSH
	coproc_init();
#endif /* KSH */

	/* set up variable and command dictionaries */
	tinit(&taliases, APERM, 0);
	tinit(&aliases, APERM, 0);
	tinit(&homedirs, APERM, 0);

	/* define shell keywords */
	initkeywords();

	/* define built-in commands */
	tinit(&builtins, APERM, 64); /* must be 2^n (currently 40 builtins) */
	for (i = 0; shbuiltins[i].name != NULL; i++)
		builtin(shbuiltins[i].name, shbuiltins[i].func);
	for (i = 0; kshbuiltins[i].name != NULL; i++)
		builtin(kshbuiltins[i].name, kshbuiltins[i].func);

	init_histvec();

	def_path = DEFAULT__PATH;
#if defined(HAVE_CONFSTR) && defined(_CS_PATH)
	{
		size_t len = confstr(_CS_PATH, (char *) 0, 0);
		char *new;

		if (len > 0) {
			confstr(_CS_PATH, new = alloc(len + 1, APERM), len + 1);
			def_path = new;
		}
	}
#endif /* HAVE_CONFSTR && _CS_PATH */

	/* Set PATH to def_path (will set the path global variable).
	 * (import of environment below will probably change this setting).
	 */
	{
		struct tbl *vp = global("PATH");
		/* setstr can't fail here */
		setstr(vp, def_path, KSH_RETURN_ERROR);
	}


	/* Turn on nohup by default for now - will change to off
	 * by default once people are aware of its existence
	 * (at&t ksh does not have a nohup option - it always sends
	 * the hup).
	 */
	Flag(FNOHUP) = 1;

	/* Turn on brace expansion by default.  At&t ksh's that have
	 * alternation always have it on.  BUT, posix doesn't have
	 * brace expansion, so set this before setting up FPOSIX
	 * (change_flag() clears FBRACEEXPAND when FPOSIX is set).
	 */
#ifdef BRACE_EXPAND
	Flag(FBRACEEXPAND) = 1;
#endif /* BRACE_EXPAND */

	/* set posix flag just before environment so that it will have
	 * exactly the same effect as the POSIXLY_CORRECT environment
	 * variable.  If this needs to be done sooner to ensure correct posix
	 * operation, an initial scan of the environment will also have
	 * done sooner.
	 */
#ifdef POSIXLY_CORRECT
	change_flag(FPOSIX, OF_SPECIAL, 1);
#endif /* POSIXLY_CORRECT */

	/* Set edit mode to emacs by default, may be overridden
	 * by the environment or the user.  Also, we want tab completion
	 * on in vi by default. */
#if defined(EDIT) && defined(EMACS)
	change_flag(FEMACS, OF_SPECIAL, 1);
#endif /* EDIT && EMACS */
#if defined(EDIT) && defined(VI)
	Flag(FVITABCOMPLETE) = 1;
#endif /* EDIT && VI */

	/* import environment */
	if (environ != NULL)
		for (wp = environ; *wp != NULL; wp++)
			typeset(*wp, IMPORT|EXPORT, 0, 0, 0);

	kshpid = procpid = getpid();
	typeset(initifs, 0, 0, 0, 0);	/* for security */

	/* assign default shell variable values */
	substitute(initsubs, 0);

	/* Figure out the current working directory and set $PWD */
	{
		struct stat s_pwd, s_dot;
		struct tbl *pwd_v = global("PWD");
		char *pwd = str_val(pwd_v);
		char *pwdx = pwd;

		/* Try to use existing $PWD if it is valid */
		if (!ISABSPATH(pwd)
		    || stat(pwd, &s_pwd) < 0 || stat(".", &s_dot) < 0
		    || s_pwd.st_dev != s_dot.st_dev
		    || s_pwd.st_ino != s_dot.st_ino)
			pwdx = (char *) 0;
		set_current_wd(pwdx);
		if (current_wd[0])
			simplify_path(current_wd);
		/* Only set pwd if we know where we are or if it had a
		 * bogus value
		 */
		if (current_wd[0] || pwd != null)
			/* setstr can't fail here */
			setstr(pwd_v, current_wd, KSH_RETURN_ERROR);
	}
	ppid = getppid();
	setint(global("PPID"), (long) ppid);
#ifdef KSH
	setint(global("RANDOM"), (long) (time((time_t *)0) * kshpid * ppid));
#endif /* KSH */
	/* setstr can't fail here */
	setstr(global(version_param), ksh_version, KSH_RETURN_ERROR);

	/* execute initialization statements */
	for (wp = (char**)__UNCONST(initcoms); *wp != NULL; wp++) {
		shcomexec(wp);
		for (; *wp != NULL; wp++)
			;
	}


	ksheuid = geteuid();
	safe_prompt = ksheuid ? "$ " : "# ";
	{
		struct tbl *vp = global("PS1");

		/* Set PS1 if it isn't set, or we are root and prompt doesn't
		 * contain a #.
		 */
		if (!(vp->flag & ISSET)
		    || (!ksheuid && !strchr(str_val(vp), '#')))
			/* setstr can't fail here */
			setstr(vp, safe_prompt, KSH_RETURN_ERROR);
	}

	/* Set this before parsing arguments */
	Flag(FPRIVILEGED) = getuid() != ksheuid || getgid() != getegid();

	/* this to note if monitor is set on command line (see below) */
	Flag(FMONITOR) = 127;
	argi = parse_args(argv, OF_CMDLINE, (int *) 0);
	if (argi < 0) {
		exit(1);
		/* NOTREACHED */
	}

	if (Flag(FCOMMAND)) {
		s = pushs(SSTRING, ATEMP);
		if (!(s->start = s->str = argv[argi++]))
			errorf("-c requires an argument");
		if (argv[argi])
			kshname = argv[argi++];
	} else if (argi < argc && !Flag(FSTDIN)) {
		s = pushs(SFILE, ATEMP);
		s->file = argv[argi++];
		s->u.shf = shf_open(s->file, O_RDONLY, 0, SHF_MAPHI|SHF_CLEXEC);
		if (s->u.shf == NULL) {
			exstat = 127; /* POSIX */
			errorf("%s: %s", s->file, strerror(errno));
		}
		kshname = s->file;
	} else {
		Flag(FSTDIN) = 1;
		s = pushs(SSTDIN, ATEMP);
		s->file = "<stdin>";
		s->u.shf = shf_fdopen(0, SHF_RD | can_seek(0),
				      (struct shf *) 0);
		if (isatty(0) && isatty(2)) {
			Flag(FTALKING) = Flag(FTALKING_I) = 1;
			/* The following only if isatty(0) */
			s->flags |= SF_TTY;
			s->u.shf->flags |= SHF_INTERRUPT;
			s->file = (char *) 0;
		}
	}

	/* This bizarreness is mandated by POSIX */
	{
		struct stat s_stdin;

		if (fstat(0, &s_stdin) >= 0 && S_ISCHR(s_stdin.st_mode) &&
		    Flag(FTALKING))
			reset_nonblock(0);
	}

	/* initialize job control */
	i = Flag(FMONITOR) != 127;
	Flag(FMONITOR) = 0;
	j_init(i);
#ifdef EDIT
	/* Do this after j_init(), as tty_fd is not initialized 'til then */
	if (Flag(FTALKING))
		x_init();
#endif

	l = e->loc;
	l->argv = &argv[argi - 1];
	l->argc = argc - argi;
	l->argv[0] = (char *)__UNCONST(kshname);
	getopts_reset(1);

	/* Disable during .profile/ENV reading */
	restricted = Flag(FRESTRICTED);
	Flag(FRESTRICTED) = 0;
	errexit = Flag(FERREXIT);
	Flag(FERREXIT) = 0;

	/* Do this before profile/$ENV so that if it causes problems in them,
	 * user will know why things broke.
	 */
	if (!current_wd[0] && Flag(FTALKING))
		warningf(false, "Cannot determine current working directory");

	if (Flag(FLOGIN)) {
		include(KSH_SYSTEM_PROFILE, 0, (char **) 0, 1);
		if (!Flag(FPRIVILEGED))
			include(substitute("$HOME/.profile", 0), 0,
				(char **) 0, 1);
	}

	if (Flag(FPRIVILEGED))
		include("/etc/suid_profile", 0, (char **) 0, 1);
	else {
		char *env_file;

#ifndef KSH
		if (!Flag(FPOSIX))
			env_file = null;
		else
#endif /* !KSH */
			/* include $ENV */
			env_file = str_val(global("ENV"));

#ifdef DEFAULT_ENV
		/* If env isn't set, include default environment */
		if (env_file == null)
			env_file = __UNCONST(DEFAULT_ENV);
#endif /* DEFAULT_ENV */
		env_file = substitute(env_file, DOTILDE);
		if (*env_file != '\0')
			include(env_file, 0, (char **) 0, 1);
		else if (Flag(FTALKING))
			include(substitute("$HOME/kshrc.ksh", 0), 0,
				(char **) 0, 1);
	}

	if (is_restricted(argv[0]) || is_restricted(str_val(global("SHELL"))))
		restricted = 1;
	if (restricted) {
		static const char *const restr_com[] = {
						"typeset", "-r", "PATH",
						    "ENV", "SHELL",
						(char *) 0
					    };
		shcomexec((char **)__UNCONST(restr_com));
		/* After typeset command... */
		Flag(FRESTRICTED) = 1;
	}
	if (errexit)
		Flag(FERREXIT) = 1;

	if (Flag(FTALKING)) {
		hist_init(s);
#ifdef KSH
		alarm_init();
#endif /* KSH */
	} else
		Flag(FTRACKALL) = 1;	/* set after ENV */

	setlocale(LC_CTYPE, "");
	shell(s, true);	/* doesn't return */
	return 0;
}

int
include(name, argc, argv, intr_ok)
	const char *name;
	int argc;
	char **argv;
	int intr_ok;
{
	Source *volatile s = NULL;
	struct shf *shf;
	char **volatile old_argv;
	volatile int old_argc;
	int i;

	shf = shf_open(name, O_RDONLY, 0, SHF_MAPHI|SHF_CLEXEC);
	if (shf == NULL)
		return -1;

	if (argv) {
		old_argv = e->loc->argv;
		old_argc = e->loc->argc;
	} else {
		old_argv = (char **) 0;
		old_argc = 0;
	}
	newenv(E_INCL);
	i = ksh_sigsetjmp(e->jbuf, 0);
	if (i) {
		if (s) /* Do this before quitenv(), which frees the memory */
			shf_close(s->u.shf);
		quitenv();
		if (old_argv) {
			e->loc->argv = old_argv;
			e->loc->argc = old_argc;
		}
		switch (i) {
		  case LRETURN:
		  case LERROR:
			return exstat & 0xff; /* see below */
		  case LINTR:
			/* intr_ok is set if we are including .profile or $ENV.
			 * If user ^C's out, we don't want to kill the shell...
			 */
			if (intr_ok && (exstat - 128) != SIGTERM)
				return 1;
			/* fall through... */
		  case LEXIT:
		  case LLEAVE:
		  case LSHELL:
			unwind(i);
			/*NOREACHED*/
		  default:
			internal_errorf(1, "include: %d", i);
			/*NOREACHED*/
		}
	}
	if (argv) {
		e->loc->argv = argv;
		e->loc->argc = argc;
	}
	s = pushs(SFILE, ATEMP);
	s->u.shf = shf;
	s->file = str_save(name, ATEMP);
	i = shell(s, false);
	shf_close(s->u.shf);
	quitenv();
	if (old_argv) {
		e->loc->argv = old_argv;
		e->loc->argc = old_argc;
	}
	return i & 0xff;	/* & 0xff to ensure value not -1 */
}

int
command(comm)
	const char *comm;
{
	Source *s;
	int r;

	s = pushs(SSTRING, ATEMP);
	s->start = s->str = comm;
	r = shell(s, false);
	afree(s, ATEMP);
	return r;
}

/*
 * run the commands from the input source, returning status.
 */
int
shell(s, toplevel)
	Source *volatile s;		/* input source */
	int volatile toplevel;
{
	struct op *t;
	volatile int wastty = s->flags & SF_TTY;
	volatile int attempts = 13;
	volatile int interactive = Flag(FTALKING) && toplevel;
	Source *volatile old_source = source;
	int i;

	newenv(E_PARSE);
	if (interactive)
		really_exit = 0;
	i = ksh_sigsetjmp(e->jbuf, 0);
	if (i) {
		switch (i) {
		  case LINTR: /* we get here if SIGINT not caught or ignored */
		  case LERROR:
		  case LSHELL:
			if (interactive) {
				if (i == LINTR)
					shellf("%s", newline);
				/* Reset any eof that was read as part of a
				 * multiline command.
				 */
				if (Flag(FIGNOREEOF) && s->type == SEOF
				    && wastty)
					s->type = SSTDIN;
				/* Used by exit command to get back to
				 * top level shell.  Kind of strange since
				 * interactive is set if we are reading from
				 * a tty, but to have stopped jobs, one only
				 * needs FMONITOR set (not FTALKING/SF_TTY)...
				 */
				/* toss any input we have so far */
				s->start = s->str = null;
				break;
			}
			/* fall through... */
		  case LEXIT:
		  case LLEAVE:
		  case LRETURN:
			source = old_source;
			quitenv();
			unwind(i);	/* keep on going */
			/*NOREACHED*/
		  default:
			source = old_source;
			quitenv();
			internal_errorf(1, "shell: %d", i);
			/*NOREACHED*/
		}
	}

	while (1) {
		if (trap)
			runtraps(0);

		if (s->next == NULL) {
			if (Flag(FVERBOSE))
				s->flags |= SF_ECHO;
			else
				s->flags &= ~SF_ECHO;
		}

		if (interactive) {
			j_notify();
#ifdef KSH
			mcheck();
#endif /* KSH */
			set_prompt(PS1, s);
		}

		t = compile(s);
		if (t != NULL && t->type == TEOF) {
			if (wastty && Flag(FIGNOREEOF) && --attempts > 0) {
				shellf("Use `exit' to leave ksh\n");
				s->type = SSTDIN;
			} else if (wastty && !really_exit
				   && j_stopped_running())
			{
				really_exit = 1;
				s->type = SSTDIN;
			} else {
				/* this for POSIX, which says EXIT traps
				 * shall be taken in the environment
				 * immediately after the last command
				 * executed.
				 */
				if (toplevel)
					unwind(LEXIT);
				break;
			}
		}

		if (t && (!Flag(FNOEXEC) || (s->flags & SF_TTY)))
			exstat = execute(t, 0);

		if (t != NULL && t->type != TEOF && interactive && really_exit)
			really_exit = 0;

		reclaim();
	}
	quitenv();
	source = old_source;
	return exstat;
}

/* return to closest error handler or shell(), exit if none found */
void
unwind(i)
	int i;
{
	/* ordering for EXIT vs ERR is a bit odd (this is what at&t ksh does) */
	if (i == LEXIT || (Flag(FERREXIT) && (i == LERROR || i == LINTR)
			   && sigtraps[SIGEXIT_].trap))
	{
		runtrap(&sigtraps[SIGEXIT_]);
		i = LLEAVE;
	} else if (Flag(FERREXIT) && (i == LERROR || i == LINTR)) {
		runtrap(&sigtraps[SIGERR_]);
		i = LLEAVE;
	}
	while (1) {
		switch (e->type) {
		  case E_PARSE:
		  case E_FUNC:
		  case E_INCL:
		  case E_LOOP:
		  case E_ERRH:
			ksh_siglongjmp(e->jbuf, i);
			/*NOTREACHED*/

		  case E_NONE:
			if (i == LINTR)
				e->flags |= EF_FAKE_SIGDIE;
			/* Fall through... */

		  default:
			quitenv();
		}
	}
}

void
newenv(type)
	int type;
{
	struct env *ep;

	ep = (struct env *) alloc(sizeof(*ep), ATEMP);
	ep->type = type;
	ep->flags = 0;
	ainit(&ep->area);
	ep->loc = e->loc;
	ep->savefd = NULL;
	ep->oenv = e;
	ep->temps = NULL;
	e = ep;
}

void
quitenv()
{
	struct env *ep = e;
	int fd;

	if (ep->oenv && ep->oenv->loc != ep->loc)
		popblock();
	if (ep->savefd != NULL) {
		for (fd = 0; fd < NUFILE; fd++)
			/* if ep->savefd[fd] < 0, means fd was closed */
			if (ep->savefd[fd])
				restfd(fd, ep->savefd[fd]);
		if (ep->savefd[2]) /* Clear any write errors */
			shf_reopen(2, SHF_WR, shl_out);
	}
	reclaim();

	/* Bottom of the stack.
	 * Either main shell is exiting or cleanup_parents_env() was called.
	 */
	if (ep->oenv == NULL) {
		if (ep->type == E_NONE) {	/* Main shell exiting? */
			if (Flag(FTALKING))
				hist_finish();
			j_exit();
			if (ep->flags & EF_FAKE_SIGDIE) {
				int sig = exstat - 128;

				/* ham up our death a bit (at&t ksh
				 * only seems to do this for SIGTERM)
				 * Don't do it for SIGQUIT, since we'd
				 * dump a core..
				 */
				if (sig == SIGINT || sig == SIGTERM) {
					setsig(&sigtraps[sig], SIG_DFL,
						SS_RESTORE_CURR|SS_FORCE);
					kill(0, sig);
				}
			}
		}
		exit(exstat);
	}

	e = e->oenv;
	afree(ep, ATEMP);
}

/* Called after a fork to cleanup stuff left over from parents environment */
void
cleanup_parents_env()
{
	struct env *ep;
	int fd;

	/* Don't clean up temporary files - parent will probably need them.
	 * Also, can't easily reclaim memory since variables, etc. could be
	 * anywhere.
	 */

	/* close all file descriptors hiding in savefd */
	for (ep = e; ep; ep = ep->oenv) {
		if (ep->savefd) {
			for (fd = 0; fd < NUFILE; fd++)
				if (ep->savefd[fd] > 0)
					close(ep->savefd[fd]);
			afree(ep->savefd, &ep->area);
			ep->savefd = (short *) 0;
		}
	}
	e->oenv = (struct env *) 0;
}

/* Called just before an execve cleanup stuff temporary files */
void
cleanup_proc_env()
{
	struct env *ep;

	for (ep = e; ep; ep = ep->oenv)
		remove_temps(ep->temps);
}

/* remove temp files and free ATEMP Area */
static void
reclaim()
{
	remove_temps(e->temps);
	e->temps = NULL;
	afreeall(&e->area);
}

static void
remove_temps(tp)
	struct temp *tp;
{
	for (; tp != NULL; tp = tp->next)
		if (tp->pid == procpid) {
			unlink(tp->name);
		}
}

/* Returns true if name refers to a restricted shell */
static int
is_restricted(name)
	char *name;
{
	char *p;

	if ((p = ksh_strrchr_dirsep(name)))
		name = p;
	/* accepts rsh, rksh, rpdksh, pdrksh, etc. */
	return (p = strchr(name, 'r')) && strstr(p, "sh");
}

void
aerror(ap, msg)
	Area *ap;
	const char *msg;
{
	internal_errorf(1, "alloc: %s", msg);
	errorf("%s", null); /* this is never executed - keeps gcc quiet */
	/*NOTREACHED*/
}



/* ============================================================================
 * SOURCE 11/98: minix4\libos_legacy\ls\main.c
 * Size: 1,839 bytes, Lines: 51
 * Hash: c38f902e6f41...
 * ============================================================================ */

/*	$NetBSD: main.c,v 1.5 2016/09/05 01:00:07 sevan Exp $	*/

/*-
 * Copyright (c) 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Luke Mewburn.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/cdefs.h>

#ifndef lint
__RCSID("$NetBSD: main.c,v 1.5 2016/09/05 01:00:07 sevan Exp $");
#endif /* not lint */

#include <sys/types.h>
#include <fts.h>

#include "ls.h"
#include "extern.h"

int
main(int argc, char *argv[])
{

	return ls_main(argc, argv);
	/* NOTREACHED */
}



/* ============================================================================
 * SOURCE 12/98: minix4\libos_legacy\sh\main.c
 * Size: 9,914 bytes, Lines: 446
 * Hash: 370049116fcb...
 * ============================================================================ */

/*	$NetBSD: main.c,v 1.90 2023/04/07 10:34:13 kre Exp $	*/

/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Kenneth Almquist.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/cdefs.h>
#ifndef lint
__COPYRIGHT("@(#) Copyright (c) 1991, 1993\
 The Regents of the University of California.  All rights reserved.");
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@(#)main.c	8.7 (Berkeley) 7/19/95";
#else
__RCSID("$NetBSD: main.c,v 1.90 2023/04/07 10:34:13 kre Exp $");
#endif
#endif /* not lint */

#include <errno.h>
#include <stdio.h>
#include <signal.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdbool.h>
#include <stdlib.h>
#include <locale.h>
#include <fcntl.h>


#include "shell.h"
#include "main.h"
#include "mail.h"
#include "options.h"
#include "builtins.h"
#include "output.h"
#include "parser.h"
#include "nodes.h"
#include "expand.h"
#include "eval.h"
#include "jobs.h"
#include "input.h"
#include "trap.h"
#include "var.h"
#include "show.h"
#include "memalloc.h"
#include "error.h"
#include "init.h"
#include "mystring.h"
#include "exec.h"
#include "cd.h"
#include "redir.h"

#define PROFILE 0

int rootpid;
int rootshell;
struct jmploc main_handler;
int max_user_fd;
long user_fd_limit;
bool privileged;
#if PROFILE
short profile_buf[16384];
extern int etext();
#endif

STATIC void read_profile(const char *);

/*
 * Main routine.  We initialize things, parse the arguments, execute
 * profiles if we're a login shell, and then call cmdloop to execute
 * commands.  The setjmp call sets up the location to jump to when an
 * exception occurs.  When an exception occurs the variable "state"
 * is used to figure out how far we had gotten.
 */

int
main(int argc, char **argv)
{
	struct stackmark smark;
	volatile int state;
	char *shinit;
	uid_t uid;
	gid_t gid;
	sigset_t mask;
	bool waspriv;

	/*
	 * If we happen to be invoked with SIGCHLD ignored, we cannot
	 * successfully do almost anything.   Perhaps we should remember
	 * its state and pass it on ignored to children if it was ignored
	 * on entry, but that seems like just leaving the shit on the
	 * footpath for someone else to fall into...
	 */
	(void)signal(SIGCHLD, SIG_DFL);
	/*
	 * Similarly, SIGCHLD must not be blocked
	 */
	sigemptyset(&mask);
	sigaddset(&mask, SIGCHLD);
	sigprocmask(SIG_UNBLOCK, &mask, NULL);

	uid = getuid();
	gid = getgid();

	waspriv = privileged = (uid != geteuid()) || (gid != getegid());

	max_user_fd = fcntl(0, F_MAXFD);
	if (max_user_fd < 2)
		max_user_fd = 2;
	user_fd_limit = sysconf(_SC_OPEN_MAX);

	setlocale(LC_ALL, "");

	posix = getenv("POSIXLY_CORRECT") != NULL;
#if PROFILE
	monitor(4, etext, profile_buf, sizeof profile_buf, 50);
#endif
	state = 0;
	if (setjmp(main_handler.loc)) {
		/*
		 * When a shell procedure is executed, we raise the
		 * exception EXSHELLPROC to clean up before executing
		 * the shell procedure.
		 */
		switch (exception) {
		case EXSHELLPROC:
			rootpid = getpid();
			rootshell = 1;
			minusc = NULL;
			state = 3;
			break;

		case EXEXEC:
			exitstatus = exerrno;
			break;

		case EXERROR:
			exitstatus = 2;
			break;

		default:
			break;
		}

		if (exception != EXSHELLPROC) {
			if (state == 0 || iflag == 0 || ! rootshell ||
			    exception == EXEXIT)
				exitshell(exitstatus);
		}
		reset();
		if (exception == EXINT) {
			out2c('\n');
			flushout(&errout);
		}
		popstackmark(&smark);
		FORCEINTON;				/* enable interrupts */
		if (state == 1)
			goto state1;
		else if (state == 2)
			goto state2;
		else if (state == 3)
			goto state3;
		else
			goto state4;
	}
	handler = &main_handler;
#ifdef DEBUG
#if DEBUG >= 2
	debug = 1;	/* this may be reset by procargs() later */
#endif
	opentrace();
	if (privileged)
		trputs("Privileged ");
	trputs("Shell args:  ");  trargs(argv);
#if DEBUG >= 3
	set_debug(((DEBUG)==3 ? "_@" : "++"), 1);
#endif
#endif
	rootpid = getpid();
	rootshell = 1;
	init();
	initpwd();
	setstackmark(&smark);
	procargs(argc, argv);
	setvar_invocation(argc, argv);

#if 0	/* This now happens (indirectly) in the procargs() just above */
	/*
	 * Limit bogus system(3) or popen(3) calls in setuid binaries,
	 * by requiring the -p flag
	 */
	if (!pflag && (uid != geteuid() || gid != getegid())) {
		setuid(uid);
		setgid(gid);
		/* PS1 might need to be changed accordingly. */
		choose_ps1();
	}
#else	/* except for this one little bit */
	if (waspriv && !privileged)
		choose_ps1();
#endif

	if (loginsh) {
		state = 1;
		read_profile("/etc/profile");
 state1:
		state = 2;
		if (!privileged) {
			char *profile;
			const char *home;

			home = lookupvar("HOME");
			if (home == NULL)
				home = nullstr;
			profile = ststrcat(NULL, home, "/.profile", STSTRC_END);
			read_profile(profile);
			stunalloc(profile);
		}
#if 0	/* FreeBSD does (effectively) ...*/
		else
			read_profile("/etc/suid_profile");
#endif
	}
 state2:
	state = 3;
	if ((iflag || !posix) && !privileged) {
		struct stackmark env_smark;

		setstackmark(&env_smark);
		if ((shinit = lookupvar("ENV")) != NULL && *shinit != '\0') {
			state = 3;
			read_profile(expandenv(shinit));
		}
		popstackmark(&env_smark);
	}
 state3:
	state = 4;
	line_number = 1;	/* undo anything from profile files */

	if (sflag == 0 || minusc) {
		static int sigs[] =  {
		    SIGINT, SIGQUIT, SIGHUP,
#ifdef SIGTSTP
		    SIGTSTP,
#endif
		    SIGPIPE
		};
#define SIGSSIZE (sizeof(sigs)/sizeof(sigs[0]))
		size_t i;

		for (i = 0; i < SIGSSIZE; i++)
		    setsignal(sigs[i], 0);
	}

	rststackmark(&smark);	/* this one is never popped */

	if (minusc)
		evalstring(minusc, sflag ? 0 : EV_EXIT);

	if (sflag || minusc == NULL) {
 state4:	/* XXX ??? - why isn't this before the "if" statement */
		cmdloop(1);
		if (iflag) {
			out2str("\n");
			flushout(&errout);
		}
	}
#if PROFILE
	monitor(0);
#endif
	line_number = plinno;
	exitshell(exitstatus);
	/* NOTREACHED */
}


/*
 * Read and execute commands.  "Top" is nonzero for the top level command
 * loop; it turns on prompting if the shell is interactive.
 */

void
cmdloop(int top)
{
	union node *n;
	struct stackmark smark;
	int inter;
	int numeof = 0;
	enum skipstate skip;

	CTRACE(DBG_ALWAYS, ("cmdloop(%d) called\n", top));
	setstackmark(&smark);
	for (;;) {
		if (pendingsigs)
			dotrap();
		inter = 0;
		if (iflag == 1 && top) {
			inter = 1;
			showjobs(out2, SHOW_CHANGED);
			chkmail(0);
			flushout(&errout);
			nflag = 0;
		}
		n = parsecmd(inter);
		VXTRACE(DBG_PARSE|DBG_EVAL|DBG_CMDS,("cmdloop: "),showtree(n));
		if (n == NEOF) {
			if (!top || numeof >= 50)
				break;
			if (nflag)
				break;
			if (!stoppedjobs()) {
				if (!iflag || !Iflag)
					break;
				out2str("\nUse \"exit\" to leave shell.\n");
			}
			numeof++;
		} else if (n != NULL && nflag == 0) {
			job_warning = (job_warning == 2) ? 1 : 0;
			numeof = 0;
			evaltree(n, 0);
		}
		rststackmark(&smark);

		/*
		 * Any SKIP* can occur here!  SKIP(FUNC|BREAK|CONT) occur when
		 * a dotcmd is in a loop or a function body and appropriate
		 * built-ins occurs in file scope in the sourced file.  Values
		 * other than SKIPFILE are reset by the appropriate eval*()
		 * that contained the dotcmd() call.
		 */
		skip = current_skipstate();
		if (skip != SKIPNONE) {
			if (skip == SKIPFILE)
				stop_skipping();
			break;
		}
	}
	popstackmark(&smark);
}



/*
 * Read /etc/profile or .profile.  Return on error.
 */

STATIC void
read_profile(const char *name)
{
	int fd;
	int xflag_set = 0;
	int vflag_set = 0;

	if (*name == '\0')
		return;

	INTOFF;
	if ((fd = open(name, O_RDONLY)) >= 0)
		setinputfd(fd, 1);
	INTON;
	if (fd < 0)
		return;
	/* -q turns off -x and -v just when executing init files */
	if (qflag)  {
	    if (xflag)
		    xflag = 0, xflag_set = 1;
	    if (vflag)
		    vflag = 0, vflag_set = 1;
	}
	(void)set_dot_funcnest(1);	/* allow profile to "return" */
	cmdloop(0);
	(void)set_dot_funcnest(0);
	if (qflag)  {
	    if (xflag_set)
		    xflag = 1;
	    if (vflag_set)
		    vflag = 1;
	}
	popfile();
}



/*
 * Read a file containing shell functions.
 */

void
readcmdfile(char *name)
{
	int fd;

	INTOFF;
	if ((fd = open(name, O_RDONLY)) >= 0)
		setinputfd(fd, 1);
	else
		error("Can't open %s", name);
	INTON;
	cmdloop(0);
	popfile();
}



int
exitcmd(int argc, char **argv)
{
	if (stoppedjobs())
		return 0;
	if (argc > 1)
		exitshell(number(argv[1]));
	else
		exitshell_savedstatus();
	/* NOTREACHED */
}



/* ============================================================================
 * SOURCE 13/98: minix4\libos\lib_legacy\libpuffs\main.c
 * Size: 3,575 bytes, Lines: 148
 * Hash: a8bcf7e59119...
 * ============================================================================ */


#include "fs.h"

static message fs_msg;
static int fs_ipc_status;
static int fs_pending;

#define PUFFS_MAX_ARGS 20

/*===========================================================================*
 *		            sef_cb_init_fresh                                *
 *===========================================================================*/
static int sef_cb_init_fresh(int type, sef_init_info_t *info)
{
/* Initialize the Minix file server. */
  return(OK);
}

/*===========================================================================*
 *		           sef_cb_signal_handler                             *
 *===========================================================================*/
static void sef_cb_signal_handler(int signo)
{
  /* Only check for termination signal, ignore anything else. */
  if (signo != SIGTERM) return;

  exitsignaled = 1;
  if (mounted)
	fs_sync();

  sef_cancel();
}

/*===========================================================================*
 *			       sef_local_startup			     *
 *===========================================================================*/
static void sef_local_startup(void)
{
  /* Register init callbacks. */
  sef_setcb_init_fresh(sef_cb_init_fresh);

  /* Register signal callbacks. */
  sef_setcb_signal_handler(sef_cb_signal_handler);

  /* Let SEF perform startup. */
  sef_startup();
}

/*===========================================================================*
 *				get_work				     *
 *===========================================================================*/
static int get_work(message *msg, int *ipc_status)
{
  int r;

  for (;;) {
	if ((r = sef_receive_status(ANY, msg, ipc_status)) != OK) {
		if (r == EINTR) /* sef_cancel from signal handler? */
			break; /* see if we can exit the main loop */
		panic("sef_receive failed: %d", r);
	}
	if (msg->m_source == VFS_PROC_NR)
		break;
	lpuffs_debug("libpuffs: unexpected source %d\n", msg->m_source);
  }

  return r;
}

int __wrap_main(int argc, char *argv[]);
int __real_main(int argc, char* argv[]);

int __wrap_main(int argc, char *argv[])
{
  int i;
  int new_argc = 0;
  static char* new_argv[PUFFS_MAX_ARGS];
  char *name;

  /* SEF local startup. */
  env_setargs(argc, argv);
  sef_local_startup();

  global_kcred.pkcr_type = PUFFCRED_TYPE_INTERNAL;

  if (argc < 3) {
	panic("Unexpected arguments, use:\
		mount -t fs /dev/ /dir [-o option1,option2]\n");
  }

  name = argv[0] + strlen(argv[0]);
  while (*name != '/' && name != argv[0])
	  name--;
  if (name != argv[0])
	  name++;
  strcpy(fs_name, name);

  new_argv[new_argc] = argv[0];
  new_argc++;

  for (i = 1; i < argc; i++) {
	if (new_argc >= PUFFS_MAX_ARGS) {
		panic("Too many arguments, change PUFFS_MAX_ARGS");
	}
	new_argv[new_argc] = argv[i];
	new_argc++;
  }

  assert(new_argc > 0);

  /* Get the mount request from VFS, so we can deal with it later. */
  (void)get_work(&fs_msg, &fs_ipc_status);
  fs_pending = TRUE;

  return __real_main(new_argc, new_argv);
}

/*
 * Receive a message unless one was already pending.  Process the message, and
 * send a reply if necessary.  Return whether puffs should keep running.
 */
int
lpuffs_pump(void)
{

	if (fs_pending == TRUE || get_work(&fs_msg, &fs_ipc_status) == OK) {
		fs_pending = FALSE;

		fsdriver_process(&puffs_table, &fs_msg, fs_ipc_status, FALSE);
	}

	return mounted || !exitsignaled;
}

/*
 * Initialize MINIX3-specific settings.
 */
void
lpuffs_init(struct puffs_usermount * pu)
{

	buildpath = pu->pu_flags & PUFFS_FLAG_BUILDPATH; /* XXX */

	LIST_INIT(&pu->pu_pnode_removed_lst);

	global_pu = pu;
}



/* ============================================================================
 * SOURCE 14/98: minix4\libos\lib_legacy\libsffs\main.c
 * Size: 1,609 bytes, Lines: 60
 * Hash: 335f6a78d44d...
 * ============================================================================ */

/* This file contains the SFFS initialization code and message loop.
 *
 * The entry points into this file are:
 *   sffs_init		initialization
 *   sffs_signal	signal handler
 *   sffs_loop		main message loop
 *
 * Created:
 *   April 2009 (D.C. van Moolenbroek)
 */

#include "inc.h"

/*===========================================================================*
 *				sffs_init				     *
 *===========================================================================*/
int sffs_init(char *name, const struct sffs_table *table,
  struct sffs_params *params)
{
/* Initialize this file server. Called at startup time.
 */
  int i;

  /* Make sure that the given path prefix doesn't end with a slash. */
  i = strlen(params->p_prefix);
  while (i > 0 && params->p_prefix[i - 1] == '/') i--;
  params->p_prefix[i] = 0;

  sffs_name = name;
  sffs_table = table;
  sffs_params = params;

  return OK;
}

/*===========================================================================*
 *				sffs_signal				     *
 *===========================================================================*/
void sffs_signal(int signo)
{

  /* Only check for termination signal, ignore anything else. */
  if (signo != SIGTERM) return;

  dprintf(("%s: got SIGTERM\n", sffs_name));

  fsdriver_terminate();
}

/*===========================================================================*
 *				sffs_loop				     *
 *===========================================================================*/
void sffs_loop(void)
{
/* The main function of this file server. Libfsdriver does the real work.
 */

  fsdriver_task(&sffs_dtable);
}



/* ============================================================================
 * SOURCE 15/98: minix4\libos\lib_legacy\util\gmake-3.66\main.c
 * Size: 45,263 bytes, Lines: 1,726
 * Hash: 089c6d22d173...
 * ============================================================================ */

/* Copyright (C) 1988, 1989, 1990, 1991 Free Software Foundation, Inc.
This file is part of GNU Make.

GNU Make is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GNU Make is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU Make; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

#include "make.h"
#include "commands.h"
#include "dep.h"
#include "file.h"
#include "variable.h"
#include "job.h"
#include "getopt.h"


extern char *version_string;

extern struct dep *read_all_makefiles ();

extern void print_variable_data_base ();
extern void print_dir_data_base ();
extern void print_rule_data_base ();
extern void print_file_data_base ();
extern void print_vpath_data_base ();

#ifndef	HAVE_UNISTD_H
extern int chdir ();
#endif
#ifndef	STDC_HEADERS
#ifndef	sun			/* Sun has an incorrect decl in a header.  */
extern void exit ();
#endif
extern double atof ();
#endif
extern char *mktemp ();

static void log_working_directory ();
static void print_data_base (), print_version ();
static void decode_switches (), decode_env_switches ();
static void define_makeflags ();


#if 0 /* dummy tag */
flags () {}
#endif
/* Flags:
 *	-b ignored for compatibility with System V Make
 *	-C change directory
 *	-d debug
 *	-e env_overrides
 *	-f makefile
 *	-i ignore_errors
 *	-j job_slots
 *	-k keep_going
 *	-l max_load_average
 *	-m ignored for compatibility with something or other
 *	-n just_print
 *	-o consider file old
 *	-p print_data_base
 *	-q question
 *	-r no_builtin_rules
 *	-s silent
 *	-S turn off -k
 *	-t touch
 *	-v print version information
 *	-w log working directory
 *	-W consider file new (with -n, `what' if effect)
 */

/* The structure that describes an accepted command switch.  */

struct command_switch
  {
    char c;			/* The switch character.  */

    enum			/* Type of the value.  */
      {
	flag,			/* Turn int flag on.  */
	flag_off,		/* Turn int flag off.  */
	string,			/* One string per switch.  */
	positive_int,		/* A positive integer.  */
	floating,		/* A floating-point number (double).  */
	ignore,			/* Ignored.  */
	usage_and_exit		/* Ignored; exit after processing switches.  */
      } type;

    char *value_ptr;	/* Pointer to the value-holding variable.  */

    unsigned int env:1;		/* Can come from MAKEFLAGS.  */
    unsigned int toenv:1;	/* Should be put in MAKEFLAGS.  */
    unsigned int no_makefile:1;	/* Don't propagate when remaking makefiles.  */

    char *noarg_value;	/* Pointer to value used if no argument is given.  */
    char *default_value;/* Pointer to default value.  */

    char *long_name;		/* Long option name.  */
    char *argdesc;		/* Descriptive word for argument.  */
    char *description;		/* Description for usage message.  */
  };


/* The structure used to hold the list of strings given
   in command switches of a type that takes string arguments.  */

struct stringlist
  {
    char **list;	/* Nil-terminated list of strings.  */
    unsigned int idx;	/* Index into above.  */
    unsigned int max;	/* Number of pointers allocated.  */
  };


/* The recognized command switches.  */

/* Nonzero means do not print commands to be executed (-s).  */

int silent_flag;

/* Nonzero means just touch the files
   that would appear to need remaking (-t)  */

int touch_flag;

/* Nonzero means just print what commands would need to be executed,
   don't actually execute them (-n).  */

int just_print_flag;

/* Print debugging trace info (-d).  */

int debug_flag = 0;

/* Environment variables override makefile definitions.  */

int env_overrides = 0;

/* Nonzero means ignore status codes returned by commands
   executed to remake files.  Just treat them all as successful (-i).  */

int ignore_errors_flag = 0;

/* Nonzero means don't remake anything, just print the data base
   that results from reading the makefile (-p).  */

int print_data_base_flag = 0;

/* Nonzero means don't remake anything; just return a nonzero status
   if the specified targets are not up to date (-q).  */

int question_flag = 0;

/* Nonzero means do not use any of the builtin rules (-r).  */

int no_builtin_rules_flag = 0;

/* Nonzero means keep going even if remaking some file fails (-k).  */

int keep_going_flag;
int default_keep_going_flag = 0;

/* Nonzero means print directory before starting and when done (-w).  */

int print_directory_flag = 0;

/* Nonzero means ignore print_directory_flag and never print the directory.
   This is necessary because print_directory_flag is set implicitly.  */

int inhibit_print_directory_flag = 0;

/* Nonzero means print version information.  */

int print_version_flag = 0;

/* List of makefiles given with -f switches.  */

static struct stringlist *makefiles = 0;


/* Number of job slots (commands that can be run at once).  */

unsigned int job_slots = 1;
unsigned int default_job_slots = 1;

/* Value of job_slots that means no limit.  */

static unsigned int inf_jobs = 0;

/* Maximum load average at which multiple jobs will be run.
   Negative values mean unlimited, while zero means limit to
   zero load (which could be useful to start infinite jobs remotely
   but one at a time locally).  */

double max_load_average = -1.0;
double default_load_average = -1.0;

/* List of directories given with -c switches.  */

static struct stringlist *directories = 0;

/* List of include directories given with -I switches.  */

static struct stringlist *include_directories = 0;

/* List of files given with -o switches.  */

static struct stringlist *old_files = 0;

/* List of files given with -W switches.  */

static struct stringlist *new_files = 0;

/* The table of command switches.  */

static const struct command_switch switches[] =
  {
    { 'b', ignore, 0, 0, 0, 0, 0, 0,
	0, 0,
	"Ignored for compatibility" },
    { 'C', string, (char *) &directories, 0, 0, 0, 0, 0,
	"directory", "DIRECTORY",
	"Change to DIRECTORY before doing anything" },
    { 'd', flag, (char *) &debug_flag, 1, 1, 0, 0, 0,
	"debug", 0,
	"Print lots of debugging information" },
    { 'e', flag, (char *) &env_overrides, 1, 1, 0, 0, 0,
	"environment-overrides", 0,
	"Environment variables override makefiles" },
    { 'f', string, (char *) &makefiles, 0, 0, 0, 0, 0,
	"file", "FILE",
	"Read FILE as a makefile" },
    { 'h', usage_and_exit, 0, 0, 0, 0, 0, 0,
	"help", 0,
	"Print this message and exit" },
    { 'i', flag, (char *) &ignore_errors_flag, 1, 1, 0, 0, 0,
	"ignore-errors", 0,
	"Ignore errors from commands" },
    { 'I', string, (char *) &include_directories, 1, 1, 0, 0, 0,
	"include-dir", "DIRECTORY",
	"Search DIRECTORY for included makefiles" },
    { 'j', positive_int, (char *) &job_slots, 1, 1, 0,
	(char *) &inf_jobs, (char *) &default_job_slots,
	"jobs", "N",
	"Allow N jobs at once; infinite jobs with no arg" },
    { 'k', flag, (char *) &keep_going_flag, 1, 1, 0,
	0, (char *) &default_keep_going_flag,
	"keep-going", 0,
	"Keep going when some targets can't be made" },
    { 'l', floating, (char *) &max_load_average, 1, 1, 0,
	(char *) &default_load_average, (char *) &default_load_average,
	"load-average", "N",
	"Don't start multiple jobs unless load is below N" },
    { 'm', ignore, 0, 0, 0, 0, 0, 0,
	0, 0,
	"-b" },
    { 'n', flag, (char *) &just_print_flag, 1, 1, 1, 0, 0,
	"just-print", 0,
	"Don't actually run any commands; just print them" },
    { 'o', string, (char *) &old_files, 0, 0, 0, 0, 0,
	"old-file", "FILE",
	"Consider FILE to be very old and don't remake it" },
    { 'p', flag, (char *) &print_data_base_flag, 1, 1, 0, 0, 0,
	"print-data-base", 0,
	"Print make's internal database" },
    { 'q', flag, (char *) &question_flag, 1, 1, 1, 0, 0,
	"question", 0,
	"Run no commands; exit status says if up to date" },
    { 'r', flag, (char *) &no_builtin_rules_flag, 1, 1, 0, 0, 0,
	"no-builtin-rules", 0,
	"Disable the built-in implicit rules" },
    { 's', flag, (char *) &silent_flag, 1, 1, 0, 0, 0,
	"silent", 0,
	"Don't echo commands" },
    { 'S', flag_off, (char *) &keep_going_flag, 1, 1, 0,
	0, (char *) &default_keep_going_flag,
	"no-keep-going", 0,
	"Turns off -k" },
    { 't', flag, (char *) &touch_flag, 1, 1, 1, 0, 0,
	"touch", 0,
	"Touch targets instead of remaking them" },
    { 'v', flag, (char *) &print_version_flag, 1, 1, 0, 0, 0,
	"version", 0,
	"Print the version number of make and exit" },
    { 'w', flag, (char *) &print_directory_flag, 1, 1, 0, 0, 0,
	"print-directory", 0,
	"Print the current directory" },
    { 1, flag, (char *) &inhibit_print_directory_flag, 1, 1, 0, 0, 0,
	"no-print-directory", 0,
	"Turn off -w, even if it was turned on implicitly" },
    { 'W', string, (char *) &new_files, 0, 0, 0, 0, 0,
	"what-if", "FILE",
	"Consider FILE to be infinitely new" },
    { '\0', }
  };

/* Secondary long names for options.  */

static struct option long_option_aliases[] =
  {
    { "quiet",		no_argument,		0, 's' },
    { "stop",		no_argument,		0, 'S' },
    { "new-file",	required_argument,	0, 'W' },
    { "assume-new",	required_argument,	0, 'W' },
    { "assume-old",	required_argument,	0, 'o' },
    { "max-load",	optional_argument,	0, 'l' },
    { "dry-run",	no_argument,		0, 'n' },
    { "recon",		no_argument,		0, 'n' },
    { "makefile",	required_argument,	0, 'f' },
  };

/* The usage message prints the descriptions of options starting in
   this column.  Make sure it leaves enough room for the longest
   description to fit in less than 80 characters.  */

#define	DESCRIPTION_COLUMN	30

/* List of non-switch arguments.  */

struct stringlist *other_args = 0;

/* The name we were invoked with.  */

char *program;

/* Our current directory after processing all -C options.  */

char *starting_directory;

/* Value of the MAKELEVEL variable at startup (or 0).  */

unsigned int makelevel;

/* First file defined in the makefile whose name does not
   start with `.'.  This is the default to remake if the
   command line does not specify.  */

struct file *default_goal_file;

/* Pointer to structure for the file .DEFAULT
   whose commands are used for any file that has none of its own.
   This is zero if the makefiles do not define .DEFAULT.  */

struct file *default_file;

/* Mask of signals that are being caught with fatal_error_signal.  */

#ifdef	POSIX
sigset_t fatal_signal_set;
#else
#ifdef	HAVE_SIGSETMASK
int fatal_signal_mask;
#endif
#endif

int
main (argc, argv, envp)
     int argc;
     char **argv;
     char **envp;
{
  extern void init_dir ();
  extern RETSIGTYPE fatal_error_signal (), child_handler ();
  register struct file *f;
  register unsigned int i;
  register char *cmd_defs;
  register unsigned int cmd_defs_len, cmd_defs_idx;
  char **p;
  time_t now;
  struct dep *goals = 0;
  register struct dep *lastgoal;
  struct dep *read_makefiles;
  PATH_VAR (current_directory);
  char *directory_before_chdir;

  default_goal_file = 0;
  reading_filename = 0;
  reading_lineno_ptr = 0;
  
#ifndef	HAVE_SYS_SIGLIST
  signame_init ();
#endif

#ifdef	POSIX
  sigemptyset (&fatal_signal_set);
#define	ADD_SIG(sig)	sigaddset (&fatal_signal_set, sig)
#else
#ifdef	HAVE_SIGSETMASK
  fatal_signal_mask = 0;
#define	ADD_SIG(sig)	fatal_signal_mask |= sigmask (sig)
#else
#define	ADD_SIG(sig)
#endif
#endif

#define	FATAL_SIG(sig)							      \
  if (signal ((sig), fatal_error_signal) == SIG_IGN)			      \
    (void) signal ((sig), SIG_IGN);					      \
  else									      \
    ADD_SIG (sig);

  FATAL_SIG (SIGHUP);
  FATAL_SIG (SIGQUIT);
  FATAL_SIG (SIGINT);
  FATAL_SIG (SIGTERM);

#ifdef	SIGDANGER
  FATAL_SIG (SIGDANGER);
#endif
#ifdef SIGXCPU
  FATAL_SIG (SIGXCPU);
#endif
#ifdef SIGXFSZ
  FATAL_SIG (SIGXFSZ);
#endif

#undef	FATAL_SIG

  /* Make sure stdout is line-buffered.  */

#ifdef	HAVE_SETLINEBUF
  setlinebuf (stdout);
#else
#ifndef	SETVBUF_REVERSED
  setvbuf (stdout, (char *) 0, _IOLBF, BUFSIZ);
#else	/* setvbuf not reversed.  */
  /* Some buggy systems lose if we pass 0 instead of allocating ourselves.  */
  setvbuf (stdout, _IOLBF, xmalloc (BUFSIZ), BUFSIZ);
#endif	/* setvbuf reversed.  */
#endif	/* setlinebuf missing.  */

  /* Initialize the directory hashing code.  */
  init_dir ();

  /* Set up to access user data (files).  */
  user_access ();

  /* Figure out where this program lives.  */

  if (argv[0] == 0)
    argv[0] = "";
  if (argv[0][0] == '\0')
    program = "make";
  else 
    {
      program = rindex (argv[0], '/');
      if (program == 0)
	program = argv[0];
      else
	++program;
    }

  /* Figure out where we are.  */

  if (getcwd (current_directory, GET_PATH_MAX) == 0)
    {
#ifdef	HAVE_GETCWD
      perror_with_name ("getcwd: ", "");
#else
      error ("getwd: %s", current_directory);
#endif
      current_directory[0] = '\0';
      directory_before_chdir = 0;
    }
  else
    directory_before_chdir = savestring (current_directory,
					 strlen (current_directory));

  /* Read in variables from the environment.  It is important that this be
     done before `MAKE' and `MAKEOVERRIDES' are figured out so their
     definitions will not be ones from the environment.  */

  for (i = 0; envp[i] != 0; ++i)
    {
      register char *ep = envp[i];
      while (*ep++ != '=')
	;
      (void) define_variable (envp[i], ep - envp[i] - 1, ep, o_env, 1);
    }

  /* Decode the switches.  */

  decode_env_switches ("MAKEFLAGS", 9);
  decode_env_switches ("MFLAGS", 6);
  decode_switches (argc, argv, 0);

  /* Print version information.  */

  if (print_version_flag || print_data_base_flag || debug_flag)
    print_version ();

  /* `make --version' is supposed to just print the version and exit.  */
  if (print_version_flag)
    die (1);

  /* Search for command line arguments that define variables,
     and do the definitions.  Also save up the text of these
     arguments in CMD_DEFS so we can put them into the values
     of $(MAKEOVERRIDES) and $(MAKE).  */

  cmd_defs_len = 200;
  cmd_defs = (char *) xmalloc (cmd_defs_len);
  cmd_defs_idx = 0;

  for (i = 1; other_args->list[i] != 0; ++i)
    {
      if (other_args->list[i][0] == '\0')
	/* Ignore empty arguments, so they can't kill enter_file.  */
	continue;

      /* Try a variable definition.  */
      if (try_variable_definition ((char *) 0, 0,
				   other_args->list[i], o_command))
	{
	  /* It succeeded.  The variable is already defined.
	     Backslash-quotify it and append it to CMD_DEFS, then clobber it
	     to 0 in the list so that it won't be taken for a goal target.  */
	  register char *p = other_args->list[i];
	  unsigned int l = strlen (p);
	  if (cmd_defs_idx + (l * 2) + 1 > cmd_defs_len)
	    {
	      if (l * 2 > cmd_defs_len)
		cmd_defs_len += l * 2;
	      else
		cmd_defs_len *= 2;
	      cmd_defs = (char *) xrealloc (cmd_defs, cmd_defs_len);
	    }
	  
	  while (*p != '\0')
	    {
	      if (index (";'\"*?[]$<>(){}|&~`\\ \t\r\n\f\v", *p) != 0)
		cmd_defs[cmd_defs_idx++] = '\\';
	      cmd_defs[cmd_defs_idx++] = *p++;
	    }
	  cmd_defs[cmd_defs_idx++] = ' ';
	}
      else
	{
	  /* It was not a variable definition, so it is a target to be made.
	     Enter it as a file and add it to the dep chain of goals.  */
	  f = enter_file (other_args->list[i]);
	  f->cmd_target = 1;
	  
	  if (goals == 0)
	    {
	      goals = (struct dep *) xmalloc (sizeof (struct dep));
	      lastgoal = goals;
	    }
	  else
	    {
	      lastgoal->next = (struct dep *) xmalloc (sizeof (struct dep));
	      lastgoal = lastgoal->next;
	    }
	  lastgoal->name = 0;
	  lastgoal->file = f;
	}
    }

  if (cmd_defs_idx > 0)
    {
      cmd_defs[cmd_defs_idx - 1] = '\0';
      (void) define_variable ("MAKEOVERRIDES", 13, cmd_defs, o_default, 0);
    }
  free (cmd_defs);

  /* Set the "MAKE_COMMAND" variable to the name we were invoked with.
     (If it is a relative pathname with a slash, prepend our directory name
     so the result will run the same program regardless of the current dir.
     If it is a name with no slash, we can only hope that PATH did not
     find it in the current directory.)  */

  if (current_directory[0] != '\0'
      && argv[0] != 0 && argv[0][0] != '/' && index (argv[0], '/') != 0)
    argv[0] = concat (current_directory, "/", argv[0]);

  (void) define_variable ("MAKE_COMMAND", 12, argv[0], o_default, 0);

  /* Append the command-line variable definitions gathered above
     so sub-makes will get them as command-line definitions.  */

  (void) define_variable ("MAKE", 4,
			  "$(MAKE_COMMAND) $(MAKEOVERRIDES)", o_default, 1);

  /* If there were -C flags, move ourselves about.  */

  if (directories != 0)
    for (i = 0; directories->list[i] != 0; ++i)
      {
	char *dir = directories->list[i];
	if (chdir (dir) < 0)
	  pfatal_with_name (dir);
      }

  /* Figure out the level of recursion.  */
  {
    struct variable *v = lookup_variable ("MAKELEVEL", 9);
    if (v != 0 && *v->value != '\0' && *v->value != '-')
      makelevel = (unsigned int) atoi (v->value);
    else
      makelevel = 0;
  }

  /* Except under -s, always do -w in sub-makes and under -C.  */
  if (!silent_flag && (directories != 0 || makelevel > 0))
    print_directory_flag = 1;

  /* Let the user disable that with --no-print-directory.  */
  if (inhibit_print_directory_flag)
    print_directory_flag = 0;

  /* Construct the list of include directories to search.  */

  construct_include_path (include_directories == 0 ? (char **) 0
			  : include_directories->list);

  /* Figure out where we are now, after chdir'ing.  */
  if (directories == 0)
    /* We didn't move, so we're still in the same place.  */
    starting_directory = current_directory;
  else
    {
      if (getcwd (current_directory, GET_PATH_MAX) == 0)
	{
#ifdef	HAVE_GETCWD
	  perror_with_name ("getcwd: ", "");
#else
	  error ("getwd: %s", current_directory);
#endif
	  starting_directory = 0;
	}
      else
	starting_directory = current_directory;
    }

  /* Tell the user where he is.  */

  if (print_directory_flag)
    log_working_directory (1);

  /* Read any stdin makefiles into temporary files.  */

  if (makefiles != 0)
    {
      register unsigned int i;
      for (i = 0; i < makefiles->idx; ++i)
	if (makefiles->list[i][0] == '-' && makefiles->list[i][1] == '\0')
	  {
	    /* This makefile is standard input.  Since we may re-exec
	       and thus re-read the makefiles, we read standard input
	       into a temporary file and read from that.  */
	    static char name[] = "/tmp/GmXXXXXX";
	    FILE *outfile;

	    /* Free the storage allocated for "-".  */
	    free (makefiles->list[i]);

	    /* Make a unique filename.  */
	    (void) mktemp (name);

	    outfile = fopen (name, "w");
	    if (outfile == 0)
	      pfatal_with_name ("fopen (temporary file)");
	    while (!feof (stdin))
	      {
		char buf[2048];
		int n = fread (buf, 1, sizeof(buf), stdin);
		if (n > 0 && fwrite (buf, 1, n, outfile) != n)
		  pfatal_with_name ("fwrite (temporary file)");
	      }
	    /* Try to make sure we won't remake the temporary
	       file when we are re-exec'd.  Kludge-o-matic!  */
	    fprintf (outfile, "%s:;\n", name);
	    (void) fclose (outfile);

	    /* Replace the name that read_all_makefiles will
	       see with the name of the temporary file.  */
	    makefiles->list[i] = savestring (name, sizeof name - 1);

	    /* Make sure the temporary file will not be remade.  */
	    f = enter_file (savestring (name, sizeof name - 1));
	    f->updated = 1;
	    f->update_status = 0;
	    f->command_state = cs_finished;
	    /* Let it be removed when we're done.  */
	    f->intermediate = 1;
	    /* But don't mention it.  */
	    f->dontcare = 1;
	  }
    }

  /* Set up to handle children dying.  This must be done before
     reading in the makefiles so that `shell' function calls will work.  */

#ifdef SIGCHLD
  (void) signal (SIGCHLD, child_handler);
#endif
#ifdef SIGCLD
  (void) signal (SIGCLD, child_handler);
#endif

  /* Define the initial list of suffixes for old-style rules.  */

  set_default_suffixes ();

  /* Define some internal and special variables.  */

  define_automatic_variables ();

  /* Set up the MAKEFLAGS and MFLAGS variables
     so makefiles can look at them.  */

  define_makeflags (0, 0);

  /* Define the default variables.  */
  define_default_variables ();

  /* Read all the makefiles.  */

  default_file = enter_file (".DEFAULT");

  read_makefiles
    = read_all_makefiles (makefiles == 0 ? (char **) 0 : makefiles->list);

  /* Decode switches again, in case the variables were set by the makefile.  */
  decode_env_switches ("MAKEFLAGS", 9);
  decode_env_switches ("MFLAGS", 6);

  /* Set up MAKEFLAGS and MFLAGS again, so they will be right.  */

  define_makeflags (1, 0);

  ignore_errors_flag |= lookup_file (".IGNORE") != 0;

  silent_flag |= lookup_file (".SILENT") != 0;

  /* Make each `struct dep' point at the
     `struct file' for the file depended on.  */

  snap_deps ();

  /* Install the default implicit rules.
     This used to be done before reading the makefiles.
     But in that case, built-in pattern rules were in the chain
     before user-defined ones, so they matched first.  */

  install_default_implicit_rules ();

  /* Convert old-style suffix rules to pattern rules.  */

  convert_to_pattern ();

  /* Compute implicit rule limits.  */

  count_implicit_rule_limits ();

  /* Construct the listings of directories in VPATH lists.  */

  build_vpath_lists ();

  /* Mark files given with -o flags as very old (00:00:01.00 Jan 1, 1970)
     and as having been updated already, and files given with -W flags
     as brand new (time-stamp of now).  */

  if (old_files != 0)
    for (p = old_files->list; *p != 0; ++p)
      {
	f = enter_file (*p);
	f->last_mtime = (time_t) 1;
	f->updated = 1;
	f->update_status = 0;
	f->command_state = cs_finished;
      }

  if (new_files != 0)
    {
      now = time ((time_t *) 0);
      for (p = new_files->list; *p != 0; ++p)
	{
	  f = enter_file (*p);
	  f->last_mtime = now;
	}
    }

  if (read_makefiles != 0)
    {
      /* Update any makefiles if necessary.  */

      time_t *makefile_mtimes = 0;
      unsigned int mm_idx = 0;

      if (debug_flag)
	puts ("Updating makefiles....");

      /* Remove any makefiles we don't want to try to update.
	 Also record the current modtimes so we can compare them later.  */
      {
	register struct dep *d, *last;
	last = 0;
	d = read_makefiles;
	while (d != 0)
	  {
	    register struct file *f = d->file;
	    if (f->double_colon)
	      do
		{
		  if (f->deps == 0 && f->cmds != 0)
		    {
		      /* This makefile is a :: target with commands, but
			 no dependencies.  So, it will always be remade.
			 This might well cause an infinite loop, so don't
			 try to remake it.  (This will only happen if
			 your makefiles are written exceptionally
			 stupidly; but if you work for Athena, that's how
			 you write your makefiles.)  */

		      if (debug_flag)
			printf ("Makefile `%s' might loop; not remaking it.\n",
				f->name);

		      if (last == 0)
			read_makefiles = d->next;
		      else
			last->next = d->next;

		      /* Free the storage.  */
		      free ((char *) d);

		      d = last == 0 ? 0 : last->next;

		      break;
		    }
		  f = f->prev;
		}
	      while (f != NULL);
	    if (f == NULL || !f->double_colon)
	      {
		if (makefile_mtimes == 0)
		  makefile_mtimes = (time_t *) xmalloc (sizeof (time_t));
		else
		  makefile_mtimes = (time_t *)
		    xrealloc ((char *) makefile_mtimes,
			      (mm_idx + 1) * sizeof (time_t));
		makefile_mtimes[mm_idx++] = file_mtime_no_search (d->file);
		last = d;
		d = d->next;
	      }
	  }
      }	

      /* Set up `MAKEFLAGS' specially while remaking makefiles.  */
      define_makeflags (1, 1);

      switch (update_goal_chain (read_makefiles, 1))
	{
	default:
	  abort ();
	  
	case -1:
	  /* Did nothing.  */
	  break;
	  
	case 1:
	  /* Failed to update.  Figure out if we care.  */
	  {
	    /* Nonzero if any makefile was successfully remade.  */
	    int any_remade = 0;
	    /* Nonzero if any makefile we care about failed
	       in updating or could not be found at all.  */
	    int any_failed = 0;
	    register unsigned int i;

	    for (i = 0; read_makefiles != 0; ++i)
	      {
		struct dep *d = read_makefiles;
		read_makefiles = d->next;
		if (d->file->updated)
		  {
		    /* This makefile was updated.  */
		    if (d->file->update_status == 0)
		      {
			/* It was successfully updated.  */
			any_remade |= (file_mtime_no_search (d->file)
				       != makefile_mtimes[i]);
		      }
		    else if (d->changed != 1)
		      {
			time_t mtime;
			/* The update failed and this makefile was not
			   from the MAKEFILES variable, so we care.  */
			error ("Failed to remake makefile `%s'.",
			       d->file->name);
			mtime = file_mtime_no_search (d->file);
			any_remade |= (mtime != (time_t) -1
				       && mtime != makefile_mtimes[i]);
		      }
		  }
		else
		  /* This makefile was not found at all.  */
		  switch (d->changed)
		    {
		    case 0:
		      /* A normal makefile.  We must die later.  */
		      error ("Makefile `%s' was not found", dep_name (d));
		      any_failed = 1;
		      break;
		    case 1:
		      /* A makefile from the MAKEFILES variable.
			 We don't care.  */
		      break;
		    case 2:
		      /* An included makefile.  We don't need
			 to die, but we do want to complain.  */
		      error ("Included makefile `%s' was not found.",
			     dep_name (d));
		      break;
		    }

		free ((char *) d);
	      }

	    if (any_remade)
	      goto re_exec;
	    else if (any_failed)
	      die (1);
	    else
	      break;
	  }

	case 0:
	re_exec:;
	  /* Updated successfully.  Re-exec ourselves.  */
	  if (print_directory_flag)
	    log_working_directory (0);
	  if (debug_flag)
	    puts ("Re-execing myself....");
	  if (makefiles != 0)
	    {
	      /* These names might have changed.  */
	      register unsigned int i, j = 0;
	      for (i = 1; i < argc; ++i)
		if (!strcmp (argv[i], "-f"))
		  {
		    char *p = &argv[i][2];
		    if (*p == '\0')
		      argv[++i] = makefiles->list[j];
		    else
		      argv[i] = concat ("-f", makefiles->list[j], "");
		    ++j;
		  }
	    }
	  if (directories != 0 && directories->idx > 0)
	    {
	      char bad;
	      if (directory_before_chdir != 0)
		{
		  if (chdir (directory_before_chdir) < 0)
		    {
		      perror_with_name ("chdir", "");
		      bad = 1;
		    }
		  else
		    bad = 0;
		}
	      else
		bad = 1;
	      if (bad)
		fatal ("Couldn't change back to original directory.");
	    }
	  fflush (stdout);
	  fflush (stderr);
	  for (p = environ; *p != 0; ++p)
	    if (!strncmp (*p, "MAKELEVEL=", 10))
	      {
		/* The SGI compiler apparently can't understand
		   the concept of storing the result of a function
		   in something other than a local variable.  */
		char *sgi_loses;
		sgi_loses = (char *) alloca (40);
		*p = sgi_loses;
		sprintf (*p, "MAKELEVEL=%u", makelevel);
		break;
	      }
	  exec_command (argv, environ);
	  /* NOTREACHED */
	}
    }

  /* Set up `MAKEFLAGS' again for the normal targets.  */
  define_makeflags (1, 0);

  {
    int status;

    /* If there were no command-line goals, use the default.  */
    if (goals == 0)
      {
	if (default_goal_file != 0)
	  {
	    goals = (struct dep *) xmalloc (sizeof (struct dep));
	    goals->next = 0;
	    goals->name = 0;
	    goals->file = default_goal_file;
	  }
      }
    else
      lastgoal->next = 0;

    if (goals != 0)
      {
	/* Update the goals.  */

	if (debug_flag)
	  puts ("Updating goal targets....");

	switch (update_goal_chain (goals, 0))
	  {
	  case -1:
	    /* Nothing happened.  */
	  case 0:
	    /* Updated successfully.  */
	    status = 0;
	    break;
	  case 1:
	    /* Updating failed.  */
	    status = 1;
	    break;
	  default:
	    abort ();
	  }
      }
    else
      {
	if (read_makefiles == 0)
	  fatal ("No targets specified and no makefile found");
	else
	  fatal ("No targets");
      }

    /* Exit.  */
    die (status);
  }

  return 0;
}

/* Parsing of arguments, decoding of switches.  */

static char options[sizeof (switches) / sizeof (switches[0]) * 3];
static struct option long_options[(sizeof (switches) / sizeof (switches[0])) +
				  (sizeof (long_option_aliases) /
				   sizeof (long_option_aliases[0]))];

/* Fill in the string and vector for getopt.  */
static void
init_switches ()
{
  register char *p;
  register int c;
  register unsigned int i;

  if (options[0] != '\0')
    /* Already done.  */
    return;

  p = options;
  for (i = 0; switches[i].c != '\0'; ++i)
    {
      long_options[i].name = (switches[i].long_name == 0 ? "" :
			      switches[i].long_name);
      long_options[i].flag = 0;
      long_options[i].val = switches[i].c;
      if (isalnum (switches[i].c))
	*p++ = switches[i].c;
      switch (switches[i].type)
	{
	case flag:
	case flag_off:
	case ignore:
	case usage_and_exit:
	  long_options[i].has_arg = no_argument;
	  break;

	case string:
	case positive_int:
	case floating:
	  if (isalnum (switches[i].c))
	    *p++ = ':';
	  if (switches[i].noarg_value != 0)
	    {
	      if (isalnum (switches[i].c))
		*p++ = ':';
	      long_options[i].has_arg = optional_argument;
	    }
	  else
	    long_options[i].has_arg = required_argument;
	  break;
	}
    }
  *p = '\0';
  for (c = 0; c < (sizeof (long_option_aliases) /
		   sizeof (long_option_aliases[0]));
       ++c)
    long_options[i++] = long_option_aliases[c];
  long_options[i].name = 0;
}

/* Decode switches from ARGC and ARGV.
   They came from the environment if ENV is nonzero.  */

static void
decode_switches (argc, argv, env)
     int argc;
     char **argv;
     int env;
{
  int bad = 0;
  register const struct command_switch *cs;
  register struct stringlist *sl;
  register int c;

  if (!env)
    {
      other_args = (struct stringlist *) xmalloc (sizeof (struct stringlist));
      other_args->max = argc + 1;
      other_args->list = (char **) xmalloc ((argc + 1) * sizeof (char *));
      other_args->idx = 1;
      other_args->list[0] = savestring (argv[0], strlen (argv[0]));
    }

  /* getopt does most of the parsing for us.
     First, get its vectors set up.  */

  init_switches ();

  /* Let getopt produce error messages for the command line,
     but not for options from the environment.  */
  opterr = !env;
  /* Reset getopt's state.  */
  optind = 0;

  while ((c = getopt_long (argc, argv,
			   options, long_options, (int *) 0)) != EOF)
    {
      if (c == '?')
	/* Bad option.  We will print a usage message and die later.
	   But continue to parse the other options so the user can
	   see all he did wrong.  */
	bad = 1;
      else
	for (cs = switches; cs->c != '\0'; ++cs)
	  if (cs->c == c)
	    {
	      /* Whether or not we will actually do anything with
		 this switch.  We test this individually inside the
		 switch below rather than just once outside it, so that
		 options which are to be ignored still consume args.  */
	      int doit = !env || cs->env;

	      switch (cs->type)
		{
		default:
		  abort ();

		case ignore:
		  break;

		case usage_and_exit:
		  bad = 1;
		  break;

		case flag:
		case flag_off:
		  if (doit)
		    *(int *) cs->value_ptr = cs->type == flag;
		  break;

		case string:
		  if (!doit)
		    break;

		  if (optarg == 0)
		    optarg = cs->noarg_value;

		  sl = *(struct stringlist **) cs->value_ptr;
		  if (sl == 0)
		    {
		      sl = (struct stringlist *)
			xmalloc (sizeof (struct stringlist));
		      sl->max = 5;
		      sl->idx = 0;
		      sl->list = (char **) xmalloc (5 * sizeof (char *));
		      *(struct stringlist **) cs->value_ptr = sl;
		    }
		  else if (sl->idx == sl->max - 1)
		    {
		      sl->max += 5;
		      sl->list = (char **)
			xrealloc ((char *) sl->list,
				  sl->max * sizeof (char *));
		    }
		  sl->list[sl->idx++] = savestring (optarg, strlen (optarg));
		  sl->list[sl->idx] = 0;
		  break;

		case positive_int:
		  if (optarg == 0 && argc > optind
		      && isdigit (argv[optind][0]))
		    optarg = argv[optind++];

		  if (!doit)
		    break;

		  if (optarg != 0)
		    {
		      int i = atoi (optarg);
		      if (i < 1)
			{
			  if (doit)
			    error ("the `-%c' option requires a \
positive integral argument",
				   cs->c);
			  bad = 1;
			}
		      else
			*(unsigned int *) cs->value_ptr = i;
		    }
		  else
		    *(unsigned int *) cs->value_ptr
		      = *(unsigned int *) cs->noarg_value;
		  break;

		case floating:
		  if (optarg == 0 && optind < argc
		      && (isdigit (argv[optind][0]) || argv[optind][0] == '.'))
		    optarg = argv[optind++];

		  if (doit)
		    *(double *) cs->value_ptr		    
		      = (optarg != 0 ? atof (optarg)
			 : *(double *) cs->noarg_value);

		  break;
		}
	    
	      /* We've found the switch.  Stop looking.  */
	      break;
	    }
    }

  if (!env)
    {
      /* Collect the remaining args in the `other_args' string list.  */

      while (optind < argc)
	{
	  char *arg = argv[optind++];
	  if (arg[0] != '-' || arg[1] != '\0')
	    other_args->list[other_args->idx++] = arg;
	}
      other_args->list[other_args->idx] = 0;
    }

  if (bad && !env)
    {
      /* Print a nice usage message.  */

      if (print_version_flag)
	print_version ();

      fprintf (stderr, "Usage: %s [options] [target] ...\n", program);

      fputs ("Options:\n", stderr);
      for (cs = switches; cs->c != '\0'; ++cs)
	{
	  char buf[1024], arg[50], *p;

	  if (cs->description[0] == '-')
	    continue;

	  switch (long_options[cs - switches].has_arg)
	    {
	    case no_argument:
	      arg[0] = '\0';
	      break;
	    case required_argument:
	      sprintf (arg, " %s", cs->argdesc);
	      break;
	    case optional_argument:
	      sprintf (arg, " [%s]", cs->argdesc);
	      break;
	    }

	  p = buf;

	  if (isalnum (cs->c))
	    {
	      sprintf (buf, "  -%c%s", cs->c, arg);
	      p += strlen (p);
	    }
	  if (cs->long_name != 0)
	    {
	      unsigned int i;
	      sprintf (p, "%s--%s%s",
		       !isalnum (cs->c) ? "  " : ", ",
		       cs->long_name, arg);
	      p += strlen (p);
	      for (i = 0; i < (sizeof (long_option_aliases) /
			       sizeof (long_option_aliases[0]));
		   ++i)
		if (long_option_aliases[i].val == cs->c)
		  {
		    sprintf (p, ", --%s%s", long_option_aliases[i].name, arg);
		    p += strlen (p);
		  }
	    }
	  {
	    const struct command_switch *ncs = cs;
	    while ((++ncs)->c != '\0')
	      if (ncs->description[0] == '-' &&
		  ncs->description[1] == cs->c)
		{
		  /* This is another switch that does the same
		     one as the one we are processing.  We want
		     to list them all together on one line.  */
		  sprintf (p, ", -%c%s", ncs->c, arg);
		  p += strlen (p);
		  if (ncs->long_name != 0)
		    {
		      sprintf (p, ", --%s%s", ncs->long_name, arg);
		      p += strlen (p);
		    }
		}
	  }

	  if (p - buf > DESCRIPTION_COLUMN - 2)
	    /* The list of option names is too long to fit on the same
	       line with the description, leaving at least two spaces.
	       Print it on its own line instead.  */
	    {
	      fprintf (stderr, "%s\n", buf);
	      buf[0] = '\0';
	    }

	  fprintf (stderr, "%*s%s.\n",
		   - DESCRIPTION_COLUMN,
		   buf, cs->description);
	}

      die (1);
    }
}

/* Decode switches from environment variable ENVAR (which is LEN chars long).
   We do this by chopping the value into a vector of words, prepending a
   dash to the first word if it lacks one, and passing the vector to
   decode_switches.  */

static void
decode_env_switches (envar, len)
     char *envar;
     unsigned int len;
{
  char *varref = (char *) alloca (2 + len + 2);
  char *value, *args;
  int argc;
  char **argv;

  /* Get the variable's value.  */
  varref[0] = '$';
  varref[1] = '(';
  bcopy (envar, &varref[2], len);
  varref[2 + len] = ')';
  varref[2 + len + 1] = '\0';
  value = variable_expand (varref);

  /* Skip whitespace, and check for an empty value.  */
  value = next_token (value);
  len = strlen (value);
  if (len == 0)
    return;

  /* Make a copy of the value in ARGS, where we will munge it.
     If it does not begin with a dash, prepend one.  */
  args = (char *) alloca (1 + len + 2);
  if (value[0] != '-')
    args[0] = '-';
  bcopy (value, value[0] == '-' ? args : &args[1], len + 1);
  /* Write an extra null terminator so our loop below will
     never be in danger of looking past the end of the string.  */
  args[(value[0] == '-' ? 0 : 1) + len + 1] = '\0';

  /* Allocate a vector that is definitely big enough.  */
  argv = (char **) alloca ((1 + len + 1) * sizeof (char *));

  /* getopt will look at the arguments starting at ARGV[1].
     Prepend a spacer word.  */
  argv[0] = 0;
  argc = 1;
  do
    {
      argv[argc++] = args;
      args = end_of_token (args);
      *args++ = '\0';
    } while (*args != '\0');
  argv[argc] = 0;

  /* Parse those words.  */
  decode_switches (argc, argv, 1);
}

/* Define the MAKEFLAGS and MFLAGS variables to reflect the settings of the
   command switches.  Include options with args if ALL is nonzero.
   Don't include options with the `no_makefile' flag set if MAKEFILE.  */

static void
define_makeflags (all, makefile)
     int all, makefile;
{
  register const struct command_switch *cs;
  char *flagstring;

  /* We will construct a linked list of `struct flag's describing
     all the flags which need to go in MAKEFLAGS.  Then, once we
     know how many there are and their lengths, we can put them all
     together in a string.  */

  struct flag
    {
      struct flag *next;
      const struct command_switch *cs;
      char *arg;
      unsigned int arglen;
    };
  struct flag *flags = 0;
  unsigned int flagslen = 0;
#define	ADD_FLAG(ARG, LEN) \
  do {									      \
    struct flag *new = (struct flag *) alloca (sizeof (struct flag));	      \
    new->cs = cs;							      \
    new->arg = (ARG);							      \
    new->arglen = (LEN);						      \
    new->next = flags;							      \
    flags = new;							      \
    if (new->arg == 0)							      \
      ++flagslen;		/* Just a single flag letter.  */	      \
    else								      \
      flagslen += 1 + 1 + 1 + 1 + new->arglen; /* " -x foo" */		      \
    if (!isalnum (cs->c))						      \
      /* This switch has no single-letter version, so we use the long.  */    \
      flagslen += 2 + strlen (cs->long_name);				      \
  } while (0)

  for (cs = switches; cs->c != '\0'; ++cs)
    if (cs->toenv && (!makefile || !cs->no_makefile))
      switch (cs->type)
	{
	default:
	  abort ();

	case ignore:
	  break;

	case flag:
	case flag_off:
	  if (!*(int *) cs->value_ptr == (cs->type == flag_off)
	      && (cs->default_value == 0
		  || *(int *) cs->value_ptr != *(int *) cs->default_value))
	    ADD_FLAG (0, 0);
	  break;

	case positive_int:
	  if (all)
	    {
	      if ((cs->default_value != 0
		   && (*(unsigned int *) cs->value_ptr
		       == *(unsigned int *) cs->default_value)))
		break;
	      else if (cs->noarg_value != 0
		       && (*(unsigned int *) cs->value_ptr ==
			   *(unsigned int *) cs->noarg_value))
		ADD_FLAG ("", 0); /* Optional value omitted; see below.  */
	      else if (cs->c == 'j')
		/* Special case for `-j'.  */
		ADD_FLAG ("1", 1);
	      else
		{
		  char *buf = (char *) alloca (30);
		  sprintf (buf, "%u", *(unsigned int *) cs->value_ptr);
		  ADD_FLAG (buf, strlen (buf));
		}
	    }
	  break;

	case floating:
	  if (all)
	    {
	      if (cs->default_value != 0
		  && (*(double *) cs->value_ptr
		      == *(double *) cs->default_value))
		break;
	      else if (cs->noarg_value != 0
		       && (*(double *) cs->value_ptr
			   == *(double *) cs->noarg_value))
		ADD_FLAG ("", 0); /* Optional value omitted; see below.  */
	      else
		{
		  char *buf = (char *) alloca (100);
		  sprintf (buf, "%g", *(double *) cs->value_ptr);
		  ADD_FLAG (buf, strlen (buf));
		}
	    }
	  break;

	case string:
	  if (all)
	    {
	      struct stringlist *sl = *(struct stringlist **) cs->value_ptr;
	      if (sl != 0)
		{
		  /* Add the elements in reverse order, because
		     all the flags get reversed below; and the order
		     matters for some switches (like -I).  */
		  register unsigned int i = sl->idx;
		  while (i-- > 0)
		    ADD_FLAG (sl->list[i], strlen (sl->list[i]));
		}
	    }
	  break;
	}

#undef	ADD_FLAG

  if (flags == 0)
    /* No flags.  Use a string of two nulls so [1] works below.  */
    flagstring = "\0";
  else
    {
      /* Construct the value in FLAGSTRING.
	 We allocate enough space for a preceding dash and trailing null.  */
      register char *p;
      flagstring = (char *) alloca (1 + flagslen + 1);
      p = flagstring;
      *p++ = '-';
      do
	{
	  /* Add the flag letter or name to the string.  */
	  if (!isalnum (flags->cs->c))
	    {
	      *p++ = '-';
	      strcpy (p, flags->cs->long_name);
	      p += strlen (p);
	    }
	  else
	    *p++ = flags->cs->c;
	  if (flags->arg != 0)
	    {
	      /* A flag that takes an optional argument which in this case
		 is omitted is specified by ARG being "" and ARGLEN being 0.
		 We must distinguish because a following flag appended without
		 an intervening " -" is considered the arg for the first.  */
	      if (flags->arglen > 0)
		{
		  /* Add its argument too.  */
		  *p++ = !isalnum (flags->cs->c) ? '=' : ' ';
		  bcopy (flags->arg, p, flags->arglen);
		  p += flags->arglen;
		}
	      /* Write a following space and dash, for the next flag.  */
	      *p++ = ' ';
	      *p++ = '-';
	    }
	  else if (!isalnum (flags->cs->c))
	    {
	      /* Long options must each go in their own word,
		 so we write the following space and dash.  */
	      *p++ = ' ';
	      *p++ = '-';
	    }
	  flags = flags->next;
	} while (flags != 0);

      if (p[-1] == '-')
	/* Kill the final space and dash.  */
	p -= 2;

      /* Terminate the string.  */
      *p = '\0';
    }

  (void) define_variable ("MAKEFLAGS", 9,
			  /* On Sun, the value of MFLAGS starts with a `-' but
			     the value of MAKEFLAGS lacks the `-'.
			     Be compatible with this unless FLAGSTRING starts
			     with a long option `--foo', since removing the
			     first dash would result in the bogus `-foo'.  */
			  flagstring[1] == '-' ? flagstring : &flagstring[1],
			  o_env, 0);
  (void) define_variable ("MFLAGS", 6, flagstring, o_env, 0);
}

/* Print version information.  */

static void
print_version ()
{
  static int printed_version = 0;

  extern char *remote_description;
  char *precede = print_data_base_flag ? "# " : "";

  if (printed_version)
    /* Do it only once.  */
    return;

  printf ("%sGNU Make version %s", precede, version_string);
  if (remote_description != 0 && *remote_description != '\0')
    printf ("-%s", remote_description);

  printf (", by Richard Stallman and Roland McGrath.\n\
%sCopyright (C) 1988, 89, 90, 91, 92, 93 Free Software Foundation, Inc.\n\
%sThis is free software; see the source for copying conditions.\n\
%sThere is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A\n\
%sPARTICULAR PURPOSE.\n\n", precede, precede, precede, precede);

  printed_version = 1;

  /* Flush stdout so the user doesn't have to wait to see the
     version information while things are thought about.  */
  fflush (stdout);
}

/* Print a bunch of information about this and that.  */

static void
print_data_base ()
{
  extern char *ctime ();
  time_t when;

  when = time ((time_t *) 0);
  printf ("\n# Make data base, printed on %s", ctime (&when));

  print_variable_data_base ();
  print_dir_data_base ();
  print_rule_data_base ();
  print_file_data_base ();
  print_vpath_data_base ();

  when = time ((time_t *) 0);
  printf ("\n# Finished Make data base on %s\n", ctime (&when));
}

/* Exit with STATUS, cleaning up as necessary.  */

void
die (status)
     int status;
{
  static char dying = 0;

  if (!dying)
    {
      int err;

      dying = 1;

      if (print_version_flag)
	print_version ();

      /* Wait for children to die.  */
      for (err = status != 0; job_slots_used > 0; err = 0)
	reap_children (1, err);

      /* Remove the intermediate files.  */
      remove_intermediates (0);

      if (print_data_base_flag)
	print_data_base ();

      if (print_directory_flag)
	log_working_directory (0);
    }

  exit (status);
}

/* Write a message indicating that we've just entered or
   left (according to ENTERING) the current directory.  */

static void
log_working_directory (entering)
     int entering;
{
  static int entered = 0;
  char *message = entering ? "Entering" : "Leaving";

  if (entering)
    entered = 1;
  else if (!entered)
    /* Don't print the leaving message if we
       haven't printed the entering message.  */
    return;

  if (print_data_base_flag)
    fputs ("# ", stdout);

  if (makelevel == 0)
    printf ("%s: %s ", program, message);
  else
    printf ("%s[%u]: %s ", program, makelevel, message);

  if (starting_directory == 0)
    puts ("an unknown directory");
  else
    printf ("directory `%s'\n", starting_directory);
}



/* ============================================================================
 * SOURCE 16/98: minix4\libos\lib_legacy\openssl\sunos\SUNVIDEO\main.c
 * Size: 6,148 bytes, Lines: 251
 * Hash: d8d079257585...
 * ============================================================================ */


#ifndef lint
static char sccsid[] = "@(#)main.c 1.1 92/07/30 Copyr 1989 Sun Micro";
#endif

#include <stdio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <pixrect/pixrect.h>
#include <pixrect/memvar.h>

#include <sunwindow/notify.h>

#include <suntool/sunview.h>
#include <suntool/panel.h>
#include <suntool/canvas.h>
#include <video.h>

static short video_icon_image[256] =
{
#include "video_icon.h"
};
mpr_static(icon_pixrect, 64, 64, 1, video_icon_image);

Window video_frame,
       video_window,
       file_panel,
       video_adjust_panel,
       video_panel,
       video_config_panel,
       video_blanket,
       create_file_panel(),
       create_video_adjust_panel(),
       create_video_panel(),
       create_video_config_panel();

struct pixrect *my_video_pixrect;

Menu video_menu;

Icon video_icon;

extern Notify_value video_poll();

static char *default_list[]= {
    "Luma_gain=0",
    "Chroma_gain=0",
    "RGB_gain=0",
    "RGB_black_level=0",
    "Zoom=1/1",
    "Video_live=Live",
    "Output_select=On screen",
    "Save_as=32 bit Raster File",
    "Input_format=NTSC",
    "Sync_select=Input(NTSC)",
    "Component_out=RGB",
    "Chroma_demodulation=On",
    "Sync_lock=Internal",
    "De_interlace=Fast",
    "Epsf_format=New",
    (char *) 0
};

int y_offset;

main(argc, argv)
    int argc;
    char **argv;
{
    struct itimerval	poll_timer;
    create_windows(&argc, argv);
    my_video_pixrect = (struct pixrect *)window_get(video_window,
						     VIDEO_PIXRECT);
    y_offset = (int)window_get(video_window, VIDEO_Y_OFFSET);
    window_set(video_window, VIDEO_LIVE, 0, 0);
    make_cbars(my_video_pixrect); /* put colorbars in as default pattern */
    initialize_items_from_list(default_list);
    initialize_items_from_file(".video_config");
    poll_timer.it_interval.tv_usec = 250000;
    poll_timer.it_interval.tv_sec = 0;
    poll_timer.it_value.tv_usec = 250000;
    poll_timer.it_value.tv_sec = 0;
    notify_set_itimer_func((Notify_client)main, video_poll, ITIMER_REAL,
			    &poll_timer, 0);
    window_main_loop(video_frame);
}

create_windows(argcp, argv)
    int *argcp;
    char **argv;
{
    extern video_event_proc(),
	   video_frame_event_proc(),
	   file_panel_notify(),
	   video_panel_notify(),
	   video_adjust_panel_notify(),
	   video_config_notify(),
	   blanket_repaint(),
	   quit_notify();


    video_icon = icon_create(ICON_IMAGE, &icon_pixrect, 0);
    video_frame = window_create(NULL, FRAME,
                          FRAME_LABEL, "Video",
			  FRAME_ICON, video_icon,
			  WIN_EVENT_PROC, video_frame_event_proc,
			  FRAME_ARGC_PTR_ARGV, argcp, argv,
                          0);
    video_menu = menu_create(
			    MENU_ITEM,
			     MENU_STRING, "Video Control",
			     MENU_NOTIFY_PROC, video_panel_notify,
			     0,
			    MENU_ITEM,
			     MENU_STRING, "Image Load and Save",
			     MENU_NOTIFY_PROC, file_panel_notify,
			     0,
			    MENU_ITEM,
			     MENU_STRING, "Video Adjust",
			     MENU_NOTIFY_PROC, video_adjust_panel_notify,
			     0,
			    MENU_ITEM,
			     MENU_STRING, "Video Configuration",
			     MENU_NOTIFY_PROC, video_config_notify,
			     0,
			    MENU_ITEM,
			    MENU_STRING, "Quit",
			    MENU_NOTIFY_PROC, quit_notify,
			     0,
			    0);
    if(!video_frame) {
	fprintf(stderr, "Must be in windows to run\n");
	exit(1);
    }
    video_window = window_create(video_frame, VIDEO,
				 WIN_EVENT_PROC, video_event_proc,
				 0);
    if(!video_window) {
	fprintf(stderr, "Device does not support video windows\n");
	exit(1);
    }
   /* The blanket canvas is used when video is output off the screen */
    /* so that cursor and the display remains intact. */
    video_blanket = window_create(video_frame, CANVAS,
				 CANVAS_RETAINED, FALSE,
				 CANVAS_AUTO_EXPAND, TRUE,
				 CANVAS_AUTO_SHRINK, TRUE,
				 WIN_SHOW, FALSE,
				 WIN_EVENT_PROC, video_event_proc,
				 CANVAS_REPAINT_PROC, blanket_repaint,
				 0);
    window_fit(video_window);
    window_fit_width(video_frame);
    
    file_panel = create_file_panel(video_frame);
    video_adjust_panel = create_video_adjust_panel(video_frame);
    video_panel = create_video_panel(video_frame);
    video_config_panel = create_video_config_panel(video_frame);
    window_fit(video_window);
    window_fit(video_frame);    
}


video_frame_event_proc(window, event, arg)
    Window window;
    Event *event;
    caddr_t arg;
{
    int id;

    switch (id=event_id(event)) {
	case WIN_RESIZE:
	    window_default_event_proc(window, event, arg);
	    /* If we need to do anything else, do it here */
	    break;

	default:
	    window_default_event_proc(window, event, arg);
    }
}

video_event_proc(window, event, arg)
    Window window;
    Event *event;
    caddr_t arg;
{
    int id;

    switch (id=event_id(event)) {

	case MS_RIGHT:
	    /* Instead of passinig our window, pass the frame's */
	    /* so the menu might show */
	    menu_show(video_menu, video_frame, event, 0);
	    break;

	default:
	    window_default_event_proc(window, event, arg);
    }
}


file_panel_notify()
{
    /* Enable display of file panel */
    window_set(file_panel, WIN_SHOW, 1, 0);
}

video_panel_notify()
{
    /* Enable display of video control panel */
    window_set(video_panel, WIN_SHOW, 1, 0);
}

video_adjust_panel_notify()
{
    /* Enable display of video control panel */
    window_set(video_adjust_panel, WIN_SHOW, 1, 0);
}

video_config_notify()
{
    /* Enable display of video config panel */
    window_set(video_config_panel, WIN_SHOW, 1, 0);
}

quit_notify()
{
    exit(0);
}

blanket_repaint(canvas, pw, area)
    Canvas canvas;
    Pixwin *pw;
    Rectlist *area;
{
    static char message[]="Video being output off screen";

    Pixfont *font;
    int w, h;
    struct pr_subregion subregion;

    font = (Pixfont *)window_get(canvas, WIN_FONT);
    w = (int) window_get(canvas, WIN_WIDTH);
    h = (int) window_get(canvas, WIN_HEIGHT);
    pf_textbound(&subregion, strlen(message), font, message);
    pw_text(pw, (w - subregion.size.x)/2 - subregion.pos.x,
                (h -  subregion.size.y)/2 - subregion.pos.y,
		PIX_SRC, font, message);
}



/* ============================================================================
 * SOURCE 17/98: minix4\libos\lib_legacy\openssl\sunos\SUNVIDEO\LASERDISC\lasertool\main.c
 * Size: 4,938 bytes, Lines: 238
 * Hash: 275ae35618dc...
 * ============================================================================ */

#ifndef lint
static	char sccsid[] = "@(#)main.c 1.1 92/07/30 SMI";
#endif not lint

/*
 * Copyright (c) 1989 by Sun Microsystems, Inc.
 */


#include <stdio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <signal.h>
#include <suntool/sunview.h>
#include <suntool/panel.h>
#include <sunwindow/notify.h>
#include <suntool/alert.h>
#include <video.h>
#include "sony_laser.h"
#include "lasertool.h"

static short icon_image[] = {
#include "lasertool.icon"
};
mpr_static(icon_pixrect, 64, 64, 1, icon_image);

FILE *device;
Window base_frame, video_window;
Panel cycle_panel, button_panel, search_etc_panel;
Panel info_panel;
Icon laser_icon;

main(argc,argv)
int argc;
char **argv;
{
	extern void info_create(), button_create(), cycle_create();
	extern void search_etc_create(), alrm();
	extern int poll_fd, poll_state;
	extern int ch_go, disk_go, play_mode; 
	static Notify_value catch_intr(), poll();
	caddr_t frame_quit();
	void init_player();
	struct itimerval laser_timer;
	int no_video_window = 0;

	laser_icon = icon_create(ICON_IMAGE, &icon_pixrect, 0);

	base_frame = window_create( (Window)NULL, FRAME,
			WIN_Y, 0,
			WIN_X, 400,
			FRAME_LABEL, "LaserTool",
			FRAME_ARGC_PTR_ARGV, &argc, argv,
			FRAME_ICON, laser_icon,
			0);

	if(!base_frame) {
		fprintf(stderr,"lasertool : Must be in windows to run\n");
		exit(1);
	}

	argc--;
	argv++;
	while(argc && (**argv == '-')) {
		switch(*++*argv) { case 'n':
			no_video_window++;
			break;
		default :
			fprintf(stderr,"vid_dither : unknown flag\n");
			exit(1);
		}
		argc--;
		argv++;
	}

	if(argc == 1) {	
		if((device = (FILE *)sony_open(*argv)) == NULL) {
			fprintf(stderr,"Could not open serial line to laser disk\n");
			exit(1);
		}
	} else if(argc == 0) {
		if((device = (FILE *)sony_open((char *)NULL)) == NULL) {
			fprintf(stderr,"Could not open serial line to laser disk\n");
			exit(1);
		}
	} else {
		fprintf(stderr,"Usage : lasertool [-n] device\n");
		exit(1);
	} 
	

	/* 
	 * Initialise the disk player
	 */
	init_player();

	/*
	 * Create the video window, set i/p NTSC, sync NTSC,
	 * window size 640*480
	 */
	if(!no_video_window) {
		video_window = window_create(base_frame, VIDEO,
				WIN_WIDTH, 640,
				WIN_HEIGHT, 480,
				VIDEO_LIVE, TRUE,
				VIDEO_INPUT, VIDEO_NTSC,
				VIDEO_SYNC, VIDEO_NTSC,
				VIDEO_COMPRESSION, VIDEO_1X,
				VIDEO_DEMOD, VIDEO_DEMOD_AUTO,
				VIDEO_OUTPUT, VIDEO_ONSCREEN,
				0);
		if(!video_window) {
			fprintf(stderr,"Video windows not supported, ");
			fprintf(stderr,"using non-video window lasertool instead\n");
		}
	}

	cycle_panel = window_create(base_frame, PANEL, 
			WIN_WIDTH, 640, 
			WIN_HEIGHT, 180,
			0);
	if(video_window) {
		window_set(cycle_panel, 
			WIN_BELOW, video_window, 
			WIN_X, 0, 
			0);
	}

	info_panel = window_create(base_frame, PANEL,
			WIN_BELOW, cycle_panel,
			WIN_X, 0,
			WIN_WIDTH, 200,
			WIN_HEIGHT, 180,
			0);

	search_etc_panel = window_create(base_frame, PANEL, 
			WIN_WIDTH, 215,
			WIN_HEIGHT, 180,
			0);

	button_panel = window_create(base_frame, PANEL, 
			WIN_WIDTH, 215,
			WIN_HEIGHT, 180,
			0);

	play_mode = FWD;
	cycle_create();
	info_create();
	search_etc_create();
	button_create();
	window_fit(base_frame);

	/*
	 * Poll timer for checking completion status
	 * address, chapter and disk type
	 */
	laser_timer.it_interval.tv_usec = 4000;
	laser_timer.it_interval.tv_sec = 0;
	laser_timer.it_value.tv_usec = 4000;
	laser_timer.it_value.tv_sec = 0;
	poll_fd = fileno(device);
	poll_state = POLL_PRINT;
	ch_go = 0;
	disk_go = 0;
	notify_set_itimer_func((Notify_client)main, poll, ITIMER_REAL,
		&laser_timer, 0);

	/*
	 * Catch interrupts and clear laser disk using quit
	 */
	(void) notify_set_signal_func((Notify_client)main, catch_intr, 
		SIGINT, NOTIFY_ASYNC);

	/*
	 * Set the Frame menu quit function to use
	 * our own quit procedure
	 */
	menu_set( (Menu)menu_find( (Menu)window_get(base_frame, WIN_MENU),
				MENU_STRING, "Quit", 0),
					MENU_ACTION_PROC,
					 frame_quit, 0);

	window_main_loop(base_frame);
	exit(0);
} 

/*
 * Catch interrupts and clear laser disk 
 */
static Notify_value
catch_intr(me, signal, when)
Notify_client me;
int signal;
Notify_signal_mode when;
{
	sony_clear_all(device);
	sony_close(device);
	exit(0);
}

/*
 * Interpose frame quit action
 */
caddr_t
frame_quit(menu, menu_item)
Menu menu;
Menu_item menu_item;
{
	int result;

	result = alert_prompt((Frame)base_frame, (Event *) NULL,
		ALERT_MESSAGE_STRINGS, "Confirm quit", 0,
		ALERT_BUTTON_YES, "Confirm",
		ALERT_BUTTON_NO, "Cancel",
		ALERT_POSITION, ALERT_CLIENT_CENTERED,
		0);
	if((result == ALERT_NO) || (result == ALERT_FAILED))
		return;
	sony_clear_all(device);
	sony_close(device);
	exit(0);
}

/*
 * set the initial disk player settings
 */
void
init_player()
{
	sony_clear_all(device);
	sony_motor_on(device);
	sony_frame_mode(device);
	sony_index_off(device);
	sony_audio_mute_on(device);
	sony_video_on(device);
	sony_index_off(device);
}



/* ============================================================================
 * SOURCE 18/98: minix4\libos\lib_legacy\openssl\lib\posix\netiso\xebec\main.c
 * Size: 9,571 bytes, Lines: 411
 * Hash: fe9e410a42c2...
 * ============================================================================ */

/* $Header: /n/fast/usr/lsrc/mach/CVS/lites/server/netiso/xebec/main.c,v 1.1.1.1 1995/03/02 21:49:58 mike Exp $ */
/* $Source: /n/fast/usr/lsrc/mach/CVS/lites/server/netiso/xebec/main.c,v $ */
/*
 * TODO:
 * rewrite the command line stuff altogether - it's kludged beyond
 * belief (as is the rest of the code...)
 *
 * DISCLAIMER DISCLAIMER DISCLAIMER
 * This code is such a kludge that I don't want to put my name on it.
 * It was a ridiculously fast hack and needs rewriting.
 * However it does work...
 */

#include <stdio.h>
#include <strings.h>
#include "malloc.h"
#include "debug.h"
#include "main.h"

int	debug[128];

int lineno = 1;

FILE *statefile, *actfile, *eventfile_h, *statevalfile;
FILE *infile, *astringfile;
char *Transfilename;
char *astringfile_name = DEBUGFILE;
char *actfile_name = ACTFILE;
char *statefile_name = STATEFILE;
char *statevalfile_name = STATEVALFILE;
char *eventfile_h_name = EVENTFILE_H;
int print_trans = 0;
int print_protoerrs = 0;
int pgoption = 0;
char kerneldirname[50] = "\0";

char protocol[50];

char *synonyms[] = {
	"EVENT",
	"PCB",
	0
};

usage(a)
char *a;
{
	fprintf(stderr, 
	"usage: %s <transition file> {-D<debug options>} <other options>\n",
		a);
	fprintf(stderr, "\t<other options> is any combination of:\n");
	fprintf(stderr, "\t\t-A<action file name>\n");
	fprintf(stderr, "\t\t-E<event file name>\n");
	fprintf(stderr, "\t\t-S<state file name>\n");
	fprintf(stderr, "\t\t-I<initial values file name>\n");
	fprintf(stderr, "\t\t-X<debugging file name>\n");
	fprintf(stderr, "\t\t-K<directory name>\n");
	fprintf(stderr, 
	"\tThese names do NOT include the suffices (.c, .h)\n");
	fprintf(stderr, 
	"\t\t-D<options> to turn on debug options for xebec itself\n");
	fprintf(stderr, "\t-<nn> for levels of debugging output\n");
	fprintf(stderr, "\t\t<nn> ranges from 1 to 3, 1 is default(everything)\n");
	fprintf(stderr, "\t\t-T to print transitions\n");
	fprintf(stderr, "\t\t-e to print list of combinations of\n");
	fprintf(stderr, "\t\t\t [event,old_state] that produce protocol errors\n");
	fprintf(stderr, "\t\t-g include profiling code in driver\n");
	Exit(-1);
}

openfiles(proto)
register char *proto;
{
	register char *junk;
	register int lenp = strlen(proto);

	IFDEBUG(b)
		fprintf(OUT, "openfiles %s\n",proto);
	ENDDEBUG

#define HEADER Header
#define SOURCE Source
#define DOIT(X)\
	/* GAG */\
	junk = Malloc( 2 + lenp + strlen(X/**/_name) );\
	(void) sprintf(junk, "%s_", proto);\
	X/**/_name = strcat(junk, X/**/_name);\
	X = fopen(X/**/_name, "w");\
	if((X)==(FILE *)0)\
	{ fprintf(stderr,"Open failed: %s\n", "X"); Exit(-1); }\
	fprintf(X, "/* %cHeader%c */\n",'$', '$' );\
	fprintf(X, "/* %cSource%c */\n",'$', '$' );

	DOIT(eventfile_h);

	IFDEBUG(X)
#ifdef DEBUG
		DOIT(astringfile);
#endif DEBUG
		fprintf(astringfile, 
				"#ifndef _NFILE\n#include <stdio.h>\n#endif _NFILE\n" );
	ENDDEBUG

	DOIT(statevalfile);
	DOIT(statefile);
	DOIT(actfile);
	fprintf(actfile,
		"#ifndef lint\nstatic char *rcsid = \"$Header/**/$\";\n#endif lint\n");

	if(pgoption)
		putdriver(actfile, 15);
	else 
		putdriver(actfile, 14);

	FakeFilename(actfile, Transfilename, lineno);
	putdriver(actfile, 1);
	FakeFilename(actfile, Transfilename, lineno);
	putdriver(actfile, 12);
	fprintf(actfile, "#include \"%s%s\"\n", kerneldirname, statevalfile_name);
	FakeFilename(actfile, Transfilename, lineno);
	putdriver(actfile, 2);

	initsets(eventfile_h, statefile);
}

includecode(file, f)
FILE *file;
register char *f;
{
	register int count=1;
	static char o='{';
	static char c='}';
	register char *g;

	IFDEBUG(a)
		fprintf(stdout, "including: %s, f=0x%x", f,f);
	ENDDEBUG
	g = ++f;
	while(count>0) {
		if(*g == o) count++;
		if(*g == c) count--;
		g++;
	}
	*(--g) = '\0';
	IFDEBUG(a)
		fprintf(stdout, "derived: %s", f);
	ENDDEBUG
	fprintf(file, "%s", f);
	FakeFilename(file, Transfilename, lineno);
}

putincludes()
{
	FakeFilename(actfile, Transfilename, lineno);
	fprintf(actfile, "\n#include \"%s%s\"\n", kerneldirname, eventfile_h_name);
	IFDEBUG(X)
		if( !debug['K'] )
			fprintf(actfile, "\n#include \"%s\"\n", astringfile_name);
			/* not in kernel mode */
	ENDDEBUG
	FakeFilename(actfile, Transfilename, lineno);
}

main(argc, argv)
int argc;
char *argv[];
{
	register int i = 2;
	extern char *strcpy();
	int start, finish;
	extern int FirstEventAttribute;
	extern int Nevents, Nstates;

	start = time(0);
	if(argc < 2) {
		usage(argv[0]);
	}
	IFDEBUG(a)
		fprintf(stdout, "infile = %s\n",argv[1]);
	ENDDEBUG
	Transfilename = argv[1];
	infile = fopen(argv[1], "r");

	if(argc > 2) while(i < argc) {
		register int j=0;
		char c;
		char *name;

		if(argv[i][j] == '-') j++;
		switch(c = argv[i][j]) {

		/* GROT */
		case 'A':
			name = &argv[i][++j];
			actfile_name = Malloc( strlen(name)+4);
			actfile_name =  (char *)strcpy(actfile_name,name);
#ifdef LINT
			name =
#endif LINT
			strcat(actfile_name, ".c");
			fprintf(stdout, "debugging file is %s\n",actfile_name);
			break;
		case 'K':
			debug[c]=1;
			fprintf(OUT, "option %c file %s\n",c, &argv[i][j+1]);
			(void) strcpy(kerneldirname,&argv[i][++j]);
			break;
		case 'X':
			debug[c]=1;
			name = &argv[i][++j];
			astringfile_name = Malloc( strlen(name)+4);
			astringfile_name =  (char *)strcpy(astringfile_name,name);
#ifdef LINT
			name =
#endif LINT
			strcat(astringfile_name, ".c");
			fprintf(OUT, "option %c, astringfile name %s\n",c, name);
			break;
		case 'E':
			name = &argv[i][++j];
			eventfile_h_name = Malloc( strlen(name)+4);
			eventfile_h_name =  (char *)strcpy(eventfile_h_name,name);
#ifdef LINT
			name =
#endif LINT
			strcat(eventfile_h_name, ".h");
			fprintf(stdout, "event files is %s\n",eventfile_h_name);
			break;
		case 'I':
			name = &argv[i][++j];
			statevalfile_name = Malloc( strlen(name)+4 );
			statevalfile_name =  (char *)strcpy(statevalfile_name,name);
#ifdef LINT
			name =
#endif LINT
			strcat(statevalfile_name, ".init");
			fprintf(stdout, "state table initial values file is %s\n",statevalfile_name);
			break;
		case 'S':
			name = &argv[i][++j];
			statefile_name = Malloc( strlen(name)+4);
			statefile_name =  (char *)strcpy(statefile_name,name);
#ifdef LINT
			name =
#endif LINT
			strcat(statefile_name, ".h");
			fprintf(stdout, "state file is %s\n",statefile_name);
			break;
		/* END GROT */
		case '1':
		case '2':
		case '3':
			debug['X']= (int)argv[i][j] - (int) '0';
			fprintf(OUT, "value of debug['X'] is 0x%x,%d\n", debug['X'],
				debug['X']);
			break;
		case 'D':
			while( c = argv[i][++j] ) {
				if(c ==  'X') {
					fprintf(OUT, "debugging on");
					if(debug['X']) fprintf(OUT,
						" - overrides any -%d flags used\n", debug['X']);
				}
				debug[c]=1;
				fprintf(OUT, "debug %c\n",c);
			}
			break;
		case 'g':
			pgoption = 1;
			fprintf(stdout, "Profiling\n");
			break;
		case 'e':
			print_protoerrs = 1;
			fprintf(stdout, "Protocol error table:\n");
			break;

		case 'T':
			print_trans = 1;
			fprintf(stdout, "Transitions:\n");
			break;
		default:
			usage(argv[0]);
			break;
		}
		i++;
	}
	if(kerneldirname[0]) {
		char *c;
#ifdef notdef
		if(debug['X']) {
			fprintf(OUT, "Option K overrides option X\n");
			debug['X'] = 0;
		}
#endif notdef
		if(strlen(kerneldirname)<1) {
			fprintf(OUT, "K option: dir name too short!\n");
			exit(-1);
		}
		/* add ../name/ */
		c = (char *) Malloc(strlen(kerneldirname)+6) ;
		if(c <= (char *)0) {
			fprintf(OUT, "Cannot allocate %d bytes for kerneldirname\n",
				strlen(kerneldirname + 6) );
			fprintf(OUT, "kerneldirname is %s\n", kerneldirname  );
			exit(-1);
		}
		*c = '.';
		*(c+1) = '.';
		*(c+2) = '/';
		(void) strcat(c, kerneldirname);
		(void) strcat(c, "/\0");
		strcpy(kerneldirname, c);
	}

	init_alloc();

	(void) llparse();

	/* {{ */
	if( !FirstEventAttribute )
		fprintf(eventfile_h, "\t}ev_union;\n");
	fprintf(eventfile_h, "};/* end struct event */\n");
	fprintf(eventfile_h, "\n#define %s_NEVENTS 0x%x\n", protocol, Nevents);
	fprintf(eventfile_h,
		"\n#define ATTR(X)ev_union.%s/**/X/**/\n",EV_PREFIX);
	(void) fclose(eventfile_h);

	/* {{ */ fprintf(actfile, "\t}\nreturn 0;\n}\n"); /* end switch; end action() */
	dump_predtable(actfile);

	putdriver(actfile, 3);
	IFDEBUG(X)
		if(!debug['K'])
			putdriver(actfile, 4);
	ENDDEBUG
	putdriver(actfile, 6);
	IFDEBUG(X)
		/*
		putdriver(actfile, 10);
		*/
		if(debug['K']) { 
			putdriver(actfile, 11);
		} else {
			switch(debug['X']) {
			case 1:
			default:
				putdriver(actfile, 7);
				break;
			case 2:
				putdriver(actfile, 13);
				break;
			case 3:
				break;
			}
		}
	ENDDEBUG
	putdriver(actfile, 8);
	(void) fclose(actfile);
	IFDEBUG(X) 
		/* { */ 
		fprintf(astringfile, "};\n");
		(void) fclose(astringfile);
	ENDDEBUG

	(void) fclose(statevalfile);

	fprintf(statefile, "\n#define %s_NSTATES 0x%x\n", protocol, Nstates);
	(void) fclose(statefile);

	finish = time(0);
	fprintf(stdout, "%d seconds\n", finish - start);
	if( print_protoerrs ) 
		printprotoerrs();
}

int transno = 0;

Exit(n)
{
	fprintf(stderr, "Error at line %d\n",lineno);
	if(transno) fprintf(stderr, "Transition number %d\n",transno);
	(void) fflush(stdout);
	(void) fflush(statefile);
	(void) fflush(eventfile_h);
	(void) fflush(actfile);
	exit(n);
}

syntax() 
{
	static char *synt[] = {
		"*PROTOCOL <string>\n",
		"*PCB <string> <optional: SYNONYM synonymstring>\n",
		"<optional: *INCLUDE {\n<C source>\n} >\n",
		"*STATES <string>\n",
		"*EVENTS <string>\n",
		"*TRANSITIONS <string>\n",
	};
}
	
FakeFilename(outfile, name, l)
FILE *outfile;
char *name;
int l;
{
	/*
	doesn't work
	fprintf(outfile, "\n\n\n\n# line %d \"%s\"\n", l, name);
	*/
}



/* ============================================================================
 * SOURCE 19/98: minix4\libos\lib_legacy\libsqlite\src\main.c
 * Size: 37,231 bytes, Lines: 1,144
 * Hash: 5729a4a87951...
 * ============================================================================ */

/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** Main file for the SQLite library.  The routines in this file
** implement the programmer interface to the library.  Routines in
** other files are for internal use by SQLite and should not be
** accessed by users of the library.
**
** $Id: main.c,v 1.164.2.2 2004/06/26 14:40:05 drh Exp $
*/
#include "sqliteInt.h"
#include "os.h"
#include <ctype.h>

/*
** A pointer to this structure is used to communicate information
** from sqliteInit into the sqliteInitCallback.
*/
typedef struct {
  sqlite *db;         /* The database being initialized */
  char **pzErrMsg;    /* Error message stored here */
} InitData;

/*
** Fill the InitData structure with an error message that indicates
** that the database is corrupt.
*/
static void corruptSchema(InitData *pData, const char *zExtra){
  sqliteSetString(pData->pzErrMsg, "malformed database schema",
     zExtra!=0 && zExtra[0]!=0 ? " - " : (char*)0, zExtra, (char*)0);
}

/*
** This is the callback routine for the code that initializes the
** database.  See sqliteInit() below for additional information.
**
** Each callback contains the following information:
**
**     argv[0] = "file-format" or "schema-cookie" or "table" or "index"
**     argv[1] = table or index name or meta statement type.
**     argv[2] = root page number for table or index.  NULL for meta.
**     argv[3] = SQL text for a CREATE TABLE or CREATE INDEX statement.
**     argv[4] = "1" for temporary files, "0" for main database, "2" or more
**               for auxiliary database files.
**
*/
static
int sqliteInitCallback(void *pInit, int argc, char **argv, char **azColName){
  InitData *pData = (InitData*)pInit;
  int nErr = 0;

  assert( argc==5 );
  if( argv==0 ) return 0;   /* Might happen if EMPTY_RESULT_CALLBACKS are on */
  if( argv[0]==0 ){
    corruptSchema(pData, 0);
    return 1;
  }
  switch( argv[0][0] ){
    case 'v':
    case 'i':
    case 't': {  /* CREATE TABLE, CREATE INDEX, or CREATE VIEW statements */
      sqlite *db = pData->db;
      if( argv[2]==0 || argv[4]==0 ){
        corruptSchema(pData, 0);
        return 1;
      }
      if( argv[3] && argv[3][0] ){
        /* Call the parser to process a CREATE TABLE, INDEX or VIEW.
        ** But because db->init.busy is set to 1, no VDBE code is generated
        ** or executed.  All the parser does is build the internal data
        ** structures that describe the table, index, or view.
        */
        char *zErr;
        assert( db->init.busy );
        db->init.iDb = atoi(argv[4]);
        assert( db->init.iDb>=0 && db->init.iDb<db->nDb );
        db->init.newTnum = atoi(argv[2]);
        if( sqlite_exec(db, argv[3], 0, 0, &zErr) ){
          corruptSchema(pData, zErr);
          sqlite_freemem(zErr);
        }
        db->init.iDb = 0;
      }else{
        /* If the SQL column is blank it means this is an index that
        ** was created to be the PRIMARY KEY or to fulfill a UNIQUE
        ** constraint for a CREATE TABLE.  The index should have already
        ** been created when we processed the CREATE TABLE.  All we have
        ** to do here is record the root page number for that index.
        */
        int iDb;
        Index *pIndex;

        iDb = atoi(argv[4]);
        assert( iDb>=0 && iDb<db->nDb );
        pIndex = sqliteFindIndex(db, argv[1], db->aDb[iDb].zName);
        if( pIndex==0 || pIndex->tnum!=0 ){
          /* This can occur if there exists an index on a TEMP table which
          ** has the same name as another index on a permanent index.  Since
          ** the permanent table is hidden by the TEMP table, we can also
          ** safely ignore the index on the permanent table.
          */
          /* Do Nothing */;
        }else{
          pIndex->tnum = atoi(argv[2]);
        }
      }
      break;
    }
    default: {
      /* This can not happen! */
      nErr = 1;
      assert( nErr==0 );
    }
  }
  return nErr;
}

/*
** This is a callback procedure used to reconstruct a table.  The
** name of the table to be reconstructed is passed in as argv[0].
**
** This routine is used to automatically upgrade a database from
** format version 1 or 2 to version 3.  The correct operation of
** this routine relys on the fact that no indices are used when
** copying a table out to a temporary file.
**
** The change from version 2 to version 3 occurred between SQLite
** version 2.5.6 and 2.6.0 on 2002-July-18.
*/
static
int upgrade_3_callback(void *pInit, int argc, char **argv, char **NotUsed){
  InitData *pData = (InitData*)pInit;
  int rc;
  Table *pTab;
  Trigger *pTrig;
  char *zErr = 0;

  pTab = sqliteFindTable(pData->db, argv[0], 0);
  assert( pTab!=0 );
  assert( sqliteStrICmp(pTab->zName, argv[0])==0 );
  if( pTab ){
    pTrig = pTab->pTrigger;
    pTab->pTrigger = 0;  /* Disable all triggers before rebuilding the table */
  }
  rc = sqlite_exec_printf(pData->db,
    "CREATE TEMP TABLE sqlite_x AS SELECT * FROM '%q'; "
    "DELETE FROM '%q'; "
    "INSERT INTO '%q' SELECT * FROM sqlite_x; "
    "DROP TABLE sqlite_x;",
    0, 0, &zErr, argv[0], argv[0], argv[0]);
  if( zErr ){
    if( *pData->pzErrMsg ) sqlite_freemem(*pData->pzErrMsg);
    *pData->pzErrMsg = zErr;
  }

  /* If an error occurred in the SQL above, then the transaction will
  ** rollback which will delete the internal symbol tables.  This will
  ** cause the structure that pTab points to be deleted.  In case that
  ** happened, we need to refetch pTab.
  */
  pTab = sqliteFindTable(pData->db, argv[0], 0);
  if( pTab ){
    assert( sqliteStrICmp(pTab->zName, argv[0])==0 );
    pTab->pTrigger = pTrig;  /* Re-enable triggers */
  }
  return rc!=SQLITE_OK;
}



/*
** Attempt to read the database schema and initialize internal
** data structures for a single database file.  The index of the
** database file is given by iDb.  iDb==0 is used for the main
** database.  iDb==1 should never be used.  iDb>=2 is used for
** auxiliary databases.  Return one of the SQLITE_ error codes to
** indicate success or failure.
*/
static int sqliteInitOne(sqlite *db, int iDb, char **pzErrMsg){
  int rc;
  BtCursor *curMain;
  int size;
  Table *pTab;
  char const *azArg[6];
  char zDbNum[30];
  int meta[SQLITE_N_BTREE_META];
  InitData initData;
  char const *zMasterSchema;
  char const *zMasterName;
  char *zSql = 0;

  /*
  ** The master database table has a structure like this
  */
  static char master_schema[] =
     "CREATE TABLE sqlite_master(\n"
     "  type text,\n"
     "  name text,\n"
     "  tbl_name text,\n"
     "  rootpage integer,\n"
     "  sql text\n"
     ")"
  ;
  static char temp_master_schema[] =
     "CREATE TEMP TABLE sqlite_temp_master(\n"
     "  type text,\n"
     "  name text,\n"
     "  tbl_name text,\n"
     "  rootpage integer,\n"
     "  sql text\n"
     ")"
  ;

  assert( iDb>=0 && iDb<db->nDb );

  /* zMasterSchema and zInitScript are set to point at the master schema
  ** and initialisation script appropriate for the database being
  ** initialised. zMasterName is the name of the master table.
  */
  if( iDb==1 ){
    zMasterSchema = temp_master_schema;
    zMasterName = TEMP_MASTER_NAME;
  }else{
    zMasterSchema = master_schema;
    zMasterName = MASTER_NAME;
  }

  /* Construct the schema table.
  */
  sqliteSafetyOff(db);
  azArg[0] = "table";
  azArg[1] = zMasterName;
  azArg[2] = "2";
  azArg[3] = zMasterSchema;
  sprintf(zDbNum, "%d", iDb);
  azArg[4] = zDbNum;
  azArg[5] = 0;
  initData.db = db;
  initData.pzErrMsg = pzErrMsg;
  sqliteInitCallback(&initData, 5, (char **)azArg, 0);
  pTab = sqliteFindTable(db, zMasterName, db->aDb[iDb].zName);
  if( pTab ){
    pTab->readOnly = 1;
  }else{
    return SQLITE_NOMEM;
  }
  sqliteSafetyOn(db);

  /* Create a cursor to hold the database open
  */
  if( db->aDb[iDb].pBt==0 ) return SQLITE_OK;
  rc = sqliteBtreeCursor(db->aDb[iDb].pBt, 2, 0, &curMain);
  if( rc ){
    sqliteSetString(pzErrMsg, sqlite_error_string(rc), (char*)0);
    return rc;
  }

  /* Get the database meta information
  */
  rc = sqliteBtreeGetMeta(db->aDb[iDb].pBt, meta);
  if( rc ){
    sqliteSetString(pzErrMsg, sqlite_error_string(rc), (char*)0);
    sqliteBtreeCloseCursor(curMain);
    return rc;
  }
  db->aDb[iDb].schema_cookie = meta[1];
  if( iDb==0 ){
    db->next_cookie = meta[1];
    db->file_format = meta[2];
    size = meta[3];
    if( size==0 ){ size = MAX_PAGES; }
    db->cache_size = size;
    db->safety_level = meta[4];
    if( meta[6]>0 && meta[6]<=2 && db->temp_store==0 ){
      db->temp_store = meta[6];
    }
    if( db->safety_level==0 ) db->safety_level = 2;

    /*
    **  file_format==1    Version 2.1.0.
    **  file_format==2    Version 2.2.0. Add support for INTEGER PRIMARY KEY.
    **  file_format==3    Version 2.6.0. Fix empty-string index bug.
    **  file_format==4    Version 2.7.0. Add support for separate numeric and
    **                    text datatypes.
    */
    if( db->file_format==0 ){
      /* This happens if the database was initially empty */
      db->file_format = 4;
    }else if( db->file_format>4 ){
      sqliteBtreeCloseCursor(curMain);
      sqliteSetString(pzErrMsg, "unsupported file format", (char*)0);
      return SQLITE_ERROR;
    }
  }else if( iDb!=1 && (db->file_format!=meta[2] || db->file_format<4) ){
    assert( db->file_format>=4 );
    if( meta[2]==0 ){
      sqliteSetString(pzErrMsg, "cannot attach empty database: ",
         db->aDb[iDb].zName, (char*)0);
    }else{
      sqliteSetString(pzErrMsg, "incompatible file format in auxiliary "
         "database: ", db->aDb[iDb].zName, (char*)0);
    }
    sqliteBtreeClose(db->aDb[iDb].pBt);
    db->aDb[iDb].pBt = 0;
    return SQLITE_FORMAT;
  }
  sqliteBtreeSetCacheSize(db->aDb[iDb].pBt, db->cache_size);
  sqliteBtreeSetSafetyLevel(db->aDb[iDb].pBt, meta[4]==0 ? 2 : meta[4]);

  /* Read the schema information out of the schema tables
  */
  assert( db->init.busy );
  sqliteSafetyOff(db);

  /* The following SQL will read the schema from the master tables.
  ** The first version works with SQLite file formats 2 or greater.
  ** The second version is for format 1 files.
  **
  ** Beginning with file format 2, the rowid for new table entries
  ** (including entries in sqlite_master) is an increasing integer.
  ** So for file format 2 and later, we can play back sqlite_master
  ** and all the CREATE statements will appear in the right order.
  ** But with file format 1, table entries were random and so we
  ** have to make sure the CREATE TABLEs occur before their corresponding
  ** CREATE INDEXs.  (We don't have to deal with CREATE VIEW or
  ** CREATE TRIGGER in file format 1 because those constructs did
  ** not exist then.)
  */
  if( db->file_format>=2 ){
    sqliteSetString(&zSql,
        "SELECT type, name, rootpage, sql, ", zDbNum, " FROM \"",
       db->aDb[iDb].zName, "\".", zMasterName, (char*)0);
  }else{
    sqliteSetString(&zSql,
        "SELECT type, name, rootpage, sql, ", zDbNum, " FROM \"",
       db->aDb[iDb].zName, "\".", zMasterName,
       " WHERE type IN ('table', 'index')"
       " ORDER BY CASE type WHEN 'table' THEN 0 ELSE 1 END", (char*)0);
  }
  rc = sqlite_exec(db, zSql, sqliteInitCallback, &initData, 0);

  sqliteFree(zSql);
  sqliteSafetyOn(db);
  sqliteBtreeCloseCursor(curMain);
  if( sqlite_malloc_failed ){
    sqliteSetString(pzErrMsg, "out of memory", (char*)0);
    rc = SQLITE_NOMEM;
    sqliteResetInternalSchema(db, 0);
  }
  if( rc==SQLITE_OK ){
    DbSetProperty(db, iDb, DB_SchemaLoaded);
  }else{
    sqliteResetInternalSchema(db, iDb);
  }
  return rc;
}

/*
** Initialize all database files - the main database file, the file
** used to store temporary tables, and any additional database files
** created using ATTACH statements.  Return a success code.  If an
** error occurs, write an error message into *pzErrMsg.
**
** After the database is initialized, the SQLITE_Initialized
** bit is set in the flags field of the sqlite structure.  An
** attempt is made to initialize the database as soon as it
** is opened.  If that fails (perhaps because another process
** has the sqlite_master table locked) than another attempt
** is made the first time the database is accessed.
*/
int sqliteInit(sqlite *db, char **pzErrMsg){
  int i, rc;

  if( db->init.busy ) return SQLITE_OK;
  assert( (db->flags & SQLITE_Initialized)==0 );
  rc = SQLITE_OK;
  db->init.busy = 1;
  for(i=0; rc==SQLITE_OK && i<db->nDb; i++){
    if( DbHasProperty(db, i, DB_SchemaLoaded) || i==1 ) continue;
    rc = sqliteInitOne(db, i, pzErrMsg);
    if( rc ){
      sqliteResetInternalSchema(db, i);
    }
  }

  /* Once all the other databases have been initialised, load the schema
  ** for the TEMP database. This is loaded last, as the TEMP database
  ** schema may contain references to objects in other databases.
  */
  if( rc==SQLITE_OK && db->nDb>1 && !DbHasProperty(db, 1, DB_SchemaLoaded) ){
    rc = sqliteInitOne(db, 1, pzErrMsg);
    if( rc ){
      sqliteResetInternalSchema(db, 1);
    }
  }

  db->init.busy = 0;
  if( rc==SQLITE_OK ){
    db->flags |= SQLITE_Initialized;
    sqliteCommitInternalChanges(db);
  }

  /* If the database is in formats 1 or 2, then upgrade it to
  ** version 3.  This will reconstruct all indices.  If the
  ** upgrade fails for any reason (ex: out of disk space, database
  ** is read only, interrupt received, etc.) then fail the init.
  */
  if( rc==SQLITE_OK && db->file_format<3 ){
    char *zErr = 0;
    InitData initData;
    int meta[SQLITE_N_BTREE_META];

    db->magic = SQLITE_MAGIC_OPEN;
    initData.db = db;
    initData.pzErrMsg = &zErr;
    db->file_format = 3;
    rc = sqlite_exec(db,
      "BEGIN; SELECT name FROM sqlite_master WHERE type='table';",
      upgrade_3_callback,
      &initData,
      &zErr);
    if( rc==SQLITE_OK ){
      sqliteBtreeGetMeta(db->aDb[0].pBt, meta);
      meta[2] = 4;
      sqliteBtreeUpdateMeta(db->aDb[0].pBt, meta);
      sqlite_exec(db, "COMMIT", 0, 0, 0);
    }
    if( rc!=SQLITE_OK ){
      sqliteSetString(pzErrMsg,
        "unable to upgrade database to the version 2.6 format",
        zErr ? ": " : 0, zErr, (char*)0);
    }
    sqlite_freemem(zErr);
  }

  if( rc!=SQLITE_OK ){
    db->flags &= ~SQLITE_Initialized;
  }
  return rc;
}

/*
** The version of the library
*/
const char rcsid[] = "@(#) \044Id: SQLite version " SQLITE_VERSION " $";
const char sqlite_version[] = SQLITE_VERSION;

/*
** Does the library expect data to be encoded as UTF-8 or iso8859?  The
** following global constant always lets us know.
*/
#ifdef SQLITE_UTF8
const char sqlite_encoding[] = "UTF-8";
#else
const char sqlite_encoding[] = "iso8859";
#endif

/*
** Open a new SQLite database.  Construct an "sqlite" structure to define
** the state of this database and return a pointer to that structure.
**
** An attempt is made to initialize the in-memory data structures that
** hold the database schema.  But if this fails (because the schema file
** is locked) then that step is deferred until the first call to
** sqlite_exec().
*/
sqlite *sqlite_open(const char *zFilename, int mode, char **pzErrMsg){
  sqlite *db;
  int rc, i;

  /* Allocate the sqlite data structure */
  db = sqliteMalloc( sizeof(sqlite) );
  if( pzErrMsg ) *pzErrMsg = 0;
  if( db==0 ) goto no_mem_on_open;
  db->onError = OE_Default;
  db->priorNewRowid = 0;
  db->magic = SQLITE_MAGIC_BUSY;
  db->nDb = 2;
  db->aDb = db->aDbStatic;
  /* db->flags |= SQLITE_ShortColNames; */
  sqliteHashInit(&db->aFunc, SQLITE_HASH_STRING, 1);
  for(i=0; i<db->nDb; i++){
    sqliteHashInit(&db->aDb[i].tblHash, SQLITE_HASH_STRING, 0);
    sqliteHashInit(&db->aDb[i].idxHash, SQLITE_HASH_STRING, 0);
    sqliteHashInit(&db->aDb[i].trigHash, SQLITE_HASH_STRING, 0);
    sqliteHashInit(&db->aDb[i].aFKey, SQLITE_HASH_STRING, 1);
  }

  /* Open the backend database driver */
  if( zFilename[0]==':' && strcmp(zFilename,":memory:")==0 ){
    db->temp_store = 2;
  }
  rc = sqliteBtreeFactory(db, zFilename, 0, MAX_PAGES, &db->aDb[0].pBt);
  if( rc!=SQLITE_OK ){
    switch( rc ){
      default: {
        sqliteSetString(pzErrMsg, "unable to open database: ",
           zFilename, (char*)0);
      }
    }
    sqliteFree(db);
    sqliteStrRealloc(pzErrMsg);
    return 0;
  }
  db->aDb[0].zName = "main";
  db->aDb[1].zName = "temp";

  /* Attempt to read the schema */
  sqliteRegisterBuiltinFunctions(db);
  rc = sqliteInit(db, pzErrMsg);
  db->magic = SQLITE_MAGIC_OPEN;
  if( sqlite_malloc_failed ){
    sqlite_close(db);
    goto no_mem_on_open;
  }else if( rc!=SQLITE_OK && rc!=SQLITE_BUSY ){
    sqlite_close(db);
    sqliteStrRealloc(pzErrMsg);
    return 0;
  }else if( pzErrMsg ){
    sqliteFree(*pzErrMsg);
    *pzErrMsg = 0;
  }

  /* Return a pointer to the newly opened database structure */
  return db;

no_mem_on_open:
  sqliteSetString(pzErrMsg, "out of memory", (char*)0);
  sqliteStrRealloc(pzErrMsg);
  return 0;
}

/*
** Return the ROWID of the most recent insert
*/
int sqlite_last_insert_rowid(sqlite *db){
  return db->lastRowid;
}

/*
** Return the number of changes in the most recent call to sqlite_exec().
*/
int sqlite_changes(sqlite *db){
  return db->nChange;
}

/*
** Return the number of changes produced by the last INSERT, UPDATE, or
** DELETE statement to complete execution. The count does not include
** changes due to SQL statements executed in trigger programs that were
** triggered by that statement
*/
int sqlite_last_statement_changes(sqlite *db){
  return db->lsChange;
}

/*
** Close an existing SQLite database
*/
void sqlite_close(sqlite *db){
  HashElem *i;
  int j;
  db->want_to_close = 1;
  if( sqliteSafetyCheck(db) || sqliteSafetyOn(db) ){
    /* printf("DID NOT CLOSE\n"); fflush(stdout); */
    return;
  }
  db->magic = SQLITE_MAGIC_CLOSED;
  for(j=0; j<db->nDb; j++){
    struct Db *pDb = &db->aDb[j];
    if( pDb->pBt ){
      sqliteBtreeClose(pDb->pBt);
      pDb->pBt = 0;
    }
  }
  sqliteResetInternalSchema(db, 0);
  assert( db->nDb<=2 );
  assert( db->aDb==db->aDbStatic );
  for(i=sqliteHashFirst(&db->aFunc); i; i=sqliteHashNext(i)){
    FuncDef *pFunc, *pNext;
    for(pFunc = (FuncDef*)sqliteHashData(i); pFunc; pFunc=pNext){
      pNext = pFunc->pNext;
      sqliteFree(pFunc);
    }
  }
  sqliteHashClear(&db->aFunc);
  sqliteFree(db);
}

/*
** Rollback all database files.
*/
void sqliteRollbackAll(sqlite *db){
  int i;
  for(i=0; i<db->nDb; i++){
    if( db->aDb[i].pBt ){
      sqliteBtreeRollback(db->aDb[i].pBt);
      db->aDb[i].inTrans = 0;
    }
  }
  sqliteResetInternalSchema(db, 0);
  /* sqliteRollbackInternalChanges(db); */
}

/*
** Execute SQL code.  Return one of the SQLITE_ success/failure
** codes.  Also write an error message into memory obtained from
** malloc() and make *pzErrMsg point to that message.
**
** If the SQL is a query, then for each row in the query result
** the xCallback() function is called.  pArg becomes the first
** argument to xCallback().  If xCallback=NULL then no callback
** is invoked, even for queries.
*/
int sqlite_exec(
  sqlite *db,                 /* The database on which the SQL executes */
  const char *zSql,           /* The SQL to be executed */
  sqlite_callback xCallback,  /* Invoke this callback routine */
  void *pArg,                 /* First argument to xCallback() */
  char **pzErrMsg             /* Write error messages here */
){
  int rc = SQLITE_OK;
  const char *zLeftover;
  sqlite_vm *pVm;
  int nRetry = 0;
  int nChange = 0;
  int nCallback;

  if( zSql==0 ) return SQLITE_OK;
  while( rc==SQLITE_OK && zSql[0] ){
    pVm = 0;
    rc = sqlite_compile(db, zSql, &zLeftover, &pVm, pzErrMsg);
    if( rc!=SQLITE_OK ){
      assert( pVm==0 || sqlite_malloc_failed );
      return rc;
    }
    if( pVm==0 ){
      /* This happens if the zSql input contained only whitespace */
      break;
    }
    db->nChange += nChange;
    nCallback = 0;
    while(1){
      int nArg;
      char **azArg, **azCol;
      rc = sqlite_step(pVm, &nArg, (const char***)&azArg,(const char***)&azCol);
      if( rc==SQLITE_ROW ){
        if( xCallback!=0 && xCallback(pArg, nArg, azArg, azCol) ){
          sqlite_finalize(pVm, 0);
          return SQLITE_ABORT;
        }
        nCallback++;
      }else{
        if( rc==SQLITE_DONE && nCallback==0
          && (db->flags & SQLITE_NullCallback)!=0 && xCallback!=0 ){
          xCallback(pArg, nArg, azArg, azCol);
        }
        rc = sqlite_finalize(pVm, pzErrMsg);
        if( rc==SQLITE_SCHEMA && nRetry<2 ){
          nRetry++;
          rc = SQLITE_OK;
          break;
        }
        if( db->pVdbe==0 ){
          nChange = db->nChange;
        }
        nRetry = 0;
        zSql = zLeftover;
        while( isspace(zSql[0]) ) zSql++;
        break;
      }
    }
  }
  return rc;
}


/*
** Compile a single statement of SQL into a virtual machine.  Return one
** of the SQLITE_ success/failure codes.  Also write an error message into
** memory obtained from malloc() and make *pzErrMsg point to that message.
*/
int sqlite_compile(
  sqlite *db,                 /* The database on which the SQL executes */
  const char *zSql,           /* The SQL to be executed */
  const char **pzTail,        /* OUT: Next statement after the first */
  sqlite_vm **ppVm,           /* OUT: The virtual machine */
  char **pzErrMsg             /* OUT: Write error messages here */
){
  Parse sParse;

  if( pzErrMsg ) *pzErrMsg = 0;
  if( sqliteSafetyOn(db) ) goto exec_misuse;
  if( !db->init.busy ){
    if( (db->flags & SQLITE_Initialized)==0 ){
      int rc, cnt = 1;
      while( (rc = sqliteInit(db, pzErrMsg))==SQLITE_BUSY
         && db->xBusyCallback
         && db->xBusyCallback(db->pBusyArg, "", cnt++)!=0 ){}
      if( rc!=SQLITE_OK ){
        sqliteStrRealloc(pzErrMsg);
        sqliteSafetyOff(db);
        return rc;
      }
      if( pzErrMsg ){
        sqliteFree(*pzErrMsg);
        *pzErrMsg = 0;
      }
    }
    if( db->file_format<3 ){
      sqliteSafetyOff(db);
      sqliteSetString(pzErrMsg, "obsolete database file format", (char*)0);
      return SQLITE_ERROR;
    }
  }
  assert( (db->flags & SQLITE_Initialized)!=0 || db->init.busy );
  if( db->pVdbe==0 ){ db->nChange = 0; }
  memset(&sParse, 0, sizeof(sParse));
  sParse.db = db;
  sqliteRunParser(&sParse, zSql, pzErrMsg);
  if( db->xTrace && !db->init.busy ){
    /* Trace only the statment that was compiled.
    ** Make a copy of that part of the SQL string since zSQL is const
    ** and we must pass a zero terminated string to the trace function
    ** The copy is unnecessary if the tail pointer is pointing at the
    ** beginnig or end of the SQL string.
    */
    if( sParse.zTail && sParse.zTail!=zSql && *sParse.zTail ){
      char *tmpSql = sqliteStrNDup(zSql, sParse.zTail - zSql);
      if( tmpSql ){
        db->xTrace(db->pTraceArg, tmpSql);
        free(tmpSql);
      }else{
        /* If a memory error occurred during the copy,
        ** trace entire SQL string and fall through to the
        ** sqlite_malloc_failed test to report the error.
        */
        db->xTrace(db->pTraceArg, zSql);
      }
    }else{
      db->xTrace(db->pTraceArg, zSql);
    }
  }
  if( sqlite_malloc_failed ){
    sqliteSetString(pzErrMsg, "out of memory", (char*)0);
    sParse.rc = SQLITE_NOMEM;
    sqliteRollbackAll(db);
    sqliteResetInternalSchema(db, 0);
    db->flags &= ~SQLITE_InTrans;
  }
  if( sParse.rc==SQLITE_DONE ) sParse.rc = SQLITE_OK;
  if( sParse.rc!=SQLITE_OK && pzErrMsg && *pzErrMsg==0 ){
    sqliteSetString(pzErrMsg, sqlite_error_string(sParse.rc), (char*)0);
  }
  sqliteStrRealloc(pzErrMsg);
  if( sParse.rc==SQLITE_SCHEMA ){
    sqliteResetInternalSchema(db, 0);
  }
  assert( ppVm );
  *ppVm = (sqlite_vm*)sParse.pVdbe;
  if( pzTail ) *pzTail = sParse.zTail;
  if( sqliteSafetyOff(db) ) goto exec_misuse;
  return sParse.rc;

exec_misuse:
  if( pzErrMsg ){
    *pzErrMsg = 0;
    sqliteSetString(pzErrMsg, sqlite_error_string(SQLITE_MISUSE), (char*)0);
    sqliteStrRealloc(pzErrMsg);
  }
  return SQLITE_MISUSE;
}


/*
** The following routine destroys a virtual machine that is created by
** the sqlite_compile() routine.
**
** The integer returned is an SQLITE_ success/failure code that describes
** the result of executing the virtual machine.  An error message is
** written into memory obtained from malloc and *pzErrMsg is made to
** point to that error if pzErrMsg is not NULL.  The calling routine
** should use sqlite_freemem() to delete the message when it has finished
** with it.
*/
int sqlite_finalize(
  sqlite_vm *pVm,            /* The virtual machine to be destroyed */
  char **pzErrMsg            /* OUT: Write error messages here */
){
  int rc = sqliteVdbeFinalize((Vdbe*)pVm, pzErrMsg);
  sqliteStrRealloc(pzErrMsg);
  return rc;
}

/*
** Terminate the current execution of a virtual machine then
** reset the virtual machine back to its starting state so that it
** can be reused.  Any error message resulting from the prior execution
** is written into *pzErrMsg.  A success code from the prior execution
** is returned.
*/
int sqlite_reset(
  sqlite_vm *pVm,            /* The virtual machine to be destroyed */
  char **pzErrMsg            /* OUT: Write error messages here */
){
  int rc = sqliteVdbeReset((Vdbe*)pVm, pzErrMsg);
  sqliteVdbeMakeReady((Vdbe*)pVm, -1, 0);
  sqliteStrRealloc(pzErrMsg);
  return rc;
}

/*
** Return a static string that describes the kind of error specified in the
** argument.
*/
const char *sqlite_error_string(int rc){
  const char *z;
  switch( rc ){
    case SQLITE_OK:         z = "not an error";                          break;
    case SQLITE_ERROR:      z = "SQL logic error or missing database";   break;
    case SQLITE_INTERNAL:   z = "internal SQLite implementation flaw";   break;
    case SQLITE_PERM:       z = "access permission denied";              break;
    case SQLITE_ABORT:      z = "callback requested query abort";        break;
    case SQLITE_BUSY:       z = "database is locked";                    break;
    case SQLITE_LOCKED:     z = "database table is locked";              break;
    case SQLITE_NOMEM:      z = "out of memory";                         break;
    case SQLITE_READONLY:   z = "attempt to write a readonly database";  break;
    case SQLITE_INTERRUPT:  z = "interrupted";                           break;
    case SQLITE_IOERR:      z = "disk I/O error";                        break;
    case SQLITE_CORRUPT:    z = "database disk image is malformed";      break;
    case SQLITE_NOTFOUND:   z = "table or record not found";             break;
    case SQLITE_FULL:       z = "database is full";                      break;
    case SQLITE_CANTOPEN:   z = "unable to open database file";          break;
    case SQLITE_PROTOCOL:   z = "database locking protocol failure";     break;
    case SQLITE_EMPTY:      z = "table contains no data";                break;
    case SQLITE_SCHEMA:     z = "database schema has changed";           break;
    case SQLITE_TOOBIG:     z = "too much data for one table row";       break;
    case SQLITE_CONSTRAINT: z = "constraint failed";                     break;
    case SQLITE_MISMATCH:   z = "datatype mismatch";                     break;
    case SQLITE_MISUSE:     z = "library routine called out of sequence";break;
    case SQLITE_NOLFS:      z = "kernel lacks large file support";       break;
    case SQLITE_AUTH:       z = "authorization denied";                  break;
    case SQLITE_FORMAT:     z = "auxiliary database format error";       break;
    case SQLITE_RANGE:      z = "bind index out of range";               break;
    case SQLITE_NOTADB:     z = "file is encrypted or is not a database";break;
    default:                z = "unknown error";                         break;
  }
  return z;
}

/*
** This routine implements a busy callback that sleeps and tries
** again until a timeout value is reached.  The timeout value is
** an integer number of milliseconds passed in as the first
** argument.
*/
static int sqliteDefaultBusyCallback(
 void *Timeout,           /* Maximum amount of time to wait */
 const char *NotUsed,     /* The name of the table that is busy */
 int count                /* Number of times table has been busy */
){
#if SQLITE_MIN_SLEEP_MS==1
  static const char delays[] =
     { 1, 2, 5, 10, 15, 20, 25, 25,  25,  50,  50,  50, 100};
  static const short int totals[] =
     { 0, 1, 3,  8, 18, 33, 53, 78, 103, 128, 178, 228, 287};
# define NDELAY (sizeof(delays)/sizeof(delays[0]))
  int timeout = (int)(long)Timeout;
  int delay, prior;

  if( count <= NDELAY ){
    delay = delays[count-1];
    prior = totals[count-1];
  }else{
    delay = delays[NDELAY-1];
    prior = totals[NDELAY-1] + delay*(count-NDELAY-1);
  }
  if( prior + delay > timeout ){
    delay = timeout - prior;
    if( delay<=0 ) return 0;
  }
  sqliteOsSleep(delay);
  return 1;
#else
  int timeout = (int)(long)Timeout;
  if( (count+1)*1000 > timeout ){
    return 0;
  }
  sqliteOsSleep(1000);
  return 1;
#endif
}

/*
** This routine sets the busy callback for an Sqlite database to the
** given callback function with the given argument.
*/
void sqlite_busy_handler(
  sqlite *db,
  int (*xBusy)(void*,const char*,int),
  void *pArg
){
  db->xBusyCallback = xBusy;
  db->pBusyArg = pArg;
}

#ifndef SQLITE_OMIT_PROGRESS_CALLBACK
/*
** This routine sets the progress callback for an Sqlite database to the
** given callback function with the given argument. The progress callback will
** be invoked every nOps opcodes.
*/
void sqlite_progress_handler(
  sqlite *db,
  int nOps,
  int (*xProgress)(void*),
  void *pArg
){
  if( nOps>0 ){
    db->xProgress = xProgress;
    db->nProgressOps = nOps;
    db->pProgressArg = pArg;
  }else{
    db->xProgress = 0;
    db->nProgressOps = 0;
    db->pProgressArg = 0;
  }
}
#endif


/*
** This routine installs a default busy handler that waits for the
** specified number of milliseconds before returning 0.
*/
void sqlite_busy_timeout(sqlite *db, int ms){
  if( ms>0 ){
    sqlite_busy_handler(db, sqliteDefaultBusyCallback, (void*)(long)ms);
  }else{
    sqlite_busy_handler(db, 0, 0);
  }
}

/*
** Cause any pending operation to stop at its earliest opportunity.
*/
void sqlite_interrupt(sqlite *db){
  db->flags |= SQLITE_Interrupt;
}

/*
** Windows systems should call this routine to free memory that
** is returned in the in the errmsg parameter of sqlite_open() when
** SQLite is a DLL.  For some reason, it does not work to call free()
** directly.
**
** Note that we need to call free() not sqliteFree() here, since every
** string that is exported from SQLite should have already passed through
** sqliteStrRealloc().
*/
void sqlite_freemem(void *p){ free(p); }

/*
** Windows systems need functions to call to return the sqlite_version
** and sqlite_encoding strings since they are unable to access constants
** within DLLs.
*/
const char *sqlite_libversion(void){ return sqlite_version; }
const char *sqlite_libencoding(void){ return sqlite_encoding; }

/*
** Create new user-defined functions.  The sqlite_create_function()
** routine creates a regular function and sqlite_create_aggregate()
** creates an aggregate function.
**
** Passing a NULL xFunc argument or NULL xStep and xFinalize arguments
** disables the function.  Calling sqlite_create_function() with the
** same name and number of arguments as a prior call to
** sqlite_create_aggregate() disables the prior call to
** sqlite_create_aggregate(), and vice versa.
**
** If nArg is -1 it means that this function will accept any number
** of arguments, including 0.  The maximum allowed value of nArg is 127.
*/
int sqlite_create_function(
  sqlite *db,          /* Add the function to this database connection */
  const char *zName,   /* Name of the function to add */
  int nArg,            /* Number of arguments */
  void (*xFunc)(sqlite_func*,int,const char**),  /* The implementation */
  void *pUserData      /* User data */
){
  FuncDef *p;
  int nName;
  if( db==0 || zName==0 || sqliteSafetyCheck(db) ) return 1;
  if( nArg<-1 || nArg>127 ) return 1;
  nName = strlen(zName);
  if( nName>255 ) return 1;
  p = sqliteFindFunction(db, zName, nName, nArg, 1);
  if( p==0 ) return 1;
  p->xFunc = xFunc;
  p->xStep = 0;
  p->xFinalize = 0;
  p->pUserData = pUserData;
  return 0;
}
int sqlite_create_aggregate(
  sqlite *db,          /* Add the function to this database connection */
  const char *zName,   /* Name of the function to add */
  int nArg,            /* Number of arguments */
  void (*xStep)(sqlite_func*,int,const char**), /* The step function */
  void (*xFinalize)(sqlite_func*),              /* The finalizer */
  void *pUserData      /* User data */
){
  FuncDef *p;
  int nName;
  if( db==0 || zName==0 || sqliteSafetyCheck(db) ) return 1;
  if( nArg<-1 || nArg>127 ) return 1;
  nName = strlen(zName);
  if( nName>255 ) return 1;
  p = sqliteFindFunction(db, zName, nName, nArg, 1);
  if( p==0 ) return 1;
  p->xFunc = 0;
  p->xStep = xStep;
  p->xFinalize = xFinalize;
  p->pUserData = pUserData;
  return 0;
}

/*
** Change the datatype for all functions with a given name.  See the
** header comment for the prototype of this function in sqlite.h for
** additional information.
*/
int sqlite_function_type(sqlite *db, const char *zName, int dataType){
  FuncDef *p = (FuncDef*)sqliteHashFind(&db->aFunc, zName, strlen(zName));
  while( p ){
    p->dataType = dataType;
    p = p->pNext;
  }
  return SQLITE_OK;
}

/*
** Register a trace function.  The pArg from the previously registered trace
** is returned.
**
** A NULL trace function means that no tracing is executes.  A non-NULL
** trace is a pointer to a function that is invoked at the start of each
** sqlite_exec().
*/
void *sqlite_trace(sqlite *db, void (*xTrace)(void*,const char*), void *pArg){
  void *pOld = db->pTraceArg;
  db->xTrace = xTrace;
  db->pTraceArg = pArg;
  return pOld;
}

/*** EXPERIMENTAL ***
**
** Register a function to be invoked when a transaction comments.
** If either function returns non-zero, then the commit becomes a
** rollback.
*/
void *sqlite_commit_hook(
  sqlite *db,               /* Attach the hook to this database */
  int (*xCallback)(void*),  /* Function to invoke on each commit */
  void *pArg                /* Argument to the function */
){
  void *pOld = db->pCommitArg;
  db->xCommitCallback = xCallback;
  db->pCommitArg = pArg;
  return pOld;
}


/*
** This routine is called to create a connection to a database BTree
** driver.  If zFilename is the name of a file, then that file is
** opened and used.  If zFilename is the magic name ":memory:" then
** the database is stored in memory (and is thus forgotten as soon as
** the connection is closed.)  If zFilename is NULL then the database
** is for temporary use only and is deleted as soon as the connection
** is closed.
**
** A temporary database can be either a disk file (that is automatically
** deleted when the file is closed) or a set of red-black trees held in memory,
** depending on the values of the TEMP_STORE compile-time macro and the
** db->temp_store variable, according to the following chart:
**
**       TEMP_STORE     db->temp_store     Location of temporary database
**       ----------     --------------     ------------------------------
**           0               any             file
**           1                1              file
**           1                2              memory
**           1                0              file
**           2                1              file
**           2                2              memory
**           2                0              memory
**           3               any             memory
*/
int sqliteBtreeFactory(
  const sqlite *db,	    /* Main database when opening aux otherwise 0 */
  const char *zFilename,    /* Name of the file containing the BTree database */
  int omitJournal,          /* if TRUE then do not journal this file */
  int nCache,               /* How many pages in the page cache */
  Btree **ppBtree){         /* Pointer to new Btree object written here */

  assert( ppBtree != 0);

#ifndef SQLITE_OMIT_INMEMORYDB
  if( zFilename==0 ){
    if (TEMP_STORE == 0) {
      /* Always use file based temporary DB */
      return sqliteBtreeOpen(0, omitJournal, nCache, ppBtree);
    } else if (TEMP_STORE == 1 || TEMP_STORE == 2) {
      /* Switch depending on compile-time and/or runtime settings. */
      int location = db->temp_store==0 ? TEMP_STORE : db->temp_store;

      if (location == 1) {
        return sqliteBtreeOpen(zFilename, omitJournal, nCache, ppBtree);
      } else {
        return sqliteRbtreeOpen(0, 0, 0, ppBtree);
      }
    } else {
      /* Always use in-core DB */
      return sqliteRbtreeOpen(0, 0, 0, ppBtree);
    }
  }else if( zFilename[0]==':' && strcmp(zFilename,":memory:")==0 ){
    return sqliteRbtreeOpen(0, 0, 0, ppBtree);
  }else
#endif
  {
    return sqliteBtreeOpen(zFilename, omitJournal, nCache, ppBtree);
  }
}



/* ============================================================================
 * SOURCE 20/98: minix4\libos\lib_legacy\libarchive\test\main.c
 * Size: 53,554 bytes, Lines: 2,131
 * Hash: 4f8f0aef1541...
 * ============================================================================ */

/*
 * Copyright (c) 2003-2009 Tim Kientzle
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "test.h"
#include <errno.h>
#include <locale.h>
#include <stdarg.h>
#include <time.h>

/*
 * This same file is used pretty much verbatim for all test harnesses.
 *
 * The next few lines are the only differences.
 * TODO: Move this into a separate configuration header, have all test
 * suites share one copy of this file.
 */
__FBSDID("$FreeBSD: head/lib/libarchive/test/main.c 201247 2009-12-30 05:59:21Z kientzle $");
#define KNOWNREF	"test_compat_gtar_1.tar.uu"
#define	ENVBASE "LIBARCHIVE" /* Prefix for environment variables. */
#undef	PROGRAM              /* Testing a library, not a program. */
#define	LIBRARY	"libarchive"
#define	EXTRA_DUMP(x)	archive_error_string((struct archive *)(x))
#define	EXTRA_VERSION	archive_version()

/*
 *
 * Windows support routines
 *
 * Note: Configuration is a tricky issue.  Using HAVE_* feature macros
 * in the test harness is dangerous because they cover up
 * configuration errors.  The classic example of this is omitting a
 * configure check.  If libarchive and libarchive_test both look for
 * the same feature macro, such errors are hard to detect.  Platform
 * macros (e.g., _WIN32 or __GNUC__) are a little better, but can
 * easily lead to very messy code.  It's best to limit yourself
 * to only the most generic programming techniques in the test harness
 * and thus avoid conditionals altogether.  Where that's not possible,
 * try to minimize conditionals by grouping platform-specific tests in
 * one place (e.g., test_acl_freebsd) or by adding new assert()
 * functions (e.g., assertMakeHardlink()) to cover up platform
 * differences.  Platform-specific coding in libarchive_test is often
 * a symptom that some capability is missing from libarchive itself.
 */
#if defined(_WIN32) && !defined(__CYGWIN__)
#include <io.h>
#include <windows.h>
#ifndef F_OK
#define F_OK (0)
#endif
#ifndef S_ISDIR
#define S_ISDIR(m)  ((m) & _S_IFDIR)
#endif
#ifndef S_ISREG
#define S_ISREG(m)  ((m) & _S_IFREG)
#endif
#if !defined(__BORLANDC__)
#define access _access
#define chdir _chdir
#endif
#ifndef fileno
#define fileno _fileno
#endif
/*#define fstat _fstat64*/
#if !defined(__BORLANDC__)
#define getcwd _getcwd
#endif
#define lstat stat
/*#define lstat _stat64*/
/*#define stat _stat64*/
#define rmdir _rmdir
#if !defined(__BORLANDC__)
#define strdup _strdup
#define umask _umask
#endif
#define int64_t __int64
#endif

#if defined(HAVE__CrtSetReportMode)
# include <crtdbg.h>
#endif

#if defined(_WIN32) && !defined(__CYGWIN__)
void *GetFunctionKernel32(const char *name)
{
	static HINSTANCE lib;
	static int set;
	if (!set) {
		set = 1;
		lib = LoadLibrary("kernel32.dll");
	}
	if (lib == NULL) {
		fprintf(stderr, "Can't load kernel32.dll?!\n");
		exit(1);
	}
	return (void *)GetProcAddress(lib, name);
}

static int
my_CreateSymbolicLinkA(const char *linkname, const char *target, int flags)
{
	static BOOLEAN (WINAPI *f)(LPCSTR, LPCSTR, DWORD);
	static int set;
	if (!set) {
		set = 1;
		f = GetFunctionKernel32("CreateSymbolicLinkA");
	}
	return f == NULL ? 0 : (*f)(linkname, target, flags);
}

static int
my_CreateHardLinkA(const char *linkname, const char *target)
{
	static BOOLEAN (WINAPI *f)(LPCSTR, LPCSTR, LPSECURITY_ATTRIBUTES);
	static int set;
	if (!set) {
		set = 1;
		f = GetFunctionKernel32("CreateHardLinkA");
	}
	return f == NULL ? 0 : (*f)(linkname, target, NULL);
}

int
my_GetFileInformationByName(const char *path, BY_HANDLE_FILE_INFORMATION *bhfi)
{
	HANDLE h;
	int r;

	memset(bhfi, 0, sizeof(*bhfi));
	h = CreateFile(path, FILE_READ_ATTRIBUTES, 0, NULL,
		OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (h == INVALID_HANDLE_VALUE)
		return (0);
	r = GetFileInformationByHandle(h, bhfi);
	CloseHandle(h);
	return (r);
}
#endif

#if defined(HAVE__CrtSetReportMode)
static void
invalid_parameter_handler(const wchar_t * expression,
    const wchar_t * function, const wchar_t * file,
    unsigned int line, uintptr_t pReserved)
{
	/* nop */
}
#endif

/*
 *
 * OPTIONS FLAGS
 *
 */

/* Enable core dump on failure. */
static int dump_on_failure = 0;
/* Default is to remove temp dirs and log data for successful tests. */
static int keep_temp_files = 0;
/* Default is to just report pass/fail for each test. */
static int verbosity = 0;
#define	VERBOSITY_SUMMARY_ONLY -1 /* -q */
#define VERBOSITY_PASSFAIL 0   /* Default */
#define VERBOSITY_LIGHT_REPORT 1 /* -v */
#define VERBOSITY_FULL 2 /* -vv */
/* A few places generate even more output for verbosity > VERBOSITY_FULL,
 * mostly for debugging the test harness itself. */
/* Cumulative count of assertion failures. */
static int failures = 0;
/* Cumulative count of reported skips. */
static int skips = 0;
/* Cumulative count of assertions checked. */
static int assertions = 0;

/* Directory where uuencoded reference files can be found. */
static const char *refdir;

/*
 * Report log information selectively to console and/or disk log.
 */
static int log_console = 0;
static FILE *logfile;
static void
vlogprintf(const char *fmt, va_list ap)
{
#ifdef va_copy
	va_list lfap;
	va_copy(lfap, ap);
#endif
	if (log_console)
		vfprintf(stdout, fmt, ap);
	if (logfile != NULL)
#ifdef va_copy
		vfprintf(logfile, fmt, lfap);
	va_end(lfap);
#else
		vfprintf(logfile, fmt, ap);
#endif
}

static void
logprintf(const char *fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);
	vlogprintf(fmt, ap);
	va_end(ap);
}

/* Set up a message to display only if next assertion fails. */
static char msgbuff[4096];
static const char *msg, *nextmsg;
void
failure(const char *fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);
	vsprintf(msgbuff, fmt, ap);
	va_end(ap);
	nextmsg = msgbuff;
}

/*
 * Copy arguments into file-local variables.
 * This was added to permit vararg assert() functions without needing
 * variadic wrapper macros.  Turns out that the vararg capability is almost
 * never used, so almost all of the vararg assertions can be simplified
 * by removing the vararg capability and reworking the wrapper macro to
 * pass __FILE__, __LINE__ directly into the function instead of using
 * this hook.  I suspect this machinery is used so rarely that we
 * would be better off just removing it entirely.  That would simplify
 * the code here noticably.
 */
static const char *test_filename;
static int test_line;
static void *test_extra;
void assertion_setup(const char *filename, int line)
{
	test_filename = filename;
	test_line = line;
}

/* Called at the beginning of each assert() function. */
static void
assertion_count(const char *file, int line)
{
	(void)file; /* UNUSED */
	(void)line; /* UNUSED */
	++assertions;
	/* Proper handling of "failure()" message. */
	msg = nextmsg;
	nextmsg = NULL;
	/* Uncomment to print file:line after every assertion.
	 * Verbose, but occasionally useful in tracking down crashes. */
	/* printf("Checked %s:%d\n", file, line); */
}

/*
 * For each test source file, we remember how many times each
 * assertion was reported.  Cleared before each new test,
 * used by test_summarize().
 */
static struct line {
	int count;
	int skip;
}  failed_lines[10000];

/* Count this failure, setup up log destination and handle initial report. */
static void
failure_start(const char *filename, int line, const char *fmt, ...)
{
	va_list ap;

	/* Record another failure for this line. */
	++failures;
	/* test_filename = filename; */
	failed_lines[line].count++;

	/* Determine whether to log header to console. */
	switch (verbosity) {
	case VERBOSITY_LIGHT_REPORT:
		log_console = (failed_lines[line].count < 2);
		break;
	default:
		log_console = (verbosity >= VERBOSITY_FULL);
	}

	/* Log file:line header for this failure */
	va_start(ap, fmt);
#if _MSC_VER
	logprintf("%s(%d): ", filename, line);
#else
	logprintf("%s:%d: ", filename, line);
#endif
	vlogprintf(fmt, ap);
	va_end(ap);
	logprintf("\n");

	if (msg != NULL && msg[0] != '\0') {
		logprintf("   Description: %s\n", msg);
		msg = NULL;
	}

	/* Determine whether to log details to console. */
	if (verbosity == VERBOSITY_LIGHT_REPORT)
		log_console = 0;
}

/* Complete reporting of failed tests. */
/*
 * The 'extra' hook here is used by libarchive to include libarchive
 * error messages with assertion failures.  It could also be used
 * to add strerror() output, for example.  Just define the EXTRA_DUMP()
 * macro appropriately.
 */
static void
failure_finish(void *extra)
{
	(void)extra; /* UNUSED (maybe) */
#ifdef EXTRA_DUMP
	if (extra != NULL)
		logprintf("   detail: %s\n", EXTRA_DUMP(extra));
#endif

	if (dump_on_failure) {
		fprintf(stderr,
		    " *** forcing core dump so failure can be debugged ***\n");
		abort();
		exit(1);
	}
}

/* Inform user that we're skipping some checks. */
void
test_skipping(const char *fmt, ...)
{
	char buff[1024];
	va_list ap;

	va_start(ap, fmt);
	vsprintf(buff, fmt, ap);
	va_end(ap);
	/* failure_start() isn't quite right, but is awfully convenient. */
	failure_start(test_filename, test_line, "SKIPPING: %s", buff);
	--failures; /* Undo failures++ in failure_start() */
	/* Don't failure_finish() here. */
	/* Mark as skip, so doesn't count as failed test. */
	failed_lines[test_line].skip = 1;
	++skips;
}

/*
 *
 * ASSERTIONS
 *
 */

/* Generic assert() just displays the failed condition. */
int
assertion_assert(const char *file, int line, int value,
    const char *condition, void *extra)
{
	assertion_count(file, line);
	if (!value) {
		failure_start(file, line, "Assertion failed: %s", condition);
		failure_finish(extra);
	}
	return (value);
}

/* chdir() and report any errors */
int
assertion_chdir(const char *file, int line, const char *pathname)
{
	assertion_count(file, line);
	if (chdir(pathname) == 0)
		return (1);
	failure_start(file, line, "chdir(\"%s\")", pathname);
	failure_finish(NULL);
	return (0);

}

/* Verify two integers are equal. */
int
assertion_equal_int(const char *file, int line,
    long long v1, const char *e1, long long v2, const char *e2, void *extra)
{
	assertion_count(file, line);
	if (v1 == v2)
		return (1);
	failure_start(file, line, "%s != %s", e1, e2);
	logprintf("      %s=%lld (0x%llx, 0%llo)\n", e1, v1, v1, v1);
	logprintf("      %s=%lld (0x%llx, 0%llo)\n", e2, v2, v2, v2);
	failure_finish(extra);
	return (0);
}

static void strdump(const char *e, const char *p)
{
	const char *q = p;

	logprintf("      %s = ", e);
	if (p == NULL) {
		logprintf("NULL");
		return;
	}
	logprintf("\"");
	while (*p != '\0') {
		unsigned int c = 0xff & *p++;
		switch (c) {
		case '\a': printf("\a"); break;
		case '\b': printf("\b"); break;
		case '\n': printf("\n"); break;
		case '\r': printf("\r"); break;
		default:
			if (c >= 32 && c < 127)
				logprintf("%c", c);
			else
				logprintf("\\x%02X", c);
		}
	}
	logprintf("\"");
	logprintf(" (length %d)\n", q == NULL ? -1 : (int)strlen(q));
}

/* Verify two strings are equal, dump them if not. */
int
assertion_equal_string(const char *file, int line,
    const char *v1, const char *e1,
    const char *v2, const char *e2,
    void *extra)
{
	assertion_count(file, line);
	if (v1 == v2 || (v1 != NULL && v2 != NULL && strcmp(v1, v2) == 0))
		return (1);
	failure_start(file, line, "%s != %s", e1, e2);
	strdump(e1, v1);
	strdump(e2, v2);
	failure_finish(extra);
	return (0);
}

static void
wcsdump(const char *e, const wchar_t *w)
{
	logprintf("      %s = ", e);
	if (w == NULL) {
		logprintf("(null)");
		return;
	}
	logprintf("\"");
	while (*w != L'\0') {
		unsigned int c = *w++;
		if (c >= 32 && c < 127)
			logprintf("%c", c);
		else if (c < 256)
			logprintf("\\x%02X", c);
		else if (c < 0x10000)
			logprintf("\\u%04X", c);
		else
			logprintf("\\U%08X", c);
	}
	logprintf("\"\n");
}

#ifndef HAVE_WCSCMP
static int
wcscmp(const wchar_t *s1, const wchar_t *s2)
{

	while (*s1 == *s2++) {
		if (*s1++ == L'\0')
			return 0;
	}
	if (*s1 > *--s2)
		return 1;
	else
		return -1;
}
#endif

/* Verify that two wide strings are equal, dump them if not. */
int
assertion_equal_wstring(const char *file, int line,
    const wchar_t *v1, const char *e1,
    const wchar_t *v2, const char *e2,
    void *extra)
{
	assertion_count(file, line);
	if (v1 == v2 || wcscmp(v1, v2) == 0)
		return (1);
	failure_start(file, line, "%s != %s", e1, e2);
	wcsdump(e1, v1);
	wcsdump(e2, v2);
	failure_finish(extra);
	return (0);
}

/*
 * Pretty standard hexdump routine.  As a bonus, if ref != NULL, then
 * any bytes in p that differ from ref will be highlighted with '_'
 * before and after the hex value.
 */
static void
hexdump(const char *p, const char *ref, size_t l, size_t offset)
{
	size_t i, j;
	char sep;

	if (p == NULL) {
		logprintf("(null)\n");
		return;
	}
	for(i=0; i < l; i+=16) {
		logprintf("%04x", (unsigned)(i + offset));
		sep = ' ';
		for (j = 0; j < 16 && i + j < l; j++) {
			if (ref != NULL && p[i + j] != ref[i + j])
				sep = '_';
			logprintf("%c%02x", sep, 0xff & (int)p[i+j]);
			if (ref != NULL && p[i + j] == ref[i + j])
				sep = ' ';
		}
		for (; j < 16; j++) {
			logprintf("%c  ", sep);
			sep = ' ';
		}
		logprintf("%c", sep);
		for (j=0; j < 16 && i + j < l; j++) {
			int c = p[i + j];
			if (c >= ' ' && c <= 126)
				logprintf("%c", c);
			else
				logprintf(".");
		}
		logprintf("\n");
	}
}

/* Verify that two blocks of memory are the same, display the first
 * block of differences if they're not. */
int
assertion_equal_mem(const char *file, int line,
    const void *_v1, const char *e1,
    const void *_v2, const char *e2,
    size_t l, const char *ld, void *extra)
{
	const char *v1 = (const char *)_v1;
	const char *v2 = (const char *)_v2;
	size_t offset;

	assertion_count(file, line);
	if (v1 == v2 || (v1 != NULL && v2 != NULL && memcmp(v1, v2, l) == 0))
		return (1);

	failure_start(file, line, "%s != %s", e1, e2);
	logprintf("      size %s = %d\n", ld, (int)l);
	/* Dump 48 bytes (3 lines) so that the first difference is
	 * in the second line. */
	offset = 0;
	while (l > 64 && memcmp(v1, v2, 32) == 0) {
		/* Two lines agree, so step forward one line. */
		v1 += 16;
		v2 += 16;
		l -= 16;
		offset += 16;
	}
	logprintf("      Dump of %s\n", e1);
	hexdump(v1, v2, l < 64 ? l : 64, offset);
	logprintf("      Dump of %s\n", e2);
	hexdump(v2, v1, l < 64 ? l : 64, offset);
	logprintf("\n");
	failure_finish(extra);
	return (0);
}

/* Verify that the named file exists and is empty. */
int
assertion_empty_file(const char *f1fmt, ...)
{
	char buff[1024];
	char f1[1024];
	struct stat st;
	va_list ap;
	ssize_t s;
	FILE *f;

	assertion_count(test_filename, test_line);
	va_start(ap, f1fmt);
	vsprintf(f1, f1fmt, ap);
	va_end(ap);

	if (stat(f1, &st) != 0) {
		failure_start(test_filename, test_line, "Stat failed: %s", f1);
		failure_finish(NULL);
		return (0);
	}
	if (st.st_size == 0)
		return (1);

	failure_start(test_filename, test_line, "File should be empty: %s", f1);
	logprintf("    File size: %d\n", (int)st.st_size);
	logprintf("    Contents:\n");
	f = fopen(f1, "rb");
	if (f == NULL) {
		logprintf("    Unable to open %s\n", f1);
	} else {
		s = ((off_t)sizeof(buff) < st.st_size) ?
		    (ssize_t)sizeof(buff) : (ssize_t)st.st_size;
		s = fread(buff, 1, s, f);
		hexdump(buff, NULL, s, 0);
		fclose(f);
	}
	failure_finish(NULL);
	return (0);
}

/* Verify that the named file exists and is not empty. */
int
assertion_non_empty_file(const char *f1fmt, ...)
{
	char f1[1024];
	struct stat st;
	va_list ap;

	assertion_count(test_filename, test_line);
	va_start(ap, f1fmt);
	vsprintf(f1, f1fmt, ap);
	va_end(ap);

	if (stat(f1, &st) != 0) {
		failure_start(test_filename, test_line, "Stat failed: %s", f1);
		failure_finish(NULL);
		return (0);
	}
	if (st.st_size == 0) {
		failure_start(test_filename, test_line, "File empty: %s", f1);
		failure_finish(NULL);
		return (0);
	}
	return (1);
}

/* Verify that two files have the same contents. */
/* TODO: hexdump the first bytes that actually differ. */
int
assertion_equal_file(const char *fn1, const char *f2pattern, ...)
{
	char fn2[1024];
	va_list ap;
	char buff1[1024];
	char buff2[1024];
	FILE *f1, *f2;
	int n1, n2;

	assertion_count(test_filename, test_line);
	va_start(ap, f2pattern);
	vsprintf(fn2, f2pattern, ap);
	va_end(ap);

	f1 = fopen(fn1, "rb");
	f2 = fopen(fn2, "rb");
	for (;;) {
		n1 = fread(buff1, 1, sizeof(buff1), f1);
		n2 = fread(buff2, 1, sizeof(buff2), f2);
		if (n1 != n2)
			break;
		if (n1 == 0 && n2 == 0) {
			fclose(f1);
			fclose(f2);
			return (1);
		}
		if (memcmp(buff1, buff2, n1) != 0)
			break;
	}
	fclose(f1);
	fclose(f2);
	failure_start(test_filename, test_line, "Files not identical");
	logprintf("  file1=\"%s\"\n", fn1);
	logprintf("  file2=\"%s\"\n", fn2);
	failure_finish(test_extra);
	return (0);
}

/* Verify that the named file does exist. */
int
assertion_file_exists(const char *fpattern, ...)
{
	char f[1024];
	va_list ap;

	assertion_count(test_filename, test_line);
	va_start(ap, fpattern);
	vsprintf(f, fpattern, ap);
	va_end(ap);

#if defined(_WIN32) && !defined(__CYGWIN__)
	if (!_access(f, 0))
		return (1);
#else
	if (!access(f, F_OK))
		return (1);
#endif
	failure_start(test_filename, test_line, "File should exist: %s", f);
	failure_finish(test_extra);
	return (0);
}

/* Verify that the named file doesn't exist. */
int
assertion_file_not_exists(const char *fpattern, ...)
{
	char f[1024];
	va_list ap;

	assertion_count(test_filename, test_line);
	va_start(ap, fpattern);
	vsprintf(f, fpattern, ap);
	va_end(ap);

#if defined(_WIN32) && !defined(__CYGWIN__)
	if (_access(f, 0))
		return (1);
#else
	if (access(f, F_OK))
		return (1);
#endif
	failure_start(test_filename, test_line, "File should not exist: %s", f);
	failure_finish(test_extra);
	return (0);
}

/* Compare the contents of a file to a block of memory. */
int
assertion_file_contents(const void *buff, int s, const char *fpattern, ...)
{
	char fn[1024];
	va_list ap;
	char *contents;
	FILE *f;
	int n;

	assertion_count(test_filename, test_line);
	va_start(ap, fpattern);
	vsprintf(fn, fpattern, ap);
	va_end(ap);

	f = fopen(fn, "rb");
	if (f == NULL) {
		failure_start(test_filename, test_line,
		    "File should exist: %s", fn);
		failure_finish(test_extra);
		return (0);
	}
	contents = malloc(s * 2);
	n = fread(contents, 1, s * 2, f);
	fclose(f);
	if (n == s && memcmp(buff, contents, s) == 0) {
		free(contents);
		return (1);
	}
	failure_start(test_filename, test_line, "File contents don't match");
	logprintf("  file=\"%s\"\n", fn);
	if (n > 0)
		hexdump(contents, buff, n > 512 ? 512 : n, 0);
	else {
		logprintf("  File empty, contents should be:\n");
		hexdump(buff, NULL, s > 512 ? 512 : n, 0);
	}
	failure_finish(test_extra);
	free(contents);
	return (0);
}

/* Check the contents of a text file, being tolerant of line endings. */
int
assertion_text_file_contents(const char *buff, const char *fn)
{
	char *contents;
	const char *btxt, *ftxt;
	FILE *f;
	int n, s;

	assertion_count(test_filename, test_line);
	f = fopen(fn, "r");
	s = strlen(buff);
	contents = malloc(s * 2 + 128);
	n = fread(contents, 1, s * 2 + 128 - 1, f);
	if (n >= 0)
		contents[n] = '\0';
	fclose(f);
	/* Compare texts. */
	btxt = buff;
	ftxt = (const char *)contents;
	while (*btxt != '\0' && *ftxt != '\0') {
		if (*btxt == *ftxt) {
			++btxt;
			++ftxt;
			continue;
		}
		if (btxt[0] == '\n' && ftxt[0] == '\r' && ftxt[1] == '\n') {
			/* Pass over different new line characters. */
			++btxt;
			ftxt += 2;
			continue;
		}
		break;
	}
	if (*btxt == '\0' && *ftxt == '\0') {
		free(contents);
		return (1);
	}
	failure_start(test_filename, test_line, "Contents don't match");
	logprintf("  file=\"%s\"\n", fn);
	if (n > 0)
		hexdump(contents, buff, n, 0);
	else {
		logprintf("  File empty, contents should be:\n");
		hexdump(buff, NULL, s, 0);
	}
	failure_finish(test_extra);
	free(contents);
	return (0);
}

/* Test that two paths point to the same file. */
/* As a side-effect, asserts that both files exist. */
static int
is_hardlink(const char *file, int line,
    const char *path1, const char *path2)
{
#if defined(_WIN32) && !defined(__CYGWIN__)
	BY_HANDLE_FILE_INFORMATION bhfi1, bhfi2;
	int r;

	assertion_count(file, line);
	r = my_GetFileInformationByName(path1, &bhfi1);
	if (r == 0) {
		failure_start(file, line, "File %s can't be inspected?", path1);
		failure_finish(NULL);
		return (0);
	}
	r = my_GetFileInformationByName(path2, &bhfi2);
	if (r == 0) {
		failure_start(file, line, "File %s can't be inspected?", path2);
		failure_finish(NULL);
		return (0);
	}
	return (bhfi1.dwVolumeSerialNumber == bhfi2.dwVolumeSerialNumber
		&& bhfi1.nFileIndexHigh == bhfi2.nFileIndexHigh
		&& bhfi1.nFileIndexLow == bhfi2.nFileIndexLow);
#else
	struct stat st1, st2;
	int r;

	assertion_count(file, line);
	r = lstat(path1, &st1);
	if (r != 0) {
		failure_start(file, line, "File should exist: %s", path1);
		failure_finish(NULL);
		return (0);
	}
	r = lstat(path2, &st2);
	if (r != 0) {
		failure_start(file, line, "File should exist: %s", path2);
		failure_finish(NULL);
		return (0);
	}
	return (st1.st_ino == st2.st_ino && st1.st_dev == st2.st_dev);
#endif
}

int
assertion_is_hardlink(const char *file, int line,
    const char *path1, const char *path2)
{
	if (is_hardlink(file, line, path1, path2))
		return (1);
	failure_start(file, line,
	    "Files %s and %s are not hardlinked", path1, path2);
	failure_finish(NULL);
	return (0);
}

int
assertion_is_not_hardlink(const char *file, int line,
    const char *path1, const char *path2)
{
	if (!is_hardlink(file, line, path1, path2))
		return (1);
	failure_start(file, line,
	    "Files %s and %s should not be hardlinked", path1, path2);
	failure_finish(NULL);
	return (0);
}

/* Verify a/b/mtime of 'pathname'. */
/* If 'recent', verify that it's within last 10 seconds. */
static int
assertion_file_time(const char *file, int line,
    const char *pathname, long t, long nsec, char type, int recent)
{
	long long filet, filet_nsec;
	int r;

#if defined(_WIN32) && !defined(__CYGWIN__)
#define EPOC_TIME	(116444736000000000ULL)
	FILETIME ftime, fbirthtime, fatime, fmtime;
	ULARGE_INTEGER wintm;
	HANDLE h;
	ftime.dwLowDateTime = 0;
	ftime.dwHighDateTime = 0;

	assertion_count(file, line);
	h = CreateFile(pathname, FILE_READ_ATTRIBUTES, 0, NULL,
	    OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (h == INVALID_HANDLE_VALUE) {
		failure_start(file, line, "Can't access %s\n", pathname);
		failure_finish(NULL);
		return (0);
	}
	r = GetFileTime(h, &fbirthtime, &fatime, &fmtime);
	switch (type) {
	case 'a': ftime = fatime; break;
	case 'b': ftime = fbirthtime; break;
	case 'm': ftime = fmtime; break;
	}
	CloseHandle(h);
	if (r == 0) {
		failure_start(file, line, "Can't GetFileTime %s\n", pathname);
		failure_finish(NULL);
		return (0);
	}
	wintm.LowPart = ftime.dwLowDateTime;
	wintm.HighPart = ftime.dwHighDateTime;
	filet = (wintm.QuadPart - EPOC_TIME) / 10000000;
	filet_nsec = ((wintm.QuadPart - EPOC_TIME) % 10000000) * 100;
	nsec = (nsec / 100) * 100; /* Round the request */
#else
	struct stat st;

	assertion_count(file, line);
	r = lstat(pathname, &st);
	if (r != 0) {
		failure_start(file, line, "Can't stat %s\n", pathname);
		failure_finish(NULL);
		return (0);
	}
	switch (type) {
	case 'a': filet = st.st_atime; break;
	case 'm': filet = st.st_mtime; break;
	case 'b': filet = 0; break;
	default: fprintf(stderr, "INTERNAL: Bad type %c for file time", type);
		exit(1);
	}
#if defined(__FreeBSD__)
	switch (type) {
	case 'a': filet_nsec = st.st_atimespec.tv_nsec; break;
	case 'b': filet = st.st_birthtime;
		filet_nsec = st.st_birthtimespec.tv_nsec; break;
	case 'm': filet_nsec = st.st_mtimespec.tv_nsec; break;
	default: fprintf(stderr, "INTERNAL: Bad type %c for file time", type);
		exit(1);
	}
	/* FreeBSD generally only stores to microsecond res, so round. */
	filet_nsec = (filet_nsec / 1000) * 1000;
	nsec = (nsec / 1000) * 1000;
#else
	filet_nsec = nsec = 0;	/* Generic POSIX only has whole seconds. */
	if (type == 'b') return (1); /* Generic POSIX doesn't have birthtime */
#if defined(__HAIKU__)
	if (type == 'a') return (1); /* Haiku doesn't have atime. */
#endif
#endif
#endif
	if (recent) {
		/* Check that requested time is up-to-date. */
		time_t now = time(NULL);
		if (filet < now - 10 || filet > now + 1) {
			failure_start(file, line,
			    "File %s has %ctime %ld, %ld seconds ago\n",
			    pathname, type, filet, now - filet);
			failure_finish(NULL);
			return (0);
		}
	} else if (filet != t || filet_nsec != nsec) {
		failure_start(file, line,
		    "File %s has %ctime %ld.%09ld, expected %ld.%09ld",
		    pathname, type, filet, filet_nsec, t, nsec);
		failure_finish(NULL);
		return (0);
	}
	return (1);
}

/* Verify atime of 'pathname'. */
int
assertion_file_atime(const char *file, int line,
    const char *pathname, long t, long nsec)
{
	return assertion_file_time(file, line, pathname, t, nsec, 'a', 0);
}

/* Verify atime of 'pathname' is up-to-date. */
int
assertion_file_atime_recent(const char *file, int line, const char *pathname)
{
	return assertion_file_time(file, line, pathname, 0, 0, 'a', 1);
}

/* Verify birthtime of 'pathname'. */
int
assertion_file_birthtime(const char *file, int line,
    const char *pathname, long t, long nsec)
{
	return assertion_file_time(file, line, pathname, t, nsec, 'b', 0);
}

/* Verify birthtime of 'pathname' is up-to-date. */
int
assertion_file_birthtime_recent(const char *file, int line,
    const char *pathname)
{
	return assertion_file_time(file, line, pathname, 0, 0, 'b', 1);
}

/* Verify mtime of 'pathname'. */
int
assertion_file_mtime(const char *file, int line,
    const char *pathname, long t, long nsec)
{
	return assertion_file_time(file, line, pathname, t, nsec, 'm', 0);
}

/* Verify mtime of 'pathname' is up-to-date. */
int
assertion_file_mtime_recent(const char *file, int line, const char *pathname)
{
	return assertion_file_time(file, line, pathname, 0, 0, 'm', 1);
}

/* Verify number of links to 'pathname'. */
int
assertion_file_nlinks(const char *file, int line,
    const char *pathname, int nlinks)
{
#if defined(_WIN32) && !defined(__CYGWIN__)
	BY_HANDLE_FILE_INFORMATION bhfi;
	int r;

	assertion_count(file, line);
	r = my_GetFileInformationByName(pathname, &bhfi);
	if (r != 0 && bhfi.nNumberOfLinks == (DWORD)nlinks)
		return (1);
	failure_start(file, line, "File %s has %d links, expected %d",
	    pathname, bhfi.nNumberOfLinks, nlinks);
	failure_finish(NULL);
	return (0);
#else
	struct stat st;
	int r;

	assertion_count(file, line);
	r = lstat(pathname, &st);
	if (r == 0 && st.st_nlink == nlinks)
			return (1);
	failure_start(file, line, "File %s has %d links, expected %d",
	    pathname, st.st_nlink, nlinks);
	failure_finish(NULL);
	return (0);
#endif
}

/* Verify size of 'pathname'. */
int
assertion_file_size(const char *file, int line, const char *pathname, long size)
{
	int64_t filesize;
	int r;

	assertion_count(file, line);
#if defined(_WIN32) && !defined(__CYGWIN__)
	{
		BY_HANDLE_FILE_INFORMATION bhfi;
		r = !my_GetFileInformationByName(pathname, &bhfi);
		filesize = ((int64_t)bhfi.nFileSizeHigh << 32) + bhfi.nFileSizeLow;
	}
#else
	{
		struct stat st;
		r = lstat(pathname, &st);
		filesize = st.st_size;
	}
#endif
	if (r == 0 && filesize == size)
			return (1);
	failure_start(file, line, "File %s has size %ld, expected %ld",
	    pathname, (long)filesize, (long)size);
	failure_finish(NULL);
	return (0);
}

/* Assert that 'pathname' is a dir.  If mode >= 0, verify that too. */
int
assertion_is_dir(const char *file, int line, const char *pathname, int mode)
{
	struct stat st;
	int r;

#if defined(_WIN32) && !defined(__CYGWIN__)
	(void)mode; /* UNUSED */
#endif
	assertion_count(file, line);
	r = lstat(pathname, &st);
	if (r != 0) {
		failure_start(file, line, "Dir should exist: %s", pathname);
		failure_finish(NULL);
		return (0);
	}
	if (!S_ISDIR(st.st_mode)) {
		failure_start(file, line, "%s is not a dir", pathname);
		failure_finish(NULL);
		return (0);
	}
#if !defined(_WIN32) || defined(__CYGWIN__)
	/* Windows doesn't handle permissions the same way as POSIX,
	 * so just ignore the mode tests. */
	/* TODO: Can we do better here? */
	if (mode >= 0 && mode != (st.st_mode & 07777)) {
		failure_start(file, line, "Dir %s has wrong mode", pathname);
		logprintf("  Expected: 0%3o\n", mode);
		logprintf("  Found: 0%3o\n", st.st_mode & 07777);
		failure_finish(NULL);
		return (0);
	}
#endif
	return (1);
}

/* Verify that 'pathname' is a regular file.  If 'mode' is >= 0,
 * verify that too. */
int
assertion_is_reg(const char *file, int line, const char *pathname, int mode)
{
	struct stat st;
	int r;

#if defined(_WIN32) && !defined(__CYGWIN__)
	(void)mode; /* UNUSED */
#endif
	assertion_count(file, line);
	r = lstat(pathname, &st);
	if (r != 0 || !S_ISREG(st.st_mode)) {
		failure_start(file, line, "File should exist: %s", pathname);
		failure_finish(NULL);
		return (0);
	}
#if !defined(_WIN32) || defined(__CYGWIN__)
	/* Windows doesn't handle permissions the same way as POSIX,
	 * so just ignore the mode tests. */
	/* TODO: Can we do better here? */
	if (mode >= 0 && mode != (st.st_mode & 07777)) {
		failure_start(file, line, "File %s has wrong mode", pathname);
		logprintf("  Expected: 0%3o\n", mode);
		logprintf("  Found: 0%3o\n", st.st_mode & 07777);
		failure_finish(NULL);
		return (0);
	}
#endif
	return (1);
}

/* Check whether 'pathname' is a symbolic link.  If 'contents' is
 * non-NULL, verify that the symlink has those contents. */
static int
is_symlink(const char *file, int line,
    const char *pathname, const char *contents)
{
#if defined(_WIN32) && !defined(__CYGWIN__)
	(void)pathname; /* UNUSED */
	(void)contents; /* UNUSED */
	assertion_count(file, line);
	/* Windows sort-of has real symlinks, but they're only usable
	 * by privileged users and are crippled even then, so there's
	 * really not much point in bothering with this. */
	return (0);
#else
	char buff[300];
	struct stat st;
	ssize_t linklen;
	int r;

	assertion_count(file, line);
	r = lstat(pathname, &st);
	if (r != 0) {
		failure_start(file, line,
		    "Symlink should exist: %s", pathname);
		failure_finish(NULL);
		return (0);
	}
	if (!S_ISLNK(st.st_mode))
		return (0);
	if (contents == NULL)
		return (1);
	linklen = readlink(pathname, buff, sizeof(buff));
	if (linklen < 0) {
		failure_start(file, line, "Can't read symlink %s", pathname);
		failure_finish(NULL);
		return (0);
	}
	buff[linklen] = '\0';
	if (strcmp(buff, contents) != 0)
		return (0);
	return (1);
#endif
}

/* Assert that path is a symlink that (optionally) contains contents. */
int
assertion_is_symlink(const char *file, int line,
    const char *path, const char *contents)
{
	if (is_symlink(file, line, path, contents))
		return (1);
	if (contents)
		failure_start(file, line, "File %s is not a symlink to %s",
		    path, contents);
	else
		failure_start(file, line, "File %s is not a symlink", path);
	failure_finish(NULL);
	return (0);
}


/* Create a directory and report any errors. */
int
assertion_make_dir(const char *file, int line, const char *dirname, int mode)
{
	assertion_count(file, line);
#if defined(_WIN32) && !defined(__CYGWIN__)
	(void)mode; /* UNUSED */
	if (0 == _mkdir(dirname))
		return (1);
#else
	if (0 == mkdir(dirname, mode))
		return (1);
#endif
	failure_start(file, line, "Could not create directory %s", dirname);
	failure_finish(NULL);
	return(0);
}

/* Create a file with the specified contents and report any failures. */
int
assertion_make_file(const char *file, int line,
    const char *path, int mode, const char *contents)
{
#if defined(_WIN32) && !defined(__CYGWIN__)
	/* TODO: Rework this to set file mode as well. */
	FILE *f;
	(void)mode; /* UNUSED */
	assertion_count(file, line);
	f = fopen(path, "wb");
	if (f == NULL) {
		failure_start(file, line, "Could not create file %s", path);
		failure_finish(NULL);
		return (0);
	}
	if (contents != NULL) {
		if (strlen(contents)
		    != fwrite(contents, 1, strlen(contents), f)) {
			fclose(f);
			failure_start(file, line,
			    "Could not write file %s", path);
			failure_finish(NULL);
			return (0);
		}
	}
	fclose(f);
	return (1);
#else
	int fd;
	assertion_count(file, line);
	fd = open(path, O_CREAT | O_WRONLY, mode >= 0 ? mode : 0644);
	if (fd < 0) {
		failure_start(file, line, "Could not create %s", path);
		failure_finish(NULL);
		return (0);
	}
	if (contents != NULL) {
		if ((ssize_t)strlen(contents)
		    != write(fd, contents, strlen(contents))) {
			close(fd);
			failure_start(file, line, "Could not write to %s", path);
			failure_finish(NULL);
			return (0);
		}
	}
	close(fd);
	return (1);
#endif
}

/* Create a hardlink and report any failures. */
int
assertion_make_hardlink(const char *file, int line,
    const char *newpath, const char *linkto)
{
	int succeeded;

	assertion_count(file, line);
#if defined(_WIN32) && !defined(__CYGWIN__)
	succeeded = my_CreateHardLinkA(newpath, linkto);
#elif HAVE_LINK
	succeeded = !link(linkto, newpath);
#else
	succeeded = 0;
#endif
	if (succeeded)
		return (1);
	failure_start(file, line, "Could not create hardlink");
	logprintf("   New link: %s\n", newpath);
	logprintf("   Old name: %s\n", linkto);
	failure_finish(NULL);
	return(0);
}

/* Create a symlink and report any failures. */
int
assertion_make_symlink(const char *file, int line,
    const char *newpath, const char *linkto)
{
#if defined(_WIN32) && !defined(__CYGWIN__)
	int targetIsDir = 0;  /* TODO: Fix this */
	assertion_count(file, line);
	if (my_CreateSymbolicLinkA(newpath, linkto, targetIsDir))
		return (1);
#elif HAVE_SYMLINK
	assertion_count(file, line);
	if (0 == symlink(linkto, newpath))
		return (1);
#endif
	failure_start(file, line, "Could not create symlink");
	logprintf("   New link: %s\n", newpath);
	logprintf("   Old name: %s\n", linkto);
	failure_finish(NULL);
	return(0);
}

/* Set umask, report failures. */
int
assertion_umask(const char *file, int line, int mask)
{
	assertion_count(file, line);
	(void)file; /* UNUSED */
	(void)line; /* UNUSED */
	umask(mask);
	return (1);
}

/*
 *
 *  UTILITIES for use by tests.
 *
 */

/*
 * Check whether platform supports symlinks.  This is intended
 * for tests to use in deciding whether to bother testing symlink
 * support; if the platform doesn't support symlinks, there's no point
 * in checking whether the program being tested can create them.
 *
 * Note that the first time this test is called, we actually go out to
 * disk to create and verify a symlink.  This is necessary because
 * symlink support is actually a property of a particular filesystem
 * and can thus vary between directories on a single system.  After
 * the first call, this returns the cached result from memory, so it's
 * safe to call it as often as you wish.
 */
int
canSymlink(void)
{
	/* Remember the test result */
	static int value = 0, tested = 0;
	if (tested)
		return (value);

	++tested;
	assertion_make_file(__FILE__, __LINE__, "canSymlink.0", 0644, "a");
	/* Note: Cygwin has its own symlink() emulation that does not
	 * use the Win32 CreateSymbolicLink() function. */
#if defined(_WIN32) && !defined(__CYGWIN__)
	value = my_CreateSymbolicLinkA("canSymlink.1", "canSymlink.0", 0)
	    && is_symlink(__FILE__, __LINE__, "canSymlink.1", "canSymlink.0");
#elif HAVE_SYMLINK
	value = (0 == symlink("canSymlink.0", "canSymlink.1"))
	    && is_symlink(__FILE__, __LINE__, "canSymlink.1","canSymlink.0");
#endif
	return (value);
}

/*
 * Can this platform run the gzip program?
 */
/* Platform-dependent options for hiding the output of a subcommand. */
#if defined(_WIN32) && !defined(__CYGWIN__)
static const char *redirectArgs = ">NUL 2>NUL"; /* Win32 cmd.exe */
#else
static const char *redirectArgs = ">/dev/null 2>/dev/null"; /* POSIX 'sh' */
#endif
int
canGzip(void)
{
	static int tested = 0, value = 0;
	if (!tested) {
		tested = 1;
		if (systemf("gzip -V %s", redirectArgs) == 0)
			value = 1;
	}
	return (value);
}

/*
 * Can this platform run the gunzip program?
 */
int
canGunzip(void)
{
	static int tested = 0, value = 0;
	if (!tested) {
		tested = 1;
		if (systemf("gunzip -V %s", redirectArgs) == 0)
			value = 1;
	}
	return (value);
}

/*
 * Sleep as needed; useful for verifying disk timestamp changes by
 * ensuring that the wall-clock time has actually changed before we
 * go back to re-read something from disk.
 */
void
sleepUntilAfter(time_t t)
{
	while (t >= time(NULL))
#if defined(_WIN32) && !defined(__CYGWIN__)
		Sleep(500);
#else
		sleep(1);
#endif
}

/*
 * Call standard system() call, but build up the command line using
 * sprintf() conventions.
 */
int
systemf(const char *fmt, ...)
{
	char buff[8192];
	va_list ap;
	int r;

	va_start(ap, fmt);
	vsprintf(buff, fmt, ap);
	if (verbosity > VERBOSITY_FULL)
		logprintf("Cmd: %s\n", buff);
	r = system(buff);
	va_end(ap);
	return (r);
}

/*
 * Slurp a file into memory for ease of comparison and testing.
 * Returns size of file in 'sizep' if non-NULL, null-terminates
 * data in memory for ease of use.
 */
char *
slurpfile(size_t * sizep, const char *fmt, ...)
{
	char filename[8192];
	struct stat st;
	va_list ap;
	char *p;
	ssize_t bytes_read;
	FILE *f;
	int r;

	va_start(ap, fmt);
	vsprintf(filename, fmt, ap);
	va_end(ap);

	f = fopen(filename, "rb");
	if (f == NULL) {
		/* Note: No error; non-existent file is okay here. */
		return (NULL);
	}
	r = fstat(fileno(f), &st);
	if (r != 0) {
		logprintf("Can't stat file %s\n", filename);
		fclose(f);
		return (NULL);
	}
	p = malloc((size_t)st.st_size + 1);
	if (p == NULL) {
		logprintf("Can't allocate %ld bytes of memory to read file %s\n",
		    (long int)st.st_size, filename);
		fclose(f);
		return (NULL);
	}
	bytes_read = fread(p, 1, (size_t)st.st_size, f);
	if (bytes_read < st.st_size) {
		logprintf("Can't read file %s\n", filename);
		fclose(f);
		free(p);
		return (NULL);
	}
	p[st.st_size] = '\0';
	if (sizep != NULL)
		*sizep = (size_t)st.st_size;
	fclose(f);
	return (p);
}

/* Read a uuencoded file from the reference directory, decode, and
 * write the result into the current directory. */
#define	UUDECODE(c) (((c) - 0x20) & 0x3f)
void
extract_reference_file(const char *name)
{
	char buff[1024];
	FILE *in, *out;

	sprintf(buff, "%s/%s.uu", refdir, name);
	in = fopen(buff, "r");
	failure("Couldn't open reference file %s", buff);
	assert(in != NULL);
	if (in == NULL)
		return;
	/* Read up to and including the 'begin' line. */
	for (;;) {
		if (fgets(buff, sizeof(buff), in) == NULL) {
			/* TODO: This is a failure. */
			return;
		}
		if (memcmp(buff, "begin ", 6) == 0)
			break;
	}
	/* Now, decode the rest and write it. */
	/* Not a lot of error checking here; the input better be right. */
	out = fopen(name, "wb");
	while (fgets(buff, sizeof(buff), in) != NULL) {
		char *p = buff;
		int bytes;

		if (memcmp(buff, "end", 3) == 0)
			break;

		bytes = UUDECODE(*p++);
		while (bytes > 0) {
			int n = 0;
			/* Write out 1-3 bytes from that. */
			if (bytes > 0) {
				n = UUDECODE(*p++) << 18;
				n |= UUDECODE(*p++) << 12;
				fputc(n >> 16, out);
				--bytes;
			}
			if (bytes > 0) {
				n |= UUDECODE(*p++) << 6;
				fputc((n >> 8) & 0xFF, out);
				--bytes;
			}
			if (bytes > 0) {
				n |= UUDECODE(*p++);
				fputc(n & 0xFF, out);
				--bytes;
			}
		}
	}
	fclose(out);
	fclose(in);
}

/*
 *
 * TEST management
 *
 */

/*
 * "list.h" is simply created by "grep DEFINE_TEST test_*.c"; it has
 * a line like
 *      DEFINE_TEST(test_function)
 * for each test.
 */

/* Use "list.h" to declare all of the test functions. */
#undef DEFINE_TEST
#define	DEFINE_TEST(name) void name(void);
#include "list.h"

/* Use "list.h" to create a list of all tests (functions and names). */
#undef DEFINE_TEST
#define	DEFINE_TEST(n) { n, #n, 0 },
struct { void (*func)(void); const char *name; int failures; } tests[] = {
	#include "list.h"
};

/*
 * Summarize repeated failures in the just-completed test.
 */
static void
test_summarize(const char *filename, int failed)
{
	unsigned int i;

	switch (verbosity) {
	case VERBOSITY_SUMMARY_ONLY:
		printf(failed ? "E" : ".");
		fflush(stdout);
		break;
	case VERBOSITY_PASSFAIL:
		printf(failed ? "FAIL\n" : "ok\n");
		break;
	}

	log_console = (verbosity == VERBOSITY_LIGHT_REPORT);

	for (i = 0; i < sizeof(failed_lines)/sizeof(failed_lines[0]); i++) {
		if (failed_lines[i].count > 1 && !failed_lines[i].skip)
			logprintf("%s:%d: Summary: Failed %d times\n",
			    filename, i, failed_lines[i].count);
	}
	/* Clear the failure history for the next file. */
	memset(failed_lines, 0, sizeof(failed_lines));
}

/*
 * Actually run a single test, with appropriate setup and cleanup.
 */
static int
test_run(int i, const char *tmpdir)
{
	char logfilename[64];
	int failures_before = failures;
	int oldumask;

	switch (verbosity) {
	case VERBOSITY_SUMMARY_ONLY: /* No per-test reports at all */
		break;
	case VERBOSITY_PASSFAIL: /* rest of line will include ok/FAIL marker */
		printf("%3d: %-50s", i, tests[i].name);
		fflush(stdout);
		break;
	default: /* Title of test, details will follow */
		printf("%3d: %s\n", i, tests[i].name);
	}

	/* Chdir to the top-level work directory. */
	if (!assertChdir(tmpdir)) {
		fprintf(stderr,
		    "ERROR: Can't chdir to top work dir %s\n", tmpdir);
		exit(1);
	}
	/* Create a log file for this test. */
	sprintf(logfilename, "%s.log", tests[i].name);
	logfile = fopen(logfilename, "w");
	fprintf(logfile, "%s\n\n", tests[i].name);
	/* Chdir() to a work dir for this specific test. */
	if (!assertMakeDir(tests[i].name, 0755)
	    || !assertChdir(tests[i].name)) {
		fprintf(stderr,
		    "ERROR: Can't chdir to work dir %s/%s\n",
		    tmpdir, tests[i].name);
		exit(1);
	}
	/* Explicitly reset the locale before each test. */
	setlocale(LC_ALL, "C");
	/* Record the umask before we run the test. */
	umask(oldumask = umask(0));
	/*
	 * Run the actual test.
	 */
	(*tests[i].func)();
	/*
	 * Clean up and report afterwards.
	 */
	/* Restore umask */
	umask(oldumask);
	/* Reset locale. */
	setlocale(LC_ALL, "C");
	/* Reset directory. */
	if (!assertChdir(tmpdir)) {
		fprintf(stderr, "ERROR: Couldn't chdir to temp dir %s\n",
		    tmpdir);
		exit(1);
	}
	/* Report per-test summaries. */
	tests[i].failures = failures - failures_before;
	test_summarize(test_filename, tests[i].failures);
	/* Close the per-test log file. */
	fclose(logfile);
	logfile = NULL;
	/* If there were no failures, we can remove the work dir and logfile. */
	if (tests[i].failures == 0) {
		if (!keep_temp_files && assertChdir(tmpdir)) {
#if defined(_WIN32) && !defined(__CYGWIN__)
			/* Make sure not to leave empty directories.
			 * Sometimes a processing of closing files used by tests
			 * is not done, then rmdir will be failed and it will
			 * leave a empty test directory. So we should wait a few
			 * seconds and retry rmdir. */
			int r, t;
			for (t = 0; t < 10; t++) {
				if (t > 0)
					Sleep(1000);
				r = systemf("rmdir /S /Q %s", tests[i].name);
				if (r == 0)
					break;
			}
			systemf("del %s", logfilename);
#else
			systemf("rm -rf %s", tests[i].name);
			systemf("rm %s", logfilename);
#endif
		}
	}
	/* Return appropriate status. */
	return (tests[i].failures);
}

/*
 *
 *
 * MAIN and support routines.
 *
 *
 */

static void
usage(const char *program)
{
	static const int limit = sizeof(tests) / sizeof(tests[0]);
	int i;

	printf("Usage: %s [options] <test> <test> ...\n", program);
	printf("Default is to run all tests.\n");
	printf("Otherwise, specify the numbers of the tests you wish to run.\n");
	printf("Options:\n");
	printf("  -d  Dump core after any failure, for debugging.\n");
	printf("  -k  Keep all temp files.\n");
	printf("      Default: temp files for successful tests deleted.\n");
#ifdef PROGRAM
	printf("  -p <path>  Path to executable to be tested.\n");
	printf("      Default: path taken from " ENVBASE " environment variable.\n");
#endif
	printf("  -q  Quiet.\n");
	printf("  -r <dir>   Path to dir containing reference files.\n");
	printf("      Default: Current directory.\n");
	printf("  -v  Verbose.\n");
	printf("Available tests:\n");
	for (i = 0; i < limit; i++)
		printf("  %d: %s\n", i, tests[i].name);
	exit(1);
}

static char *
get_refdir(const char *d)
{
	char tried[512] = { '\0' };
	char buff[128];
	char *pwd, *p;

	/* If a dir was specified, try that */
	if (d != NULL) {
		pwd = NULL;
		snprintf(buff, sizeof(buff), "%s", d);
		p = slurpfile(NULL, "%s/%s", buff, KNOWNREF);
		if (p != NULL) goto success;
		strncat(tried, buff, sizeof(tried) - strlen(tried) - 1);
		strncat(tried, "\n", sizeof(tried) - strlen(tried) - 1);
		goto failure;
	}

	/* Get the current dir. */
	pwd = getcwd(NULL, 0);
	while (pwd[strlen(pwd) - 1] == '\n')
		pwd[strlen(pwd) - 1] = '\0';

	/* Look for a known file. */
	snprintf(buff, sizeof(buff), "%s", pwd);
	p = slurpfile(NULL, "%s/%s", buff, KNOWNREF);
	if (p != NULL) goto success;
	strncat(tried, buff, sizeof(tried) - strlen(tried) - 1);
	strncat(tried, "\n", sizeof(tried) - strlen(tried) - 1);

	snprintf(buff, sizeof(buff), "%s/test", pwd);
	p = slurpfile(NULL, "%s/%s", buff, KNOWNREF);
	if (p != NULL) goto success;
	strncat(tried, buff, sizeof(tried) - strlen(tried) - 1);
	strncat(tried, "\n", sizeof(tried) - strlen(tried) - 1);

#if defined(LIBRARY)
	snprintf(buff, sizeof(buff), "%s/%s/test", pwd, LIBRARY);
#else
	snprintf(buff, sizeof(buff), "%s/%s/test", pwd, PROGRAM);
#endif
	p = slurpfile(NULL, "%s/%s", buff, KNOWNREF);
	if (p != NULL) goto success;
	strncat(tried, buff, sizeof(tried) - strlen(tried) - 1);
	strncat(tried, "\n", sizeof(tried) - strlen(tried) - 1);

	if (memcmp(pwd, "/usr/obj", 8) == 0) {
		snprintf(buff, sizeof(buff), "%s", pwd + 8);
		p = slurpfile(NULL, "%s/%s", buff, KNOWNREF);
		if (p != NULL) goto success;
		strncat(tried, buff, sizeof(tried) - strlen(tried) - 1);
		strncat(tried, "\n", sizeof(tried) - strlen(tried) - 1);

		snprintf(buff, sizeof(buff), "%s/test", pwd + 8);
		p = slurpfile(NULL, "%s/%s", buff, KNOWNREF);
		if (p != NULL) goto success;
		strncat(tried, buff, sizeof(tried) - strlen(tried) - 1);
		strncat(tried, "\n", sizeof(tried) - strlen(tried) - 1);
	}

failure:
	printf("Unable to locate known reference file %s\n", KNOWNREF);
	printf("  Checked following directories:\n%s\n", tried);
#if defined(_WIN32) && !defined(__CYGWIN__) && defined(_DEBUG)
	DebugBreak();
#endif
	exit(1);

success:
	free(p);
	free(pwd);
	return strdup(buff);
}

int
main(int argc, char **argv)
{
	static const int limit = sizeof(tests) / sizeof(tests[0]);
	int i, tests_run = 0, tests_failed = 0, option;
	time_t now;
	char *refdir_alloc = NULL;
	const char *progname;
	const char *tmp, *option_arg, *p;
	char tmpdir[256];
	char tmpdir_timestamp[256];

	(void)argc; /* UNUSED */

#if defined(HAVE__CrtSetReportMode)
	/* To stop to run the default invalid parameter handler. */
	_set_invalid_parameter_handler(invalid_parameter_handler);
	/* Disable annoying assertion message box. */
	_CrtSetReportMode(_CRT_ASSERT, 0);
#endif

	/*
	 * Name of this program, used to build root of our temp directory
	 * tree.
	 */
	progname = p = argv[0];
	while (*p != '\0') {
		/* Support \ or / dir separators for Windows compat. */
		if (*p == '/' || *p == '\\')
			progname = p + 1;
		++p;
	}

#ifdef PROGRAM
	/* Get the target program from environment, if available. */
	testprogfile = getenv(ENVBASE);
#endif

	if (getenv("TMPDIR") != NULL)
		tmp = getenv("TMPDIR");
	else if (getenv("TMP") != NULL)
		tmp = getenv("TMP");
	else if (getenv("TEMP") != NULL)
		tmp = getenv("TEMP");
	else if (getenv("TEMPDIR") != NULL)
		tmp = getenv("TEMPDIR");
	else
		tmp = "/tmp";

	/* Allow -d to be controlled through the environment. */
	if (getenv(ENVBASE "_DEBUG") != NULL)
		dump_on_failure = 1;

	/* Get the directory holding test files from environment. */
	refdir = getenv(ENVBASE "_TEST_FILES");

	/*
	 * Parse options, without using getopt(), which isn't available
	 * on all platforms.
	 */
	++argv; /* Skip program name */
	while (*argv != NULL) {
		if (**argv != '-')
			break;
		p = *argv++;
		++p; /* Skip '-' */
		while (*p != '\0') {
			option = *p++;
			option_arg = NULL;
			/* If 'opt' takes an argument, parse that. */
			if (option == 'p' || option == 'r') {
				if (*p != '\0')
					option_arg = p;
				else if (*argv == NULL) {
					fprintf(stderr,
					    "Option -%c requires argument.\n",
					    option);
					usage(progname);
				} else
					option_arg = *argv++;
				p = ""; /* End of this option word. */
			}

			/* Now, handle the option. */
			switch (option) {
			case 'd':
				dump_on_failure = 1;
				break;
			case 'k':
				keep_temp_files = 1;
				break;
			case 'p':
#ifdef PROGRAM
				testprogfile = option_arg;
#else
				usage(progname);
#endif
				break;
			case 'q':
				verbosity--;
				break;
			case 'r':
				refdir = option_arg;
				break;
			case 'v':
				verbosity++;
				break;
			default:
				usage(progname);
			}
		}
	}

	/*
	 * Sanity-check that our options make sense.
	 */
#ifdef PROGRAM
	if (testprogfile == NULL)
		usage(progname);
	{
		char *testprg;
#if defined(_WIN32) && !defined(__CYGWIN__)
		/* Command.com sometimes rejects '/' separators. */
		testprg = strdup(testprogfile);
		for (i = 0; testprg[i] != '\0'; i++) {
			if (testprg[i] == '/')
				testprg[i] = '\\';
		}
		testprogfile = testprg;
#endif
		/* Quote the name that gets put into shell command lines. */
		testprg = malloc(strlen(testprogfile) + 3);
		strcpy(testprg, "\"");
		strcat(testprg, testprogfile);
		strcat(testprg, "\"");
		testprog = testprg;
	}
#endif

	/*
	 * Create a temp directory for the following tests.
	 * Include the time the tests started as part of the name,
	 * to make it easier to track the results of multiple tests.
	 */
	now = time(NULL);
	for (i = 0; ; i++) {
		strftime(tmpdir_timestamp, sizeof(tmpdir_timestamp),
		    "%Y-%m-%dT%H.%M.%S",
		    localtime(&now));
		sprintf(tmpdir, "%s/%s.%s-%03d", tmp, progname,
		    tmpdir_timestamp, i);
		if (assertMakeDir(tmpdir,0755))
			break;
		if (i >= 999) {
			fprintf(stderr,
			    "ERROR: Unable to create temp directory %s\n",
			    tmpdir);
			exit(1);
		}
	}

	/*
	 * If the user didn't specify a directory for locating
	 * reference files, try to find the reference files in
	 * the "usual places."
	 */
	refdir = refdir_alloc = get_refdir(refdir);

	/*
	 * Banner with basic information.
	 */
	printf("\n");
	printf("If tests fail or crash, details will be in:\n");
	printf("   %s\n", tmpdir);
	printf("\n");
	if (verbosity > VERBOSITY_SUMMARY_ONLY) {
		printf("Reference files will be read from: %s\n", refdir);
#ifdef PROGRAM
		printf("Running tests on: %s\n", testprog);
#endif
		printf("Exercising: ");
		fflush(stdout);
		printf("%s\n", EXTRA_VERSION);
	} else {
		printf("Running ");
		fflush(stdout);
	}

	/*
	 * Run some or all of the individual tests.
	 */
	if (*argv == NULL) {
		/* Default: Run all tests. */
		for (i = 0; i < limit; i++) {
			if (test_run(i, tmpdir))
				tests_failed++;
			tests_run++;
		}
	} else {
		while (*(argv) != NULL) {
			if (**argv >= '0' && **argv <= '9') {
				i = atoi(*argv);
				if (i < 0 || i >= limit) {
					printf("*** INVALID Test %s\n", *argv);
					free(refdir_alloc);
					usage(progname);
					/* usage() never returns */
				}
			} else {
				for (i = 0; i < limit; ++i) {
					if (strcmp(*argv, tests[i].name) == 0)
						break;
				}
				if (i >= limit) {
					printf("*** INVALID Test ``%s''\n",
					       *argv);
					free(refdir_alloc);
					usage(progname);
					/* usage() never returns */
				}
			}
			if (test_run(i, tmpdir))
				tests_failed++;
			tests_run++;
			argv++;
		}
	}

	/*
	 * Report summary statistics.
	 */
	if (verbosity > VERBOSITY_SUMMARY_ONLY) {
		printf("\n");
		printf("Totals:\n");
		printf("  Tests run:         %8d\n", tests_run);
		printf("  Tests failed:      %8d\n", tests_failed);
		printf("  Assertions checked:%8d\n", assertions);
		printf("  Assertions failed: %8d\n", failures);
		printf("  Skips reported:    %8d\n", skips);
	}
	if (failures) {
		printf("\n");
		printf("Failing tests:\n");
		for (i = 0; i < limit; ++i) {
			if (tests[i].failures)
				printf("  %d: %s (%d failures)\n", i,
				    tests[i].name, tests[i].failures);
		}
		printf("\n");
		printf("Details for failing tests: %s\n", tmpdir);
		printf("\n");
	} else {
		if (verbosity == VERBOSITY_SUMMARY_ONLY)
			printf("\n");
		printf("%d tests passed, no failures\n", tests_run);
	}

	free(refdir_alloc);

	/* If the final tmpdir is empty, we can remove it. */
	/* This should be the usual case when all tests succeed. */
	assertChdir("..");
	rmdir(tmpdir);

	return (tests_failed ? 1 : 0);
}



/* ============================================================================
 * SOURCE 21/98: minix4\libos\lib_legacy\i386\boot\bsd\main.c
 * Size: 14,191 bytes, Lines: 441
 * Hash: f661cfc8f7bf...
 * ============================================================================ */

/* 
 * Copyright (c) 1995 The University of Utah and
 * the Computer Systems Laboratory at the University of Utah (CSL).
 * All rights reserved.
 *
 * Permission to use, copy, modify and distribute this software is hereby
 * granted provided that (1) source code retains these copyright, permission,
 * and disclaimer notices, and (2) redistributions including binaries
 * reproduce the notices in supporting documentation, and (3) all advertising
 * materials mentioning features or use of this software display the following
 * acknowledgement: ``This product includes software developed by the
 * Computer Systems Laboratory at the University of Utah.''
 *
 * THE UNIVERSITY OF UTAH AND CSL ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS
 * IS" CONDITION.  THE UNIVERSITY OF UTAH AND CSL DISCLAIM ANY LIABILITY OF
 * ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * CSL requests users of this software to return to csl-dist@cs.utah.edu any
 * improvements that they make and grant CSL redistribution rights.
 *
 *      Author: Bryan Ford, University of Utah CSL
 */

#include <mach/exec/exec.h>
#include <mach/exec/a.out.h>
#include <mach/machine/multiboot.h>
#include <mach/machine/proc_reg.h>
#include <sys/reboot.h>
#include <stdlib.h>

#include "vm_param.h"
#include "phys_mem.h"
#include "cpu.h"
#include "pic.h"
#include "real.h"
#include "debug.h"
#include "boottype.h"
#include "boot.h"


/* Keeps track of the highest physical memory address we know about.
   Initialized by phys_mem_add().  */
vm_offset_t phys_mem_max;
/* PC memory values (in K) from BIOS */
vm_offset_t phys_mem_lower;
vm_offset_t phys_mem_upper;

/* Always zero - virtual addresses are physical addresses.  */
vm_offset_t phys_mem_va;

int irq_master_base = PICM_VECTBASE;
int irq_slave_base = PICS_VECTBASE;

struct multiboot_info *boot_info;
static struct multiboot_module *boot_mods;

struct multiboot_header boot_kern_hdr;
void *boot_kern_image;
struct exec_info boot_kern_info;

extern int boottype;
extern unsigned long boothowto, bootdev;

extern struct lmod
{
	void *start;
	void *end;
	char *string;
} boot_modules[];

/* Find the extended memory available and add it to malloc's free list.  */
static void grab_ext_mem(void)
{
	extern char _end[];

	struct real_call_data rcd;
	vm_offset_t free_bot, free_top;

	/* Find the top of lower memory (up to 640K).  */
	rcd.flags = 0;
	real_int(0x12, &rcd);
	phys_mem_lower = (rcd.eax & 0xFFFF);

	/* Find the top of extended memory (up to 64MB).  */
	rcd.eax = 0x8800;
	rcd.flags = 0;
	real_int(0x15, &rcd);
	phys_mem_upper = (rcd.eax & 0xFFFF);
	free_top = 0x100000 + (phys_mem_upper * 1024);

	/* Add the available memory to the free list.  */
	free_bot = (vm_offset_t)kvtophys(_end);
	assert(free_bot > 0x100000); assert(free_bot < free_top);
	phys_mem_add(free_bot, free_top - free_bot);

	printf("using extended memory %08x-%08x\n", free_bot, free_top);
}

/* Unlike the Linux boot mechanism, the older Mach and BSD systems
   do not have any notion of a general command line,
   only a fixed, kludgy (and diverging) set of flags and values.
   Here we make a best-effort attempt
   to piece together a sane Linux-style command line
   from the boothowto and bootdev values provided by the boot loader.
   Naturally, the interpretation changes depending on who loaded us;
   that's what the boottype is for (see crt0.S).  */
static void init_cmdline(void)
{
	static char buf[30];
	char *major;

	/* First handle the option flags.
	   Just supply the flags as they would appear on the command line
	   of the Mach or BSD reboot command line,
	   and let the kernel handle or ignore them as appropriate.  */
	if (boothowto & RB_ASKNAME)
		strcat(buf, "-a ");
	if (boothowto & RB_SINGLE)
		strcat(buf, "-s ");
	if (boothowto & RB_DFLTROOT)
		strcat(buf, "-r ");
	if (boothowto & RB_HALT)
		strcat(buf, "-b ");
	if (boottype == BOOTTYPE_MACH)
	{
		/* These were determined from what the command-line parser does
		   in boot.c in the original Mach boot loader.  */
		if (boothowto & RB_KDB)
			strcat(buf, "-d ");
	}
	else
	{
		/* These were determined from what the command-line parser does
		   in boot.c in the FreeBSD 2.0 boot loader.  */
		if (boothowto & BSD_RB_KDB)
			strcat(buf, "-d ");
		if (boothowto & BSD_RB_CONFIG)
			strcat(buf, "-c ");
	}

	/* Now indicate the root device with a "root=" option.  */
	major = 0;
	if (boottype == BOOTTYPE_MACH)
	{
		static char *devs[] = {"hd", "fd", "wt", "sd", "ha"};
		if (B_TYPE(bootdev) < sizeof(devs)/sizeof(devs[0]))
			major = devs[B_TYPE(bootdev)];
	}
	else
	{
		static char *devs[] = {"wd", "hd", "fd", "wt", "sd"};
		if (B_TYPE(bootdev) < sizeof(devs)/sizeof(devs[0]))
			major = devs[B_TYPE(bootdev)];
	}
	if (major)
	{
		sprintf(buf + strlen(buf), "root=%s%d%c",
			major, B_UNIT(bootdev), 'a' + B_PARTITION(bootdev));
	}

	/* Insert the command line into the boot_info structure.  */
	boot_info->cmdline = (vm_offset_t)kvtophys(buf);
	boot_info->flags |= MULTIBOOT_CMDLINE;
}

static void init_symtab(struct multiboot_header *h)
{
	if (h->flags & MULTIBOOT_AOUT_KLUDGE)
	{
		struct exec *hdr;

		/* This file is probably (but not necessarily) in a.out format.
		   Check for an a.out symbol/string table.
		   If we can't find one, or if the a.out header appears bogus,
		   then continue but just don't supply a symbol table.  */
		hdr = (struct exec*)boot_modules[0].start;
		if (!N_BADMAG(*hdr) && (hdr->a_syms > 0))
		{
			void *in_symtab, *in_strtab, *symtab;

			/* Calculate the address of the symbol table.
			   Don't try to use the information in the header
			   to find the beginning of the text segment;
			   its interpretation varies widely.
			   Instead, use the boot_kern_image pointer
			   we calculated from tho MULTIBOOT_AOUT_KLUDGE data,
			   which should consistently tell us
			   where the beginning of the text segment is.  */
			in_symtab = boot_kern_image
				    + hdr->a_text
				    + hdr->a_data
				    + hdr->a_trsize
				    + hdr->a_drsize;
			in_strtab = in_symtab
				    + hdr->a_syms;

			/* Note that tabsize doesn't include the size word,
			   but strsize does.  */
			boot_info->syms.a.tabsize = hdr->a_syms;
			boot_info->syms.a.strsize = *(vm_size_t *)(in_strtab);

			printf("bsdboot: Symbols found, tab = %#x str = %#x.\n",
			       boot_info->syms.a.tabsize,
			       boot_info->syms.a.strsize);

			/* Allocate a new buffer for the symbol table
			   in non-conflicting memory.  */
			symtab = mustmalloc(sizeof(vm_size_t)
					    + boot_info->syms.a.tabsize
					    + boot_info->syms.a.strsize);
			*((vm_size_t *)symtab) = boot_info->syms.a.tabsize;
			memcpy(symtab + sizeof(vm_size_t), in_symtab,
			       boot_info->syms.a.tabsize
			       + boot_info->syms.a.strsize);

			/* Register the symbol table in the boot_info.  */
			boot_info->flags |= MULTIBOOT_AOUT_SYMS;
			boot_info->syms.a.addr = (vm_offset_t)kvtophys(symtab);
		}
	}
	else
	{
		/* XXX get symbol/string table from exec_load().  */
	}
}

static
int kimg_read(void *handle, vm_offset_t file_ofs, void *buf, vm_size_t size, vm_size_t *out_actual)
{
	/* XXX limit length */
	memcpy(buf, boot_modules[0].start + file_ofs, size);
	*out_actual = size;
	return 0;
}

static
int kimg_read_exec_1(void *handle, vm_offset_t file_ofs, vm_size_t file_size,
		     vm_offset_t mem_addr, vm_size_t mem_size,
		     exec_sectype_t section_type)
{
	if (!(section_type & EXEC_SECTYPE_ALLOC))
		return 0;

	assert(mem_size > 0);
	if (mem_addr < boot_kern_hdr.load_addr)
		boot_kern_hdr.load_addr = mem_addr;
	if (mem_addr+file_size > boot_kern_hdr.load_end_addr)
		boot_kern_hdr.load_end_addr = mem_addr+file_size;
	if (mem_addr+mem_size > boot_kern_hdr.bss_end_addr)
		boot_kern_hdr.bss_end_addr = mem_addr+mem_size;

	return 0;
}

static
int kimg_read_exec_2(void *handle, vm_offset_t file_ofs, vm_size_t file_size,
		     vm_offset_t mem_addr, vm_size_t mem_size,
		     exec_sectype_t section_type)
{
	if (!(section_type & EXEC_SECTYPE_ALLOC))
		return 0;

	assert(mem_size > 0);
	assert(mem_addr >= boot_kern_hdr.load_addr);
	assert(mem_addr+file_size <= boot_kern_hdr.load_end_addr);
	assert(mem_addr+mem_size <= boot_kern_hdr.bss_end_addr);

	memcpy(boot_kern_image + mem_addr - boot_kern_hdr.load_addr,
		boot_modules[0].start + file_ofs, file_size);

	return 0;
}

void raw_start(void)
{
	struct multiboot_header *h;
	int i, err;


	cpu_tables_init(&cpu[0]);
	cpu_tables_load(&cpu[0]);
	pic_init(PICM_VECTBASE, PICS_VECTBASE);
	idt_irq_init();

	/* Get some memory to work in.  */
	grab_ext_mem();

	if (boot_modules[0].start == 0)
		die("This boot image contains no boot modules!?!?");

	/* Scan for the multiboot_header.  */
	for (i = 0; ; i += 4)
	{
		if (i >= MULTIBOOT_SEARCH)
			die("kernel image has no multiboot_header");
		h = (struct multiboot_header*)(boot_modules[0].start+i);
		if (h->magic == MULTIBOOT_MAGIC
		    && !(h->magic + h->flags + h->checksum))
			break;
	}
	if (h->flags & MULTIBOOT_MUSTKNOW & ~MULTIBOOT_MEMORY_INFO)
		die("unknown multiboot_header flag bits %08x",
			h->flags & MULTIBOOT_MUSTKNOW & ~MULTIBOOT_MEMORY_INFO);
	boot_kern_hdr = *h;

	if (h->flags & MULTIBOOT_AOUT_KLUDGE)
	{
		boot_kern_image = (void*)h + h->load_addr - h->header_addr;
	}
	else
	{
		/* No a.out-kludge information available;
		   attempt to interpret the exec header instead,
		   using the simple interpreter in libmach_exec.a.  */

		/* Perform the "load" in two passes.
		   In the first pass, find the number of sections the load image contains
		   and reserve the physical memory containing each section.
		   Also, initialize the boot_kern_hdr to reflect the extent of the image.
		   In the second pass, load the sections into a temporary area
		   that can be copied to the final location all at once by do_boot.S.  */

		boot_kern_hdr.load_addr = 0xffffffff;
		boot_kern_hdr.load_end_addr = 0;
		boot_kern_hdr.bss_end_addr = 0;

		if (err = exec_load(kimg_read, kimg_read_exec_1, 0,
				    &boot_kern_info))
			panic("cannot load kernel image: error code %d", err);
		boot_kern_hdr.entry = boot_kern_info.entry;

		/* It's OK to malloc this before reserving the memory the kernel will occupy,
		   because do_boot.S can deal with overlapping source and destination.  */
		assert(boot_kern_hdr.load_addr < boot_kern_hdr.load_end_addr);
		assert(boot_kern_hdr.load_end_addr < boot_kern_hdr.bss_end_addr);
		boot_kern_image = malloc(boot_kern_hdr.load_end_addr - boot_kern_hdr.load_addr);

		if (err = exec_load(kimg_read, kimg_read_exec_2, 0,
				    &boot_kern_info))
			panic("cannot load kernel image: error code %d", err);
		assert(boot_kern_hdr.entry == boot_kern_info.entry);
	}

	/* Reserve the memory that the kernel will eventually occupy.
	   All malloc calls after this are guaranteed to stay out of this region.  */
	malloc_reserve(phystokv(boot_kern_hdr.load_addr), phystokv(boot_kern_hdr.bss_end_addr));

	printf("kernel at %08x-%08x text+data %d bss %d\n",
		boot_kern_hdr.load_addr, boot_kern_hdr.bss_end_addr,
		boot_kern_hdr.load_end_addr - boot_kern_hdr.load_addr,
		boot_kern_hdr.bss_end_addr - boot_kern_hdr.load_end_addr);
	assert(boot_kern_hdr.load_addr < boot_kern_hdr.load_end_addr);
	assert(boot_kern_hdr.load_end_addr < boot_kern_hdr.bss_end_addr);
	if (boot_kern_hdr.load_addr < 0x1000)
		panic("kernel wants to be loaded too low!");
#if 0
	if (boot_kern_hdr.bss_end_addr > phys_mem_max)
		panic("kernel wants to be loaded beyond available physical memory!");
#endif
	if ((boot_kern_hdr.load_addr < 0x100000)
	    && (boot_kern_hdr.bss_end_addr > 0xa0000))
		panic("kernel wants to be loaded on top of I/O space!");

	boot_info = (struct multiboot_info*)mustcalloc(sizeof(*boot_info));

	/* Build a command line to pass to the kernel.  */
	init_cmdline();

	/* Add memory information */
	boot_info->flags |= MULTIBOOT_MEMORY;
	boot_info->mem_upper = phys_mem_upper;
	boot_info->mem_lower = phys_mem_lower;

	/* Indicate to the kernel which BIOS disk device we booted from.
	   The Mach and BSD boot loaders obscure this information somewhat;
	   we have to extract it from the mangled bootdev value.
	   We assume that any unit other than floppy means BIOS hard drive.
	   XXX If we boot from FreeBSD's netboot, we shouldn't set this.  */
	boot_info->flags |= MULTIBOOT_BOOT_DEVICE;
	if (boottype == BOOTTYPE_MACH)
		boot_info->boot_device[0] = B_TYPE(bootdev) == 1 ? 0 : 0x80;
	else
		boot_info->boot_device[0] = B_TYPE(bootdev) == 2 ? 0 : 0x80;
	boot_info->boot_device[0] += B_UNIT(bootdev);
	boot_info->boot_device[1] = 0xff;
	boot_info->boot_device[2] = B_PARTITION(bootdev);
	boot_info->boot_device[3] = 0xff;

	/* Find the symbol table to supply to the kernel, if possible.  */
	init_symtab(h);

	/* Initialize the boot module entries in the boot_info.  */
	boot_info->flags |= MULTIBOOT_MODS;
	for (i = 1; boot_modules[i].start; i++);
	boot_info->mods_count = i-1;
	boot_mods = (struct multiboot_module*)mustcalloc(
		boot_info->mods_count * sizeof(*boot_mods));
	boot_info->mods_addr = kvtophys(boot_mods);
	for (i = 0; i < boot_info->mods_count; i++)
	{
		struct lmod *lm = &boot_modules[1+i];
		struct multiboot_module *bm = &boot_mods[i];

		assert(lm->end > lm->start);

		/* Try to leave the boot module where it is and pass its address.  */
		bm->mod_start = kvtophys(lm->start);
		bm->mod_end = kvtophys(lm->end);

		/* However, if the current location of the boot module
		   overlaps with the final location of the kernel image,
		   we have to move the boot module somewhere else.  */
		if ((bm->mod_start < boot_kern_hdr.load_end_addr)
		    && (bm->mod_end > boot_kern_hdr.load_addr))
		{
			vm_size_t size = lm->end - lm->start;
			void *newaddr = mustmalloc(size);

			printf("moving boot module %d from %08x to %08x\n",
				i, kvtophys(lm->start), kvtophys(newaddr));
			memcpy(newaddr, lm->start, size);

			bm->mod_start = kvtophys(newaddr);
			bm->mod_end = bm->mod_start + size;
		}

		/* Also provide the string associated with the module.  */
		printf("lm->string '%s'\n", lm->string);
		{
			char *newstring = mustmalloc(strlen(lm->string)+1);
			strcpy(newstring, lm->string);
			bm->string = kvtophys(newstring);
		}

		bm->reserved = 0;
	}

	boot_start();
}




/* ============================================================================
 * SOURCE 22/98: minix4\exokernel\kernel_legacy\main.c
 * Size: 23,173 bytes, Lines: 666
 * Hash: 82aaa1d5d739...
 * ============================================================================ */

/**
 * @file main.c
 * @brief MINIX kernel main program and system initialization
 *
 * This file contains the core initialization routines for the MINIX kernel.
 * It handles the complete boot process from early system setup to process
 * scheduling, including:
 * - Boot parameter processing and environment variable parsing
 * - Process table initialization for boot image processes
 * - Privilege and security setup for kernel tasks and system processes
 * - Memory management initialization
 * - Interrupt and timer system setup
 * - SMP (Symmetric Multi-Processing) configuration when enabled
 * - System shutdown and halt procedures
 *
 * Key Functions:
 * - kmain(): Primary kernel entry point that orchestrates the boot process
 * - bsp_finish_booting(): Completes boot on the bootstrap processor
 * - cstart(): Early system initialization before main kernel startup
 * - prepare_shutdown()/minix_shutdown(): System shutdown procedures
 * - announce(): Displays the MINIX startup banner
 * - env_get()/get_value(): Environment variable access for boot parameters
 *
 * The initialization process sets up all kernel tasks, system processes,
 * and user processes from the boot image, configures their privileges,
 * and transitions control to the scheduler to begin normal operation.
 *
 * @note This implementation uses kernel-specific string and memory functions
 *       (kstring.h, kmemory.h) instead of standard library functions.
 * @note SMP support is conditionally compiled based on CONFIG_SMP flag.
 * @note The kernel transitions from initialization mode to user mode scheduling
 *       at the end of the boot process.
 */
/* This file contains the main program of MINIX as well as its shutdown code.
 * The routine main() initializes the system and starts the ball rolling by
 * setting up the process table, interrupt vectors, and scheduling each task 
 * to run to initialize itself.
 * The routine shutdown() does the opposite and brings down MINIX. 
 *
 * The entries into this file are:
 *   main:	    	MINIX main program
 *   prepare_shutdown:	prepare to take MINIX down
 */
// #include <string.h> // Replaced by kstring.h
// #include <stdlib.h> // Replaced by katoi placeholder or removed
// #include <assert.h> // Replaced by KASSERT_PLACEHOLDER

// #include <string.h> // Replaced by kstring.h
// #include <stdlib.h> // Replaced by katoi placeholder or removed
// #include <assert.h> // Replaced by KASSERT_PLACEHOLDER

#include <minix/endpoint.h>
#include <machine/vmparam.h>
#include <minix/u64.h>
#include <minix/board.h>
#include <sys/reboot.h> // Keep for reboot flags like RB_POWERDOWN
#include <sys/reboot.h> // Keep for reboot flags like RB_POWERDOWN
#include "clock.h"
#include "direct_utils.h"
#include "hw_intr.h"
#include "arch_proto.h"

#ifdef CONFIG_SMP
#include "smp.h"
#endif
#ifdef USE_WATCHDOG
#include "watchdog.h"
#endif
#include "spinlock.h"

// Kernel includes added:
#include <klib/include/kstring.h>
#include <klib/include/kmemory.h>
#include <klib/include/kprintf.h>
#include <minix/kernel_types.h>
#include <sys/kassert.h>
#include <minix/profile.h> // For k_prof_init()
#ifdef CONFIG_MDLM
#include <minix/mdlm_cap_dag.h> // For mdlm_cap_dag_init
#endif

// Includes for Capability DAG
#include "../lib/klib/include/klib.h" // For kprintf_stub, kpanic, and kcapability_dag_run_mathematical_tests
#include <minix/kcapability_dag.h> // For kcapability_dag_t and kcapability_dag_create
#include <minix/kcap.h> // For INITIAL_KERNEL_CAPABILITY_CAPACITY and kernel_capability_dag extern


/* dummy for linking */
char *** _penviron;

/* Prototype declarations for PRIVATE functions. */
static void announce(void);

// Definition of the global DAG pointer is NOT here, will be in kcap.c or similar.
// extern struct kcapability_dag* kernel_capability_dag; // Already in kcap.h

/**
 * @brief Initializes the mathematical capability framework.
 *
 * This function is called early during kernel startup to:
 * 1. Run mathematical verification tests for the Capability DAG implementation.
 * 2. Create and initialize the global kernel_capability_dag instance.
 * It panics if either the tests fail (implicitly via KASSERT in tests) or
 * if the global DAG cannot be created.
 */
void kernel_initialize_mathematical_foundation(void) {
    // Use kprintf_stub from klib.h for early kernel messages
    kprintf_stub("Initializing mathematical capability framework...\n");

    /*
     * Run mathematical verification tests to prove that our capability
     * DAG implementation maintains all required mathematical properties
     * in the actual kernel environment.
     * KASSERTs within the tests will panic on failure.
     */
    kcapability_dag_run_mathematical_tests();

    kprintf_stub("Capability DAG mathematical tests passed.\n");

    /*
     * Initialize the global kernel capability DAG that will manage
     * all system-wide capability relationships.
     * Note: kernel_capability_dag is declared extern in kcap.h
     * and will be defined globally in a separate .c file (e.g. kcap.c).
     */
    kernel_capability_dag = kcapability_dag_create(INITIAL_KERNEL_CAPABILITY_CAPACITY);

    if (!kernel_capability_dag) {
        kpanic("Failed to initialize kernel capability DAG - mathematical foundation compromised");
    }

    // Assuming kprintf_stub or a kprintf that can handle _BitInt directly or via casting
    // For safety, let's cast node_capacity for kprintf_stub.
    kprintf_stub("Mathematical capability framework initialized successfully.\n");
    kprintf_stub("Kernel capability DAG created with %u node capacity.\n",
            (unsigned int)kernel_capability_dag->node_capacity);
}


void bsp_finish_booting(void)
{
  int i;
#if SPROFILE
  sprofiling = 0;      /* we're not profiling until instructed to */
#endif /* SPROFILE */

  cpu_identify();

  vm_running = 0;
  krandom.random_sources = RANDOM_SOURCES;
  krandom.random_elements = RANDOM_ELEMENTS;

  /* MINIX is now ready. All boot image processes are on the ready queue.
   * Return to the assembly code to start running the current process. 
   */
  
  /* it should point somewhere */
  get_cpulocal_var(bill_ptr) = get_cpulocal_var_ptr(idle_proc);
  get_cpulocal_var(proc_ptr) = get_cpulocal_var_ptr(idle_proc);
  announce();				/* print MINIX startup banner */

  /*
   * we have access to the cpu local run queue, only now schedule the processes.
   * We ignore the slots for the former kernel tasks
   */
  for (i=0; i < NR_BOOT_PROCS - NR_TASKS; i++) {
	RTS_UNSET(proc_addr(i), RTS_PROC_STOP);
  }
  /*
   * Enable timer interrupts and clock task on the boot CPU.  First reset the
   * CPU accounting values, as the timer initialization (indirectly) uses them.
   */
  cycles_accounting_init();

  if (boot_cpu_init_timer(system_hz)) {
	  panic("FATAL : failed to initialize timer interrupts, "
			  "cannot continue without any clock source!");
  }

  fpu_init();

/* Warnings for sanity checks that take time. These warnings are printed
 * so it's a clear warning no full release should be done with them
 * enabled.
 */
#if DEBUG_SCHED_CHECK
  FIXME("DEBUG_SCHED_CHECK enabled");
#endif
#if DEBUG_VMASSERT
  FIXME("DEBUG_VMASSERT enabled");
#endif
#if DEBUG_PROC_CHECK
  FIXME("PROC check enabled");
#endif

#ifdef CONFIG_SMP
  cpu_set_flag(bsp_cpu_id, CPU_IS_READY);
  machine.processors_count = ncpus;
  machine.bsp_id = bsp_cpu_id;
#else
  machine.processors_count = 1;
  machine.bsp_id = 0;
#endif
  

  /* Kernel may no longer use bits of memory as VM will be running soon */
  kernel_may_alloc = 0;

  switch_to_user();
  NOT_REACHABLE;
}


/*===========================================================================*
 *			kmain 	                             		*
 *===========================================================================*/
void kmain(kinfo_t *local_cbi)
{
/* Start the ball rolling. */
  struct boot_image *ip;	/* boot image pointer */
  register struct proc *rp;	/* process pointer */
  register int i, j;
  static int bss_test;

  /* bss sanity check */
  KASSERT(bss_test == 0);
  KASSERT(bss_test == 0);
  bss_test = 1;

  /* save a global copy of the boot parameters */
  kmemcpy(&kinfo, local_cbi, sizeof(kinfo)); // MODIFIED
  kmemcpy(&kmess, kinfo.kmess, sizeof(kmess)); // MODIFIED
  kmemcpy(&kinfo, local_cbi, sizeof(kinfo)); // MODIFIED
  kmemcpy(&kmess, kinfo.kmess, sizeof(kmess)); // MODIFIED

   /* We have done this exercise in pre_init so we expect this code
      to simply work! */
   machine.board_id = get_board_id_by_name(env_get(BOARDVARNAME));
#ifdef __arm__
  /* We want to initialize serial before we do any output */
  arch_ser_init();
#endif
  /* We can talk now */
  DEBUGBASIC(("MINIX booting\n"));

  /* Kernel may use bits of main memory before VM is started */
  kernel_may_alloc = 1;

  KASSERT(sizeof(kinfo.boot_procs) == sizeof(image));
  kmemcpy(kinfo.boot_procs, image, sizeof(kinfo.boot_procs)); // MODIFIED
  KASSERT(sizeof(kinfo.boot_procs) == sizeof(image));
  kmemcpy(kinfo.boot_procs, image, sizeof(kinfo.boot_procs)); // MODIFIED

  cstart();

  k_prof_init(); // Initialize kernel profiling framework

  // Initialize the chosen Big Kernel Lock implementation
  // (e.g., CLH BKL, if selected over older spinlock BKL)
  // This needs to be done before the first BKL_LOCK() call.
  extern void init_global_clh_bkl(void); // Declaration
  init_global_clh_bkl(); // Call CLH BKL initialization

  BKL_LOCK();

  // Initialize the mathematical capability foundation
  kernel_initialize_mathematical_foundation();
 
   DEBUGEXTRA(("main()\n"));

  /* Clear the process table. Anounce each slot as empty and set up mappings
   * for proc_addr() and proc_nr() macros. Do the same for the table with
   * privilege structures for the system processes and the ipc filter pool.
   */
  proc_init(); // This now calls init_proc_capabilities for each process
  IPCF_POOL_INIT();

#ifdef CONFIG_MDLM
  mdlm_cap_dag_init(); // Initialize MDLM Capability DAG component
#endif

   if(NR_BOOT_MODULES != kinfo.mbi.mi_mods_count)
   	panic("expecting %d boot processes/modules, found %d",
		NR_BOOT_MODULES, kinfo.mbi.mi_mods_count);

  /* Set up proc table entries for processes in boot image. */
  for (i=0; i < NR_BOOT_PROCS; ++i) {
	int schedulable_proc;
	proc_nr_t proc_nr;
	int ipc_to_m, kcalls;
	sys_map_t map;

	ip = &image[i];				/* process' attributes */
	DEBUGEXTRA(("initializing %s... ", ip->proc_name));
	rp = proc_addr(ip->proc_nr);		/* get process pointer */
	ip->endpoint = rp->p_endpoint;		/* ipc endpoint */
	rp->p_cpu_time_left = 0;
	if(i < NR_TASKS)			/* name (tasks only) */
		kstrlcpy(rp->p_name, ip->proc_name, sizeof(rp->p_name)); // MODIFIED
		kstrlcpy(rp->p_name, ip->proc_name, sizeof(rp->p_name)); // MODIFIED

	if(i >= NR_TASKS) {
		/* Remember this so it can be passed to VM */
		multiboot_module_t *mb_mod = &kinfo.module_list[i - NR_TASKS];
		ip->start_addr = mb_mod->mod_start;
		ip->len = mb_mod->mod_end - mb_mod->mod_start;
	}
	
	reset_proc_accounting(rp);

	/* See if this process is immediately schedulable.
	 * In that case, set its privileges now and allow it to run.
	 * Only kernel tasks and the root system process get to run immediately.
	 * All the other system processes are inhibited from running by the
	 * RTS_NO_PRIV flag. They can only be scheduled once the root system
	 * process has set their privileges.
	 */
	proc_nr = proc_nr(rp);
	schedulable_proc = (iskerneln(proc_nr) || isrootsysn(proc_nr) ||
		proc_nr == VM_PROC_NR);
	if(schedulable_proc) {
	    /* Assign privilege structure. Force a static privilege id. */
            (void) get_priv(rp, static_priv_id(proc_nr));

            /* Privileges for kernel tasks. */
	    if(proc_nr == VM_PROC_NR) {
                priv(rp)->s_flags = VM_F;
                priv(rp)->s_trap_mask = SRV_T;
		ipc_to_m = SRV_M;
		kcalls = SRV_KC;
                priv(rp)->s_sig_mgr = SELF;
                rp->p_priority = SRV_Q;
                rp->p_quantum_size_ms = SRV_QT;
	    }
	    else if(iskerneln(proc_nr)) {
                /* Privilege flags. */
                priv(rp)->s_flags = (proc_nr == IDLE ? IDL_F : TSK_F);
                /* Init flags. */
                priv(rp)->s_init_flags = TSK_I;
                /* Allowed traps. */
                priv(rp)->s_trap_mask = (proc_nr == CLOCK 
                    || proc_nr == SYSTEM  ? CSK_T : TSK_T);
                ipc_to_m = TSK_M;                  /* allowed targets */
                kcalls = TSK_KC;                   /* allowed kernel calls */
            }
            /* Privileges for the root system process. */
            else {
		KASSERT(isrootsysn(proc_nr));
		KASSERT(isrootsysn(proc_nr));
                priv(rp)->s_flags= RSYS_F;        /* privilege flags */
                priv(rp)->s_init_flags = SRV_I;   /* init flags */
                priv(rp)->s_trap_mask= SRV_T;     /* allowed traps */
                ipc_to_m = SRV_M;                 /* allowed targets */
                kcalls = SRV_KC;                  /* allowed kernel calls */
                priv(rp)->s_sig_mgr = SRV_SM;     /* signal manager */
                rp->p_priority = SRV_Q;	          /* priority queue */
                rp->p_quantum_size_ms = SRV_QT;   /* quantum size */
            }

            /* Fill in target mask. */
            kmemset(&map, 0, sizeof(map)); // MODIFIED
            kmemset(&map, 0, sizeof(map)); // MODIFIED

            if (ipc_to_m == ALL_M) {
                for(j = 0; j < NR_SYS_PROCS; j++)
                    set_sys_bit(map, j);
            }

            fill_sendto_mask(rp, &map);

            /* Fill in kernel call mask. */
            for(j = 0; j < SYS_CALL_MASK_SIZE; j++) {
                priv(rp)->s_k_call_mask[j] = (kcalls == NO_C ? 0 : (~0));
            }
	}
	else {
	    /* Don't let the process run for now. */
            RTS_SET(rp, RTS_NO_PRIV | RTS_NO_QUANTUM);
	}

	/* Arch-specific state initialization. */
	arch_boot_proc(ip, rp);

	/* scheduling functions depend on proc_ptr pointing somewhere. */
	if(!get_cpulocal_var(proc_ptr))
		get_cpulocal_var(proc_ptr) = rp;

	/* Process isn't scheduled until VM has set up a pagetable for it. */
	if(rp->p_nr != VM_PROC_NR && rp->p_nr >= 0) {
		rp->p_rts_flags |= RTS_VMINHIBIT;
		rp->p_rts_flags |= RTS_BOOTINHIBIT;
	}

	rp->p_rts_flags |= RTS_PROC_STOP;
	rp->p_rts_flags &= ~RTS_SLOT_FREE;
	DEBUGEXTRA(("done\n"));
  }

  /* update boot procs info for VM */
  kmemcpy(kinfo.boot_procs, image, sizeof(kinfo.boot_procs)); // MODIFIED
  kmemcpy(kinfo.boot_procs, image, sizeof(kinfo.boot_procs)); // MODIFIED

#define IPCNAME(n) { \
	KASSERT((n) >= 0 && (n) <= IPCNO_HIGHEST); \
	KASSERT(!ipc_call_names[n]);	\
	KASSERT((n) >= 0 && (n) <= IPCNO_HIGHEST); \
	KASSERT(!ipc_call_names[n]);	\
	ipc_call_names[n] = #n; \
}

  arch_post_init();

  IPCNAME(SEND);
  IPCNAME(RECEIVE);
  IPCNAME(SENDREC);
  IPCNAME(NOTIFY);
  IPCNAME(SENDNB);
  IPCNAME(SENDA);

  /* System and processes initialization */
  memory_init();
  DEBUGEXTRA(("system_init()... "));
  system_init();
  DEBUGEXTRA(("done\n"));

  /* The bootstrap phase is over, so we can add the physical
   * memory used for it to the free list.
   */
  add_memmap(&kinfo, kinfo.bootstrap_start, kinfo.bootstrap_len);

#ifdef CONFIG_SMP
  if (config_no_apic) {
	  DEBUGBASIC(("APIC disabled, disables SMP, using legacy PIC\n"));
	  smp_single_cpu_fallback();
  } else if (config_no_smp) {
	  DEBUGBASIC(("SMP disabled, using legacy PIC\n"));
	  smp_single_cpu_fallback();
  } else {
	  smp_init();
	  /*
	   * if smp_init() returns it means that it failed and we try to finish
	   * single CPU booting
	   */
	  bsp_finish_booting();
  }
#else
  /* 
   * if configured for a single CPU, we are already on the kernel stack which we
   * are going to use everytime we execute kernel code. We finish booting and we
   * never return here
   */
  bsp_finish_booting();
#endif

  NOT_REACHABLE;
}

/*===========================================================================*
 *				announce				     *
 *===========================================================================*/
static void announce(void)
{
  /* Display the MINIX startup banner. */
  kprintf_stub("\nMINIX %s. " // MODIFIED
  kprintf_stub("\nMINIX %s. " // MODIFIED
#ifdef PAE
"(PAE) "
#endif
#ifdef _VCS_REVISION
	"(" _VCS_REVISION ")\n"
#endif
      "Copyright 2016, Vrije Universiteit, Amsterdam, The Netherlands\n",
      OS_RELEASE);
  kprintf_stub("MINIX is open source software, see http://www.minix3.org\n"); // MODIFIED
  kprintf_stub("MINIX is open source software, see http://www.minix3.org\n"); // MODIFIED
}

/*===========================================================================*
 *				prepare_shutdown			     *
 *===========================================================================*/
void prepare_shutdown(const int how)
{
/* This function prepares to shutdown MINIX. */
  static minix_timer_t shutdown_timer;

  /* Continue after 1 second, to give processes a chance to get scheduled to 
   * do shutdown work.  Set a watchog timer to call shutdown(). The timer 
   * argument passes the shutdown status. 
   */
  kprintf_stub("MINIX will now be shut down ...\n"); // MODIFIED
  kprintf_stub("MINIX will now be shut down ...\n"); // MODIFIED
  set_kernel_timer(&shutdown_timer, get_monotonic() + system_hz,
      minix_shutdown, how);
}

/*===========================================================================*
 *				shutdown 				     *
 *===========================================================================*/
void minix_shutdown(int how)
{
/* This function is called from prepare_shutdown or stop_sequence to bring 
 * down MINIX.
 */

#ifdef CONFIG_SMP
  /* 
   * FIXME
   *
   * we will need to stop timers on all cpus if SMP is enabled and put them in
   * such a state that we can perform the whole boot process once restarted from
   * monitor again
   */
  if (ncpus > 1)
	  smp_shutdown_aps();
#endif
  hw_intr_disable_all();
  stop_local_timer();

  /* Show shutdown message */
  direct_cls();
  if((how & RB_POWERDOWN) == RB_POWERDOWN)
	direct_print("MINIX has halted and will now power off.\n");
  else if(how & RB_HALT)
	direct_print("MINIX has halted. "
		     "It is safe to turn off your computer.\n");
  else
	direct_print("MINIX will now reset.\n");
  arch_shutdown(how);
}

/*===========================================================================*
 *				cstart					     *
 *===========================================================================*/
void cstart(void)
{
/* Perform system initializations prior to calling main(). Most settings are
 * determined with help of the environment strings passed by MINIX' loader.
 */
  register char *value;				/* value in key=value pair */

  /* low-level initialization */
  prot_init();

  /* determine verbosity */
  if ((value = env_get(VERBOSEBOOTVARNAME)))
	  verboseboot = 0; /* FIXME: atoi(value) was here, replace with katoi */ // MODIFIED
	  verboseboot = 0; /* FIXME: atoi(value) was here, replace with katoi */ // MODIFIED

  /* Initialize clock variables. */
  init_clock();

  /* Get memory parameters. */
  value = env_get("ac_layout");
  if(value && (*value != '0')) { /* FIXME: atoi(value) was here, simple check for non-zero for now */ // MODIFIED
  if(value && (*value != '0')) { /* FIXME: atoi(value) was here, simple check for non-zero for now */ // MODIFIED
        kinfo.user_sp = (vir_bytes) USR_STACKTOP_COMPACT;
        kinfo.user_end = (vir_bytes) USR_DATATOP_COMPACT;
  }

  DEBUGEXTRA(("cstart\n"));

  /* Record miscellaneous information for user-space servers. */
  kinfo.nr_procs = NR_PROCS;
  kinfo.nr_tasks = NR_TASKS;
  kstrlcpy(kinfo.release, OS_RELEASE, sizeof(kinfo.release)); // MODIFIED
  kstrlcpy(kinfo.version, OS_VERSION, sizeof(kinfo.version)); // MODIFIED
  kstrlcpy(kinfo.release, OS_RELEASE, sizeof(kinfo.release)); // MODIFIED
  kstrlcpy(kinfo.version, OS_VERSION, sizeof(kinfo.version)); // MODIFIED

  /* Initialize various user-mapped structures. */
  kmemset(&arm_frclock, 0, sizeof(arm_frclock)); // MODIFIED
  kmemset(&arm_frclock, 0, sizeof(arm_frclock)); // MODIFIED

  kmemset(&kuserinfo, 0, sizeof(kuserinfo)); // MODIFIED
  kmemset(&kuserinfo, 0, sizeof(kuserinfo)); // MODIFIED
  kuserinfo.kui_size = sizeof(kuserinfo);
  kuserinfo.kui_user_sp = kinfo.user_sp;

#ifdef USE_APIC
  value = env_get("no_apic");
  if(value)
	config_no_apic = (*value != '0'); /* FIXME: atoi(value) was here */ // MODIFIED (default to true if value is non-zero)
	config_no_apic = (*value != '0'); /* FIXME: atoi(value) was here */ // MODIFIED (default to true if value is non-zero)
  else
	config_no_apic = 1; /* Default if not set */
	config_no_apic = 1; /* Default if not set */
  value = env_get("apic_timer_x");
  if(value)
	config_apic_timer_x = 0; /* FIXME: atoi(value) was here, replace with katoi */ // MODIFIED (default to 0, needs proper katoi)
	config_apic_timer_x = 0; /* FIXME: atoi(value) was here, replace with katoi */ // MODIFIED (default to 0, needs proper katoi)
  else
	config_apic_timer_x = 1; /* Default if not set */
	config_apic_timer_x = 1; /* Default if not set */
#endif

#ifdef USE_WATCHDOG
  value = env_get("watchdog");
  if (value)
	  watchdog_enabled = (*value != '0'); /* FIXME: atoi(value) was here */ // MODIFIED (default to true if value is non-zero)
	  watchdog_enabled = (*value != '0'); /* FIXME: atoi(value) was here */ // MODIFIED (default to true if value is non-zero)
#endif

#ifdef CONFIG_SMP
  if (config_no_apic)
	  config_no_smp = 1;
  value = env_get("no_smp");
  if(value)
	config_no_smp = (*value != '0'); /* FIXME: atoi(value) was here */ // MODIFIED (default to true if value is non-zero)
	config_no_smp = (*value != '0'); /* FIXME: atoi(value) was here */ // MODIFIED (default to true if value is non-zero)
  else
	config_no_smp = 0; /* Default if not set */
	config_no_smp = 0; /* Default if not set */
#endif
  DEBUGEXTRA(("intr_init(0)\n"));

  intr_init(0);

  arch_init();
}

/*===========================================================================*
 *				get_value				     *
 *===========================================================================*/

char *get_value(
  const char *params,			/* boot monitor parameters */
  const char *name			/* key to look up */
)
{
/* Get environment value - kernel version of getenv to avoid setting up the
 * usual environment array.
 */
  register const char *namep;
  register char *envp;

  for (envp = (char *) params; *envp != 0;) {
	for (namep = name; *namep != 0 && *namep == *envp; namep++, envp++)
		;
	if (*namep == '\0' && *envp == '=') return(envp + 1);
	while (*envp++ != 0)
		;
  }
  return(NULL);
}

/*===========================================================================*
 *				env_get				     	*
 *===========================================================================*/
char *env_get(const char *name)
{
	return get_value(kinfo.param_buf, name);
}

void cpu_print_freq(unsigned cpu)
{
        u64_t freq;

        freq = cpu_get_freq(cpu);
        DEBUGBASIC(("CPU %d freq %lu MHz\n", cpu, (unsigned long)(freq / 1000000)));
}

int is_fpu(void)
{
        return get_cpulocal_var(fpu_presence);
}



/* ============================================================================
 * SOURCE 23/98: minix4\exokernel\minix_drivers\system\random\main.c
 * Size: 8,311 bytes, Lines: 269
 * Hash: 4710e8c360a5...
 * ============================================================================ */

/* This file contains the device dependent part of the drivers for the
 * following special files:
 *     /dev/random	- random number generator
 */

#include <minix/drivers.h>
#include <minix/chardriver.h>
#include <minix/type.h>

#include "assert.h"
#include "random.h"

#define NR_DEVS            1		/* number of minor devices */
#  define RANDOM_DEV  0			/* minor device for /dev/random */

#define KRANDOM_PERIOD    1 		/* ticks between krandom calls */

static struct device m_geom[NR_DEVS];  /* base and size of each device */
static dev_t m_device;			/* current device */

extern int errno;			/* error number for PM calls */

static struct device *r_prepare(dev_t device);
static ssize_t r_read(devminor_t minor, u64_t position, endpoint_t endpt,
	cp_grant_id_t grant, size_t size, int flags, cdev_id_t id);
static ssize_t r_write(devminor_t minor, u64_t position, endpoint_t endpt,
	cp_grant_id_t grant, size_t size, int flags, cdev_id_t id);
static int r_open(devminor_t minor, int access, endpoint_t user_endpt);
static void r_random(clock_t stamp);
static void r_updatebin(int source, struct k_randomness_bin *rb);
static int r_select(devminor_t, unsigned int, endpoint_t);

/* Entry points to this driver. */
static struct chardriver r_dtab = {
  .cdr_open	= r_open,	/* open device */
  .cdr_read	= r_read,	/* read from device */
  .cdr_write	= r_write,	/* write to device (seeding it) */
  .cdr_select	= r_select,	/* select hook */
  .cdr_alarm	= r_random 	/* get randomness from kernel (alarm) */
};

/* select requestor */
static endpoint_t random_select = NONE;

/* Buffer for the /dev/random number generator. */
#define RANDOM_BUF_SIZE 		1024
static char random_buf[RANDOM_BUF_SIZE];

/* SEF functions and variables. */
static void sef_local_startup(void);
static int sef_cb_init_fresh(int type, sef_init_info_t *info);

/*===========================================================================*
 *				   main 				     *
 *===========================================================================*/
int main(void)
{
  /* SEF local startup. */
  sef_local_startup();

  /* Call the generic receive loop. */
  chardriver_task(&r_dtab);

  return(OK);
}

/*===========================================================================*
 *			       sef_local_startup			     *
 *===========================================================================*/
static void sef_local_startup()
{
  /* Register init callbacks. */
  sef_setcb_init_fresh(sef_cb_init_fresh);
  sef_setcb_init_restart(sef_cb_init_fresh);

  /* Let SEF perform startup. */
  sef_startup();
}

/*===========================================================================*
 *		            sef_cb_init_fresh                                *
 *===========================================================================*/
static int sef_cb_init_fresh(int UNUSED(type), sef_init_info_t *UNUSED(info))
{
/* Initialize the random driver. */
  static struct k_randomness krandom;
  int i, s;

  random_init();
  r_random(0);				/* also set periodic timer */

  /* Retrieve first randomness buffer with parameters. */
  if (OK != (s=sys_getrandomness(&krandom))) {
  	printf("RANDOM: sys_getrandomness failed: %d\n", s);
	exit(1);
  }

  /* Do sanity check on parameters. */
  if(krandom.random_sources != RANDOM_SOURCES ||
     krandom.random_elements != RANDOM_ELEMENTS) {
     printf("random: parameters (%d, %d) don't match kernel's (%d, %d)\n",
	RANDOM_SOURCES, RANDOM_ELEMENTS,
	krandom.random_sources, krandom.random_elements);
     exit(1);
  }

  /* Feed initial batch. */
  for(i = 0; i < RANDOM_SOURCES; i++)
	r_updatebin(i, &krandom.bin[i]);

  /* Announce we are up! */
  chardriver_announce();

  return(OK);
}

/*===========================================================================*
 *				r_read					     *
 *===========================================================================*/
static ssize_t r_read(devminor_t minor, u64_t UNUSED(position),
	endpoint_t endpt, cp_grant_id_t grant, size_t size, int UNUSED(flags),
	cdev_id_t UNUSED(id))
{
/* Read from one of the driver's minor devices. */
  size_t offset, chunk;
  int r;

  if (minor != RANDOM_DEV) return(EIO);

  if (!random_isseeded()) return(EAGAIN);

  for (offset = 0; offset < size; offset += chunk) {
	chunk = MIN(size - offset, RANDOM_BUF_SIZE);
	random_getbytes(random_buf, chunk);
	r = sys_safecopyto(endpt, grant, offset, (vir_bytes)random_buf, chunk);
	if (r != OK) {
		printf("random: sys_safecopyto failed for proc %d, grant %d\n",
			endpt, grant);
		return r;
	}
  }

  return size;
}

/*===========================================================================*
 *				r_write					     *
 *===========================================================================*/
static ssize_t r_write(devminor_t minor, u64_t UNUSED(position),
	endpoint_t endpt, cp_grant_id_t grant, size_t size, int UNUSED(flags),
	cdev_id_t UNUSED(id))
{
/* Write to one of the driver's minor devices. */
  size_t offset, chunk;
  int r;

  if (minor != RANDOM_DEV) return(EIO);

  for (offset = 0; offset < size; offset += chunk) {
	chunk = MIN(size - offset, RANDOM_BUF_SIZE);
	r = sys_safecopyfrom(endpt, grant, offset, (vir_bytes)random_buf,
		chunk);
	if (r != OK) {
		printf("random: sys_safecopyfrom failed for proc %d,"
			" grant %d\n", endpt, grant);
		return r;
	}
	random_putbytes(random_buf, chunk);
  }

  return size;
}

/*===========================================================================*
 *				r_open					     *
 *===========================================================================*/
static int r_open(devminor_t minor, int access, endpoint_t UNUSED(user_endpt))
{
/* Check device number on open.
 */

  if (minor < 0 || minor >= NR_DEVS) return(ENXIO);

  return(OK);
}

#define UPDATE(binnumber, bp, startitem, elems) 	{	\
		rand_t *r;					\
		int n = elems, item = startitem;\
		int high;					\
		assert(binnumber >= 0 && binnumber < RANDOM_SOURCES);	 \
		assert(item >= 0 && item < RANDOM_ELEMENTS);	\
		if(n > 0) {					\
			high = item+n-1;			\
			assert(high >= item);				\
			assert(high >= 0 && high < RANDOM_ELEMENTS);	\
			r = &bp->r_buf[item];		\
	  		random_update(binnumber, r, n);			\
		}							\
}

/*===========================================================================*
 *				r_updatebin				     *
 *===========================================================================*/
static void r_updatebin(int source, struct k_randomness_bin *rb)
{
  	int r_next, r_size, r_high;

  	r_next= rb->r_next;
  	r_size= rb->r_size;

	assert(r_next >= 0 && r_next < RANDOM_ELEMENTS);
	assert(r_size >= 0 && r_size <= RANDOM_ELEMENTS);

  	r_high= r_next+r_size;

  	if (r_high <= RANDOM_ELEMENTS) {
		UPDATE(source, rb, r_next, r_size);
	} else {
		assert(r_next < RANDOM_ELEMENTS);
		UPDATE(source, rb, r_next, RANDOM_ELEMENTS-r_next);
		UPDATE(source, rb, 0, r_high-RANDOM_ELEMENTS);
	}

	return;
}

/*===========================================================================*
 *				r_random				     *
 *===========================================================================*/
static void r_random(clock_t UNUSED(stamp))
{
  /* Fetch random information from the kernel to update /dev/random. */
  int s;
  static int bin = 0;
  static struct k_randomness_bin krandom_bin;
  u32_t hi, lo;
  rand_t r;
  int nextperiod = random_isseeded() ? KRANDOM_PERIOD*500 : KRANDOM_PERIOD;

  bin = (bin+1) % RANDOM_SOURCES;

  if(sys_getrandom_bin(&krandom_bin, bin) == OK)
	r_updatebin(bin, &krandom_bin);

  /* Add our own timing source. */
  read_tsc(&hi, &lo);
  r = lo;
  random_update(RND_TIMING, &r, 1);

  /* Schedule new alarm for next m_random call. */
  if (OK != (s=sys_setalarm(nextperiod, 0)))
  	printf("RANDOM: sys_setalarm failed: %d\n", s);
}

/*===========================================================================*
 *				r_select				     *
 *===========================================================================*/
static int r_select(devminor_t minor, unsigned int ops, endpoint_t ep)
{
	/* random device is always writable; it's infinitely readable
	 * once seeded, and doesn't block when it's not, so all operations
	 * are instantly possible. we ignore CDEV_OP_ERR.
	 */
	int ready_ops = 0;
	if (minor != RANDOM_DEV) return(EIO);
	return ops & (CDEV_OP_RD | CDEV_OP_WR);
}



/* ============================================================================
 * SOURCE 24/98: minix4\exokernel\minix_drivers\storage\filter\main.c
 * Size: 11,720 bytes, Lines: 413
 * Hash: 9b699aafcfba...
 * ============================================================================ */

/* Filter driver - top layer - block interface */

/* This is a filter driver, which lays above disk driver, and forwards
 * messages between disk driver and its callers. The filter can detect
 * corrupted data (toggled by USE_CHECKSUM) and recover it (toggled
 * by USE_MIRROR). These two functions are independent from each other. 
 * The mirroring function requires two disks, on separate disk drivers.
 */

#include "inc.h"

#define _POSIX_SOURCE 1
#include <signal.h>

/* Global settings. */
int USE_CHECKSUM = 0;	/* enable checksumming */
int USE_MIRROR = 0;	/* enable mirroring */

int BAD_SUM_ERROR = 1;	/* bad checksums are considered a driver error */

int USE_SUM_LAYOUT = 0;	/* use checksumming layout on disk */
int NR_SUM_SEC = 8;	/* number of checksums per checksum sector */

int SUM_TYPE = ST_CRC;	/* use NIL, XOR, CRC, or MD5 */
int SUM_SIZE = 0;	/* size of the stored checksum */

int NR_RETRIES = 3;	/* number of times the request will be retried (N) */
int NR_RESTARTS = 3;	/* number of times a driver will be restarted (M) */
int DRIVER_TIMEOUT = 5;	/* timeout in seconds to declare a driver dead (T) */

int CHUNK_SIZE = 0;	/* driver requests will be vectorized at this size */

char MAIN_LABEL[LABEL_SIZE] = "";		/* main disk driver label */
char BACKUP_LABEL[LABEL_SIZE] = "";		/* backup disk driver label */
int MAIN_MINOR = -1;				/* main partition minor nr */
int BACKUP_MINOR = -1;				/* backup partition minor nr */

static struct optset optset_table[] = {
  { "label0",	OPT_STRING,	MAIN_LABEL,		LABEL_SIZE	},
  { "label1",	OPT_STRING,	BACKUP_LABEL,		LABEL_SIZE	},
  { "minor0",	OPT_INT,	&MAIN_MINOR,		10		},
  { "minor1",	OPT_INT,	&BACKUP_MINOR,		10		},
  { "sum_sec",	OPT_INT,	&NR_SUM_SEC,		10		},
  { "layout",	OPT_BOOL,	&USE_SUM_LAYOUT,	1		},
  { "nolayout",	OPT_BOOL,	&USE_SUM_LAYOUT,	0		},
  { "sum",	OPT_BOOL,	&USE_CHECKSUM,		1		},
  { "nosum",	OPT_BOOL,	&USE_CHECKSUM,		0		},
  { "mirror",	OPT_BOOL,	&USE_MIRROR,		1		},
  { "nomirror",	OPT_BOOL,	&USE_MIRROR,		0		},
  { "nil",	OPT_BOOL,	&SUM_TYPE,		ST_NIL		},
  { "xor",	OPT_BOOL,	&SUM_TYPE,		ST_XOR		},
  { "crc",	OPT_BOOL,	&SUM_TYPE,		ST_CRC		},
  { "md5",	OPT_BOOL,	&SUM_TYPE,		ST_MD5		},
  { "sumerr",	OPT_BOOL,	&BAD_SUM_ERROR,		1		},
  { "nosumerr",	OPT_BOOL,	&BAD_SUM_ERROR,		0		},
  { "retries",	OPT_INT,	&NR_RETRIES,		10		},
  { "N",	OPT_INT,	&NR_RETRIES,		10		},
  { "restarts",	OPT_INT,	&NR_RESTARTS,		10		},
  { "M",	OPT_INT,	&NR_RESTARTS,		10		},
  { "timeout",	OPT_INT,	&DRIVER_TIMEOUT,	10		},
  { "T",	OPT_INT,	&DRIVER_TIMEOUT,	10		},
  { "chunk",	OPT_INT,	&CHUNK_SIZE,		10		},
  { NULL,	0,		NULL,			0		}
};

/* Data buffers. */
static char *buf_array, *buffer;		/* contiguous buffer */

/* SEF functions and variables. */
static void sef_local_startup(void);
static int sef_cb_init_fresh(int type, sef_init_info_t *info);
static void sef_cb_signal_handler(int signo);

static int filter_open(devminor_t minor, int access);
static int filter_close(devminor_t minor);
static ssize_t filter_transfer(devminor_t minor, int do_write, u64_t pos,
	endpoint_t endpt, iovec_t *iov, unsigned int count, int flags);
static int filter_ioctl(devminor_t minor, unsigned long request,
	endpoint_t endpt, cp_grant_id_t grant, endpoint_t user_endpt);
static void filter_other(message *m, int ipc_status);

static struct blockdriver filter_tab = {
	.bdr_type	= BLOCKDRIVER_TYPE_OTHER,
	.bdr_open	= filter_open,
	.bdr_close	= filter_close,
	.bdr_transfer	= filter_transfer,
	.bdr_ioctl	= filter_ioctl,
	.bdr_other	= filter_other
};

/*===========================================================================*
 *				filter_open				     *
 *===========================================================================*/
static int filter_open(devminor_t UNUSED(minor), int UNUSED(access))
{
	/* Open is a noop for filter. */
	return OK;
}

/*===========================================================================*
 *				filter_close				     *
 *===========================================================================*/
static int filter_close(devminor_t UNUSED(minor))
{
	/* Close is a noop for filter. */
	return OK;
}

/*===========================================================================*
 *				vcarry					     *
 *===========================================================================*/
static int vcarry(endpoint_t endpt, unsigned int grants, iovec_t *iov,
	int do_write, size_t size)
{
	/* Carry data between caller proc and filter, through grant-vector.
	 */
	char *bufp;
	int i, r;
	size_t bytes;

	bufp = buffer;
	for(i = 0; i < grants && size > 0; i++) {
		bytes = MIN(size, iov[i].iov_size);

		if (do_write)
			r = sys_safecopyfrom(endpt,
				(vir_bytes) iov[i].iov_addr, 0,
				(vir_bytes) bufp, bytes);
		else
			r = sys_safecopyto(endpt,
				(vir_bytes) iov[i].iov_addr, 0,
				(vir_bytes) bufp, bytes);

		if(r != OK)
			return r;

		bufp += bytes;
		size -= bytes;
	}

	return OK;
}


/*===========================================================================*
 *				filter_transfer				     *
 *===========================================================================*/
static ssize_t filter_transfer(devminor_t UNUSED(minor), int do_write,
	u64_t pos, endpoint_t endpt, iovec_t *iov, unsigned int count,
	int UNUSED(flags))
{
	size_t size, size_ret;
	int r, i;

	for(size = 0, i = 0; i < count; i++)
		size += iov[i].iov_size;

	if (pos % SECTOR_SIZE != 0 || size % SECTOR_SIZE != 0) {
		printf("Filter: unaligned request from caller!\n");
		return EINVAL;
	}

	buffer = flt_malloc(size, buf_array, BUF_SIZE);

	if (do_write)
		vcarry(endpt, count, iov, do_write, size);

	reset_kills();

	for (;;) {
		size_ret = size;
		r = transfer(pos, buffer, &size_ret,
			do_write ? FLT_WRITE : FLT_READ);
		if(r != RET_REDO)
			break;

#if DEBUG
		printf("Filter: transfer yielded RET_REDO, checking drivers\n");
#endif
		if((r = check_driver(DRIVER_MAIN)) != OK) break;
		if((r = check_driver(DRIVER_BACKUP)) != OK) break;
	}

	if(r != OK) {
		flt_free(buffer, size, buf_array);
		return r;
	}

	if (!do_write)
		vcarry(endpt, count, iov, do_write, size_ret);

	flt_free(buffer, size, buf_array);

	return size_ret;
}

/*===========================================================================*
 *				filter_ioctl				     *
 *===========================================================================*/
static int filter_ioctl(devminor_t UNUSED(minor), unsigned long request,
	endpoint_t endpt, cp_grant_id_t grant, endpoint_t UNUSED(user_endpt))
{
	struct part_geom sizepart;

	switch (request) {
	case DIOCSETP:
	case DIOCTIMEOUT:
	case DIOCOPENCT:
		/* These do not make sense for us. */
		return EINVAL;

	case DIOCGETP:
		memset(&sizepart, 0, sizeof(sizepart));

		/* The presented disk size is the raw partition size,
		 * corrected for space needed for checksums.
		 */
		sizepart.size = convert(get_raw_size());

		if (sys_safecopyto(endpt, grant, 0, (vir_bytes) &sizepart,
				sizeof(struct part_geom)) != OK) {
			printf("Filter: DIOCGETP safecopyto failed\n");
			return EIO;
		}
		break;

	default:
		printf("Filter: unknown ioctl request: %ld!\n", request);
		return ENOTTY;
	}

	return OK;
}

/*===========================================================================*
 *				filter_other				     *
 *===========================================================================*/
static void filter_other(message *m, int ipc_status)
{
	/* Process other messages. */
	if (m->m_source == DS_PROC_NR && is_ipc_notify(ipc_status)) {
		ds_event();
	}
}

/*===========================================================================*
 *				parse_arguments				     *
 *===========================================================================*/
static int parse_arguments(int argc, char *argv[])
{

	if(argc != 2)
		return EINVAL;

	optset_parse(optset_table, argv[1]);

	if (MAIN_LABEL[0] == 0 || MAIN_MINOR < 0 || MAIN_MINOR > 255)
		return EINVAL;
	if (USE_MIRROR && (BACKUP_LABEL[0] == 0 ||
			BACKUP_MINOR < 0 || BACKUP_MINOR > 255))
		return EINVAL;

	/* Checksumming implies a checksum layout. */
	if (USE_CHECKSUM)
		USE_SUM_LAYOUT = 1;

	/* Determine the checksum size for the chosen checksum type. */
	switch (SUM_TYPE) {
	case ST_NIL:
		SUM_SIZE = 4;	/* for the sector number */
		break;
	case ST_XOR:
		SUM_SIZE = 16;	/* compatibility */
		break;
	case ST_CRC:
		SUM_SIZE = 4;
		break;
	case ST_MD5:
		SUM_SIZE = 16;
		break;
	default:
		return EINVAL;
	}

	if (NR_SUM_SEC <= 0 || SUM_SIZE * NR_SUM_SEC > SECTOR_SIZE)
		return EINVAL;

#if DEBUG
	printf("Filter starting. Configuration:\n");
	printf("  USE_CHECKSUM :   %3s ", USE_CHECKSUM ? "yes" : "no");
	printf("  USE_MIRROR : %3s\n", USE_MIRROR ? "yes" : "no");

	if (USE_CHECKSUM) {
		printf("  BAD_SUM_ERROR :  %3s ",
			BAD_SUM_ERROR ? "yes" : "no");
		printf("  NR_SUM_SEC : %3d\n", NR_SUM_SEC);

		printf("  SUM_TYPE :       ");

		switch (SUM_TYPE) {
		case ST_NIL: printf("nil"); break;
		case ST_XOR: printf("xor"); break;
		case ST_CRC: printf("crc"); break;
		case ST_MD5: printf("md5"); break;
		}

		printf("   SUM_SIZE :   %3d\n", SUM_SIZE);
	}
	else printf("  USE_SUM_LAYOUT : %3s\n", USE_SUM_LAYOUT ? "yes" : "no");

	printf("  N : %3dx       M : %3dx        T : %3ds\n",
		NR_RETRIES, NR_RESTARTS, DRIVER_TIMEOUT);

	printf("  MAIN_LABEL / MAIN_MINOR : %19s / %d\n",
		MAIN_LABEL, MAIN_MINOR);
	if (USE_MIRROR) {
		printf("  BACKUP_LABEL / BACKUP_MINOR : %15s / %d\n",	
			BACKUP_LABEL, BACKUP_MINOR);
	}

#endif

	/* Convert timeout seconds to ticks. */
	DRIVER_TIMEOUT *= sys_hz();

	return OK;
}

/*===========================================================================*
 *				main					     *
 *===========================================================================*/
int main(int argc, char *argv[])
{
	message m_out;
	int r, ipc_status;
	size_t size;

	/* SEF local startup. */
	env_setargs(argc, argv);
	sef_local_startup();

	blockdriver_task(&filter_tab);

	return 0;
}

/*===========================================================================*
 *			       sef_local_startup			     *
 *===========================================================================*/
static void sef_local_startup(void)
{
	/* Register init callbacks. */
	sef_setcb_init_fresh(sef_cb_init_fresh);
	sef_setcb_init_restart(sef_cb_init_fresh);

	/* Register signal callbacks. */
	sef_setcb_signal_handler(sef_cb_signal_handler);

	/* Let SEF perform startup. */
	sef_startup();
}

/*===========================================================================*
 *		            sef_cb_init_fresh                                *
 *===========================================================================*/
static int sef_cb_init_fresh(int type, sef_init_info_t *UNUSED(info))
{
	/* Initialize the filter driver. */
	int r;

	r = parse_arguments(env_argc, env_argv);
	if(r != OK) {
		printf("Filter: wrong argument!\n");
		return 1;
	}

	if ((buf_array = flt_malloc(BUF_SIZE, NULL, 0)) == NULL)
		panic("no memory available");

	sum_init();

	driver_init();

	/* Subscribe to block driver events. */
	r = ds_subscribe("drv\\.blk\\..*", DSF_INITIAL | DSF_OVERWRITE);
	if(r != OK) {
		panic("Filter: can't subscribe to driver events");
	}

	/* Announce we are up! */
	blockdriver_announce(type);

	return(OK);
}

/*===========================================================================*
 *		           sef_cb_signal_handler                             *
 *===========================================================================*/
static void sef_cb_signal_handler(int signo)
{
	/* Only check for termination signal, ignore anything else. */
	if (signo != SIGTERM) return;

	/* If so, shut down this driver. */
#if DEBUG
	printf("Filter: shutdown...\n");
#endif

	driver_shutdown();

	exit(0);
}



/* ============================================================================
 * SOURCE 25/98: minix4\exokernel\minix_drivers\bus\pci\main.c
 * Size: 13,356 bytes, Lines: 741
 * Hash: f9d496e2c456...
 * ============================================================================ */

#include <sys/types.h>

#include <dev/pci/pciio.h>

#include <minix/chardriver.h>
#include <minix/driver.h>
#include <minix/rs.h>

#include "pci.h"

int debug = 0;
struct pci_acl pci_acl[NR_DRIVERS];

/*======================================================================*
 *				Helpers					*
 *======================================================================*/
static struct rs_pci *
find_acl(int endpoint)
{
	int i;

	/* Find ACL entry for caller */
	for (i= 0; i<NR_DRIVERS; i++)
	{
		if (!pci_acl[i].inuse)
			continue;
		if (pci_acl[i].acl.rsp_endpoint == endpoint)
			return &pci_acl[i].acl;
	}
	return NULL;
}

static void
reply(message *mp, int result)
{
	int r;
	message m;

	m.m_type= result;
	r= ipc_send(mp->m_source, &m);
	if (r != 0)
		printf("reply: unable to send to %d: %d\n", mp->m_source, r);
}

static void
do_init(message *mp)
{
	int r;

#if DEBUG
	printf("PCI: do_init: called by '%d'\n", mp->m_source);
#endif

	mp->m_type= 0;
	r= ipc_send(mp->m_source, mp);
	if (r != 0)
		printf("PCI: do_init: unable to send to %d: %d\n",
			mp->m_source, r);
}

static void
do_first_dev(message *mp)
{
	int r, devind;
	u16_t vid, did;
	struct rs_pci *aclp;

	aclp= find_acl(mp->m_source);

	if (!aclp && debug)
		printf("PCI: do_first_dev: no acl for caller %d\n",
			mp->m_source);

	r= _pci_first_dev(aclp, &devind, &vid, &did);
	if (r == 1)
	{
		mp->m1_i1= devind;
		mp->m1_i2= vid;
		mp->m1_i3= did;
	}
	mp->m_type= r;
	r= ipc_send(mp->m_source, mp);
	if (r != 0)
	{
		printf("PCI: do_first_dev: unable to send to %d: %d\n",
			mp->m_source, r);
	}
}

static void
do_next_dev(message *mp)
{
	int r, devind;
	u16_t vid, did;
	struct rs_pci *aclp;

	devind= mp->m1_i1;
	aclp= find_acl(mp->m_source);

	r= _pci_next_dev(aclp, &devind, &vid, &did);
	if (r == 1)
	{
		mp->m1_i1= devind;
		mp->m1_i2= vid;
		mp->m1_i3= did;
	}
	mp->m_type= r;
	r= ipc_send(mp->m_source, mp);
	if (r != 0)
	{
		printf("PCI: do_next_dev: unable to send to %d: %d\n",
			mp->m_source, r);
	}
}

static void
do_find_dev(message *mp)
{
	int r, devind;
	u8_t bus, dev, func;

	bus= mp->m1_i1;
	dev= mp->m1_i2;
	func= mp->m1_i3;

	r= _pci_find_dev(bus, dev, func, &devind);
	if (r == 1)
		mp->m1_i1= devind;
	mp->m_type= r;
	r= ipc_send(mp->m_source, mp);
	if (r != 0)
	{
		printf("PCI: do_find_dev: unable to send to %d: %d\n",
			mp->m_source, r);
	}
}

static void
do_ids(message *mp)
{
	int r, devind;
	u16_t vid, did;

	devind= mp->m1_i1;

	r= _pci_ids(devind, &vid, &did);
	if (r != OK)
	{
		printf("pci:do_ids: failed for devind %d: %d\n",
			devind, r);
	}

	mp->m1_i1= vid;
	mp->m1_i2= did;
	mp->m_type= r;
	r= ipc_send(mp->m_source, mp);
	if (r != 0)
	{
		printf("PCI: do_ids: unable to send to %d: %d\n",
			mp->m_source, r);
	}
}

static void
do_dev_name(message *mp)
{
	int r, name_len, len;
	u16_t vid, did;
	cp_grant_id_t name_gid;
	const char *name;

	vid= mp->m7_i1;
	did= mp->m7_i2;
	name_len= mp->m7_i3;
	name_gid= mp->m7_i4;

	name= _pci_dev_name(vid, did);
	if (name == NULL)
	{
		/* No name */
		r= ENOENT;
	}
	else
	{
		len= strlen(name)+1;
		if (len > name_len)
			len= name_len;
		r= sys_safecopyto(mp->m_source, name_gid, 0, (vir_bytes)name,
			len);
	}

	mp->m_type= r;
	r= ipc_send(mp->m_source, mp);
	if (r != 0)
	{
		printf("PCI: do_dev_name: unable to send to %d: %d\n",
			mp->m_source, r);
	}
}

static void
do_slot_name(message *mp)
{
	int r, devind, name_len, len;
	cp_grant_id_t gid;
	char *name;

	devind= mp->m1_i1;
	name_len= mp->m1_i2;
	gid= mp->m1_i3;

	r= _pci_slot_name(devind, &name);
	if (r != OK)
	{
		printf("pci:do_slot_name_s: failed for devind %d: %d\n",
			devind, r);
	}

	if (r == OK)
	{
		len= strlen(name)+1;
		if (len > name_len)
			len= name_len;
		r= sys_safecopyto(mp->m_source, gid, 0,
			(vir_bytes)name, len);
	}

	mp->m_type= r;
	r= ipc_send(mp->m_source, mp);
	if (r != 0)
	{
		printf("PCI: do_slot_name: unable to send to %d: %d\n",
			mp->m_source, r);
	}
}

static void
do_set_acl(message *mp)
{
	int i, r, gid;

	if (mp->m_source != RS_PROC_NR)
	{
		printf("PCI: do_set_acl: not from RS\n");
		reply(mp, EPERM);
		return;
	}

	for (i= 0; i<NR_DRIVERS; i++)
	{
		if (!pci_acl[i].inuse)
			break;
	}
	if (i >= NR_DRIVERS)
	{
		printf("PCI: do_set_acl: table is full\n");
		reply(mp, ENOMEM);
		return;
	}

	gid= mp->m1_i1;

	r= sys_safecopyfrom(mp->m_source, gid, 0, (vir_bytes)&pci_acl[i].acl,
		sizeof(pci_acl[i].acl));
	if (r != OK)
	{
		printf("PCI: do_set_acl: safecopyfrom failed\n");
		reply(mp, r);
		return;
	}
	pci_acl[i].inuse= 1;
	if(debug)
	  printf("PCI: do_acl: setting ACL for %d ('%s') at entry %d\n",
		pci_acl[i].acl.rsp_endpoint, pci_acl[i].acl.rsp_label,
		i);

	reply(mp, OK);
}

static void
do_del_acl(message *mp)
{
	int i, proc_nr;

	if (mp->m_source != RS_PROC_NR)
	{
		printf("do_del_acl: not from RS\n");
		reply(mp, EPERM);
		return;
	}

	proc_nr= mp->m1_i1;

	for (i= 0; i<NR_DRIVERS; i++)
	{
		if (!pci_acl[i].inuse)
			continue;
		if (pci_acl[i].acl.rsp_endpoint == proc_nr)
			break;
	}

	if (i >= NR_DRIVERS)
	{
		printf("do_del_acl: nothing found for %d\n", proc_nr);
		reply(mp, EINVAL);
		return;
	}

	pci_acl[i].inuse= 0;
#if 0
	printf("do_acl: deleting ACL for %d ('%s') at entry %d\n",
		pci_acl[i].acl.rsp_endpoint, pci_acl[i].acl.rsp_label, i);
#endif

	/* Also release all devices held by this process */
	_pci_release(proc_nr);

	reply(mp, OK);
}

static void
do_reserve(message *mp)
{
	struct rs_pci *aclp;
	int r, devind;

	devind= mp->m1_i1;

	aclp= find_acl(mp->m_source);

	mp->m_type= _pci_reserve(devind, mp->m_source, aclp);
	r= ipc_send(mp->m_source, mp);
	if (r != 0)
	{
		printf("do_reserve: unable to send to %d: %d\n",
			mp->m_source, r);
	}
}

static void
do_attr_r8(message *mp)
{
	int r, devind, port;
	u8_t v;

	devind= mp->m2_i1;
	port= mp->m2_i2;

	r= _pci_attr_r8(devind, port, &v);
	if (r != OK)
	{
		printf(
		"pci:do_attr_r8: pci_attr_r8(%d, %d, ...) failed: %d\n",
			devind, port, r);
	}
	mp->m2_l1= v;
	mp->m_type= r;
	r= ipc_send(mp->m_source, mp);
	if (r != 0)
	{
		printf("do_attr_r8: unable to send to %d: %d\n",
			mp->m_source, r);
	}
}

static void
do_attr_r16(message *mp)
{
	int r, devind, port;
	u16_t v;

	devind= mp->m2_i1;
	port= mp->m2_i2;

	r= _pci_attr_r16(devind, port, &v);
	if (r != OK)
	{
		printf(
		"pci:do_attr_r16: pci_attr_r16(%d, %d, ...) failed: %d\n",
			devind, port, r);
	}
	mp->m2_l1= v;
	mp->m_type= OK;
	r= ipc_send(mp->m_source, mp);
	if (r != 0)
	{
		printf("do_attr_r16: unable to send to %d: %d\n",
			mp->m_source, r);
	}
}

static void
do_attr_r32(message *mp)
{
	int r, devind, port;
	u32_t v;

	devind= mp->m2_i1;
	port= mp->m2_i2;

	r= _pci_attr_r32(devind, port, &v);
	if (r != OK)
	{
		printf(
		"pci:do_attr_r32: pci_attr_r32(%d, %d, ...) failed: %d\n",
			devind, port, r);
	}
	mp->m2_l1= v;
	mp->m_type= OK;
	r= ipc_send(mp->m_source, mp);
	if (r != 0)
	{
		printf("do_attr_r32: unable to send to %d: %d\n",
			mp->m_source, r);
	}
}

static void
do_attr_w8(message *mp)
{
	int r, devind, port;
	u8_t v;

	devind= mp->m2_i1;
	port= mp->m2_i2;
	v= mp->m2_l1;

	_pci_attr_w8(devind, port, v);
	mp->m_type= OK;
	r= ipc_send(mp->m_source, mp);
	if (r != 0)
	{
		printf("do_attr_w8: unable to send to %d: %d\n",
			mp->m_source, r);
	}
}

static void
do_attr_w16(message *mp)
{
	int r, devind, port;
	u16_t v;

	devind= mp->m2_i1;
	port= mp->m2_i2;
	v= mp->m2_l1;

	_pci_attr_w16(devind, port, v);
	mp->m_type= OK;
	r= ipc_send(mp->m_source, mp);
	if (r != 0)
	{
		printf("do_attr_w16: unable to send to %d: %d\n",
			mp->m_source, r);
	}
}

static void
do_attr_w32(message *mp)
{
	int r, devind, port;
	u32_t v;

	devind= mp->m2_i1;
	port= mp->m2_i2;
	v= mp->m2_l1;

	_pci_attr_w32(devind, port, v);
	mp->m_type= OK;
	r= ipc_send(mp->m_source, mp);
	if (r != 0)
	{
		printf("do_attr_w32: unable to send to %d: %d\n",
			mp->m_source, r);
	}
}

static void
do_get_bar(message *mp)
{
	int r, devind, port, ioflag;
	u32_t base, size;

	devind= mp->m_lsys_pci_busc_get_bar.devind;
	port= mp->m_lsys_pci_busc_get_bar.port;

	mp->m_type= _pci_get_bar(devind, port, &base, &size, &ioflag);

	if (mp->m_type == OK)
	{
		mp->m_pci_lsys_busc_get_bar.base= base;
		mp->m_pci_lsys_busc_get_bar.size= size;
		mp->m_pci_lsys_busc_get_bar.flags= ioflag;
	}

	r= ipc_send(mp->m_source, mp);
	if (r != 0)
	{
		printf("do_get_bar: unable to send to %d: %d\n",
			mp->m_source, r);
	}
}

static void
do_rescan_bus(message *mp)
{
	int r, busnr;

	busnr= mp->m2_i1;

	_pci_rescan_bus(busnr);
	mp->m_type= OK;
	r= ipc_send(mp->m_source, mp);
	if (r != 0)
	{
		printf("do_rescan_bus: unable to send to %d: %d\n",
			mp->m_source, r);
	}
}

/*======================================================================*
 *			CharDriver Callbacks				*
 *======================================================================*/
static int
pci_open(devminor_t UNUSED(minor), int UNUSED(access),
	endpoint_t UNUSED(user_endpt))
{
	return OK;
}

static int
pci_close(devminor_t UNUSED(minor))
{
	return OK;
}

static int
pci_ioctl(devminor_t minor, unsigned long request, endpoint_t endpt,
	cp_grant_id_t grant, int flags, endpoint_t user_endpt, cdev_id_t id)
{
	int devind;
	int r = ENOTTY;

	switch(request)
	{
	case PCI_IOC_BDF_CFGREAD:
	{
		struct pciio_bdf_cfgreg bdf;

		if ((r = sys_safecopyfrom(endpt, grant, 0, (vir_bytes)&bdf,
				sizeof(bdf))) != OK)
			break;

		r = _pci_find_dev(bdf.bus, bdf.device, bdf.function, &devind);
		if (r != 1) {
			r = EINVAL;
			break;
		}

		if ((r = _pci_attr_r32(devind, bdf.cfgreg.reg,
					&bdf.cfgreg.val)) != OK)
			break;

		r = sys_safecopyto(endpt, grant, 0, (vir_bytes)&bdf,
			sizeof(bdf));
		break;
	}
	case PCI_IOC_BDF_CFGWRITE:
	{
		struct pciio_bdf_cfgreg bdf;

		if ((r = sys_safecopyfrom(endpt, grant, 0, (vir_bytes)&bdf,
				sizeof(bdf))) != OK)
			break;

		r = _pci_find_dev(bdf.bus, bdf.device, bdf.function, &devind);
		if (r != 1) {
			r = EINVAL;
			break;
		}

		_pci_attr_w32(devind, bdf.cfgreg.reg, bdf.cfgreg.val);
		r = OK;
		break;
	}
	case PCI_IOC_BUSINFO:
		break;
	case PCI_IOC_MAP:
	{
		struct pciio_map map;
		struct minix_mem_range mr;

		if ((r = sys_safecopyfrom(endpt, grant, 0,
				(vir_bytes)&map, sizeof(map))) != OK)
			break;

#if 1
		mr.mr_base = map.phys_offset;
		mr.mr_limit = map.phys_offset + map.size - 1;

		r = sys_privctl(user_endpt, SYS_PRIV_ADD_MEM, &mr);
		if (r != OK)
		{
			break;
		}
#endif

		map.vaddr_ret = vm_map_phys(user_endpt,
			(void *)map.phys_offset, map.size);
		r = sys_safecopyto(endpt, grant, 0, (vir_bytes)&map,
			sizeof(map));
		break;
	}
	case PCI_IOC_UNMAP:
	{
		struct pciio_map map;

		if ((r = sys_safecopyfrom(endpt, grant, 0,
				(vir_bytes)&map, sizeof(map))) != OK)
			break;

		r = vm_unmap_phys(user_endpt, map.vaddr, map.size);
		break;
	}
	case PCI_IOC_RESERVE:
	{
		struct pciio_acl acl;

		if ((r = sys_safecopyfrom(endpt, grant, 0,
				(vir_bytes)&acl, sizeof(acl))) != OK)
			break;

		r = _pci_find_dev(acl.bus, acl.device, acl.function, &devind);
		if (r != 1) {
			r = EINVAL;
			break;
		}

		r = _pci_grant_access(devind, user_endpt);
		break;
	}
	case PCI_IOC_RELEASE:
	{
		struct pciio_acl acl;

		if ((r = sys_safecopyfrom(endpt, grant, 0,
				(vir_bytes)&acl, sizeof(acl))) != OK)
			break;

		r = _pci_find_dev(acl.bus, acl.device, acl.function, &devind);
		if (r != 1) {
			r = EINVAL;
			break;
		}

		_pci_release(endpt);
		r = OK;

		break;
	}
	case PCI_IOC_CFGREAD:
	case PCI_IOC_CFGWRITE:
	default:
		r = ENOTTY;
	}
	return r;
}

static void
pci_other(message *m, int ipc_status)
{
	switch(m->m_type)
	{
	case BUSC_PCI_INIT: do_init(m); break;
	case BUSC_PCI_FIRST_DEV: do_first_dev(m); break;
	case BUSC_PCI_NEXT_DEV: do_next_dev(m); break;
	case BUSC_PCI_FIND_DEV: do_find_dev(m); break;
	case BUSC_PCI_IDS: do_ids(m); break;
	case BUSC_PCI_RESERVE: do_reserve(m); break;
	case BUSC_PCI_ATTR_R8: do_attr_r8(m); break;
	case BUSC_PCI_ATTR_R16: do_attr_r16(m); break;
	case BUSC_PCI_ATTR_R32: do_attr_r32(m); break;
	case BUSC_PCI_ATTR_W8: do_attr_w8(m); break;
	case BUSC_PCI_ATTR_W16: do_attr_w16(m); break;
	case BUSC_PCI_ATTR_W32: do_attr_w32(m); break;
	case BUSC_PCI_RESCAN: do_rescan_bus(m); break;
	case BUSC_PCI_DEV_NAME_S: do_dev_name(m); break;
	case BUSC_PCI_SLOT_NAME_S: do_slot_name(m); break;
	case BUSC_PCI_SET_ACL: do_set_acl(m); break;
	case BUSC_PCI_DEL_ACL: do_del_acl(m); break;
	case BUSC_PCI_GET_BAR: do_get_bar(m); break;
	default:
		printf("PCI: unhandled message from %d, type %d\n",
			m->m_source, m->m_type);
		break;
	}
}

static struct chardriver driver =
{
	.cdr_open	= pci_open,
	.cdr_close	= pci_close,
	.cdr_ioctl	= pci_ioctl,
	.cdr_other	= pci_other,
};

/*======================================================================*
 *			SEF Callbacks					*
 *======================================================================*/
/* NOTE: sef_cb_init is in pci.c. */
static void
sef_local_startup(void)
{
	/*
	 * Register init callbacks. Use the same function for all event types
	 */
	sef_setcb_init_fresh(sef_cb_init);
	sef_setcb_init_restart(sef_cb_init);

	/* Let SEF perform startup. */
	sef_startup();
}

/*======================================================================*
 *				main					*
 *======================================================================*/
int
main(void)
{
	/*
	 * Perform initialization.
	 */
	sef_local_startup();

	/*
	 * Run the main loop.
	 */
	chardriver_task(&driver);
	return OK;
}



/* ============================================================================
 * SOURCE 26/98: minix4\exokernel\kernel_legacy\include\main.c
 * Size: 4,638 bytes, Lines: 260
 * Hash: a36546d19993...
 * ============================================================================ */

/* Copyright (c) 1979 Regents of the University of California */
#
/*
 * pi - Pascal interpreter code translator
 *
 * Charles Haley, Bill Joy UCB
 * Version 1.2 January 1979
 */

#include "0.h"

/*
 * This program is described in detail in the "PI 1.0 Implementation Notes"
 *
 * This version of pi has been in use at Berkeley since May 1977
 * and is very stable, except for the syntactic error recovery which
 * has just been written.  Please report any problems with the error
 * recovery to the second author at the address given in the file
 * READ_ME.  The second author takes full responsibility for any bugs
 * in the syntactic error recovery.
 */

char	piusage[]	"pi [ -blnpstuw ] [ -i file ... ] name.p";
char	pixusage[]	"pix [ -blnpstuw ] [ -i file ... ] name.p [ arg ... ]";

char	*usageis	piusage;
char	*obj		"obj";
/*
 * Be careful changing errfile and howfile.
 * There are the "magic" constants 9 and 15 immediately below.
 */
char	*errfile	"/usr/lib/pi1:2strings";
char	*howfile	"/usr/lib/how_pi\0";

int	onintr();

extern	int ibuf[259];

extern	char *lastname;

/*
 * Main program for pi.
 * Process options, then call yymain
 * to do all the real work.
 */
main(argc, argv)
	int argc;
	char *argv[];
{
	extern char *PI1;
	register char *cp;
	register c;
	int i;

	cp = argv[0];
	if (cp[0] == 'a')
		errfile =+ 9, howfile =+ 9;
#ifdef PC0
	if (cp[1] == 'c')
		PI1 = "/usr/lib/pc1";
#endif
	if (cp[0] == 'x')
		errfile = "/usr/lib/xpi_strings";
	if (argv[0][0] == '-' && argv[0][1] == 'o') {
		obj = &argv[0][2];
		usageis = pixusage;
		howfile[15] = 'x';
		ofil = 3;
	} else {
		ofil = creat(obj, 0755);
		if (ofil < 0) {
			perror(obj);
			pexit(NOSTART);
		}
	}
	argv++, argc--;
	if (argc == 0) {
		i = fork();
		if (i == -1)
			goto usage;
		if (i == 0) {
			execl("/bin/cat", "cat", howfile, 0);
			goto usage;
		}
		while (wait(&i) != -1)
			continue;
		pexit(NOSTART);
	}
	opt('p') = opt('t') = opt('b') = 1;
	while (argc > 0) {
		cp = argv[0];
		if (*cp++ != '-')
			break;
		while (c = *cp++) switch (c) {
#ifdef DEBUG
			case 'r':
				togopt(c);
				continue;
			case 'C':
				yycosts();
				pexit(NOSTART);
			case 'A':
				testtrace++;
			case 'F':
				fulltrace++;
			case 'E':
				errtrace++;
				opt('r')++;
				continue;
			case 'U':
				yyunique = 0;
				continue;
			case 'h':
				hp21mx++;
				continue;
#endif
			case 'b':
				opt('b') = 2;
				continue;
			case 'i':
				pflist = argv + 1;
				pflstc = 0;
				while (argc > 1) {
					if (dotted(argv[1], 'p'))
						break;
					pflstc++, argc--, argv++;
				}
				if (pflstc == 0)
					goto usage;
				continue;
			case 'c':
			case 'd':
#ifdef PC0
			case 'f':
#endif
			case 'l':
			case 'n':
			case 'p':
			case 's':
			case 't':
			case 'u':
			case 'w':
			case 'y':
			case 'z':
				togopt(c);
				continue;
			default:
usage:
				Perror( "Usage", usageis);
				pexit(NOSTART);
		}
		argc--, argv++;
	}
	if (argc != 1)
		goto usage;
	efil = open(errfile, 0);
	if (efil < 0)
		perror(errfile), pexit(NOSTART);
	filename = argv[0];
	if (!dotted(filename, 'p')) {
		Perror(filename, "Name must end in '.p'");
		pexit(NOSTART);
	}
	close(0);
	if (fopen(filename, ibuf) < 0)
		perror(filename), pexit(NOSTART);
	if ((signal(2, 1) & 01) == 0)
		signal(2, onintr);
	if (opt('l')) {
		opt('n')++;
		yysetfile(filename);
		opt('n')--;
	} else
		lastname = filename;
	yymain();
	/* No return */
}

/*
 * Buffer for putchar
 */
char	pcbuf[128];
char	*pcbp pcbuf;

/*
 * Line buffered putchar for pi.
 */
putchar(c)
	char c;
{

	*pcbp++ = c;
	if (c == '\n' || pcbp == &pcbuf[sizeof pcbuf-1]) {
		write(1, &pcbuf, pcbp-pcbuf);
		pcbp = pcbuf;
	}
}

char	ugh[]	"Fatal error in pi\n";
/*
 * Exit from the Pascal system.
 * We throw in an ungraceful termination
 * message if c > 1 indicating a severe
 * error such as running out of memory
 * or an internal inconsistency.
 */
pexit(c)
	int c;
{

	if (opt('l') && c != DIED && c != NOSTART)
		while (getline() != -1)
			continue;
	yyflush();
	switch (c) {
		case DIED:
			write(2, ugh, sizeof ugh);
		case NOSTART:
		case ERRS:
			if (ofil > 0)
				unlink(obj);
			send(RKILL);
			break;
		case AOK:
			break;
	}
	exit(c);
}

onintr()
{

	signal(2, 1);
	pexit(NOSTART);
}

/*
 * Get an error message from the error message file
 */
geterr(seekpt, buf)
	int seekpt;
	char *buf;
{

	if (seek(efil, seekpt, 0) || read(efil, buf, 256) <= 0)
		perror(errfile), pexit(DIED);
}

header()
{
	extern char version[];
	static char anyheaders;

	gettime();
	if (anyheaders && opt('n'))
		putchar('\f');
	anyheaders++;
	printf("Berkeley Pascal PI -- Version 1.2 (%s)\n\n%s  %s\n\n", version, myctime(tvec), filename);
}



/* ============================================================================
 * SOURCE 27/98: minix4\exokernel\kernel_legacy\uts\common\os\main.c
 * Size: 17,845 bytes, Lines: 693
 * Hash: 3ceaae29f230...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (c) 1988, 2010, Oracle and/or its affiliates. All rights reserved.
 */

/*	Copyright (c) 1988 AT&T	*/
/*	  All Rights Reserved		*/

/*
 * Copyright 2019 Joyent, Inc.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/sysmacros.h>
#include <sys/pcb.h>
#include <sys/systm.h>
#include <sys/signal.h>
#include <sys/cred.h>
#include <sys/user.h>
#include <sys/vfs.h>
#include <sys/vnode.h>
#include <sys/proc.h>
#include <sys/time.h>
#include <sys/file.h>
#include <sys/priocntl.h>
#include <sys/procset.h>
#include <sys/disp.h>
#include <sys/callo.h>
#include <sys/callb.h>
#include <sys/debug.h>
#include <sys/conf.h>
#include <sys/bootconf.h>
#include <sys/utsname.h>
#include <sys/cmn_err.h>
#include <sys/vmparam.h>
#include <sys/modctl.h>
#include <sys/vm.h>
#include <sys/callb.h>
#include <sys/ddi_periodic.h>
#include <sys/kmem.h>
#include <sys/vmem.h>
#include <sys/cpuvar.h>
#include <sys/cladm.h>
#include <sys/corectl.h>
#include <sys/exec.h>
#include <sys/syscall.h>
#include <sys/reboot.h>
#include <sys/task.h>
#include <sys/exacct.h>
#include <sys/autoconf.h>
#include <sys/errorq.h>
#include <sys/class.h>
#include <sys/stack.h>
#include <sys/brand.h>
#include <sys/mmapobj.h>
#include <sys/smt.h>

#include <vm/as.h>
#include <vm/seg_kmem.h>
#include <sys/dc_ki.h>

#include <c2/audit.h>
#include <sys/bootprops.h>

/* well known processes */
proc_t *proc_sched;		/* memory scheduler */
proc_t *proc_init;		/* init */
proc_t *proc_pageout;		/* pageout daemon */
proc_t *proc_fsflush;		/* fsflush daemon */

pgcnt_t	maxmem;		/* Maximum available memory in pages.	*/
pgcnt_t	freemem;	/* Current available memory in pages.	*/
int	interrupts_unleashed;	/* set when we do the first spl0() */

kmem_cache_t *process_cache;	/* kmem cache for proc structures */

/*
 * Indicates whether the auditing module (c2audit) is loaded. Possible
 * values are:
 * 0 - c2audit module is excluded in /etc/system and cannot be loaded
 * 1 - c2audit module is not loaded but can be anytime
 * 2 - c2audit module is loaded
 */
int audit_active = C2AUDIT_DISABLED;

/*
 * Process 0's lwp directory and lwpid hash table.
 */
lwpdir_t p0_lwpdir[2];
tidhash_t p0_tidhash[2];
lwpent_t p0_lep;

/*
 * Machine-independent initialization code
 * Called from cold start routine as
 * soon as a stack and segmentation
 * have been established.
 * Functions:
 *	clear and free user core
 *	turn on clock
 *	hand craft 0th process
 *	call all initialization routines
 *	fork	- process 0 to schedule
 *		- process 1 execute bootstrap
 *		- process 2 to page out
 *	create system threads
 */

int cluster_bootflags = 0;

void
cluster_wrapper(void)
{
	cluster();
	panic("cluster()  returned");
}

char initname[INITNAME_SZ] = "/sbin/init";	/* also referenced by zone0 */
char initargs[BOOTARGS_MAX] = "";		/* also referenced by zone0 */

/*
 * Construct a stack for init containing the arguments to it, then
 * pass control to exec_common.
 */
int
exec_init(const char *initpath, const char *args)
{
	uintptr_t ucp;
	uintptr_t uap;
	uintptr_t *argv;
	uintptr_t exec_fnamep;
	char *scratchargs;
	int i, sarg;
	size_t argvlen, alen;
	size_t wlen = sizeof (uintptr_t);
	boolean_t in_arg;
	int argc = 0;
	int error = 0, count = 0;
	proc_t *p = ttoproc(curthread);
	klwp_t *lwp = ttolwp(curthread);
	int brand_action = EBA_NONE;

	if (args == NULL)
		args = "";

	alen = strlen(initpath) + 1 + strlen(args) + 1;
	scratchargs = kmem_alloc(alen, KM_SLEEP);
	(void) snprintf(scratchargs, alen, "%s %s", initpath, args);

	/*
	 * We do a quick two state parse of the string to sort out how big
	 * argc should be.
	 */
	in_arg = B_FALSE;
	for (i = 0; i < strlen(scratchargs); i++) {
		if (scratchargs[i] == ' ' || scratchargs[i] == '\0') {
			if (in_arg) {
				in_arg = B_FALSE;
				argc++;
			}
		} else {
			in_arg = B_TRUE;
		}
	}
	argvlen = sizeof (uintptr_t) * (argc + 1);
	argv = kmem_zalloc(argvlen, KM_SLEEP);

	/*
	 * We pull off a bit of a hack here.  We work our way through the
	 * args string, putting nulls at the ends of space delimited tokens
	 * (boot args don't support quoting at this time).  Then we just
	 * copy the whole mess to userland in one go.  In other words, we
	 * transform this: "init -s -r\0" into this on the stack:
	 *
	 *	-0x00 \0
	 *	-0x01 r
	 *	-0x02 -  <--------.
	 *	-0x03 \0	  |
	 *	-0x04 s		  |
	 *	-0x05 -  <------. |
	 *	-0x06 \0	| |
	 *	-0x07 t		| |
	 *	-0x08 i		| |
	 *	-0x09 n		| |
	 *	-0x0a i  <---.  | |
	 *	-0x10 NULL   |  | |	(argv[3])
	 *	-0x14   -----|--|-'	(argv[2])
	 *	-0x18  ------|--'	(argv[1])
	 *	-0x1c -------'		(argv[0])
	 *
	 * Since we know the value of ucp at the beginning of this process,
	 * we can trivially compute the argv[] array which we also need to
	 * place in userland: argv[i] = ucp - sarg(i), where ucp is the
	 * stack ptr, and sarg is the string index of the start of the
	 * argument.
	 */
	ucp = (uintptr_t)p->p_usrstack;

	argc = 0;
	in_arg = B_FALSE;
	sarg = 0;

	for (i = 0; i < alen; i++) {
		if (scratchargs[i] == ' ' || scratchargs[i] == '\0') {
			if (in_arg == B_TRUE) {
				in_arg = B_FALSE;
				scratchargs[i] = '\0';
				argv[argc++] = ucp - (alen - sarg);
			}
		} else if (in_arg == B_FALSE) {
			in_arg = B_TRUE;
			sarg = i;
		}
	}

	exec_fnamep = argv[0];

	ucp -= alen;
	error |= copyout(scratchargs, (caddr_t)ucp, alen);

	if (p->p_model == DATAMODEL_ILP32) {
		uintptr32_t *argv32;

		argv32 = kmem_zalloc(argvlen / 2, KM_SLEEP);

		for (i = 0; i < argc; i++)
			argv32[i] = (uintptr32_t)argv[i];

		kmem_free(argv, argvlen);
		argv = (uintptr_t *)argv32;
		argvlen /= 2;

		wlen = sizeof (uintptr32_t);
	}

	uap = P2ALIGN(ucp, wlen);
	/* advance to be below the word we're in */
	uap -= wlen;
	/* advance argc words down, plus one for NULL */
	uap -= (argc + 1) * wlen;
	error |= copyout(argv, (caddr_t)uap, argvlen);

	if (error != 0) {
		zcmn_err(p->p_zone->zone_id, CE_WARN,
		    "Could not construct stack for init.\n");
		kmem_free(argv, argvlen);
		kmem_free(scratchargs, alen);
		return (EFAULT);
	}

	kmem_free(argv, argvlen);
	kmem_free(scratchargs, alen);

	/*
	 * Point at the arguments.
	 */
	lwp->lwp_ap = lwp->lwp_arg;
	lwp->lwp_arg[0] = exec_fnamep;
	lwp->lwp_arg[1] = uap;
	lwp->lwp_arg[2] = 0;
	curthread->t_post_sys = 1;
	curthread->t_sysnum = SYS_execve;

	/*
	 * If we are executing init from zsched, we may have inherited its
	 * parent process's signal mask.  Clear it now so that we behave in
	 * the same way as when started from the global zone.
	 */
	sigemptyset(&curthread->t_hold);

	/*
	 * Only instruct exec_common to brand the process if necessary.  It is
	 * possible that the init process is already properly branded due to the
	 * proc_exit -> restart_init -> exec_init call chain.
	 */
	if (ZONE_IS_BRANDED(p->p_zone) &&
	    p->p_brand != p->p_zone->zone_brand) {
		brand_action = EBA_BRAND;
	}
again:
	error = exec_common((const char *)exec_fnamep,
	    (const char **)uap, NULL, NULL, brand_action);

	/*
	 * Normally we would just set lwp_argsaved and t_post_sys and
	 * let post_syscall reset lwp_ap for us.  Unfortunately,
	 * exec_init isn't always called from a system call.  Instead
	 * of making a mess of trap_cleanup, we just reset the args
	 * pointer here.
	 */
	reset_syscall_args();

	switch (error) {
	case 0:
		return (0);

	case ENOENT:
		zcmn_err(p->p_zone->zone_id, CE_WARN,
		    "exec(%s) failed (file not found).\n", initpath);
		return (ENOENT);

	case EAGAIN:
	case EINTR:
		++count;
		if (count < 5) {
			zcmn_err(p->p_zone->zone_id, CE_WARN,
			    "exec(%s) failed with errno %d.  Retrying...\n",
			    initpath, error);
			goto again;
		}
	}

	zcmn_err(p->p_zone->zone_id, CE_WARN,
	    "exec(%s) failed with errno %d.", initpath, error);
	return (error);
}

/*
 * This routine does all of the common setup for invoking init; global
 * and non-global zones employ this routine for the functionality which is
 * in common.
 *
 * This program (init, presumably) must be a 32-bit process.
 */
int
start_init_common()
{
	proc_t *p = curproc;
	ASSERT_STACK_ALIGNED();
	p->p_zone->zone_proc_initpid = p->p_pid;

	p->p_cstime = p->p_stime = p->p_cutime = p->p_utime = 0;
	p->p_usrstack = (caddr_t)USRSTACK32;
	p->p_model = DATAMODEL_ILP32;
	p->p_stkprot = PROT_ZFOD & ~PROT_EXEC;
	p->p_datprot = PROT_ZFOD & ~PROT_EXEC;
	p->p_stk_ctl = INT32_MAX;

	p->p_as = as_alloc();
	p->p_as->a_proc = p;
	p->p_as->a_userlimit = (caddr_t)USERLIMIT32;
	(void) hat_setup(p->p_as->a_hat, HAT_INIT);

	init_core();

	init_mstate(curthread, LMS_SYSTEM);
	return (exec_init(p->p_zone->zone_initname, p->p_zone->zone_bootargs));
}

/*
 * Start the initial user process for the global zone; once running, if
 * init should subsequently fail, it will be automatically be caught in the
 * exit(2) path, and restarted by restart_init().
 */
static void
start_init(void)
{
	proc_init = curproc;

	ASSERT(curproc->p_zone->zone_initname != NULL);

	if (start_init_common() != 0)
		halt("unix: Could not start init");
	lwp_rtt();
}

void
main(void)
{
	proc_t		*p = ttoproc(curthread);	/* &p0 */
	int		(**initptr)();
	extern void	sched();
	extern void	fsflush();
	extern int	(*init_tbl[])();
	extern int	(*mp_init_tbl[])();
	extern id_t	syscid, defaultcid;
	extern int	swaploaded;
	extern int	netboot;
	extern ib_boot_prop_t *iscsiboot_prop;
	extern void	vm_init(void);
	extern void	cbe_init_pre(void);
	extern void	cbe_init(void);
	extern void	clock_tick_init_pre(void);
	extern void	clock_tick_init_post(void);
	extern void	clock_init(void);
	extern void	physio_bufs_init(void);
	extern void	pm_cfb_setup_intr(void);
	extern int	pm_adjust_timestamps(dev_info_t *, void *);
	extern void	start_other_cpus(int);
	extern void	sysevent_evc_thrinit();
	extern kmutex_t	ualock;
#if defined(__x86)
	extern void	fastboot_post_startup(void);
	extern void	progressbar_start(void);
#endif
	/*
	 * In the horrible world of x86 in-lines, you can't get symbolic
	 * structure offsets a la genassym.  This assertion is here so
	 * that the next poor slob who innocently changes the offset of
	 * cpu_thread doesn't waste as much time as I just did finding
	 * out that it's hard-coded in i86/ml/i86.il.  Similarly for
	 * curcpup.  You're welcome.
	 */
	ASSERT(CPU == CPU->cpu_self);
	ASSERT(curthread == CPU->cpu_thread);
	ASSERT_STACK_ALIGNED();

	/*
	 * We take the ualock until we have completed the startup
	 * to prevent kadmin() from disrupting this work. In particular,
	 * we don't want kadmin() to bring the system down while we are
	 * trying to start it up.
	 */
	mutex_enter(&ualock);

	/*
	 * Setup root lgroup and leaf lgroup for CPU 0
	 */
	lgrp_init(LGRP_INIT_STAGE2);

	/*
	 * Once 'startup()' completes, the thread_reaper() daemon would be
	 * created(in thread_init()). After that, it is safe to create threads
	 * that could exit. These exited threads will get reaped.
	 */
	startup();
	segkmem_gc();
	callb_init();
	cbe_init_pre();	/* x86 must initialize gethrtimef before timer_init */
	ddi_periodic_init();
	cbe_init();
	callout_init();	/* callout table MUST be init'd after cyclics */
	clock_tick_init_pre();
	clock_init();

#if defined(__x86)
	/*
	 * The progressbar thread uses cv_reltimedwait() and hence needs to be
	 * started after the callout mechanism has been initialized.
	 */
	progressbar_start();
#endif
	/*
	 * On some platforms, clkinitf() changes the timing source that
	 * gethrtime_unscaled() uses to generate timestamps.  cbe_init() calls
	 * clkinitf(), so re-initialize the microstate counters after the
	 * timesource has been chosen.
	 */
	init_mstate(&t0, LMS_SYSTEM);
	init_cpu_mstate(CPU, CMS_SYSTEM);

	/*
	 * May need to probe to determine latencies from CPU 0 after
	 * gethrtime() comes alive in cbe_init() and before enabling interrupts
	 * and copy and release any temporary memory allocated with BOP_ALLOC()
	 * before release_bootstrap() frees boot memory
	 */
	lgrp_init(LGRP_INIT_STAGE3);

	/*
	 * Call all system initialization functions.
	 */
	for (initptr = &init_tbl[0]; *initptr; initptr++)
		(**initptr)();
	/*
	 * Load iSCSI boot properties
	 */
	ld_ib_prop();
	/*
	 * initialize vm related stuff.
	 */
	vm_init();

	/*
	 * initialize buffer pool for raw I/O requests
	 */
	physio_bufs_init();

	ttolwp(curthread)->lwp_error = 0; /* XXX kludge for SCSI driver */

	/*
	 * Drop the interrupt level and allow interrupts.  At this point
	 * the DDI guarantees that interrupts are enabled.
	 */
	(void) spl0();
	interrupts_unleashed = 1;

	/*
	 * Create kmem cache for proc structures
	 */
	process_cache = kmem_cache_create("process_cache", sizeof (proc_t),
	    0, NULL, NULL, NULL, NULL, NULL, 0);

	vfs_mountroot();	/* Mount the root file system */
	errorq_init();		/* after vfs_mountroot() so DDI root is ready */
	cpu_kstat_init(CPU);	/* after vfs_mountroot() so TOD is valid */
	ddi_walk_devs(ddi_root_node(), pm_adjust_timestamps, NULL);
				/* after vfs_mountroot() so hrestime is valid */

	post_startup();
	swaploaded = 1;

	/*
	 * Initialize Solaris Audit Subsystem
	 */
	audit_init();

	/*
	 * Start the periodic hash rescale for all vmem arenas before we load
	 * protocol modules and drivers via strplumb() below.  Some drivers
	 * might rely on heavy vmem operations that could hurt performance
	 * without the rescale.
	 */
	vmem_update(NULL);

	/*
	 * Plumb the protocol modules and drivers only if we are not
	 * networked booted, in this case we already did it in rootconf().
	 */
	if (netboot == 0 && iscsiboot_prop == NULL)
		(void) strplumb();

	gethrestime(&PTOU(curproc)->u_start);
	curthread->t_start = PTOU(curproc)->u_start.tv_sec;
	p->p_mstart = gethrtime();

	/*
	 * Perform setup functions that can only be done after root
	 * and swap have been set up.
	 */
	consconfig();
#ifndef	__sparc
	release_bootstrap();
#endif

	/*
	 * attach drivers with ddi-forceattach prop
	 * It must be done early enough to load hotplug drivers (e.g.
	 * pcmcia nexus) so that devices enumerated via hotplug is
	 * available before I/O subsystem is fully initialized.
	 */
	i_ddi_forceattach_drivers();

	/*
	 * Set the scan rate and other parameters of the paging subsystem.
	 */
	setupclock();

	/*
	 * Initialize process 0's lwp directory and lwpid hash table.
	 */
	p->p_lwpdir = p->p_lwpfree = p0_lwpdir;
	p->p_lwpdir->ld_next = p->p_lwpdir + 1;
	p->p_lwpdir_sz = 2;
	p->p_tidhash = p0_tidhash;
	p->p_tidhash_sz = 2;
	p0_lep.le_thread = curthread;
	p0_lep.le_lwpid = curthread->t_tid;
	p0_lep.le_start = curthread->t_start;
	lwp_hash_in(p, &p0_lep, p0_tidhash, 2, 0);

	/*
	 * Initialize extended accounting.
	 */
	exacct_init();

	/*
	 * Initialize threads of sysevent event channels
	 */
	sysevent_evc_thrinit();

	/*
	 * This must be done after post_startup() but before
	 * start_other_cpus()
	 */
	lgrp_init(LGRP_INIT_STAGE4);

	/*
	 * Perform MP initialization, if any.
	 */
	start_other_cpus(0);

#ifdef	__sparc
	/*
	 * Release bootstrap here since PROM interfaces are
	 * used to start other CPUs above.
	 */
	release_bootstrap();
#endif

	/*
	 * Finish lgrp initialization after all CPUS are brought online.
	 */
	lgrp_init(LGRP_INIT_STAGE5);

	/*
	 * After mp_init(), number of cpus are known (this is
	 * true for the time being, when there are actually
	 * hot pluggable cpus then this scheme  would not do).
	 * Any per cpu initialization is done here.
	 */
	kmem_mp_init();

	clock_tick_init_post();

	for (initptr = &mp_init_tbl[0]; *initptr; initptr++)
		(**initptr)();

	/*
	 * These must be called after start_other_cpus
	 */
	pm_cfb_setup_intr();
#if defined(__x86)
	fastboot_post_startup();

	smt_late_init();
#endif

	/*
	 * Make init process; enter scheduling loop with system process.
	 *
	 * Note that we manually assign the pids for these processes, for
	 * historical reasons.  If more pre-assigned pids are needed,
	 * FAMOUS_PIDS will have to be updated.
	 */

	/* create init process */
	if (newproc(start_init, NULL, defaultcid, 59, NULL,
	    FAMOUS_PID_INIT))
		panic("main: unable to fork init.");

	/* create pageout daemon */
	if (newproc(pageout, NULL, syscid, maxclsyspri - 1, NULL,
	    FAMOUS_PID_PAGEOUT))
		panic("main: unable to fork pageout()");

	/* create fsflush daemon */
	if (newproc(fsflush, NULL, syscid, minclsyspri, NULL,
	    FAMOUS_PID_FSFLUSH))
		panic("main: unable to fork fsflush()");

	/* create cluster process if we're a member of one */
	if (cluster_bootflags & CLUSTER_BOOTED) {
		if (newproc(cluster_wrapper, NULL, syscid, minclsyspri,
		    NULL, 0)) {
			panic("main: unable to fork cluster()");
		}
	}

	/*
	 * Create system threads (threads are associated with p0)
	 */

	/* create module uninstall daemon */
	/* BugID 1132273. If swapping over NFS need a bigger stack */
	(void) thread_create(NULL, 0, (void (*)())mod_uninstall_daemon,
	    NULL, 0, &p0, TS_RUN, minclsyspri);

	(void) thread_create(NULL, 0, seg_pasync_thread,
	    NULL, 0, &p0, TS_RUN, minclsyspri);

	pid_setmin();

	/* system is now ready */
	mutex_exit(&ualock);

	bcopy("sched", PTOU(curproc)->u_psargs, 6);
	bcopy("sched", PTOU(curproc)->u_comm, 5);
	sched();
	/* NOTREACHED */
}



/* ============================================================================
 * SOURCE 28/98: minix4\exokernel\kernel_legacy\tools\cscope-fast\main.c
 * Size: 42,185 bytes, Lines: 1,621
 * Hash: 1abebf5f0d84...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*	Copyright (c) 1988 AT&T	*/
/*	  All Rights Reserved  	*/


/*
 * Copyright 2005 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

/*
 *	cscope - interactive C symbol cross-reference
 *
 *	main functions
 */

#include <curses.h>	/* stdscr and TRUE */
#include <fcntl.h>	/* O_RDONLY */
#include <sys/types.h>	/* needed by stat.h */
#include <unistd.h>	/* O_RDONLY */
#include <unistd.h>	/* O_RDONLY */
#include <sys/stat.h>	/* stat */
#include <libgen.h>	/* O_RDONLY */
#include "global.h"
#include "version.h"	/* FILEVERSION and FIXVERSION */
#include "vp.h"		/* vpdirs and vpndirs */

#define	OPTSEPS	" \t"	/* CSCOPEOPTION separators */
#define	MINHOURS 4	/* minimum no activity timeout hours */

/* defaults for unset environment variables */
#define	EDITOR	"vi"
#define	SHELL	"sh"
#define	TMPDIR	"/tmp"

/*
 * note: these digraph character frequencies were calculated from possible
 * printable digraphs in the cross-reference for the C compiler
 */
char	dichar1[] = " teisaprnl(of)=c";	/* 16 most frequent first chars */
char	dichar2[] = " tnerpla";		/* 8 most frequent second chars */
					/* using the above as first chars */
char	dicode1[256];		/* digraph first character code */
char	dicode2[256];		/* digraph second character code */

char	*editor, *home, *shell;	/* environment variables */
BOOL	compress = YES;		/* compress the characters in the crossref */
int	cscopedepth;		/* cscope invocation nesting depth */
char	currentdir[PATHLEN + 1]; /* current directory */
BOOL	dbtruncated;		/* database symbols are truncated to 8 chars */
char	**dbvpdirs;		/* directories (including current) in */
				/* database view path */
int	dbvpndirs;		/* # of directories in database view path */
int	dispcomponents = 1;	/* file path components to display */
BOOL	editallprompt = YES;	/* prompt between editing files */
int	fileargc;		/* file argument count */
char	**fileargv;		/* file argument values */
int	fileversion;		/* cross-reference file version */
BOOL	incurses;		/* in curses */
INVCONTROL invcontrol;		/* inverted file control structure */
BOOL	invertedindex;		/* the database has an inverted index */
BOOL	isuptodate;		/* consider the crossref up-to-date */
BOOL	linemode;		/* use line oriented user interface */
char	*namefile;		/* file of file names */
char	*newinvname;		/* new inverted index file name */
char	*newinvpost;		/* new inverted index postings file name */
char	*newreffile;		/* new cross-reference file name */
FILE	*newrefs;		/* new cross-reference */
BOOL	noacttimeout;		/* no activity timeout occurred */
BOOL	ogs;			/* display OGS book and subsystem names */
FILE	*postings;		/* new inverted index postings */
char	*prependpath;		/* prepend path to file names */
BOOL	returnrequired;		/* RETURN required after selection number */
int	symrefs = -1;		/* cross-reference file */
char	temp1[PATHLEN + 1];	/* temporary file name */
char	temp2[PATHLEN + 1];	/* temporary file name */
long	totalterms;		/* total inverted index terms */
BOOL	truncatesyms;		/* truncate symbols to 8 characters */

static	BOOL	buildonly;		/* only build the database */
static	BOOL	fileschanged;		/* assume some files changed */
static	char	*invname = INVNAME;	/* inverted index to the database */
static	char	*invpost = INVPOST;	/* inverted index postings */
static	unsigned noacttime;		/* no activity timeout in seconds */
static	BOOL	onesearch;		/* one search only in line mode */
static	char	*reffile = REFFILE;	/* cross-reference file path name */
static	char	*reflines;		/* symbol reference lines file */
static	char	*tmpdir;		/* temporary directory */
static	long	traileroffset;		/* file trailer offset */
static	BOOL	unconditional;		/* unconditionally build database */

static void options(int argc, char **argv);
static void printusage(void);
static void removeindex(void);
static void cannotindex(void);
static void initcompress(void);
static void opendatabase(void);
static void closedatabase(void);
static void build(void);
static int compare(const void *s1, const void *s2);
static char *getoldfile(void);
static void putheader(char *dir);
static void putlist(char **names, int count);
static BOOL samelist(FILE *oldrefs, char **names, int count);
static void skiplist(FILE *oldrefs);
static void copydata(void);
static void copyinverted(void);
static void putinclude(char *s);
static void movefile(char *new, char *old);
static void timedout(int sig);

int
main(int argc, char **argv)
{
	int	envc;			/* environment argument count */
	char	**envv;			/* environment argument list */
	FILE	*names;			/* name file pointer */
	int	oldnum;			/* number in old cross-ref */
	char	path[PATHLEN + 1];	/* file path */
	FILE	*oldrefs;	/* old cross-reference file */
	char	*s;
	int	c, i;
	pid_t	pid;

	/* save the command name for messages */
	argv0 = basename(argv[0]);

	/* get the current directory for build() and line-oriented P command */
	if (mygetwd(currentdir) == NULL) {
		(void) fprintf(stderr,
		    "cscope: warning: cannot get current directory name\n");
		(void) strcpy(currentdir, "<unknown>");
	}
	/* initialize any view path; (saves time since currendir is known) */
	vpinit(currentdir);
	dbvpndirs = vpndirs; /* number of directories in database view path */
	/* directories (including current) in database view path */
	dbvpdirs = vpdirs;

	/* the first source directory is the current directory */
	sourcedir(".");

	/* read the environment */
	editor = mygetenv("EDITOR", EDITOR);
	editor = mygetenv("VIEWER", editor);	/* use viewer if set */
	home = getenv("HOME");
	shell = mygetenv("SHELL", SHELL);
	tmpdir = mygetenv("TMPDIR", TMPDIR);
	/* increment nesting depth */
	cscopedepth = atoi(mygetenv("CSCOPEDEPTH", "0"));
	(void) sprintf(path, "CSCOPEDEPTH=%d", ++cscopedepth);
	(void) putenv(stralloc(path));
	if ((s = getenv("CSCOPEOPTIONS")) != NULL) {

		/* parse the environment option string */
		envc = 1;
		envv = mymalloc(sizeof (char *));
		s = strtok(stralloc(s), OPTSEPS);
		while (s != NULL) {
			envv = myrealloc(envv, ++envc * sizeof (char *));
			envv[envc - 1] = stralloc(s);
			s = strtok((char *)NULL, OPTSEPS);
		}
		/* set the environment options */
		options(envc, envv);
	}
	/* set the command line options */
	options(argc, argv);

	/* create the temporary file names */
	pid = getpid();
	(void) sprintf(temp1, "%s/cscope%d.1", tmpdir, (int)pid);
	(void) sprintf(temp2, "%s/cscope%d.2", tmpdir, (int)pid);

	/* if running in the foreground */
	if (signal(SIGINT, SIG_IGN) != SIG_IGN) {

		/* cleanup on the interrupt and quit signals */
		(void) signal(SIGINT, myexit);
		(void) signal(SIGQUIT, myexit);
	}

	/* cleanup on the hangup signal */
	(void) signal(SIGHUP, myexit);
	/* if the database path is relative and it can't be created */
	if (reffile[0] != '/' && access(".", WRITE) != 0) {

		/* if the database may not be up-to-date or can't be read */
		(void) sprintf(path, "%s/%s", home, reffile);
		if (isuptodate == NO || access(reffile, READ) != 0) {

			/* put it in the home directory */
			reffile = stralloc(path);
			(void) sprintf(path, "%s/%s", home, invname);
			invname = stralloc(path);
			(void) sprintf(path, "%s/%s", home, invpost);
			invpost = stralloc(path);
			(void) fprintf(stderr,
			    "cscope: symbol database will be %s\n", reffile);
		}
	}
	/* if the cross-reference is to be considered up-to-date */
	if (isuptodate == YES) {
		if ((oldrefs = vpfopen(reffile, "r")) == NULL) {
			cannotopen(reffile);
			exit(1);
		}
		/*
		 * get the crossref file version but skip the current
		 * directory
		 */
		if (fscanf(oldrefs, "cscope %d %*s", &fileversion) != 1) {
			(void) fprintf(stderr,
			    "cscope: cannot read file version from file %s\n",
			    reffile);
			exit(1);
		}
		if (fileversion >= 8) {

			/* override these command line options */
			compress = YES;
			invertedindex = NO;

			/* see if there are options in the database */
			for (;;) {
				/* no -q leaves multiple blanks */
				while ((c = getc(oldrefs)) == ' ') {
					;
				}
				if (c != '-') {
					(void) ungetc(c, oldrefs);
					break;
				}
				switch (c = getc(oldrefs)) {
				case 'c':	/* ASCII characters only */
					compress = NO;
					break;
				case 'q':	/* quick search */
					invertedindex = YES;
					(void) fscanf(oldrefs,
					    "%ld", &totalterms);
					break;
				case 'T':
					/* truncate symbols to 8 characters */
					dbtruncated = YES;
					truncatesyms = YES;
					break;
				}
			}
			initcompress();

			/* seek to the trailer */
			if (fscanf(oldrefs, "%ld", &traileroffset) != 1) {
				(void) fprintf(stderr,
				    "cscope: cannot read trailer offset from "
				    "file %s\n", reffile);
				exit(1);
			}
			if (fseek(oldrefs, traileroffset, 0) != 0) {
				(void) fprintf(stderr,
				    "cscope: cannot seek to trailer in "
				    "file %s\n", reffile);
				exit(1);
			}
		}
		/*
		 * read the view path for use in converting relative paths to
		 * full paths
		 *
		 * note: don't overwrite vp[n]dirs because this can cause
		 * the wrong database index files to be found in the viewpath
		 */
		if (fileversion >= 13) {
			if (fscanf(oldrefs, "%d", &dbvpndirs) != 1) {
				(void) fprintf(stderr,
				    "cscope: cannot read view path size from "
				    "file %s\n", reffile);
				exit(1);
			}
			if (dbvpndirs > 0) {
				dbvpdirs = mymalloc(
				    dbvpndirs * sizeof (char *));
				for (i = 0; i < dbvpndirs; ++i) {
					if (fscanf(oldrefs, "%s", path) != 1) {
						(void) fprintf(stderr,
						    "cscope: cannot read view "
						    "path from file %s\n",
						    reffile);
						exit(1);
					}
					dbvpdirs[i] = stralloc(path);
				}
			}
		}
		/* skip the source and include directory lists */
		skiplist(oldrefs);
		skiplist(oldrefs);

		/* get the number of source files */
		if (fscanf(oldrefs, "%d", &nsrcfiles) != 1) {
			(void) fprintf(stderr,
			    "cscope: cannot read source file size from "
			    "file %s\n", reffile);
			exit(1);
		}
		/* get the source file list */
		srcfiles = mymalloc(nsrcfiles * sizeof (char *));
		if (fileversion >= 9) {

			/* allocate the string space */
			if (fscanf(oldrefs, "%d", &oldnum) != 1) {
				(void) fprintf(stderr,
				    "cscope: cannot read string space size "
				    "from file %s\n", reffile);
				exit(1);
			}
			s = mymalloc(oldnum);
			(void) getc(oldrefs);	/* skip the newline */

			/* read the strings */
			if (fread(s, oldnum, 1, oldrefs) != 1) {
				(void) fprintf(stderr,
				    "cscope: cannot read source file names "
				    "from file %s\n", reffile);
				exit(1);
			}
			/* change newlines to nulls */
			for (i = 0; i < nsrcfiles; ++i) {
				srcfiles[i] = s;
				for (++s; *s != '\n'; ++s) {
					;
				}
				*s = '\0';
				++s;
			}
			/* if there is a file of source file names */
			if (namefile != NULL &&
			    (names = vpfopen(namefile, "r")) != NULL ||
			    (names = vpfopen(NAMEFILE, "r")) != NULL) {

				/* read any -p option from it */
				while (fscanf(names, "%s", path) == 1 &&
				    *path == '-') {
					i = path[1];
					s = path + 2;	/* for "-Ipath" */
					if (*s == '\0') {
						/* if "-I path" */
						(void) fscanf(names,
						    "%s", path);
						s = path;
					}
					switch (i) {
					case 'p':
						/* file path components */
						/* to display */
						if (*s < '0' || *s > '9') {
							(void) fprintf(stderr,
							    "cscope: -p option "
							    "in file %s: "
							    "missing or "
							    "invalid numeric "
							    "value\n",
							    namefile);
						}
						dispcomponents = atoi(s);
					}
				}
				(void) fclose(names);
			}
		} else {
			for (i = 0; i < nsrcfiles; ++i) {
				if (fscanf(oldrefs, "%s", path) != 1) {
					(void) fprintf(stderr,
					    "cscope: cannot read source file "
					    "name from file %s\n", reffile);
					exit(1);
				}
				srcfiles[i] = stralloc(path);
			}
		}
		(void) fclose(oldrefs);
	} else {
		/* get source directories from the environment */
		if ((s = getenv("SOURCEDIRS")) != NULL) {
			sourcedir(s);
		}
		/* make the source file list */
		srcfiles = mymalloc(msrcfiles * sizeof (char *));
		makefilelist();
		if (nsrcfiles == 0) {
			(void) fprintf(stderr,
			    "cscope: no source files found\n");
			printusage();
			exit(1);
		}
		/* get include directories from the environment */
		if ((s = getenv("INCLUDEDIRS")) != NULL) {
			includedir(s);
		}
		/* add /usr/include to the #include directory list */
		includedir("/usr/include");

		/* initialize the C keyword table */
		initsymtab();

		/* create the file name(s) used for a new cross-reference */
		(void) strcpy(path, reffile);
		s = basename(path);
		*s = '\0';
		(void) strcat(path, "n");
		++s;
		(void) strcpy(s, basename(reffile));
		newreffile = stralloc(path);
		(void) strcpy(s, basename(invname));
		newinvname = stralloc(path);
		(void) strcpy(s, basename(invpost));
		newinvpost = stralloc(path);

		/* build the cross-reference */
		initcompress();
		build();
		if (buildonly == YES) {
			exit(0);
		}
	}
	opendatabase();

	/*
	 * removing a database will not release the disk space if a cscope
	 * process has the file open, so a project may want unattended cscope
	 * processes to exit overnight, including their subshells and editors
	 */
	if (noacttime) {
		(void) signal(SIGALRM, timedout);
		(void) alarm(noacttime);
	}
	/*
	 * if using the line oriented user interface so cscope can be a
	 * subprocess to emacs or samuel
	 */
	if (linemode == YES) {
		if (*pattern != '\0') {		/* do any optional search */
			if (search() == YES) {
				while ((c = getc(refsfound)) != EOF) {
					(void) putchar(c);
				}
			}
		}
		if (onesearch == YES) {
			myexit(0);
		}
		for (;;) {
			char buf[PATLEN + 2];
			if (noacttime) {
				(void) alarm(noacttime);
			}
			(void) printf(">> ");
			(void) fflush(stdout);
			if (fgets(buf, sizeof (buf), stdin) == NULL) {
				myexit(0);
			}
			/* remove any trailing newline character */
			if (*(s = buf + strlen(buf) - 1) == '\n') {
				*s = '\0';
			}
			switch (*buf) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	/* samuel only */
				field = *buf - '0';
				(void) strcpy(pattern, buf + 1);
				(void) search();
				(void) printf("cscope: %d lines\n", totallines);
				while ((c = getc(refsfound)) != EOF) {
					(void) putchar(c);
				}
				break;

			case 'c':	/* toggle caseless mode */
			case ctrl('C'):
				if (caseless == NO) {
					caseless = YES;
				} else {
					caseless = NO;
				}
				egrepcaseless(caseless);
				break;

			case 'r':	/* rebuild database cscope style */
			case ctrl('R'):
				freefilelist();
				makefilelist();
				/* FALLTHROUGH */

			case 'R':	/* rebuild database samuel style */
				rebuild();
				(void) putchar('\n');
				break;

			case 'C':	/* clear file names */
				freefilelist();
				(void) putchar('\n');
				break;

			case 'F':	/* add a file name */
				(void) strcpy(path, buf + 1);
				if (infilelist(path) == NO &&
				    vpaccess(path, READ) == 0) {
					addsrcfile(path);
				}
				(void) putchar('\n');
				break;

			case 'P':	/* print the path to the files */
				if (prependpath != NULL) {
					(void) puts(prependpath);
				} else {
					(void) puts(currentdir);
				}
				break;

			case 'q':	/* quit */
			case ctrl('D'):
			case ctrl('Z'):
				myexit(0);

			default:
				(void) fprintf(stderr,
				    "cscope: unknown command '%s'\n", buf);
				break;
			}
		}
		/* NOTREACHED */
	}
	/* pause before clearing the screen if there have been error messages */
	if (errorsfound == YES) {
		errorsfound = NO;
		askforreturn();
	}
	(void) signal(SIGINT, SIG_IGN);	/* ignore interrupts */
	(void) signal(SIGPIPE, SIG_IGN); /* | command can cause pipe signal */
	/* initialize the curses display package */
	(void) initscr();	/* initialize the screen */
	setfield();	/* set the initial cursor position */
	entercurses();
	(void) keypad(stdscr, TRUE);	/* enable the keypad */
	dispinit();	/* initialize display parameters */
	putmsg("");	/* clear any build progress message */
	display();	/* display the version number and input fields */

	/* do any optional search */
	if (*pattern != '\0') {
		atfield();		/* move to the input field */
		(void) command(ctrl('A'));	/* search */
		display();		/* update the display */
	} else if (reflines != NULL) {
		/* read any symbol reference lines file */
		(void) readrefs(reflines);
		display();		/* update the display */
	}
	for (;;) {
		if (noacttime) {
			(void) alarm(noacttime);
		}
		atfield();	/* move to the input field */

		/* exit if the quit command is entered */
		if ((c = mygetch()) == EOF || c == ctrl('D') ||
		    c == ctrl('Z')) {
			break;
		}
		/* execute the commmand, updating the display if necessary */
		if (command(c) == YES) {
			display();
		}
	}
	/* cleanup and exit */
	myexit(0);
	/* NOTREACHED */
	return (0);
}

static void
options(int argc, char **argv)
{
	char	path[PATHLEN + 1];	/* file path */
	int	c;
	char	*s;

	while (--argc > 0 && (*++argv)[0] == '-') {
		for (s = argv[0] + 1; *s != '\0'; s++) {
			/* look for an input field number */
			if (isdigit(*s)) {
				field = *s - '0';
				if (*++s == '\0' && --argc > 0) {
					s = *++argv;
				}
				if (strlen(s) > PATLEN) {
					(void) fprintf(stderr,
					    "cscope: pattern too long, cannot "
					    "be > %d characters\n", PATLEN);
					exit(1);
				}
				(void) strcpy(pattern, s);
				goto nextarg;
			}
			switch (*s) {
			case '-':	/* end of options */
				--argc;
				++argv;
				goto lastarg;
			case 'V':	/* print the version number */
				(void) fprintf(stderr,
				    "%s: version %d%s\n", argv0,
				    FILEVERSION, FIXVERSION);
				exit(0);
				/*NOTREACHED*/
			case 'b':	/* only build the cross-reference */
				buildonly = YES;
				break;
			case 'c':	/* ASCII characters only in crossref */
				compress = NO;
				break;
			case 'C':
				/* turn on caseless mode for symbol searches */
				caseless = YES;
				/* simulate egrep -i flag */
				egrepcaseless(caseless);
				break;
			case 'd':	/* consider crossref up-to-date */
				isuptodate = YES;
				break;
			case 'e':	/* suppress ^E prompt between files */
				editallprompt = NO;
				break;
			case 'L':
				onesearch = YES;
				/* FALLTHROUGH */
			case 'l':
				linemode = YES;
				break;
			case 'o':
				/* display OGS book and subsystem names */
				ogs = YES;
				break;
			case 'q':	/* quick search */
				invertedindex = YES;
				break;
			case 'r':	/* display as many lines as possible */
				returnrequired = YES;
				break;
			case 'T':	/* truncate symbols to 8 characters */
				truncatesyms = YES;
				break;
			case 'u':
				/* unconditionally build the cross-reference */
				unconditional = YES;
				break;
			case 'U':	/* assume some files have changed */
				fileschanged = YES;
				break;
			case 'f':	/* alternate cross-reference file */
			case 'F':	/* symbol reference lines file */
			case 'i':	/* file containing file names */
			case 'I':	/* #include file directory */
			case 'p':	/* file path components to display */
			case 'P':	/* prepend path to file names */
			case 's':	/* additional source file directory */
			case 'S':
			case 't':	/* no activity timeout in hours */
				c = *s;
				if (*++s == '\0' && --argc > 0) {
					s = *++argv;
				}
				if (*s == '\0') {
					(void) fprintf(stderr,
					    "%s: -%c option: missing or empty "
					    "value\n", argv0, c);
					goto usage;
				}
				switch (c) {
				case 'f':
					/* alternate cross-reference file */
					reffile = s;
					(void) strcpy(path, s);
					/* System V has a 14 character limit */
					s = basename(path);
					if ((int)strlen(s) > 11) {
						s[11] = '\0';
					}
					s = path + strlen(path);
					(void) strcpy(s, ".in");
					invname = stralloc(path);
					(void) strcpy(s, ".po");
					invpost = stralloc(path);
					break;
				case 'F':
					/* symbol reference lines file */
					reflines = s;
					break;
				case 'i':	/* file containing file names */
					namefile = s;
					break;
				case 'I':	/* #include file directory */
					includedir(s);
					break;
				case 'p':
					/* file path components to display */
					if (*s < '0' || *s > '9') {
						(void) fprintf(stderr,
						    "%s: -p option: missing "
						    "or invalid numeric "
						    "value\n", argv0);
						goto usage;
					}
					dispcomponents = atoi(s);
					break;
				case 'P':	/* prepend path to file names */
					prependpath = s;
					break;
				case 's':
				case 'S':
					/* additional source directory */
					sourcedir(s);
					break;
				case 't':
					/* no activity timeout in hours */
					if (*s < '1' || *s > '9') {
						(void) fprintf(stderr,
						    "%s: -t option: missing or "
						    "invalid numeric value\n",
						    argv0);
						goto usage;
					}
					c = atoi(s);
					if (c < MINHOURS) {
						(void) fprintf(stderr,
						    "cscope: minimum timeout "
						    "is %d hours\n", MINHOURS);
						(void) sleep(3);
						c = MINHOURS;
					}
					noacttime = c * 3600;
					break;
				}
				goto nextarg;
			default:
				(void) fprintf(stderr,
				    "%s: unknown option: -%c\n", argv0, *s);
			usage:
				printusage();
				exit(1);
			}
		}
nextarg:	continue;
	}
lastarg:
	/* save the file arguments */
	fileargc = argc;
	fileargv = argv;
}

static void
printusage(void)
{
	(void) fprintf(stderr,
	    "Usage:  cscope [-bcdelLoqrtTuUV] [-f file] [-F file] [-i file] "
	    "[-I dir] [-s dir]\n");
	(void) fprintf(stderr,
	    "               [-p number] [-P path] [-[0-8] pattern] "
	    "[source files]\n");
	(void) fprintf(stderr,
	    "-b		Build the database only.\n");
	(void) fprintf(stderr,
	    "-c		Use only ASCII characters in the database file, "
	    "that is,\n");
	(void) fprintf(stderr,
	    "		do not compress the data.\n");
	(void) fprintf(stderr,
	    "-d		Do not update the database.\n");
	(void) fprintf(stderr,
	    "-f \"file\"	Use \"file\" as the database file name "
	    "instead of\n");
	(void) fprintf(stderr,
	    "		the default (cscope.out).\n");
	(void) fprintf(stderr,
	    "-F \"file\"	Read symbol reference lines from file, just\n");
/* BEGIN CSTYLED */
	(void) fprintf(stderr,
	    "		like the \"<\" command.\n");
/* END CSTYLED */
	(void) fprintf(stderr,
	    "-i \"file\"	Read any -I, -p, -q, and -T options and the\n");
	(void) fprintf(stderr,
	    "		list of source files from \"file\" instead of the \n");
	(void) fprintf(stderr,
	    "		default (cscope.files).\n");
	(void) fprintf(stderr,
	    "-I \"dir\"	Look in \"dir\" for #include files.\n");
	(void) fprintf(stderr,
	    "-q		Build an inverted index for quick symbol seaching.\n");
	(void) fprintf(stderr,
	    "-s \"dir\"	Look in \"dir\" for additional source files.\n");
}

static void
removeindex(void)
{
	(void) fprintf(stderr,
	    "cscope: removed files %s and %s\n", invname, invpost);
	(void) unlink(invname);
	(void) unlink(invpost);
}

static void
cannotindex(void)
{
	(void) fprintf(stderr,
	    "cscope: cannot create inverted index; ignoring -q option\n");
	invertedindex = NO;
	errorsfound = YES;
	(void) fprintf(stderr,
	    "cscope: removed files %s and %s\n", newinvname, newinvpost);
	(void) unlink(newinvname);
	(void) unlink(newinvpost);
	removeindex();	/* remove any existing index to prevent confusion */
}

void
cannotopen(char *file)
{
	char	msg[MSGLEN + 1];

	(void) sprintf(msg, "Cannot open file %s", file);
	putmsg(msg);
}

void
cannotwrite(char *file)
{
	char	msg[MSGLEN + 1];

	(void) sprintf(msg, "Removed file %s because write failed", file);
	myperror(msg);	/* display the reason */
	(void) unlink(file);
	myexit(1);	/* calls exit(2), which closes files */
}

/* set up the digraph character tables for text compression */

static void
initcompress(void)
{
	int	i;

	if (compress == YES) {
		for (i = 0; i < 16; ++i) {
			dicode1[(unsigned)(dichar1[i])] = i * 8 + 1;
		}
		for (i = 0; i < 8; ++i) {
			dicode2[(unsigned)(dichar2[i])] = i + 1;
		}
	}
}

/* open the database */

static void
opendatabase(void)
{
	if ((symrefs = vpopen(reffile, O_RDONLY)) == -1) {
		cannotopen(reffile);
		myexit(1);
	}
	blocknumber = -1;	/* force next seek to read the first block */

	/* open any inverted index */
	if (invertedindex == YES &&
	    invopen(&invcontrol, invname, invpost, INVAVAIL) == -1) {
		askforreturn();		/* so user sees message */
		invertedindex = NO;
	}
}

/* close the database */

static void
closedatabase(void)
{
	(void) close(symrefs);
	if (invertedindex == YES) {
		invclose(&invcontrol);
		nsrcoffset = 0;
		npostings = 0;
	}
}

/* rebuild the database */

void
rebuild(void)
{
	closedatabase();
	build();
	opendatabase();

	/* revert to the initial display */
	if (refsfound != NULL) {
		(void) fclose(refsfound);
		refsfound = NULL;
	}
	*lastfilepath = '\0';	/* last file may have new path */
}

/* build the cross-reference */

static void
build(void)
{
	int	i;
	FILE	*oldrefs;	/* old cross-reference file */
	time_t	reftime;	/* old crossref modification time */
	char	*file;			/* current file */
	char	*oldfile;		/* file in old cross-reference */
	char	newdir[PATHLEN + 1];	/* directory in new cross-reference */
	char	olddir[PATHLEN + 1];	/* directory in old cross-reference */
	char	oldname[PATHLEN + 1];	/* name in old cross-reference */
	int	oldnum;			/* number in old cross-ref */
	struct	stat statstruct;	/* file status */
	int	firstfile;		/* first source file in pass */
	int	lastfile;		/* last source file in pass */
	int	built = 0;		/* built crossref for these files */
	int	copied = 0;		/* copied crossref for these files */
	BOOL	interactive = YES;	/* output progress messages */

	/*
	 * normalize the current directory relative to the home directory so
	 * the cross-reference is not rebuilt when the user's login is moved
	 */
	(void) strcpy(newdir, currentdir);
	if (strcmp(currentdir, home) == 0) {
		(void) strcpy(newdir, "$HOME");
	} else if (strncmp(currentdir, home, strlen(home)) == 0) {
		(void) sprintf(newdir, "$HOME%s", currentdir + strlen(home));
	}
	/* sort the source file names (needed for rebuilding) */
	qsort((char *)srcfiles, (unsigned)nsrcfiles, sizeof (char *), compare);

	/*
	 * if there is an old cross-reference and its current directory
	 * matches or this is an unconditional build
	 */
	if ((oldrefs = vpfopen(reffile, "r")) != NULL && unconditional == NO &&
	    fscanf(oldrefs, "cscope %d %s", &fileversion, olddir) == 2 &&
	    (strcmp(olddir, currentdir) == 0 || /* remain compatible */
	    strcmp(olddir, newdir) == 0)) {

		/* get the cross-reference file's modification time */
		(void) fstat(fileno(oldrefs), &statstruct);
		reftime = statstruct.st_mtime;
		if (fileversion >= 8) {
			BOOL	oldcompress = YES;
			BOOL	oldinvertedindex = NO;
			BOOL	oldtruncatesyms = NO;
			int	c;

			/* see if there are options in the database */
			for (;;) {
				while ((c = getc(oldrefs)) == ' ') {
				}
				if (c != '-') {
					(void) ungetc(c, oldrefs);
					break;
				}
				switch (c = getc(oldrefs)) {
				case 'c':	/* ASCII characters only */
					oldcompress = NO;
					break;
				case 'q':	/* quick search */
					oldinvertedindex = YES;
					(void) fscanf(oldrefs,
					    "%ld", &totalterms);
					break;
				case 'T':
					/* truncate symbols to 8 characters */
					oldtruncatesyms = YES;
					break;
				}
			}
			/* check the old and new option settings */
			if (oldcompress != compress ||
			    oldtruncatesyms != truncatesyms) {
				(void) fprintf(stderr,
				    "cscope: -c or -T option mismatch between "
				    "command line and old symbol database\n");
				goto force;
			}
			if (oldinvertedindex != invertedindex) {
				(void) fprintf(stderr,
				    "cscope: -q option mismatch between "
				    "command line and old symbol database\n");
				if (invertedindex == NO) {
					removeindex();
				}
				goto outofdate;
			}
			/* seek to the trailer */
			if (fscanf(oldrefs, "%ld", &traileroffset) != 1 ||
			    fseek(oldrefs, traileroffset, 0) == -1) {
				(void) fprintf(stderr,
				    "cscope: incorrect symbol database file "
				    "format\n");
				goto force;
			}
		}
		/* if assuming that some files have changed */
		if (fileschanged == YES) {
			goto outofdate;
		}
		/* see if the view path is the same */
		if (fileversion >= 13 &&
		    samelist(oldrefs, vpdirs, vpndirs) == NO) {
			goto outofdate;
		}
		/* see if the directory lists are the same */
		if (samelist(oldrefs, srcdirs, nsrcdirs) == NO ||
		    samelist(oldrefs, incdirs, nincdirs) == NO ||
		    fscanf(oldrefs, "%d", &oldnum) != 1 ||
		    fileversion >= 9 && fscanf(oldrefs, "%*s") != 0) {
			/* skip the string space size */
			goto outofdate;
		}
		/*
		 * see if the list of source files is the same and
		 * none have been changed up to the included files
		 */
		for (i = 0; i < nsrcfiles; ++i) {
			if (fscanf(oldrefs, "%s", oldname) != 1 ||
			    strnotequal(oldname, srcfiles[i]) ||
			    vpstat(srcfiles[i], &statstruct) != 0 ||
			    statstruct.st_mtime > reftime) {
				goto outofdate;
			}
		}
		/* the old cross-reference is up-to-date */
		/* so get the list of included files */
		while (i++ < oldnum && fscanf(oldrefs, "%s", oldname) == 1) {
			addsrcfile(oldname);
		}
		(void) fclose(oldrefs);
		return;

outofdate:
		/* if the database format has changed, rebuild it all */
		if (fileversion != FILEVERSION) {
			(void) fprintf(stderr,
			    "cscope: converting to new symbol database file "
			    "format\n");
			goto force;
		}
		/* reopen the old cross-reference file for fast scanning */
		if ((symrefs = vpopen(reffile, O_RDONLY)) == -1) {
			cannotopen(reffile);
			myexit(1);
		}
		/* get the first file name in the old cross-reference */
		blocknumber = -1;
		(void) readblock();	/* read the first cross-ref block */
		(void) scanpast('\t');	/* skip the header */
		oldfile = getoldfile();
	} else {	/* force cross-referencing of all the source files */
force:
		reftime = 0;
		oldfile = NULL;
	}
	/* open the new cross-reference file */
	if ((newrefs = fopen(newreffile, "w")) == NULL) {
		cannotopen(newreffile);
		myexit(1);
	}
	if (invertedindex == YES && (postings = fopen(temp1, "w")) == NULL) {
		cannotopen(temp1);
		cannotindex();
	}
	(void) fprintf(stderr, "cscope: building symbol database\n");
	putheader(newdir);
	fileversion = FILEVERSION;
	if (buildonly == YES && !isatty(0)) {
		interactive = NO;
	} else {
		initprogress();
	}
	/* output the leading tab expected by crossref() */
	dbputc('\t');

	/*
	 * make passes through the source file list until the last level of
	 * included files is processed
	 */
	firstfile = 0;
	lastfile = nsrcfiles;
	if (invertedindex == YES) {
		srcoffset = mymalloc((nsrcfiles + 1) * sizeof (long));
	}
	for (;;) {

		/* get the next source file name */
		for (fileindex = firstfile; fileindex < lastfile; ++fileindex) {
			/* display the progress about every three seconds */
			if (interactive == YES && fileindex % 10 == 0) {
				if (copied == 0) {
					progress("%ld files built",
					    (long)built, 0L);
				} else {
					progress("%ld files built, %ld "
					    "files copied", (long)built,
					    (long)copied);
				}
			}
			/* if the old file has been deleted get the next one */
			file = srcfiles[fileindex];
			while (oldfile != NULL && strcmp(file, oldfile) > 0) {
				oldfile = getoldfile();
			}
			/*
			 * if there isn't an old database or this is
			 * a new file
			 */
			if (oldfile == NULL || strcmp(file, oldfile) < 0) {
				crossref(file);
				++built;
			} else if (vpstat(file, &statstruct) == 0 &&
			    statstruct.st_mtime > reftime) {
				/* if this file was modified */
				crossref(file);
				++built;

				/*
				 * skip its old crossref so modifying the last
				 * source file does not cause all included files
				 * to be built.  Unfortunately a new file that
				 * is alphabetically last will cause all
				 * included files to be built, but this is
				 * less likely
				 */
				oldfile = getoldfile();
			} else {	/* copy its cross-reference */
				putfilename(file);
				if (invertedindex == YES) {
					copyinverted();
				} else {
					copydata();
				}
				++copied;
				oldfile = getoldfile();
			}
		}
		/* see if any included files were found */
		if (lastfile == nsrcfiles) {
			break;
		}
		firstfile = lastfile;
		lastfile = nsrcfiles;
		if (invertedindex == YES) {
			srcoffset = myrealloc(srcoffset,
			    (nsrcfiles + 1) * sizeof (long));
		}
		/* sort the included file names */
		qsort((char *)&srcfiles[firstfile],
		    (unsigned)(lastfile - firstfile), sizeof (char *), compare);
	}
	/* add a null file name to the trailing tab */
	putfilename("");
	dbputc('\n');

	/* get the file trailer offset */

	traileroffset = dboffset;

	/*
	 * output the view path and source and include directory and
	 * file lists
	 */
	putlist(vpdirs, vpndirs);
	putlist(srcdirs, nsrcdirs);
	putlist(incdirs, nincdirs);
	putlist(srcfiles, nsrcfiles);
	if (fflush(newrefs) == EOF) {
		/* rewind doesn't check for write failure */
		cannotwrite(newreffile);
		/* NOTREACHED */
	}
	/* create the inverted index if requested */
	if (invertedindex == YES) {
		char	sortcommand[PATHLEN + 1];

		if (fflush(postings) == EOF) {
			cannotwrite(temp1);
			/* NOTREACHED */
		}
		(void) fstat(fileno(postings), &statstruct);
		(void) fprintf(stderr,
		    "cscope: building symbol index: temporary file size is "
		    "%ld bytes\n", statstruct.st_size);
		(void) fclose(postings);
	/*
	 * sort -T is broken until it is fixed we don't have too much choice
	 */
	/*
	 * (void) sprintf(sortcommand, "sort -y -T %s %s", tmpdir, temp1);
	 */
	(void) sprintf(sortcommand, "LC_ALL=C sort %s", temp1);
		if ((postings = popen(sortcommand, "r")) == NULL) {
			(void) fprintf(stderr,
			    "cscope: cannot open pipe to sort command\n");
			cannotindex();
		} else {
			if ((totalterms = invmake(newinvname, newinvpost,
			    postings)) > 0) {
				movefile(newinvname, invname);
				movefile(newinvpost, invpost);
			} else {
				cannotindex();
			}
			(void) pclose(postings);
		}
		(void) unlink(temp1);
		(void) free(srcoffset);
		(void) fprintf(stderr,
		    "cscope: index has %ld references to %ld symbols\n",
		    npostings, totalterms);
	}
	/* rewrite the header with the trailer offset and final option list */
	rewind(newrefs);
	putheader(newdir);
	(void) fclose(newrefs);

	/* close the old database file */
	if (symrefs >= 0) {
		(void) close(symrefs);
	}
	if (oldrefs != NULL) {
		(void) fclose(oldrefs);
	}
	/* replace it with the new database file */
	movefile(newreffile, reffile);
}

/* string comparison function for qsort */

static int
compare(const void *s1, const void *s2)
{
	return (strcmp((char *)s1, (char *)s2));
}

/* get the next file name in the old cross-reference */

static char *
getoldfile(void)
{
	static	char	file[PATHLEN + 1];	/* file name in old crossref */

	if (blockp != NULL) {
		do {
			if (*blockp == NEWFILE) {
				skiprefchar();
				getstring(file);
				if (file[0] != '\0') {
					/* if not end-of-crossref */
					return (file);
				}
				return (NULL);
			}
		} while (scanpast('\t') != NULL);
	}
	return (NULL);
}

/*
 * output the cscope version, current directory, database format options, and
 * the database trailer offset
 */

static void
putheader(char *dir)
{
	dboffset = fprintf(newrefs, "cscope %d %s", FILEVERSION, dir);
	if (compress == NO) {
		dboffset += fprintf(newrefs, " -c");
	}
	if (invertedindex == YES) {
		dboffset += fprintf(newrefs, " -q %.10ld", totalterms);
	} else {
		/*
		 * leave space so if the header is overwritten without -q
		 * because writing the inverted index failed, the header is
		 * the same length
		 */
		dboffset += fprintf(newrefs, "              ");
	}
	if (truncatesyms == YES) {
		dboffset += fprintf(newrefs, " -T");
	}
	dbfprintf(newrefs, " %.10ld\n", traileroffset);
}

/* put the name list into the cross-reference file */

static void
putlist(char **names, int count)
{
	int	i, size = 0;

	(void) fprintf(newrefs, "%d\n", count);
	if (names == srcfiles) {

		/* calculate the string space needed */
		for (i = 0; i < count; ++i) {
			size += strlen(names[i]) + 1;
		}
		(void) fprintf(newrefs, "%d\n", size);
	}
	for (i = 0; i < count; ++i) {
		if (fputs(names[i], newrefs) == EOF ||
		    putc('\n', newrefs) == EOF) {
			cannotwrite(newreffile);
			/* NOTREACHED */
		}
	}
}

/* see if the name list is the same in the cross-reference file */

static BOOL
samelist(FILE *oldrefs, char **names, int count)
{
	char	oldname[PATHLEN + 1];	/* name in old cross-reference */
	int	oldcount;
	int	i;

	/* see if the number of names is the same */
	if (fscanf(oldrefs, "%d", &oldcount) != 1 ||
	    oldcount != count) {
		return (NO);
	}
	/* see if the name list is the same */
	for (i = 0; i < count; ++i) {
		if (fscanf(oldrefs, "%s", oldname) != 1 ||
		    strnotequal(oldname, names[i])) {
			return (NO);
		}
	}
	return (YES);
}

/* skip the list in the cross-reference file */

static void
skiplist(FILE *oldrefs)
{
	int	i;

	if (fscanf(oldrefs, "%d", &i) != 1) {
		(void) fprintf(stderr,
		    "cscope: cannot read list size from file %s\n", reffile);
		exit(1);
	}
	while (--i >= 0) {
		if (fscanf(oldrefs, "%*s") != 0) {
			(void) fprintf(stderr,
			    "cscope: cannot read list name from file %s\n",
			    reffile);
			exit(1);
		}
	}
}

/* copy this file's symbol data */

static void
copydata(void)
{
	char	symbol[PATLEN + 1];
	char	*cp;

	setmark('\t');
	cp = blockp;
	for (;;) {
		/* copy up to the next \t */
		do {	/* innermost loop optimized to only one test */
			while (*cp != '\t') {
				dbputc(*cp++);
			}
		} while (*++cp == '\0' && (cp = readblock()) != NULL);
		dbputc('\t');	/* copy the tab */

		/* get the next character */
		if (*(cp + 1) == '\0') {
			cp = readblock();
		}
		/* exit if at the end of this file's data */
		if (cp == NULL || *cp == NEWFILE) {
			break;
		}
		/* look for an #included file */
		if (*cp == INCLUDE) {
			blockp = cp;
			putinclude(symbol);
			putstring(symbol);
			setmark('\t');
			cp = blockp;
		}
	}
	blockp = cp;
}

/* copy this file's symbol data and output the inverted index postings */

static void
copyinverted(void)
{
	char	*cp;
	int	c;
	int	type;	/* reference type (mark character) */
	char	symbol[PATLEN + 1];

	/* note: this code was expanded in-line for speed */
	/* while (scanpast('\n') != NULL) { */
	/* other macros were replaced by code using cp instead of blockp */
	cp = blockp;
	for (;;) {
		setmark('\n');
		do {	/* innermost loop optimized to only one test */
			while (*cp != '\n') {
				dbputc(*cp++);
			}
		} while (*++cp == '\0' && (cp = readblock()) != NULL);
		dbputc('\n');	/* copy the newline */

		/* get the next character */
		if (*(cp + 1) == '\0') {
			cp = readblock();
		}
		/* exit if at the end of this file's data */
		if (cp == NULL) {
			break;
		}
		switch (*cp) {
		case '\n':
			lineoffset = dboffset + 1;
			continue;
		case '\t':
			dbputc('\t');
			blockp = cp;
			type = getrefchar();
			switch (type) {
			case NEWFILE:		/* file name */
				return;
			case INCLUDE:		/* #included file */
				putinclude(symbol);
				goto output;
			}
			dbputc(type);
			skiprefchar();
			getstring(symbol);
			goto output;
		}
		c = *cp;
		if (c & 0200) {	/* digraph char? */
			c = dichar1[(c & 0177) / 8];
		}
		/* if this is a symbol */
		if (isalpha(c) || c == '_') {
			blockp = cp;
			getstring(symbol);
			type = ' ';
		output:
			putposting(symbol, type);
			putstring(symbol);
			if (blockp == NULL) {
				return;
			}
			cp = blockp;
		}
	}
	blockp = cp;
}

/* process the #included file in the old database */

static void
putinclude(char *s)
{
	dbputc(INCLUDE);
	skiprefchar();
	getstring(s);
	incfile(s + 1, *s);
}

/* replace the old file with the new file */

static void
movefile(char *new, char *old)
{
	(void) unlink(old);
	if (link(new, old) == -1) {
		(void) perror("cscope");
		(void) fprintf(stderr,
		    "cscope: cannot link file %s to file %s\n", new, old);
		myexit(1);
	}
	if (unlink(new) == -1) {
		(void) perror("cscope");
		(void) fprintf(stderr, "cscope: cannot unlink file %s\n", new);
		errorsfound = YES;
	}
}

/* enter curses mode */

void
entercurses(void)
{
	incurses = YES;
	(void) nonl();		/* don't translate an output \n to \n\r */
	(void) cbreak();	/* single character input */
	(void) noecho();	/* don't echo input characters */
	(void) clear();		/* clear the screen */
	initmouse();		/* initialize any mouse interface */
	drawscrollbar(topline, nextline, totallines);
	atfield();
}

/* exit curses mode */

void
exitcurses(void)
{
	/* clear the bottom line */
	(void) move(LINES - 1, 0);
	(void) clrtoeol();
	(void) refresh();

	/* exit curses and restore the terminal modes */
	(void) endwin();
	incurses = NO;

	/* restore the mouse */
	cleanupmouse();
	(void) fflush(stdout);
}

/* no activity timeout occurred */

static void
timedout(int sig)
{
	/* if there is a child process, don't exit until it does */
	if (childpid) {
		closedatabase();
		noacttimeout = YES;
		return;
	}
	exitcurses();
	(void) fprintf(stderr, "cscope: no activity for %d hours--exiting\n",
	    noacttime / 3600);
	myexit(sig);
}

/* cleanup and exit */

void
myexit(int sig)
{
	/* deleted layer causes multiple signals */
	(void) signal(SIGHUP, SIG_IGN);
	/* remove any temporary files */
	if (temp1[0] != '\0') {
		(void) unlink(temp1);
		(void) unlink(temp2);
	}
	/* restore the terminal to its original mode */
	if (incurses == YES) {
		exitcurses();
	}

	/* dump core for debugging on the quit signal */
	if (sig == SIGQUIT) {
		(void) abort();
	}
	exit(sig);
}



/* ============================================================================
 * SOURCE 29/98: minix4\exokernel\kernel_legacy\libl\lib\main.c
 * Size: 69 bytes, Lines: 7
 * Hash: 43d4d385603b...
 * ============================================================================ */

/*	@(#)main.c	1.2	*/
# include "stdio.h"
main(){
yylex();
exit(0);
}



/* ============================================================================
 * SOURCE 30/98: minix4\exokernel\kernel_legacy\contrib\ast\src\cmd\ksh93\sh\main.c
 * Size: 18,536 bytes, Lines: 771
 * Hash: 55c8f842231d...
 * ============================================================================ */

/***********************************************************************
*                                                                      *
*               This software is part of the ast package               *
*          Copyright (c) 1982-2012 AT&T Intellectual Property          *
*                      and is licensed under the                       *
*                 Eclipse Public License, Version 1.0                  *
*                    by AT&T Intellectual Property                     *
*                                                                      *
*                A copy of the License is available at                 *
*          http://www.eclipse.org/org/documents/epl-v10.html           *
*         (with md5 checksum b35adb5213ca9657e911e9befb180842)         *
*                                                                      *
*              Information and Software Systems Research               *
*                            AT&T Research                             *
*                           Florham Park NJ                            *
*                                                                      *
*                  David Korn <dgk@research.att.com>                   *
*                                                                      *
***********************************************************************/
#pragma prototyped
/*
 * UNIX shell
 *
 * S. R. Bourne
 * Rewritten By David Korn
 * AT&T Labs
 *
 */
/*
 * Copyright (c) 2007, 2011, Oracle and/or its affiliates. All rights reserved.
 */

#include	<ast.h>
#include	<sfio.h>
#include	<stak.h>
#include	<ls.h>
#include	<fcin.h>
#include	"defs.h"
#include	"variables.h"
#include	"path.h"
#include	"io.h"
#include	"jobs.h"
#include	"shlex.h"
#include	"shnodes.h"
#include	"history.h"
#include	"timeout.h"
#include	"FEATURE/time"
#include	"FEATURE/pstat"
#include	"FEATURE/execargs"
#include	"FEATURE/externs"
#ifdef	_hdr_nc
#   include	<nc.h>
#endif	/* _hdr_nc */

#define CMD_LENGTH	64

/* These routines are referenced by this module */
static void	exfile(Shell_t*, Sfio_t*,int);
static void	chkmail(Shell_t *shp, char*);
#if defined(_lib_fork) && !defined(_NEXT_SOURCE)
    static void	fixargs(char**,int);
#else
#   define fixargs(a,b)
#endif

#ifndef environ
    extern char	**environ;
#endif

static struct stat lastmail;
static time_t	mailtime;
static char	beenhere = 0;

#ifdef _lib_sigvec
    void clearsigmask(register int sig)
    {
	struct sigvec vec;
	if(sigvec(sig,NIL(struct sigvec*),&vec)>=0 && vec.sv_mask)
	{
		vec.sv_mask = 0;
		sigvec(sig,&vec,NIL(struct sigvec*));
	}
    }
#endif /* _lib_sigvec */

#ifdef PATH_BFPATH
#define PATHCOMP	NIL(Pathcomp_t*)
#else
#define PATHCOMP	""
#endif

/*
 * search for file and exfile() it if it exists
 * 1 returned if file found, 0 otherwise
 */

int sh_source(Shell_t *shp, Sfio_t *iop, const char *file)
{
	char*	oid;
	char*	nid;
	int	fd;

	if (!file || !*file || (fd = path_open(shp,file, PATHCOMP)) < 0)
	{
		REGRESS(source, "sh_source", ("%s:ENOENT", file));
		return 0;
	}
	oid = error_info.id;
	nid = error_info.id = strdup(file);
	shp->st.filename = path_fullname(shp,stakptr(PATH_OFFSET));
	REGRESS(source, "sh_source", ("%s", file));
	exfile(shp, iop, fd);
	error_info.id = oid;
	free(nid);
	return 1;
}

#ifdef S_ISSOCK
#define REMOTE(m)	(S_ISSOCK(m)||!(m))
#else
#define REMOTE(m)	!(m)
#endif

int sh_main(int ac, char *av[], Shinit_f userinit)
{
	register char	*name;
	register int	fdin;
	register Sfio_t  *iop;
	register Shell_t *shp;
	struct stat	statb;
	int i, rshflag;		/* set for restricted shell */
	char *command;
	free(malloc(64*1024));
#ifdef _lib_sigvec
	/* This is to clear mask that may be left on by rlogin */
	clearsigmask(SIGALRM);
	clearsigmask(SIGHUP);
	clearsigmask(SIGCHLD);
#endif /* _lib_sigvec */
#ifdef	_hdr_nc
	_NutConf(_NC_SET_SUFFIXED_SEARCHING, 1);
#endif	/* _hdr_nc */
	fixargs(av,0);
	shp = sh_init(ac,av,userinit);
	time(&mailtime);
	if(rshflag=sh_isoption(SH_RESTRICTED))
		sh_offoption(SH_RESTRICTED);
	if(sigsetjmp(*((sigjmp_buf*)shp->jmpbuffer),0))
	{
		/* begin script execution here */
		sh_reinit((char**)0);
		shp->gd->pid = getpid();
		shp->gd->ppid = getppid();
	}
	shp->fn_depth = shp->dot_depth = 0;
	command = error_info.id;
	/* set pidname '$$' */
	srand(shp->gd->pid&0x7fff);
	if(nv_isnull(PS4NOD))
		nv_putval(PS4NOD,e_traceprompt,NV_RDONLY);
	path_pwd(shp,1);
	iop = (Sfio_t*)0;
#if SHOPT_BRACEPAT
	sh_onoption(SH_BRACEEXPAND);
#endif
	if((beenhere++)==0)
	{
		sh_onstate(SH_PROFILE);
		((Lex_t*)shp->lex_context)->nonstandard = 0;
		if(shp->gd->ppid==1)
			shp->login_sh++;
		if(shp->login_sh >= 2)
			sh_onoption(SH_LOGIN_SHELL);
		/* decide whether shell is interactive */
		if(!sh_isoption(SH_INTERACTIVE) && !sh_isoption(SH_TFLAG) && !sh_isoption(SH_CFLAG) &&
		   sh_isoption(SH_SFLAG) && tty_check(0) && tty_check(ERRIO))
			sh_onoption(SH_INTERACTIVE);
		if(sh_isoption(SH_INTERACTIVE))
		{
			sh_onoption(SH_BGNICE);
			sh_onoption(SH_RC);
		}
		if(!sh_isoption(SH_RC) && (sh_isoption(SH_BASH) && !sh_isoption(SH_POSIX)
#if SHOPT_REMOTE
		   || !fstat(0, &statb) && REMOTE(statb.st_mode)
#endif
		  ))
			sh_onoption(SH_RC);
		for(i=0; i<elementsof(shp->offoptions.v); i++)
			shp->options.v[i] &= ~shp->offoptions.v[i];
		if(sh_isoption(SH_INTERACTIVE))
		{
#ifdef SIGXCPU
			signal(SIGXCPU,SIG_DFL);
#endif /* SIGXCPU */
#ifdef SIGXFSZ
			signal(SIGXFSZ,SIG_DFL);
#endif /* SIGXFSZ */
			sh_onoption(SH_MONITOR);
		}
		job_init(shp,sh_isoption(SH_LOGIN_SHELL));
		if(sh_isoption(SH_LOGIN_SHELL))
		{
			/*	system profile	*/
			sh_source(shp, iop, e_sysprofile);
			if(!sh_isoption(SH_NOUSRPROFILE) && !sh_isoption(SH_PRIVILEGED))
			{
				char **files = shp->gd->login_files;
				while ((name = *files++) && !sh_source(shp, iop, sh_mactry(shp,name)));
			}
		}
		/* make sure PWD is set up correctly */
		path_pwd(shp,1);
		if(!sh_isoption(SH_NOEXEC))
		{
			if(!sh_isoption(SH_NOUSRPROFILE) && !sh_isoption(SH_PRIVILEGED) && sh_isoption(SH_RC))
			{
#if SHOPT_BASH
				if(sh_isoption(SH_BASH) && !sh_isoption(SH_POSIX))
				{
#if SHOPT_SYSRC
					sh_source(shp, iop, e_bash_sysrc);
#endif
					sh_source(shp, iop, shp->gd->rcfile ? shp->gd->rcfile : sh_mactry(shp,(char*)e_bash_rc));
				}
				else
#endif
				{
					if(name = sh_mactry(shp,nv_getval(ENVNOD)))
						name = *name ? strdup(name) : (char*)0;
#if SHOPT_SYSRC
					if(!strmatch(name, "?(.)/./*"))
						sh_source(shp, iop, e_sysrc);
#endif
					if(name)
					{
						sh_source(shp, iop, name);
						free(name);
					}
				}
			}
			else if(sh_isoption(SH_INTERACTIVE) && sh_isoption(SH_PRIVILEGED))
				sh_source(shp, iop, e_suidprofile);
		}
		shp->st.cmdname = error_info.id = command;
		sh_offstate(SH_PROFILE);
		if(rshflag)
			sh_onoption(SH_RESTRICTED);
		/* open input file if specified */
		if(shp->comdiv)
		{
		shell_c:
			iop = sfnew(NIL(Sfio_t*),shp->comdiv,strlen(shp->comdiv),0,SF_STRING|SF_READ);
		}
		else
		{
			name = error_info.id;
			error_info.id = shp->shname;
			if(sh_isoption(SH_SFLAG))
				fdin = 0;
			else
			{
				char *sp;
				/* open stream should have been passed into shell */
				if(strmatch(name,e_devfdNN))
				{
#if !_WINIX
					char *cp;
					int type;
#endif
					fdin = (int)strtol(name+8, (char**)0, 10);
					if(fstat(fdin,&statb)<0)
						errormsg(SH_DICT,ERROR_system(1),e_open,name);
#if !_WINIX
					/*
					 * try to undo effect of solaris 2.5+
					 * change for argv for setuid scripts
					 */
					if (shp->st.repl_index > 0)
						av[shp->st.repl_index] = shp->st.repl_arg;
					if(((type = sh_type(cp = av[0])) & SH_TYPE_SH) && (name = nv_getval(L_ARGNOD)) && (!((type = sh_type(cp = name)) & SH_TYPE_SH)))
					{
						av[0] = (type & SH_TYPE_LOGIN) ? cp : path_basename(cp);
						/*  exec to change $0 for ps */
						execv(pathshell(),av);
						/* exec fails */
						shp->st.dolv[0] = av[0];
						fixargs(shp->st.dolv,1);
					}
#endif
					name = av[0];
					sh_offoption(SH_VERBOSE);
					sh_offoption(SH_XTRACE);
				}
				else
				{
					int isdir = 0;
					if((fdin=sh_open(name,O_RDONLY,0))>=0 &&(fstat(fdin,&statb)<0 || S_ISDIR(statb.st_mode)))
					{
						close(fdin);
						isdir = 1;
						fdin = -1;
					}
					else
						shp->st.filename = path_fullname(shp,name);
					sp = 0;
					if(fdin < 0 && !strchr(name,'/'))
					{
#ifdef PATH_BFPATH
						if(path_absolute(shp,name,NIL(Pathcomp_t*)))
							sp = stakptr(PATH_OFFSET);
#else
							sp = path_absolute(shp,name,NIL(char*));
#endif
						if(sp)
						{
							if((fdin=sh_open(sp,O_RDONLY,0))>=0)
								shp->st.filename = path_fullname(shp,sp);
						}
					}
					if(fdin<0)
					{
						if(isdir)
							errno = EISDIR;
						 error_info.id = av[0];
						if(sp || errno!=ENOENT)
							errormsg(SH_DICT,ERROR_system(ERROR_NOEXEC),e_open,name);
						/* try sh -c 'name "$@"' */
						sh_onoption(SH_CFLAG);
						shp->comdiv = (char*)malloc(strlen(name)+7);
						name = strcopy(shp->comdiv,name);
						if(shp->st.dolc)
							strcopy(name," \"$@\"");
						goto shell_c;
					}
					if(fdin==0)
						fdin = sh_iomovefd(fdin);
				}
				shp->readscript = shp->shname;
			}
			error_info.id = name;
			shp->comdiv--;
#if SHOPT_ACCT
			sh_accinit();
			if(fdin != 0)
				sh_accbegin(error_info.id);
#endif	/* SHOPT_ACCT */
		}
	}
	else
	{
		fdin = shp->infd;
		fixargs(shp->st.dolv,1);
	}
	if(sh_isoption(SH_INTERACTIVE))
		sh_onstate(SH_INTERACTIVE);
	nv_putval(IFSNOD,(char*)e_sptbnl,NV_RDONLY);
	exfile(shp,iop,fdin);
	sh_done(shp,0);
	/* NOTREACHED */
	return(0);
}

/*
 * iop is not null when the input is a string
 * fdin is the input file descriptor 
 */

static void	exfile(register Shell_t *shp, register Sfio_t *iop,register int fno)
{
	time_t curtime;
	Shnode_t *t;
	int maxtry=IOMAXTRY, tdone=0, execflags;
	int states,jmpval;
	struct checkpt buff;
	sh_pushcontext(shp,&buff,SH_JMPERREXIT);
	/* open input stream */
	nv_putval(SH_PATHNAMENOD, shp->st.filename ,NV_NOFREE);
	if(!iop)
	{
		if(fno > 0)
		{
			int r;
			VALIDATE_FD(shp, fno);
			if(fno < 10 && ((r=sh_fcntl(fno,F_DUPFD,10))>=10))
			{
				VALIDATE_FD(shp, r);
				shp->fdstatus[r] = shp->fdstatus[fno];
				sh_close(fno);
				fno = r;
			}
			fcntl(fno,F_SETFD,FD_CLOEXEC);
			shp->fdstatus[fno] |= IOCLEX;
			iop = sh_iostream((void*)shp,fno);
		}
		else
			iop = sfstdin;
	}
	else
		fno = -1;
	shp->infd = fno;
	if(sh_isstate(SH_INTERACTIVE))
	{
		if(nv_isnull(PS1NOD))
			nv_putval(PS1NOD,(shp->gd->euserid?e_stdprompt:e_supprompt),NV_RDONLY);
		sh_sigdone();
		if(sh_histinit((void*)shp))
			sh_onoption(SH_HISTORY);
	}
	else
	{
		if(!sh_isstate(SH_PROFILE))
		{
			buff.mode = SH_JMPEXIT;
			sh_onoption(SH_TRACKALL);
			sh_offoption(SH_MONITOR);
		}
		sh_offstate(SH_INTERACTIVE);
		sh_offstate(SH_MONITOR);
		sh_offstate(SH_HISTORY);
		sh_offoption(SH_HISTORY);
	}
	states = sh_getstate();
	jmpval = sigsetjmp(buff.buff,0);
	if(jmpval)
	{
		Sfio_t *top;
		sh_iorestore((void*)shp,0,jmpval);
		hist_flush(shp->gd->hist_ptr);
		sfsync(shp->outpool);
		shp->st.execbrk = shp->st.breakcnt = 0;
		/* check for return from profile or env file */
		if(sh_isstate(SH_PROFILE) && (jmpval==SH_JMPFUN || jmpval==SH_JMPEXIT))
		{
			sh_setstate(states);
			goto done;
		}
		if(!sh_isoption(SH_INTERACTIVE) || sh_isstate(SH_FORKED) || (jmpval > SH_JMPERREXIT && job_close(shp) >=0))
		{
			sh_offstate(SH_INTERACTIVE);
			sh_offstate(SH_MONITOR);
			goto done;
		}
		exitset();
		/* skip over remaining input */
		if(top = fcfile())
		{
			while(fcget()>0);
			fcclose();
			while(top=sfstack(iop,SF_POPSTACK))
				sfclose(top);
		}
		/* make sure that we own the terminal */
#ifdef SIGTSTP
		tcsetpgrp(job.fd,shp->gd->pid);
#endif /* SIGTSTP */
	}
	/* error return here */
	sfclrerr(iop);
	sh_setstate(states);
	shp->st.optindex = 1;
	opt_info.offset = 0;
	shp->st.loopcnt = 0;
	shp->trapnote = 0;
	shp->intrap = 0;
	error_info.line = 1;
	shp->inlineno = 1;
	shp->binscript = 0;
	shp->exittrap = 0;
	shp->errtrap = 0;
	shp->end_fn = 0;
	if(sfeof(iop))
		goto eof_or_error;
	/* command loop */
	while(1)
	{
		shp->nextprompt = 1;
		sh_freeup(shp);
		stakset(NIL(char*),0);
		sh_offstate(SH_STOPOK);
		sh_offstate(SH_ERREXIT);
		sh_offstate(SH_VERBOSE);
		sh_offstate(SH_TIMING);
		sh_offstate(SH_GRACE);
		sh_offstate(SH_TTYWAIT);
		if(sh_isoption(SH_VERBOSE))
			sh_onstate(SH_VERBOSE);
		sh_onstate(SH_ERREXIT);
		/* -eim  flags don't apply to profiles */
		if(sh_isstate(SH_PROFILE))
		{
			sh_offstate(SH_INTERACTIVE);
			sh_offstate(SH_ERREXIT);
			sh_offstate(SH_MONITOR);
		}
		if(sh_isstate(SH_INTERACTIVE) && !tdone)
		{
			register char *mail;
#ifdef JOBS
			sh_offstate(SH_MONITOR);
			if(sh_isoption(SH_MONITOR))
				sh_onstate(SH_MONITOR);
			if(job.pwlist)
			{
				job_walk(sfstderr,job_list,JOB_NFLAG,(char**)0);
				job_wait((pid_t)0);
			}
#endif	/* JOBS */
			if((mail=nv_getval(MAILPNOD)) || (mail=nv_getval(MAILNOD)))
			{
				time(&curtime);
				if ((curtime - mailtime) >= sh_mailchk)
				{
					chkmail(shp,mail);
					mailtime = curtime;
				}
			}
			if(shp->gd->hist_ptr)
				hist_eof(shp->gd->hist_ptr);
			/* sets timeout for command entry */
			shp->timeout = shp->st.tmout;
#if SHOPT_TIMEOUT
			if(shp->timeout <= 0 || shp->timeout > SHOPT_TIMEOUT)
				shp->timeout = SHOPT_TIMEOUT;
#endif /* SHOPT_TIMEOUT */
			shp->inlineno = 1;
			error_info.line = 1;
			shp->trapnote = 0;
			if(buff.mode == SH_JMPEXIT)
			{
				buff.mode = SH_JMPERREXIT;
#ifdef DEBUG
				errormsg(SH_DICT,ERROR_warn(0),"%d: mode changed to JMP_EXIT",getpid());
#endif
			}
		}
		errno = 0;
		if(tdone || !sfreserve(iop,0,0))
		{
		eof_or_error:
			if(sh_isstate(SH_INTERACTIVE) && !sferror(iop)) 
			{
				if(--maxtry>0 && sh_isoption(SH_IGNOREEOF) &&
					 !sferror(sfstderr) && (shp->fdstatus[fno]&IOTTY))
				{
					sfclrerr(iop);
					errormsg(SH_DICT,0,e_logout);
					continue;
				}
				else if(job_close(shp)<0)
					continue;
			}
			if(errno==0 && sferror(iop) && --maxtry>0)
			{
				sfclrlock(iop);
				sfclrerr(iop);
				continue;
			}
			goto done;
		}
		shp->exitval = sh.savexit;
		maxtry = IOMAXTRY;
		if(sh_isstate(SH_INTERACTIVE) && shp->gd->hist_ptr)
		{
			job_wait((pid_t)0);
			hist_eof(shp->gd->hist_ptr);
			sfsync(sfstderr);
		}
		if(sh_isoption(SH_HISTORY))
			sh_onstate(SH_HISTORY);
		job.waitall = job.curpgid = 0;
		error_info.flags |= ERROR_INTERACTIVE;
		t = (Shnode_t*)sh_parse(shp,iop,0);
		if(!sh_isstate(SH_INTERACTIVE) && !sh_isoption(SH_CFLAG))
			error_info.flags &= ~ERROR_INTERACTIVE;
		shp->readscript = 0;
		if(sh_isstate(SH_INTERACTIVE) && shp->gd->hist_ptr)
			hist_flush(shp->gd->hist_ptr);
		sh_offstate(SH_HISTORY);
		if(t)
		{
			execflags = sh_state(SH_ERREXIT)|sh_state(SH_INTERACTIVE);
			shp->st.execbrk = 0;
			sh_exec(t,execflags);
			if(shp->forked)
			{
				sh_offstate(SH_INTERACTIVE);
				goto done;
			}
			/* This is for sh -t */
			if(sh_isoption(SH_TFLAG) && !sh_isstate(SH_PROFILE))
				tdone++;
		}
	}
done:
	sh_popcontext(shp,&buff);
	if(sh_isstate(SH_INTERACTIVE))
	{
		sfputc(sfstderr,'\n');
		job_close(shp);
	}
	if(jmpval == SH_JMPSCRIPT)
		siglongjmp(*shp->jmplist,jmpval);
	else if(jmpval == SH_JMPEXIT)
		sh_done(shp,0);
	if(fno>0)
		sh_close(fno);
	if(shp->st.filename)
		free((void*)shp->st.filename);
	shp->st.filename = 0;
}


/* prints out messages if files in list have been modified since last call */
static void chkmail(Shell_t *shp, char *files)
{
	register char *cp,*sp,*qp;
	register char save;
	struct argnod *arglist=0;
	int	offset = staktell();
	char 	*savstak=stakptr(0);
	struct stat	statb;
	if(*(cp=files) == 0)
		return;
	sp = cp;
	do
	{
		/* skip to : or end of string saving first '?' */
		for(qp=0;*sp && *sp != ':';sp++)
			if((*sp == '?' || *sp=='%') && qp == 0)
				qp = sp;
		save = *sp;
		*sp = 0;
		/* change '?' to end-of-string */
		if(qp)
			*qp = 0;
		do
		{
			/* see if time has been modified since last checked
			 * and the access time <= the modification time
			 */
			if(stat(cp,&statb) >= 0 && statb.st_mtime >= mailtime
				&& statb.st_atime <= statb.st_mtime)
			{
				/* check for directory */
				if(!arglist && S_ISDIR(statb.st_mode)) 
				{
					/* generate list of directory entries */
					path_complete(shp,cp,"/*",&arglist);
				}
				else
				{
					/*
					 * If the file has shrunk,
					 * or if the size is zero
					 * then don't print anything
					 */
					if(statb.st_size &&
						(  statb.st_ino != lastmail.st_ino
						|| statb.st_dev != lastmail.st_dev
						|| statb.st_size > lastmail.st_size))
					{
						/* save and restore $_ */
						char *save = shp->lastarg;
						shp->lastarg = cp;
						errormsg(SH_DICT,0,sh_mactry(shp,qp?qp+1:(char*)e_mailmsg));
						shp->lastarg = save;
					}
					lastmail = statb;
					break;
				}
			}
			if(arglist)
			{
				cp = arglist->argval;
				arglist = arglist->argchn.ap;
			}
			else
				cp = 0;
		}
		while(cp);
		if(qp)
			*qp = '?';
		*sp++ = save;
		cp = sp;
	}
	while(save);
	stakset(savstak,offset);
}

#undef EXECARGS
#undef PSTAT
#if defined(_hdr_execargs) && defined(pdp11)
#   include	<execargs.h>
#   define EXECARGS	1
#endif

#if defined(_lib_pstat) && defined(_sys_pstat)
#   include	<sys/pstat.h>
#   define PSTAT	1
#endif

#if defined(_lib_fork) && !defined(_NEXT_SOURCE)
/*
 * fix up command line for ps command
 * mode is 0 for initialization
 */
static void fixargs(char **argv, int mode)
{
#if EXECARGS
	*execargs=(char *)argv;
#else
	static char *buff;
	static int command_len;
	register char *cp;
	int offset=0,size;
#   ifdef PSTAT
	union pstun un;
	if(mode==0)
	{
		struct pst_static st;
		un.pst_static = &st;
		if(pstat(PSTAT_STATIC, un, sizeof(struct pst_static), 1, 0)<0)
			return;
		command_len = st.command_length;
		return;
	}
	stakseek(command_len+2);
	buff = stakseek(0);
#   else
	if(mode==0)
	{
		buff = argv[0];
		while(cp = *argv++)
			command_len += strlen(cp)+1;
		if(environ && *environ==buff+command_len)
		{
			for(argv=environ; cp = *argv; cp++)
			{
				if(command_len > CMD_LENGTH)
				{
					command_len = CMD_LENGTH;
					break;
				}
				*argv++ = strdup(cp);
				command_len += strlen(cp)+1;
			}
		}
		command_len -= 1;
		return;
	}
#   endif /* PSTAT */
	if(command_len==0)
		return;
	while((cp = *argv++) && offset < command_len)
	{
		if(offset + (size=strlen(cp)) >= command_len)
			size = command_len - offset;
		memcpy(buff+offset,cp,size);
		offset += size;
		buff[offset++] = ' ';
	}
	buff[offset-1] = 0;
#   ifdef PSTAT
	un.pst_command = stakptr(0);
	pstat(PSTAT_SETCMD,un,0,0,0);
#   endif /* PSTAT */
#endif /* EXECARGS */
}
#endif /* _lib_fork */



/* ============================================================================
 * SOURCE 31/98: minix4\exokernel\kernel_legacy\common\ficl\main.c
 * Size: 4,088 bytes, Lines: 151
 * Hash: 43a2c16513bd...
 * ============================================================================ */

/*
 * stub main for testing Ficl
 * $Id: main.c,v 1.2 2010/09/10 09:01:28 asau Exp $
 */
/*
 * Copyright (c) 1997-2001 John Sadler (john_sadler@alum.mit.edu)
 * All rights reserved.
 *
 * Get the latest Ficl release at http://ficl.sourceforge.net
 *
 * I am interested in hearing from anyone who uses Ficl. If you have
 * a problem, a success story, a defect, an enhancement request, or
 * if you would like to contribute to the Ficl release, please
 * contact me by email at the address above.
 *
 * L I C E N S E  and  D I S C L A I M E R
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <termios.h>
#include <sys/errno.h>
#include <err.h>

#include <ficl.h>
#include <ficlplatform/emu.h>
#include <libtecla.h>

#define	LINELEN	1024
#define	HISTORY	2048

static char *
prompt(void)
{
	static char prompt[20]; /* probably too large, but well... */
	char *pr, *p, *cp, *ev;
	int n = 0;

	if ((cp = getenv("prompt")) == NULL)
		cp = ">";
	pr = p = strdup(cp);

	while (*p != 0) {
		if ((*p == '$') && (*(p+1) == '{')) {
			for (cp = p + 2; (*cp != 0) && (*cp != '}'); cp++)
				;
			*cp = 0;
			ev = getenv(p + 2);

			if (ev != NULL)
				n = sprintf(prompt+n, "%s", ev);
			p = cp + 1;
			continue;
		}
		prompt[n++] = *p;
		p++;
	}
	if (prompt[n - 1] != ' ')
		prompt[n++] = ' ';
	prompt[n] = '\0';
	free(pr);
	return (prompt);
}

int
main(int argc, char **argv)
{
	int returnValue = 0;
	char *buffer;
	GetLine *gl;
	ficlVm *vm;
	struct winsize ws;
	int cols = 80, rows = 24;

	if (ioctl(1, TIOCGWINSZ, &ws) != -1) {
		if (ws.ws_col)
			cols = ws.ws_col;
		if (ws.ws_row)
			rows = ws.ws_row;
	}

	(void) clearenv();
	if (asprintf(&buffer, "%d", cols) < 0)
		err(EXIT_FAILURE, NULL);
	(void) setenv("screen-#cols", buffer, 1);
	free(buffer);
	if (asprintf(&buffer, "%d", rows) < 0)
		err(EXIT_FAILURE, NULL);
	(void) setenv("screen-#rows", buffer, 1);
	free(buffer);

	if (getenv("prompt") == NULL)
		(void) setenv("prompt", "${interpret}", 1);
	if (getenv("interpret") == NULL)
		(void) setenv("interpret", "ok", 1);

	if ((vm = bf_init("", NULL)) == NULL)
		err(EXIT_FAILURE, NULL);
	returnValue = ficlVmEvaluate(vm, ".ver cr quit");

	/*
	 * load files specified on command-line
	 */
	if (argc  > 1) {
		if (asprintf(&buffer, ".( loading %s ) cr include %s\n cr",
		    argv[1], argv[1]) < 0)
			err(EXIT_FAILURE, NULL);
		returnValue = ficlVmEvaluate(vm, buffer);
		free(buffer);
	}

	if ((gl = new_GetLine(LINELEN, HISTORY)) == NULL) {
		bf_fini();
		err(EXIT_FAILURE, NULL);
	}

	while (returnValue != FICL_VM_STATUS_USER_EXIT) {
		if ((buffer = gl_get_line(gl, prompt(), NULL, -1)) == NULL)
			break;
		returnValue = bf_run(buffer);
	}

	gl = del_GetLine(gl);
	bf_fini();
	if (returnValue != FICL_VM_STATUS_USER_EXIT)
		return (EXIT_FAILURE);
	return (EXIT_SUCCESS);
}



/* ============================================================================
 * SOURCE 32/98: minix4\exokernel\kernel_legacy\common\mapfiles\gen\main.c
 * Size: 951 bytes, Lines: 30
 * Hash: d5c97195b0a5...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

int
main()
{
	return (0);
}



/* ============================================================================
 * SOURCE 33/98: minix4\exokernel\kernel_legacy\cmd\acctadm\main.c
 * Size: 15,376 bytes, Lines: 561
 * Hash: 3cccbf18c40c...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (c) 2000, 2010, Oracle and/or its affiliates. All rights reserved.
 */

#include <sys/acctctl.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <libintl.h>
#include <libdllink.h>
#include <locale.h>
#include <priv.h>
#include <libscf.h>
#include <zone.h>

#include "utils.h"
#include "aconf.h"
#include "res.h"

#define	ACCTADM_NET_LOG_INTERVAL	20

static const char USAGE[] = "\
Usage:\n\
    acctadm [ {process | task | flow | net} ]\n\
    acctadm -s\n\
    acctadm -r [ {process | task | flow | net} ]\n\
    acctadm -x|-E|-D {process | task | flow | net}\n\
    acctadm -f filename {process | task | flow | net}\n\
    acctadm -e resources -d resources {process | task | flow | net}\n";

static const char OPTS[] = "rsxf:e:d:ED";

dladm_handle_t dld_handle = NULL;

static void
usage()
{
	(void) fprintf(stderr, gettext(USAGE));
	exit(E_USAGE);
}

static void
setup_privs()
{
	priv_set_t *privset;

	if (seteuid(getuid()) == -1 || setegid(getgid()) == -1)
		die(gettext("seteuid()/setegid() failed"));

	/*
	 * Add our privileges and remove unneeded 'basic' privileges from the
	 * permitted set.
	 */
	if ((privset = priv_str_to_set("basic", ",", NULL)) == NULL)
		die(gettext("cannot setup privileges"));

	(void) priv_addset(privset, PRIV_SYS_ACCT);
	(void) priv_addset(privset, PRIV_FILE_DAC_WRITE);
	(void) priv_addset(privset, PRIV_SYS_DL_CONFIG);
	(void) priv_delset(privset, PRIV_FILE_LINK_ANY);
	(void) priv_delset(privset, PRIV_PROC_EXEC);
	(void) priv_delset(privset, PRIV_PROC_FORK);
	(void) priv_delset(privset, PRIV_PROC_INFO);
	(void) priv_delset(privset, PRIV_PROC_SESSION);
	priv_inverse(privset);
	if (setppriv(PRIV_OFF, PRIV_PERMITTED, privset) == -1)
		die(gettext("cannot setup privileges"));
	priv_freeset(privset);

	/*
	 * Clear the Inheritable and Limit sets.
	 */
	if ((privset = priv_allocset()) == NULL)
		die(gettext("cannot setup privileges"));
	priv_emptyset(privset);
	if (setppriv(PRIV_SET, PRIV_INHERITABLE, privset) == -1 ||
	    setppriv(PRIV_SET, PRIV_LIMIT, privset) == -1)
		die(gettext("cannot setup privileges"));

	/*
	 * Turn off the sys_acct, file_dac_write and dl_config privileges
	 * until needed.
	 */
	(void) priv_set(PRIV_OFF, PRIV_EFFECTIVE, PRIV_FILE_DAC_WRITE,
	    PRIV_SYS_ACCT, PRIV_SYS_DL_CONFIG, NULL);
}

int
main(int argc, char *argv[])
{
	int c;			/* options character */
	int type = 0;		/* type of accounting */
	int modified = 0;	/* have we modified any properties? */
	acctconf_t ac;		/* current configuration */
	char *typestr = NULL;	/* type of accounting argument string */
	char *enabled = NULL;	/* enabled resources string */
	char *disabled = NULL;	/* disabled resources string */
	char *file = NULL;
	int Eflg = 0;
	int Dflg = 0;
	int rflg = 0;
	int sflg = 0;
	int xflg = 0;
	int optcnt = 0;
	int state;
	const char *fmri;	/* FMRI for this instance */
	int err = 0;

	setup_privs();

	(void) setlocale(LC_ALL, "");
	(void) textdomain(TEXT_DOMAIN);
	(void) setpname(argv[0]);

	for (; optind < argc; optind++) {
		while ((c = getopt(argc, argv, OPTS)) != (int)EOF) {
			switch (c) {
			case 'd':
				disabled = optarg;
				break;
			case 'e':
				enabled = optarg;
				break;
			case 'D':
				Dflg = 1;
				optcnt++;
				break;
			case 'E':
				Eflg = 1;
				optcnt++;
				break;
			case 'f':
				file = optarg;
				optcnt++;
				break;
			case 'r':
				rflg = 1;
				optcnt++;
				break;
			case 's':
				sflg = 1;
				optcnt++;
				break;
			case 'x':
				xflg = 1;
				optcnt++;
				break;
			case '?':
			default:
				usage();
			}
		}

		/*
		 * Permanently give up euid 0, egid 0 and privileges we
		 * don't need for the specified options.
		 */
		if (!(file || sflg)) {
			if (setreuid(getuid(), getuid()) == -1 ||
			    setregid(getgid(), getgid()) == -1)
				die(gettext("setreuid()/setregid() failed"));
			(void) priv_set(PRIV_OFF, PRIV_PERMITTED,
			    PRIV_FILE_DAC_WRITE, NULL);
		}
		if (!(disabled || enabled || Dflg || Eflg || file || sflg ||
		    xflg))
			(void) priv_set(PRIV_OFF, PRIV_PERMITTED,
			    PRIV_SYS_ACCT, PRIV_SYS_DL_CONFIG, NULL);

		if (optind < argc) {
			if (typestr != NULL) {
				warn(gettext("illegal argument -- %s\n"),
				    argv[optind]);
				usage();
			} else {
				typestr = argv[optind];
			}
		}
	}
	if (typestr != NULL) {
		if (strcmp(typestr, "process") == 0 ||
		    strcmp(typestr, "proc") == 0)
			type |= AC_PROC;
		else if (strcmp(typestr, "task") == 0)
			type |= AC_TASK;
		else if (strcmp(typestr, "flow") == 0)
			type |= AC_FLOW;
		else if (strcmp(typestr, "net") == 0)
			type |= AC_NET;
		else {
			warn(gettext("unknown accounting type -- %s\n"),
			    typestr);
			usage();
		}
	} else
		type = AC_PROC | AC_TASK | AC_FLOW | AC_NET;

	/*
	 * Drop the DL config privilege if we are not working with
	 * net.
	 */
	if ((type & AC_NET) == 0) {
		(void) priv_set(PRIV_OFF, PRIV_PERMITTED,
		    PRIV_SYS_DL_CONFIG, NULL);
	}
	/*
	 * check for invalid options
	 */
	if (optcnt > 1)
		usage();

	/*
	 * XXX For AC_NET, enabled/disabled should only be "basic" or
	 * "extended" - need to check it here.
	 */
	if ((enabled || disabled) && (rflg || Dflg || sflg || xflg || Eflg))
		usage();

	if ((file || xflg || Dflg || Eflg || enabled || disabled) &&
	    !typestr) {
		warn(gettext("accounting type must be specified\n"));
		usage();
	}

	if (rflg) {
		printgroups(type);
		return (E_SUCCESS);
	}

	/*
	 * If no arguments have been passed then just print out the current
	 * state and exit.
	 */
	if (!enabled && !disabled && !file &&
	    !Eflg && !rflg && !Dflg && !sflg && !xflg) {
		aconf_print(stdout, type);
		return (E_SUCCESS);
	}

	/* Open the libdladm handle */
	if (dladm_open(&dld_handle) != DLADM_STATUS_OK)
		die(gettext("failed to open dladm handle\n"));

	/*
	 * smf(7) start method.  The FMRI to operate on is retrieved from the
	 * SMF_FMRI environment variable that the restarter provides.
	 */
	if (sflg) {
		if ((fmri = getenv("SMF_FMRI")) != NULL) {
			int ret = aconf_setup(fmri);
			dladm_close(dld_handle);
			return (ret);
		}

		die(gettext("-s option should only be invoked by smf(7)\n"));
	}

	assert(type == AC_PROC || type == AC_TASK || type == AC_FLOW ||
	    type == AC_NET);

	if ((type == AC_FLOW || type == AC_NET) && getzoneid() != GLOBAL_ZONEID)
		die(gettext("%s accounting cannot be configured in "
		    "non-global zones\n"), ac_type_name(type));

	fmri = aconf_type2fmri(type);
	if (aconf_scf_init(fmri) == -1)
		die(gettext("cannot connect to repository for %s\n"), fmri);

	/*
	 * Since the sys_acct the privilege allows use of acctctl() regardless
	 * of the accounting type, we check the smf(7) authorizations granted
	 * to the user to determine whether the user is allowed to change the
	 * configuration for this particular accounting type.
	 */
	if (!aconf_have_smf_auths())
		die(gettext("insufficient authorization to change %s extended "
		    "accounting configuration\n"), ac_type_name(type));

	if (xflg) {
		/*
		 * Turn off the specified accounting and close its file
		 */

		/*
		 * Stop net logging before turning it off so that the last
		 * set of logs can be written.
		 */
		if (type & AC_NET) {
			(void) priv_set(PRIV_ON, PRIV_EFFECTIVE,
			    PRIV_SYS_DL_CONFIG, NULL);
			err = dladm_stop_usagelog(dld_handle,
			    DLADM_LOGTYPE_FLOW);
			(void) priv_set(PRIV_OFF, PRIV_EFFECTIVE,
			    PRIV_SYS_DL_CONFIG, NULL);
			if (err != DLADM_STATUS_OK) {
				die(gettext("failed to stop logging network "
				    "information, error %d\n"), errno);
			}
		}
		state = AC_OFF;

		(void) priv_set(PRIV_ON, PRIV_EFFECTIVE, PRIV_SYS_ACCT, NULL);
		if (acctctl(type | AC_STATE_SET, &state, sizeof (int)) == -1)
			die(gettext("cannot disable %s accounting"),
			    ac_type_name(type));
		if (acctctl(type | AC_FILE_SET, NULL, 0) == -1)
			die(gettext("cannot close %s accounting file\n"),
			    ac_type_name(type));
		(void) priv_set(PRIV_OFF, PRIV_EFFECTIVE, PRIV_SYS_ACCT, NULL);

		if (aconf_set_bool(AC_PROP_STATE, B_FALSE) == -1)
			die(gettext("cannot update %s property\n"),
			    AC_PROP_STATE);
		if (aconf_set_string(AC_PROP_FILE, AC_STR_NONE) == -1)
			die(gettext("cannot update %s property\n"),
			    AC_PROP_FILE);
		modified++;
	}

	if (enabled || disabled) {
		char *tracked, *untracked;
		ac_res_t *buf;

		/*
		 * Enable/disable resources
		 */
		if ((buf = malloc(AC_BUFSIZE)) == NULL)
			die(gettext("not enough memory\n"));
		(void) memset(buf, 0, AC_BUFSIZE);
		if (acctctl(type | AC_RES_GET, buf, AC_BUFSIZE) == -1) {
			free(buf);
			die(gettext("cannot obtain list of resources\n"));
		}
		if (disabled) {
			/*
			 * Stop net logging before turning it off so that the
			 * last set of logs can be written.
			 */
			if (type & AC_NET) {
				(void) priv_set(PRIV_ON, PRIV_EFFECTIVE,
				    PRIV_SYS_DL_CONFIG, NULL);
				err = dladm_stop_usagelog(dld_handle,
				    strcmp(disabled, "basic") == 0 ?
				    DLADM_LOGTYPE_LINK : DLADM_LOGTYPE_FLOW);
				(void) priv_set(PRIV_OFF, PRIV_EFFECTIVE,
				    PRIV_SYS_DL_CONFIG, NULL);
				if (err != DLADM_STATUS_OK) {
					die(gettext("failed to stop logging "
					    "network information, error %d\n"),
					    errno);
				}
			}
			str2buf(buf, disabled, AC_OFF, type);
		} else if (enabled) {
			str2buf(buf, enabled, AC_ON, type);
		}
		(void) priv_set(PRIV_ON, PRIV_EFFECTIVE, PRIV_SYS_ACCT, NULL);
		if (acctctl(type | AC_RES_SET, buf, AC_BUFSIZE) == -1) {
			free(buf);
			die(gettext("cannot enable/disable %s accounting "
			    "resources\n"), ac_type_name(type));
		}
		(void) priv_set(PRIV_OFF, PRIV_EFFECTIVE, PRIV_SYS_ACCT, NULL);
		tracked = buf2str(buf, AC_BUFSIZE, AC_ON, type);
		untracked = buf2str(buf, AC_BUFSIZE, AC_OFF, type);
		if (aconf_set_string(AC_PROP_TRACKED, tracked) == -1)
			die(gettext("cannot update %s property\n"),
			    AC_PROP_TRACKED);
		if (aconf_set_string(AC_PROP_UNTRACKED, untracked) == -1)
			die(gettext("cannot update %s property\n"),
			    AC_PROP_UNTRACKED);
		free(tracked);
		free(untracked);
		free(buf);
		modified++;
	}

	if (file) {
		/*
		 * Open new accounting file
		 */
		(void) priv_set(PRIV_ON, PRIV_EFFECTIVE, PRIV_SYS_ACCT, NULL);
		if (open_exacct_file(file, type) == -1) {
			dladm_close(dld_handle);
			exit(E_ERROR);
		}
		if (aconf_set_string(AC_PROP_FILE, file) == -1)
			die(gettext("cannot update %s property\n"),
			    AC_PROP_FILE);
		state = AC_ON;

		if (acctctl(type | AC_STATE_SET, &state, sizeof (int)) == -1)
			die(gettext("cannot enable %s accounting"),
			    ac_type_name(type));
		(void) priv_set(PRIV_OFF, PRIV_EFFECTIVE, PRIV_SYS_ACCT, NULL);

		if (aconf_set_bool(AC_PROP_STATE, B_TRUE) == -1)
			die(gettext("cannot update %s property\n"),
			    AC_PROP_STATE);
		modified++;
	}

	/*
	 * Let's get network logging started. We do this after turning on
	 * accounting and opening the file so that we can start writing
	 * immediately.
	 */
	if (enabled && (type & AC_NET)) {
		/*
		 * Default logging interval for AC_NET is
		 * ACCTADM_NET_LOG_INTERVAL.
		 */
		(void) priv_set(PRIV_ON, PRIV_EFFECTIVE,
		    PRIV_SYS_DL_CONFIG, NULL);
		err = dladm_start_usagelog(dld_handle,
		    strcmp(enabled, "basic") == 0 ?
		    DLADM_LOGTYPE_LINK : DLADM_LOGTYPE_FLOW,
		    ACCTADM_NET_LOG_INTERVAL);
		(void) priv_set(PRIV_OFF, PRIV_EFFECTIVE,
		    PRIV_SYS_DL_CONFIG, NULL);
		if (err != DLADM_STATUS_OK) {
			die(gettext("failed to start logging "
			    "network information, error %d\n"),
			    errno);
		}
	}

	if (Dflg) {
		/*
		 * Disable accounting
		 */

		/*
		 * Stop net logging before turning it off so that the last
		 * set of logs can be written.
		 */
		if (type & AC_NET) {
			(void) priv_set(PRIV_ON, PRIV_EFFECTIVE,
			    PRIV_SYS_DL_CONFIG, NULL);
			err = dladm_stop_usagelog(dld_handle,
			    DLADM_LOGTYPE_FLOW);
			(void) priv_set(PRIV_OFF, PRIV_EFFECTIVE,
			    PRIV_SYS_DL_CONFIG, NULL);
			if (err != DLADM_STATUS_OK) {
				die(gettext("failed to stop logging "
				    "network information, error %d\n"), errno);
			}
		}
		state = AC_OFF;

		(void) priv_set(PRIV_ON, PRIV_EFFECTIVE, PRIV_SYS_ACCT, NULL);
		if (acctctl(type | AC_STATE_SET, &state, sizeof (int)) == -1)
			die(gettext("cannot disable %s accounting"),
			    ac_type_name(type));
		(void) priv_set(PRIV_OFF, PRIV_EFFECTIVE, PRIV_SYS_ACCT, NULL);

		if (aconf_set_bool(AC_PROP_STATE, B_FALSE) == -1)
			die(gettext("cannot update %s property\n"),
			    AC_PROP_STATE);
		modified++;
	}

	if (Eflg) {
		/*
		 * Enable accounting
		 */

		/*
		 * Let's get network logging started.
		 */
		if (type & AC_NET) {
			/*
			 * Default logging interval for AC_NET is
			 * ACCTADM_NET_LOG_INTERVAL.
			 */
			(void) priv_set(PRIV_ON, PRIV_EFFECTIVE,
			    PRIV_SYS_DL_CONFIG, NULL);
			err = dladm_start_usagelog(dld_handle,
			    DLADM_LOGTYPE_FLOW, ACCTADM_NET_LOG_INTERVAL);
			(void) priv_set(PRIV_OFF, PRIV_EFFECTIVE,
			    PRIV_SYS_DL_CONFIG, NULL);
			if (err != DLADM_STATUS_OK) {
				die(gettext("failed to start logging "
				    "network information, error %d\n"), errno);
			}
		}
		state = AC_ON;

		(void) priv_set(PRIV_ON, PRIV_EFFECTIVE, PRIV_SYS_ACCT, NULL);
		if (acctctl(type | AC_STATE_SET, &state, sizeof (int)) == -1)
			die(gettext("cannot enable %s accounting"),
			    ac_type_name(type));
		(void) priv_set(PRIV_OFF, PRIV_EFFECTIVE, PRIV_SYS_ACCT, NULL);

		if (aconf_set_bool(AC_PROP_STATE, B_TRUE) == -1)
			die(gettext("cannot update %s property\n"),
			    AC_PROP_STATE);
		modified++;
	}
	(void) priv_set(PRIV_OFF, PRIV_PERMITTED, PRIV_SYS_ACCT, NULL);

	if (modified) {
		char *smf_state;

		if (aconf_save() == -1)
			die(gettext("cannot save %s accounting "
			    "configuration\n"), ac_type_name(type));

		/*
		 * Enable or disable the instance depending on the effective
		 * configuration.  If the effective configuration results in
		 * extended accounting being 'on', the instance is enabled so
		 * the configuration is applied at the next boot.
		 */
		smf_state = smf_get_state(fmri);
		aconf_init(&ac, type);

		if (ac.state == AC_ON ||
		    strcmp(ac.file, AC_STR_NONE) != 0 ||
		    strcmp(ac.tracked, AC_STR_NONE) != 0) {
			if (strcmp(smf_state, SCF_STATE_STRING_ONLINE) != 0)
				if (smf_enable_instance(fmri, 0) == -1)
					die(gettext("cannot enable %s\n"),
					    fmri);
		} else {
			if (strcmp(smf_state, SCF_STATE_STRING_ONLINE) == 0)
				if (smf_disable_instance(fmri, 0) == -1)
					die(gettext("cannot disable %s\n"),
					    fmri);
		}
		free(smf_state);
	}
	aconf_scf_fini();
	dladm_close(dld_handle);
	return (E_SUCCESS);
}



/* ============================================================================
 * SOURCE 34/98: minix4\exokernel\kernel_legacy\cmd\auditreduce\main.c
 * Size: 27,657 bytes, Lines: 1,094
 * Hash: abc5ad8b087a...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

/*
 * Copyright 2019 Joyent, Inc.
 * Copyright 2024 Oxide Computer Company
 */

/*
 * The Secure SunOS audit reduction tool - auditreduce.
 * Document SM0071 is the primary source of information on auditreduce.
 *
 * Composed of 4 source modules:
 * main.c - main driver.
 * option.c - command line option processing.
 * process.c - record/file/process functions.
 * time.c - date/time handling.
 *
 * Main(), write_header(), audit_stats(), and a_calloc()
 * are the only functions visible outside this module.
 */

#include <siginfo.h>
#include <locale.h>
#include <libintl.h>
#include "auditr.h"
#include "auditrd.h"

#if !defined(TEXT_DOMAIN)
#define	TEXT_DOMAIN "SUNW_OST_OSCMD"
#endif

extern void	derive_str(time_t, char *);
extern int	process_options(int, char **);
extern int	mproc(audit_pcb_t *);
extern void	init_tokens(void);	/* shared with praudit */

static int	a_pow(int, int);
static void	calc_procs(void);
static void	chld_handler(int);
static int	close_outfile(void);
static void	c_close(audit_pcb_t *, int);
static void	delete_infiles(void);
static void	gather_pcb(audit_pcb_t *, int, int);
static void	init_options(void);
static int	init_sig(void);
static void	int_handler(int);
static int	mfork(audit_pcb_t *, int, int, int);
static void	mcount(int, int);
static int	open_outfile(void);
static void	p_close(audit_pcb_t *);
static int	rename_outfile(void);
static void	rm_mem(audit_pcb_t *);
static void	rm_outfile(void);
static void	trim_mem(audit_pcb_t *);
static int	write_file_token(time_t);
static int	write_trailer(void);

/*
 * File globals.
 */
static int	max_sproc;	/* maximum number of subprocesses per process */
static int	total_procs;	/* number of processes in the process tree */
static int	total_layers;	/* number of layers in the process tree */

/*
 * .func main - main.
 * .desc The beginning. Main() calls each of the initialization routines
 *	and then allocates the root pcb. Then it calls mfork() to get
 *	the work done.
 * .call	main(argc, argv).
 * .arg	argc	- number of arguments.
 * .arg	argv	- array of pointers to arguments.
 * .ret	0	- via exit() - no errors detected.
 * .ret	1	- via exit() - errors detected (messages printed).
 */
int
main(int argc, char **argv)
{
	int	ret;
	audit_pcb_t *pcb;

	/* Internationalization */
	(void) setlocale(LC_ALL, "");
	(void) textdomain(TEXT_DOMAIN);

	root_pid = getpid();	/* know who is root process for error */
	init_options();		/* initialize options */
	init_tokens();		/* initialize token processing table */
	if (init_sig())		/* initialize signals */
		exit(1);
	if (process_options(argc, argv))
		exit(1);	/* process command line options */
	if (open_outfile())	/* setup root process output stream */
		exit(1);
	calc_procs();		/* see how many subprocesses we need */
	/*
	 * Allocate the root pcb and set it up.
	 */
	pcb = (audit_pcb_t *)a_calloc(1, sizeof (audit_pcb_t));
	pcb->pcb_procno = root_pid;
	pcb->pcb_flags |= PF_ROOT;
	pcb->pcb_fpw = stdout;
	pcb->pcb_time = -1;
	/*
	 * Now start the whole thing rolling.
	 */
	if (mfork(pcb, pcbnum, 0, pcbnum - 1)) {
		/*
		 * Error in processing somewhere. A message is already printed.
		 * Display usage statistics and remove the outfile.
		 */
		if (getpid() == root_pid) {
			audit_stats();
			(void) close_outfile();
			rm_outfile();
		}
		exit(1);
	}
	/*
	 * Clean up afterwards.
	 * Only do outfile cleanup if we are root process.
	 */
	if (getpid() == root_pid) {
		if ((ret = write_trailer()) == 0) { /* write trailer to file */

			ret = close_outfile();	/* close the outfile */
		}
		/*
		 * If there was an error in cleanup then remove outfile.
		 */
		if (ret) {
			rm_outfile();
			exit(1);
		}
		/*
		 * And lastly delete the infiles if the user so wishes.
		 */
		if (f_delete)
			delete_infiles();
	}
	return (0);
/*NOTREACHED*/
}


/*
 * .func mfork - main fork routine.
 * .desc Create a (sub-)tree of processses if needed, or just do the work
 *	if we have few enough groups to process. This is a recursive routine
 *	which stops recursing when the number of files to process is small
 *	enough. Each call to mfork() is responsible for a range of pcbs
 *	from audit_pcbs[]. This range is designated by the lo and hi
 *	arguments (inclusive). If the number of pcbs is small enough
 *	then we have hit a leaf of the tree and mproc() is called to
 *	do the processing. Otherwise we fork some processes and break
 *	the range of pcbs up amongst them.
 * .call	ret = mfork(pcb, nsp, lo, hi).
 * .arg	pcb	- ptr to pcb that is root node of the to-be-created tree.
 * .arg	nsp	- number of sub-processes this tree must process.
 * .arg	lo	- lower-limit of process number range. Index into audit_pcbs.
 * .arg	hi	- higher limit of pcb range. Index into audit_pcbs.
 * .ret	0	- succesful completion.
 * .ret	-1	- error encountered in processing - message already printed.
 */
static int
mfork(audit_pcb_t *pcb, int nsp, int lo, int hi)
{
	int	range, procno, i, tofork, nnsp, nrem;
	int	fildes[2];
	audit_pcb_t *pcbn;

#if AUDIT_PROC_TRACE
	(void) fprintf(stderr, "mfork: nsp %d %d->%d\n", nsp, lo, hi);
#endif

	/*
	 * The range of pcb's to process is small enough now. Do the work.
	 */
	if (nsp <= max_sproc) {
		pcb->pcb_flags |= PF_LEAF;	/* leaf in process tree */
		pcb->pcb_below = audit_pcbs;	/* proc pcbs from audit_pcbs */
		gather_pcb(pcb, lo, hi);
		trim_mem(pcb);			/* trim allocated memory */
		return (mproc(pcb));		/* do the work */
	}
	/*
	 * Too many pcb's for one process - must fork.
	 * Try to balance the tree as it grows and make it short and fat.
	 * The thing to minimize is the number of times a record passes
	 * through a pipe.
	 */
	else {
		/*
		 * Fork less than the maximum number of processes.
		 */
		if (nsp <= max_sproc * (max_sproc - 1)) {
			tofork = nsp / max_sproc;
			if (nsp % max_sproc)
				tofork++;	/* how many to fork */
		}
		/*
		 * Fork the maximum number of processes.
		 */
		else {
			tofork = max_sproc;	/* how many to fork */
		}
		/*
		 * Allocate the nodes below us in the process tree.
		 */
		pcb->pcb_below = (audit_pcb_t *)a_calloc(tofork, sizeof (*pcb));
		nnsp = nsp / tofork;	/* # of pcbs per forked process */
		nrem = nsp % tofork;	/* remainder to spread around */
		/*
		 * Loop to fork all of the subs. Open a pipe for each.
		 * If there are any errors in pipes, forks, or getting streams
		 * for the pipes then quit altogether.
		 */
		for (i = 0; i < tofork; i++) {
			pcbn = &pcb->pcb_below[i];
			pcbn->pcb_time = -1;
			if (pipe(fildes)) {
				perror(gettext(
				    "auditreduce: couldn't get a pipe"));
				return (-1);
			}
			/*
			 * Convert descriptors to streams.
			 */
			if ((pcbn->pcb_fpr = fdopen(fildes[0], "r")) == NULL) {
				perror(gettext("auditreduce: couldn't get read "
				    "stream for pipe"));
				return (-1);
			}
			if ((pcbn->pcb_fpw = fdopen(fildes[1], "w")) == NULL) {
				perror(gettext("auditreduce: couldn't get "
				    "write stream for pipe"));
				return (-1);
			}
			if ((procno = fork()) == -1) {
				perror(gettext("auditreduce: fork failed"));
				return (-1);
			}
			/*
			 * Calculate the range of pcbs from audit_pcbs [] this
			 * branch of the tree will be responsible for.
			 */
			range = (nrem > 0) ? nnsp + 1 : nnsp;
			/*
			 * Child route.
			 */
			if (procno == 0) {
				pcbn->pcb_procno = getpid();
				c_close(pcb, i); /* close unused streams */
				/*
				 * Continue resolving this branch.
				 */
				return (mfork(pcbn, range, lo, lo + range - 1));
			}
			/* Parent route. */
			else {
				pcbn->pcb_procno = i;
				/* allocate buffer to hold record */
				pcbn->pcb_rec = (char *)a_calloc(1,
				    AUDITBUFSIZE);
				pcbn->pcb_size = AUDITBUFSIZE;
				p_close(pcbn);	/* close unused streams */

				nrem--;
				lo += range;
			}
		}
		/*
		 * Done forking all of the subs.
		 */
		gather_pcb(pcb, 0, tofork - 1);
		trim_mem(pcb);			/* free unused memory */
		return (mproc(pcb));
	}
}


/*
 * .func	trim_mem - trim memory usage.
 * .desc	Free un-needed allocated memory.
 * .call	trim_mem(pcb).
 * .arg	pcb	- ptr to pcb for current process.
 * .ret	void.
 */
static void
trim_mem(audit_pcb_t *pcb)
{
	int	count;
	size_t	size;

	/*
	 * For the root don't free anything. We need to save audit_pcbs[]
	 * in case we are deleting the infiles at the end.
	 */
	if (pcb->pcb_flags & PF_ROOT)
		return;
	/*
	 * For a leaf save its part of audit_pcbs[] and then remove it all.
	 */
	if (pcb->pcb_flags & PF_LEAF) {
		count = pcb->pcb_count;
		size = sizeof (audit_pcb_t);
		/* allocate a new buffer to hold the pcbs */
		pcb->pcb_below = (audit_pcb_t *)a_calloc(count, size);
		/* save this pcb's portion */
		(void) memcpy((void *) pcb->pcb_below,
		    (void *) &audit_pcbs[pcb->pcb_lo], count * size);
		rm_mem(pcb);
		gather_pcb(pcb, 0, count - 1);
	}
		/*
		 * If this is an intermediate node then just remove it all.
		 */
	else {
		rm_mem(pcb);
	}
}


/*
 * .func	rm_mem - remove memory.
 * .desc	Remove unused memory associated with audit_pcbs[]. For each
 *	pcb in audit_pcbs[] free the record buffer and all of
 *	the fcbs. Then free audit_pcbs[].
 * .call	rm_mem(pcbr).
 * .arg	pcbr	- ptr to pcb of current process.
 * .ret	void.
 */
static void
rm_mem(audit_pcb_t *pcbr)
{
	int	i;
	audit_pcb_t *pcb;
	audit_fcb_t *fcb, *fcbn;

	for (i = 0; i < pcbsize; i++) {
		/*
		 * Don't free the record buffer and fcbs for the pcbs this
		 * process is using.
		 */
		if (pcbr->pcb_flags & PF_LEAF) {
			if (pcbr->pcb_lo <= i || i <= pcbr->pcb_hi)
				continue;
		}
		pcb = &audit_pcbs[i];
		free(pcb->pcb_rec);
		for (fcb = pcb->pcb_first; fcb != NULL; /* */) {
			fcbn = fcb->fcb_next;
			free((char *)fcb);
			fcb = fcbn;
		}
	}
	free((char *)audit_pcbs);
}


/*
 * .func	c_close - close unused streams.
 * .desc	This is called for each child process just after being born.
 *	The child closes the read stream for the pipe to its parent.
 *	It also closes the read streams for the other children that
 *	have been born before it. If any closes fail a warning message
 *	is printed, but processing continues.
 * .call	ret = c_close(pcb, i).
 * .arg	pcb	- ptr to the child's parent pcb.
 * .arg	i	- iteration # of child in forking loop.
 * .ret	void.
 */
static void
c_close(audit_pcb_t *pcb, int	i)
{
	int	j;
	audit_pcb_t *pcbt;

	/*
	 * Do all pcbs in parent's group up to and including us
	 */
	for (j = 0; j <= i; j++) {
		pcbt = &pcb->pcb_below[j];
		if (fclose(pcbt->pcb_fpr) == EOF) {
			if (!f_quiet) {
				perror(gettext("auditreduce: initial close "
				    "on pipe failed"));
			}
		}
		/*
		 * Free the buffer allocated to hold incoming records.
		 */
		if (i != j) {
			free(pcbt->pcb_rec);
		}
	}
}


/*
 * .func	p_close - close unused streams for parent.
 * .desc	Called by the parent right after forking a child.
 *	Closes the write stream on the pipe to the child since
 *	we will never use it.
 * .call	p_close(pcbn),
 * .arg	pcbn	- ptr to pcb.
 * .ret	void.
 */
static void
p_close(audit_pcb_t *pcbn)
{
	if (fclose(pcbn->pcb_fpw) == EOF) {
		if (!f_quiet) {
			perror(gettext("auditreduce: close for write "
			    "pipe failed"));
		}
	}
}


/*
 * .func	audit_stats - print statistics.
 * .desc	Print usage statistics for the user if the run fails.
 *	Tells them how many files they had and how many groups this
 *	totalled. Also tell them how many layers and processes the
 *	process tree had.
 * .call	audit_stats().
 * .arg	none.
 * .ret	void.
 */
void
audit_stats(void)
{
	struct rlimit rl;

	if (getrlimit(RLIMIT_NOFILE, &rl) != -1) {
		(void) fprintf(stderr,
		    gettext("%s The system allows %d files per process.\n"),
		    ar, rl.rlim_cur);
	}
	(void) fprintf(stderr, gettext(
	    "%s There were %d file(s) %d file group(s) %d process(es) "
	    "%d layer(s).\n"),
	    ar, filenum, pcbnum, total_procs, total_layers);
}


/*
 * .func gather_pcb - gather pcbs.
 * .desc Gather together the range of the sub-processes that we are
 *	responsible for. For a pcb that controls processes this is all
 *	of the sub-processes that it forks. For a pcb that controls
 *	files this is the the range of pcbs from audit_pcbs[].
 * .call gather_pcb(pcb, lo, hi).
 * .arg	pcb	- ptr to pcb.
 * .arg	lo	- lo index into pcb_below.
 * .arg	hi	- hi index into pcb_below.
 * .ret	void.
 */
static void
gather_pcb(audit_pcb_t *pcb, int lo, int hi)
{
	pcb->pcb_lo = lo;
	pcb->pcb_hi = hi;
	pcb->pcb_count = hi - lo + 1;
}


/*
 * .func calc_procs - calculate process parameters.
 * .desc Calculate the current run's paramters regarding how many
 *	processes will have to be forked (maybe none).
 *	5 is subtracted from maxfiles_proc to allow for stdin, stdout,
 *	stderr, and the pipe to a parent process. The outfile
 *	in the root process is assigned to stdout. The unused half of each
 *	pipe is closed, to allow for more connections, but we still
 *	have to have the 5th spot because in order to get the pipe
 *	we need 2 descriptors up front.
 * .call calc_procs().
 * .arg	none.
 * .ret	void.
 */
static void
calc_procs(void)
{
	int	val;
	int	maxfiles_proc;
	struct rlimit rl;

	if (getrlimit(RLIMIT_NOFILE, &rl) == -1) {
		perror("auditreduce: getrlimit");
		exit(1);
	}

	maxfiles_proc = rl.rlim_cur;

	max_sproc = maxfiles_proc - 5;	/* max subprocesses per process */

	/*
	 * Calculate how many layers the process tree has.
	 */
	total_layers = 1;
	for (/* */; /* */; /* */) {
		val = a_pow(max_sproc, total_layers);
		if (val > pcbnum)
			break;
		total_layers++;
	}
	/*
	 * Count how many processes are in the process tree.
	 */
	mcount(pcbnum, 0);

#if AUDIT_PROC_TRACE
	(void) fprintf(stderr,
	    "pcbnum %d filenum %d mfp %d msp %d ly %d tot %d\n\n",
	    pcbnum, filenum, maxfiles_proc, max_sproc,
	    total_layers, total_procs);
#endif
}


static int
a_pow(int base, int exp)
{
	int	i;
	int	answer;

	if (exp == 0) {
		answer = 1;
	} else {
		answer = base;
		for (i = 0; i < (exp - 1); i++)
			answer *= base;
	}
	return (answer);
}


/*
 * .func mcount - main count.
 * .desc Go through the motions of building the process tree just
 *	to count how many processes there are. Don't really
 *	build anything. Answer is in global var total_procs.
 * .call mcount(nsp, lo).
 * .arg	nsp	- number of subs for this tree branch.
 * .arg	lo	- lo side of range of subs.
 * .ret	void.
 */
static void
mcount(int nsp, int lo)
{
	int	range, i, tofork, nnsp, nrem;

	total_procs++;		/* count another process created */

	if (nsp > max_sproc) {
		if (nsp <= max_sproc * (max_sproc - 1)) {
			tofork = nsp / max_sproc;
			if (nsp % max_sproc)
				tofork++;
		} else {
			tofork = max_sproc;
		}
		nnsp = nsp / tofork;
		nrem = nsp % tofork;
		for (i = 0; i < tofork; i++) {
			range = (nrem > 0) ? nnsp + 1 : nnsp;
			mcount(range, lo);
			nrem--;
			lo += range;
		}
	}
}


/*
 * .func delete_infiles - delete the input files.
 * .desc If the user asked us to (via 'D' flag) then unlink the input files.
 * .call ret = delete_infiles().
 * .arg none.
 * .ret void.
 */
static void
delete_infiles(void)
{
	int	i;
	audit_pcb_t *pcb;
	audit_fcb_t *fcb;

	for (i = 0; i < pcbsize; i++) {
		pcb = &audit_pcbs[i];
		fcb = pcb->pcb_dfirst;
		while (fcb != NULL) {
			/*
			 * Only delete a file if it was succesfully processed.
			 * If there were any read errors or bad records
			 * then don't delete it.
			 * There may still be unprocessed records in it.
			 */
			if (fcb->fcb_flags & FF_DELETE) {
				if (unlink(fcb->fcb_file)) {
					if (f_verbose) {
						(void) sprintf(errbuf, gettext(
						    "%s delete on %s failed"),
						    ar, fcb->fcb_file);
					}
					perror(errbuf);
				}
			}
			fcb = fcb->fcb_next;
		}
	}
}


/*
 * .func rm_outfile - remove the outfile.
 * .desc Remove the file we are writing the records to. We do this if
 *	processing failed and we are quitting before finishing.
 *	Update - don't actually remove the outfile, but generate
 *	a warning about its possible heathen nature.
 * .call ret = rm_outfile().
 * .arg	none.
 * .ret	void.
 */
static void
rm_outfile(void)
{
#if 0
	if (f_outfile) {
		if (unlink(f_outtemp) == -1) {
			(void) sprintf(errbuf,
			    gettext("%s delete on %s failed"),
			    ar, f_outtemp);
			perror(errbuf);
		}
	}
#else
	(void) fprintf(stderr,
	    gettext(
	    "%s Warning: Incomplete audit file may have been generated - %s\n"),
	    ar,
	    (f_outfile == NULL) ? gettext("standard output") : f_outfile);
#endif
}


/*
 * .func	close_outfile - close the outfile.
 * .desc	Close the file we are writing records to.
 * .call	ret = close_outfile().
 * .arg	none.
 * .ret	0	- close was succesful.
 * .ret	-1	- close failed.
 */
static int
close_outfile(void)
{
	if (fclose(stdout) == EOF) {
		(void) sprintf(errbuf, gettext("%s close on %s failed"),
		    ar, f_outfile ? f_outfile : "standard output");
		perror(errbuf);
		return (-1);
	}
	(void) fsync(fileno(stdout));
	return (rename_outfile());
}


/*
 * .func write_header - write audit file header.
 * .desc Write an audit file header to the output stream. The time in the
 *	header is the time of the first record written to the stream. This
 *	routine is called by the process handling the root node of the
 *	process tree just before it writes the first record to the output
 *	stream.
 * .ret	0 - succesful write.
 * .ret -1 - failed write - message printed.
 */
int
write_header(void)
{
	return (write_file_token(f_start));
}


static int
write_file_token(time_t when)
{
	adr_t adr;			/* adr ptr */
	struct timeval tv;		/* time now */
	char	for_adr[16];		/* plenty of room */
#ifdef _LP64
	char	token_id = AUT_OTHER_FILE64;
#else
	char	token_id = AUT_OTHER_FILE32;
#endif
	short	i = 1;
	char	c = '\0';

	tv.tv_sec = when;
	tv.tv_usec = 0;
	adr_start(&adr, for_adr);
	adr_char(&adr, &token_id, 1);
#ifdef _LP64
	adr_int64(&adr, (int64_t *)&tv, 2);
#else
	adr_int32(&adr, (int32_t *)&tv, 2);
#endif
	adr_short(&adr, &i, 1);
	adr_char(&adr, &c, 1);

	if (fwrite(for_adr, sizeof (char), adr_count(&adr), stdout) !=
	    adr_count(&adr)) {
		if (when == f_start) {
			(void) sprintf(errbuf,
			    gettext("%s error writing header to %s. "),
			    ar,
			    f_outfile ? f_outfile :
			    gettext("standard output"));
		} else {
			(void) sprintf(errbuf,
			    gettext("%s error writing trailer to %s. "),
			    ar,
			    f_outfile ? f_outfile :
			    gettext("standard output"));
		}
		perror(errbuf);
		return (-1);
	}
	return (0);
}


/*
 * .func  write_trailer - write audit file trailer.
 * .desc  Write an audit file trailer to the output stream. The finish
 *	time for the trailer is the time of the last record written
 *	to the stream.
 * .ret	0 - succesful write.
 * .ret	-1 - failed write - message printed.
 */
static int
write_trailer(void)
{
	return (write_file_token(f_end));
}


/*
 * .func rename_outfile - rename the outfile.
 * .desc If the user used the -O flag they only gave us the suffix name
 *	for the outfile. We have to add the time stamps to put the filename
 *	in the proper audit file name format. The start time will be the time
 *	of the first record in the file and the end time will be the time of
 *	the last record in the file.
 * .ret	0 - rename succesful.
 * .ret	-1 - rename failed - message printed.
 */
static int
rename_outfile(void)
{
	static char f_newfile[MAXFILELEN];
	char	buf1[15], buf2[15];
	char	*f_file, *f_nfile, *f_time, *f_name;

	if (f_outfile != NULL) {
		/*
		 * Get string representations of start and end times.
		 */
		derive_str(f_start, buf1);
		derive_str(f_end, buf2);

		f_nfile = f_time = f_newfile;	/* working copy */
		f_file = f_name = f_outfile;	/* their version */
		while (*f_file) {
			if (*f_file == '/') {	/* look for filename */
				f_time = f_nfile + 1;
				f_name = f_file + 1;
			}
			*f_nfile++ = *f_file++;	/* make copy of their version */
		}
		*f_time = '\0';
		/* start time goes first */
		(void) strcat(f_newfile, buf1);
		(void) strcat(f_newfile, ".");
		/* then the finish time */
		(void) strcat(f_newfile, buf2);
		(void) strcat(f_newfile, ".");
		/* and the name they gave us */
		(void) strcat(f_newfile, f_name);

#if AUDIT_FILE
		(void) fprintf(stderr, "rename_outfile: <%s> --> <%s>\n",
		    f_outfile, f_newfile);
#endif

#if AUDIT_RENAME
		if (rename(f_outtemp, f_newfile) == -1) {
			(void) fprintf(stderr,
			    "%s rename of %s to %s failed.\n",
			    ar, f_outtemp, f_newfile);
			return (-1);
		}
		f_outfile = f_newfile;
#else
		if (rename(f_outtemp, f_outfile) == -1) {
			(void) fprintf(stderr,
			    gettext("%s rename of %s to %s failed.\n"),
			    ar, f_outtemp, f_outfile);
			return (-1);
		}
#endif
	}
	return (0);
}


/*
 * .func open_outfile - open the outfile.
 * .desc Open the outfile specified by the -O option. Assign it to the
 *	the standard output. Get a unique temporary name to use so we
 *	don't clobber an existing file.
 * .ret	0 - no errors detected.
 * .ret	-1 - errors in processing (message already printed).
 */
static int
open_outfile(void)
{
	int	tmpfd = -1;

	if (f_outfile != NULL) {
		f_outtemp = (char *)a_calloc(1, strlen(f_outfile) + 8);
		(void) strcpy(f_outtemp, f_outfile);
		(void) strcat(f_outtemp, "XXXXXX");
		if ((tmpfd = mkstemp(f_outtemp)) == -1) {
			(void) sprintf(errbuf,
			    gettext("%s couldn't create temporary file"), ar);
			perror(errbuf);
			return (-1);
		}
		(void) fflush(stdout);
		if (tmpfd != fileno(stdout)) {
			if ((dup2(tmpfd, fileno(stdout))) == -1) {
				(void) sprintf(errbuf,
				    gettext("%s can't assign %s to the "
				    "standard output"), ar, f_outfile);
				perror(errbuf);
				return (-1);
			}
			(void) close(tmpfd);
		}
	}
	return (0);
}


/*
 * .func init_options - initialize the options.
 * .desc Give initial and/or default values to some options.
 * .call init_options();
 * .arg	none.
 * .ret	void.
 */
static void
init_options(void)
{
	struct timeval tp;
	struct timezone tpz;

	/*
	 * Get current time for general use.
	 */
	if (gettimeofday(&tp, &tpz) == -1)
		perror(gettext("auditreduce: initial getttimeofday failed"));

	time_now = tp.tv_sec;		/* save for general use */
	f_start = 0;			/* first record time default */
	f_end = time_now;		/* last record time default */
	m_after = 0;			/* Jan 1, 1970 00:00:00 */

	/*
	 * Setup initial size of audit_pcbs[].
	 */
	pcbsize = PCB_INITSIZE;		/* initial size of file-holding pcb's */

	audit_pcbs = (audit_pcb_t *)a_calloc(pcbsize, sizeof (audit_pcb_t));

	/* description of 'current' error */
	error_str = gettext("initial error");

}


/*
 * .func a_calloc - audit calloc.
 * .desc Calloc with check for failure. This is called by all of the
 *	places that want memory.
 * .call ptr = a_calloc(nelem, size).
 * .arg	nelem - number of elements to allocate.
 * .arg	size - size of each element.
 * .ret	ptr - ptr to allocated and zeroed memory.
 * .ret	never - if calloc fails then we never return.
 */
void	*
a_calloc(int nelem, size_t size)
{
	void	*ptr;

	if ((ptr = calloc((unsigned)nelem, size)) == NULL) {
		perror(gettext("auditreduce: memory allocation failed"));
		exit(1);
	}
	return (ptr);
}


/*
 * .func init_sig - initial signal catching.
 *
 * .desc
 *	Setup the signal catcher to catch the SIGCHLD signal plus
 *	"environmental" signals -- keyboard plus other externally
 *	generated signals such as out of file space or cpu time.  If a
 *	child exits with either a non-zero exit code or was killed by
 *	a signal to it then we will also exit with a non-zero exit
 *	code. In this way abnormal conditions can be passed up to the
 *	root process and the entire run be halted. Also catch the int
 *	and quit signals. Remove the output file since it is in an
 *	inconsistent state.
 * .call ret = init_sig().
 * .arg none.
 * .ret 0 - no errors detected.
 * .ret -1 - signal failed (message printed).
 */
static int
init_sig(void)
{
	if (signal(SIGCHLD, chld_handler) == SIG_ERR) {
		perror(gettext("auditreduce: SIGCHLD signal failed"));
		return (-1);
	}

	if (signal(SIGHUP, int_handler) == SIG_ERR) {
		perror(gettext("auditreduce: SIGHUP signal failed"));
		return (-1);
	}
	if (signal(SIGINT, int_handler) == SIG_ERR) {
		perror(gettext("auditreduce: SIGINT signal failed"));
		return (-1);
	}
	if (signal(SIGQUIT, int_handler) == SIG_ERR) {
		perror(gettext("auditreduce: SIGQUIT signal failed"));
		return (-1);
	}
	if (signal(SIGABRT, int_handler) == SIG_ERR) {
		perror(gettext("auditreduce: SIGABRT signal failed"));
		return (-1);
	}
	if (signal(SIGTERM, int_handler) == SIG_ERR) {
		perror(gettext("auditreduce: SIGTERM signal failed"));
		return (-1);
	}
	if (signal(SIGPWR, int_handler) == SIG_ERR) {
		perror(gettext("auditreduce: SIGPWR signal failed"));
		return (-1);
	}
	if (signal(SIGXCPU, int_handler) == SIG_ERR) {
		perror(gettext("auditreduce: SIGXCPU signal failed"));
		return (-1);
	}
	if (signal(SIGXFSZ, int_handler) == SIG_ERR) {
		perror(gettext("auditreduce: SIGXFSZ signal failed"));
		return (-1);
	}
	if (signal(SIGSEGV, int_handler) == SIG_ERR) {
		perror(gettext("auditreduce: SIGSEGV signal failed"));
		return (-1);
	}

	return (0);
}


/*
 * .func chld_handler - handle child signals.
 * .desc Catch the SIGCHLD signals. Remove the root process
 *	output file because it is in an inconsistent state.
 *	Print a message giving the signal number and/or return code
 *	of the child who caused the signal.
 * .ret	void.
 */
/* ARGSUSED */
void
chld_handler(int sig)
{
	int	pid;
	int	status;

	/*
	 * Get pid and reasons for cause of event.
	 */
	pid = wait(&status);

	if (pid > 0) {
		/*
		 * If child received a signal or exited with a non-zero
		 * exit status then print message and exit
		 */
		if ((WHIBYTE(status) == 0 && WLOBYTE(status) != 0) ||
		    (WHIBYTE(status) != 0 && WLOBYTE(status) == 0)) {
			(void) fprintf(stderr,
			    gettext("%s abnormal child termination - "), ar);

			if (WHIBYTE(status) == 0 && WLOBYTE(status) != 0) {
				psignal(WLOBYTE(status), "signal");
				if (WCOREDUMP(status))
					(void) fprintf(stderr,
					    gettext("core dumped\n"));
			}

			if (WHIBYTE(status) != 0 && WLOBYTE(status) == 0) {
				(void) fprintf(stderr,
				    gettext("return code %d\n"),
				    WHIBYTE(status));
			}

			/*
			 * Get rid of outfile - it is suspect.
			 */
			if (f_outfile != NULL) {
				(void) close_outfile();
				rm_outfile();
			}
			/*
			 * Give statistical info that may be useful.
			 */
			audit_stats();

			exit(1);
		}
	}
}


/*
 * .func	int_handler - handle quit/int signals.
 * .desc	Catch the keyboard and other environmental signals.
 *		Remove the root process output file because it is in
 *		an inconsistent state.
 * .ret	void.
 */
/* ARGSUSED */
void
int_handler(int sig)
{
	if (getpid() == root_pid) {
		(void) close_outfile();
		rm_outfile();
		exit(1);
	}
	/*
	 * For a child process don't give an error exit or the
	 * parent process will catch it with the chld_handler and
	 * try to erase the outfile again.
	 */
	exit(0);
}



/* ============================================================================
 * SOURCE 35/98: minix4\exokernel\kernel_legacy\cmd\awk\main.c
 * Size: 7,170 bytes, Lines: 268
 * Hash: 614241086198...
 * ============================================================================ */

/*
 * Copyright (C) Lucent Technologies 1997
 * All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and
 * its documentation for any purpose and without fee is hereby
 * granted, provided that the above copyright notice appear in all
 * copies and that both that the copyright notice and this
 * permission notice and warranty disclaimer appear in supporting
 * documentation, and that the name Lucent Technologies or any of
 * its entities not be used in advertising or publicity pertaining
 * to distribution of the software without specific, written prior
 * permission.
 *
 * LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
 * IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY
 * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
 * THIS SOFTWARE.
 */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

/*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved  	*/

#include <stdio.h>
#include <ctype.h>
#include <signal.h>
#include <locale.h>
#include <libintl.h>
#include <stdarg.h>
#include <errno.h>
#include <values.h>
#include <langinfo.h>
#include "awk.h"
#include "y.tab.h"

char	*version = "version Aug 27, 2018";

int	dbg	= 0;
Awkfloat	srand_seed = 1;
char	*cmdname;	/* gets argv[0] for error messages */
char	*lexprog;	/* points to program argument if it exists */
int	compile_time = 2;	/* for error printing: */
				/* 2 = cmdline, 1 = compile, 0 = running */

static char	**pfile = NULL;	/* program filenames from -f's */
static int	npfile = 0;	/* number of filenames */
static int	curpfile = 0;	/* current filename */

int	safe	= 0;	/* 1 => "safe" mode */

int
main(int argc, char *argv[], char *envp[])
{
	const char *fs = NULL;
	/*
	 * At this point, numbers are still scanned as in
	 * the POSIX locale.
	 * (POSIX.2, volume 2, P867, L4742-4757)
	 */
	(void) setlocale(LC_ALL, "");
	(void) setlocale(LC_NUMERIC, "C");
#if !defined(TEXT_DOMAIN)	/* Should be defined by cc -D */
#define	TEXT_DOMAIN	"SYS_TEST"	/* Use this only if it weren't */
#endif
	(void) textdomain(TEXT_DOMAIN);
	cmdname = argv[0];
	if (argc == 1) {
		(void) fprintf(stderr, gettext(
		    "Usage: %s [-f programfile | 'program'] [-Ffieldsep] "
		    "[-v var=value] [files]\n"), cmdname);
		exit(1);
	}
	(void) signal(SIGFPE, fpecatch);

	srand_seed = 1;
	srand((unsigned int)srand_seed);

	yyin = NULL;
	symtab = makesymtab(NSYMTAB/NSYMTAB);
	while (argc > 1 && argv[1][0] == '-' && argv[1][1] != '\0') {
		if (strcmp(argv[1], "-version") == 0 ||
		    strcmp(argv[1], "--version") == 0) {
			(void) printf("awk %s\n", version);
			exit(0);
			break;
		}
		if (strcmp(argv[1], "--") == 0) {
			/* explicit end of args */
			argc--;
			argv++;
			break;
		}
		switch (argv[1][1]) {
		case 's':
			if (strcmp(argv[1], "-safe") == 0)
				safe = 1;
			break;
		case 'f':	/* next argument is program filename */
			if (argv[1][2] != 0) {  /* arg is -fsomething */
				pfile = realloc(pfile,
				    sizeof (char *) * (npfile + 1));
				if (pfile == NULL)
					FATAL("out of space in main");
				pfile[npfile++] = &argv[1][2];
			} else {		/* arg is -f something */
				argc--; argv++;
				if (argc <= 1)
					FATAL("no program filename");
				pfile = realloc(pfile,
				    sizeof (char *) * (npfile + 1));
				if (pfile == NULL)
					FATAL("out of space in main");
				pfile[npfile++] = argv[1];
			}
			break;
		case 'F':	/* set field separator */
			if (argv[1][2] != 0) {	/* arg is -Fsomething */
				/* wart: t=>\t */
				if (argv[1][2] == 't' && argv[1][3] == 0)
					fs = "\t";
				else if (argv[1][2] != 0)
					fs = &argv[1][2];
			} else {		/* arg is -F something */
				argc--; argv++;
				if (argc > 1) {
					/* wart: t=>\t */
					if (argv[1][0] == 't' &&
					    argv[1][1] == 0)
						fs = "\t";
					else if (argv[1][0] != 0)
						fs = &argv[1][0];
				}
			}
			if (fs == NULL || *fs == '\0')
				WARNING("field separator FS is empty");
			break;
		case 'v':	/* -v a=1 to be done NOW.  one -v for each */
			if (argv[1][2] != 0) {  /* arg is -vsomething */
				if (isclvar(&argv[1][2]))
					setclvar(&argv[1][2]);
				else
					FATAL("invalid -v option argument: %s",
					    &argv[1][2]);
			} else {		/* arg is -v something */
				argc--; argv++;
				if (argc <= 1)
					FATAL("no variable name");
				if (isclvar(argv[1]))
					setclvar(argv[1]);
				else
					FATAL("invalid -v option argument: %s",
					    argv[1]);
			}
			break;
		case 'd':
			dbg = atoi(&argv[1][2]);
			if (dbg == 0)
				dbg = 1;
			(void) printf("awk %s\n", version);
			break;
		default:
			WARNING("unknown option %s ignored", argv[1]);
			break;
		}
		argc--;
		argv++;
	}
	/* argv[1] is now the first argument */
	if (npfile == 0) {	/* no -f; first argument is program */
		if (argc <= 1) {
			if (dbg)
				exit(0);
			FATAL("no program given");
		}
		dprintf(("program = |%s|\n", argv[1]));
		lexprog = argv[1];
		argc--;
		argv++;
	}
	recinit(recsize);
	syminit();
	compile_time = 1;
	argv[0] = cmdname;	/* put prog name at front of arglist */
	dprintf(("argc=%d, argv[0]=%s\n", argc, argv[0]));
	arginit(argc, argv);
	if (!safe)
		envinit(envp);
	(void) yyparse();
	if (fs)
		*FS = qstring(fs, '\0');
	dprintf(("errorflag=%d\n", errorflag));
	/*
	 * done parsing, so now activate the LC_NUMERIC
	 */
	(void) setlocale(LC_ALL, "");

	if (errorflag == 0) {
		compile_time = 0;
		run(winner);
	} else
		bracecheck();
	return (errorflag);
}

int
pgetc(void)		/* get 1 character from awk program */
{
	int c;

	for (;;) {
		if (yyin == NULL) {
			if (curpfile >= npfile)
				return (EOF);
			yyin = (strcmp(pfile[curpfile], "-") == 0) ?
			    stdin : fopen(pfile[curpfile], "rF");
			if (yyin == NULL) {
				FATAL("can't open file %s", pfile[curpfile]);
			}
			lineno = 1;
		}
		if ((c = getc(yyin)) != EOF)
			return (c);
		if (yyin != stdin)
			(void) fclose(yyin);
		yyin = NULL;
		curpfile++;
	}
}

char *
cursource(void)	/* current source file name */
{
	if (curpfile < npfile)
		return (pfile[curpfile]);
	else
		return (NULL);
}



/* ============================================================================
 * SOURCE 36/98: minix4\exokernel\kernel_legacy\cmd\bart\main.c
 * Size: 1,976 bytes, Lines: 77
 * Hash: b99bee212d1d...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2003 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */
#include <signal.h>
#include <unistd.h>
#include <locale.h>
#include <sys/acl.h>
#include "bart.h"

int
main(int argc, char **argv)
{
	/* Make sure we are in the correct locale */
	(void) setlocale(LC_ALL, "");
	(void) textdomain(TEXT_DOMAIN);

	/* Superficial check of the arguments.  Note usage() exits the pgm */
	if (argc < 2)
		usage();

	/*
	 * OK, hand it off to bart_create() or bart_compare().
	 *
	 * Since the command line was 'bart create ..',  or 'bart compare ..',
	 * those subcommands should start parsing options at &argv[1], and
	 *  (argc-1) to be consistent.
	 */
	if (strcmp(argv[1], "create") == 0)
		return (bart_create((argc-1), (argv+1)));
	else if (strcmp(argv[1], "compare") == 0) {
		return (bart_compare((argc-1), (argv+1)));

	} else usage();

	return (FATAL_EXIT);
}
void
usage()
{
	(void) fprintf(stderr, USAGE_MSG);
	exit(FATAL_EXIT);
}
void *
safe_calloc(size_t size)
{
	char	*ptr;

	ptr = calloc((size_t)1, size);
	if (ptr == NULL)
		exit(FATAL_EXIT);
	else return (ptr);

	/* NOTREACHED */
}



/* ============================================================================
 * SOURCE 37/98: minix4\exokernel\kernel_legacy\cmd\cdrw\main.c
 * Size: 10,599 bytes, Lines: 486
 * Hash: 4c99b05b199f...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <limits.h>
#include <unistd.h>
#include <libintl.h>
#include <locale.h>
#include <dbus/dbus.h>
#include <hal/libhal.h>

#include "msgs.h"
#include "device.h"
#include "util.h"
#include "main.h"
#include "options.h"
#include "mmc.h"
#include "misc_scsi.h"

/*
 * global flags
 */
int	debug = 0;
int	keep_disc_open = 0;
int	requested_speed = 0;
int	simulation = 0;
int	verbose = 0;
char	*image_file = NULL;
char	*blanking_type = NULL;
int	audio_type = AUDIO_TYPE_NONE;
int	extract_track_no = 0;
char	*extract_file = NULL;
char	*alt_tmp_dir = NULL;
char	*copy_src = NULL;
int	vol_running = 0;
int	cflag = 0;
int	tflag = 0;
uid_t	ruid, cur_uid;

/*
 * global variables
 */
cd_device *target = NULL;		/* Default target device */
static char *tgtdev = NULL;
int device_type = CD_RW;		/* Default to CD/RW */
int write_mode = TAO_MODE;		/* Default to track at once */

static void
print_usage(void)
{
	err_msg(gettext("USAGE:\n"));
	err_msg(gettext("\tcdrw -i [ -vSCO ] [ -d device ] [ -p speed ]"));
	err_msg(gettext(" [ image-file ]\n"));
	err_msg(gettext("\tcdrw -a [ -vSCO ] [ -d device ] [ -p speed ]"));
	err_msg(gettext(" [ -T audio-type ] audio-file1 audio-file2 ...\n"));
	err_msg(gettext("\tcdrw -x [ -v ] [ -d device ] [ -T audio-type ]"));
	err_msg(gettext(" track-number audio-file\n"));
	err_msg(gettext("\tcdrw -c [ -SC ] [ -d device ] [ -p speed ]"));
	err_msg(gettext(" [ -m tmp-dir ] [ -s src-device ]\n"));
	err_msg(
	    gettext("\tcdrw -b [ -v ] [ -d device ] all | session | fast\n"));
	err_msg(gettext("\tcdrw -M [ -v ] [ -d device ]\n"));
	err_msg(gettext("\tcdrw -L [ -v ] [ -d device ]\n"));
	err_msg(gettext("\tcdrw -l [ -v ]\n"));
	err_msg(gettext("\tcdrw -h\n"));

	exit(2);
}

static void
check_invalid_option(options *specified, char *opstr)
{
	options c_op;
	int ret;

	set_options_mask(&c_op, opstr);
	if ((ret = compare_options_mask(&c_op, specified)) != 0) {
		err_msg(
		    gettext("Option %c is not defined for this operation.\n"),
		    (char)ret);
		print_usage();
	}
}

LibHalContext *
attach_to_hald(void)
{
	LibHalContext *ctx = NULL;
	DBusConnection *con = NULL;
	DBusError error;
	hal_state_t state;

	/* Initialize the dbus error states */
	dbus_error_init(&error);

	if ((con = dbus_bus_get(DBUS_BUS_SYSTEM, &error)) == NULL) {
		return (NULL);
	}
	state = DBUS_CONNECTION;

	/* Allocate a new hal context to work with the dbus */
	if ((ctx = libhal_ctx_new()) == NULL)
		return (NULL);
	state = HAL_CONTEXT;

	/* Pair up the context with the connection */
	if (!libhal_ctx_set_dbus_connection(ctx, con))
		goto fail;
	state = HAL_PAIRED;

	/* If libhal_ctx_init fails hald is not present */
	if (!libhal_ctx_init(ctx, &error)) {
		goto fail;
	}
	state = HAL_INITIALIZED;

	return (ctx);
fail:
	if (dbus_error_is_set(&error))
		dbus_error_free(&error);
	detach_from_hald(ctx, state);
	return (NULL);

}

void
detach_from_hald(LibHalContext *ctx, hal_state_t state)
{
	DBusError error;
	DBusConnection *con = libhal_ctx_get_dbus_connection(ctx);

	dbus_error_init(&error);

	switch (state) {
	case HAL_INITIALIZED:
		if (libhal_ctx_shutdown(ctx, &error) == FALSE)
			if (dbus_error_is_set(&error))
				dbus_error_free(&error);
	/*FALLTHROUGH*/
	case HAL_PAIRED:
		(void) libhal_ctx_free(ctx);
		dbus_connection_unref(con);
		break;
	case HAL_CONTEXT:
		(void) libhal_ctx_free(ctx);
		break;
	case DBUS_CONNECTION:
	default:
		break;
	}
}

/*
 * This function returns one if hald is running and
 * zero if hald is not running
 */
int
hald_running(void)
{
	LibHalContext *ctx;

	if ((ctx = attach_to_hald()) == NULL)
		return (0);

	detach_from_hald(ctx, HAL_INITIALIZED);
	return (1);
}

int
setup_target(int flag)
{
	char *devpath;

	if (tgtdev != NULL) {
		devpath = (char *)my_zalloc(PATH_MAX);
		if (lookup_device(tgtdev, devpath)) {
			target = get_device(tgtdev, devpath);
		}
		free(devpath);
		if (target == NULL) {
			return (0);
		}
		return (1);
	}
	return (scan_for_cd_device(flag, &target));
}

int
main(int argc, char **argv)
{
	int		c;
	int		operations;
	options		specified_ops;
	int		aflag, iflag, Mflag, Lflag, lflag, bflag, xflag;
	int		ret;

	(void) setlocale(LC_ALL, "");

#if !defined(TEXT_DOMAIN)
#define	TEXT_DOMAIN	"SYS_TEST"
#endif


	(void) textdomain(TEXT_DOMAIN);

	ruid = getuid();
	cur_uid = geteuid();

	if (check_auth(ruid) != 1)  {
		err_msg(gettext(
		    "Authorization failed, Cannot access disks.\n"));
		exit(1);
	}

	if ((cur_uid == 0) && (ruid != 0)) {
		priv_change_needed = 1;
		lower_priv();
	}

	vol_running = hald_running();

	tgtdev = NULL;
	operations = 0;
	set_options_mask(&specified_ops, "");
	iflag = Mflag = Lflag = lflag = bflag = aflag = xflag = cflag = 0;

	while ((c = getopt(argc, argv, "abcCd:hiLlm:MOp:s:ST:vVx")) != EOF) {
		add_option(&specified_ops, c);
		switch (c) {
		case 'a':
			aflag = 1;
			operations++;
			break;
		case 'b':
			bflag = 1;
			operations++;
			break;
		case 'c':
			cflag = 1;
			operations++;
			break;
		case 'C':
			/*
			 * cdrw now attempts to use the stated medium capacity
			 * by default, so this option no longer has any effect.
			 * It remains in the interface for backwards
			 * compatibility only.
			 */
			break;
		case 'd':
			tgtdev = optarg;
			break;
		case 'h':
			print_usage(); /* will not return */
			break;
		case 'i':
			iflag = 1;
			operations++;
			break;
		case 'L':
			Lflag = 1;
			operations++;
			break;
		case 'l':
			lflag = 1;
			operations++;
			break;
		case 'm':
			alt_tmp_dir = optarg;
			break;
		case 'M':
			Mflag = 1;
			operations++;
			break;
		case 'O':
			keep_disc_open = 1;
			break;
		case 'p':
			requested_speed = atoi(optarg);
			break;
		case 's':
			copy_src = optarg;
			break;
		case 'S':
			simulation++;
			break;
		case 'T':
			audio_type = get_audio_type(optarg);
			if (audio_type == -1) {
				err_msg(gettext("Unknown audio type %s\n"),
				    optarg);
				exit(1);
			}
			break;
		case 'v':
			verbose++;
			break;
		case 'V':
			/*
			 * more verbose. this will print out debug comments
			 */

			debug++;
			break;
		case 'x':
			xflag++;
			operations++;
			break;
		default:
			print_usage();
		}
	}
	if (operations == 0) {
		err_msg(gettext("No operation specified.\n"));
		exit(1);
	}
	if (operations != 1) {
		err_msg(gettext("More than one operation specified.\n"));
		exit(1);
	}

	if (lflag) {
		check_invalid_option(&specified_ops, "lhvV");
		list();
	}

	/*
	 * we'll allow the user to specify the source device (-s) when
	 *  extracting audio.
	 */

	if (xflag && copy_src)
		tgtdev = copy_src;

	/*
	 * This will scan for all CD devices when xflag or Mflag
	 * (extract audio, list toc) commands are used, providing
	 * no CD-RW devices are found. Since these commands can
	 * be used without a CD writer.
	 */

	if (xflag || Mflag) {
		ret = setup_target(SCAN_ALL_CDS);
	} else {
		ret = setup_target(SCAN_WRITERS);
	}

	if (ret == 0) {

		if (tgtdev != NULL) {
			err_msg(gettext(
			    "Cannot find device %s.\n"), tgtdev);

		}

		if (vol_running) {
			err_msg(gettext(
			    "No CD writers found or no media in the drive.\n"));
		} else {
			if (cur_uid != 0) {
				err_msg(gettext(
				    "Volume manager is not running.\n"));
				err_msg(gettext(
"Please start volume manager or run cdrw as root to access all devices.\n"));
			} else {
				err_msg(gettext(
				    "No CD writers found.\n"));
			}
		}
		exit(1);

	} else if (ret != 1) {
		err_msg(gettext("More than one CD device found.\n"));
		err_msg(gettext("Specify one using -d option.\n"));
		err_msg(gettext(
		    "Or use -l option to list all the CD devices found\n"));
		exit(1);
	}
	(void) check_device(target, CHECK_TYPE_NOT_CDROM|EXIT_IF_CHECK_FAILED);

	if (check_device(target, CHECK_NO_MEDIA) == 0) {
		int retry;
		for (retry = 0; retry < 5; retry++) {
			if (check_device(target, CHECK_DEVICE_NOT_READY) == 0)
				break;
			(void) sleep(3);
		}
	}

	if (aflag) {
		check_invalid_option(&specified_ops, "ahvSCOdpTV");
		if (optind == argc) {
			err_msg(gettext("No audio files specified.\n"));
			exit(1);
		}
		write_audio(argv, optind, argc);
	}
	if (Mflag) {
		check_invalid_option(&specified_ops, "MhvdV");
		info();
	}
	if (iflag) {
		check_invalid_option(&specified_ops, "ihvSCOdpV");
		if (optind == (argc - 1)) {
			image_file = argv[optind];
			write_image();
		}
		if (optind == argc)
			write_image();
		err_msg(gettext("Command line parsing error.\n"));
		err_msg(gettext("Only one image-file can be specified.\n"));
		exit(1);
	}
	if (bflag) {
		check_invalid_option(&specified_ops, "bhvdV");
		if (optind != (argc - 1)) {
			err_msg(gettext("Command line parsing error.\n"));
			print_usage();
		}
		blanking_type = argv[argc - 1];
		blank();
	}
	if (xflag) {
		check_invalid_option(&specified_ops, "xhpvdsTV");
		if (optind != (argc - 2)) {
			err_msg(gettext("Command line parsing error.\n"));
			print_usage();
		}
		extract_track_no = atoi(argv[argc - 2]);
		extract_file = argv[argc - 1];
		extract_audio();
	}
	if (cflag) {
		check_invalid_option(&specified_ops, "chvSCdpmsV");
		copy_cd();
	}

	/*
	 * Open a closed disk, we do this by erasing the track tail
	 * and then re-finalizing with an open leadout.
	 */
	if (Lflag) {
		check_invalid_option(&specified_ops, "LvdV");
		(void) check_device(target, CHECK_NO_MEDIA |
		    CHECK_DEVICE_NOT_READY | EXIT_IF_CHECK_FAILED);

		/* no need to erase blank media */
		if (!check_device(target, CHECK_MEDIA_IS_NOT_BLANK))
			exit(0);

		blanking_type = "leadout";
		blank();

		write_init(TRACK_MODE_DATA);
		(void) close_track(target->d_fd, 0, 1, 1);
		(void) finalize(target);
		(void) printf(gettext("done.\n"));
		exit(0);
	}
	return (0);
}



/* ============================================================================
 * SOURCE 38/98: minix4\exokernel\kernel_legacy\cmd\dumpadm\main.c
 * Size: 6,444 bytes, Lines: 252
 * Hash: f9a8db29e29f...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 1998, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright 2015 Nexenta Systems, Inc. All rights reserved.
 * Copyright 2024 MNX Cloud, Inc.
 */

#include <sys/stat.h>
#include <locale.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "dconf.h"
#include "minfree.h"
#include "utils.h"

static const char USAGE[] = "\
Usage: %s [-Henpuy] [-c kernel | curproc | all ]\n\
	[-d dump-device | swap | none ] [-m min {k|m|%%} ] [-s savecore-dir]\n\
	[-r root-dir] [-z on|off]\n";

static const char OPTS[] = "Heinpuyc:d:m:s:r:z:";

static const char PATH_DEVICE[] = "/dev/dump";
static const char PATH_CONFIG[] = "/etc/dumpadm.conf";

int
main(int argc, char *argv[])
{
	const char *pname = getpname(argv[0]);

	u_longlong_t minf;
	struct stat st;
	int c;
	int dflag = 0;			/* for checking in use during -d ops */
	int eflag = 0;			/* print estimated dump size */
	int dcmode = DC_CURRENT;	/* kernel settings override unless -u */
	int modified = 0;		/* have we modified the dump config? */
	char *minfstr = NULL;		/* string value of -m argument */
	dumpconf_t dc;			/* current configuration */
	int chrooted = 0;
	int douuid = 0;

	(void) setlocale(LC_ALL, "");
	(void) textdomain(TEXT_DOMAIN);

	/*
	 * Take an initial lap through argv hunting for -r root-dir,
	 * so that we can chroot before opening the configuration file.
	 * We also handle -u and any bad options at this point.
	 */
	while (optind < argc) {
		while ((c = getopt(argc, argv, OPTS)) != (int)EOF) {
			if (c == 'r' && ++chrooted && chroot(optarg) == -1)
				die(gettext("failed to chroot to %s"), optarg);
			else if (c == 'u')
				dcmode = DC_OVERRIDE;
			else if (c == '?') {
				(void) fprintf(stderr, gettext(USAGE), pname);
				return (E_USAGE);
			}
		}

		if (optind < argc) {
			warn(gettext("illegal argument -- %s\n"), argv[optind]);
			(void) fprintf(stderr, gettext(USAGE), pname);
			return (E_USAGE);
		}
	}

	if (geteuid() != 0)
		die(gettext("you must be root to use %s\n"), pname);

	/*
	 * If no config file exists yet, we're going to create an empty one,
	 * so set the modified flag to force writing out the file.
	 */
	if (access(PATH_CONFIG, F_OK) == -1)
		modified++;

	/*
	 * Now open and read in the initial values from the config file.
	 * If it doesn't exist, we create an empty file and dc is
	 * initialized with the default values.
	 */
	if (dconf_open(&dc, PATH_DEVICE, PATH_CONFIG, dcmode) == -1)
		return (E_ERROR);

	/*
	 * Take another lap through argv, processing options and
	 * modifying the dumpconf_t as appropriate.
	 */
	for (optind = 1; optind < argc; optind++) {
		while ((c = getopt(argc, argv, OPTS)) != (int)EOF) {
			switch (c) {
			case 'H':
				dc.dc_headers = false;
				break;

			case 'c':
				if (dconf_str2content(&dc, optarg) == -1)
					return (E_USAGE);
				modified++;
				break;
			case 'd':
				if (dconf_str2device(&dc, optarg) == -1)
					return (E_USAGE);
				dflag++;
				modified++;
				break;
			case 'e':
				eflag++;
				break;
			case 'i':
				/* undocumented option */
				if (chrooted) {
					warn(gettext("-i and -r cannot be "
					    "used together\n"));
					return (E_USAGE);
				}
				douuid++;
				break;

			case 'm':
				minfstr = optarg;
				break;

			case 'n':
				dc.dc_enable = DC_OFF;
				modified++;
				break;

			case 'p':
				dc.dc_parsable = true;
				break;

			case 's':
				if (stat(optarg, &st) == -1 ||
				    !S_ISDIR(st.st_mode)) {
					warn(gettext("%s is missing or not a "
					    "directory\n"), optarg);
					return (E_USAGE);
				}

				if (dconf_str2savdir(&dc, optarg) == -1)
					return (E_USAGE);
				modified++;
				break;

			case 'y':
				dc.dc_enable = DC_ON;
				modified++;
				break;

			case 'z':
				if (dconf_str2csave(&dc, optarg) == -1)
					return (E_USAGE);
				modified++;
				break;
			}
		}
	}

	if (eflag) {
		if (modified < 2 && douuid == 0 && chrooted == 0 &&
		    dcmode == DC_CURRENT && minfstr == NULL)
			return (dconf_get_dumpsize(&dc) ? E_SUCCESS : E_ERROR);
		else
			die(gettext("-e cannot be used with other options\n"));
	}

	if (dc.dc_parsable) {
		die(gettext("-p can only be used with -e\n"));
	}

	if (!dc.dc_headers) {
		die(gettext("-H can only be used with -e\n"));
	}

	if (douuid)
		return (dconf_write_uuid(&dc) ? E_SUCCESS : E_ERROR);

	if (minfstr != NULL) {
		if (minfree_compute(dc.dc_savdir, minfstr, &minf) == -1)
			return (E_USAGE);
		if (minfree_write(dc.dc_savdir, minf) == -1)
			return (E_ERROR);
	}

	if (dcmode == DC_OVERRIDE) {
		/*
		 * In override mode, we try to force an update.  If this
		 * fails, we re-load the kernel configuration and write that
		 * out to the file in order to force the file in sync.
		 *
		 * We allow the file to be read-only but print a warning to the
		 * user that indicates it hasn't been updated.
		 */
		if (dconf_update(&dc, 0) == -1)
			(void) dconf_getdev(&dc);
		if (dc.dc_readonly)
			warn(gettext("kernel settings updated, but "
			    "%s is read-only\n"), PATH_CONFIG);
		else if (dconf_write(&dc) == -1)
			return (E_ERROR);

	} else if (modified) {
		/*
		 * If we're modifying the configuration, then try
		 * to update it, and write out the file if successful.
		 */
		if (dc.dc_readonly) {
			warn(gettext("failed to update settings: %s is "
			    "read-only\n"), PATH_CONFIG);
			return (E_ERROR);
		}

		if (dconf_update(&dc, dflag) == -1 ||
		    dconf_write(&dc) == -1)
			return (E_ERROR);
	}

	if (dcmode == DC_CURRENT)
		dconf_print(&dc, stdout);

	if (dconf_close(&dc) == -1)
		warn(gettext("failed to close configuration file"));

	return (E_SUCCESS);
}



/* ============================================================================
 * SOURCE 39/98: minix4\exokernel\kernel_legacy\cmd\filesync\main.c
 * Size: 16,923 bytes, Lines: 686
 * Hash: 0eed7734412d...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

/*
 * module:
 *	main.c
 *
 * purpose:
 *	argument handling and top level dispatch
 *
 * contents:
 *	main		argument handling and main loop
 *	usage		(static) print out usage message
 *	confirm		prompt the user for a confirmation and get it
 *	nomem		fatal error handler for malloc failures
 *	findfiles	(static) locate our baseline and rules files
 *	cleanup		(static) unlock baseline and delete temp file
 *	check_access	(static) do we have adequate access to a file/directory
 *	whoami		(static) get uid/gid/umask
 */

#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <errno.h>
#include <sys/stat.h>

#include "filesync.h"
#include "database.h"
#include "messages.h"
#include "debug.h"

/*
 * local routines in this module:
 */
static errmask_t findfiles();		/* find rule and baseline files	*/
static void cleanup(int);		/* cleanup locks and temps	*/
static errmask_t check_access(char *, int *); /* check access to file	*/
static void whoami();			/* gather information about me	*/
static void usage(void);		/* general usage		*/


/*
 * globals exported to the rest of the program
 */
bool_t	opt_mtime;	/* preserve modification times on propagations	*/
bool_t	opt_notouch;	/* don't actually make any changes		*/
bool_t	opt_quiet;	/* disable reconciliation command output	*/
bool_t	opt_verbose;	/* enable analysis descriptions			*/
side_t	opt_force;	/* designated winner for conflicts		*/
side_t	opt_oneway;	/* one way only propagation			*/
side_t	opt_onesided;	/* permit one-sided evaluation			*/
bool_t	opt_everything;	/* everything must agree (modes/uid/gid)	*/
bool_t	opt_yes;	/* pre-confirm massive deletions are OK		*/
bool_t	opt_acls;	/* always scan for acls on all files		*/
bool_t	opt_errors;	/* simulate errors on specified files		*/
bool_t	opt_halt;	/* halt on propagation errors			*/
dbgmask_t opt_debug;	/* debug mask					*/

uid_t	my_uid;		/* default UID for files I create		*/
gid_t	my_gid;		/* default GID for files I create		*/

static char *file_rules; /* name of rules file				*/
static char *file_base;	/* name of baseline file			*/

static int new_baseline; /* are we creating a new baseline		*/
static int new_rules;	/* are we creating a new rules file		*/
static int my_umask;	/* default UMASK for files I create		*/
static int lockfd;	/* file descriptor for locking baseline		*/

static char *rlist[MAX_RLIST];
static int num_restrs = 0;

/*
 * routine:
 *	main
 *
 * purpose:
 *	argument processing and primary dispatch
 *
 * returns:
 *	error codes per filesync.1 (ERR_* in filesync.h)
 *
 * notes:
 *	read filesync.1 in order to understand the argument processing
 *
 *	most of the command line options just set some opt_ global
 *	variable that is later looked at by the code that actually
 *	implements the features.  Only file names are really processed
 *	in this routine.
 */
int
main(int argc, char **argv)
{	int i;
	int c;
	errmask_t errs = ERR_OK;
	int do_prune = 0;
	char *srcname = 0;
	char *dstname = 0;
	struct base *bp;

	/* keep the error messages simple	*/
	argv[0] = "filesync";

	/* gather together all of the options	*/
	while ((c = getopt(argc, argv, "AaehmnqvyD:E:r:s:d:f:o:")) != EOF)
		switch (c) {
			case 'a':	/* always scan for acls	*/
				opt_acls = TRUE;
				break;
			case 'e':	/* everything agrees	*/
				opt_everything = TRUE;
				break;
			case 'h':	/* halt on error	*/
				opt_halt = TRUE;
				break;
			case 'm':	/* preserve modtimes	*/
				opt_mtime = TRUE;
				break;
			case 'n':	/* notouch		*/
				opt_notouch = TRUE;
				break;
			case 'q':	/* quiet		*/
				opt_quiet = TRUE;
				break;
			case 'v':	/* verbose		*/
				opt_verbose = TRUE;
				break;
			case 'y':	/* yes			*/
				opt_yes = TRUE;
				break;
			case 'D':	/* debug options	*/
				if (!isdigit(optarg[0])) {
					dbg_usage();
					exit(ERR_INVAL);
				}
				opt_debug |= strtol(optarg, (char **)NULL, 0);
				break;

			case 'E':	/* error simulation	*/
				if (dbg_set_error(optarg)) {
					err_usage();
					exit(ERR_INVAL);
				}
				opt_errors = TRUE;
				break;

			case 'f':	/* force conflict resolution	*/
				switch (optarg[0]) {
					case 's':
						opt_force = OPT_SRC;
						break;
					case 'd':
						opt_force = OPT_DST;
						break;
					case 'o':
						opt_force = OPT_OLD;
						break;
					case 'n':
						opt_force = OPT_NEW;
						break;
					default:
						fprintf(stderr,
							gettext(ERR_badopt),
							c, optarg);
						errs |= ERR_INVAL;
						break;
				}
				break;

			case 'o':	/* one way propagation		*/
				switch (optarg[0]) {
					case 's':
						opt_oneway = OPT_SRC;
						break;
					case 'd':
						opt_oneway = OPT_DST;
						break;
					default:
						fprintf(stderr,
							gettext(ERR_badopt),
							c, optarg);
						errs |= ERR_INVAL;
						break;
				}
				break;

			case 'r':	/* restricted reconciliation	*/
				if (num_restrs < MAX_RLIST)
					rlist[ num_restrs++ ] = optarg;
				else {
					fprintf(stderr, gettext(ERR_tomany),
						MAX_RLIST);
					errs |= ERR_INVAL;
				}
				break;

			case 's':
				if ((srcname = qualify(optarg)) == 0)
					errs |= ERR_MISSING;
				break;

			case 'd':
				if ((dstname = qualify(optarg)) == 0)
					errs |= ERR_MISSING;
				break;

			default:
			case '?':
				errs |= ERR_INVAL;
				break;
		}

	if (opt_debug & DBG_MISC)
		fprintf(stderr, "MISC: DBG=%s\n", showflags(dbgmap, opt_debug));

	/* if we have file names, we need a source and destination */
	if (optind < argc) {
		if (srcname == 0) {
			fprintf(stderr, gettext(ERR_nosrc));
			errs |= ERR_INVAL;
		}
		if (dstname == 0) {
			fprintf(stderr, gettext(ERR_nodst));
			errs |= ERR_INVAL;
		}
	}

	/* check for simple usage errors	*/
	if (errs & ERR_INVAL) {
		usage();
		exit(errs);
	}

	/* locate our baseline and rules files	*/
	if (c = findfiles())
		exit(c);

	/* figure out file creation defaults	*/
	whoami();

	/* read in our initial baseline		*/
	if (!new_baseline && (c = read_baseline(file_base)))
		errs |= c;

	/* read in the rules file if we need or have rules	*/
	if (optind >= argc && new_rules) {
		fprintf(stderr, ERR_nonames);
		errs |= ERR_INVAL;
	} else if (!new_rules)
		errs |= read_rules(file_rules);

	/* if anything has failed with our setup, go no further	*/
	if (errs) {
		cleanup(errs);
		exit(errs);
	}

	/*
	 * figure out whether or not we are willing to do a one-sided
	 * analysis (where we don't even look at the other side.  This
	 * is an "I'm just curious what has changed" query, and we are
	 * only willing to do it if:
	 *	we aren't actually going to do anything
	 *	we have a baseline we can compare against
	 * otherwise, we are going to insist on being able to access
	 * both the source and destination.
	 */
	if (opt_notouch && !new_baseline)
		opt_onesided = opt_oneway;

	/*
	 * there are two interested usage scenarios:
	 *	file names specified
	 *		create new rules for the specified files
	 *		evaulate and reconcile only the specified files
	 *	no file names specified
	 *		use already existing rules
	 *		consider restricting them to specified subdirs/files
	 */
	if (optind < argc) {
		/* figure out what base pair we're working on	*/
		bp = add_base(srcname, dstname);

		/* perverse default rules to avoid trouble	*/
		if (new_rules) {
			errs |= add_ignore(0, SUFX_RULES);
			errs |= add_ignore(0, SUFX_BASE);
		}

		/* create include rules for each file/dir arg	*/
		while (optind < argc)
			errs |= add_include(bp, argv[ optind++ ]);

		/*
		 * evaluate the specified base on each side,
		 * being careful to limit evaulation to new rules
		 */
		errs |= evaluate(bp, OPT_SRC, TRUE);
		errs |= evaluate(bp, OPT_DST, TRUE);
	} else {
		/* note any possible evaluation restrictions	*/
		for (i = 0; i < num_restrs; i++)
			errs |= add_restr(rlist[i]);

		/*
		 * we can only prune the baseline file if we have done
		 * a complete (unrestricted) analysis.
		 */
		if (i == 0)
			do_prune = 1;

		/* evaulate each base on each side		*/
		for (bp = bases; bp; bp = bp->b_next) {
			errs |= evaluate(bp, OPT_SRC, FALSE);
			errs |= evaluate(bp, OPT_DST, FALSE);
		}
	}

	/* if anything serious happened, skip reconciliation	*/
	if (errs & ERR_FATAL) {
		cleanup(errs);
		exit(errs);
	}

	/* analyze and deal with the differenecs		*/
	errs |= analyze();

	/* see if there is any dead-wood in the baseline	*/
	if (do_prune) {
		c = prune();

		if (c > 0 && opt_verbose)
			fprintf(stdout, V_prunes, c);
	}

	/* print out a final summary				*/
	summary();

	/* update the rules and baseline files (if needed)	*/
	(void) umask(my_umask);
	errs |= write_baseline(file_base);
	errs |= write_rules(file_rules);

	if (opt_debug & DBG_MISC)
		fprintf(stderr, "MISC: EXIT=%s\n", showflags(errmap, errs));

	/* just returning ERR_RESOLVABLE upsets some people	*/
	if (errs == ERR_RESOLVABLE && !opt_notouch)
		errs = 0;

	/* all done	*/
	cleanup(0);
	return (errs);
}


/*
 * routine:
 *	usage
 *
 * purpose:
 *	print out a usage message
 *
 * parameters:
 *	none
 *
 * returns:
 *	none
 *
 * note:
 *	the -D and -E switches are for development/test/support
 *	use only and do not show up in the general usage message.
 */
static void
usage(void)
{
	fprintf(stderr, "%s\t%s %s\n", gettext(ERR_usage), "filesync",
					gettext(USE_simple));
	fprintf(stderr, "\t%s %s\n", "filesync", gettext(USE_all));
	fprintf(stderr, "\t-a .......... %s\n", gettext(USE_a));
	fprintf(stderr, "\t-e .......... %s\n", gettext(USE_e));
	fprintf(stderr, "\t-h .......... %s\n", gettext(USE_h));
	fprintf(stderr, "\t-m .......... %s\n", gettext(USE_m));
	fprintf(stderr, "\t-n .......... %s\n", gettext(USE_n));
	fprintf(stderr, "\t-q .......... %s\n", gettext(USE_q));
	fprintf(stderr, "\t-v .......... %s\n", gettext(USE_v));
	fprintf(stderr, "\t-y .......... %s\n", gettext(USE_y));
	fprintf(stderr, "\t-s dir ...... %s\n", gettext(USE_s));
	fprintf(stderr, "\t-d dir ...... %s\n", gettext(USE_d));
	fprintf(stderr, "\t-r dir ...... %s\n", gettext(USE_r));
	fprintf(stderr, "\t-f [sdon].... %s\n", gettext(USE_f));
	fprintf(stderr, "\t-o src/dst... %s\n", gettext(USE_o));
}

/*
 * routine:
 *	confirm
 *
 * purpose:
 *	to confirm that the user is willing to do something dangerous
 *
 * parameters:
 *	warning message to be printed
 *
 * returns:
 * 	void
 *
 * notes:
 *	if this is a "notouch" or if the user has pre-confirmed,
 *	we should not obtain the confirmation and just return that
 *	the user has confirmed.
 */
void
confirm(char *message)
{	FILE *ttyi, *ttyo;
	char ansbuf[ MAX_LINE ];

	/* if user pre-confirmed, we don't have to ask	*/
	if (opt_yes || opt_notouch)
		return;

	ttyo = fopen("/dev/tty", "w");
	ttyi = fopen("/dev/tty", "r");
	if (ttyi == NULL || ttyo == NULL)
		exit(ERR_OTHER);

	/* explain the problem and prompt for confirmation	*/
	fprintf(ttyo, message);
	fprintf(ttyo, gettext(WARN_proceed));

	/* if the user doesn't kill us, we can continue		*/
	(void) fgets(ansbuf, sizeof (ansbuf), ttyi);

	/* close the files and return				*/
	(void) fclose(ttyi);
	(void) fclose(ttyo);
}

void
nomem(char *reason)
{
	fprintf(stderr, gettext(ERR_nomem), reason);
	exit(ERR_OTHER);
}

/*
 * routine:
 *	findfiles
 *
 * purpose:
 *	to locate our baseline and rules files
 *
 * parameters:
 *	none
 *
 * returns:
 *	error mask
 *	settings of file_base and file_rules
 *
 * side-effects:
 *	in order to keep multiple filesyncs from running in parallel
 *	we put an advisory lock on the baseline file.  If the baseline
 *	file does not exist we create one.  The unlocking (and deletion
 *	of extraneous baselines) is handled in cleanup.
 */
static errmask_t
findfiles(void)		/* find rule and baseline files	*/
{ 	char *s, *where;
	char namebuf[MAX_PATH];
	int ret;
	errmask_t errs = 0;

	/* figure out where the files should be located	*/
	s = getenv("FILESYNC");
	where = (s && *s) ? expand(s) : expand(DFLT_PRFX);

	/* see if we got a viable name		*/
	if (where == 0) {
		fprintf(stderr, gettext(ERR_nofsync));
		return (ERR_FILES);
	}

	/* try to form the name of the rules file */
	strcpy(namebuf, where);
	strcat(namebuf, SUFX_RULES);
	s = strdup(namebuf);
	errs = check_access(namebuf, &new_rules);

	/* if we cannot find a proper rules file, look in the old place */
	if (new_rules && errs == 0) {
		strcpy(namebuf, where);
		strcat(namebuf, SUFX_OLD);
		file_rules = strdup(namebuf);
		errs = check_access(namebuf, &new_rules);

		/* if we couldn't find that either, go with new name	*/
		if (new_rules && errs == 0)
			file_rules = s;
	} else
		file_rules = s;

	/* try to form the name of the baseline file */
	strcpy(namebuf, where);
	strcat(namebuf, SUFX_BASE);
	file_base = strdup(namebuf);
	errs |= check_access(namebuf, &new_baseline);

	if (opt_debug & DBG_FILES) {
		fprintf(stderr, "FILE: %s rules file: %s\n",
			new_rules ? "new" : "existing", file_rules);

		fprintf(stderr, "FILE: %s base file:  %s\n",
			new_baseline ? "new" : "existing", file_base);
	}

	/*
	 * in order to lock out other filesync programs we need some
	 * file we can lock.  We do an advisory lock on the baseline
	 * file.  If no baseline file exists, we create an empty one.
	 */
	if (new_baseline)
		lockfd = creat(file_base, 0666);
	else
		lockfd = open(file_base, O_RDWR);

	if (lockfd < 0) {
		fprintf(stderr, new_baseline ? ERR_creat : ERR_open,
			TXT_base, file_base);
		errs |= ERR_FILES;
	} else {
		ret = lockf(lockfd, F_TLOCK, 0L);
		if (ret < 0) {
			fprintf(stderr, ERR_lock, TXT_base, file_base);
			errs |= ERR_FILES;
		} else if (opt_debug & DBG_FILES)
			fprintf(stderr, "FILE: locking baseline file %s\n",
				file_base);
	}

	return (errs);
}

/*
 * routine:
 *	cleanup
 *
 * purpose:
 *	to clean up temporary files and locking prior to exit
 *
 * paremeters:
 *	error mask
 *
 * returns:
 *	void
 *
 * notes:
 *	if there are no errors, the baseline file is assumed to be good.
 *	Otherwise, if we created a temporary baseline file (just for
 *	locking) we will delete it.
 */
static void
cleanup(errmask_t errmask)
{
	/* unlock the baseline file	*/
	if (opt_debug & DBG_FILES)
		fprintf(stderr, "FILE: unlock baseline file %s\n", file_base);
	(void) lockf(lockfd, F_ULOCK, 0);

	/* see if we need to delete a temporary copy	*/
	if (errmask && new_baseline) {
		if (opt_debug & DBG_FILES)
			fprintf(stderr, "FILE: unlink temp baseline file %s\n",
				file_base);
		(void) unlink(file_base);
	}
}

/*
 * routine:
 *	check_access
 *
 * purpose:
 *	to determine whether or not we can access an existing file
 *	or create a new one
 *
 * parameters:
 *	name of file (in a clobberable buffer)
 *	pointer to new file flag
 *
 * returns:
 *	error mask
 *	setting of the new file flag
 *
 * note:
 *	it is kind of a kluge that this routine clobbers the name,
 *	but it is only called from one place, it needs a modified
 *	copy of the name, and the one caller doesn't mind.
 */
static errmask_t
check_access(char *name, int *newflag)
{	char *s;

	/* start out by asking for what we want		*/
	if (access(name, R_OK|W_OK) == 0) {
		*newflag = 0;
		return (0);
	}

	/* if the problem is isn't non-existence, lose	*/
	if (errno != ENOENT) {
		*newflag = 0;
		fprintf(stderr, gettext(ERR_rdwri), name);
		return (ERR_FILES);
	}

	/*
	 * the file doesn't exist, so there is still hope if we can
	 * write in the directory that should contain the file
	 */
	*newflag = 1;

	/* truncate the file name to its containing directory */
	for (s = name; s[1]; s++);
	while (s > name && *s != '/')
		s--;
	if (s > name)
		*s = 0;
	else if (*s == '/')
		s[1] = 0;
	else
		name = ".";

	/* then see if we have write access to the directory	*/
	if (access(name, W_OK) == 0)
		return (0);

	fprintf(stderr, gettext(ERR_dirwac), name);
	return (ERR_FILES);
}

/*
 * routine:
 *	whoami
 *
 * purpose:
 *	to figure out who I am and what the default modes/ownership
 *	is on files that I create.
 */
static void
whoami()
{
	my_uid = geteuid();
	my_gid = getegid();
	my_umask = umask(0);

	if (opt_debug & DBG_MISC)
		fprintf(stderr, "MISC: my_uid=%u, my_gid=%u, my_umask=%03o\n",
			my_uid, my_gid, my_umask);
}



/* ============================================================================
 * SOURCE 40/98: minix4\exokernel\kernel_legacy\cmd\fmtmsg\main.c
 * Size: 20,226 bytes, Lines: 829
 * Hash: 2fbfd4116f35...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

/*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved  	*/

/*
 * Copyright (c) 2018, Joyent, Inc.
 */

/*
 * fmtmsg.c
 *
 * Contains:
 *	fmtmsg		Command that writes a message in the standard
 *			message format.  May in future make these
 *			messages available for logging.
 */


/*
 * Header files used:
 *	<stdio.h>	C Standard I/O function definitions
 *	<string.h>	C string-handling definitions
 *	<errno.h>	UNIX error-code "errno" definitions
 *	<fmtmsg.h>	Standard Message definitions
 */

#include	<stdio.h>
#include	<string.h>
#include	<errno.h>
#include	<fmtmsg.h>


/*
 * Externals referenced:
 *	strtol		Function that converts char strings to "long"
 *	fmtmsg		Function that writes a message in standard format
 *	getenv		Function that extracts an environment variable's
 *			value
 *	malloc		Allocate memory from the memory pool
 *	free		Frees allocated memory
 *	getopt		Function that extracts arguments from the command-
 *	optarg		Points to option's argument (from getopt())
 *	optind		Option's argument index (from getopt())
 *	opterr		FLAG, write error if invalid option (for getopt())
 *			line.
 *	exit		Exits the command
 */

extern	long		strtol();
extern	int		fmtmsg();
extern	char	       *getenv();
extern	void	       *malloc();
extern	void		free();
extern	int		getopt();
extern	char	       *optarg;
extern	int		optind;
extern	int		opterr;
extern	void		exit();

/*
 * Local definitions
 */

/*
 * Local constants
 */


/*
 * Boolean constants
 *	TRUE	Boolean value for "true" (any bits on)
 *	FALSE	Boolean value for "false" (all bits off)
 */

#ifndef	FALSE
#define	FALSE		(0)
#endif

#ifndef TRUE
#define	TRUE		(1)
#endif


#define	CLASS		(MM_PRINT|MM_SOFT|MM_NRECOV|MM_UTIL)
#define BIGUSAGE	"fmtmsg [-a action] [-c class] [-l label] [-s severity] [-t tag]\n       [-u subclass[,subclass[,...]]] [text]\n"


/*
 * Local data-type definitions
 */

/*
 * Structure used for tables containing keywords and integer values
 */

struct sev_info {
	char   *keyword;
	int	value;
};


/*
 * Structure used for tables containing keywords, long values
 */

struct class_info {
	char   *keyword;
	long	value;
	long	conflict;
};


/*
 * Severity string structure
 *
 *	struct sevstr
 *		sevvalue	Value of the severity-level being defined
 *		sevkywd		Keyword identifying the severity
 *		sevprptr	Pointer to the string associated with the value
 *		sevnext		Pointer to the next value in the list.
 */

struct sevstr {
	int		sevvalue;
	char           *sevkywd;
	char	       *sevprstr;
	struct sevstr  *sevnext;
};


/*
 * Local static data
 */


/*
 * Table contains the keywords for the classes of a message
 */

static	struct class_info	classes[] = {

	{"hard", 	MM_HARD,	MM_SOFT|MM_FIRM},	/* hardware */
	{"soft", 	MM_SOFT,	MM_HARD|MM_FIRM},	/* software */
	{"firm", 	MM_FIRM,	MM_SOFT|MM_FIRM},	/* firmware */

	{(char *) NULL,	0L,		0L}			/* end of list */

};


/*
 * Table contains the keywords for the subclasses for a message
 */

static	struct class_info	subclasses[] = 	{

	{"appl",     	MM_APPL,	MM_UTIL|MM_OPSYS},	/* Application */
	{"util",     	MM_UTIL,	MM_APPL|MM_OPSYS},	/* Utility */
	{"opsys",    	MM_OPSYS,	MM_APPL|MM_UTIL},	/* Operating System */

	{"recov",    	MM_RECOVER,	MM_NRECOV},		/* Recoverable */
	{"nrecov",   	MM_NRECOV,	MM_RECOVER},		/* Non-recoverable */

	{"print",    	MM_PRINT,	0L}, 			/* Write message to stderr */
	{"console",  	MM_CONSOLE,	0L},			/* Write message on /dev/console */
	{(char *) NULL,	0L,		0L}			/* End of list */

};


/*
 * Table contains the keywords for the standard severities of a message.
 * User may supply more through the SEV_LEVEL environment variable.
 */

static  struct sev_info		severities[] =  {
	{"halt",	MM_HALT},	/* halt */
	{"error",	MM_ERROR},	/* error */
	{"warn",	MM_WARNING},	/* warn */
	{"info",	MM_INFO},	/* info */
	{(char *) NULL,	0}		/* end of list */
};


/*
 * Buffers used by the command
 */

static	char	labelbuf[128];		/* Buf for message label */
static	char	msgbuf[256];		/* Buf for messages */

/*
 * static char *exttok(str, delims)
 *	char   *str
 *	char   *delims
 *
 *	This function examines the string pointed to by "str", looking
 *	for the first occurrence of any of the characters in the string
 *	whose address is "delims".  It returns the address of that
 *	character or (char *) NULL if there was nothing to search.
 *
 * Arguments:
 *	str	Address of the string to search
 *	delims	Address of the string containing delimiters
 *
 * Returns:  char *
 *	Returns the address of the first occurrence of any of the characters
 *	in "delim" in the string "str" (incl '\0').  If there was nothing
 *	to search, the function returns (char *) NULL.
 *
 * Notes:
 *    - This function is needed because strtok() can't be used inside a
 *	function.  Besides, strtok() is destructive in the string, which
 *	is undesirable in many circumstances.
 *    - This function understands escaped delimiters as non-delimiters.
 *	Delimiters are escaped by preceding them with '\' characters.
 *	The '\' character also must be escaped.
 */

static char *
exttok(tok, delims)
	char   *tok;		/* Ptr to the token we're parsing */
	char   *delims;		/* Ptr to string with delimiters */
{

	/* Automatic Data */
	char   *tokend;		/* Ptr to the end of the token */
	char   *p, *q;	 	/* Temp pointers */


	/* Algorithm:
	 *    1.  Get the starting address (new string or where we
	 *	  left off).  If nothing to search, return (char *) NULL
	 *    2.  Find the end of the string
	 *    3.  Look for the first unescaped delimiter closest to the
	 *	  beginning of the string
	 *    4.  Remember where we left off
	 *    5.  Return a pointer to the delimiter we found
	 */

	/* Begin at the beginning, if any */
	if (tok == (char *) NULL) {
	    return ((char *) NULL);
	}

	/* Find end of the token string */
	tokend = tok + strlen(tok);

	/* Look for the 1st occurrence of any delimiter */
	for (p = delims ; *p != '\0' ; p++) {
	    for (q = strchr(tok, *p) ; q && (q != tok) && (*(q-1) == '\\') ; q = strchr(q+1, *p)) ;
	    if (q && (q < tokend)) tokend = q;
	}

	/* Done */
	return(tokend);
}

/*
 * char *noesc(str)
 *
 *	This function squeezes out all of the escaped character sequences
 *	from the string <str>.  It returns a pointer to that string.
 *
 *  Arguments:
 *	str	char *
 *		The string that is to have its escaped characters removed.
 *
 *  Returns:  char *
 *	This function returns its argument <str> always.
 *
 *  Notes:
 *	This function potentially modifies the string it is given.
 */

char *
noesc(str)
	char   *str;		/* String to remove escaped characters from */
{
	char   *p;		/* Temp string pointer */
	char   *q;		/* Temp string pointer */

	/* Look for an escaped character */
	p = str;
	while (*p && (*p != '\\')) p++;


	/*
	 * If there was at least one, squeeze them out
	 * Otherwise, don't touch the argument string
	 */

	if (*p) {
	    q = p++;
	    while (*q++ = *p++) if (*p == '\\') p++;
	}

	/* Finished.  Return our argument */
	return(str);
}

/*
 * struct sevstr *getauxsevs(ptr)
 *
 *	Parses a string that is in the format of the severity definitions.
 *	Returns a pointer to a (malloc'd) structure that contains the
 *	definition, or (struct sevstr *) NULL if none was parsed.
 *
 * Arguments:
 *	ptr	char *
 *		References the string from which data is to be extracted.
 *		If (char *) NULL, continue where we left off.  Otherwise,
 *		start with the string referenced by ptr.
 *
 * Returns: struct sevstr *
 *	A pointer to a malloc'd structure containing the severity definition
 *	parsed from string, or (struct sevstr *) NULL if none.
 *
 * Notes:
 *    - This function is destructive to the string referenced by its argument.
 */


/* Static data */
static	char	       *leftoff = (char *) NULL;

static	struct sevstr *
getauxsevs(ptr)
	char   *ptr;
{

	/* Automatic data */
	char	       *current;	/* Ptr to current sev def'n */
	char	       *tokend;		/* Ptr to end of current sev def'n */
	char	       *kywd;		/* Ptr to extracted kywd */
	char	       *valstr;		/* Ptr to extracted sev value */
	char	       *prstr;		/* Ptr to extracted print str */
	char	       *p;		/* Temp pointer */
	int		val;		/* Converted severity value */
	int		done;		/* Flag, sev def'n found and ok? */
	struct sevstr  *rtnval;		/* Value to return */


	/* Start anew or start where we left off? */
	current = (ptr == (char *) NULL) ? leftoff : ptr;


	/* If nothing to parse, return (char *) NULL */
	if (current == (char *) NULL) {
	    return ((struct sevstr *) NULL);
	}


	/*
	 * Look through the string "current" for a token of the form
	 * <kywd>,<sev>,<printstring> delimited by ':' or '\0'
	 */

	/* Loop initializations */
	done = FALSE;
	rtnval = (struct sevstr *) NULL;
	while (!done) {

	    /* Eat leading junk */
	    while (*(tokend = exttok(current, ":,")) == ':') {
		current = tokend + 1;
	    }

	    /* If we've found a <kywd>,... */
	    if (*tokend == ',') {
		kywd = current;
		*tokend = '\0';

		/* Look for <kywd>,<sev>,... */
		current = tokend + 1;
		if (*(tokend = exttok(current, ":,")) == ',') {
		    valstr = current;
		    *tokend = '\0';
		    current = tokend+1;
		    prstr = current;

		    /* Make sure <sev> > 4 */
		    val = (int) strtol(noesc(valstr), &p, 0);
		    if ((val > 4) && (p == tokend)) {

			/*
			 * Found <kywd>,<sev>,<printstring>.
			 * remember where we left off
			 */

		        if (*(tokend = exttok(current, ":")) == ':') {
			    *tokend = '\0';
			    leftoff = tokend + 1;
			} else leftoff = (char *) NULL;

			/* Alloc structure to contain severity definition */
			if (rtnval = (struct sevstr *) malloc(sizeof(struct sevstr))) {

			    /* Fill in structure */
			    rtnval->sevkywd = noesc(kywd);
			    rtnval->sevvalue = val;
			    rtnval->sevprstr = noesc(prstr);
			    rtnval->sevnext = (struct sevstr *) NULL;
			}

			done = TRUE;

		    } else {

			/* Invalid severity value, eat thru end of token */
			current = tokend;
			if (*(tokend = exttok(prstr, ":")) == ':')
			    current++;
		    }

		} else {

		    /* Invalid severity definition, eat thru end of token */
		    current = tokend;
		    if (*tokend == ':')
			current++;
		}

	    } else {

		/* End of string found */
		done = TRUE;
		leftoff = (char *) NULL;
	    }

	} /* while (!done) */

	/* Finished */
	return(rtnval);
}

/*
 * fmtmsg [-a action] [-c classification] [-l label] [-s severity] [-t tag]
 *        [-u subclass[,subclass[,...]]] [text]
 *
 * Function:
 *	Writes a message in the standard format.  Typically used by shell
 *	scripts to write error messages to the user.
 *
 * Arguments:
 *	text		String that is the text of the message
 *
 * Options:
 *   -a action		String that describes user action to take to
 *			correct the situation
 *   -c classification	Keyword that identifies the type of the message
 *   -l label		String that identifies the source of the message
 *   -s severity	Keyword that identifies the severity of the message
 *   -t tag		String that identifies the message (use unclear)
 *   -u sub_classes	Comma-list of keywords that refines the type of
 *			the message
 *
 * Environment Variables Used:
 *	MSGVERB		Defines the pieces of a message the user expects
 *			to see.  It is a list of keywords separated by
 *			colons (':').
 *	SEV_LEVEL	Defines a list of auxiliary severity keywords, values,
 *			and print-strings.  It is a list of fields separated
 *			by colons (':').  Each field consists of three
 *			elements, keyword, value (in octal, hex, or decimal),
 *			and print-string, separated by commas (',').
 *
 * Needs:
 *
 * Open Issues:
 */

int
main(int argc, char **argv)
{

	/* Local automatic data */

	long			class;		/* Classification (built) */

	int			severity;	/* User specified severity */
	int			msgrtn;		/* Value returned by fmtmsg() */
	int			optchar;	/* Opt char on cmdline */
	int			exitval;	/* Value to return */

	int			found;		/* FLAG, kywd found yet? */
	int			errflg;		/* FLAG, error seen in cmd */
	int			a_seen;		/* FLAG, -a option seen */
	int			c_seen;		/* FLAG, -c option seen */
	int			l_seen;		/* FLAG, -l option seen */
	int			s_seen;		/* FLAG, -s option seen */
	int			t_seen;		/* FLAG, -t option seen */
	int			u_seen;		/* FLAG, -u option seen */
	int			text_seen;	/* FLAG, text seen */

	char		       *text;		/* Ptr to user's text */
	char		       *label;		/* Ptr to user's label */
	char		       *tag;		/* Ptr to user's tag */
	char		       *action;		/* Ptr to user's action str */
	char		       *sstr;		/* Ptr to -s (severity) arg */
	char		       *ustr;		/* Ptr to -u (subclass) arg */
	char		       *cstr;		/* Ptr to -c (class) arg */
	char		       *sevstrval;	/* Ptr to SEV_LEVEL argument */
	char		       *sevval;		/* Ptr to temp SEV_LEVEL arg */
	char		       *tokenptr;	/* Ptr to current token */
	char		       *cmdname;	/* Ptr to base command name */
	char		       *p;		/* Multipurpose ptr */

	struct class_info      *class_info;	/* Ptr to class/subclass info structure */
	struct sev_info	       *sev_info;	/* Ptr to severity info struct */
	struct sevstr	       *penvsev;	/* Ptr to SEV_LEVEL values */



	/*
	 * fmtmsg
	 */


	/* Initializations */


	/* Extract the base command name from the command */
	if ((p = strrchr(argv[0], '/')) == (char *) NULL)
	    cmdname = argv[0];
	else
	    cmdname = p+1;

	/* Build the label for messages from "fmtmsg" */
	(void) snprintf(labelbuf, sizeof (labelbuf), "UX:%s", cmdname);


	/*
	 * Extract arguments from the command line
	 */

	/* Initializations */

	opterr = 0;			/* Disable messages from getopt() */
	errflg = FALSE;			/* No errors seen yet */

	a_seen = FALSE;			/* No action (-a) text seen yet */
	c_seen = FALSE;			/* No classification (-c) seen yet */
	l_seen = FALSE;			/* No label (-l) seen yet */
	s_seen = FALSE;			/* No severity (-s) seen yet */
	t_seen = FALSE;			/* No tag (-t) seen yet */
	u_seen = FALSE;			/* No subclass (-u) seen yet */
	text_seen = FALSE;		/* No text seen yet */


	/*
	 * If only the command name was used, write out a usage string to
	 * the standard output file.
	 */

	if (argc == 1) {
	    (void) fputs(BIGUSAGE, stderr);
	    exit(0);
	}


	/* Parce command line */
	while (((optchar = getopt(argc, argv, "a:c:l:s:t:u:")) != EOF) &&
	       !errflg) {

	    switch(optchar) {

	    case 'a':		/* -a actiontext */
		if (!a_seen) {
		    action = optarg;
		    a_seen = TRUE;
		} else errflg = TRUE;
		break;

	    case 'c':		/* -c classification */
		if (!c_seen) {
		    cstr = optarg;
		    c_seen = TRUE;
		} else errflg = TRUE;
		break;

	    case 'l':		/* -l label */
		if (!l_seen) {
		    label = optarg;
		    l_seen = TRUE;
		} else errflg = TRUE;
		break;

	    case 's':		/* -s severity */
		if (!s_seen) {
		    sstr = optarg;
		    s_seen = TRUE;
		} else errflg = TRUE;
		break;

	    case 't':		/* -t tag */
		if (!t_seen) {
		    tag = optarg;
		    t_seen = TRUE;
		} else errflg = TRUE;
		break;

	    case 'u':		/* -u subclasslist */
		if (!u_seen) {
		    ustr = optarg;
		    u_seen = TRUE;
		} else errflg = TRUE;
		break;

	    case '?':		/* -? or unknown option */
	    default:
		errflg = TRUE;
		break;

	    } /* esac */
	}


	/* Get the text */
	if (!errflg) {
	    if (argc == (optind+1)) {
		text = argv[optind];
		text_seen = TRUE;
	    }
	    else if (argc != optind) {
		errflg = TRUE;
	    }
	}


	/* Report syntax errors */
	if (errflg) {
	    (void) fputs(BIGUSAGE, stderr);
	    exit(1);
	}


	/*
	 * Classification.
	 */

	class = 0L;
	if (c_seen) {

	    /* Search for keyword in list */
	    for (class_info = &classes[0] ;
		 (class_info->keyword != (char *) NULL) &&
		 (strcmp(cstr, class_info->keyword)) ;
		 class_info++) ;

	    /* If invalid (keyword unknown), write a message and exit */
	    if (class_info->keyword == (char *) NULL) {
		(void) snprintf(msgbuf, sizeof (msgbuf),
			"Invalid class: %s", cstr);
		(void) fmtmsg(CLASS, labelbuf, MM_ERROR, msgbuf,
		              MM_NULLACT, MM_NULLTAG);
		exit(1);
	    }

	    /* Save classification */
	    class = class_info->value;

	}


	/*
	 * Subclassification.
	 */

	if (u_seen) {

	    errflg = FALSE;
	    p = strcpy(malloc((unsigned int) strlen(ustr)+1), ustr);
	    if ((tokenptr = strtok(p, ",")) == (char *) NULL) errflg = TRUE;
	    else do {

		/* Got a keyword.  Look for it in keyword list */
		for (class_info = subclasses ;
		     (class_info->keyword != (char *) NULL) &&
		     (strcmp(tokenptr, class_info->keyword) != 0) ;
		     class_info++) ;

		/* If found in list and no conflict, remember in class */
		if ((class_info->keyword != (char *) NULL) && ((class & class_info->conflict) == 0L))
		    class |= class_info->value;
		else
		    errflg = TRUE;

	    } while (!errflg && ((tokenptr = strtok((char *) NULL, ",")) != (char *) NULL)) ;

	    if (errflg) {
		(void) snprintf(msgbuf, sizeof (msgbuf),
			"Invalid subclass: %s", ustr);
		(void) fmtmsg(CLASS, labelbuf, MM_ERROR, msgbuf,
		              MM_NULLACT, MM_NULLTAG);
		exit(1);
	    }

	}

	if (!c_seen && !u_seen) class = MM_NULLMC;



	/*
	 * Severity.
	 */

	if (s_seen) {

	    /* If the severity is specified as a number, use that value */
	    severity = strtol(sstr, &p, 10);
	    if (*p || (strlen(sstr) == 0)) {

		/* Look for the standard severities */
		for (sev_info = severities ;
		     (sev_info->keyword != (char *) NULL) &&
		     (strcmp(sstr, sev_info->keyword)) ;
		     sev_info++) ;

		/*
		 * If the "severity" argument is one of the standard keywords,
		 * remember it for fmtmsg().  Otherwise, look at the SEV_LEVEL
		 * environment variable for severity extensions.
		 */

		/* If the keyword is one of the standard ones, save severity */
		if (sev_info->keyword != (char *) NULL) severity = sev_info->value;

		else {

		    /*
		     * Severity keyword may be one of the extended set, if any.
		     */

		    /* Get the value of the SEV_LEVEL environment variable */
		    found = FALSE;
		    if ((sevstrval = getenv(SEV_LEVEL)) != (char *) NULL) {
			sevval = (char *) malloc((unsigned int) strlen(sevstrval)+1);
			penvsev = getauxsevs(strcpy(sevval, sevstrval));
			if (penvsev != (struct sevstr *) NULL) do {
			    if (strcmp(penvsev->sevkywd, sstr) == 0) {
				severity = penvsev->sevvalue;
				found = TRUE;
			    }
			    else {
				free(penvsev);
				penvsev = getauxsevs((char *) NULL);
			    }
			} while (!found && (penvsev != (struct sevstr *) NULL));

			if (found) free(penvsev);
			free(sevval);
		    }

		    if (!found) {
			(void) snprintf(msgbuf, sizeof (msgbuf),
				"Invalid severity: %s", sstr);
			(void) fmtmsg(CLASS, labelbuf, MM_ERROR, msgbuf,
				      MM_NULLACT, MM_NULLTAG);
			exit(1);
		    }

		}  /* <severity> is not one of the standard severities */

	    }  /* <severity> is not numeric */

	}  /* if (s_seen) */

	else severity = MM_NULLSEV;


	/*
	 * Other options
	 */

	if (!a_seen) action = MM_NULLACT;
	if (!l_seen) label = MM_NULLLBL;
	if (!t_seen) tag = MM_NULLTAG;
	if (!text_seen) text = MM_NULLTXT;


	/*
	 * Write the message
	 */

	msgrtn = fmtmsg(class, label, severity, text, action ,tag);


	/*
	 * Return appropriate value to the shell (or wherever)
	 */

	exitval = 0;
	if (msgrtn == MM_NOTOK) exitval = 32;
	else {
	    if (msgrtn & MM_NOMSG) exitval += 2;
	    if (msgrtn & MM_NOCON) exitval += 4;
	}

	return(exitval);
}



/* ============================================================================
 * SOURCE 41/98: minix4\exokernel\kernel_legacy\cmd\format\main.c
 * Size: 17,249 bytes, Lines: 683
 * Hash: b9d1cb750273...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 * Copyright (c) 2016 by Delphix. All rights reserved.
 */

/*
 * This file contains the main entry point of the program and other
 * routines relating to the general flow.
 */
#include "global.h"
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <signal.h>
#include <memory.h>
#include <string.h>
#include <errno.h>

#ifdef sparc
#include <sys/hdio.h>
#include <sys/dkbad.h>
#endif

#include <sys/time.h>
#include "main.h"
#include "analyze.h"
#include "menu.h"
#include "param.h"
#include "misc.h"
#include "startup.h"
#include "menu_command.h"
#include "menu_partition.h"
#include "prompts.h"
#include "checkdev.h"
#include "label.h"

extern	struct menu_item menu_command[];
uint_t	apc;
uint_t	solaris_offset;
char	cur_menu;
char	last_menu;
void	*pattern_buf;
FILE	*log_file;
void	*cur_buf;
struct disk_info *cur_disk;
struct ctlr_ops *cur_ops;
struct ctlr_info *cur_ctlr;
struct ctlr_type *cur_ctype;
struct disk_type *cur_dtype;
struct partition_info *cur_parts;
struct defect_list cur_list;
int	cur_file;
int	cur_flags;
int	cur_label;
uint_t	pcyl;
uint_t	ncyl;
uint_t	acyl;
uint_t	bcyl;
uint_t	nhead;
uint_t	phead;
uint_t	nsect;
uint_t	psect;

#ifdef	__STDC__

/*
 *	Local prototypes for ANSI C compilers
 */
static void	get_disk_characteristics(void);


#else	/* __STDC__ */

/*
 *	Local prototypes for non-ANSI C compilers
 */
static void	get_disk_characteristics();

#endif	/* __STDC__ */

/*
 * This is the main entry point.
 */
int
main(int argc, char *argv[])
{
	int	i;
	int	ret_code = 1;
	char	**arglist;
	struct	disk_info *disk = NULL;
	struct	disk_type *type, *oldtype;
	struct	partition_info *parts;
	struct	sigaction act;

	solaris_offset = 0;
	/*
	 * Initialize cur_ctype to avoid null pointer dereference
	 * in auto_efi_sense().
	 */
	cur_ctype = NULL;
	/*
	 * Decode the command line options.
	 */
	i = do_options(argc, argv);
	/*
	 * If we are to run from a command file, open it up.
	 */
	if (option_f) {
		if (freopen(option_f, "r", stdin) == NULL) {
			err_print("Unable to open command file '%s'.\n",
			    option_f);
			fullabort();
		}
	}
	/*
	 * If we are logging, open the log file.
	 */
	if (option_l) {
		if ((log_file = fopen(option_l, "w")) == NULL) {
			err_print("Unable to open log file '%s'.\n",
			    option_l);
			fullabort();
		}
	}
	/*
	 * Read in the data file and initialize the hardware structs.
	 */
	sup_init();
	/*
	 * If there are no disks on the command line, search the
	 * appropriate device directory for character devices that
	 * look like disks.
	 */
	if (i < 0) {
		arglist = NULL;
	/*
	 * There were disks on the command line.  They comprise the
	 * search list.
	 */
	} else {
		arglist = &argv[i];
	}
	/*
	 * Perform the search for disks.
	 */
	do_search(arglist);
	/*
	 * Catch ctrl-C and ctrl-Z so critical sections can be
	 * implemented.  We use sigaction, as this sets up the
	 * signal handler permanently, and also automatically
	 * restarts any interrupted system call.
	 */
	act.sa_handler = cmdabort;
	(void) memset(&act.sa_mask, 0, sizeof (sigset_t));
	act.sa_flags = SA_RESTART | SA_NODEFER;
	if (sigaction(SIGINT, &act, NULL) == -1) {
		err_print("sigaction(SIGINT) failed - %s\n",
		    strerror(errno));
		fullabort();
	}

	act.sa_handler = onsusp;
	(void) memset(&act.sa_mask, 0, sizeof (sigset_t));
	act.sa_flags = SA_RESTART | SA_NODEFER;
	if (sigaction(SIGTSTP, &act, NULL) == -1) {
		err_print("sigaction(SIGTSTP) failed - %s\n",
		    strerror(errno));
		fullabort();
	}

	act.sa_handler = onalarm;
	(void) memset(&act.sa_mask, 0, sizeof (sigset_t));
	act.sa_flags = SA_RESTART;
	if (sigaction(SIGALRM, &act, NULL) == -1) {
		err_print("sigaction(SIGALRM) failed - %s\n",
		    strerror(errno));
		fullabort();
	}

	/*
	 * If there was only 1 disk on the command line, mark it
	 * to be the current disk.  If it wasn't found, it's an error.
	 */
	if (i == argc - 1) {
		disk = disk_list;
		if (disk == NULL) {
			err_print("Unable to find specified disk '%s'.\n",
			    argv[i]);
			fullabort();
		}
	}
	/*
	 * A disk was forced on the command line.
	 */
	if (option_d) {
		/*
		 * Find it in the list of found disks and mark it to
		 * be the current disk.
		 */
		for (disk = disk_list; disk != NULL; disk = disk->disk_next)
			if (diskname_match(option_d, disk))
				break;
		/*
		 * If it wasn't found, it's an error.
		 */
		if (disk == NULL) {
			err_print("Unable to find specified disk '%s'.\n",
			    option_d);
			fullabort();
		}
	}
	/*
	 * A disk type was forced on the command line.
	 */
	if (option_t != NULL) {
		/*
		 * Only legal if a disk was also forced.
		 */
		if (disk == NULL) {
			err_print("Must specify disk as well as type.\n");
			fullabort();
		}
		oldtype = disk->disk_type;
		/*
		 * Find the specified type in the list of legal types
		 * for the disk.
		 */
		for (type = disk->disk_ctlr->ctlr_ctype->ctype_dlist;
		    type != NULL; type = type->dtype_next)
			if (strcmp(option_t, type->dtype_asciilabel) == 0)
				break;
		/*
		 * If it wasn't found, it's an error.
		 */
		if (type == NULL) {
			err_print(
"Specified type '%s' is not a known type.\n", option_t);
			fullabort();
		}
		/*
		 * If the specified type is not the same as the type
		 * in the disk label, update the type and nullify the
		 * partition map.
		 */
		if (type != oldtype) {
			disk->disk_type = type;
			disk->disk_parts = NULL;
		}
	}
	/*
	 * A partition map was forced on the command line.
	 */
	if (option_p) {
		/*
		 * Only legal if both disk and type were also forced.
		 */
		if (disk == NULL || disk->disk_type == NULL) {
			err_print("Must specify disk and type as well ");
			err_print("as partitiion.\n");
			fullabort();
		}
		/*
		 * Find the specified map in the list of legal maps
		 * for the type.
		 */
		for (parts = disk->disk_type->dtype_plist; parts != NULL;
		    parts = parts->pinfo_next)
			if (strcmp(option_p, parts->pinfo_name) == 0)
				break;
		/*
		 * If it wasn't found, it's an error.
		 */
		if (parts == NULL) {
			err_print(
"Specified table '%s' is not a known table.\n", option_p);
			fullabort();
		}
		/*
		 * Update the map.
		 */
		disk->disk_parts = parts;
	}
	/*
	 * If a disk was marked to become current, initialize the state
	 * to make it current.  If not, ask user to pick one.
	 */
	if (disk != NULL) {
		init_globals(disk);
	} else if (option_f == 0 && option_d == 0) {
		while (ret_code) {
			ret_code = c_disk();
		}
	}

#ifdef	BUG1134748
	/*
	 * if -f command-file is specified, check for disk and disktype
	 * input also. For SCSI disks, the type input may not be needed
	 * since format would have figured that using inquiry information.
	 */
	if (option_f) {
		if (cur_disk == NULL) {
			err_print("Must specify a disk using -d option.\n");
			fullabort();
		}
		if (cur_dtype == NULL) {
			err_print("Must specify disk as well as type.\n");
			fullabort();
		}
	}
#endif	/* BUG1134748 */

	/*
	 * Run the command menu.
	 */
	cur_menu = last_menu = 0;
	run_menu(menu_command, "FORMAT", "format", 1);

	/*
	 * normal ending. Explicitly return(0);
	 */
	return (0);
}

/*
 * This routine initializes the internal state to ready it for a new
 * current disk.  There are a zillion state variables that store
 * information on the current disk, and they must all be updated.
 * We also tell SunOS about the disk, since it may not know if the
 * disk wasn't labeled at boot time.
 */
void
init_globals(struct disk_info *disk)
{
	int		status;
	int		found_mount;
	int		found_inuse;
#ifdef sparc
	int		i;
	caddr_t		bad_ptr = (caddr_t)&badmap;
#endif

	/*
	 * If there was an old current disk, close the file for it.
	 */
	if (cur_disk != NULL)
		(void) close(cur_file);
	/*
	 * Kill off any defect lists still lying around.
	 */
	kill_deflist(&cur_list);
	kill_deflist(&work_list);
	/*
	 * If there were any buffers, free them up.
	 */
	if ((char *)cur_buf != NULL) {
		destroy_data((char *)cur_buf);
		cur_buf = NULL;
	}
	if ((char *)pattern_buf != NULL) {
		destroy_data((char *)pattern_buf);
		pattern_buf = NULL;
	}
	/*
	 * Fill in the hardware struct pointers for the new disk.
	 */
	cur_disk = disk;
	cur_dtype = cur_disk->disk_type;
	cur_label = cur_disk->label_type;
	cur_ctlr = cur_disk->disk_ctlr;
	cur_parts = cur_disk->disk_parts;
	cur_blksz = cur_disk->disk_lbasize;
	cur_ctype = cur_ctlr->ctlr_ctype;
	cur_ops = cur_ctype->ctype_ops;
	cur_flags = 0;
	/*
	 * Open a file for the new disk.
	 */
	if ((cur_file = open_disk(cur_disk->disk_path,
	    O_RDWR | O_NDELAY)) < 0) {
		err_print(
"Error: can't open selected disk '%s'.\n", cur_disk->disk_name);
		fullabort();
	}
#ifdef sparc
	/*
	 * If the new disk uses bad-144, initialize the bad block table.
	 */
	if (cur_ctlr->ctlr_flags & DKI_BAD144) {
		badmap.bt_mbz = badmap.bt_csn = badmap.bt_flag = 0;
		for (i = 0; i < NDKBAD; i++) {
			badmap.bt_bad[i].bt_cyl = -1;
			badmap.bt_bad[i].bt_trksec = -1;
		}
	}
#endif
	/*
	 * If the type of the new disk is known...
	 */
	if (cur_dtype != NULL) {
		/*
		 * Initialize the physical characteristics.
		 * If need disk specs, prompt for undefined disk
		 * characteristics.  If running from a file,
		 * use defaults.
		 */
		if (cur_dtype->dtype_flags & DT_NEED_SPEFS) {
			get_disk_characteristics();
			cur_dtype->dtype_flags &= ~DT_NEED_SPEFS;
		}

		ncyl = cur_dtype->dtype_ncyl;
		acyl = cur_dtype->dtype_acyl;
		pcyl = cur_dtype->dtype_pcyl;
		nhead = cur_dtype->dtype_nhead;
		nsect = cur_dtype->dtype_nsect;
		phead = cur_dtype->dtype_phead;
		psect = cur_dtype->dtype_psect;
		/*
		 * Alternates per cylinder are forced to 0 or 1,
		 * independent of what the label says.  This works
		 * because we know which ctlr we are dealing with.
		 */
		if (cur_ctype->ctype_flags & CF_APC)
			apc = 1;
		else
			apc = 0;
		/*
		 * Initialize the surface analysis info.  We always start
		 * out with scan set for the whole disk.  Note,
		 * for SCSI disks, we can only scan the data area.
		 */
		scan_lower = 0;
		scan_size = BUF_SECTS;
		if ((cur_ctype->ctype_flags & CF_SCSI) &&
		    (cur_disk->label_type == L_TYPE_SOLARIS)) {
			scan_upper = datasects() - 1;
		} else if (cur_disk->label_type == L_TYPE_SOLARIS) {
			scan_upper = physsects() - 1;
		} else if (cur_disk->label_type == L_TYPE_EFI) {
			scan_upper = cur_parts->etoc->efi_last_lba;
		}

		/*
		 * Allocate the buffers.
		 */
		cur_buf = (void *) zalloc(BUF_SECTS * cur_blksz);
		pattern_buf = (void *) zalloc(BUF_SECTS * cur_blksz);

		/*
		 * Tell the user which disk they selected.
		 */
		if (chk_volname(cur_disk)) {
			fmt_print("selecting %s: ", cur_disk->disk_name);
			print_volname(cur_disk);
			fmt_print("\n");
		} else {
			fmt_print("selecting %s\n", cur_disk->disk_name);
		}

		/*
		 * If the drive is formatted...
		 */
		if ((*cur_ops->op_ck_format)()) {
			/*
			 * Mark it formatted.
			 */
			cur_flags |= DISK_FORMATTED;
			/*
			 * Read the defect list, if we have one.
			 */
			if (!EMBEDDED_SCSI) {
				read_list(&cur_list);
			}
#ifdef sparc
			/*
			 * If the disk does BAD-144, we do an ioctl to
			 * tell SunOS about the bad block table.
			 */
			if (cur_ctlr->ctlr_flags & DKI_BAD144) {
				if (ioctl(cur_file, HDKIOCSBAD, &bad_ptr)) {
					err_print(
"Warning: error telling SunOS bad block map table.\n");
				}
			}
#endif
			fmt_print("[disk formatted");
			if (!EMBEDDED_SCSI) {
				if (cur_list.list != NULL) {
					fmt_print(", defect list found");
				} else {
					fmt_print(", no defect list found");
				}
			}
			fmt_print("]");
		/*
		 * Drive wasn't formatted.  Tell the user in case they
		 * disagree.
		 */
		} else if (EMBEDDED_SCSI) {
			fmt_print("[disk unformatted]");
		} else {
			/*
			 * Make sure the user is serious.  Note, for
			 * SCSI disks since this is instantaneous, we
			 * will just do it and not ask for confirmation.
			 */
			status = 0;
			if (!(cur_ctype->ctype_flags & CF_CONFIRM)) {
				if (check("\n\
Ready to get manufacturer's defect list from unformatted drive.\n\
This cannot be interrupted and takes a long while.\n\
Continue"))
					status = 1;
				else
					fmt_print(
				"Extracting manufacturer's defect list...");
			}
			/*
			 * Extract manufacturer's defect list.
			 */
			if ((status == 0) && (cur_ops->op_ex_man != NULL)) {
				status = (*cur_ops->op_ex_man)(&cur_list);
			} else {
				status = 1;
			}
			fmt_print("[disk unformatted");
			if (status != 0) {
				fmt_print(", no defect list found]");
			} else {
				fmt_print(", defect list found]");
			}
		}
	} else {
		/*
		 * Disk type is not known.
		 * Initialize physical characteristics to 0 and tell the
		 * user we don't know what type the disk is.
		 */
		ncyl = acyl = nhead = nsect = psect = 0;
	}

	fmt_print("\n");

	/*
	 * Check to see if there are any mounted file systems on the
	 * disk.  If there are, print a warning.
	 */
	if ((found_mount = checkmount((diskaddr_t)-1, (diskaddr_t)-1)) != 0)
		err_print("Warning: Current Disk has mounted partitions.\n");

	/*
	 * If any part of this device is also part of an SVM, VxVM or
	 * Live Upgrade device, print a warning.
	 */
	found_inuse =  checkdevinuse(cur_disk->disk_name, (diskaddr_t)-1,
	    (diskaddr_t)-1, 1, 0);

	/*
	 * Get the Solaris Fdisk Partition information
	 */
	(void) copy_solaris_part(&cur_disk->fdisk_part);

	if (!found_mount && !found_inuse &&
	    cur_disk->label_type == L_TYPE_EFI) {

		/*
		 * If alter_lba is 1, we are using the backup label.
		 * Since we can locate the backup label by disk capacity,
		 * there must be no space expanded after backup label.
		 */
		if ((cur_parts->etoc->efi_altern_lba != 1) &&
		    (cur_parts->etoc->efi_altern_lba <
		    cur_parts->etoc->efi_last_lba)) {

			/*
			 * Lun expansion detected. Prompt user now and actually
			 * adjust the label in <partition> command.
			 */
			fmt_print(
"Note: capacity in disk label is smaller than the real disk capacity.\n\
Select <partition> <expand> to adjust the label capacity. \n");
		}
	}
}


/*
 * Prompt for some undefined disk characteristics.
 * Used when there is no disk definition, but the
 * disk has a valid label, so basically we're
 * prompting for everything that isn't in the label.
 */
static void
get_disk_characteristics(void)
{
	/*
	 * The need_spefs flag is used to tell us that this disk
	 * is not a known type and the ctlr specific info must
	 * be prompted for.  We only prompt for the info that applies
	 * to this ctlr.
	 */
	assert(cur_dtype->dtype_flags & DT_NEED_SPEFS);

	/*
	 * If we're running with input from a file, use
	 * reasonable defaults, since prompting for the
	 * information will probably mess things up.
	 */
	if (option_f) {
		cur_dtype->dtype_pcyl = ncyl + acyl;
		cur_dtype->dtype_rpm = AVG_RPM;
		cur_dtype->dtype_bpt = INFINITY;
		cur_dtype->dtype_phead = 0;
		cur_dtype->dtype_psect = 0;
		cur_dtype->dtype_cyl_skew = 0;
		cur_dtype->dtype_trk_skew = 0;
		cur_dtype->dtype_trks_zone = 0;
		cur_dtype->dtype_atrks = 0;
		cur_dtype->dtype_asect = 0;
		cur_dtype->dtype_cache = 0;
		cur_dtype->dtype_threshold = 0;
		cur_dtype->dtype_prefetch_min = 0;
		cur_dtype->dtype_prefetch_max = 0;

		if (cur_ctype->ctype_flags & CF_SMD_DEFS) {
			cur_dtype->dtype_bps = AVG_BPS;
		}
	} else {

		cur_dtype->dtype_pcyl = get_pcyl(ncyl, cur_dtype->dtype_acyl);
		cur_dtype->dtype_bpt = get_bpt(cur_dtype->dtype_nsect,
		    &cur_dtype->dtype_options);
		cur_dtype->dtype_rpm = get_rpm();
		cur_dtype->dtype_fmt_time =
		    get_fmt_time(&cur_dtype->dtype_options);
		cur_dtype->dtype_cyl_skew =
		    get_cyl_skew(&cur_dtype->dtype_options);
		cur_dtype->dtype_trk_skew =
		    get_trk_skew(&cur_dtype->dtype_options);
		cur_dtype->dtype_trks_zone =
		    get_trks_zone(&cur_dtype->dtype_options);
		cur_dtype->dtype_atrks = get_atrks(&cur_dtype->dtype_options);
		cur_dtype->dtype_asect = get_asect(&cur_dtype->dtype_options);
		cur_dtype->dtype_cache = get_cache(&cur_dtype->dtype_options);
		cur_dtype->dtype_threshold =
		    get_threshold(&cur_dtype->dtype_options);
		cur_dtype->dtype_prefetch_min =
		    get_min_prefetch(&cur_dtype->dtype_options);
		cur_dtype->dtype_prefetch_max =
		    get_max_prefetch(cur_dtype->dtype_prefetch_min,
		    &cur_dtype->dtype_options);
		cur_dtype->dtype_phead =
		    get_phead(nhead, &cur_dtype->dtype_options);
		cur_dtype->dtype_psect = get_psect(&cur_dtype->dtype_options);
		cur_dtype->dtype_bps = get_bps();
#ifdef sparc
		cur_dtype->dtype_dr_type = 0;
#endif
	}
}



/* ============================================================================
 * SOURCE 42/98: minix4\exokernel\kernel_legacy\cmd\genmsg\main.c
 * Size: 9,489 bytes, Lines: 409
 * Hash: 45c2270e3aee...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

#include <stdio.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include <libgen.h>
#include <libintl.h>
#include <locale.h>
#include <unistd.h>
#include <sys/param.h>

#include "genmsg.h"

#define	MSG_SUFFIX	".msg"
#define	NEW_SUFFIX	".new"

#if !defined(TEXT_DOMAIN)
#define	TEXT_DOMAIN	"genmsg"
#endif

/*
 * External functions.
 */
extern void write_msgfile(char *);	/* from util.c */
extern int read_projfile(char *);	/* from util.c */
extern void write_projfile(char *);	/* from util.c */
extern void read_msgfile(char *);	/* from util.c */
extern int is_writable(char *);		/* from util.c */
extern int file_copy(char *, char *);	/* from util.c */
extern void init_lex(void);		/* from genmsg.l */
extern void init_linemsgid(void);	/* from genmsg.l */
extern FILE *yyin;			/* from lex */
extern int yyparse(void);		/* from genmsg.l */

/* Program name. */
char *program;

/* File pointer for auto-message-numbering. */
FILE *newfp = NULL;

/* Input source file. */
char *srcfile;

/* Tag for message comments. */
char *mctag = NULL;

/* Tag for set number comments. */
char *sctag = NULL;

/* Mode mask to define the genmsg tasks. */
Mode active_mode = NoMode;

/*
 * This flag will be TRUE if a catgets() call is found
 * in the input file.
 */
int is_cat_found = FALSE;

/* Suppress an error message if this flag is TRUE. */
int suppress_error = FALSE;

/* Prefix and suffix of messages for testing. */
char *premsg = NULL;
char *sufmsg = NULL;

static void usage(void);
static void validate_options(void);

int
main(int argc, char **argv)
{
	int c;
	char *msgfile = NULL;
	char *projfile = NULL;
	char *newprojfile = NULL;
	char *cpppath = NULL;
	int do_msgfile = FALSE;
	int tmpfd = -1;
	char	*cmd, *tmp;
	char	tmpfile[32];
	size_t	len;

	program = basename(argv[0]);

	(void) setlocale(LC_ALL, "");
	(void) textdomain(TEXT_DOMAIN);

	while ((c = getopt(argc, argv, "arndfg:o:l:p:c:s:m:M:txb")) != EOF) {
		switch (c) {
		case 'o':
			SetActiveMode(MessageMode);
			msgfile = optarg;
			break;
		case 'a':
			SetActiveMode(AppendMode);
			break;
		case 'l':
			projfile = optarg;
			SetActiveMode(AutoNumMode);
			break;
		case 'r':
			SetActiveMode(ReverseMode);
			break;
		case 'p':
			cpppath = optarg;
			SetActiveMode(PreProcessMode);
			break;
		case 'g':
			newprojfile = optarg;
			suppress_error = TRUE;
			SetActiveMode(ProjectMode);
			break;
		case 'c':
			mctag = optarg;
			SetActiveMode(MsgCommentMode);
			break;
		case 's':
			sctag = optarg;
			SetActiveMode(SetCommentMode);
			break;
		case 'b':
			SetActiveMode(BackCommentMode);
			break;
		case 'n':
			SetActiveMode(LineInfoMode);
			break;
		case 'm':
			premsg = optarg;
			SetActiveMode(PrefixMode);
			break;
		case 'M':
			sufmsg = optarg;
			SetActiveMode(SuffixMode);
			break;
		case 't':
			SetActiveMode(TripleMode);
			break;
		case 'd':
			SetActiveMode(DoubleLineMode);
			break;
		case 'f':
			SetActiveMode(OverwriteMode);
			break;
		case 'x':
			suppress_error = TRUE;
			SetActiveMode(NoErrorMode);
			break;
		default:
			usage();
			break;
		}
	}

	if (optind >= argc) {
		usage();
	}

	validate_options();

	if (IsActiveMode(AutoNumMode)) {
		if (read_projfile(projfile)) {
			tmp = basename(projfile);
			len = strlen(tmp) + sizeof (NEW_SUFFIX);
			if ((newprojfile = malloc(len)) == NULL) {
				prg_err(gettext("fatal: out of memory"));
				exit(EXIT_FAILURE);
			}
			(void) snprintf(newprojfile, len, "%s%s",
			    tmp, NEW_SUFFIX);
		} else {
			newprojfile = basename(projfile);
		}
	}

	if ((IsActiveMode(AutoNumMode) || IsActiveMode(ProjectMode)) &&
	    (is_writable(IsActiveMode(OverwriteMode) ?
	    projfile : newprojfile) == FALSE)) {
		prg_err(gettext("cannot write \"%s\": permission denied"),
		    IsActiveMode(OverwriteMode) ? projfile : newprojfile);
		exit(EXIT_FAILURE);
	}

	if (IsActiveMode(AppendMode) && msgfile != NULL) {
		read_msgfile(msgfile);
	}

	if (msgfile == NULL) {
		tmp = basename(argv[optind]);
		len = strlen(tmp) + sizeof (MSG_SUFFIX);
		if ((msgfile = malloc(len)) == NULL) {
			prg_err(gettext("fatal: out of memory"));
			exit(EXIT_FAILURE);
		}
		(void) snprintf(msgfile, len, "%s%s", tmp, MSG_SUFFIX);
	}

	while (optind < argc) {
		is_cat_found = FALSE;
		srcfile = argv[optind];

		if (IsActiveMode(AutoNumMode) || IsActiveMode(ReverseMode)) {
			init_linemsgid();
		}

		if (IsActiveMode(PreProcessMode)) {
			len = strlen(cpppath) + 1 + strlen(srcfile) + 1;
			if ((cmd = malloc(len)) == NULL) {
				prg_err(gettext("fatal: out of memory"));
				exit(EXIT_FAILURE);
			}
			(void) snprintf(cmd, len, "%s %s", cpppath, srcfile);
			if ((yyin = popen(cmd, "r")) == NULL) {
				prg_err(
				    gettext("fatal: cannot execute \"%s\""),
				    cpppath);
				exit(EXIT_FAILURE);
			}
			free(cmd);
		} else {
			if ((yyin = fopen(srcfile, "r")) == NULL) {
				prg_err(
				    gettext("cannot open \"%s\""), srcfile);
				goto end;
			}
		}

		init_lex();
		(void) yyparse();

		if (IsActiveMode(PreProcessMode)) {
			if (pclose(yyin) != 0) {
				prg_err(gettext("\"%s\" failed for \"%s\""),
				    cpppath, srcfile);
				goto end;
			}
		}

		if (is_cat_found == FALSE) {
			if (!IsActiveMode(PreProcessMode)) {
				(void) fclose(yyin);
			}
			goto end;
		}

		if (do_msgfile == FALSE) {
			do_msgfile = TRUE;
		}

		if (IsActiveMode(AutoNumMode) || IsActiveMode(ReverseMode)) {
			char	*newfile;

			tmp = basename(srcfile);

			if (IsActiveMode(OverwriteMode)) {
				newfile = srcfile;
			} else {
				len = strlen(tmp) + sizeof (NEW_SUFFIX);
				if ((newfile = malloc(len)) == NULL) {
					prg_err(
					    gettext("fatal: out of memory"));
					exit(EXIT_FAILURE);
				}
				(void) snprintf(newfile, len, "%s%s",
				    tmp, NEW_SUFFIX);
			}

			if (is_writable(newfile) == FALSE) {
				prg_err(gettext(
			"cannot create \"%s\": permission denied"), newfile);
				goto end;
			}

			(void) strlcpy(tmpfile, "/tmp/gensmg.XXXXXX",
			    sizeof (tmpfile));

			if ((tmpfd = mkstemp(tmpfile)) == -1) {
				prg_err(gettext(
			"cannot create \"%s\""), tmpfile);
				if (!IsActiveMode(PreProcessMode)) {
					(void) fclose(yyin);
				}
				goto end;
			}
			if ((newfp = fdopen(tmpfd, "w")) == NULL) {
				prg_err(gettext(
			"cannot create \"%s\""), tmpfile);
				if (!IsActiveMode(PreProcessMode)) {
					(void) fclose(yyin);
				}
				(void) close(tmpfd);
				(void) unlink(tmpfile);
				goto end;
			}

			if (IsActiveMode(PreProcessMode)) {
				if ((yyin = fopen(srcfile, "r")) == NULL) {
					prg_err(gettext(
			"cannot open \"%s\""), srcfile);
					(void) fclose(newfp);
					(void) unlink(tmpfile);
					goto end;
				}
			} else {
				rewind(yyin);
			}

			SetActiveMode(ReplaceMode);
			init_lex();
			(void) yyparse();
			ResetActiveMode(ReplaceMode);

			(void) fclose(newfp);
			newfp = NULL;

			(void) fclose(yyin);

			(void) file_copy(tmpfile, newfile);

			(void) unlink(tmpfile);

			goto end;
		}

		if (!IsActiveMode(PreProcessMode)) {
			(void) fclose(yyin);
		}

end:
		optind++;
	}

	if (!do_msgfile) { /* no more business. */
		return (EXIT_SUCCESS);
	}

	if (!IsActiveMode(ReverseMode) && !IsActiveMode(ProjectMode)) {
		write_msgfile(msgfile);
	}

	if (IsActiveMode(AutoNumMode) || IsActiveMode(ProjectMode)) {
		write_projfile(IsActiveMode(OverwriteMode) ?
		    projfile : newprojfile);
	}
	return (EXIT_SUCCESS);
}

static void
validate_options(void)
{
	/* -r doesn't work with either -a or -l. */
	if (IsActiveMode(ReverseMode) &&
	    (IsActiveMode(AutoNumMode) || IsActiveMode(AppendMode))) {
		usage();
	}
	/* -b should be accompanied with -c, -s, -d, and -n. */
	if (IsActiveMode(BackCommentMode) &&
	    (!IsActiveMode(MsgCommentMode) &&
	    !IsActiveMode(SetCommentMode) &&
	    !IsActiveMode(DoubleLineMode) &&
	    !IsActiveMode(LineInfoMode))) {
		usage();
	}
	if (IsActiveMode(ProjectMode) &&
	    (IsActiveMode(AutoNumMode) || IsActiveMode(ReverseMode) ||
	    IsActiveMode(AppendMode) || IsActiveMode(MsgCommentMode) ||
	    IsActiveMode(LineInfoMode) || IsActiveMode(OverwriteMode) ||
	    IsActiveMode(PrefixMode) || IsActiveMode(SuffixMode) ||
	    IsActiveMode(TripleMode) || IsActiveMode(DoubleLineMode) ||
	    IsActiveMode(MessageMode) || IsActiveMode(NoErrorMode))) {
		usage();
	}
}

static void
usage(void)
{
	(void) fprintf(stderr, gettext(
	    "Usage: %s [-o message-file] [-a] [-d] [-p preprocessor]\n"
	    "          [-s set-tag] [-c message-tag] [-b] [-n]\n"
	    "          [-l project-file] [-r] [-f] [-g project-file]\n"
	    "          [-m prefix] [-M suffix] [-t] [-x] files ...\n"),
	    program);
	exit(EXIT_FAILURE);
}



/* ============================================================================
 * SOURCE 43/98: minix4\exokernel\kernel_legacy\cmd\lofiadm\main.c
 * Size: 57,197 bytes, Lines: 2,183
 * Hash: 4a30b053c142...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 * Copyright 2012 Joyent, Inc.  All rights reserved.
 *
 * Copyright 2013 Nexenta Systems, Inc. All rights reserved.
 * Copyright (c) 2014 Gary Mills
 * Copyright (c) 2016 Andrey Sokolov
 */

/*
 * lofiadm - administer lofi(4D). Very simple, add and remove file<->device
 * associations, and display status. All the ioctls are private between
 * lofi and lofiadm, and so are very simple - device information is
 * communicated via a minor number.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/lofi.h>
#include <sys/stat.h>
#include <sys/sysmacros.h>
#include <sys/modctl.h>
#include <netinet/in.h>
#include <stdio.h>
#include <fcntl.h>
#include <locale.h>
#include <string.h>
#include <strings.h>
#include <errno.h>
#include <stdlib.h>
#include <unistd.h>
#include <stropts.h>
#include <libdevinfo.h>
#include <libgen.h>
#include <ctype.h>
#include <dlfcn.h>
#include <limits.h>
#include <security/cryptoki.h>
#include <cryptoutil.h>
#include <sys/crypto/ioctl.h>
#include <sys/crypto/ioctladmin.h>
#include <sys/cmlb.h>
#include <sys/mkdev.h>
#include "utils.h"
#include <LzmaEnc.h>

/* Only need the IV len #defines out of these files, nothing else. */
#include <aes/aes_impl.h>
#include <des/des_impl.h>
#include <blowfish/blowfish_impl.h>

static const char USAGE[] =
	"Usage: %s [-r] [-l] -a file [ device ]\n"
	"       %s [-r] -c crypto_algorithm -a file [device]\n"
	"       %s [-r] -c crypto_algorithm -k raw_key_file -a file [device]\n"
	"       %s [-r] -c crypto_algorithm -T [token]:[manuf]:[serial]:key "
	"-a file [device]\n"
	"       %s [-r] -c crypto_algorithm -T [token]:[manuf]:[serial]:key "
	"-k wrapped_key_file -a file [device]\n"
	"       %s [-r] -c crypto_algorithm -e -a file [device]\n"
	"       %s -d file | device\n"
	"       %s -C [gzip|gzip-6|gzip-9|lzma] [-s segment_size] file\n"
	"       %s -U file\n"
	"       %s [ file | device ]\n";

typedef struct token_spec {
	char	*name;
	char	*mfr;
	char	*serno;
	char	*key;
} token_spec_t;

typedef struct mech_alias {
	char	*alias;
	CK_MECHANISM_TYPE type;
	char	*name;		/* for ioctl */
	char	*iv_name;	/* for ioctl */
	size_t	iv_len;		/* for ioctl */
	iv_method_t iv_type;	/* for ioctl */
	size_t	min_keysize;	/* in bytes */
	size_t	max_keysize;	/* in bytes */
	token_spec_t *token;
	CK_SLOT_ID slot;
} mech_alias_t;

static mech_alias_t mech_aliases[] = {
	/* Preferred one should always be listed first. */
	{ "aes-256-cbc", CKM_AES_CBC, "CKM_AES_CBC", "CKM_AES_ECB", AES_IV_LEN,
	    IVM_ENC_BLKNO, ULONG_MAX, 0L, NULL, (CK_SLOT_ID) -1 },
	{ "aes-192-cbc", CKM_AES_CBC, "CKM_AES_CBC", "CKM_AES_ECB", AES_IV_LEN,
	    IVM_ENC_BLKNO, ULONG_MAX, 0L, NULL, (CK_SLOT_ID) -1 },
	{ "aes-128-cbc", CKM_AES_CBC, "CKM_AES_CBC", "CKM_AES_ECB", AES_IV_LEN,
	    IVM_ENC_BLKNO, ULONG_MAX, 0L, NULL, (CK_SLOT_ID) -1 },
	{ "des3-cbc", CKM_DES3_CBC, "CKM_DES3_CBC", "CKM_DES3_ECB", DES_IV_LEN,
	    IVM_ENC_BLKNO, ULONG_MAX, 0L, NULL, (CK_SLOT_ID)-1 },
	{ "blowfish-cbc", CKM_BLOWFISH_CBC, "CKM_BLOWFISH_CBC",
	    "CKM_BLOWFISH_ECB", BLOWFISH_IV_LEN, IVM_ENC_BLKNO, ULONG_MAX,
	    0L, NULL, (CK_SLOT_ID)-1 }
	/*
	 * A cipher without an iv requirement would look like this:
	 * { "aes-xex", CKM_AES_XEX, "CKM_AES_XEX", NULL, 0,
	 *    IVM_NONE, ULONG_MAX, 0L, NULL, (CK_SLOT_ID)-1 }
	 */
};

int	mech_aliases_count = (sizeof (mech_aliases) / sizeof (mech_alias_t));

/* Preferred cipher, if one isn't specified on command line. */
#define	DEFAULT_CIPHER	(&mech_aliases[0])

#define	DEFAULT_CIPHER_NUM	64	/* guess # kernel ciphers available */
#define	DEFAULT_MECHINFO_NUM	16	/* guess # kernel mechs available */
#define	MIN_PASSLEN		8	/* min acceptable passphrase size */

static int gzip_compress(void *src, size_t srclen, void *dst,
	size_t *destlen, int level);
static int lzma_compress(void *src, size_t srclen, void *dst,
	size_t *destlen, int level);

lofi_compress_info_t lofi_compress_table[LOFI_COMPRESS_FUNCTIONS] = {
	{NULL,  		gzip_compress,  6,	"gzip"}, /* default */
	{NULL,			gzip_compress,	6,	"gzip-6"},
	{NULL,			gzip_compress,	9, 	"gzip-9"},
	{NULL,  		lzma_compress, 	0, 	"lzma"}
};

/* For displaying lofi mappings */
#define	FORMAT 			"%-20s     %-30s	%s\n"

#define	COMPRESS_ALGORITHM	"gzip"
#define	COMPRESS_THRESHOLD	2048
#define	SEGSIZE			131072
#define	BLOCK_SIZE		512
#define	KILOBYTE		1024
#define	MEGABYTE		(KILOBYTE * KILOBYTE)
#define	GIGABYTE		(KILOBYTE * MEGABYTE)
#define	LIBZ			"libz.so.1"

const char lofi_crypto_magic[6] = LOFI_CRYPTO_MAGIC;

static void
usage(const char *pname)
{
	(void) fprintf(stderr, gettext(USAGE), pname, pname, pname,
	    pname, pname, pname, pname, pname, pname, pname);
	exit(E_USAGE);
}

static int
gzip_compress(void *src, size_t srclen, void *dst, size_t *dstlen, int level)
{
	static int (*compress2p)(void *, ulong_t *, void *, size_t, int) = NULL;
	void *libz_hdl = NULL;

	/*
	 * The first time we are called, attempt to dlopen()
	 * libz.so.1 and get a pointer to the compress2() function
	 */
	if (compress2p == NULL) {
		if ((libz_hdl = openlib(LIBZ)) == NULL)
			die(gettext("could not find %s. "
			    "gzip compression unavailable\n"), LIBZ);

		if ((compress2p =
		    (int (*)(void *, ulong_t *, void *, size_t, int))
		    dlsym(libz_hdl, "compress2")) == NULL) {
			closelib();
			die(gettext("could not find the correct %s. "
			    "gzip compression unavailable\n"), LIBZ);
		}
	}

	if ((*compress2p)(dst, (ulong_t *)dstlen, src, srclen, level) != 0)
		return (-1);
	return (0);
}

/*ARGSUSED*/
static void
*SzAlloc(void *p, size_t size)
{
	return (malloc(size));
}

/*ARGSUSED*/
static void
SzFree(void *p, void *address, size_t size)
{
	free(address);
}

static ISzAlloc g_Alloc = {
	SzAlloc,
	SzFree
};

#define	LZMA_UNCOMPRESSED_SIZE	8
#define	LZMA_HEADER_SIZE (LZMA_PROPS_SIZE + LZMA_UNCOMPRESSED_SIZE)

/*ARGSUSED*/
static int
lzma_compress(void *src, size_t srclen, void *dst,
    size_t *dstlen, int level)
{
	CLzmaEncProps props;
	size_t outsize2;
	size_t outsizeprocessed;
	size_t outpropssize = LZMA_PROPS_SIZE;
	uint64_t t = 0;
	SRes res;
	Byte *dstp;
	int i;

	outsize2 = *dstlen;

	LzmaEncProps_Init(&props);

	/*
	 * The LZMA compressed file format is as follows -
	 *
	 * Offset Size(bytes) Description
	 * 0		1	LZMA properties (lc, lp, lp (encoded))
	 * 1		4	Dictionary size (little endian)
	 * 5		8	Uncompressed size (little endian)
	 * 13			Compressed data
	 */

	/* set the dictionary size to be 8MB */
	props.dictSize = 1 << 23;

	if (*dstlen < LZMA_HEADER_SIZE)
		return (SZ_ERROR_OUTPUT_EOF);

	dstp = (Byte *)dst;
	t = srclen;
	/*
	 * Set the uncompressed size in the LZMA header
	 * The LZMA properties (specified in 'props')
	 * will be set by the call to LzmaEncode()
	 */
	for (i = 0; i < LZMA_UNCOMPRESSED_SIZE; i++, t >>= 8) {
		dstp[LZMA_PROPS_SIZE + i] = (Byte)t;
	}

	outsizeprocessed = outsize2 - LZMA_HEADER_SIZE;
	res = LzmaEncode(dstp + LZMA_HEADER_SIZE, &outsizeprocessed,
	    src, srclen, &props, dstp, &outpropssize, 0, NULL,
	    &g_Alloc, &g_Alloc);

	if (res != 0)
		return (-1);

	*dstlen = outsizeprocessed + LZMA_HEADER_SIZE;
	return (0);
}

/*
 * Translate a lofi device name to a minor number. We might be asked
 * to do this when there is no association (such as when the user specifies
 * a particular device), so we can only look at the string.
 */
static int
name_to_minor(const char *devicename)
{
	struct stat st;

	/*
	 * If devicename does not exist, then devicename contains
	 * the name of the device to be created.
	 * Note we only allow non-labeled devices here.
	 */
	if (stat(devicename, &st)) {
		int minor, rv;

		rv = sscanf(devicename, "/dev/" LOFI_BLOCK_NAME "/%d", &minor);
		if (rv == 1)
			return (minor);
		rv = sscanf(devicename, "/dev/" LOFI_CHAR_NAME "/%d", &minor);
		if (rv == 1)
			return (minor);

		return (0);
	}

	/*
	 * For disk devices we use modctl(MODGETNAME) to read driver name
	 * for major device.
	 */
	if (st.st_mode & S_IFCHR || st.st_mode & S_IFBLK) {
		major_t maj;
		char mname[MODMAXNAMELEN];

		maj = major(st.st_rdev);

		if (modctl(MODGETNAME, mname,  MODMAXNAMELEN, &maj) == 0) {
			if (strncmp(mname, LOFI_DRIVER_NAME,
			    sizeof (LOFI_DRIVER_NAME)) == 0) {
				return (LOFI_MINOR2ID(minor(st.st_rdev)));
			}
		}
	}

	return (0);
}

/*
 * This might be the first time we've used this minor number. If so,
 * it might also be that the /dev links are in the process of being created
 * by devfsadmd (or that they'll be created "soon"). We cannot return
 * until they're there or the invoker of lofiadm might try to use them
 * and not find them. This can happen if a shell script is running on
 * an MP.
 */
static int sleeptime = 2;	/* number of seconds to sleep between stat's */
static int maxsleep = 120;	/* maximum number of seconds to sleep */

static void
make_blkdevname(struct lofi_ioctl *li, char *path, size_t len)
{
	char *r1, *r2;
	size_t l1;

	if (li->li_devpath[0] == '\0') {
		if (li->li_labeled)
			(void) strlcpy(path, "unknown", len);
		else
			(void) snprintf(path, len,
			    "/dev/" LOFI_BLOCK_NAME "/%d", li->li_id);
		return;
	}
	(void) strlcpy(path, li->li_devpath, len);
	r1 = strchr(path, 'r');
	l1 = r1 - path;
	r2 = strchr(li->li_devpath, 'r');
	(void) strlcpy(r1, r2+1, len - l1);

	if (li->li_labeled) {
		(void) strlcat(path, "p0", len);
	}
}

static void
wait_until_dev_complete(struct lofi_ioctl *li)
{
	struct stat64 buf;
	int	cursleep;
	char	blkpath[MAXPATHLEN];
	char	charpath[MAXPATHLEN];
	di_devlink_handle_t hdl;

	make_blkdevname(li, blkpath, sizeof (blkpath));
	(void) strlcpy(charpath, li->li_devpath, sizeof (charpath));

	if (li->li_labeled) {
		(void) strlcat(charpath, "p0", sizeof (charpath));
	}

	/* Check if links already present */
	if (stat64(blkpath, &buf) == 0 && stat64(charpath, &buf) == 0)
		return;

	/* First use di_devlink_init() */
	if (hdl = di_devlink_init("lofi", DI_MAKE_LINK)) {
		(void) di_devlink_fini(&hdl);
		goto out;
	}

	/*
	 * Under normal conditions, di_devlink_init(DI_MAKE_LINK) above will
	 * only fail if the caller is non-root. In that case, wait for
	 * link creation via sysevents.
	 */
	for (cursleep = 0; cursleep < maxsleep; cursleep += sleeptime) {
		if (stat64(blkpath, &buf) == 0 && stat64(charpath, &buf) == 0)
			return;
		(void) sleep(sleeptime);
	}

	/* one last try */
out:
	if (stat64(blkpath, &buf) == -1) {
		die(gettext("%s was not created"), blkpath);
	}
	if (stat64(charpath, &buf) == -1) {
		die(gettext("%s was not created"), charpath);
	}
}

/*
 * Map the file and return the minor number the driver picked for the file
 * DO NOT use this function if the filename is actually the device name.
 */
static int
lofi_map_file(int lfd, struct lofi_ioctl *li, const char *filename)
{
	int	minor;

	li->li_id = 0;
	(void) strlcpy(li->li_filename, filename, sizeof (li->li_filename));
	minor = ioctl(lfd, LOFI_MAP_FILE, li);
	if (minor == -1) {
		if (errno == ENOTSUP)
			warn(gettext("encrypting compressed files is "
			    "unsupported"));
		die(gettext("could not map file %s"), filename);
	}
	wait_until_dev_complete(li);
	return (minor);
}

/*
 * Add a device association. If devicename is NULL, let the driver
 * pick a device.
 */
static void
add_mapping(int lfd, const char *devicename, const char *filename,
    mech_alias_t *cipher, const char *rkey, size_t rksz, boolean_t rdonly,
    boolean_t label)
{
	struct lofi_ioctl li;

	bzero(&li, sizeof (li));
	li.li_readonly = rdonly;
	li.li_labeled = label;

	li.li_crypto_enabled = B_FALSE;
	if (cipher != NULL) {
		/* set up encryption for mapped file */
		li.li_crypto_enabled = B_TRUE;
		(void) strlcpy(li.li_cipher, cipher->name,
		    sizeof (li.li_cipher));
		if (rksz > sizeof (li.li_key)) {
			die(gettext("key too large"));
		}
		bcopy(rkey, li.li_key, rksz);
		li.li_key_len = rksz << 3;	/* convert to bits */

		li.li_iv_type = cipher->iv_type;
		li.li_iv_len = cipher->iv_len;	/* 0 when no iv needed */
		switch (cipher->iv_type) {
		case IVM_ENC_BLKNO:
			(void) strlcpy(li.li_iv_cipher, cipher->iv_name,
			    sizeof (li.li_iv_cipher));
			break;
		case IVM_NONE:
			/* FALLTHROUGH */
		default:
			break;
		}
	}

	if (devicename == NULL) {
		int	minor;
		char	path[MAXPATHLEN];

		/* pick one via the driver */
		minor = lofi_map_file(lfd, &li, filename);
		if (minor > 0) {
			make_blkdevname(&li, path, sizeof (path));

			/* if mapping succeeds, print the one picked */
			(void) printf("%s\n", path);
		}
		return;
	}

	/* use device we were given */
	li.li_id = name_to_minor(devicename);
	if (li.li_id == 0) {
		die(gettext("malformed device name %s\n"), devicename);
	}
	(void) strlcpy(li.li_filename, filename, sizeof (li.li_filename));

	/* if device is already in use li.li_minor won't change */
	if (ioctl(lfd, LOFI_MAP_FILE_MINOR, &li) == -1) {
		if (errno == ENOTSUP)
			warn(gettext("encrypting compressed files is "
			    "unsupported"));
		die(gettext("could not map file %s to %s"), filename,
		    devicename);
	}
	wait_until_dev_complete(&li);
}

/*
 * Remove an association. Delete by device name if non-NULL, or by
 * filename otherwise.
 */
static void
delete_mapping(int lfd, const char *devicename, const char *filename,
    boolean_t force)
{
	struct lofi_ioctl li;

	li.li_force = force;
	li.li_cleanup = B_FALSE;

	if (devicename == NULL) {
		/* delete by filename */
		(void) strlcpy(li.li_filename, filename,
		    sizeof (li.li_filename));
		li.li_id = 0;
		if (ioctl(lfd, LOFI_UNMAP_FILE, &li) == -1) {
			die(gettext("could not unmap file %s"), filename);
		}
		return;
	}

	/* delete by device */
	li.li_id = name_to_minor(devicename);
	if (li.li_id == 0) {
		die(gettext("malformed device name %s\n"), devicename);
	}
	if (ioctl(lfd, LOFI_UNMAP_FILE_MINOR, &li) == -1) {
		die(gettext("could not unmap device %s"), devicename);
	}
}

/*
 * Show filename given devicename, or devicename given filename.
 */
static void
print_one_mapping(int lfd, const char *devicename, const char *filename)
{
	struct lofi_ioctl li;
	char blkpath[MAXPATHLEN];

	if (devicename == NULL) {
		/* given filename, print devicename */
		li.li_id = 0;
		(void) strlcpy(li.li_filename, filename,
		    sizeof (li.li_filename));
		if (ioctl(lfd, LOFI_GET_MINOR, &li) == -1) {
			die(gettext("could not find device for %s"), filename);
		}
		make_blkdevname(&li, blkpath, sizeof (blkpath));
		(void) printf("%s\n", blkpath);
		return;
	}

	/* given devicename, print filename */
	li.li_id = name_to_minor(devicename);
	if (li.li_id == 0) {
		die(gettext("malformed device name %s\n"), devicename);
	}
	if (ioctl(lfd, LOFI_GET_FILENAME, &li) == -1) {
		die(gettext("could not find filename for %s"), devicename);
	}
	(void) printf("%s\n", li.li_filename);
}

/*
 * Print the list of all the mappings, including a header.
 */
static void
print_mappings(int fd)
{
	struct lofi_ioctl li;
	int	minor;
	int	maxminor;
	char	path[MAXPATHLEN];
	char	options[MAXPATHLEN] = { 0 };

	li.li_id = 0;
	if (ioctl(fd, LOFI_GET_MAXMINOR, &li) == -1) {
		die("ioctl");
	}
	maxminor = li.li_id;

	(void) printf(FORMAT, gettext("Block Device"), gettext("File"),
	    gettext("Options"));
	for (minor = 1; minor <= maxminor; minor++) {
		li.li_id = minor;
		if (ioctl(fd, LOFI_GET_FILENAME, &li) == -1) {
			if (errno == ENXIO)
				continue;
			warn("ioctl");
			break;
		}
		make_blkdevname(&li, path, sizeof (path));

		options[0] = '\0';

		/*
		 * Encrypted lofi and compressed lofi are mutually exclusive.
		 */
		if (li.li_crypto_enabled)
			(void) snprintf(options, sizeof (options),
			    gettext("Encrypted"));
		else if (li.li_algorithm[0] != '\0')
			(void) snprintf(options, sizeof (options),
			    gettext("Compressed(%s)"), li.li_algorithm);
		if (li.li_readonly) {
			if (strlen(options) != 0) {
				(void) strlcat(options, ",Readonly",
				    sizeof (options));
			} else {
				(void) snprintf(options, sizeof (options),
				    gettext("Readonly"));
			}
		}
		if (li.li_labeled) {
			if (strlen(options) != 0) {
				(void) strlcat(options, ",Labeled",
				    sizeof (options));
			} else {
				(void) snprintf(options, sizeof (options),
				    gettext("Labeled"));
			}
		}
		if (strlen(options) == 0)
			(void) snprintf(options, sizeof (options), "-");

		(void) printf(FORMAT, path, li.li_filename, options);
	}
}

/*
 * Verify the cipher selected by user.
 */
static mech_alias_t *
ciph2mech(const char *alias)
{
	int	i;

	for (i = 0; i < mech_aliases_count; i++) {
		if (strcasecmp(alias, mech_aliases[i].alias) == 0)
			return (&mech_aliases[i]);
	}
	return (NULL);
}

/*
 * Verify user selected cipher is also available in kernel.
 *
 * While traversing kernel list of mechs, if the cipher is supported in the
 * kernel for both encryption and decryption, it also picks up the min/max
 * key size.
 */
static boolean_t
kernel_cipher_check(mech_alias_t *cipher)
{
	boolean_t ciph_ok = B_FALSE;
	boolean_t iv_ok = B_FALSE;
	int	i;
	int	count;
	crypto_get_mechanism_list_t *kciphers = NULL;
	crypto_get_all_mechanism_info_t *kinfo = NULL;
	int	fd = -1;
	size_t	keymin;
	size_t	keymax;

	/* if cipher doesn't need iv generating mech, bypass that check now */
	if (cipher->iv_name == NULL)
		iv_ok = B_TRUE;

	/* allocate some space for the list of kernel ciphers */
	count = DEFAULT_CIPHER_NUM;
	kciphers = malloc(sizeof (crypto_get_mechanism_list_t) +
	    sizeof (crypto_mech_name_t) * (count - 1));
	if (kciphers == NULL)
		die(gettext("failed to allocate memory for list of "
		    "kernel mechanisms"));
	kciphers->ml_count = count;

	/* query crypto device to get list of kernel ciphers */
	if ((fd = open("/dev/crypto", O_RDWR)) == -1) {
		warn(gettext("failed to open %s"), "/dev/crypto");
		goto kcc_out;
	}

	if (ioctl(fd, CRYPTO_GET_MECHANISM_LIST, kciphers) == -1) {
		warn(gettext("CRYPTO_GET_MECHANISM_LIST ioctl failed"));
		goto kcc_out;
	}

	if (kciphers->ml_return_value == CRYPTO_BUFFER_TOO_SMALL) {
		count = kciphers->ml_count;
		free(kciphers);
		kciphers = malloc(sizeof (crypto_get_mechanism_list_t) +
		    sizeof (crypto_mech_name_t) * (count - 1));
		if (kciphers == NULL) {
			warn(gettext("failed to allocate memory for list of "
			    "kernel mechanisms"));
			goto kcc_out;
		}
		kciphers->ml_count = count;

		if (ioctl(fd, CRYPTO_GET_MECHANISM_LIST, kciphers) == -1) {
			warn(gettext("CRYPTO_GET_MECHANISM_LIST ioctl failed"));
			goto kcc_out;
		}
	}

	if (kciphers->ml_return_value != CRYPTO_SUCCESS) {
		warn(gettext(
		    "CRYPTO_GET_MECHANISM_LIST ioctl return value = %d\n"),
		    kciphers->ml_return_value);
		goto kcc_out;
	}

	/*
	 * scan list of kernel ciphers looking for the selected one and if
	 * it needs an iv generated using another cipher, also look for that
	 * additional cipher to be used for generating the iv
	 */
	count = kciphers->ml_count;
	for (i = 0; i < count && !(ciph_ok && iv_ok); i++) {
		if (!ciph_ok &&
		    strcasecmp(cipher->name, kciphers->ml_list[i]) == 0)
			ciph_ok = B_TRUE;
		if (!iv_ok &&
		    strcasecmp(cipher->iv_name, kciphers->ml_list[i]) == 0)
			iv_ok = B_TRUE;
	}
	free(kciphers);
	kciphers = NULL;

	if (!ciph_ok)
		warn(gettext("%s mechanism not supported in kernel\n"),
		    cipher->name);
	if (!iv_ok)
		warn(gettext("%s mechanism not supported in kernel\n"),
		    cipher->iv_name);

	if (ciph_ok) {
		/* Get the details about the user selected cipher */
		count = DEFAULT_MECHINFO_NUM;
		kinfo = malloc(sizeof (crypto_get_all_mechanism_info_t) +
		    sizeof (crypto_mechanism_info_t) * (count - 1));
		if (kinfo == NULL) {
			warn(gettext("failed to allocate memory for "
			    "kernel mechanism info"));
			goto kcc_out;
		}
		kinfo->mi_count = count;
		(void) strlcpy(kinfo->mi_mechanism_name, cipher->name,
		    CRYPTO_MAX_MECH_NAME);

		if (ioctl(fd, CRYPTO_GET_ALL_MECHANISM_INFO, kinfo) == -1) {
			warn(gettext(
			    "CRYPTO_GET_ALL_MECHANISM_INFO ioctl failed"));
			goto kcc_out;
		}

		if (kinfo->mi_return_value == CRYPTO_BUFFER_TOO_SMALL) {
			count = kinfo->mi_count;
			free(kinfo);
			kinfo = malloc(
			    sizeof (crypto_get_all_mechanism_info_t) +
			    sizeof (crypto_mechanism_info_t) * (count - 1));
			if (kinfo == NULL) {
				warn(gettext("failed to allocate memory for "
				    "kernel mechanism info"));
				goto kcc_out;
			}
			kinfo->mi_count = count;
			(void) strlcpy(kinfo->mi_mechanism_name, cipher->name,
			    CRYPTO_MAX_MECH_NAME);

			if (ioctl(fd, CRYPTO_GET_ALL_MECHANISM_INFO, kinfo) ==
			    -1) {
				warn(gettext("CRYPTO_GET_ALL_MECHANISM_INFO "
				    "ioctl failed"));
				goto kcc_out;
			}
		}

		if (kinfo->mi_return_value != CRYPTO_SUCCESS) {
			warn(gettext("CRYPTO_GET_ALL_MECHANISM_INFO ioctl "
			    "return value = %d\n"), kinfo->mi_return_value);
			goto kcc_out;
		}

		/* Set key min and max size */
		count = kinfo->mi_count;
		i = 0;
		if (i < count) {
			keymin = kinfo->mi_list[i].mi_min_key_size;
			keymax = kinfo->mi_list[i].mi_max_key_size;
			if (kinfo->mi_list[i].mi_keysize_unit &
			    CRYPTO_KEYSIZE_UNIT_IN_BITS) {
				keymin = CRYPTO_BITS2BYTES(keymin);
				keymax = CRYPTO_BITS2BYTES(keymax);

			}
			cipher->min_keysize = keymin;
			cipher->max_keysize = keymax;
		}
		free(kinfo);
		kinfo = NULL;

		if (i == count) {
			(void) close(fd);
			die(gettext(
			    "failed to find usable %s kernel mechanism, "
			    "use \"cryptoadm list -m\" to find available "
			    "mechanisms\n"),
			    cipher->name);
		}
	}

	/* Note: key min/max, unit size, usage for iv cipher are not checked. */

	return (ciph_ok && iv_ok);

kcc_out:
	if (kinfo != NULL)
		free(kinfo);
	if (kciphers != NULL)
		free(kciphers);
	if (fd != -1)
		(void) close(fd);
	return (B_FALSE);
}

/*
 * Break up token spec into its components (non-destructive)
 */
static token_spec_t *
parsetoken(char *spec)
{
#define	FLD_NAME	0
#define	FLD_MANUF	1
#define	FLD_SERIAL	2
#define	FLD_LABEL	3
#define	NFIELDS		4
#define	nullfield(i)	((field[(i)+1] - field[(i)]) <= 1)
#define	copyfield(fld, i)	\
		{							\
			int	n;					\
			(fld) = NULL;					\
			if ((n = (field[(i)+1] - field[(i)])) > 1) {	\
				if (((fld) = malloc(n)) != NULL) {	\
					(void) strncpy((fld), field[(i)], n); \
					((fld))[n - 1] = '\0';		\
				}					\
			}						\
		}

	int	i;
	char	*field[NFIELDS + 1];	/* +1 to catch extra delimiters */
	token_spec_t *ti = NULL;

	if (spec == NULL)
		return (NULL);

	/*
	 * Correct format is "[name]:[manuf]:[serial]:key". Can't use
	 * strtok because it treats ":::key" and "key:::" and "key" all
	 * as the same thing, and we can't have the :s compressed away.
	 */
	field[0] = spec;
	for (i = 1; i < NFIELDS + 1; i++) {
		field[i] = strchr(field[i-1], ':');
		if (field[i] == NULL)
			break;
		field[i]++;
	}
	if (i < NFIELDS)		/* not enough fields */
		return (NULL);
	if (field[NFIELDS] != NULL)	/* too many fields */
		return (NULL);
	field[NFIELDS] = strchr(field[NFIELDS-1], '\0') + 1;

	/* key label can't be empty */
	if (nullfield(FLD_LABEL))
		return (NULL);

	ti = malloc(sizeof (token_spec_t));
	if (ti == NULL)
		return (NULL);

	copyfield(ti->name, FLD_NAME);
	copyfield(ti->mfr, FLD_MANUF);
	copyfield(ti->serno, FLD_SERIAL);
	copyfield(ti->key, FLD_LABEL);

	/*
	 * If token specified and it only contains a key label, then
	 * search all tokens for the key, otherwise only those with
	 * matching name, mfr, and serno are used.
	 */
	/*
	 * That's how we'd like it to be, however, if only the key label
	 * is specified, default to using softtoken.  It's easier.
	 */
	if (ti->name == NULL && ti->mfr == NULL && ti->serno == NULL)
		ti->name = strdup(pkcs11_default_token());
	return (ti);
}

/*
 * PBE the passphrase into a raw key
 */
static void
getkeyfromuser(mech_alias_t *cipher, char **raw_key, size_t *raw_key_sz,
    boolean_t with_confirmation)
{
	CK_SESSION_HANDLE sess;
	CK_RV	rv;
	char	*pass = NULL;
	size_t	passlen = 0;
	void	*salt = NULL;	/* don't use NULL, see note on salt below */
	size_t	saltlen = 0;
	CK_KEY_TYPE ktype;
	void	*kvalue;
	size_t	klen;

	/* did init_crypto find a slot that supports this cipher? */
	if (cipher->slot == (CK_SLOT_ID)-1 || cipher->max_keysize == 0) {
		rv = CKR_MECHANISM_INVALID;
		goto cleanup;
	}

	rv = pkcs11_mech2keytype(cipher->type, &ktype);
	if (rv != CKR_OK)
		goto cleanup;

	/*
	 * use the passphrase to generate a PBE PKCS#5 secret key and
	 * retrieve the raw key data to eventually pass it to the kernel;
	 */
	rv = C_OpenSession(cipher->slot, CKF_SERIAL_SESSION, NULL, NULL, &sess);
	if (rv != CKR_OK)
		goto cleanup;

	/* get user passphrase with 8 byte minimum */
	if (pkcs11_get_pass(NULL, &pass, &passlen, MIN_PASSLEN,
	    with_confirmation) < 0) {
		die(gettext("passphrases do not match\n"));
	}

	/*
	 * salt should not be NULL, or else pkcs11_PasswdToKey() will
	 * complain about CKR_MECHANISM_PARAM_INVALID; the following is
	 * to make up for not having a salt until a proper one is used
	 */
	salt = pass;
	saltlen = passlen;

	klen = cipher->max_keysize;
	rv = pkcs11_PasswdToKey(sess, pass, passlen, salt, saltlen, ktype,
	    cipher->max_keysize, &kvalue, &klen);

	(void) C_CloseSession(sess);

	if (rv != CKR_OK) {
		goto cleanup;
	}

	/* assert(klen == cipher->max_keysize); */
	*raw_key_sz = klen;
	*raw_key = (char *)kvalue;
	return;

cleanup:
	die(gettext("failed to generate %s key from passphrase: %s"),
	    cipher->alias, pkcs11_strerror(rv));
}

/*
 * Read raw key from file; also handles ephemeral keys.
 */
void
getkeyfromfile(const char *pathname, mech_alias_t *cipher, char **key,
    size_t *ksz)
{
	int	fd;
	struct stat sbuf;
	boolean_t notplain = B_FALSE;
	ssize_t	cursz;
	ssize_t	nread;

	/* ephemeral keys are just random data */
	if (pathname == NULL) {
		*ksz = cipher->max_keysize;
		*key = malloc(*ksz);
		if (*key == NULL)
			die(gettext("failed to allocate memory for"
			    " ephemeral key"));
		if (pkcs11_get_urandom(*key, *ksz) < 0) {
			free(*key);
			die(gettext("failed to get enough random data"));
		}
		return;
	}

	/*
	 * If the remaining section of code didn't also check for secure keyfile
	 * permissions and whether the key is within cipher min and max lengths,
	 * (or, if those things moved out of this block), we could have had:
	 *	if (pkcs11_read_data(pathname, key, ksz) < 0)
	 *		handle_error();
	 */

	if ((fd = open(pathname, O_RDONLY, 0)) == -1)
		die(gettext("open of keyfile (%s) failed"), pathname);

	if (fstat(fd, &sbuf) == -1)
		die(gettext("fstat of keyfile (%s) failed"), pathname);

	if (S_ISREG(sbuf.st_mode)) {
		if ((sbuf.st_mode & (S_IWGRP | S_IWOTH)) != 0)
			die(gettext("insecure permissions on keyfile %s\n"),
			    pathname);

		*ksz = sbuf.st_size;
		if (*ksz < cipher->min_keysize || cipher->max_keysize < *ksz) {
			warn(gettext("%s: invalid keysize: %d\n"),
			    pathname, (int)*ksz);
			die(gettext("\t%d <= keysize <= %d\n"),
			    cipher->min_keysize, cipher->max_keysize);
		}
	} else {
		*ksz = cipher->max_keysize;
		notplain = B_TRUE;
	}

	*key = malloc(*ksz);
	if (*key == NULL)
		die(gettext("failed to allocate memory for key from file"));

	for (cursz = 0, nread = 0; cursz < *ksz; cursz += nread) {
		nread = read(fd, *key, *ksz);
		if (nread > 0)
			continue;
		/*
		 * nread == 0.  If it's not a regular file we were trying to
		 * get the maximum keysize of data possible for this cipher.
		 * But if we've got at least the minimum keysize of data,
		 * round down to the nearest keysize unit and call it good.
		 * If we haven't met the minimum keysize, that's an error.
		 * If it's a regular file, nread = 0 is also an error.
		 */
		if (nread == 0 && notplain && cursz >= cipher->min_keysize) {
			*ksz = (cursz / cipher->min_keysize) *
			    cipher->min_keysize;
			break;
		}
		die(gettext("%s: can't read all keybytes"), pathname);
	}
	(void) close(fd);
}

/*
 * Read the raw key from token, or from a file that was wrapped with a
 * key from token
 */
void
getkeyfromtoken(CK_SESSION_HANDLE sess,
    token_spec_t *token, const char *keyfile, mech_alias_t *cipher,
    char **raw_key, size_t *raw_key_sz)
{
	CK_RV	rv = CKR_OK;
	CK_BBOOL trueval = B_TRUE;
	CK_OBJECT_CLASS kclass;		/* secret key or RSA private key */
	CK_KEY_TYPE ktype;		/* from selected cipher or CKK_RSA */
	CK_KEY_TYPE raw_ktype;		/* from selected cipher */
	CK_ATTRIBUTE	key_tmpl[] = {
		{ CKA_CLASS, NULL, 0 },	/* re-used for token key and unwrap */
		{ CKA_KEY_TYPE, NULL, 0 },	/* ditto */
		{ CKA_LABEL, NULL, 0 },
		{ CKA_TOKEN, NULL, 0 },
		{ CKA_PRIVATE, NULL, 0 }
	    };
	CK_ULONG attrs = sizeof (key_tmpl) / sizeof (CK_ATTRIBUTE);
	int	i;
	char	*pass = NULL;
	size_t	passlen = 0;
	CK_OBJECT_HANDLE obj, rawobj;
	CK_ULONG num_objs = 1;		/* just want to find 1 token key */
	CK_MECHANISM unwrap = { CKM_RSA_PKCS, NULL, 0 };
	char	*rkey;
	size_t	rksz;

	if (token == NULL || token->key == NULL)
		return;

	/* did init_crypto find a slot that supports this cipher? */
	if (cipher->slot == (CK_SLOT_ID)-1 || cipher->max_keysize == 0) {
		die(gettext("failed to find any cryptographic provider, "
		    "use \"cryptoadm list -p\" to find providers: %s\n"),
		    pkcs11_strerror(CKR_MECHANISM_INVALID));
	}

	if (pkcs11_get_pass(token->name, &pass, &passlen, 0, B_FALSE) < 0)
		die(gettext("unable to get passphrase"));

	/* use passphrase to login to token */
	if (pass != NULL && passlen > 0) {
		rv = C_Login(sess, CKU_USER, (CK_UTF8CHAR_PTR)pass, passlen);
		if (rv != CKR_OK) {
			die(gettext("cannot login to the token %s: %s\n"),
			    token->name, pkcs11_strerror(rv));
		}
	}

	rv = pkcs11_mech2keytype(cipher->type, &raw_ktype);
	if (rv != CKR_OK) {
		die(gettext("failed to get key type for cipher %s: %s\n"),
		    cipher->name, pkcs11_strerror(rv));
	}

	/*
	 * If no keyfile was given, then the token key is secret key to
	 * be used for encryption/decryption.  Otherwise, the keyfile
	 * contains a wrapped secret key, and the token is actually the
	 * unwrapping RSA private key.
	 */
	if (keyfile == NULL) {
		kclass = CKO_SECRET_KEY;
		ktype = raw_ktype;
	} else {
		kclass = CKO_PRIVATE_KEY;
		ktype = CKK_RSA;
	}

	/* Find the key in the token first */
	for (i = 0; i < attrs; i++) {
		switch (key_tmpl[i].type) {
		case CKA_CLASS:
			key_tmpl[i].pValue = &kclass;
			key_tmpl[i].ulValueLen = sizeof (kclass);
			break;
		case CKA_KEY_TYPE:
			key_tmpl[i].pValue = &ktype;
			key_tmpl[i].ulValueLen = sizeof (ktype);
			break;
		case CKA_LABEL:
			key_tmpl[i].pValue = token->key;
			key_tmpl[i].ulValueLen = strlen(token->key);
			break;
		case CKA_TOKEN:
			key_tmpl[i].pValue = &trueval;
			key_tmpl[i].ulValueLen = sizeof (trueval);
			break;
		case CKA_PRIVATE:
			key_tmpl[i].pValue = &trueval;
			key_tmpl[i].ulValueLen = sizeof (trueval);
			break;
		default:
			break;
		}
	}
	rv = C_FindObjectsInit(sess, key_tmpl, attrs);
	if (rv != CKR_OK)
		die(gettext("cannot find key %s: %s\n"), token->key,
		    pkcs11_strerror(rv));
	rv = C_FindObjects(sess, &obj, 1, &num_objs);
	(void) C_FindObjectsFinal(sess);

	if (num_objs == 0) {
		die(gettext("cannot find key %s\n"), token->key);
	} else if (rv != CKR_OK) {
		die(gettext("cannot find key %s: %s\n"), token->key,
		    pkcs11_strerror(rv));
	}

	/*
	 * No keyfile means when token key is found, convert it to raw key,
	 * and done.  Otherwise still need do an unwrap to create yet another
	 * obj and that needs to be converted to raw key before we're done.
	 */
	if (keyfile == NULL) {
		/* obj contains raw key, extract it */
		rv = pkcs11_ObjectToKey(sess, obj, (void **)&rkey, &rksz,
		    B_FALSE);
		if (rv != CKR_OK) {
			die(gettext("failed to get key value for %s"
			    " from token %s, %s\n"), token->key,
			    token->name, pkcs11_strerror(rv));
		}
	} else {
		getkeyfromfile(keyfile, cipher, &rkey, &rksz);

		/*
		 * Got the wrapping RSA obj and the wrapped key from file.
		 * Unwrap the key from file with RSA obj to get rawkey obj.
		 */

		/* re-use the first two attributes of key_tmpl */
		kclass = CKO_SECRET_KEY;
		ktype = raw_ktype;

		rv = C_UnwrapKey(sess, &unwrap, obj, (CK_BYTE_PTR)rkey,
		    rksz, key_tmpl, 2, &rawobj);
		if (rv != CKR_OK) {
			die(gettext("failed to unwrap key in keyfile %s,"
			    " %s\n"), keyfile, pkcs11_strerror(rv));
		}
		/* rawobj contains raw key, extract it */
		rv = pkcs11_ObjectToKey(sess, rawobj, (void **)&rkey, &rksz,
		    B_TRUE);
		if (rv != CKR_OK) {
			die(gettext("failed to get unwrapped key value for"
			    " key in keyfile %s, %s\n"), keyfile,
			    pkcs11_strerror(rv));
		}
	}

	/* validate raw key size */
	if (rksz < cipher->min_keysize || cipher->max_keysize < rksz) {
		warn(gettext("%s: invalid keysize: %d\n"), keyfile, (int)rksz);
		die(gettext("\t%d <= keysize <= %d\n"), cipher->min_keysize,
		    cipher->max_keysize);
	}

	*raw_key_sz = rksz;
	*raw_key = (char *)rkey;
}

/*
 * Set up cipher key limits and verify PKCS#11 can be done
 * match_token_cipher is the function pointer used by
 * pkcs11_GetCriteriaSession() init_crypto.
 */
boolean_t
match_token_cipher(CK_SLOT_ID slot_id, void *args, CK_RV *rv)
{
	token_spec_t *token;
	mech_alias_t *cipher;
	CK_TOKEN_INFO tokinfo;
	CK_MECHANISM_INFO mechinfo;
	boolean_t token_match;

	/*
	 * While traversing slot list, pick up the following info per slot:
	 * - if token specified, whether it matches this slot's token info
	 * - if the slot supports the PKCS#5 PBKD2 cipher
	 *
	 * If the user said on the command line
	 *	-T tok:mfr:ser:lab -k keyfile
	 *	-c cipher -T tok:mfr:ser:lab -k keyfile
	 * the given cipher or the default cipher apply to keyfile,
	 * If the user said instead
	 *	-T tok:mfr:ser:lab
	 *	-c cipher -T tok:mfr:ser:lab
	 * the key named "lab" may or may not agree with the given
	 * cipher or the default cipher.  In those cases, cipher will
	 * be overridden with the actual cipher type of the key "lab".
	 */
	*rv = CKR_FUNCTION_FAILED;

	if (args == NULL) {
		return (B_FALSE);
	}

	cipher = (mech_alias_t *)args;
	token = cipher->token;

	if (C_GetMechanismInfo(slot_id, cipher->type, &mechinfo) != CKR_OK) {
		return (B_FALSE);
	}

	if (token == NULL) {
		if (C_GetMechanismInfo(slot_id, CKM_PKCS5_PBKD2, &mechinfo) !=
		    CKR_OK) {
			return (B_FALSE);
		}
		goto foundit;
	}

	/* does the token match the token spec? */
	if (token->key == NULL || (C_GetTokenInfo(slot_id, &tokinfo) != CKR_OK))
		return (B_FALSE);

	token_match = B_TRUE;

	if (token->name != NULL && (token->name)[0] != '\0' &&
	    strncmp((char *)token->name, (char *)tokinfo.label,
	    TOKEN_LABEL_SIZE) != 0)
		token_match = B_FALSE;
	if (token->mfr != NULL && (token->mfr)[0] != '\0' &&
	    strncmp((char *)token->mfr, (char *)tokinfo.manufacturerID,
	    TOKEN_MANUFACTURER_SIZE) != 0)
		token_match = B_FALSE;
	if (token->serno != NULL && (token->serno)[0] != '\0' &&
	    strncmp((char *)token->serno, (char *)tokinfo.serialNumber,
	    TOKEN_SERIAL_SIZE) != 0)
		token_match = B_FALSE;

	if (!token_match)
		return (B_FALSE);

foundit:
	cipher->slot = slot_id;
	return (B_TRUE);
}

/*
 * Clean up crypto loose ends
 */
static void
end_crypto(CK_SESSION_HANDLE sess)
{
	(void) C_CloseSession(sess);
	(void) C_Finalize(NULL);
}

/*
 * Set up crypto, opening session on slot that matches token and cipher
 */
static void
init_crypto(token_spec_t *token, mech_alias_t *cipher,
    CK_SESSION_HANDLE_PTR sess)
{
	CK_RV	rv;

	cipher->token = token;

	/* Turn off Metaslot so that we can see actual tokens */
	if (setenv("METASLOT_ENABLED", "false", 1) < 0) {
		die(gettext("could not disable Metaslot"));
	}

	rv = pkcs11_GetCriteriaSession(match_token_cipher, (void *)cipher,
	    sess);
	if (rv != CKR_OK) {
		end_crypto(*sess);
		if (rv == CKR_HOST_MEMORY) {
			die("malloc");
		}
		die(gettext("failed to find any cryptographic provider, "
		    "use \"cryptoadm list -p\" to find providers: %s\n"),
		    pkcs11_strerror(rv));
	}
}

/*
 * Uncompress a file.
 *
 * First map the file in to establish a device
 * association, then read from it. On-the-fly
 * decompression will automatically uncompress
 * the file if it's compressed
 *
 * If the file is mapped and a device association
 * has been established, disallow uncompressing
 * the file until it is unmapped.
 */
static void
lofi_uncompress(int lfd, const char *filename)
{
	struct lofi_ioctl li;
	char buf[MAXBSIZE];
	char devicename[32];
	char tmpfilename[MAXPATHLEN];
	char *x;
	char *dir = NULL;
	char *file = NULL;
	int minor = 0;
	struct stat64 statbuf;
	int compfd = -1;
	int uncompfd = -1;
	ssize_t rbytes;

	/*
	 * Disallow uncompressing the file if it is
	 * already mapped.
	 */
	li.li_crypto_enabled = B_FALSE;
	li.li_id = 0;
	(void) strlcpy(li.li_filename, filename, sizeof (li.li_filename));
	if (ioctl(lfd, LOFI_GET_MINOR, &li) != -1)
		die(gettext("%s must be unmapped before uncompressing"),
		    filename);

	/* Zero length files don't need to be uncompressed */
	if (stat64(filename, &statbuf) == -1)
		die(gettext("stat: %s"), filename);
	if (statbuf.st_size == 0)
		return;

	minor = lofi_map_file(lfd, &li, filename);
	(void) snprintf(devicename, sizeof (devicename), "/dev/%s/%d",
	    LOFI_BLOCK_NAME, minor);

	/* If the file isn't compressed, we just return */
	if ((ioctl(lfd, LOFI_CHECK_COMPRESSED, &li) == -1) ||
	    (li.li_algorithm[0] == '\0')) {
		delete_mapping(lfd, devicename, filename, B_TRUE);
		die("%s is not compressed\n", filename);
	}

	if ((compfd = open64(devicename, O_RDONLY | O_NONBLOCK)) == -1) {
		delete_mapping(lfd, devicename, filename, B_TRUE);
		die(gettext("open: %s"), filename);
	}
	/* Create a temp file in the same directory */
	x = strdup(filename);
	dir = strdup(dirname(x));
	free(x);
	x = strdup(filename);
	file = strdup(basename(x));
	free(x);
	(void) snprintf(tmpfilename, sizeof (tmpfilename),
	    "%s/.%sXXXXXX", dir, file);
	free(dir);
	free(file);

	if ((uncompfd = mkstemp64(tmpfilename)) == -1) {
		(void) close(compfd);
		delete_mapping(lfd, devicename, filename, B_TRUE);
		die("%s could not be uncompressed\n", filename);
	}

	/*
	 * Set the mode bits and the owner of this temporary
	 * file to be that of the original uncompressed file
	 */
	(void) fchmod(uncompfd, statbuf.st_mode);

	if (fchown(uncompfd, statbuf.st_uid, statbuf.st_gid) == -1) {
		(void) close(compfd);
		(void) close(uncompfd);
		delete_mapping(lfd, devicename, filename, B_TRUE);
		die("%s could not be uncompressed\n", filename);
	}

	/* Now read from the device in MAXBSIZE-sized chunks */
	for (;;) {
		rbytes = read(compfd, buf, sizeof (buf));

		if (rbytes <= 0)
			break;

		if (write(uncompfd, buf, rbytes) != rbytes) {
			rbytes = -1;
			break;
		}
	}

	(void) close(compfd);
	(void) close(uncompfd);

	/* Delete the mapping */
	delete_mapping(lfd, devicename, filename, B_TRUE);

	/*
	 * If an error occured while reading or writing, rbytes will
	 * be negative
	 */
	if (rbytes < 0) {
		(void) unlink(tmpfilename);
		die(gettext("could not read from %s"), filename);
	}

	/* Rename the temp file to the actual file */
	if (rename(tmpfilename, filename) == -1)
		(void) unlink(tmpfilename);
}

/*
 * Compress a file
 */
static void
lofi_compress(int *lfd, const char *filename, int compress_index,
    uint32_t segsize)
{
	struct lofi_ioctl lic;
	lofi_compress_info_t *li;
	struct flock lock;
	char tmpfilename[MAXPATHLEN];
	char comp_filename[MAXPATHLEN];
	char algorithm[MAXALGLEN];
	char *x;
	char *dir = NULL, *file = NULL;
	uchar_t *uncompressed_seg = NULL;
	uchar_t *compressed_seg = NULL;
	uint32_t compressed_segsize;
	uint32_t len_compressed, count;
	uint32_t index_entries, index_sz;
	uint64_t *index = NULL;
	uint64_t offset;
	size_t real_segsize;
	struct stat64 statbuf;
	int compfd = -1, uncompfd = -1;
	int tfd = -1;
	ssize_t rbytes, wbytes, lastread;
	int i, type;

	/*
	 * Disallow compressing the file if it is
	 * already mapped
	 */
	lic.li_id = 0;
	(void) strlcpy(lic.li_filename, filename, sizeof (lic.li_filename));
	if (ioctl(*lfd, LOFI_GET_MINOR, &lic) != -1)
		die(gettext("%s must be unmapped before compressing"),
		    filename);

	/*
	 * Close the control device so other operations
	 * can use it
	 */
	(void) close(*lfd);
	*lfd = -1;

	li = &lofi_compress_table[compress_index];

	/*
	 * The size of the buffer to hold compressed data must
	 * be slightly larger than the compressed segment size.
	 *
	 * The compress functions use part of the buffer as
	 * scratch space to do calculations.
	 * Ref: http://www.zlib.net/manual.html#compress2
	 */
	compressed_segsize = segsize + (segsize >> 6);
	compressed_seg = (uchar_t *)malloc(compressed_segsize + SEGHDR);
	uncompressed_seg = (uchar_t *)malloc(segsize);

	if (compressed_seg == NULL || uncompressed_seg == NULL)
		die(gettext("No memory"));

	if ((uncompfd = open64(filename, O_RDWR|O_LARGEFILE, 0)) == -1)
		die(gettext("open: %s"), filename);

	lock.l_type = F_WRLCK;
	lock.l_whence = SEEK_SET;
	lock.l_start = 0;
	lock.l_len = 0;

	/*
	 * Use an advisory lock to ensure that only a
	 * single lofiadm process compresses a given
	 * file at any given time
	 *
	 * A close on the file descriptor automatically
	 * closes all lock state on the file
	 */
	if (fcntl(uncompfd, F_SETLKW, &lock) == -1)
		die(gettext("fcntl: %s"), filename);

	if (fstat64(uncompfd, &statbuf) == -1) {
		(void) close(uncompfd);
		die(gettext("fstat: %s"), filename);
	}

	/* Zero length files don't need to be compressed */
	if (statbuf.st_size == 0) {
		(void) close(uncompfd);
		return;
	}

	/*
	 * Create temporary files in the same directory that
	 * will hold the intermediate data
	 */
	x = strdup(filename);
	dir = strdup(dirname(x));
	free(x);
	x = strdup(filename);
	file = strdup(basename(x));
	free(x);
	(void) snprintf(tmpfilename, sizeof (tmpfilename),
	    "%s/.%sXXXXXX", dir, file);
	(void) snprintf(comp_filename, sizeof (comp_filename),
	    "%s/.%sXXXXXX", dir, file);
	free(dir);
	free(file);

	if ((tfd = mkstemp64(tmpfilename)) == -1)
		goto cleanup;

	if ((compfd = mkstemp64(comp_filename)) == -1)
		goto cleanup;

	/*
	 * Set the mode bits and owner of the compressed
	 * file to be that of the original uncompressed file
	 */
	(void) fchmod(compfd, statbuf.st_mode);

	if (fchown(compfd, statbuf.st_uid, statbuf.st_gid) == -1)
		goto cleanup;

	/*
	 * Calculate the number of index entries required.
	 * index entries are stored as an array. adding
	 * a '2' here accounts for the fact that the last
	 * segment may not be a multiple of the segment size
	 */
	index_sz = (statbuf.st_size / segsize) + 2;
	index = malloc(sizeof (*index) * index_sz);

	if (index == NULL)
		goto cleanup;

	offset = 0;
	lastread = segsize;
	count = 0;

	/*
	 * Now read from the uncompressed file in 'segsize'
	 * sized chunks, compress what was read in and
	 * write it out to a temporary file
	 */
	for (;;) {
		rbytes = read(uncompfd, uncompressed_seg, segsize);

		if (rbytes <= 0)
			break;

		if (lastread < segsize)
			goto cleanup;

		/*
		 * Account for the first byte that
		 * indicates whether a segment is
		 * compressed or not
		 */
		real_segsize = segsize - 1;
		(void) li->l_compress(uncompressed_seg, rbytes,
		    compressed_seg + SEGHDR, &real_segsize, li->l_level);

		/*
		 * If the length of the compressed data is more
		 * than a threshold then there isn't any benefit
		 * to be had from compressing this segment - leave
		 * it uncompressed.
		 *
		 * NB. In case an error occurs during compression (above)
		 * the 'real_segsize' isn't changed. The logic below
		 * ensures that that segment is left uncompressed.
		 */
		len_compressed = real_segsize;
		if (segsize <= COMPRESS_THRESHOLD ||
		    real_segsize > (segsize - COMPRESS_THRESHOLD)) {
			(void) memcpy(compressed_seg + SEGHDR, uncompressed_seg,
			    rbytes);
			type = UNCOMPRESSED;
			len_compressed = rbytes;
		} else {
			type = COMPRESSED;
		}

		/*
		 * Set the first byte or the SEGHDR to
		 * indicate if it's compressed or not
		 */
		*compressed_seg = type;
		wbytes = write(tfd, compressed_seg, len_compressed + SEGHDR);
		if (wbytes != (len_compressed + SEGHDR)) {
			rbytes = -1;
			break;
		}

		index[count] = BE_64(offset);
		offset += wbytes;
		lastread = rbytes;
		count++;
	}

	(void) close(uncompfd);

	if (rbytes < 0)
		goto cleanup;
	/*
	 * The last index entry is a sentinel entry. It does not point to
	 * an actual compressed segment but helps in computing the size of
	 * the compressed segment. The size of each compressed segment is
	 * computed by subtracting the current index value from the next
	 * one (the compressed blocks are stored sequentially)
	 */
	index[count++] = BE_64(offset);

	/*
	 * Now write the compressed data along with the
	 * header information to this file which will
	 * later be renamed to the original uncompressed
	 * file name
	 *
	 * The header is as follows -
	 *
	 * Signature (name of the compression algorithm)
	 * Compression segment size (a multiple of 512)
	 * Number of index entries
	 * Size of the last block
	 * The array containing the index entries
	 *
	 * the header is always stored in network byte
	 * order
	 */
	(void) bzero(algorithm, sizeof (algorithm));
	(void) strlcpy(algorithm, li->l_name, sizeof (algorithm));
	if (write(compfd, algorithm, sizeof (algorithm))
	    != sizeof (algorithm))
		goto cleanup;

	segsize = htonl(segsize);
	if (write(compfd, &segsize, sizeof (segsize)) != sizeof (segsize))
		goto cleanup;

	index_entries = htonl(count);
	if (write(compfd, &index_entries, sizeof (index_entries)) !=
	    sizeof (index_entries))
		goto cleanup;

	lastread = htonl(lastread);
	if (write(compfd, &lastread, sizeof (lastread)) != sizeof (lastread))
		goto cleanup;

	for (i = 0; i < count; i++) {
		if (write(compfd, index + i, sizeof (*index)) !=
		    sizeof (*index))
			goto cleanup;
	}

	/* Header is written, now write the compressed data */
	if (lseek(tfd, 0, SEEK_SET) != 0)
		goto cleanup;

	rbytes = wbytes = 0;

	for (;;) {
		rbytes = read(tfd, compressed_seg, compressed_segsize + SEGHDR);

		if (rbytes <= 0)
			break;

		if (write(compfd, compressed_seg, rbytes) != rbytes)
			goto cleanup;
	}

	if (fstat64(compfd, &statbuf) == -1)
		goto cleanup;

	/*
	 * Round up the compressed file size to be a multiple of
	 * DEV_BSIZE. lofi(4D) likes it that way.
	 */
	if ((offset = statbuf.st_size % DEV_BSIZE) > 0) {

		offset = DEV_BSIZE - offset;

		for (i = 0; i < offset; i++)
			uncompressed_seg[i] = '\0';
		if (write(compfd, uncompressed_seg, offset) != offset)
			goto cleanup;
	}
	(void) close(compfd);
	(void) close(tfd);
	(void) unlink(tmpfilename);
cleanup:
	if (rbytes < 0) {
		if (tfd != -1)
			(void) unlink(tmpfilename);
		if (compfd != -1)
			(void) unlink(comp_filename);
		die(gettext("error compressing file %s"), filename);
	} else {
		/* Rename the compressed file to the actual file */
		if (rename(comp_filename, filename) == -1) {
			(void) unlink(comp_filename);
			die(gettext("error compressing file %s"), filename);
		}
	}
	if (compressed_seg != NULL)
		free(compressed_seg);
	if (uncompressed_seg != NULL)
		free(uncompressed_seg);
	if (index != NULL)
		free(index);
	if (compfd != -1)
		(void) close(compfd);
	if (uncompfd != -1)
		(void) close(uncompfd);
	if (tfd != -1)
		(void) close(tfd);
}

static int
lofi_compress_select(const char *algname)
{
	int i;

	for (i = 0; i < LOFI_COMPRESS_FUNCTIONS; i++) {
		if (strcmp(lofi_compress_table[i].l_name, algname) == 0)
			return (i);
	}
	return (-1);
}

static void
check_algorithm_validity(const char *algname, int *compress_index)
{
	*compress_index = lofi_compress_select(algname);
	if (*compress_index < 0)
		die(gettext("invalid algorithm name: %s\n"), algname);
}

static void
check_file_validity(const char *filename)
{
	struct stat64 buf;
	int 	error;
	int	fd;

	fd = open64(filename, O_RDONLY);
	if (fd == -1) {
		die(gettext("open: %s"), filename);
	}
	error = fstat64(fd, &buf);
	if (error == -1) {
		die(gettext("fstat: %s"), filename);
	} else if (!S_ISLOFIABLE(buf.st_mode)) {
		die(gettext("%s is not a regular file, "
		    "block, or character device\n"),
		    filename);
	} else if ((buf.st_size % DEV_BSIZE) != 0) {
		die(gettext("size of %s is not a multiple of %d\n"),
		    filename, DEV_BSIZE);
	}
	(void) close(fd);

	if (name_to_minor(filename) != 0) {
		die(gettext("cannot use %s on itself\n"), LOFI_DRIVER_NAME);
	}
}

static boolean_t
check_file_is_encrypted(const char *filename)
{
	int	fd;
	char    buf[sizeof (lofi_crypto_magic)];
	int	got;
	int	rest = sizeof (lofi_crypto_magic);

	fd = open64(filename, O_RDONLY);
	if (fd == -1)
		die(gettext("failed to open: %s"), filename);

	if (lseek(fd, CRYOFF, SEEK_SET) != CRYOFF)
		die(gettext("failed to seek to offset 0x%lx in file %s"),
		    CRYOFF, filename);

	do {
		got = read(fd, buf + sizeof (lofi_crypto_magic) - rest, rest);
		if ((got == 0) || ((got == -1) && (errno != EINTR)))
			die(gettext("failed to read crypto header"
			    " at offset 0x%lx in file %s"), CRYOFF, filename);

		if (got > 0)
			rest -= got;
	} while (rest > 0);

	while (close(fd) == -1) {
		if (errno != EINTR)
			die(gettext("failed to close file %s"), filename);
	}

	return (strncmp(buf, lofi_crypto_magic,
	    sizeof (lofi_crypto_magic)) == 0);
}

static uint32_t
convert_to_num(const char *str)
{
	int len;
	uint32_t segsize, mult = 1;

	len = strlen(str);
	if (len && isalpha(str[len - 1])) {
		switch (str[len - 1]) {
		case 'k':
		case 'K':
			mult = KILOBYTE;
			break;
		case 'b':
		case 'B':
			mult = BLOCK_SIZE;
			break;
		case 'm':
		case 'M':
			mult = MEGABYTE;
			break;
		case 'g':
		case 'G':
			mult = GIGABYTE;
			break;
		default:
			die(gettext("invalid segment size %s\n"), str);
		}
	}

	segsize = atol(str);
	segsize *= mult;

	return (segsize);
}

int
main(int argc, char *argv[])
{
	int	lfd;
	int	c;
	const char *devicename = NULL;
	const char *filename = NULL;
	const char *algname = COMPRESS_ALGORITHM;
	int	openflag;
	int	minor;
	int	compress_index;
	uint32_t segsize = SEGSIZE;
	static char *lofictl = "/dev/" LOFI_CTL_NAME;
	boolean_t force = B_FALSE;
	const char *pname;
	boolean_t errflag = B_FALSE;
	boolean_t addflag = B_FALSE;
	boolean_t labelflag = B_FALSE;
	boolean_t rdflag = B_FALSE;
	boolean_t deleteflag = B_FALSE;
	boolean_t ephflag = B_FALSE;
	boolean_t compressflag = B_FALSE;
	boolean_t uncompressflag = B_FALSE;
	/* the next two work together for -c, -k, -T, -e options only */
	boolean_t need_crypto = B_FALSE;	/* if any -c, -k, -T, -e */
	boolean_t cipher_only = B_TRUE;		/* if -c only */
	const char *keyfile = NULL;
	mech_alias_t *cipher = NULL;
	token_spec_t *token = NULL;
	char	*rkey = NULL;
	size_t	rksz = 0;
	char realfilename[MAXPATHLEN];

	pname = getpname(argv[0]);

	(void) setlocale(LC_ALL, "");
	(void) textdomain(TEXT_DOMAIN);

	while ((c = getopt(argc, argv, "a:c:Cd:efk:lrs:T:U")) != EOF) {
		switch (c) {
		case 'a':
			addflag = B_TRUE;
			if ((filename = realpath(optarg, realfilename)) == NULL)
				die("%s", optarg);
			if (((argc - optind) > 0) && (*argv[optind] != '-')) {
				/* optional device */
				devicename = argv[optind];
				optind++;
			}
			break;
		case 'C':
			compressflag = B_TRUE;
			if (((argc - optind) > 1) && (*argv[optind] != '-')) {
				/* optional algorithm */
				algname = argv[optind];
				optind++;
			}
			check_algorithm_validity(algname, &compress_index);
			break;
		case 'c':
			/* is the chosen cipher allowed? */
			if ((cipher = ciph2mech(optarg)) == NULL) {
				errflag = B_TRUE;
				warn(gettext("cipher %s not allowed\n"),
				    optarg);
			}
			need_crypto = B_TRUE;
			/* cipher_only is already set */
			break;
		case 'd':
			deleteflag = B_TRUE;
			minor = name_to_minor(optarg);
			if (minor != 0)
				devicename = optarg;
			else {
				if ((filename = realpath(optarg,
				    realfilename)) == NULL)
					die("%s", optarg);
			}
			break;
		case 'e':
			ephflag = B_TRUE;
			need_crypto = B_TRUE;
			cipher_only = B_FALSE;	/* need to unset cipher_only */
			break;
		case 'f':
			force = B_TRUE;
			break;
		case 'k':
			keyfile = optarg;
			need_crypto = B_TRUE;
			cipher_only = B_FALSE;	/* need to unset cipher_only */
			break;
		case 'l':
			labelflag = B_TRUE;
			break;
		case 'r':
			rdflag = B_TRUE;
			break;
		case 's':
			segsize = convert_to_num(optarg);
			if (segsize < DEV_BSIZE || !ISP2(segsize))
				die(gettext("segment size %s is invalid "
				    "or not a multiple of minimum block "
				    "size %ld\n"), optarg, DEV_BSIZE);
			break;
		case 'T':
			if ((token = parsetoken(optarg)) == NULL) {
				errflag = B_TRUE;
				warn(
				    gettext("invalid token key specifier %s\n"),
				    optarg);
			}
			need_crypto = B_TRUE;
			cipher_only = B_FALSE;	/* need to unset cipher_only */
			break;
		case 'U':
			uncompressflag = B_TRUE;
			break;
		case '?':
		default:
			errflag = B_TRUE;
			break;
		}
	}

	/* Check for mutually exclusive combinations of options */
	if (errflag ||
	    (addflag && deleteflag) ||
	    (labelflag && !addflag) ||
	    (rdflag && !addflag) ||
	    (!addflag && need_crypto) ||
	    (need_crypto && labelflag) ||
	    ((compressflag || uncompressflag) &&
	    (labelflag || addflag || deleteflag)))
		usage(pname);

	/* ephemeral key, and key from either file or token are incompatible */
	if (ephflag && (keyfile != NULL || token != NULL)) {
		die(gettext("ephemeral key cannot be used with keyfile"
		    " or token key\n"));
	}

	/*
	 * "-c" but no "-k", "-T", "-e", or "-T -k" means derive key from
	 * command line passphrase
	 */

	switch (argc - optind) {
	case 0: /* no more args */
		if (compressflag || uncompressflag)	/* needs filename */
			usage(pname);
		break;
	case 1:
		if (addflag || deleteflag)
			usage(pname);
		/* one arg means compress/uncompress the file ... */
		if (compressflag || uncompressflag) {
			if ((filename = realpath(argv[optind],
			    realfilename)) == NULL)
				die("%s", argv[optind]);
		/* ... or without options means print the association */
		} else {
			minor = name_to_minor(argv[optind]);
			if (minor != 0)
				devicename = argv[optind];
			else {
				if ((filename = realpath(argv[optind],
				    realfilename)) == NULL)
					die("%s", argv[optind]);
			}
		}
		break;
	default:
		usage(pname);
		break;
	}

	if (addflag || compressflag || uncompressflag)
		check_file_validity(filename);

	if (filename && !valid_abspath(filename))
		exit(E_ERROR);

	/*
	 * Here, we know the arguments are correct, the filename is an
	 * absolute path, it exists and is a regular file. We don't yet
	 * know that the device name is ok or not.
	 */

	openflag = O_EXCL;
	if (addflag || deleteflag || compressflag || uncompressflag)
		openflag |= O_RDWR;
	else
		openflag |= O_RDONLY;
	lfd = open(lofictl, openflag);
	if (lfd == -1) {
		if ((errno == EPERM) || (errno == EACCES)) {
			die(gettext("you do not have permission to perform "
			    "that operation.\n"));
		} else {
			die(gettext("open: %s"), lofictl);
		}
		/*NOTREACHED*/
	}

	/*
	 * No passphrase is needed for ephemeral key, or when key is
	 * in a file and not wrapped by another key from a token.
	 * However, a passphrase is needed in these cases:
	 * 1. cipher with no ephemeral key, key file, or token,
	 *    in which case the passphrase is used to build the key
	 * 2. token with an optional cipher or optional key file,
	 *    in which case the passphrase unlocks the token
	 * If only the cipher is specified, reconfirm the passphrase
	 * to ensure the user hasn't mis-entered it.  Otherwise, the
	 * token will enforce the token passphrase.
	 */
	if (need_crypto) {
		CK_SESSION_HANDLE	sess;

		/* pick a cipher if none specified */
		if (cipher == NULL)
			cipher = DEFAULT_CIPHER;

		if (!kernel_cipher_check(cipher))
			die(gettext(
			    "use \"cryptoadm list -m\" to find available "
			    "mechanisms\n"));

		init_crypto(token, cipher, &sess);

		if (cipher_only) {
			getkeyfromuser(cipher, &rkey, &rksz,
			    !check_file_is_encrypted(filename));
		} else if (token != NULL) {
			getkeyfromtoken(sess, token, keyfile, cipher,
			    &rkey, &rksz);
		} else {
			/* this also handles ephemeral keys */
			getkeyfromfile(keyfile, cipher, &rkey, &rksz);
		}

		end_crypto(sess);
	}

	/*
	 * Now to the real work.
	 */
	if (addflag)
		add_mapping(lfd, devicename, filename, cipher, rkey, rksz,
		    rdflag, labelflag);
	else if (compressflag)
		lofi_compress(&lfd, filename, compress_index, segsize);
	else if (uncompressflag)
		lofi_uncompress(lfd, filename);
	else if (deleteflag)
		delete_mapping(lfd, devicename, filename, force);
	else if (filename || devicename)
		print_one_mapping(lfd, devicename, filename);
	else
		print_mappings(lfd);

	if (lfd != -1)
		(void) close(lfd);
	closelib();
	return (E_SUCCESS);
}



/* ============================================================================
 * SOURCE 44/98: minix4\exokernel\kernel_legacy\cmd\logadm\main.c
 * Size: 37,042 bytes, Lines: 1,279
 * Hash: affc769b222c...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2001, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright 2019 Joyent, Inc.
 *
 * logadm/main.c -- main routines for logadm
 *
 * this program is 90% argument processing, 10% actions...
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <strings.h>
#include <libintl.h>
#include <locale.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/filio.h>
#include <sys/sysmacros.h>
#include <time.h>
#include <utime.h>
#include <poll.h>
#include <errno.h>
#include "err.h"
#include "lut.h"
#include "fn.h"
#include "opts.h"
#include "conf.h"
#include "glob.h"
#include "kw.h"

/* forward declarations for functions in this file */
static void usage(const char *msg);
static void commajoin(const char *lhs, void *rhs, void *arg);
static void doaftercmd(const char *lhs, void *rhs, void *arg);
static void dologname(struct fn *fnp, struct opts *clopts);
static boolean_t rotatelog(struct fn *fnp, struct opts *opts);
static void rotateto(struct fn *fnp, struct opts *opts, int n,
    struct fn *recentlog, boolean_t isgz);
static void do_delayed_gzip(const char *lhs, void *rhs, void *arg);
static void expirefiles(struct fn *fnp, struct opts *opts);
static void dorm(struct opts *opts, const char *msg, struct fn *fnp);
static void docmd(struct opts *opts, const char *msg, const char *cmd,
    const char *arg1, const char *arg2, const char *arg3);
static void docopytruncate(struct opts *opts, const char *file,
    const char *file_copy);

/* our configuration file, unless otherwise specified by -f */
static char *Default_conffile = "/etc/logadm.conf";
/* our timestamps file, unless otherwise specified by -F */
static char *Default_timestamps = "/var/logadm/timestamps";

/* default pathnames to the commands we invoke */
static char *Sh = "/bin/sh";
static char *Mv = "/bin/mv";
static char *Rm = "/bin/rm";
static char *Touch = "/bin/touch";
static char *Chmod = "/bin/chmod";
static char *Chown = "/bin/chown";
static char *Gzip = "/bin/gzip";
static char *Mkdir = "/bin/mkdir";

int Debug;

/* return from time(0), gathered early on to avoid slewed timestamps */
time_t Now;

/* list of before commands that have been executed */
static struct lut *Beforecmds;

/* list of after commands to execute before exiting */
static struct lut *Aftercmds;

/* list of conffile entry names that are considered "done" */
static struct lut *Donenames;

/* A list of names of files to be gzipped */
static struct lut *Gzipnames = NULL;

/*
 * only the "FfhnVv" options are allowed in the first form of this command,
 * so this defines the list of options that are an error in they appear
 * in the first form.  In other words, it is not allowed to run logadm
 * with any of these options unless at least one logname is also provided.
 */
#define	OPTIONS_NOT_FIRST_FORM	"eNrwpPsabcglmoRtzACEST"

/* text that we spew with the -h flag */
#define	HELP1 \
"Usage: logadm [options]\n"\
"       (processes all entries in /etc/logadm.conf or conffile given by -f)\n"\
"   or: logadm [options] logname...\n"\
"       (processes the given lognames)\n"\
"\n"\
"General options:\n"\
"        -e mailaddr     mail errors to given address\n"\
"        -F timestamps   use timestamps instead of /var/logadm/timestamps\n"\
"        -f conffile     use conffile instead of /etc/logadm.conf\n"\
"        -h              display help\n"\
"        -N              not an error if log file nonexistent\n"\
"        -n              show actions, don't perform them\n"\
"        -r              remove logname entry from conffile\n"\
"        -V              ensure conffile entries exist, correct\n"\
"        -v              print info about actions happening\n"\
"        -w entryname    write entry to config file\n"\
"\n"\
"Options which control when a logfile is rotated:\n"\
"(default is: -s1b -p1w if no -s or -p)\n"\
"        -p period       only rotate if period passed since last rotate\n"\
"        -P timestamp    used to store rotation date in conffile\n"\
"        -s size         only rotate if given size or greater\n"\
"\n"
#define	HELP2 \
"Options which control how a logfile is rotated:\n"\
"(default is: -t '$file.$n', owner/group/mode taken from log file)\n"\
"        -a cmd          execute cmd after taking actions\n"\
"        -b cmd          execute cmd before taking actions\n"\
"        -c              copy & truncate logfile, don't rename\n"\
"        -g group        new empty log file group\n"\
"        -l              rotate log file with local time rather than UTC\n"\
"        -m mode         new empty log file mode\n"\
"        -M cmd          execute cmd to rotate the log file\n"\
"        -o owner        new empty log file owner\n"\
"        -R cmd          run cmd on file after rotate\n"\
"        -t template     template for naming old logs\n"\
"        -z count        gzip old logs except most recent count\n"\
"\n"\
"Options which control the expiration of old logfiles:\n"\
"(default is: -C10 if no -A, -C, or -S)\n"\
"        -A age          expire logs older than age\n"\
"        -C count        expire old logs until count remain\n"\
"        -E cmd          run cmd on file to expire\n"\
"        -S size         expire until space used is below size \n"\
"        -T pattern      pattern for finding old logs\n"

/*
 * main -- where it all begins
 */
/*ARGSUSED*/
int
main(int argc, char *argv[])
{
	struct opts *clopts = NULL;	/* from parsing command line */
	const char *conffile;		/* our configuration file */
	const char *timestamps;		/* our timestamps file */
	struct fn_list *lognames;	/* list of lognames we're processing */
	struct fn *fnp;
	char *val;
	char *buf;
	int status;

	(void) setlocale(LC_ALL, "");

#if !defined(TEXT_DOMAIN)
#define	TEXT_DOMAIN "SYS_TEST"	/* only used if Makefiles don't define it */
#endif

	(void) textdomain(TEXT_DOMAIN);

	/* we only print times into the timestamps file, so make them uniform */
	(void) setlocale(LC_TIME, "C");

	/* give our name to error routines & skip it for arg parsing */
	err_init(*argv++);
	(void) setlinebuf(stdout);

	if (putenv("PATH=/bin"))
		err(EF_SYS, "putenv PATH");
	if (putenv("TZ=UTC"))
		err(EF_SYS, "putenv TZ");
	tzset();

	(void) umask(0);

	Now = time(0);

	/* check for (undocumented) debugging environment variables */
	if (val = getenv("_LOGADM_DEFAULT_CONFFILE"))
		Default_conffile = val;
	if (val = getenv("_LOGADM_DEFAULT_TIMESTAMPS"))
		Default_timestamps = val;
	if (val = getenv("_LOGADM_DEBUG"))
		Debug = atoi(val);
	if (val = getenv("_LOGADM_SH"))
		Sh = val;
	if (val = getenv("_LOGADM_MV"))
		Mv = val;
	if (val = getenv("_LOGADM_RM"))
		Rm = val;
	if (val = getenv("_LOGADM_TOUCH"))
		Touch = val;
	if (val = getenv("_LOGADM_CHMOD"))
		Chmod = val;
	if (val = getenv("_LOGADM_CHOWN"))
		Chown = val;
	if (val = getenv("_LOGADM_GZIP"))
		Gzip = val;
	if (val = getenv("_LOGADM_MKDIR"))
		Mkdir = val;

	opts_init(Opttable, Opttable_cnt);

	/* parse command line arguments */
	if (SETJMP)
		usage("bailing out due to command line errors");
	else
		clopts = opts_parse(NULL, argv, OPTF_CLI);

	if (Debug) {
		(void) fprintf(stderr, "command line opts:");
		opts_print(clopts, stderr, NULL);
		(void) fprintf(stderr, "\n");
	}

	/*
	 * There are many moods of logadm:
	 *
	 *	1. "-h" for help was given.  We spew a canned help
	 *	   message and exit, regardless of any other options given.
	 *
	 *	2. "-r" or "-w" asking us to write to the conffile.  Lots
	 *	   of argument checking, then we make the change to conffile
	 *	   and exit.  (-r processing actually happens in dologname().)
	 *
	 *	3. "-V" to search/verify the conffile was given.  We do
	 *	   the appropriate run through the conffile and exit.
	 *	   (-V processing actually happens in dologname().)
	 *
	 *	4. No lognames were given, so we're being asked to go through
	 *	   every entry in conffile.  We verify that only the options
	 *	   that make sense for this form of the command are present
	 *	   and fall into the main processing loop below.
	 *
	 *	5. lognames were given, so we fall into the main processing
	 *	   loop below to work our way through them.
	 *
	 * The last two cases are where the option processing gets more
	 * complex.  Each time around the main processing loop, we're
	 * in one of these cases:
	 *
	 *	A. No cmdargs were found (we're in case 4), the entry
	 *	   in conffile supplies no log file names, so the entry
	 *	   name itself is the logfile name (or names, if it globs
	 *	   to multiple file names).
	 *
	 *	B. No cmdargs were found (we're in case 4), the entry
	 *	   in conffile gives log file names that we then loop
	 *	   through and rotate/expire.  In this case, the entry
	 *	   name is specifically NOT one of the log file names.
	 *
	 *	C. We're going through the cmdargs (we're in case 5),
	 *	   the entry in conffile either doesn't exist or it exists
	 *	   but supplies no log file names, so the cmdarg itself
	 *	   is the log file name.
	 *
	 *	D. We're going through the cmdargs (we're in case 5),
	 *	   a matching entry in conffile supplies log file names
	 *	   that we then loop through and rotate/expire.  In this
	 *	   case the entry name is specifically NOT one of the log
	 *	   file names.
	 *
	 * As we're doing all this, any options given on the command line
	 * override any found in the conffile, and we apply the defaults
	 * for rotation conditions and expiration conditions, etc. at the
	 * last opportunity, when we're sure they haven't been overridden
	 * by an option somewhere along the way.
	 *
	 */

	/* help option overrides anything else */
	if (opts_count(clopts, "h")) {
		(void) fputs(HELP1, stderr);
		(void) fputs(HELP2, stderr);
		err_done(0);
		/*NOTREACHED*/
	}

	/* detect illegal option combinations */
	if (opts_count(clopts, "rwV") > 1)
		usage("Only one of -r, -w, or -V may be used at a time.");
	if (opts_count(clopts, "cM") > 1)
		usage("Only one of -c or -M may be used at a time.");

	/* arrange for error output to be mailed if clopts includes -e */
	if (opts_count(clopts, "e"))
		err_mailto(opts_optarg(clopts, "e"));

	/* this implements the default conffile and timestamps */
	if ((conffile = opts_optarg(clopts, "f")) == NULL)
		conffile = Default_conffile;
	if ((timestamps = opts_optarg(clopts, "F")) == NULL)
		timestamps = Default_timestamps;
	if (opts_count(clopts, "v"))
		(void) out("# loading %s\n", conffile);
	status = conf_open(conffile, timestamps, clopts);
	if (!status && opts_count(clopts, "V"))
		err_done(0);

	/* handle conffile write option */
	if (opts_count(clopts, "w")) {
		if (Debug)
			(void) fprintf(stderr,
			    "main: add/replace conffile entry: <%s>\n",
			    opts_optarg(clopts, "w"));
		conf_replace(opts_optarg(clopts, "w"), clopts);
		conf_close(clopts);
		err_done(0);
		/*NOTREACHED*/
	}

	/*
	 * lognames is either a list supplied on the command line,
	 * or every entry in the conffile if none were supplied.
	 */
	lognames = opts_cmdargs(clopts);
	if (fn_list_empty(lognames)) {
		/*
		 * being asked to do all entries in conffile
		 *
		 * check to see if any options were given that only
		 * make sense when lognames are given specifically
		 * on the command line.
		 */
		if (opts_count(clopts, OPTIONS_NOT_FIRST_FORM))
			usage("some options require logname argument");
		if (Debug)
			(void) fprintf(stderr,
			    "main: run all entries in conffile\n");
		lognames = conf_entries();
	}

	/* foreach logname... */
	fn_list_rewind(lognames);
	while ((fnp = fn_list_next(lognames)) != NULL) {
		buf = fn_s(fnp);
		if (buf != NULL && lut_lookup(Donenames, buf) != NULL) {
			if (Debug)
				(void) fprintf(stderr,
				    "main: logname already done: <%s>\n",
				    buf);
			continue;
		}
		if (buf != NULL && SETJMP)
			err(EF_FILE, "bailing out on logname \"%s\" "
			    "due to errors", buf);
		else
			dologname(fnp, clopts);
	}

	/* execute any after commands */
	lut_walk(Aftercmds, doaftercmd, clopts);

	/* execute any gzip commands */
	lut_walk(Gzipnames, do_delayed_gzip, clopts);

	/* write out any conffile changes */
	conf_close(clopts);

	err_done(0);
	/*NOTREACHED*/
	return (0);	/* for lint's little mind */
}

/* spew a message, then a usage message, then exit */
static void
usage(const char *msg)
{
	if (msg)
		err(0, "%s\nUse \"logadm -h\" for help.", msg);
	else
		err(EF_RAW, "Use \"logadm -h\" for help.\n");
}

/* helper function used by doaftercmd() to join mail addrs with commas */
/*ARGSUSED1*/
static void
commajoin(const char *lhs, void *rhs, void *arg)
{
	struct fn *fnp = (struct fn *)arg;
	char *buf;

	buf = fn_s(fnp);
	if (buf != NULL && *buf)
		fn_putc(fnp, ',');
	fn_puts(fnp, lhs);
}

/* helper function used by main() to run "after" commands */
static void
doaftercmd(const char *lhs, void *rhs, void *arg)
{
	struct opts *opts = (struct opts *)arg;
	struct lut *addrs = (struct lut *)rhs;

	if (addrs) {
		struct fn *fnp = fn_new(NULL);

		/*
		 * addrs contains list of email addrs that should get
		 * the error output when this after command is executed.
		 */
		lut_walk(addrs, commajoin, fnp);
		err_mailto(fn_s(fnp));
	}

	docmd(opts, "-a cmd", Sh, "-c", lhs, NULL);
}

/* perform delayed gzip */

static void
do_delayed_gzip(const char *lhs, void *rhs, void *arg)
{
	struct opts *opts = (struct opts *)arg;

	if (rhs == NULL) {
		if (Debug) {
			(void) fprintf(stderr, "do_delayed_gzip: not gzipping "
			    "expired file <%s>\n", lhs);
		}
		return;
	}
	docmd(opts, "compress old log (-z flag)", Gzip, "-f", lhs, NULL);
}


/* main logname processing */
static void
dologname(struct fn *fnp, struct opts *clopts)
{
	const char *logname = fn_s(fnp);
	struct opts *cfopts;
	struct opts *allopts;
	struct fn_list *logfiles;
	struct fn_list *globbedfiles;
	struct fn *nextfnp;

	/* look up options set by config file */
	cfopts = conf_opts(logname);

	if (opts_count(clopts, "v"))
		(void) out("# processing logname: %s\n", logname);

	if (Debug) {
		if (logname != NULL)
			(void) fprintf(stderr, "dologname: logname <%s>\n",
			    logname);
		(void) fprintf(stderr, "conffile opts:");
		opts_print(cfopts, stderr, NULL);
		(void) fprintf(stderr, "\n");
	}

	/* handle conffile lookup option */
	if (opts_count(clopts, "V")) {
		/* lookup an entry in conffile */
		if (Debug)
			(void) fprintf(stderr,
			    "dologname: lookup conffile entry\n");
		if (conf_lookup(logname)) {
			opts_printword(logname, stdout);
			opts_print(cfopts, stdout, NULL);
			(void) out("\n");
		} else
			err_exitcode(1);
		return;
	}

	/* handle conffile removal option */
	if (opts_count(clopts, "r")) {
		if (Debug)
			(void) fprintf(stderr,
			    "dologname: remove conffile entry\n");
		if (conf_lookup(logname))
			conf_replace(logname, NULL);
		else
			err_exitcode(1);
		return;
	}

	/* generate combined options */
	allopts = opts_merge(cfopts, clopts);

	/* arrange for error output to be mailed if allopts includes -e */
	if (opts_count(allopts, "e"))
		err_mailto(opts_optarg(allopts, "e"));
	else
		err_mailto(NULL);

	/* this implements the default rotation rules */
	if (opts_count(allopts, "sp") == 0) {
		if (opts_count(clopts, "v"))
			(void) out(
			    "#     using default rotate rules: -s1b -p1w\n");
		(void) opts_set(allopts, "s", "1b");
		(void) opts_set(allopts, "p", "1w");
	}

	/* this implements the default expiration rules */
	if (opts_count(allopts, "ACS") == 0) {
		if (opts_count(clopts, "v"))
			(void) out("#     using default expire rule: -C10\n");
		(void) opts_set(allopts, "C", "10");
	}

	/* this implements the default template */
	if (opts_count(allopts, "t") == 0) {
		if (opts_count(clopts, "v"))
			(void) out("#     using default template: $file.$n\n");
		(void) opts_set(allopts, "t", "$file.$n");
	}

	if (Debug) {
		(void) fprintf(stderr, "merged opts:");
		opts_print(allopts, stderr, NULL);
		(void) fprintf(stderr, "\n");
	}

	/*
	 * if the conffile entry supplied log file names, then
	 * logname is NOT one of the log file names (it was just
	 * the entry name in conffile).
	 */
	logfiles = opts_cmdargs(cfopts);
	if (Debug) {
		char *buf;
		(void) fprintf(stderr, "dologname: logfiles from cfopts:\n");
		fn_list_rewind(logfiles);
		while ((nextfnp = fn_list_next(logfiles)) != NULL) {
			buf = fn_s(nextfnp);
			if (buf != NULL)
				(void) fprintf(stderr, "    <%s>\n", buf);
		}
	}
	if (fn_list_empty(logfiles))
		globbedfiles = glob_glob(fnp);
	else
		globbedfiles = glob_glob_list(logfiles);

	/* go through the list produced by glob expansion */
	fn_list_rewind(globbedfiles);
	while ((nextfnp = fn_list_next(globbedfiles)) != NULL)
		if (rotatelog(nextfnp, allopts))
			expirefiles(nextfnp, allopts);

	fn_list_free(globbedfiles);
	opts_free(allopts);
}


/* absurdly long buffer lengths for holding user/group/mode strings */
#define	TIMESTRMAX	100
#define	MAXATTR		100

/* rotate a log file if necessary, returns true if ok to go on to expire step */
static boolean_t
rotatelog(struct fn *fnp, struct opts *opts)
{
	char *fname = fn_s(fnp);
	struct stat stbuf;
	char nowstr[TIMESTRMAX];
	struct fn *recentlog = fn_new(NULL);	/* for -R cmd */
	char ownerbuf[MAXATTR];
	char groupbuf[MAXATTR];
	char modebuf[MAXATTR];
	const char *owner;
	const char *group;
	const char *mode;

	if (Debug && fname != NULL)
		(void) fprintf(stderr, "rotatelog: fname <%s>\n", fname);

	if (opts_count(opts, "p") && opts_optarg_int(opts, "p") == OPTP_NEVER)
		return (B_TRUE);	/* "-p never" forced no rotate */

	/* prepare the keywords */
	kw_init(fnp, NULL);
	if (Debug > 1) {
		(void) fprintf(stderr, "rotatelog keywords:\n");
		kw_print(stderr);
	}

	if (lstat(fname, &stbuf) < 0) {
		if (opts_count(opts, "N"))
			return (1);
		err(EF_WARN|EF_SYS, "%s", fname);
		return (B_FALSE);
	}

	if ((stbuf.st_mode & S_IFMT) == S_IFLNK) {
		err(EF_WARN, "%s is a symlink", fname);
		return (B_FALSE);
	}

	if ((stbuf.st_mode & S_IFMT) != S_IFREG) {
		err(EF_WARN, "%s is not a regular file", fname);
		return (B_FALSE);
	}

	/* even if size condition is not met, this entry is "done" */
	if (opts_count(opts, "s") &&
	    stbuf.st_size < opts_optarg_int(opts, "s")) {
		Donenames = lut_add(Donenames, fname, "1");
		return (B_TRUE);
	}

	/* see if age condition is present, and return if not met */
	if (opts_count(opts, "p")) {
		off_t when = opts_optarg_int(opts, "p");
		struct opts *cfopts;

		/* unless rotate forced by "-p now", see if period has passed */
		if (when != OPTP_NOW) {
			/*
			 * "when" holds the number of seconds that must have
			 * passed since the last time this log was rotated.
			 * of course, running logadm can take a little time
			 * (typically a second or two, but longer if the
			 * conffile has lots of stuff in it) and that amount
			 * of time is variable, depending on system load, etc.
			 * so we want to allow a little "slop" in the value of
			 * "when".  this way, if a log should be rotated every
			 * week, and the number of seconds passed is really a
			 * few seconds short of a week, we'll go ahead and
			 * rotate the log as expected.
			 *
			 */
			if (when >= 60 * 60)
				when -= 59;

			/*
			 * last rotation is recorded as argument to -P,
			 * but if logname isn't the same as log file name
			 * then the timestamp would be recorded on a
			 * separate line in the timestamp file.  so if we
			 * haven't seen a -P already, we check to see if
			 * it is part of a specific entry for the log
			 * file name.  this handles the case where the
			 * logname is "apache", it supplies a log file
			 * name like "/var/apache/logs/[a-z]*_log",
			 * which expands to multiple file names.  if one
			 * of the file names is "/var/apache/logs/access_log"
			 * the the -P will be attached to a line with that
			 * logname in the timestamp file.
			 */
			if (opts_count(opts, "P")) {
				off_t last = opts_optarg_int(opts, "P");

				/* return if not enough time has passed */
				if (Now - last < when)
					return (B_TRUE);
			} else if ((cfopts = conf_opts(fname)) != NULL &&
			    opts_count(cfopts, "P")) {
				off_t last = opts_optarg_int(cfopts, "P");

				/*
				 * just checking this means this entry
				 * is now "done" if we're going through
				 * the entire conffile
				 */
				Donenames = lut_add(Donenames, fname, "1");

				/* return if not enough time has passed */
				if (Now - last < when)
					return (B_TRUE);
			}
		}
	}

	if (Debug)
		(void) fprintf(stderr, "rotatelog: conditions met\n");
	if (opts_count(opts, "l")) {
		/* Change the time zone to local time zone */
		if (putenv("TZ="))
			err(EF_SYS, "putenv TZ");
		tzset();
		Now = time(0);

		/* rename the log file */
		rotateto(fnp, opts, 0, recentlog, B_FALSE);

		/* Change the time zone to UTC */
		if (putenv("TZ=UTC"))
			err(EF_SYS, "putenv TZ");
		tzset();
		Now = time(0);
	} else {
		/* rename the log file */
		rotateto(fnp, opts, 0, recentlog, B_FALSE);
	}

	/* determine owner, group, mode for empty log file */
	if (opts_count(opts, "o"))
		(void) strlcpy(ownerbuf, opts_optarg(opts, "o"), MAXATTR);
	else {
		(void) snprintf(ownerbuf, MAXATTR, "%ld", stbuf.st_uid);
	}
	owner = ownerbuf;
	if (opts_count(opts, "g"))
		group = opts_optarg(opts, "g");
	else {
		(void) snprintf(groupbuf, MAXATTR, "%ld", stbuf.st_gid);
		group = groupbuf;
	}
	(void) strlcat(ownerbuf, ":", MAXATTR - strlen(ownerbuf));
	(void) strlcat(ownerbuf, group, MAXATTR - strlen(ownerbuf));
	if (opts_count(opts, "m"))
		mode = opts_optarg(opts, "m");
	else {
		(void) snprintf(modebuf, MAXATTR,
		    "%03lo", stbuf.st_mode & 0777);
		mode = modebuf;
	}

	/* create the empty log file */
	docmd(opts, NULL, Touch, fname, NULL, NULL);
	docmd(opts, NULL, Chown, owner, fname, NULL);
	docmd(opts, NULL, Chmod, mode, fname, NULL);

	/* execute post-rotation command */
	if (opts_count(opts, "R")) {
		struct fn *rawcmd = fn_new(opts_optarg(opts, "R"));
		struct fn *cmd = fn_new(NULL);

		kw_init(recentlog, NULL);
		(void) kw_expand(rawcmd, cmd, 0, B_FALSE);
		docmd(opts, "-R cmd", Sh, "-c", fn_s(cmd), NULL);
		fn_free(rawcmd);
		fn_free(cmd);
	}
	fn_free(recentlog);

	/*
	 * add "after" command to list of after commands.  we also record
	 * the email address, if any, where the error output of the after
	 * command should be sent.  if the after command is already on
	 * our list, add the email addr to the list the email addrs for
	 * that command (the after command will only be executed once,
	 * so the error output gets mailed to every address we've come
	 * across associated with this command).
	 */
	if (opts_count(opts, "a")) {
		const char *cmd = opts_optarg(opts, "a");
		struct lut *addrs = (struct lut *)lut_lookup(Aftercmds, cmd);
		if (opts_count(opts, "e"))
			addrs = lut_add(addrs, opts_optarg(opts, "e"), NULL);
		Aftercmds = lut_add(Aftercmds, opts_optarg(opts, "a"), addrs);
	}

	/* record the rotation date */
	(void) strftime(nowstr, sizeof (nowstr),
	    "%a %b %e %T %Y", gmtime(&Now));
	if (opts_count(opts, "v") && fname != NULL)
		(void) out("#     recording rotation date %s for %s\n",
		    nowstr, fname);
	conf_set(fname, "P", STRDUP(nowstr));
	Donenames = lut_add(Donenames, fname, "1");
	return (B_TRUE);
}

/* rotate files "up" according to current template */
static void
rotateto(struct fn *fnp, struct opts *opts, int n, struct fn *recentlog,
    boolean_t isgz)
{
	struct fn *template = fn_new(opts_optarg(opts, "t"));
	struct fn *newfile = fn_new(NULL);
	struct fn *dirname;
	int hasn;
	struct stat stbuf;
	char *buf1;
	char *buf2;

	/* expand template to figure out new filename */
	hasn = kw_expand(template, newfile, n, isgz);

	buf1 = fn_s(fnp);
	buf2 = fn_s(newfile);

	if (Debug)
		if (buf1 != NULL && buf2 != NULL) {
			(void) fprintf(stderr, "rotateto: %s -> %s (%d)\n",
			    buf1, buf2, n);
		}
	/* if filename is there already, rotate "up" */
	if (hasn && lstat(buf2, &stbuf) != -1)
		rotateto(newfile, opts, n + 1, recentlog, isgz);
	else if (hasn && opts_count(opts, "z")) {
		struct fn *gzfnp = fn_dup(newfile);
		/*
		 * since we're compressing old files, see if we
		 * about to rotate into one.
		 */
		fn_puts(gzfnp, ".gz");
		if (lstat(fn_s(gzfnp), &stbuf) != -1)
			rotateto(gzfnp, opts, n + 1, recentlog, B_TRUE);
		fn_free(gzfnp);
	}

	/* first time through run "before" cmd if not run already */
	if (n == 0 && opts_count(opts, "b")) {
		const char *cmd = opts_optarg(opts, "b");

		if (lut_lookup(Beforecmds, cmd) == NULL) {
			docmd(opts, "-b cmd", Sh, "-c", cmd, NULL);
			Beforecmds = lut_add(Beforecmds, cmd, "1");
		}
	}

	/* ensure destination directory exists */
	dirname = fn_dirname(newfile);
	docmd(opts, "verify directory exists", Mkdir, "-p",
	    fn_s(dirname), NULL);
	fn_free(dirname);

	/* do the rename */
	if (n == 0 && opts_count(opts, "c") != 0) {
		docopytruncate(opts, fn_s(fnp), fn_s(newfile));
	} else if (n == 0 && opts_count(opts, "M")) {
		struct fn *rawcmd = fn_new(opts_optarg(opts, "M"));
		struct fn *cmd = fn_new(NULL);

		/* use specified command to mv the log file */
		kw_init(fnp, newfile);
		(void) kw_expand(rawcmd, cmd, 0, B_FALSE);
		docmd(opts, "-M cmd", Sh, "-c", fn_s(cmd), NULL);
		fn_free(rawcmd);
		fn_free(cmd);
	} else
		/* common case: we call "mv" to handle the actual rename */
		docmd(opts, "rotate log file", Mv, "-f",
		    fn_s(fnp), fn_s(newfile));

	/* first time through, gather interesting info for caller */
	if (n == 0)
		fn_renew(recentlog, fn_s(newfile));
}

/* expire phase of logname processing */
static void
expirefiles(struct fn *fnp, struct opts *opts)
{
	char *fname = fn_s(fnp);
	struct fn *template;
	struct fn *pattern;
	struct fn_list *files;
	struct fn *nextfnp;
	off_t count;
	off_t size;

	if (Debug && fname != NULL)
		(void) fprintf(stderr, "expirefiles: fname <%s>\n", fname);

	/* return if no potential expire conditions */
	if (opts_count(opts, "zAS") == 0 && opts_optarg_int(opts, "C") == 0)
		return;

	kw_init(fnp, NULL);
	if (Debug > 1) {
		(void) fprintf(stderr, "expirefiles keywords:\n");
		kw_print(stderr);
	}

	/* see if pattern was supplied by user */
	if (opts_count(opts, "T")) {
		template = fn_new(opts_optarg(opts, "T"));
		pattern = glob_to_reglob(template);
	} else {
		/* nope, generate pattern based on rotation template */
		template = fn_new(opts_optarg(opts, "t"));
		pattern = fn_new(NULL);
		(void) kw_expand(template, pattern, -1,
		    opts_count(opts, "z") != 0);
	}

	/* match all old log files (hopefully not any others as well!) */
	files = glob_reglob(pattern);

	if (Debug) {
		char *buf;

		buf = fn_s(pattern);
		if (buf != NULL) {
			(void) fprintf(stderr, "expirefiles: pattern <%s>\n",
			    buf);
		}
		fn_list_rewind(files);
		while ((nextfnp = fn_list_next(files)) != NULL) {
			buf = fn_s(nextfnp);
			if (buf != NULL)
				(void) fprintf(stderr, "    <%s>\n", buf);
		}
	}

	/* see if count causes expiration */
	if ((count = opts_optarg_int(opts, "C")) > 0) {
		int needexpire = fn_list_count(files) - count;

		if (Debug)
			(void) fprintf(stderr, "expirefiles: needexpire %d\n",
			    needexpire);

		while (needexpire > 0 &&
		    ((nextfnp = fn_list_popoldest(files)) != NULL)) {
			dorm(opts, "expire by count rule", nextfnp);
			fn_free(nextfnp);
			needexpire--;
		}
	}

	/* see if total size causes expiration */
	if (opts_count(opts, "S") && (size = opts_optarg_int(opts, "S")) > 0) {
		while (fn_list_totalsize(files) > size &&
		    ((nextfnp = fn_list_popoldest(files)) != NULL)) {
			dorm(opts, "expire by size rule", nextfnp);
			fn_free(nextfnp);
		}
	}

	/* see if age causes expiration */
	if (opts_count(opts, "A")) {
		int mtime = (int)time(0) - (int)opts_optarg_int(opts, "A");

		while ((nextfnp = fn_list_popoldest(files)) != NULL) {
			if (fn_getstat(nextfnp)->st_mtime < mtime) {
				dorm(opts, "expire by age rule", nextfnp);
				fn_free(nextfnp);
			} else {
				fn_list_addfn(files, nextfnp);
				break;
			}
		}
	}

	/* record old log files to be gzip'ed according to -z count */
	if (opts_count(opts, "z")) {
		int zcount = (int)opts_optarg_int(opts, "z");
		int fcount = fn_list_count(files);

		while (fcount > zcount &&
		    (nextfnp = fn_list_popoldest(files)) != NULL) {
			if (!fn_isgz(nextfnp)) {
				/*
				 * Don't gzip the old log file yet -
				 * it takes too long. Just remember that we
				 * need to gzip.
				 */
				if (Debug) {
					(void) fprintf(stderr,
					    "will compress %s count %d\n",
					    fn_s(nextfnp), fcount);
				}
				Gzipnames = lut_add(Gzipnames,
				    fn_s(nextfnp), "1");
			}
			fn_free(nextfnp);
			fcount--;
		}
	}

	fn_free(template);
	fn_list_free(files);
}

/* execute a command to remove an expired log file */
static void
dorm(struct opts *opts, const char *msg, struct fn *fnp)
{
	if (opts_count(opts, "E")) {
		struct fn *rawcmd = fn_new(opts_optarg(opts, "E"));
		struct fn *cmd = fn_new(NULL);

		/* user supplied cmd, expand $file */
		kw_init(fnp, NULL);
		(void) kw_expand(rawcmd, cmd, 0, B_FALSE);
		docmd(opts, msg, Sh, "-c", fn_s(cmd), NULL);
		fn_free(rawcmd);
		fn_free(cmd);
	} else
		docmd(opts, msg, Rm, "-f", fn_s(fnp), NULL);
	Gzipnames = lut_add(Gzipnames, fn_s(fnp), NULL);
}

/* execute a command, producing -n and -v output as necessary */
static void
docmd(struct opts *opts, const char *msg, const char *cmd,
    const char *arg1, const char *arg2, const char *arg3)
{
	int pid;
	int errpipe[2];

	/* print info about command if necessary */
	if (opts_count(opts, "vn")) {
		const char *simplecmd;

		if ((simplecmd = strrchr(cmd, '/')) == NULL)
			simplecmd = cmd;
		else
			simplecmd++;
		(void) out("%s", simplecmd);
		if (arg1)
			(void) out(" %s", arg1);
		if (arg2)
			(void) out(" %s", arg2);
		if (arg3)
			(void) out(" %s", arg3);
		if (msg)
			(void) out(" # %s", msg);
		(void) out("\n");
	}

	if (opts_count(opts, "n"))
		return;		/* -n means don't really do it */

	/*
	 * Run the cmd and see if it failed.  This function is *not* a generic
	 * command runner.  The command name must be an absolute pathname, and
	 * two args must be supplied (the second may be NULL, or they may both
	 * be NULL).  Any output (stdout and stderr) from the child process is
	 * logged to stderr and perhaps sent to an email recipient.
	 */
	if (pipe(errpipe) < 0)
		err(EF_SYS, "pipe");

	if ((pid = fork()) < 0)
		err(EF_SYS, "fork");
	else if (pid) {
		int wstat;
		struct pollfd pfd;
		boolean_t first = B_TRUE;

		/* parent */
		(void) close(errpipe[1]);

		pfd.fd = errpipe[0];
		pfd.events = POLLIN | POLLRDNORM | POLLRDBAND | POLLPRI;
		for (;;) {

			pfd.revents = 0;
			if (poll(&pfd, 1, -1) == -1) {
				if (errno == EINTR) {
					continue;
				}
				err(EF_SYS, "poll");
				break;
			}
			if ((pfd.events & pfd.revents) != 0) {
				if (first) {
					err(EF_WARN,
					    "command failed: %s%s%s%s%s%s%s",
					    cmd,
					    (arg1) ? " " : "",
					    (arg1) ? arg1 : "",
					    (arg2) ? " " : "",
					    (arg2) ? arg2 : "",
					    (arg3) ? " " : "",
					    (arg3) ? arg3 : "");
					first = B_FALSE;
				}
				err_fromfd(pfd.fd);
			}
			if ((pfd.revents & (POLLERR | POLLHUP)) != 0) {
				break;
			}
		}
		if (waitpid(pid, &wstat, 0) < 0) {
			err(EF_SYS, "waitpid");
			return;
		}

		if (!first) {
			/* Assume the command gave a useful error */
		} else if (WIFSIGNALED(wstat)) {
			err(EF_WARN,
			    "command died, signal %d: %s%s%s%s%s%s%s",
			    WTERMSIG(wstat),
			    cmd,
			    (arg1) ? " " : "",
			    (arg1) ? arg1 : "",
			    (arg2) ? " " : "",
			    (arg2) ? arg2 : "",
			    (arg3) ? " " : "",
			    (arg3) ? arg3 : "");
		} else if (WIFEXITED(wstat) && WEXITSTATUS(wstat)) {
			err(EF_WARN,
			    "command error, exit %d: %s%s%s%s%s%s%s",
			    WEXITSTATUS(wstat),
			    cmd,
			    (arg1) ? " " : "",
			    (arg1) ? arg1 : "",
			    (arg2) ? " " : "",
			    (arg2) ? arg2 : "",
			    (arg3) ? " " : "",
			    (arg3) ? arg3 : "");
		}

		(void) close(errpipe[0]);
	} else {
		/* child */
		(void) dup2(errpipe[1], fileno(stderr));
		(void) close(errpipe[0]);
		(void) execl(cmd, cmd, arg1, arg2, arg3, 0);
		perror(cmd);
		_exit(1);
	}
}

/* do internal atomic file copy and truncation */
static void
docopytruncate(struct opts *opts, const char *file, const char *file_copy)
{
	int fi, fo;
	char buf[128 * 1024];
	struct stat s;
	struct utimbuf times;
	off_t written = 0, rem, last = 0, thresh = 1024 * 1024;
	ssize_t len = 0;

	/* print info if necessary */
	if (opts_count(opts, "vn") != 0) {
		(void) out("# log rotation via atomic copy and truncation"
		    " (-c flag):\n");
		(void) out("# copy %s to %s\n", file, file_copy);
		(void) out("# truncate %s\n", file);
	}

	if (opts_count(opts, "n"))
		return;		/* -n means don't really do it */

	/* open log file to be rotated and remember its chmod mask */
	if ((fi = open(file, O_RDWR)) < 0) {
		err(EF_SYS, "cannot open file %s", file);
		return;
	}

	if (fstat(fi, &s) < 0) {
		err(EF_SYS, "cannot access: %s", file);
		(void) close(fi);
		return;
	}

	/* create new file for copy destination with correct attributes */
	if ((fo = open(file_copy, O_CREAT|O_TRUNC|O_WRONLY, s.st_mode)) < 0) {
		err(EF_SYS, "cannot create file: %s", file_copy);
		(void) close(fi);
		return;
	}

	(void) fchown(fo, s.st_uid, s.st_gid);

	/*
	 * Now we'll loop, reading the log file and writing it to our copy
	 * until the bytes remaining are beneath our atomicity threshold -- at
	 * which point we'll lock the file and copy the remainder atomically.
	 * The body of this loop is non-atomic with respect to writers, the
	 * rationale being that total atomicity (that is, locking the file for
	 * the entire duration of the copy) comes at too great a cost for a
	 * large log file, as the writer (i.e., the daemon whose log is being
	 * rolled) can be blocked for an unacceptable duration.  (For one
	 * particularly loquacious daemon, this period was observed to be
	 * several minutes in length -- a time so long that it induced
	 * additional failures in dependent components.)  Note that this means
	 * that if the log file is not always appended to -- if it is opened
	 * without O_APPEND or otherwise truncated outside of logadm -- this
	 * will result in our log snapshot being incorrect.  But of course, in
	 * either of these cases, the use of logadm at all is itself
	 * suspect...
	 */
	do {
		if (fstat(fi, &s) < 0) {
			err(EF_SYS, "cannot stat: %s", file);
			(void) close(fi);
			(void) close(fo);
			(void) remove(file_copy);
			return;
		}

		if ((rem = s.st_size - written) < thresh) {
			if (rem >= 0)
				break;

			/*
			 * If the file became smaller, something fishy is going
			 * on; we'll truncate our copy, reset our seek offset
			 * and break into the atomic copy.
			 */
			(void) ftruncate(fo, 0);
			(void) lseek(fo, 0, SEEK_SET);
			(void) lseek(fi, 0, SEEK_SET);
			break;
		}

		if (written != 0 && rem > last) {
			/*
			 * We're falling behind -- this file is getting bigger
			 * faster than we're able to write it; break out and
			 * lock the file to block the writer.
			 */
			break;
		}

		last = rem;

		while (rem > 0) {
			if ((len = read(fi, buf, MIN(sizeof (buf), rem))) <= 0)
				break;

			if (write(fo, buf, len) == len) {
				rem -= len;
				written += len;
				continue;
			}

			err(EF_SYS, "cannot write into file %s", file_copy);
			(void) close(fi);
			(void) close(fo);
			(void) remove(file_copy);
			return;
		}
	} while (len >= 0);

	/* lock log file so that nobody can write into it before we are done */
	if (fchmod(fi, s.st_mode|S_ISGID) < 0)
		err(EF_SYS, "cannot set mandatory lock bit for: %s", file);

	if (lockf(fi, F_LOCK, 0) == -1)
		err(EF_SYS, "cannot lock file %s", file);

	/* do atomic copy and truncation */
	while ((len = read(fi, buf, sizeof (buf))) > 0)
		if (write(fo, buf, len) != len) {
			err(EF_SYS, "cannot write into file %s", file_copy);
			(void) lockf(fi, F_ULOCK, 0);
			(void) fchmod(fi, s.st_mode);
			(void) close(fi);
			(void) close(fo);
			(void) remove(file_copy);
			return;
		}

	(void) ftruncate(fi, 0);

	/* unlock log file */
	if (lockf(fi, F_ULOCK, 0) == -1)
		err(EF_SYS, "cannot unlock file %s", file);

	if (fchmod(fi, s.st_mode) < 0)
		err(EF_SYS, "cannot reset mandatory lock bit for: %s", file);

	(void) close(fi);
	(void) close(fo);

	/* keep times from original file */
	times.actime = s.st_atime;
	times.modtime = s.st_mtime;
	(void) utime(file_copy, &times);
}



/* ============================================================================
 * SOURCE 45/98: minix4\exokernel\kernel_legacy\cmd\mail\main.c
 * Size: 5,546 bytes, Lines: 243
 * Hash: 1f740b8fa64c...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2005 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

/*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved  	*/

#include "mail.h"
#ifdef SVR4
#include <locale.h>
#endif
/*
 *	mail [ -ehpPqrtw ] [-x debuglevel] [ -f file ] [ -F user(s) ]
 *	mail -T file persons
 *	mail [ -tw ] [ -m messagetype ] persons
 *	rmail [ -tw ] persons
 */
int
main(int argc, char **argv)
{
	register int i;
	char *cptr, *p;
	struct stat statb;
	static char pn[] = "main";
	extern char **environ;
	int env_var_idx, next_slot_idx;
	int tmpfd = -1;

#ifdef SVR4
	(void) setlocale(LC_ALL, "");
#endif
	/* fix here for bug #1086130 - security hole	*/
	/* skip over the LD_* env variable		*/
	env_var_idx = 0; next_slot_idx = 0;
	while (environ[env_var_idx] != NULL) {
			environ[next_slot_idx] = environ[env_var_idx];
		if (strncmp(environ[env_var_idx], "LD_", 3)) {
			next_slot_idx++;
		}
		env_var_idx++;
	}
	environ[next_slot_idx] = NULL;

#ifdef SIGCONT
#ifdef SVR4
	{
	struct sigaction nsig;
	nsig.sa_handler = SIG_DFL;
	sigemptyset(&nsig.sa_mask);
	nsig.sa_flags = SA_RESTART;
	(void) sigaction(SIGCONT, &nsig, (struct sigaction *)0);
	}
#else
	sigset(SIGCONT, SIG_DFL);
#endif
#endif

	/*
	 *	Strip off path name of this command for use in messages
	 */
	if ((program = strrchr(argv[0], '/')) != NULL) {
		program++;
	} else {
		program = argv[0];
	}

	/* Close all file descriptors except stdin, stdout & stderr */
	closefrom(STDERR_FILENO + 1);

	/*
	 *	Get group id for mail, exit if none exists
	 */
	if ((grpptr = getgrnam("mail")) == NULL) {
		errmsg(E_GROUP, "");
		exit(1);
	} else {
		mailgrp = grpptr->gr_gid;
	}

	/*
	 *	Save the *id for later use.
	 */
	my_uid = getuid();
	my_gid = getgid();
	my_euid = geteuid();
	my_egid = getegid();

	/*
	 *	What command (rmail or mail)?
	 */
	if (strcmp(program, "rmail") == SAME) {
		ismail = FALSE;
	}

	/*
	 *	Parse the command line and adjust argc and argv
	 *	to compensate for any options
	 */
	i = parse(argc, argv);
	argv += (i - 1);
	argc -= (i - 1);

	/* block a potential security hole */
	if (flgT && (my_euid != 0)) {
		setgid(my_gid);
		Tout(pn, "Setgid unset\n");
	}

	if (debug == 0) {
		/* If not set as an invocation option, check for system-wide */
		/* global flag */
		char *xp = xgetenv("DEBUG");
		if (xp != (char *)NULL) {
			debug = atoi(xp);
			if (debug < 0) {
				/* Keep trace file even if successful */
				keepdbgfile = -1;
				debug = -debug;
			}
		}
	}
	if (debug > 0) {
		strcpy(dbgfname, "/tmp/MLDBGXXXXXX");
		if ((tmpfd = mkstemp(dbgfname)) == -1) {
			fprintf(stderr, "%s: can't open debugging file '%s'\n",
				program, dbgfname);
			exit(13);
		}
		if ((dbgfp = fdopen(tmpfd, "w")) == (FILE *)NULL) {
			fprintf(stderr, "%s: can't open debugging file '%s'\n",
				program, dbgfname);
			(void) close(tmpfd);
			exit(13);
		}
		setbuf(dbgfp, NULL);
		fprintf(dbgfp, "main(): debugging level == %d\n", debug);
		fprintf(dbgfp, "main(): trace file ='%s': kept %s\n", dbgfname,
			((keepdbgfile < 0) ?
				"on success or failure." : "only on failure."));
	}

	if (!ismail && (goerr > 0 || !i)) {
		Dout(pn, 11, "!ismail, goerr=%d, i=%d\n", goerr, i);
		if (goerr > 0) {
			errmsg(E_SYNTAX, "Usage: rmail [-wt] person(s)");
		}
		if (!i) {
			errmsg(E_SYNTAX, "At least one user must be specified");
		}
		Dout(pn, 11, "exiting!\n");
		done(0);
	}

	umsave = umask(7);
	uname(&utsn);
	if ((p = xgetenv("CLUSTER")) != (char *)NULL) {
		/*
		 * We are not who we appear...
		 */
		thissys = p;
	} else {
		thissys = utsn.nodename;
	}
	Dout(pn, 11, "thissys = '%s', uname = '%s'\n", thissys, utsn.nodename);

	failsafe = xgetenv("FAILSAFE");
	if (failsafe)
		Dout(pn, 11, "failsafe processing enabled to %s\n", failsafe);

	/*
	 *	Use environment variables
	 */
	home = getenv("HOME");
	if (!home || !*home) {
		home = ".";
	}

	my_name[0] = '\0';
	pwd = getpwuid(my_uid);
	if (pwd)
		(void) strlcpy(my_name, pwd->pw_name, sizeof (my_name));

	/* If root, use LOGNAME if set */
	if (my_uid == 0) {
		/* If root, use LOGNAME if set */
		if (((cptr = getenv("LOGNAME")) != NULL) &&
		    (strlen(cptr) != 0)) {
			(void) strlcpy(my_name, cptr, sizeof (my_name));
		}
	}
	Dout(pn, 11, "my_name = '%s'\n", my_name);

	/*
	 *	Catch signals for cleanup
	 */
	if (setjmp(sjbuf)) {
		done(0);
	}
	for (i = SIGINT; i < SIGCLD; i++) {
		setsig(i, delete);
	}
	setsig(SIGHUP, sig_done);
	setsig(SIGTERM, sig_done);

	cksaved(my_name);

	/*
	 *	Rmail is always invoked to send mail
	 */
	Dout(pn, 11, "ismail=%d, argc=%d\n", ismail, argc);
	if (ismail && (argc == 1)) {
		sending = FALSE;
		printmail();

	} else {
		sending = TRUE;
		sendmail(argc, argv);
	}
	done(0);
}



/* ============================================================================
 * SOURCE 46/98: minix4\exokernel\kernel_legacy\cmd\mailx\main.c
 * Size: 9,693 bytes, Lines: 464
 * Hash: 20d10d4a97f9...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 * Copyright (c) 2016 by Delphix. All rights reserved.
 */

/*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved  	*/

/*
 * University Copyright- Copyright (c) 1982, 1986, 1988
 * The Regents of the University of California
 * All Rights Reserved
 *
 * University Acknowledgment- Portions of this document are derived from
 * software developed by the University of California, Berkeley, and its
 * contributors.
 */

#include "rcv.h"
#ifndef preSVr4
#include <locale.h>
#endif

/*
 * mailx -- a modified version of a University of California at Berkeley
 *	mail program
 *
 * Startup -- interface with user.
 */

static void		hdrstop(int);

static jmp_buf	hdrjmp;

const char *const version = "mailx version 5.0";

/*
 * Find out who the user is, copy their mail file (if exists) into
 * /tmp/Rxxxxx and set up the message pointers.  Then, print out the
 * message headers and read user commands.
 *
 * Command line syntax:
 *	mailx [ -i ] [ -r address ] [ -h number ] [ -f [ name ] ]
 * or:
 *	mailx [ -i ] [ -r address ] [ -h number ] people ...
 *
 * and a bunch of other options.
 */

int
main(int argc, char **argv)
{
	register char *ef;
	register int argp;
	int mustsend, f, goerr = 0;
	void (*prevint)(int);
	int loaded = 0;
	struct termio tbuf;
	struct termios tbufs;
	int c;
	char *cwd, *mf;

	/*
	 * Set up a reasonable environment.
	 * Figure out whether we are being run interactively, set up
	 * all the temporary files, buffer standard output, and so forth.
	 */

#ifndef preSVr4
	(void)setlocale(LC_ALL, "");
#endif
#if !defined(TEXT_DOMAIN)	/* Should be defined by cc -D */
#define	TEXT_DOMAIN "SYS_TEST"	/* Use this only if it weren't */
#endif
	(void) textdomain(TEXT_DOMAIN);

#ifdef SIGCONT
	sigset(SIGCONT, SIG_DFL);
#endif
	rpterr = 0;	/* initialize; set when we output to stderr */
	progname = argv[0];
	if (progname[strlen(progname) - 1] != 'x') {
		assign("bsdcompat", "");
	}
	myegid = getegid();
	myrgid = getgid();
	myeuid = geteuid();
	myruid = getuid();
	mypid = getpid();
	setgid(myrgid);
	setuid(myruid);
	inithost();
	intty = isatty(0);
	if (ioctl(1, TCGETS, &tbufs) < 0) {
		if (ioctl(1, TCGETA, &tbuf)==0) {
			outtty = 1;
			baud = tbuf.c_cflag & CBAUD;
		} else
			baud = B9600;
	} else {
		outtty = 1;
		baud = cfgetospeed(&tbufs);
	}
	image = -1;

	/*
	 * Now, determine how we are being used.
	 * We successively pick off instances of -r, -h, -f, and -i.
	 * If called as "rmail" we note this fact for letter sending.
	 * If there is anything left, it is the base of the list
	 * of users to mail to.  Argp will be set to point to the
	 * first of these users.
	 */

	ef = NOSTR;
	argp = -1;
	mustsend = 0;
	if (argc > 0 && **argv == 'r')
		rmail++;
	while ((c = getopt(argc, argv, "b:Bc:defFh:HiInNr:s:u:UtT:vV~")) != EOF)
		switch (c) {
		case 'e':
			/*
			 * exit status only
			 */
			exitflg++;
			break;

		case 'r':
			/*
			 * Next argument is address to be sent along
			 * to the mailer.
			 */
			mustsend++;
			rflag = optarg;
			break;

		case 'T':
			/*
			 * Next argument is temp file to write which
			 * articles have been read/deleted for netnews.
			 */
			Tflag = optarg;
			if ((f = creat(Tflag, TEMPPERM)) < 0) {
				perror(Tflag);
				exit(1);
			}
			close(f);
			/* fall through for -I too */
			/* FALLTHROUGH */

		case 'I':
			/*
			 * print newsgroup in header summary
			 */
			newsflg++;
			break;

		case 'u':
			/*
			 * Next argument is person's mailbox to use.
			 * Treated the same as "-f /var/mail/user".
			 */
			{
			static char u[PATHSIZE];
			snprintf(u, sizeof (u), "%s%s", maildir, optarg);
			ef = u;
			break;
			}

		case 'i':
			/*
			 * User wants to ignore interrupts.
			 * Set the variable "ignore"
			 */
			assign("ignore", "");
			break;

		case 'U':
			UnUUCP++;
			break;

		case 'd':
			assign("debug", "");
			break;

		case 'h':
			/*
			 * Specified sequence number for network.
			 * This is the number of "hops" made so
			 * far (count of times message has been
			 * forwarded) to help avoid infinite mail loops.
			 */
			mustsend++;
			hflag = atoi(optarg);
			if (hflag == 0) {
				fprintf(stderr,
				    gettext("-h needs non-zero number\n"));
				goerr++;
			}
			break;

		case 's':
			/*
			 * Give a subject field for sending from
			 * non terminal
			 */
			mustsend++;
			sflag = optarg;
			break;

		case 'c':	/* Cc: from command line */
			mustsend++;
			cflag = optarg;
			break;

		case 'b':	/* Bcc: from command line */
			mustsend++;
			bflag = optarg;
			break;

		case 'f':
			/*
			 * User is specifying file to "edit" with mailx,
			 * as opposed to reading system mailbox.
			 * If no argument is given after -f, we read their
			 * $MBOX file or mbox in their home directory.
			 */
			ef = (argc == optind || *argv[optind] == '-')
				? "" : argv[optind++];
			if (*ef && *ef != '/' && *ef != '+')
				cwd = getcwd(NOSTR, PATHSIZE);
			break;

		case 'F':
			Fflag++;
			mustsend++;
			break;

		case 'n':
			/*
			 * User doesn't want to source
			 *	/etc/mail/mailx.rc
			 */
			nosrc++;
			break;

		case 'N':
			/*
			 * Avoid initial header printing.
			 */
			noheader++;
			break;

		case 'H':
			/*
			 * Print headers and exit
			 */
			Hflag++;
			break;

		case 'V':
			puts(version);
			return 0;

		case '~':
			/*
			 * Permit tildas no matter where
			 * the input is coming from.
			 */
			assign("escapeok", "");
			break;

		case 'v':
			/*
			 * Send mailer verbose flag
			 */
			assign("verbose", "");
			break;

		case 'B':
			/*
			 * Don't buffer output
			 * (Line buffered is good enough)
			 */
			setvbuf(stdout, NULL, _IOLBF, BUFSIZ);
			setvbuf(stderr, NULL, _IOLBF, BUFSIZ);
			break;

		case 't':
			/*
			 * Like sendmail -t, read headers from text
			 */
			tflag++;
			mustsend++;
			break;

		case '?':
		default:
			goerr++;
			break;
		}

	if (optind != argc)
		argp = optind;

	/*
	 * Check for inconsistent arguments.
	 */

	if (newsflg && ef==NOSTR) {
		fprintf(stderr, gettext("Need -f with -I flag\n"));
		goerr++;
	}
	if (ef != NOSTR && argp != -1) {
		fprintf(stderr,
		    gettext("Cannot give -f and people to send to.\n"));
		goerr++;
	}
	if (exitflg && (mustsend || argp != -1))
		exit(1);	/* nonsense flags involving -e simply exit */
	if (tflag && argp != -1) {
		fprintf(stderr,
		    gettext("Ignoring recipients on command line with -t\n"));
		argp = -1;
	} else if (!tflag && mustsend && argp == -1) {
		fprintf(stderr,
	    gettext("The flags you gave are used only when sending mail.\n"));
		goerr++;
	}
	if (goerr) {
		fprintf(stderr,
gettext("Usage: %s -eiIUdFntBNHvV~ -T FILE -u USER -h hops -r address\n"),
		    progname);
		fprintf(stderr,
		    gettext("\t\t-s SUBJECT -f FILE users\n"));
		exit(1);
	}
	tinit();
	input = stdin;
	rcvmode = !tflag && argp == -1;
	if (!nosrc)
		load(MASTER);

	if (!rcvmode) {
		load(Getf("MAILRC"));
		if (tflag)
			tmail();
		else
			mail(&argv[argp]);
		exit(senderr ? senderr : rpterr);
	}

	/*
	 * Ok, we are reading mail.
	 * Decide whether we are editing a mailbox or reading
	 * the system mailbox, and open up the right stuff.
	 *
	 * Do this before sourcing the MAILRC, because there might be
	 * a 'chdir' there that breaks the -f option.  But if the
	 * file specified with -f is a folder name, go ahead and
	 * source the MAILRC anyway so that "folder" will be defined.
	 */

	nstrcpy(origname, PATHSIZE, mailname);
	editfile = mailname;

	if (ef != NOSTR) {
		if (ef == NOSTR || *ef == '\0' || *ef == '+') {
			load(Getf("MAILRC"));
			loaded++;
		}
		ef = *ef ? safeexpand(ef) : Getf("MBOX");
		nstrcpy(origname, PATHSIZE, ef);
		if (ef[0] != '/') {
			if (cwd == NOSTR)
				cwd = getcwd(NOSTR, PATHSIZE);
			nstrcat(cwd, PATHSIZE, "/");
			nstrcat(cwd, PATHSIZE, ef);
			ef = cwd;
		}
		editfile = ef;
		edit++;
	}

	if (setfile(editfile, edit) < 0)
		exit(1);

	if (!loaded)
		load(Getf("MAILRC"));
	if (msgCount > 0 && !noheader && value("header") != NOSTR) {
		if (setjmp(hdrjmp) == 0) {
			if ((prevint = sigset(SIGINT, SIG_IGN)) != SIG_IGN)
				sigset(SIGINT, hdrstop);
			announce();
			fflush(stdout);
			sigset(SIGINT, prevint);
		}
	}
	if (Hflag || (!edit && msgCount == 0)) {
		if (!Hflag) {
			fprintf(stderr, gettext("No mail for %s\n"), myname);
			Verhogen();
		}
		fflush(stdout);
		exit(rpterr);
	}
	commands();
	sigset(SIGHUP, SIG_IGN);
	sigset(SIGINT, SIG_IGN);
	sigset(SIGQUIT, SIG_IGN);
	if (!outtty)
		sigset(SIGPIPE, SIG_IGN);
	if (edit)
		edstop(0);
	else {
		quit(0);
		Verhogen();
	}
	return (rpterr);
}

/*
 * Interrupt printing of the headers.
 */
static void
#ifdef	__cplusplus
hdrstop(int)
#else
/* ARGSUSED */
hdrstop(int s)
#endif
{

	fflush(stdout);
	fprintf(stderr, gettext("\nInterrupt\n"));
# ifdef OLD_BSD_SIGS
	sigrelse(SIGINT);
# endif
	longjmp(hdrjmp, 1);
}



/* ============================================================================
 * SOURCE 47/98: minix4\exokernel\kernel_legacy\cmd\mandoc\main.c
 * Size: 33,775 bytes, Lines: 1,376
 * Hash: 0cfcbf4f7f60...
 * ============================================================================ */

/* $Id: main.c,v 1.358 2021/09/04 22:38:46 schwarze Exp $ */
/*
 * Copyright (c) 2010-2012, 2014-2021 Ingo Schwarze <schwarze@openbsd.org>
 * Copyright (c) 2008-2012 Kristaps Dzonsons <kristaps@bsd.lv>
 * Copyright (c) 2010 Joerg Sonnenberger <joerg@netbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Main program for mandoc(1), man(1), apropos(1), whatis(1), and help(1).
 */
#include "config.h"

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/param.h>	/* MACHINE */
#include <sys/stat.h>
#include <sys/wait.h>

#include <assert.h>
#include <ctype.h>
#if HAVE_ERR
#include <err.h>
#endif
#include <errno.h>
#include <fcntl.h>
#include <glob.h>
#include <limits.h>
#if HAVE_SANDBOX_INIT
#include <sandbox.h>
#endif
#include <signal.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <time.h>
#include <unistd.h>

#include "mandoc_aux.h"
#include "mandoc.h"
#include "mandoc_xr.h"
#include "roff.h"
#include "mdoc.h"
#include "man.h"
#include "mandoc_parse.h"
#include "tag.h"
#include "term_tag.h"
#include "main.h"
#include "manconf.h"
#include "mansearch.h"

enum	outmode {
	OUTMODE_DEF = 0,
	OUTMODE_FLN,
	OUTMODE_LST,
	OUTMODE_ALL,
	OUTMODE_ONE
};

enum	outt {
	OUTT_ASCII = 0,	/* -Tascii */
	OUTT_LOCALE,	/* -Tlocale */
	OUTT_UTF8,	/* -Tutf8 */
	OUTT_TREE,	/* -Ttree */
	OUTT_MAN,	/* -Tman */
	OUTT_HTML,	/* -Thtml */
	OUTT_MARKDOWN,	/* -Tmarkdown */
	OUTT_LINT,	/* -Tlint */
	OUTT_PS,	/* -Tps */
	OUTT_PDF	/* -Tpdf */
};

struct	outstate {
	struct tag_files *tag_files;	/* Tagging state variables. */
	void		 *outdata;	/* data for output */
	int		  use_pager;
	int		  wstop;	/* stop after a file with a warning */
	int		  had_output;	/* Some output was generated. */
	enum outt	  outtype;	/* which output to use */
};


int			  mandocdb(int, char *[]);

static	void		  check_xr(struct manpaths *);
static	void		  fs_append(char **, size_t, int,
				size_t, const char *, enum form,
				struct manpage **, size_t *);
static	int		  fs_lookup(const struct manpaths *, size_t,
				const char *, const char *, const char *,
				struct manpage **, size_t *);
static	int		  fs_search(const struct mansearch *,
				const struct manpaths *, const char *,
				struct manpage **, size_t *);
static	void		  glob_esc(char **, const char *, const char *);
static	void		  outdata_alloc(struct outstate *, struct manoutput *);
static	void		  parse(struct mparse *, int, const char *,
				struct outstate *, struct manconf *);
static	void		  passthrough(int, int);
static	void		  process_onefile(struct mparse *, struct manpage *,
				int, struct outstate *, struct manconf *);
static	void		  run_pager(struct outstate *, char *);
static	pid_t		  spawn_pager(struct outstate *, char *);
static	void		  usage(enum argmode) __attribute__((__noreturn__));
static	int		  woptions(char *, enum mandoc_os *, int *);

static	const int sec_prios[] = {1, 4, 5, 8, 6, 3, 7, 2, 9};
static	char		  help_arg[] = "help";
static	char		 *help_argv[] = {help_arg, NULL};


int
main(int argc, char *argv[])
{
	struct manconf	 conf;		/* Manpaths and output options. */
	struct outstate	 outst;		/* Output state. */
	struct winsize	 ws;		/* Result of ioctl(TIOCGWINSZ). */
	struct mansearch search;	/* Search options. */
	struct manpage	*res;		/* Complete list of search results. */
	struct manpage	*resn;		/* Search results for one name. */
	struct mparse	*mp;		/* Opaque parser object. */
	const char	*conf_file;	/* -C: alternate config file. */
	const char	*os_s;		/* -I: Operating system for display. */
	const char	*progname, *sec, *ep;
	char		*defpaths;	/* -M: override manpaths. */
	char		*auxpaths;	/* -m: additional manpaths. */
	char		*oarg;		/* -O: output option string. */
	char		*tagarg;	/* -O tag: default value. */
	unsigned char	*uc;
	size_t		 ressz;		/* Number of elements in res[]. */
	size_t		 resnsz;	/* Number of elements in resn[]. */
	size_t		 i, ib, ssz;
	int		 options;	/* Parser options. */
	int		 show_usage;	/* Invalid argument: give up. */
	int		 prio, best_prio;
	int		 startdir;
	int		 c;
	enum mandoc_os	 os_e;		/* Check base system conventions. */
	enum outmode	 outmode;	/* According to command line. */

#if HAVE_PROGNAME
	progname = getprogname();
#else
	if (argc < 1)
		progname = mandoc_strdup("mandoc");
	else if ((progname = strrchr(argv[0], '/')) == NULL)
		progname = argv[0];
	else
		++progname;
	setprogname(progname);
#endif

	mandoc_msg_setoutfile(stderr);
	if (strncmp(progname, "mandocdb", 8) == 0 ||
	    strcmp(progname, BINM_MAKEWHATIS) == 0)
		return mandocdb(argc, argv);

#if HAVE_PLEDGE
	if (pledge("stdio rpath wpath cpath tmppath tty proc exec", NULL) == -1) {
		mandoc_msg(MANDOCERR_PLEDGE, 0, 0, "%s", strerror(errno));
		return mandoc_msg_getrc();
	}
#endif
#if HAVE_SANDBOX_INIT
	if (sandbox_init(kSBXProfileNoInternet, SANDBOX_NAMED, NULL) == -1)
		errx((int)MANDOCLEVEL_SYSERR, "sandbox_init");
#endif

	/* Search options. */

	memset(&conf, 0, sizeof(conf));
	conf_file = NULL;
	defpaths = auxpaths = NULL;

	memset(&search, 0, sizeof(struct mansearch));
	search.outkey = "Nd";
	oarg = NULL;

	if (strcmp(progname, BINM_MAN) == 0)
		search.argmode = ARG_NAME;
	else if (strcmp(progname, BINM_APROPOS) == 0)
		search.argmode = ARG_EXPR;
	else if (strcmp(progname, BINM_WHATIS) == 0)
		search.argmode = ARG_WORD;
	else if (strncmp(progname, "help", 4) == 0)
		search.argmode = ARG_NAME;
	else
		search.argmode = ARG_FILE;

	/* Parser options. */

	options = MPARSE_SO | MPARSE_UTF8 | MPARSE_LATIN1;
	os_e = MANDOC_OS_OTHER;
	os_s = NULL;

	/* Formatter options. */

	memset(&outst, 0, sizeof(outst));
	outst.tag_files = NULL;
	outst.outtype = OUTT_LOCALE;
	outst.use_pager = 1;

	show_usage = 0;
	outmode = OUTMODE_DEF;

	while ((c = getopt(argc, argv,
	    "aC:cfhI:iK:klM:m:O:S:s:T:VW:w")) != -1) {
		if (c == 'i' && search.argmode == ARG_EXPR) {
			optind--;
			break;
		}
		switch (c) {
		case 'a':
			outmode = OUTMODE_ALL;
			break;
		case 'C':
			conf_file = optarg;
			break;
		case 'c':
			outst.use_pager = 0;
			break;
		case 'f':
			search.argmode = ARG_WORD;
			break;
		case 'h':
			conf.output.synopsisonly = 1;
			outst.use_pager = 0;
			outmode = OUTMODE_ALL;
			break;
		case 'I':
			if (strncmp(optarg, "os=", 3) != 0) {
				mandoc_msg(MANDOCERR_BADARG_BAD, 0, 0,
				    "-I %s", optarg);
				return mandoc_msg_getrc();
			}
			if (os_s != NULL) {
				mandoc_msg(MANDOCERR_BADARG_DUPE, 0, 0,
				    "-I %s", optarg);
				return mandoc_msg_getrc();
			}
			os_s = optarg + 3;
			break;
		case 'K':
			options &= ~(MPARSE_UTF8 | MPARSE_LATIN1);
			if (strcmp(optarg, "utf-8") == 0)
				options |=  MPARSE_UTF8;
			else if (strcmp(optarg, "iso-8859-1") == 0)
				options |=  MPARSE_LATIN1;
			else if (strcmp(optarg, "us-ascii") != 0) {
				mandoc_msg(MANDOCERR_BADARG_BAD, 0, 0,
				    "-K %s", optarg);
				return mandoc_msg_getrc();
			}
			break;
		case 'k':
			search.argmode = ARG_EXPR;
			break;
		case 'l':
			search.argmode = ARG_FILE;
			outmode = OUTMODE_ALL;
			break;
		case 'M':
			defpaths = optarg;
			break;
		case 'm':
			auxpaths = optarg;
			break;
		case 'O':
			oarg = optarg;
			break;
		case 'S':
			search.arch = optarg;
			break;
		case 's':
			search.sec = optarg;
			break;
		case 'T':
			if (strcmp(optarg, "ascii") == 0)
				outst.outtype = OUTT_ASCII;
			else if (strcmp(optarg, "lint") == 0) {
				outst.outtype = OUTT_LINT;
				mandoc_msg_setoutfile(stdout);
				mandoc_msg_setmin(MANDOCERR_BASE);
			} else if (strcmp(optarg, "tree") == 0)
				outst.outtype = OUTT_TREE;
			else if (strcmp(optarg, "man") == 0)
				outst.outtype = OUTT_MAN;
			else if (strcmp(optarg, "html") == 0)
				outst.outtype = OUTT_HTML;
			else if (strcmp(optarg, "markdown") == 0)
				outst.outtype = OUTT_MARKDOWN;
			else if (strcmp(optarg, "utf8") == 0)
				outst.outtype = OUTT_UTF8;
			else if (strcmp(optarg, "locale") == 0)
				outst.outtype = OUTT_LOCALE;
			else if (strcmp(optarg, "ps") == 0)
				outst.outtype = OUTT_PS;
			else if (strcmp(optarg, "pdf") == 0)
				outst.outtype = OUTT_PDF;
			else {
				mandoc_msg(MANDOCERR_BADARG_BAD, 0, 0,
				    "-T %s", optarg);
				return mandoc_msg_getrc();
			}
			break;
		case 'W':
			if (woptions(optarg, &os_e, &outst.wstop) == -1)
				return mandoc_msg_getrc();
			break;
		case 'w':
			outmode = OUTMODE_FLN;
			break;
		default:
			show_usage = 1;
			break;
		}
	}

	if (show_usage)
		usage(search.argmode);

	/* Postprocess options. */

	switch (outmode) {
	case OUTMODE_DEF:
		switch (search.argmode) {
		case ARG_FILE:
			outmode = OUTMODE_ALL;
			outst.use_pager = 0;
			break;
		case ARG_NAME:
			outmode = OUTMODE_ONE;
			break;
		default:
			outmode = OUTMODE_LST;
			break;
		}
		break;
	case OUTMODE_FLN:
		if (search.argmode == ARG_FILE)
			outmode = OUTMODE_ALL;
		break;
	case OUTMODE_ALL:
		break;
	case OUTMODE_LST:
	case OUTMODE_ONE:
		abort();
	}

	if (oarg != NULL) {
		if (outmode == OUTMODE_LST)
			search.outkey = oarg;
		else {
			while (oarg != NULL) {
				if (manconf_output(&conf.output,
				    strsep(&oarg, ","), 0) == -1)
					return mandoc_msg_getrc();
			}
		}
	}

	if (outst.outtype != OUTT_TREE || conf.output.noval == 0)
		options |= MPARSE_VALIDATE;

	if (outmode == OUTMODE_FLN ||
	    outmode == OUTMODE_LST ||
	    (conf.output.outfilename == NULL &&
	     conf.output.tagfilename == NULL &&
	     isatty(STDOUT_FILENO) == 0))
		outst.use_pager = 0;

	if (outst.use_pager &&
	    (conf.output.width == 0 || conf.output.indent == 0) &&
	    ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws) != -1 &&
	    ws.ws_col > 1) {
		if (conf.output.width == 0 && ws.ws_col < 79)
			conf.output.width = ws.ws_col - 1;
		if (conf.output.indent == 0 && ws.ws_col < 66)
			conf.output.indent = 3;
	}

#if HAVE_PLEDGE
	if (outst.use_pager == 0)
		c = pledge("stdio rpath", NULL);
	else if (conf.output.outfilename != NULL ||
	    conf.output.tagfilename != NULL)
		c = pledge("stdio rpath wpath cpath", NULL);
	else
		c = pledge("stdio rpath tmppath tty proc exec", NULL);
	if (c == -1) {
		mandoc_msg(MANDOCERR_PLEDGE, 0, 0, "%s", strerror(errno));
		return mandoc_msg_getrc();
	}
#endif

	/* Parse arguments. */

	if (argc > 0) {
		argc -= optind;
		argv += optind;
	}

	/*
	 * Quirks for help(1) and man(1),
	 * in particular for a section argument without -s.
	 */

	if (search.argmode == ARG_NAME) {
		if (*progname == 'h') {
			if (argc == 0) {
				argv = help_argv;
				argc = 1;
			}
		} else if (argc > 1 &&
		    ((uc = (unsigned char *)argv[0]) != NULL) &&
		    ((isdigit(uc[0]) && (uc[1] == '\0' ||
		      isalpha(uc[1]))) ||
		     (uc[0] == 'n' && uc[1] == '\0'))) {
			search.sec = (char *)uc;
			argv++;
			argc--;
		}
		if (search.arch == NULL)
			search.arch = getenv("MACHINE");
#ifdef MACHINE
		if (search.arch == NULL)
			search.arch = MACHINE;
#endif
		if (outmode == OUTMODE_ONE)
			search.firstmatch = 1;
	}

	/*
	 * Use the first argument for -O tag in addition to
	 * using it as a search term for man(1) or apropos(1).
	 */

	if (conf.output.tag != NULL && *conf.output.tag == '\0') {
		tagarg = argc > 0 && search.argmode == ARG_EXPR ?
		    strchr(*argv, '=') : NULL;
		conf.output.tag = tagarg == NULL ? *argv : tagarg + 1;
	}

	/* Read the configuration file. */

	if (search.argmode != ARG_FILE ||
	    mandoc_msg_getmin() == MANDOCERR_STYLE)
		manconf_parse(&conf, conf_file, defpaths, auxpaths);

	/* man(1): Resolve each name individually. */

	if (search.argmode == ARG_NAME) {
		if (argc < 1) {
			if (outmode != OUTMODE_FLN)
				usage(ARG_NAME);
			if (conf.manpath.sz == 0) {
				warnx("The manpath is empty.");
				mandoc_msg_setrc(MANDOCLEVEL_BADARG);
			} else {
				for (i = 0; i + 1 < conf.manpath.sz; i++)
					printf("%s:", conf.manpath.paths[i]);
				printf("%s\n", conf.manpath.paths[i]);
			}
			manconf_free(&conf);
			return (int)mandoc_msg_getrc();
		}
		for (res = NULL, ressz = 0; argc > 0; argc--, argv++) {
			(void)mansearch(&search, &conf.manpath,
			    1, argv, &resn, &resnsz);
			if (resnsz == 0)
				(void)fs_search(&search, &conf.manpath,
				    *argv, &resn, &resnsz);
			if (resnsz == 0 && strchr(*argv, '/') == NULL) {
				if (search.arch != NULL &&
				    arch_valid(search.arch, OSENUM) == 0)
					warnx("Unknown architecture \"%s\".",
					    search.arch);
				else if (search.sec != NULL)
					warnx("No entry for %s in "
					    "section %s of the manual.",
					    *argv, search.sec);
				else
					warnx("No entry for %s in "
					    "the manual.", *argv);
				mandoc_msg_setrc(MANDOCLEVEL_BADARG);
				continue;
			}
			if (resnsz == 0) {
				if (access(*argv, R_OK) == -1) {
					mandoc_msg_setinfilename(*argv);
					mandoc_msg(MANDOCERR_BADARG_BAD,
					    0, 0, "%s", strerror(errno));
					mandoc_msg_setinfilename(NULL);
					continue;
				}
				resnsz = 1;
				resn = mandoc_calloc(resnsz, sizeof(*res));
				resn->file = mandoc_strdup(*argv);
				resn->ipath = SIZE_MAX;
				resn->form = FORM_SRC;
			}
			if (outmode != OUTMODE_ONE || resnsz == 1) {
				res = mandoc_reallocarray(res,
				    ressz + resnsz, sizeof(*res));
				memcpy(res + ressz, resn,
				    sizeof(*resn) * resnsz);
				ressz += resnsz;
				continue;
			}

			/* Search for the best section. */

			best_prio = 40;
			for (ib = i = 0; i < resnsz; i++) {
				sec = resn[i].file;
				sec += strcspn(sec, "123456789");
				if (sec[0] == '\0')
					continue; /* No section at all. */
				prio = sec_prios[sec[0] - '1'];
				if (search.sec != NULL) {
					ssz = strlen(search.sec);
					if (strncmp(sec, search.sec, ssz) == 0)
						sec += ssz;
				} else
					sec++; /* Prefer without suffix. */
				if (*sec != '/')
					prio += 10; /* Wrong dir name. */
				if (search.sec != NULL) {
					ep = strchr(sec, '\0');
					if (ep - sec > 3 &&
					    strncmp(ep - 3, ".gz", 3) == 0)
						ep -= 3;
					if ((size_t)(ep - sec) < ssz + 3 ||
					    strncmp(ep - ssz, search.sec,
					     ssz) != 0)      /* Wrong file */
						prio += 20;  /* extension. */
				}
				if (prio >= best_prio)
					continue;
				best_prio = prio;
				ib = i;
			}
			res = mandoc_reallocarray(res, ressz + 1,
			    sizeof(*res));
			memcpy(res + ressz++, resn + ib, sizeof(*resn));
		}

	/* apropos(1), whatis(1): Process the full search expression. */

	} else if (search.argmode != ARG_FILE) {
		if (mansearch(&search, &conf.manpath,
		    argc, argv, &res, &ressz) == 0)
			usage(search.argmode);

		if (ressz == 0) {
			warnx("nothing appropriate");
			mandoc_msg_setrc(MANDOCLEVEL_BADARG);
			goto out;
		}

	/* mandoc(1): Take command line arguments as file names. */

	} else {
		ressz = argc > 0 ? argc : 1;
		res = mandoc_calloc(ressz, sizeof(*res));
		for (i = 0; i < ressz; i++) {
			if (argc > 0)
				res[i].file = mandoc_strdup(argv[i]);
			res[i].ipath = SIZE_MAX;
			res[i].form = FORM_SRC;
		}
	}

	switch (outmode) {
	case OUTMODE_FLN:
		for (i = 0; i < ressz; i++)
			puts(res[i].file);
		goto out;
	case OUTMODE_LST:
		for (i = 0; i < ressz; i++)
			printf("%s - %s\n", res[i].names,
			    res[i].output == NULL ? "" :
			    res[i].output);
		goto out;
	default:
		break;
	}

	if (search.argmode == ARG_FILE && auxpaths != NULL) {
		if (strcmp(auxpaths, "doc") == 0)
			options |= MPARSE_MDOC;
		else if (strcmp(auxpaths, "an") == 0)
			options |= MPARSE_MAN;
	}

	mchars_alloc();
	mp = mparse_alloc(options, os_e, os_s);

	/*
	 * Remember the original working directory, if possible.
	 * This will be needed if some names on the command line
	 * are page names and some are relative file names.
	 * Do not error out if the current directory is not
	 * readable: Maybe it won't be needed after all.
	 */
	startdir = open(".", O_RDONLY | O_DIRECTORY);
	for (i = 0; i < ressz; i++) {
		process_onefile(mp, res + i, startdir, &outst, &conf);
		if (outst.wstop && mandoc_msg_getrc() != MANDOCLEVEL_OK)
			break;
	}
	if (startdir != -1) {
		(void)fchdir(startdir);
		close(startdir);
	}
	if (conf.output.tag != NULL && conf.output.tag_found == 0) {
		mandoc_msg(MANDOCERR_TAG, 0, 0, "%s", conf.output.tag);
		conf.output.tag = NULL;
	}
	if (outst.outdata != NULL) {
		switch (outst.outtype) {
		case OUTT_HTML:
			html_free(outst.outdata);
			break;
		case OUTT_UTF8:
		case OUTT_LOCALE:
		case OUTT_ASCII:
			ascii_free(outst.outdata);
			break;
		case OUTT_PDF:
		case OUTT_PS:
			pspdf_free(outst.outdata);
			break;
		default:
			break;
		}
	}
	mandoc_xr_free();
	mparse_free(mp);
	mchars_free();

out:
	mansearch_free(res, ressz);
	if (search.argmode != ARG_FILE)
		manconf_free(&conf);

	if (outst.tag_files != NULL) {
		if (term_tag_close() != -1 &&
		    conf.output.outfilename == NULL &&
		    conf.output.tagfilename == NULL)
			run_pager(&outst, conf.output.tag);
		term_tag_unlink();
	} else if (outst.had_output && outst.outtype != OUTT_LINT)
		mandoc_msg_summary();

	return (int)mandoc_msg_getrc();
}

static void
usage(enum argmode argmode)
{
	switch (argmode) {
	case ARG_FILE:
		fputs("usage: mandoc [-ac] [-I os=name] "
		    "[-K encoding] [-mdoc | -man] [-O options]\n"
		    "\t      [-T output] [-W level] [file ...]\n", stderr);
		break;
	case ARG_NAME:
		fputs("usage: man [-acfhklw] [-C file] [-M path] "
		    "[-m path] [-S subsection]\n"
		    "\t   [[-s] section] name ...\n", stderr);
		break;
	case ARG_WORD:
		fputs("usage: whatis [-afk] [-C file] "
		    "[-M path] [-m path] [-O outkey] [-S arch]\n"
		    "\t      [-s section] name ...\n", stderr);
		break;
	case ARG_EXPR:
		fputs("usage: apropos [-afk] [-C file] "
		    "[-M path] [-m path] [-O outkey] [-S arch]\n"
		    "\t       [-s section] expression ...\n", stderr);
		break;
	}
	exit((int)MANDOCLEVEL_BADARG);
}

static void
glob_esc(char **dst, const char *src, const char *suffix)
{
	while (*src != '\0') {
		if (strchr("*?[", *src) != NULL)
			*(*dst)++ = '\\';
		*(*dst)++ = *src++;
	}
	while (*suffix != '\0')
		*(*dst)++ = *suffix++;
}

static void
fs_append(char **file, size_t filesz, int copy, size_t ipath,
    const char *sec, enum form form, struct manpage **res, size_t *ressz)
{
	struct manpage	*page;

	*res = mandoc_reallocarray(*res, *ressz + filesz, sizeof(**res));
	page = *res + *ressz;
	*ressz += filesz;
	for (;;) {
		page->file = copy ? mandoc_strdup(*file) : *file;
		page->names = NULL;
		page->output = NULL;
		page->bits = NAME_FILE & NAME_MASK;
		page->ipath = ipath;
		page->sec = (*sec >= '1' && *sec <= '9') ? *sec - '1' + 1 : 10;
		page->form = form;
		if (--filesz == 0)
			break;
		file++;
		page++;
	}
}

static int
fs_lookup(const struct manpaths *paths, size_t ipath,
	const char *sec, const char *arch, const char *name,
	struct manpage **res, size_t *ressz)
{
	struct stat	 sb;
	glob_t		 globinfo;
	char		*file, *cp, secnum[2];
	int		 globres;
	enum form	 form;

	const char *const slman = "/man";
	const char *const slash = "/";
	const char *const sglob = ".[01-9]*";
	const char *const dot   = ".";
	const char *const aster = "*";

	memset(&globinfo, 0, sizeof(globinfo));
	form = FORM_SRC;

	mandoc_asprintf(&file, "%s/man%s/%s.%s",
	    paths->paths[ipath], sec, name, sec);
	if (stat(file, &sb) != -1)
		goto found;
	free(file);

	mandoc_asprintf(&file, "%s/cat%s/%s.0",
	    paths->paths[ipath], sec, name);
	if (stat(file, &sb) != -1) {
		form = FORM_CAT;
		goto found;
	}
	free(file);

	if (arch != NULL) {
		mandoc_asprintf(&file, "%s/man%s/%s/%s.%s",
		    paths->paths[ipath], sec, arch, name, sec);
		if (stat(file, &sb) != -1)
			goto found;
		free(file);
	}

	cp = file = mandoc_malloc(strlen(paths->paths[ipath]) * 2 +
	    strlen(slman) + strlen(sec) * 2 + strlen(slash) +
	    strlen(name) * 2 + strlen(sglob) + 1);
	glob_esc(&cp, paths->paths[ipath], slman);
	glob_esc(&cp, sec, slash);
	glob_esc(&cp, name, sglob);
	*cp = '\0';
	globres = glob(file, 0, NULL, &globinfo);
	if (globres != 0 && globres != GLOB_NOMATCH)
		mandoc_msg(MANDOCERR_GLOB, 0, 0,
		    "%s: %s", file, strerror(errno));
	free(file);
	file = NULL;
	if (globres == 0)
		goto found;
	globfree(&globinfo);

	if (sec[1] != '\0' && *ressz == 0) {
		secnum[0] = sec[0];
		secnum[1] = '\0';
		cp = file = mandoc_malloc(strlen(paths->paths[ipath]) * 2 +
		    strlen(slman) + strlen(secnum) * 2 + strlen(slash) +
		    strlen(name) * 2 + strlen(dot) +
		    strlen(sec) * 2 + strlen(aster) + 1);
		glob_esc(&cp, paths->paths[ipath], slman);
		glob_esc(&cp, secnum, slash);
		glob_esc(&cp, name, dot);
		glob_esc(&cp, sec, aster);
		*cp = '\0';
		globres = glob(file, 0, NULL, &globinfo);
		if (globres != 0 && globres != GLOB_NOMATCH)
			mandoc_msg(MANDOCERR_GLOB, 0, 0,
			    "%s: %s", file, strerror(errno));
		free(file);
		file = NULL;
		if (globres == 0)
			goto found;
		globfree(&globinfo);
	}

	if (res != NULL || ipath + 1 != paths->sz)
		return -1;

	mandoc_asprintf(&file, "%s.%s", name, sec);
	globres = stat(file, &sb);
	free(file);
	return globres;

found:
	warnx("outdated mandoc.db lacks %s(%s) entry, run %s %s",
	    name, sec, BINM_MAKEWHATIS, paths->paths[ipath]);
	if (res == NULL)
		free(file);
	else if (file == NULL)
		fs_append(globinfo.gl_pathv, globinfo.gl_pathc, 1,
		    ipath, sec, form, res, ressz);
	else
		fs_append(&file, 1, 0, ipath, sec, form, res, ressz);
	globfree(&globinfo);
	return 0;
}

static int
fs_search(const struct mansearch *cfg, const struct manpaths *paths,
	const char *name, struct manpage **res, size_t *ressz)
{
	const char *const sections[] =
	    {"1", "8", "6", "2", "3", "5", "7", "4", "9", "3p"};
	const size_t nsec = sizeof(sections)/sizeof(sections[0]);

	size_t		 ipath, isec;

	assert(cfg->argmode == ARG_NAME);
	if (res != NULL)
		*res = NULL;
	*ressz = 0;
	for (ipath = 0; ipath < paths->sz; ipath++) {
		if (cfg->sec != NULL) {
			if (fs_lookup(paths, ipath, cfg->sec, cfg->arch,
			    name, res, ressz) != -1 && cfg->firstmatch)
				return 0;
		} else {
			for (isec = 0; isec < nsec; isec++)
				if (fs_lookup(paths, ipath, sections[isec],
				    cfg->arch, name, res, ressz) != -1 &&
				    cfg->firstmatch)
					return 0;
		}
	}
	return -1;
}

static void
process_onefile(struct mparse *mp, struct manpage *resp, int startdir,
    struct outstate *outst, struct manconf *conf)
{
	int	 fd;

	/*
	 * Changing directories is not needed in ARG_FILE mode.
	 * Do it on a best-effort basis.  Even in case of
	 * failure, some functionality may still work.
	 */
	if (resp->ipath != SIZE_MAX)
		(void)chdir(conf->manpath.paths[resp->ipath]);
	else if (startdir != -1)
		(void)fchdir(startdir);

	mandoc_msg_setinfilename(resp->file);
	if (resp->file != NULL) {
		if ((fd = mparse_open(mp, resp->file)) == -1) {
			mandoc_msg(resp->ipath == SIZE_MAX ?
			    MANDOCERR_BADARG_BAD : MANDOCERR_OPEN,
			    0, 0, "%s", strerror(errno));
			mandoc_msg_setinfilename(NULL);
			return;
		}
	} else
		fd = STDIN_FILENO;

	if (outst->use_pager) {
		outst->use_pager = 0;
		outst->tag_files = term_tag_init(conf->output.outfilename,
		    outst->outtype == OUTT_HTML ? ".html" : "",
		    conf->output.tagfilename);
#if HAVE_PLEDGE
		if ((conf->output.outfilename != NULL ||
		     conf->output.tagfilename != NULL) &&
		    pledge("stdio rpath cpath", NULL) == -1) {
			mandoc_msg(MANDOCERR_PLEDGE, 0, 0,
			    "%s", strerror(errno));
			exit(mandoc_msg_getrc());
		}
#endif
	}
	if (outst->had_output && outst->outtype <= OUTT_UTF8) {
		if (outst->outdata == NULL)
			outdata_alloc(outst, &conf->output);
		terminal_sepline(outst->outdata);
	}

	if (resp->form == FORM_SRC)
		parse(mp, fd, resp->file, outst, conf);
	else {
		passthrough(fd, conf->output.synopsisonly);
		outst->had_output = 1;
	}

	if (ferror(stdout)) {
		if (outst->tag_files != NULL) {
			mandoc_msg(MANDOCERR_WRITE, 0, 0, "%s: %s",
			    outst->tag_files->ofn, strerror(errno));
			term_tag_unlink();
			outst->tag_files = NULL;
		} else
			mandoc_msg(MANDOCERR_WRITE, 0, 0, "%s",
			    strerror(errno));
	}
	mandoc_msg_setinfilename(NULL);
}

static void
parse(struct mparse *mp, int fd, const char *file,
    struct outstate *outst, struct manconf *conf)
{
	static struct manpaths	 basepaths;
	static int		 previous;
	struct roff_meta	*meta;

	assert(fd >= 0);
	if (file == NULL)
		file = "<stdin>";

	if (previous)
		mparse_reset(mp);
	else
		previous = 1;

	mparse_readfd(mp, fd, file);
	if (fd != STDIN_FILENO)
		close(fd);

	/*
	 * With -Wstop and warnings or errors of at least the requested
	 * level, do not produce output.
	 */

	if (outst->wstop && mandoc_msg_getrc() != MANDOCLEVEL_OK)
		return;

	if (outst->outdata == NULL)
		outdata_alloc(outst, &conf->output);
	else if (outst->outtype == OUTT_HTML)
		html_reset(outst->outdata);

	mandoc_xr_reset();
	meta = mparse_result(mp);

	/* Execute the out device, if it exists. */

	outst->had_output = 1;
	if (meta->macroset == MACROSET_MDOC) {
		switch (outst->outtype) {
		case OUTT_HTML:
			html_mdoc(outst->outdata, meta);
			break;
		case OUTT_TREE:
			tree_mdoc(outst->outdata, meta);
			break;
		case OUTT_MAN:
			man_mdoc(outst->outdata, meta);
			break;
		case OUTT_PDF:
		case OUTT_ASCII:
		case OUTT_UTF8:
		case OUTT_LOCALE:
		case OUTT_PS:
			terminal_mdoc(outst->outdata, meta);
			break;
		case OUTT_MARKDOWN:
			markdown_mdoc(outst->outdata, meta);
			break;
		default:
			break;
		}
	}
	if (meta->macroset == MACROSET_MAN) {
		switch (outst->outtype) {
		case OUTT_HTML:
			html_man(outst->outdata, meta);
			break;
		case OUTT_TREE:
			tree_man(outst->outdata, meta);
			break;
		case OUTT_MAN:
			mparse_copy(mp);
			break;
		case OUTT_PDF:
		case OUTT_ASCII:
		case OUTT_UTF8:
		case OUTT_LOCALE:
		case OUTT_PS:
			terminal_man(outst->outdata, meta);
			break;
		case OUTT_MARKDOWN:
			mandoc_msg(MANDOCERR_MAN_TMARKDOWN, 0, 0, NULL);
			break;
		default:
			break;
		}
	}
	if (conf->output.tag != NULL && conf->output.tag_found == 0 &&
	    tag_exists(conf->output.tag))
		conf->output.tag_found = 1;

	if (mandoc_msg_getmin() < MANDOCERR_STYLE) {
		if (basepaths.sz == 0)
			manpath_base(&basepaths);
		check_xr(&basepaths);
	} else if (mandoc_msg_getmin() < MANDOCERR_WARNING)
		check_xr(&conf->manpath);
}

static void
check_xr(struct manpaths *paths)
{
	struct mansearch	 search;
	struct mandoc_xr	*xr;
	size_t			 sz;

	for (xr = mandoc_xr_get(); xr != NULL; xr = xr->next) {
		if (xr->line == -1)
			continue;
		search.arch = NULL;
		search.sec = xr->sec;
		search.outkey = NULL;
		search.argmode = ARG_NAME;
		search.firstmatch = 1;
		if (mansearch(&search, paths, 1, &xr->name, NULL, &sz))
			continue;
		if (fs_search(&search, paths, xr->name, NULL, &sz) != -1)
			continue;
		if (xr->count == 1)
			mandoc_msg(MANDOCERR_XR_BAD, xr->line,
			    xr->pos + 1, "Xr %s %s", xr->name, xr->sec);
		else
			mandoc_msg(MANDOCERR_XR_BAD, xr->line,
			    xr->pos + 1, "Xr %s %s (%d times)",
			    xr->name, xr->sec, xr->count);
	}
}

static void
outdata_alloc(struct outstate *outst, struct manoutput *outconf)
{
	switch (outst->outtype) {
	case OUTT_HTML:
		outst->outdata = html_alloc(outconf);
		break;
	case OUTT_UTF8:
		outst->outdata = utf8_alloc(outconf);
		break;
	case OUTT_LOCALE:
		outst->outdata = locale_alloc(outconf);
		break;
	case OUTT_ASCII:
		outst->outdata = ascii_alloc(outconf);
		break;
	case OUTT_PDF:
		outst->outdata = pdf_alloc(outconf);
		break;
	case OUTT_PS:
		outst->outdata = ps_alloc(outconf);
		break;
	default:
		break;
	}
}

static void
passthrough(int fd, int synopsis_only)
{
	const char	 synb[] = "S\bSY\bYN\bNO\bOP\bPS\bSI\bIS\bS";
	const char	 synr[] = "SYNOPSIS";

	FILE		*stream;
	char		*line, *cp;
	size_t		 linesz;
	ssize_t		 len, written;
	int		 lno, print;

	stream = NULL;
	line = NULL;
	linesz = 0;

	if (fflush(stdout) == EOF) {
		mandoc_msg(MANDOCERR_FFLUSH, 0, 0, "%s", strerror(errno));
		goto done;
	}
	if ((stream = fdopen(fd, "r")) == NULL) {
		close(fd);
		mandoc_msg(MANDOCERR_FDOPEN, 0, 0, "%s", strerror(errno));
		goto done;
	}

	lno = print = 0;
	while ((len = getline(&line, &linesz, stream)) != -1) {
		lno++;
		cp = line;
		if (synopsis_only) {
			if (print) {
				if ( ! isspace((unsigned char)*cp))
					goto done;
				while (isspace((unsigned char)*cp)) {
					cp++;
					len--;
				}
			} else {
				if (strcmp(cp, synb) == 0 ||
				    strcmp(cp, synr) == 0)
					print = 1;
				continue;
			}
		}
		for (; len > 0; len -= written) {
			if ((written = write(STDOUT_FILENO, cp, len)) == -1) {
				mandoc_msg(MANDOCERR_WRITE, 0, 0,
				    "%s", strerror(errno));
				goto done;
			}
		}
	}
	if (ferror(stream))
		mandoc_msg(MANDOCERR_GETLINE, lno, 0, "%s", strerror(errno));

done:
	free(line);
	if (stream != NULL)
		fclose(stream);
}

static int
woptions(char *arg, enum mandoc_os *os_e, int *wstop)
{
	char		*v, *o;
	const char	*toks[11];

	toks[0] = "stop";
	toks[1] = "all";
	toks[2] = "base";
	toks[3] = "style";
	toks[4] = "warning";
	toks[5] = "error";
	toks[6] = "unsupp";
	toks[7] = "fatal";
	toks[8] = "openbsd";
	toks[9] = "netbsd";
	toks[10] = NULL;

	while (*arg) {
		o = arg;
		switch (getsubopt(&arg, (char * const *)toks, &v)) {
		case 0:
			*wstop = 1;
			break;
		case 1:
		case 2:
			mandoc_msg_setmin(MANDOCERR_BASE);
			break;
		case 3:
			mandoc_msg_setmin(MANDOCERR_STYLE);
			break;
		case 4:
			mandoc_msg_setmin(MANDOCERR_WARNING);
			break;
		case 5:
			mandoc_msg_setmin(MANDOCERR_ERROR);
			break;
		case 6:
			mandoc_msg_setmin(MANDOCERR_UNSUPP);
			break;
		case 7:
			mandoc_msg_setmin(MANDOCERR_BADARG);
			break;
		case 8:
			mandoc_msg_setmin(MANDOCERR_BASE);
			*os_e = MANDOC_OS_OPENBSD;
			break;
		case 9:
			mandoc_msg_setmin(MANDOCERR_BASE);
			*os_e = MANDOC_OS_NETBSD;
			break;
		default:
			mandoc_msg(MANDOCERR_BADARG_BAD, 0, 0, "-W %s", o);
			return -1;
		}
	}
	return 0;
}

/*
 * Wait until moved to the foreground,
 * then fork the pager and wait for the user to close it.
 */
static void
run_pager(struct outstate *outst, char *tag_target)
{
	int	 signum, status;
	pid_t	 man_pgid, tc_pgid;
	pid_t	 pager_pid, wait_pid;

	man_pgid = getpgid(0);
	outst->tag_files->tcpgid =
	    man_pgid == getpid() ? getpgid(getppid()) : man_pgid;
	pager_pid = 0;
	signum = SIGSTOP;

	for (;;) {
		/* Stop here until moved to the foreground. */

		tc_pgid = tcgetpgrp(STDOUT_FILENO);
		if (tc_pgid != man_pgid) {
			if (tc_pgid == pager_pid) {
				(void)tcsetpgrp(STDOUT_FILENO, man_pgid);
				if (signum == SIGTTIN)
					continue;
			} else
				outst->tag_files->tcpgid = tc_pgid;
			kill(0, signum);
			continue;
		}

		/* Once in the foreground, activate the pager. */

		if (pager_pid) {
			(void)tcsetpgrp(STDOUT_FILENO, pager_pid);
			kill(pager_pid, SIGCONT);
		} else
			pager_pid = spawn_pager(outst, tag_target);

		/* Wait for the pager to stop or exit. */

		while ((wait_pid = waitpid(pager_pid, &status,
		    WUNTRACED)) == -1 && errno == EINTR)
			continue;

		if (wait_pid == -1) {
			mandoc_msg(MANDOCERR_WAIT, 0, 0,
			    "%s", strerror(errno));
			break;
		}
		if (!WIFSTOPPED(status))
			break;

		signum = WSTOPSIG(status);
	}
}

static pid_t
spawn_pager(struct outstate *outst, char *tag_target)
{
	const struct timespec timeout = { 0, 100000000 };  /* 0.1s */
#define MAX_PAGER_ARGS 16
	char		*argv[MAX_PAGER_ARGS];
	const char	*pager;
	char		*cp;
#if HAVE_LESS_T
	size_t		 cmdlen;
#endif
	int		 argc, use_ofn;
	pid_t		 pager_pid;

	assert(outst->tag_files->ofd == -1);
	assert(outst->tag_files->tfs == NULL);

	pager = getenv("MANPAGER");
	if (pager == NULL || *pager == '\0')
		pager = getenv("PAGER");
	if (pager == NULL || *pager == '\0')
		pager = BINM_PAGER;
	cp = mandoc_strdup(pager);

	/*
	 * Parse the pager command into words.
	 * Intentionally do not do anything fancy here.
	 */

	argc = 0;
	while (argc + 5 < MAX_PAGER_ARGS) {
		argv[argc++] = cp;
		cp = strchr(cp, ' ');
		if (cp == NULL)
			break;
		*cp++ = '\0';
		while (*cp == ' ')
			cp++;
		if (*cp == '\0')
			break;
	}

	/* For less(1), use the tag file. */

	use_ofn = 1;
#if HAVE_LESS_T
	if (*outst->tag_files->tfn != '\0' &&
	    (cmdlen = strlen(argv[0])) >= 4) {
		cp = argv[0] + cmdlen - 4;
		if (strcmp(cp, "less") == 0) {
			argv[argc++] = mandoc_strdup("-T");
			argv[argc++] = outst->tag_files->tfn;
			if (tag_target != NULL) {
				argv[argc++] = mandoc_strdup("-t");
				argv[argc++] = tag_target;
				use_ofn = 0;
			}
		}
	}
#endif
	if (use_ofn) {
		if (outst->outtype == OUTT_HTML && tag_target != NULL)
			mandoc_asprintf(&argv[argc], "file://%s#%s",
			    outst->tag_files->ofn, tag_target);
		else
			argv[argc] = outst->tag_files->ofn;
		argc++;
	}
	argv[argc] = NULL;

	switch (pager_pid = fork()) {
	case -1:
		mandoc_msg(MANDOCERR_FORK, 0, 0, "%s", strerror(errno));
		exit(mandoc_msg_getrc());
	case 0:
		break;
	default:
		(void)setpgid(pager_pid, 0);
		(void)tcsetpgrp(STDOUT_FILENO, pager_pid);
#if HAVE_PLEDGE
		if (pledge("stdio rpath tmppath tty proc", NULL) == -1) {
			mandoc_msg(MANDOCERR_PLEDGE, 0, 0,
			    "%s", strerror(errno));
			exit(mandoc_msg_getrc());
		}
#endif
		outst->tag_files->pager_pid = pager_pid;
		return pager_pid;
	}

	/*
	 * The child process becomes the pager.
	 * Do not start it before controlling the terminal.
	 */

	while (tcgetpgrp(STDOUT_FILENO) != getpid())
		nanosleep(&timeout, NULL);

	execvp(argv[0], argv);
	mandoc_msg(MANDOCERR_EXEC, 0, 0, "%s: %s", argv[0], strerror(errno));
	_exit(mandoc_msg_getrc());
}



/* ============================================================================
 * SOURCE 48/98: minix4\exokernel\kernel_legacy\cmd\oawk\main.c
 * Size: 4,064 bytes, Lines: 162
 * Hash: 9026160b9e85...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright 1999 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

/*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved  	*/

#include <stdio.h>
#include <ctype.h>
#include "awk.def"
#include "awk.h"
#include <wctype.h>
#include <getwidth.h>
#include <langinfo.h>
#include <stdlib.h>

int	dbg	= 0;
int	svargc;
wchar_t **svargv;
eucwidth_t eucwidth;

extern FILE	*yyin;	/* lex input file */
wchar_t *lexprog;	/* points to program argument if it exists */
extern	int errorflag;	/* non-zero if any syntax errors; set by yyerror */

wchar_t	radixpoint = L'.';

int filefd, symnum, ansfd;
extern int maxsym, errno;

extern void run(NODE *a);
extern void syminit(void);

int
main(int argc, char *argv[])
{
	wchar_t	*p, **wargv;
	int i;
	static wchar_t L_dash[] = L"-";
	static wchar_t L_dashd[] = L"-d";
	char	*nl_radix;

	/*
	 * At this point, numbers are still scanned as in
	 * the POSIX locale.
	 * (POSIX.2, volume 2, P867, L4742-4757)
	 */
	(void) setlocale(LC_ALL, "");
	(void) setlocale(LC_NUMERIC, "C");
#ifndef	TEXT_DOMAIN
#define	TEXT_DOMAIN	"SYS_TEST"
#endif

	textdomain(TEXT_DOMAIN);

	getwidth(&eucwidth);
	if (argc == 1) {
		fprintf(stderr,
gettext("awk: Usage: awk [-Fc] [-f source | 'cmds'] [files]\n"));
		exit(2);
	}
	syminit();
	if ((wargv = (wchar_t **)malloc((argc+1) * sizeof (wchar_t *))) == NULL)
		error(FATAL, "Insuffcient memory on argv");
	for (i = 0; i < argc; i++) {
		if ((p = (wchar_t *)malloc((strlen(argv[i]) + 1)
						* sizeof (wchar_t))) == NULL)
			error(FATAL, "Insuffcient memory on argv");
		mbstowcs(p, argv[i], strlen(argv[i]) + 1);
		wargv[i] = p;
	}
	wargv[argc] = NULL;
	while (argc > 1) {
		argc--;
		wargv++;
		/* this nonsense is because gcos argument handling */
		/* folds -F into -f.  accordingly, one checks the next */
		/* character after f to see if it's -f file or -Fx. */
		if (wargv[0][0] == L'-' && wargv[0][1] == L'f' &&
			wargv[0][2] == 0) {
			if (argc <= 1)
				error(FATAL, "no argument for -f");
			yyin = (wscmp(wargv[1], L_dash) == 0)
					? stdin
					: fopen(toeuccode(wargv[1]), "r");
			if (yyin == NULL)
				error(FATAL, "can't open %ws", wargv[1]);
			argc--;
			wargv++;
			break;
		} else if (wargv[0][0] == L'-' && wargv[0][1] == L'F') {
			if (wargv[0][2] == L't')
				**FS = L'\t';
			else
				/* set field sep */
				**FS = wargv[0][2];
			continue;
		} else if (wargv[0][0] != L'-') {
			dprintf("cmds=|%ws|\n", wargv[0], NULL, NULL);
			yyin = NULL;
			lexprog = wargv[0];
			wargv[0] = wargv[-1];   /* need this space */
			break;
		} else if (wscmp(L_dashd, wargv[0]) == 0) {
			dbg = 1;
		}
	}
	if (argc <= 1) {
		wargv[0][0] = L'-';
		wargv[0][1] = 0;
		argc++;
		wargv--;
	}
	svargc = --argc;
	svargv = ++wargv;
	dprintf("svargc=%d svargv[0]=%ws\n", svargc, svargv[0], NULL);
	*FILENAME = *svargv;    /* initial file name */
	yyparse();
	dprintf("errorflag=%d\n", errorflag, NULL, NULL);
	/*
	 * done parsing, so now activate the LC_NUMERIC
	 */
	(void) setlocale(LC_ALL, "");
	nl_radix = nl_langinfo(RADIXCHAR);
	if (nl_radix) {
		radixpoint = (wchar_t)*nl_radix;
	}
	if (errorflag)
		exit(errorflag);
	run(winner);
	return (errorflag);
}

int
yywrap()
{
	return (1);
}



/* ============================================================================
 * SOURCE 49/98: minix4\exokernel\kernel_legacy\cmd\praudit\main.c
 * Size: 5,642 bytes, Lines: 238
 * Hash: 18823099aa90...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2019 Peter Tribble.
 */
/*
 * Copyright (c) 1992, 2010, Oracle and/or its affiliates. All rights reserved.
 */

#include <dirent.h>
#include <errno.h>
#include <locale.h>
#include <libintl.h>
#include <stdlib.h>
#include <strings.h>
#include <stdio.h>
#include <unistd.h>

#include <sys/types.h>
#include <sys/file.h>

#include <bsm/audit.h>
#include <bsm/audit_record.h>
#include <bsm/libbsm.h>

#include "praudit.h"
#include "toktable.h"

static int	process_options(int *argc, char *argv[], char *names[]);

static int	input_mode;	/* audit file source */
static int	format = PRF_DEFAULTM;	/* output mode */

static char	SEPARATOR[SEP_SIZE] = ",";	/* field separator */

static FILE	*gf = NULL;
static FILE	*pf = NULL;

/*
 * ----------------------------------------------------------------------
 * praudit  -  display contents of audit trail file
 *
 * main() - main control
 * input: - command line input:
 *    praudit -r|s -l -x -ddelim. -p pwfile -g grpfile -c filename(s)
 * ----------------------------------------------------------------------
 */

int
main(int argc, char **argv)
{
	int	i = 0, retstat;
	char	*names[MAXFILENAMES];

	/* Internationalization */
	(void) setlocale(LC_ALL, "");
	(void) textdomain(TEXT_DOMAIN);
	/*
	 * get audit file names
	 */
	if ((retstat = process_options(&argc, argv, names)) == 0) {
		if (pf != NULL) {
			errno = 0;
			loadnames(pf);
			(void) fclose(pf);
			if (errno != 0) {
				(void) fprintf(stderr,
				    gettext("praudit: Problem reading passwd "
				    "file.\n"));
				exit(1);
			}
		}
		if (gf != NULL) {
			errno = 0;
			loadgroups(gf);
			(void) fclose(gf);
			if (errno != 0) {
				(void) fprintf(stderr,
				    gettext("praudit: Problem reading group "
				    "file.\n"));
				exit(1);
			}
		}
		if (format & PRF_XMLM)
			print_audit_xml_prolog();
		do {
			retstat = 0;
			/*
			 * process each audit file
			 */
			if (input_mode == FILEMODE) {
				if (freopen(names[i], "r", stdin) == NULL) {
					(void) fprintf(stderr,
					    gettext("praudit: Cannot associate "
					    "stdin with %s: %s\n"),
					    names[i], strerror(errno));
					exit(1);
				}
			}

			/*
			 * Call the library routine to format the
			 * audit data from stdin and print to stdout
			 */
			retstat = print_audit(format, SEPARATOR);

		} while ((++i < argc) && retstat >= 0);
	}
	if ((retstat == 0) && (format & PRF_XMLM))
		print_audit_xml_ending();

	if (retstat == -2) {
		(void) printf(gettext("\nusage: praudit [-r/-s] [-l] [-x] "
		    "[-ddel] [-p file] [-g file] [-c] filename...\n"));
		exit(1);
	} else if (retstat < 0) {
		exit(1);
	}
	return (0);
}


/*
 * -------------------------------------------------------------------
 * process_options() - get command line flags and file names
 * input:    - praudit [-r]/[-s] [-l] [-x] [-ddel] [-c]
 *                     -p pwfile -g grpfile -c {audit file names}
 * output:   - {audit file names}
 * globals set:	format:		RAWM / SHORTM / XML / ONELINE or DEFAULTM
 *			SEPARATOR:  default, ",", set here if
 *				user specified
 * NOTE: no changes required here for new audit record format
 * -------------------------------------------------------------------
 */
int
process_options(int *argc, char **argv, char **names)
{
	int	c, returnstat = 0;

	/*
	 * check for flags
	 */

	while ((c = getopt(*argc, argv, "crslxd:g:p:")) != -1) {
		switch (c) {
		case 'c':
			format |= PRF_NOCACHE;	/* turn off cache */
			break;
		case 'r':
			if (format & PRF_SHORTM)
				returnstat = -2;
			else
				format |= PRF_RAWM;
			break;
		case 's':
			if (format & PRF_RAWM)
				returnstat = -2;
			else
				format |= PRF_SHORTM;
			break;
		case 'l':
			format |= PRF_ONELINE;
			break;
		case 'x':
			format |= PRF_XMLM;
			break;
		case 'd':
			if (strlen(optarg) < sizeof (SEPARATOR))
				(void) strlcpy(SEPARATOR, optarg,
				    sizeof (SEPARATOR));
			else {
				(void) fprintf(stderr,
				    gettext("praudit: Delimiter too "
				    "long.  Using default.\n"));
			}
			break;
		case 'g':
			if ((gf = fopen(optarg, "r")) == NULL) {
				(void) fprintf(stderr, gettext("praudit: Cannot"
				    " open specified group file.\n"));
				return (-1);
			}
			break;
		case 'p':
			if ((pf = fopen(optarg, "r")) == NULL) {
				(void) fprintf(stderr, gettext("praudit: Cannot"
				    " open specified passwd file.\n"));
				return (-1);
			}
			break;
		default:
			returnstat = -2;
			break;
		}
	}

	argv = &argv[optind - 1];
	*argc -= optind;

	if (*argc > MAXFILENAMES) {
		(void) fprintf(stderr, gettext("praudit: Too many file "
		    "names.\n"));
		return (-1);
	}
	if (*argc > 0) {
		int count = *argc;

		input_mode = FILEMODE;
		/*
		 * copy file names from command line
		 */
		do {
			*names++ = *++argv;
		} while (--count > 0);
	} else
		input_mode = PIPEMODE;

	return (returnstat);
}



/* ============================================================================
 * SOURCE 50/98: minix4\exokernel\kernel_legacy\cmd\prtdiag\main.c
 * Size: 1,962 bytes, Lines: 89
 * Hash: 2ae69821c4b3...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (c) 1990, 2010, Oracle and/or its affiliates. All rights reserved.
 */

/*
 * Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
 * All rights reserved.
 */

#include <stdio.h>
#include <locale.h>
#include <stdlib.h>
#include <libintl.h>
#include <string.h>
#include <unistd.h>
#include <zone.h>

extern int do_prominfo(int, char *, int, int);

static char *
setpname(char *name)
{
	char	*p;

	if (p = strrchr(name, '/'))
		return (p + 1);
	else
		return (name);
}

int
main(int argc, char *argv[])
{
	int	c;
	int	syserrlog = 0;
	char	*progname = setpname(argv[0]);
	int	print_flag = 1;
	int	logging = 0;

	(void) setlocale(LC_ALL, "");
	(void) textdomain(TEXT_DOMAIN);

	if (getzoneid() != GLOBAL_ZONEID) {
		(void) fprintf(stderr,
		    gettext("%s can only be run in the global zone\n"),
		    progname);
		return (1);
	}

	while ((c = getopt(argc, argv, "vl")) != -1)  {
		switch (c)  {
		case 'v':
			++syserrlog;
			break;

		case 'l':
			logging = 1;
			break;

		default:
			(void) fprintf(stderr, "Usage: %s [-lv]\n", progname);
			return (1);
		}
	}

	return (do_prominfo(syserrlog, progname, logging, print_flag));
}



/* ============================================================================
 * SOURCE 51/98: minix4\exokernel\kernel_legacy\cmd\prtfru\main.c
 * Size: 2,613 bytes, Lines: 123
 * Hash: 12a8fd6b0537...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2002 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

#include <libintl.h>
#include <locale.h>
#include <stdio.h>

#include "libfru.h"
#include "prtfru.h"


static void
usage(const char *command)
{
	(void) fprintf(stderr,
		gettext("Usage:  %s [ -d ] | [ -clx ] [ container ]\n"),
		command);
}

int
main(int argc, char *argv[])
{
	char  *command = argv[0], *searchpath = NULL;

	int   containers_only = 0, dtd = 0, list_only = 0, nodtd = 0, option,
		status, xml = 0;


	(void) setlocale(LC_ALL, "");
	(void) textdomain(TEXT_DOMAIN);

	opterr = 0;	/*  "getopt" should not print to "stderr"  */
	while ((option = getopt(argc, argv, "cdlx")) != EOF) {
		switch (option) {
		case 'c':
			containers_only = 1;
			nodtd = 1;
			break;
		case 'd':
			dtd = 1;
			break;
		case 'l':
			list_only = 1;
			nodtd = 1;
			break;
		case 'x':
			xml = 1;
			nodtd = 1;
			break;
		default:
			usage(command);
			return (1);
		}
	}

	argc -= optind;
	argv += optind;

	if (dtd) {
		if (nodtd || (argc > 0)) {
			usage(command);
			(void) fprintf(stderr,
			    gettext("Specify \"-d\" alone\n"));
			return (1);
		}

		return (output_dtd());
	}

	switch (argc) {
	case 0:
		break;
	case 1:
		searchpath = argv[0];
		if (!searchpath[0]) {
			usage(command);
			(void) fprintf(stderr,
			    gettext("\"container\" should not be empty\n"));
			return (1);
		}
		break;
	default:
		usage(command);
		return (1);
	}


	/*
	 * Select the data source and print all the data
	 */
	if ((status = fru_open_data_source("picl")) != FRU_SUCCESS) {
		(void) fprintf(stderr,
		    gettext("Error opening FRU ID data source:  %s\n"),
		    fru_strerror(status));
		return (1);
	}

	return (prtfru(searchpath, containers_only, list_only, xml));
}



/* ============================================================================
 * SOURCE 52/98: minix4\exokernel\kernel_legacy\cmd\ramdiskadm\main.c
 * Size: 8,257 bytes, Lines: 339
 * Hash: d5eaaf7682c2...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2002-2003 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 *
 * ramdiskadm - administer ramdisk(4D). Allows creation and deletion of
 * ramdisks, and display status. All the ioctls are private between
 * ramdisk and ramdiskadm, and so are very simple - device information is
 * communicated via a name or a minor number.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/ramdisk.h>
#include <sys/stat.h>
#include <sys/mkdev.h>
#include <sys/sunddi.h>
#include <libdevinfo.h>
#include <stdio.h>
#include <fcntl.h>
#include <locale.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>
#include <unistd.h>
#include <stropts.h>
#include <ctype.h>
#include "utils.h"

#define	RD_BLOCK_DEV_PFX	"/dev/" RD_BLOCK_NAME "/"
#define	RD_CHAR_DEV_PFX		"/dev/" RD_CHAR_NAME "/"

#define	HEADING	"%-*.*s %20s  %-10s\n"
#define	FORMAT	"%-*.*s %20llu    %s\n"
#define	FW	(sizeof (RD_BLOCK_DEV_PFX) - 1 + RD_NAME_LEN)

static char *pname;

static void
usage(void)
{
	(void) fprintf(stderr,
	    gettext("Usage: %s [ -a <name> <size>[g|m|k|b] | -d <name> ]\n"),
	    pname);
	exit(E_USAGE);
}

/*
 * This might be the first time we've used this minor device. If so,
 * it might also be that the /dev links are in the process of being created
 * by devfsadmd (or that they'll be created "soon"). We cannot return
 * until they're there or the invoker of ramdiskadm might try to use them
 * and not find them. This can happen if a shell script is running on
 * an MP.
 */
static void
wait_until_dev_complete(char *name)
{
	di_devlink_handle_t hdl;

	hdl = di_devlink_init(RD_DRIVER_NAME, DI_MAKE_LINK);
	if (hdl == NULL) {
		die(gettext("couldn't create device link for\"%s\""), name);
	}
	(void) di_devlink_fini(&hdl);
}

/*
 * Create a named ramdisk.
 */
static void
alloc_ramdisk(int ctl_fd, char *name, uint64_t size)
{
	struct rd_ioctl	ri;

	(void) strlcpy(ri.ri_name, name, sizeof (ri.ri_name));
	ri.ri_size = size;

	if (ioctl(ctl_fd, RD_CREATE_DISK, &ri) == -1) {
		die(gettext("couldn't create ramdisk \"%s\""), name);
	}
	wait_until_dev_complete(name);

	(void) printf(RD_BLOCK_DEV_PFX "%s\n", name);
}

/*
 * Delete a named ramdisk.
 */
static void
delete_ramdisk(int ctl_fd, char *name)
{
	struct rd_ioctl	ri;

	(void) strlcpy(ri.ri_name, name, sizeof (ri.ri_name));

	if (ioctl(ctl_fd, RD_DELETE_DISK, &ri) == -1) {
		die(gettext("couldn't delete ramdisk \"%s\""), name);
	}
}

/*ARGSUSED*/
static int
di_callback(di_node_t node, di_minor_t minor, void *arg)
{
	static boolean_t	heading_done = B_FALSE;
	boolean_t		obp_ramdisk;
	char			*name;
	char			devnm[MAXNAMELEN];
	uint64_t		*sizep;
	char			blkpath[MAXPATHLEN];

	/*
	 * Only consider block nodes bound to the ramdisk driver.
	 */
	if (strcmp(di_driver_name(node), RD_DRIVER_NAME) == 0 &&
	    di_minor_spectype(minor) == S_IFBLK) {
		/*
		 * Determine whether this ramdisk is pseudo or OBP-created.
		 */
		obp_ramdisk = (di_nodeid(node) == DI_PROM_NODEID);

		/*
		 * If this is an OBP-created ramdisk use the node name, having
		 * first stripped the "ramdisk-" prefix.  For pseudo ramdisks
		 * use the minor name, having first stripped any ",raw" suffix.
		 */
		if (obp_ramdisk) {
			RD_STRIP_PREFIX(name, di_node_name(node));
			(void) strlcpy(devnm, name, sizeof (devnm));
		} else {
			(void) strlcpy(devnm, di_minor_name(minor),
			    sizeof (devnm));
			RD_STRIP_SUFFIX(devnm);
		}

		/*
		 * Get the size of the ramdisk.
		 */
		if (di_prop_lookup_int64(di_minor_devt(minor), node,
		    "Size", (int64_t **)&sizep) == -1) {
			die(gettext("couldn't obtain size of ramdisk"));
		}

		/*
		 * Print information about the ramdisk.  Prepend a heading
		 * if this is the first/only one.
		 */
		if (!heading_done) {
			(void) printf(HEADING, FW, FW, gettext("Block Device"),
			    gettext("Size"), gettext("Removable"));
			heading_done = B_TRUE;
		}
		(void) snprintf(blkpath, sizeof (blkpath),
		    RD_BLOCK_DEV_PFX "%s", devnm);
		(void) printf(FORMAT, FW, FW, blkpath, *sizep,
		    obp_ramdisk ? gettext("No") : gettext("Yes"));
	}

	return (DI_WALK_CONTINUE);
}

/*
 * Print the list of all the ramdisks, their size, and whether they
 * are removeable (i.e. non-OBP ramdisks).
 */
static void
print_ramdisk(void)
{
	di_node_t	root;

	/*
	 * Create a snapshot of the device tree, then walk it looking
	 * for, and printing information about, ramdisk nodes.
	 */
	if ((root = di_init("/", DINFOCPYALL)) == DI_NODE_NIL) {
		die(gettext("couldn't create device tree snapshot"));
	}

	if (di_walk_minor(root, DDI_PSEUDO, 0, NULL, di_callback) == -1) {
		di_fini(root);
		die(gettext("device tree walk failure"));
	}

	di_fini(root);
}

int
main(int argc, char *argv[])
{
	int		c;
	char		*name = NULL;
	int		allocflag = 0;
	int		deleteflag = 0;
	int		errflag = 0;
	char		*suffix;
	uint64_t	size;
	int		openflag;
	int		ctl_fd = 0;
	static char	rd_ctl[] = "/dev/" RD_CTL_NAME;

	pname = getpname(argv[0]);

	(void) setlocale(LC_ALL, "");
	(void) textdomain(TEXT_DOMAIN);

	while ((c = getopt(argc, argv, "a:d:")) != EOF) {
		switch (c) {
		case 'a':
			allocflag = 1;
			name = optarg;

			if (((argc - optind) <= 0) || (*argv[optind] == '-')) {
				warn(gettext("<size> missing\n"));
				usage();
				/*NOTREACHED*/
			}
			size = strtoll(argv[optind], &suffix, 0);
			if (strcmp(suffix, "b") == 0) {
				size *= 512;
				++suffix;
			} else if (strcmp(suffix, "k") == 0) {
				size *= 1024;
				++suffix;
			} else if (strcmp(suffix, "m") == 0) {
				size *= (1024 * 1024);
				++suffix;
			} else if (strcmp(suffix, "g") == 0) {
				size *= (1024 * 1024 * 1024);
				++suffix;
			}
			if (size == 0 || *suffix != '\0') {
				warn(gettext("Illegal <size> \"%s\"\n"),
				    argv[optind]);
				usage();
				/*NOTREACHED*/
			}
			++optind;
			break;
		case 'd':
			deleteflag = 1;
			name = optarg;
			break;
		default:
			errflag = 1;
			break;
		}
	}
	if (errflag || (allocflag && deleteflag) || (argc - optind) > 0) {
		usage();
		/*NOTREACHED*/
	}

	if (allocflag || deleteflag) {
		boolean_t	nameok = B_TRUE;
		char		*p;

		/*
		 * Strip off any leading "/dev/{r}ramdisk/" prefix.
		 */
		if (strncmp(name, RD_BLOCK_DEV_PFX,
		    sizeof (RD_BLOCK_DEV_PFX)-1) == 0) {
			name += sizeof (RD_BLOCK_DEV_PFX)-1;
		} else if (strncmp(name, RD_CHAR_DEV_PFX,
		    sizeof (RD_CHAR_DEV_PFX)-1) == 0) {
			name += sizeof (RD_CHAR_DEV_PFX)-1;
		}

		/*
		 * Check that name isn't too long, and that it only contains
		 * valid characters, i.e. [a-zA-Z0-9_][a-zA-Z0-9_-]*
		 */
		if (name[0] == '-') {		/* permit only within name */
			nameok = B_FALSE;
		} else {
			for (p = name; *p != '\0'; p++) {
				if (!isalnum(*p) && *p != '_' && *p != '-') {
					nameok = B_FALSE;
					break;
				}
			}
		}
		if (!nameok || (p - name) > RD_NAME_LEN) {
			warn(gettext("illegal <name> \"%s\"\n"), name);
			usage();
			/*NOTREACHED*/
		}
	}

	/*
	 * Now do the real work.
	 */
	openflag = O_EXCL;
	if (allocflag || deleteflag)
		openflag |= O_RDWR;
	else
		openflag |= O_RDONLY;
	ctl_fd = open(rd_ctl, openflag);
	if (ctl_fd == -1) {
		if ((errno == EPERM) || (errno == EACCES)) {
			die(gettext("you do not have permission to perform "
			    "that operation.\n"));
		} else {
			die("%s", rd_ctl);
		}
		/*NOTREACHED*/
	}

	if (allocflag) {
		alloc_ramdisk(ctl_fd, name, size);
	} else if (deleteflag) {
		delete_ramdisk(ctl_fd, name);
	} else {
		print_ramdisk();
	}

	return (E_SUCCESS);
}



/* ============================================================================
 * SOURCE 53/98: minix4\exokernel\kernel_legacy\cmd\sed\main.c
 * Size: 12,708 bytes, Lines: 542
 * Hash: e1cafb494a05...
 * ============================================================================ */

/*
 * Copyright 2020 OmniOS Community Edition (OmniOSce) Association.
 * Copyright (c) 2013 Johann 'Myrkraverk' Oskarsson <johann@myrkraverk.com>
 * Copyright (c) 2011 Gary Mills
 * Copyright 2011 Nexenta Systems, Inc. All rights reserved.
 * Copyright (c) 1992 Diomidis Spinellis.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Diomidis Spinellis of Imperial College, University of London.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/mman.h>
#include <sys/param.h>
#include <sys/stat.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <getopt.h>
#include <libgen.h>
#include <libintl.h>
#include <limits.h>
#include <locale.h>
#include <regex.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "defs.h"
#include "extern.h"

/*
 * Linked list of units (strings and files) to be compiled
 */
struct s_compunit {
	struct s_compunit *next;
	enum e_cut {CU_FILE, CU_STRING} type;
	char *s;			/* Pointer to string or fname */
};

/*
 * Linked list pointer to compilation units and pointer to current
 * next pointer.
 */
static struct s_compunit *script, **cu_nextp = &script;

/*
 * Linked list of files to be processed
 */
struct s_flist {
	char *fname;
	struct s_flist *next;
};

/*
 * Linked list pointer to files and pointer to current
 * next pointer.
 */
static struct s_flist *files, **fl_nextp = &files;

FILE *infile;			/* Current input file */
FILE *outfile;			/* Current output file */

int aflag, eflag, nflag;
int rflags = 0;
static int rval;		/* Exit status */

static int ispan;		/* Whether inplace editing spans across files */

/*
 * Current file and line number; line numbers restart across compilation
 * units, but span across input files.  The latter is optional if editing
 * in place.
 */
const char *fname;		/* File name. */
const char *outfname;		/* Output file name */
static char oldfname[PATH_MAX];	/* Old file name (for in-place editing) */
static char tmpfname[PATH_MAX];	/* Temporary file name (for in-place editing) */
static const char *inplace;	/* Inplace edit file extension. */
ulong_t linenum;

static const struct option lopts[] = {
	{"in-place",	optional_argument,	NULL,	'i'},
	{NULL,		0,			NULL,	0}
};

static void add_compunit(enum e_cut, char *);
static void add_file(char *);
static void usage(void);


int
main(int argc, char *argv[])
{
	int c, fflag;
	char *temp_arg;

	(void) setlocale(LC_ALL, "");

#ifndef TEXT_DOMAIN
#define	TEXT_DOMAIN	"SYS_TEST"
#endif
	(void) textdomain(TEXT_DOMAIN);

	fflag = 0;
	inplace = NULL;

	while ((c = getopt_long(argc, argv, "EI::ae:f:i::lnr", lopts, NULL)) !=
	    -1)
		switch (c) {
		case 'r':		/* Gnu sed compat */
		case 'E':
			rflags = REG_EXTENDED;
			break;
		case 'I':
			if (optarg != NULL)
				inplace = optarg;
			else
				inplace = "";
			ispan = 1;	/* span across input files */
			break;
		case 'a':
			aflag = 1;
			break;
		case 'e':
			eflag = 1;
			if (asprintf(&temp_arg, "%s\n", optarg) < 1)
				err(1, "asprintf");
			add_compunit(CU_STRING, temp_arg);
			break;
		case 'f':
			fflag = 1;
			add_compunit(CU_FILE, optarg);
			break;
		case 'i':
			if (optarg != NULL)
				inplace = optarg;
			else
				inplace = "";
			ispan = 0;	/* don't span across input files */
			break;
		case 'l':
			/* On SunOS, setlinebuf "returns no useful value */
			(void) setlinebuf(stdout);
			break;
		case 'n':
			nflag = 1;
			break;
		default:
		case '?':
			usage();
		}
	argc -= optind;
	argv += optind;

	/* First usage case; script is the first arg */
	if (!eflag && !fflag && *argv) {
		add_compunit(CU_STRING, *argv);
		argv++;
	}

	compile();

	/* Continue with first and start second usage */
	if (*argv)
		for (; *argv; argv++)
			add_file(*argv);
	else
		add_file(NULL);
	process();
	cfclose(prog, NULL);
	if (fclose(stdout))
		err(1, "stdout");
	return (rval);
}

static void
usage(void)
{
	(void) fputs(_("usage: sed script [-Ealn] [-i[extension]] [file...]\n"
	    "       sed [-Ealn] [-i[extension]] [-e script]... "
	    "[-f script_file]... [file...]\n"),
	    stderr);
	exit(1);
}

/*
 * Like fgets, but go through the chain of compilation units chaining them
 * together.  Empty strings and files are ignored.
 */
char *
cu_fgets(char *buf, int n, int *more)
{
	static enum {ST_EOF, ST_FILE, ST_STRING} state = ST_EOF;
	static FILE *f;		/* Current open file */
	static char *s;		/* Current pointer inside string */
	static char string_ident[30];
	char *p;

again:
	switch (state) {
	case ST_EOF:
		if (script == NULL) {
			if (more != NULL)
				*more = 0;
			return (NULL);
		}
		linenum = 0;
		switch (script->type) {
		case CU_FILE:
			if ((f = fopen(script->s, "r")) == NULL)
				err(1, "%s", script->s);
			fname = script->s;
			state = ST_FILE;
			goto again;
		case CU_STRING:
			if (((size_t)snprintf(string_ident,
			    sizeof (string_ident), "\"%s\"", script->s)) >=
			    sizeof (string_ident) - 1)
				(void) strcpy(string_ident +
				    sizeof (string_ident) - 6, " ...\"");
			fname = string_ident;
			s = script->s;
			state = ST_STRING;
			goto again;
		default:
			errx(1, "BUG: Unknown script type: %d\n", script->type);
		}
		/*NOTREACHED*/

	case ST_FILE:
		if ((p = fgets(buf, n, f)) != NULL) {
			linenum++;
			if (linenum == 1 && buf[0] == '#' && buf[1] == 'n')
				nflag = 1;
			if (more != NULL)
				*more = !feof(f);
			return (p);
		}
		script = script->next;
		(void) fclose(f);
		state = ST_EOF;
		goto again;
	case ST_STRING:
		if (linenum == 0 && s[0] == '#' && s[1] == 'n')
			nflag = 1;
		p = buf;
		for (;;) {
			if (n-- <= 1) {
				*p = '\0';
				linenum++;
				if (more != NULL)
					*more = 1;
				return (buf);
			}
			switch (*s) {
			case '\0':
				state = ST_EOF;
				if (s == script->s) {
					script = script->next;
					goto again;
				} else {
					script = script->next;
					*p = '\0';
					linenum++;
					if (more != NULL)
						*more = 0;
					return (buf);
				}
			case '\n':
				*p++ = '\n';
				*p = '\0';
				s++;
				linenum++;
				if (more != NULL)
					*more = 0;
				return (buf);
			default:
				*p++ = *s++;
			}
		}
	}
	/* NOTREACHED */
	return (NULL);
}

/*
 * Like fgets, but go through the list of files chaining them together.
 * Set len to the length of the line.
 */
int
mf_fgets(SPACE *sp, enum e_spflag spflag)
{
	struct stat sb, nsb;
	ssize_t len;
	static char *p = NULL;
	static size_t plen = 0;
	int c;
	static int firstfile;

	if (infile == NULL) {
		/* stdin? */
		if (files->fname == NULL) {
			if (inplace != NULL)
				errx(1,
				    _("-I or -i may not be used with stdin"));
			infile = stdin;
			fname = "stdin";
			outfile = stdout;
			outfname = "stdout";
		}
		firstfile = 1;
	}

	for (;;) {
		if (infile != NULL && (c = getc(infile)) != EOF) {
			(void) ungetc(c, infile);
			break;
		}
		/* If we are here then either eof or no files are open yet */
		if (infile == stdin) {
			sp->len = 0;
			return (0);
		}
		if (infile != NULL) {
			(void) fclose(infile);
			if (*oldfname != '\0') {
				/* if there was a backup file, remove it */
				(void) unlink(oldfname);
				/*
				 * Backup the original.  Note that hard links
				 * are not supported on all filesystems.
				 */
				if ((link(fname, oldfname) != 0) &&
				    (rename(fname, oldfname) != 0)) {
					warn("rename()");
					if (*tmpfname)
						(void) unlink(tmpfname);
					exit(1);
				}
				*oldfname = '\0';
			}
			if (*tmpfname != '\0') {
				if (outfile != NULL && outfile != stdout)
					if (fclose(outfile) != 0) {
						warn("fclose()");
						(void) unlink(tmpfname);
						exit(1);
					}
				outfile = NULL;
				if (rename(tmpfname, fname) != 0) {
					/* this should not happen really! */
					warn("rename()");
					(void) unlink(tmpfname);
					exit(1);
				}
				*tmpfname = '\0';
			}
			outfname = NULL;
		}
		if (firstfile == 0)
			files = files->next;
		else
			firstfile = 0;
		if (files == NULL) {
			sp->len = 0;
			return (0);
		}
		fname = files->fname;
		if (inplace != NULL) {
			char bn[PATH_MAX];
			char dn[PATH_MAX];
			(void) strlcpy(bn, fname, sizeof (bn));
			(void) strlcpy(dn, fname, sizeof (dn));
			if (lstat(fname, &sb) != 0)
				err(1, "%s", fname);
			if (!(sb.st_mode & S_IFREG))
				fatal(_("in-place editing only "
				    "works for regular files"));
			if (*inplace != '\0') {
				(void) strlcpy(oldfname, fname,
				    sizeof (oldfname));
				len = strlcat(oldfname, inplace,
				    sizeof (oldfname));
				if (len > sizeof (oldfname))
					fatal(_("name too long"));
			}
			len = snprintf(tmpfname, sizeof (tmpfname),
			    "%s/.!%ld!%s", dirname(dn), (long)getpid(),
			    basename(bn));
			if (len >= sizeof (tmpfname))
				fatal(_("name too long"));
			(void) unlink(tmpfname);
			if ((outfile = fopen(tmpfname, "w")) == NULL)
				err(1, "%s", fname);
			/*
			 * Some file systems don't support chown or
			 * chmod fully.  On those, the owner/group and
			 * permissions will already be set to what
			 * they need to be.
			 */
			if (fstat(fileno(outfile), &nsb) != 0) {
				warn("fstat()");
			}
			if (((sb.st_uid != nsb.st_uid) ||
			    (sb.st_gid != nsb.st_gid)) &&
			    (fchown(fileno(outfile), sb.st_uid, sb.st_gid)
			    != 0))
				warn("fchown()");
			if ((sb.st_mode != nsb.st_mode) &&
			    (fchmod(fileno(outfile), sb.st_mode & 07777) != 0))
				warn("fchmod()");
			outfname = tmpfname;
			if (!ispan) {
				linenum = 0;
				resetstate();
			}
		} else {
			outfile = stdout;
			outfname = "stdout";
		}
		if ((infile = fopen(fname, "r")) == NULL) {
			warn("%s", fname);
			rval = 1;
			continue;
		}
	}
	/*
	 * We are here only when infile is open and we still have something
	 * to read from it.
	 *
	 * Use getline() so that we can handle essentially infinite
	 * input data.  The p and plen are static so each invocation gives
	 * getline() the same buffer which is expanded as needed.
	 */
	len = getline(&p, &plen, infile);
	if (len == -1)
		err(1, "%s", fname);
	if (len != 0 && p[len - 1] == '\n')
		len--;
	cspace(sp, p, len, spflag);

	linenum++;

	return (1);
}

/*
 * Add a compilation unit to the linked list
 */
static void
add_compunit(enum e_cut type, char *s)
{
	struct s_compunit *cu;

	if ((cu = malloc(sizeof (struct s_compunit))) == NULL)
		err(1, "malloc");
	cu->type = type;
	cu->s = s;
	cu->next = NULL;
	*cu_nextp = cu;
	cu_nextp = &cu->next;
}

/*
 * Add a file to the linked list
 */
static void
add_file(char *s)
{
	struct s_flist *fp;

	if ((fp = malloc(sizeof (struct s_flist))) == NULL)
		err(1, "malloc");
	fp->next = NULL;
	*fl_nextp = fp;
	fp->fname = s;
	fl_nextp = &fp->next;
}

int
lastline(void)
{
	int ch;

	if (feof(infile) != 0 || (ch = getc(infile)) == EOF) {
		struct s_flist *f;

		/*
		 * Reached the end of the current input file.
		 * If there are no more that contain data, then this is the
		 * last line.
		 */
		if (inplace != NULL && ispan == 0)
			return (1);

		for (f = files->next; f != NULL; f = f->next) {
			struct stat st;

			if (stat(f->fname, &st) == -1) {
				/* Treat an error here as an empty file */
				continue;
			}
			if (st.st_size > 0)
				return (0);
		}
		return (1);
	}

	(void) ungetc(ch, infile);
	return (0);
}



/* ============================================================================
 * SOURCE 54/98: minix4\exokernel\kernel_legacy\cmd\sh\main.c
 * Size: 10,637 bytes, Lines: 591
 * Hash: 61c8db46f50a...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (c) 1988, 2010, Oracle and/or its affiliates. All rights reserved.
 */

/*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved  	*/

/*
 * UNIX shell
 */

#include	"defs.h"
#include	"sym.h"
#include	"timeout.h"
#include	<stdio.h>
#include	<sys/types.h>
#include	<sys/stat.h>
#include	<sys/wait.h>
#include	"dup.h"

#ifdef RES
#include	<sgtty.h>
#endif

pid_t mypid, mypgid, mysid;

static BOOL	beenhere = FALSE;
unsigned char	tmpout[TMPOUTSZ];
struct fileblk	stdfile;
struct fileblk *standin = &stdfile;
int mailchk = 0;

static unsigned char	*mailp;
static long	*mod_time = 0;
static BOOL login_shell = FALSE;

#if vax
char **execargs = (char **)(0x7ffffffc);
#endif

#if pdp11
char **execargs = (char **)(-2);
#endif


static void	exfile();
extern unsigned char 	*simple();
static void Ldup(int, int);
void settmp(void);
void chkmail(void);
void setmail(unsigned char *);

int
main(int c, char *v[], char *e[])
{
	int		rflag = ttyflg;
	int		rsflag = 1;	/* local restricted flag */
	unsigned char	*flagc = flagadr;
	struct namnod	*n;

	mypid = getpid();
	mypgid = getpgid(mypid);
	mysid = getsid(mypid);

	/*
	 * Do locale processing only if /usr is mounted.
	 */
	localedir_exists = (access(localedir, F_OK) == 0);

	/*
	 * initialize storage allocation
	 */

	if (stakbot == 0) {
	addblok((unsigned)0);
	}

	/*
	 * If the first character of the last path element of v[0] is "-"
	 * (ex. -sh, or /bin/-sh), this is a login shell
	 */
	if (*simple(v[0]) == '-') {
		signal(SIGXCPU, SIG_DFL);
		signal(SIGXFSZ, SIG_DFL);

		/*
		 * As the previous comment states, this is a login shell.
		 * Therefore, we set the login_shell flag to explicitly
		 * indicate this condition.
		 */
		login_shell = TRUE;
	}

	stdsigs();

	/*
	 * set names from userenv
	 */

	setup_env();

	/*
	 * LC_MESSAGES is set here so that early error messages will
	 * come out in the right style.
	 * Note that LC_CTYPE is done later on and is *not*
	 * taken from the previous environ
	 */

	/*
	 * Do locale processing only if /usr is mounted.
	 */
	if (localedir_exists)
		(void) setlocale(LC_ALL, "");
#if !defined(TEXT_DOMAIN)	/* Should be defined by cc -D */
#define	TEXT_DOMAIN "SYS_TEST"	/* Use this only if it weren't */
#endif
	(void) textdomain(TEXT_DOMAIN);

	/*
	 * 'rsflag' is zero if SHELL variable is
	 *  set in environment and
	 *  the simple file part of the value.
	 *  is rsh
	 */
	if (n = findnam("SHELL")) {
		if (eq("rsh", simple(n->namval)))
			rsflag = 0;
	}

	/*
	 * a shell is also restricted if the simple name of argv(0) is
	 * rsh or -rsh in its simple name
	 */

#ifndef RES

	if (c > 0 && (eq("rsh", simple(*v)) || eq("-rsh", simple(*v))))
		rflag = 0;

#endif

	if (eq("jsh", simple(*v)) || eq("-jsh", simple(*v)))
		flags |= monitorflg;

	hcreate();
	set_dotpath();


	/*
	 * look for options
	 * dolc is $#
	 */
	dolc = options(c, v);

	if (dolc < 2) {
		flags |= stdflg;
		{

			while (*flagc)
				flagc++;
			*flagc++ = STDFLG;
			*flagc = 0;
		}
	}
	if ((flags & stdflg) == 0)
		dolc--;

	if ((flags & privflg) == 0) {
		uid_t euid;
		gid_t egid;
		uid_t ruid;
		gid_t rgid;

		/*
		 * Determine all of the user's id #'s for this process and
		 * then decide if this shell is being entered as a result
		 * of a fork/exec.
		 * If the effective uid/gid do NOT match and the euid/egid
		 * is < 100 and the egid is NOT 1, reset the uid and gid to
		 * the user originally calling this process.
		 */
		euid = geteuid();
		ruid = getuid();
		egid = getegid();
		rgid = getgid();
		if ((euid != ruid) && (euid < 100))
			setuid(ruid);   /* reset the uid to the orig user */
		if ((egid != rgid) && ((egid < 100) && (egid != 1)))
			setgid(rgid);   /* reset the gid to the orig user */
	}

	dolv = (unsigned char **)v + c - dolc;
	dolc--;

	/*
	 * return here for shell file execution
	 * but not for parenthesis subshells
	 */
	if (setjmp(subshell)) {
		freejobs();
		flags |= subsh;
	}

	/*
	 * number of positional parameters
	 */
	replace(&cmdadr, dolv[0]);	/* cmdadr is $0 */

	/*
	 * set pidname '$$'
	 */
	assnum(&pidadr, (long)mypid);

	/*
	 * set up temp file names
	 */
	settmp();

	/*
	 * default internal field separators
	 * Do not allow importing of IFS from parent shell.
	 * setup_env() may have set anything from parent shell to IFS.
	 * Always set the default ifs to IFS.
	 */
	assign(&ifsnod, (unsigned char *)sptbnl);

	dfault(&mchknod, MAILCHECK);
	mailchk = stoi(mchknod.namval);

	/* initialize OPTIND for getopt */

	n = lookup("OPTIND");
	assign(n, (unsigned char *)"1");
	/*
	 * make sure that option parsing starts
	 * at first character
	 */
	_sp = 1;

	if ((beenhere++) == FALSE)	/* ? profile */
	{
		if ((login_shell == TRUE) && (flags & privflg) == 0) {

			/* system profile */

#ifndef RES

			if ((input = pathopen(nullstr, sysprofile)) >= 0)
				exfile(rflag);		/* file exists */

#endif
			/* user profile */

			if ((input = pathopen(homenod.namval, profile)) >= 0) {
				exfile(rflag);
				flags &= ~ttyflg;
			}
		}
		if (rsflag == 0 || rflag == 0) {
			if ((flags & rshflg) == 0) {
				while (*flagc)
					flagc++;
				*flagc++ = 'r';
				*flagc = '\0';
			}
			flags |= rshflg;
		}

		/*
		 * open input file if specified
		 */
		if (comdiv) {
			estabf(comdiv);
			input = -1;
		}
		else
		{
			if (flags & stdflg) {
				input = 0;
			} else {
			/*
			 * If the command file specified by 'cmdadr'
			 * doesn't exist, chkopen() will fail calling
			 * exitsh(). If this is a login shell and
			 * the $HOME/.profile file does not exist, the
			 * above statement "flags &= ~ttyflg" does not
			 * get executed and this makes exitsh() call
			 * longjmp() instead of exiting. longjmp() will
			 * return to the location specified by the last
			 * active jmpbuffer, which is the one set up in
			 * the function exfile() called after the system
			 * profile file is executed (see lines above).
			 * This would cause an infinite loop, because
			 * chkopen() will continue to fail and exitsh()
			 * to call longjmp(). To make exitsh() exit instead
			 * of calling longjmp(), we then set the flag forcexit
			 * at this stage.
			 */

				flags |= forcexit;
				input = chkopen(cmdadr, 0);
				flags &= ~forcexit;
			}

#ifdef ACCT
			if (input != 0)
				preacct(cmdadr);
#endif
			comdiv--;
		}
	}
#ifdef pdp11
	else
		*execargs = (char *)dolv;	/* for `ps' cmd */
#endif


	exfile(0);
	done(0);
}

static void
exfile(int prof)
{
	time_t	mailtime = 0;	/* Must not be a register variable */
	time_t 	curtime = 0;

	/*
	 * move input
	 */
	if (input > 0) {
		Ldup(input, INIO);
		input = INIO;
	}


	setmode(prof);

	if (setjmp(errshell) && prof) {
		close(input);
		(void) endjobs(0);
		return;
	}
	/*
	 * error return here
	 */

	loopcnt = peekc = peekn = 0;
	fndef = 0;
	nohash = 0;
	iopend = 0;

	if (input >= 0)
		initf(input);
	/*
	 * command loop
	 */
	for (;;) {
		tdystak(0);
		stakchk();	/* may reduce sbrk */
		exitset();

		if ((flags & prompt) && standin->fstak == 0 && !eof) {

			if (mailp) {
				time(&curtime);

				if ((curtime - mailtime) >= mailchk) {
					chkmail();
					mailtime = curtime;
				}
			}

			/* necessary to print jobs in a timely manner */
			if (trapnote & TRAPSET)
				chktrap();

			prs(ps1nod.namval);

#ifdef TIME_OUT
			alarm(TIMEOUT);
#endif

		}

		trapnote = 0;
		peekc = readwc();
		if (eof) {
			if (endjobs(JOB_STOPPED))
				return;
			eof = 0;
		}

#ifdef TIME_OUT
		alarm(0);
#endif

		{
			struct trenod *t;
			t = cmd(NL, MTFLG);
			if (t == NULL && flags & ttyflg)
				freejobs();
			else
				execute(t, 0, eflag);
		}

		eof |= (flags & oneflg);

	}
}

void
chkpr(void)
{
	if ((flags & prompt) && standin->fstak == 0)
		prs(ps2nod.namval);
}

void
settmp(void)
{
	int len;
	serial = 0;
	if ((len = snprintf((char *)tmpout, TMPOUTSZ, "/tmp/sh%u", mypid)) >=
	    TMPOUTSZ) {
		/*
		 * TMPOUTSZ should be big enough, but if it isn't,
		 * we'll at least try to create tmp files with
		 * a truncated tmpfile name at tmpout.
		 */
		tmpout_offset = TMPOUTSZ - 1;
	} else {
		tmpout_offset = len;
	}
}

static void
Ldup(int fa, int fb)
{
#ifdef RES

	dup(fa | DUPFLG, fb);
	close(fa);
	ioctl(fb, FIOCLEX, 0);

#else

	if (fa >= 0) {
		if (fa != fb) {
			close(fb);
			fcntl(fa, 0, fb); /* normal dup */
			close(fa);
		}
		fcntl(fb, 2, 1);	/* autoclose for fb */
	}

#endif
}

void
chkmail(void)
{
	unsigned char 	*s = mailp;
	unsigned char	*save;

	long	*ptr = mod_time;
	unsigned char	*start;
	BOOL	flg;
	struct stat	statb;

	while (*s) {
		start = s;
		save = 0;
		flg = 0;

		while (*s) {
			if (*s != COLON) {
				if (*s == '%' && save == 0)
					save = s;

				s++;
			} else {
				flg = 1;
				*s = 0;
			}
		}

		if (save)
			*save = 0;

		if (*start && stat((const char *)start, &statb) >= 0) {
			if (statb.st_size && *ptr &&
			    statb.st_mtime != *ptr) {
				if (save) {
					prs(save+1);
					newline();
				}
				else
					prs(_gettext(mailmsg));
			}
			*ptr = statb.st_mtime;
		} else if (*ptr == 0)
			*ptr = 1;

		if (save)
			*save = '%';

		if (flg)
			*s++ = COLON;

		ptr++;
	}
}

void
setmail(unsigned char *mailpath)
{
	unsigned char	*s = mailpath;
	int 		cnt = 1;

	long	*ptr;

	free(mod_time);
	if (mailp = mailpath) {
		while (*s) {
			if (*s == COLON)
				cnt += 1;

			s++;
		}

		ptr = mod_time = (long *)alloc(sizeof (long) * cnt);

		while (cnt) {
			*ptr = 0;
			ptr++;
			cnt--;
		}
	}
}

void
setmode(int prof)
{
	/*
	 * decide whether interactive
	 */

	if ((flags & intflg) ||
	    ((flags&oneflg) == 0 &&
	    isatty(output) &&
	    isatty(input)))

	{
		dfault(&ps1nod, (geteuid() ? stdprompt : supprompt));
		dfault(&ps2nod, readmsg);
		flags |= ttyflg | prompt;
		if (mailpnod.namflg != N_DEFAULT)
			setmail(mailpnod.namval);
		else
			setmail(mailnod.namval);
		startjobs();
	}
	else
	{
		flags |= prof;
		flags &= ~prompt;
	}
}



/* ============================================================================
 * SOURCE 55/98: minix4\exokernel\kernel_legacy\cmd\sort\main.c
 * Size: 3,294 bytes, Lines: 88
 * Hash: 575918f14eb5...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 1998-2003 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

/*
 * Overview of sort(1)
 *
 * sort(1) implements a robust sorting program, compliant with the POSIX
 * specifications for sort, that is capable of handling large sorts and merges
 * in single byte and multibyte locales.  Like most sort(1) implementations,
 * this implementation uses an internal algorithm for sorting subsets of the
 * requested data set and an external algorithm for sorting the subsets into the
 * final output.  In the current implementation, the internal algorithm is a
 * ternary radix quicksort, modified from the algorithm described in Bentley and
 * Sedgewick [1], while the external algorithm is a priority-queue based
 * heapsort, as outlined in Sedgewick [2].
 *
 * We use three major datatypes, defined in ./types.h: the line record,
 * line_rec_t; the stream, stream_t; and the field definition, field_t.
 * Because sort supports efficient code paths for each of the C, single-byte,
 * and wide character/multibyte locales, each of these types contains unions
 * and/or function pointers to describe appropriate properties or operations for
 * each locale type.
 *
 * To utilize the radix quicksort algorithm with the potentially complex sort
 * keys definable via the POSIX standard, we convert each line to a collatable
 * string based on the key definition.  This approach is somewhat different from
 * historical implementations of sort(1), which have built a complex
 * field-by-field comparison function.  There are, of course, tradeoffs that
 * accompany this decision, particularly when the duration of use of a given
 * collated form is short.  However, the maintenance costs of parallel
 * conversion and collation functions are estimated to be high, and the
 * performance costs of a shared set of functions were found to be excessive in
 * prototype.
 *
 * [1]	J. Bentley and R. Sedgewick, Fast Algorithms for Sorting and Searching
 *	Strings, in Eighth Annual ACM-SIAM Symposium on Discrete Algorithms,
 *	1997 (SODA 1997),
 * [2]	R. Sedgewick, Algorithms in C, 3rd ed., vol. 1, Addison-Wesley, 1998.
 */

#include "main.h"

static sort_t S;

int
main(int argc, char *argv[])
{
	initialize_pre(&S);

	if (options(&S, argc, argv))
		return (2);

	initialize_post(&S);

	if (S.m_check_if_sorted_only)
		check_if_sorted(&S);

	if (!S.m_merge_only)
		internal_sort(&S);

	merge(&S);

	return (0);
}



/* ============================================================================
 * SOURCE 56/98: minix4\exokernel\kernel_legacy\cmd\truss\main.c
 * Size: 68,355 bytes, Lines: 2,725
 * Hash: 02eac6520374...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (c) 1989, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright 2015, Joyent, Inc.
 * Copyright 2023 Oxide Computer Company
 */

/*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/

#include <stdio.h>
#include <stdio_ext.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <ctype.h>
#include <string.h>
#include <memory.h>
#include <signal.h>
#include <wait.h>
#include <limits.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/fstyp.h>
#include <sys/fsid.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <sys/resource.h>
#include <libproc.h>
#include <priv.h>
#include "ramdata.h"
#include "proto.h"
#include "htbl.h"

/*
 * The user can trace individual threads by using the 'pid/1,3-6,8-' syntax.
 * This structure keeps track of pid/lwp specifications.  If there are no LWPs
 * specified, then 'lwps' will be NULL.
 */
typedef struct proc_set {
	pid_t		pid;
	const char	*lwps;
} proc_set_t;

/*
 * Function prototypes for static routines in this file.
 */
void	setup_basetime(hrtime_t, struct timeval *);
int	xcreat(char *);
void	setoutput(int);
void	report(private_t *, time_t);
void	prtim(timestruc_t *);
void	pids(char *, proc_set_t *);
void	psargs(private_t *);
int	control(private_t *, pid_t);
int	grabit(private_t *, proc_set_t *);
void	release(private_t *, pid_t);
void	intr(int);
int	wait4all(void);
void	letgo(private_t *);
void	child_to_file();
void	file_to_parent();
void	per_proc_init();
int	lib_sort(const void *, const void *);
int	key_sort(const void *, const void *);

void	*worker_thread(void *);
void	main_thread(int);

/*
 * Test for empty set.
 * is_empty() should not be called directly.
 */
int	is_empty(const uint32_t *, size_t);
#define	isemptyset(sp) \
	is_empty((uint32_t *)(sp), sizeof (*(sp)) / sizeof (uint32_t))

/*
 * OR the second set into the first set.
 * or_set() should not be called directly.
 */
void	or_set(uint32_t *, const uint32_t *, size_t);
#define	prorset(sp1, sp2) \
	or_set((uint32_t *)(sp1), (uint32_t *)(sp2), \
	sizeof (*(sp1)) / sizeof (uint32_t))

/* fetch or allocate thread-private data */
private_t *
get_private()
{
	void *value;
	private_t *pri = NULL;

	if (thr_getspecific(private_key, &value) == 0)
		pri = value;
	if (pri == NULL) {
		pri = my_malloc(sizeof (*pri), NULL);
		(void) memset(pri, 0, sizeof (*pri));
		pri->sys_path = my_malloc(pri->sys_psize = 16, NULL);
		pri->sys_string = my_malloc(pri->sys_ssize = 32, NULL);
		if (thr_setspecific(private_key, pri) == ENOMEM)
			abend("memory allocation failure", NULL);
	}
	return (pri);
}

/* destructor function for thread-private data */
void
free_private(void *value)
{
	private_t *pri = value;

	if (pri->sys_path)
		free(pri->sys_path);
	if (pri->sys_string)
		free(pri->sys_string);
	if (pri->exec_string)
		free(pri->exec_string);
	if (pri->str_buffer)
		free(pri->str_buffer);
	free(pri);
}

/*
 * This is called by the main thread (via create_thread())
 * and is also called from other threads in worker_thread()
 * while holding truss_lock.  No further locking is required.
 */
void
insert_lwpid(lwpid_t lwpid)
{
	int i;

	truss_nlwp++;
	for (i = 0; i < truss_maxlwp; i++) {
		if (truss_lwpid[i] == 0)
			break;
	}
	if (i == truss_maxlwp) {
		/* double the size of the array */
		truss_lwpid = my_realloc(truss_lwpid,
		    truss_maxlwp * 2 * sizeof (lwpid_t), NULL);
		(void) memset(&truss_lwpid[truss_maxlwp], 0,
		    truss_maxlwp * sizeof (lwpid_t));
		truss_maxlwp *= 2;
	}
	truss_lwpid[i] = lwpid;
}

/*
 * This is called from the first worker thread to encounter one of
 * (leave_hung || interrupt || sigusr1).  It must notify all other
 * worker threads of the same condition.  truss_lock is held.
 */
void
broadcast_signals(void)
{
	static int int_notified = FALSE;
	static int usr1_notified = FALSE;
	static int usr2_notified = FALSE;
	lwpid_t my_id = thr_self();
	lwpid_t lwpid;
	int i;

	if (interrupt && !int_notified) {
		int_notified = TRUE;
		for (i = 0; i < truss_maxlwp; i++) {
			if ((lwpid = truss_lwpid[i]) != 0 && lwpid != my_id)
				(void) thr_kill(lwpid, interrupt);
		}
	}
	if (sigusr1 && !usr1_notified) {
		usr1_notified = TRUE;
		for (i = 0; i < truss_maxlwp; i++) {
			if ((lwpid = truss_lwpid[i]) != 0 && lwpid != my_id)
				(void) thr_kill(lwpid, SIGUSR1);
		}
	}
	if (leave_hung && !usr2_notified) {
		usr2_notified = TRUE;
		for (i = 0; i < truss_maxlwp; i++) {
			if ((lwpid = truss_lwpid[i]) != 0 && lwpid != my_id)
				(void) thr_kill(lwpid, SIGUSR2);
		}
	}
}

static struct ps_lwphandle *
grab_lwp(lwpid_t who)
{
	struct ps_lwphandle *Lwp;
	int gcode;

	if ((Lwp = Lgrab(Proc, who, &gcode)) == NULL) {
		if (gcode != G_NOPROC) {
			(void) fprintf(stderr,
			    "%s: cannot grab LWP %u in process %d,"
			    " reason: %s\n",
			    command, who, (int)Pstatus(Proc)->pr_pid,
			    Lgrab_error(gcode));
			interrupt = SIGTERM;	/* post an interrupt */
		}
	}
	return (Lwp);
}

/*
 * Iteration function called for each initial lwp in the controlled process.
 */
/* ARGSUSED */
int
create_thread(void *arg, const lwpstatus_t *Lsp)
{
	struct ps_lwphandle *new_Lwp;
	lwpid_t lwpid;
	int *count = arg;

	if (lwptrace(Pstatus(Proc)->pr_pid, Lsp->pr_lwpid))
		*count += 1;

	if ((new_Lwp = grab_lwp(Lsp->pr_lwpid)) != NULL) {
		if (thr_create(NULL, 0, worker_thread, new_Lwp,
		    THR_BOUND | THR_SUSPENDED, &lwpid) != 0)
			abend("cannot create lwp to follow child lwp", NULL);
		insert_lwpid(lwpid);
	}
	return (0);
}

int
main(int argc, char *argv[])
{
	private_t *pri;
	struct tms tms;
	struct rlimit rlim;
	int ofd = -1;
	int opt;
	int i;
	int first;
	int errflg = FALSE;
	int badname = FALSE;
	proc_set_t *grab = NULL;
	const pstatus_t *Psp;
	const lwpstatus_t *Lsp;
	int sharedmem;

	/* a few of these need to be initialized to NULL */
	Cp = NULL;
	fcall_tbl = NULL;

	/*
	 * Make sure fd's 0, 1, and 2 are allocated,
	 * just in case truss was invoked from init.
	 */
	while ((i = open("/dev/null", O_RDWR)) >= 0 && i < 2)
		;
	if (i > 2)
		(void) close(i);

	starttime = times(&tms);	/* for elapsed timing */

	/* this should be per-traced-process */
	pagesize = sysconf(_SC_PAGESIZE);

	/* command name (e.g., "truss") */
	if ((command = strrchr(argv[0], '/')) != NULL)
		command++;
	else
		command = argv[0];

	/* set up the initial private data */
	(void) mutex_init(&truss_lock, USYNC_THREAD, NULL);
	(void) mutex_init(&count_lock, USYNC_THREAD, NULL);
	(void) cond_init(&truss_cv, USYNC_THREAD, NULL);
	if (thr_keycreate(&private_key, free_private) == ENOMEM)
		abend("memory allocation failure", NULL);
	pri = get_private();

	Euid = geteuid();
	Egid = getegid();
	Ruid = getuid();
	Rgid = getgid();
	ancestor = getpid();

	prfillset(&trace);	/* default: trace all system calls */
	premptyset(&verbose);	/* default: no syscall verbosity */
	premptyset(&rawout);	/* default: no raw syscall interpretation */

	prfillset(&signals);	/* default: trace all signals */

	prfillset(&faults);	/* default: trace all faults */
	prdelset(&faults, FLTPAGE);	/* except this one */

	premptyset(&readfd);	/* default: dump no buffers */
	premptyset(&writefd);

	premptyset(&syshang);	/* default: hang on no system calls */
	premptyset(&sighang);	/* default: hang on no signals */
	premptyset(&flthang);	/* default: hang on no faults */

	(void) sigemptyset(&emptyset);	/* for unblocking all signals */
	(void) sigfillset(&fillset);	/* for blocking all signals */

#define	OPTIONS	"FpfcaeildDEht:T:v:x:s:S:m:M:u:U:r:w:o:"
	while ((opt = getopt(argc, argv, OPTIONS)) != EOF) {
		switch (opt) {
		case 'F':		/* force grabbing (no O_EXCL) */
			Fflag = PGRAB_FORCE;
			break;
		case 'p':		/* grab processes */
			pflag = TRUE;
			break;
		case 'f':		/* follow children */
			fflag = TRUE;
			break;
		case 'c':		/* don't trace, just count */
			cflag = TRUE;
			iflag = TRUE;	/* implies no interruptable syscalls */
			break;
		case 'a':		/* display argument lists */
			aflag = TRUE;
			break;
		case 'e':		/* display environments */
			eflag = TRUE;
			break;
		case 'i':		/* don't show interruptable syscalls */
			iflag = TRUE;
			break;
		case 'l':		/* show lwp id for each syscall */
			lflag = TRUE;
			break;
		case 'h':		/* debugging: report hash stats */
			hflag = TRUE;
			break;
		case 'd':		/* show time stamps */
			dflag = TRUE;
			break;
		case 'D':		/* show time deltas */
			Dflag = TRUE;
			break;
		case 'E':
			Eflag = TRUE;	/* show syscall times */
			break;
		case 't':		/* system calls to trace */
			if (syslist(optarg, &trace, &tflag))
				badname = TRUE;
			break;
		case 'T':		/* system calls to hang process */
			if (syslist(optarg, &syshang, &Tflag))
				badname = TRUE;
			break;
		case 'v':		/* verbose interpretation of syscalls */
			if (syslist(optarg, &verbose, &vflag))
				badname = TRUE;
			break;
		case 'x':		/* raw interpretation of syscalls */
			if (syslist(optarg, &rawout, &xflag))
				badname = TRUE;
			break;
		case 's':		/* signals to trace */
			if (siglist(pri, optarg, &signals, &sflag))
				badname = TRUE;
			break;
		case 'S':		/* signals to hang process */
			if (siglist(pri, optarg, &sighang, &Sflag))
				badname = TRUE;
			break;
		case 'm':		/* machine faults to trace */
			if (fltlist(optarg, &faults, &mflag))
				badname = TRUE;
			break;
		case 'M':		/* machine faults to hang process */
			if (fltlist(optarg, &flthang, &Mflag))
				badname = TRUE;
			break;
		case 'u':		/* user library functions to trace */
			if (liblist(optarg, 0))
				badname = TRUE;
			break;
		case 'U':		/* user library functions to hang */
			if (liblist(optarg, 1))
				badname = TRUE;
			break;
		case 'r':		/* show contents of read(fd) */
			if (fdlist(optarg, &readfd))
				badname = TRUE;
			break;
		case 'w':		/* show contents of write(fd) */
			if (fdlist(optarg, &writefd))
				badname = TRUE;
			break;
		case 'o':		/* output file for trace */
			oflag = TRUE;
			if (ofd >= 0)
				(void) close(ofd);
			if ((ofd = xcreat(optarg)) < 0) {
				perror(optarg);
				badname = TRUE;
			}
			break;
		default:
			errflg = TRUE;
			break;
		}
	}

	if (badname)
		exit(2);

	/* if -a or -e was specified, force tracing of exec() */
	if (aflag || eflag)
		praddset(&trace, SYS_execve);

	/*
	 * Make sure that all system calls, signals, and machine faults
	 * that hang the process are added to their trace sets.
	 */
	prorset(&trace, &syshang);
	prorset(&signals, &sighang);
	prorset(&faults, &flthang);

	argc -= optind;
	argv += optind;

	/* collect the specified process ids */
	if (pflag && argc > 0) {
		grab = my_malloc(argc * sizeof (proc_set_t),
		    "memory for process-ids");
		while (argc-- > 0)
			pids(*argv++, grab);
	}

	if (errflg || (argc <= 0 && ngrab <= 0)) {
		(void) fprintf(stderr,
	"usage:\t%s [-fcaeildDEF] [-[tTvx] [!]syscalls] [-[sS] [!]signals]\\\n",
		    command);
		(void) fprintf(stderr,
	"\t[-[mM] [!]faults] [-[rw] [!]fds] [-[uU] [!]libs:[:][!]funcs]\\\n");
		(void) fprintf(stderr,
		    "\t[-o outfile]  command | -p pid[/lwps] ...\n");
		exit(2);
	}

	if (argc > 0) {		/* create the controlled process */
		int err;
		char path[PATH_MAX];

		Proc = Pcreate(argv[0], &argv[0], &err, path, sizeof (path));
		if (Proc == NULL) {
			switch (err) {
			case C_PERM:
				(void) fprintf(stderr,
				    "%s: cannot trace set-id or "
				    "unreadable object file: %s\n",
				    command, path);
				break;
			case C_LP64:
				(void) fprintf(stderr,
				    "%s: cannot control _LP64 "
				    "program: %s\n",
				    command, path);
				break;
			case C_NOEXEC:
				(void) fprintf(stderr,
				    "%s: cannot execute program: %s\n",
				    command, argv[0]);
				break;
			case C_NOENT:
				(void) fprintf(stderr,
				    "%s: cannot find program: %s\n",
				    command, argv[0]);
				break;
			case C_STRANGE:
				break;
			default:
				(void) fprintf(stderr, "%s: %s\n",
				    command, Pcreate_error(err));
				break;
			}
			exit(2);
		}
		if (fflag || Dynpat != NULL)
			(void) Psetflags(Proc, PR_FORK);
		else
			(void) Punsetflags(Proc, PR_FORK);
		Psp = Pstatus(Proc);
		Lsp = &Psp->pr_lwp;
		pri->lwpstat = Lsp;
		data_model = Psp->pr_dmodel;
		created = Psp->pr_pid;
		make_pname(pri, 0);
		(void) sysentry(pri, 1);
		pri->length = 0;
		if (!cflag && prismember(&trace, SYS_execve)) {
			pri->exec_string = my_realloc(pri->exec_string,
			    strlen(pri->sys_string) + 1, NULL);
			(void) strcpy(pri->exec_pname, pri->pname);
			(void) strcpy(pri->exec_string, pri->sys_string);
			pri->length += strlen(pri->sys_string);
			pri->exec_lwpid = pri->lwpstat->pr_lwpid;
			pri->sys_leng = 0;
			*pri->sys_string = '\0';
		}
		pri->syslast = Psp->pr_stime;
		pri->usrlast = Psp->pr_utime;
	}

	/*
	 * Now that we have created the victim process,
	 * give ourself a million file descriptors.
	 * This is enough to deal with a multithreaded
	 * victim process that has half a million lwps.
	 */
	rlim.rlim_cur = 1024 * 1024;
	rlim.rlim_max = 1024 * 1024;
	if ((Euid != 0 || setrlimit(RLIMIT_NOFILE, &rlim) != 0) &&
	    getrlimit(RLIMIT_NOFILE, &rlim) == 0) {
		/*
		 * Failing the million, give ourself as many
		 * file descriptors as we can get.
		 */
		rlim.rlim_cur = rlim.rlim_max;
		(void) setrlimit(RLIMIT_NOFILE, &rlim);
	}
	(void) enable_extended_FILE_stdio(-1, -1);

	setoutput(ofd);		/* establish truss output */
	istty = isatty(1);

	if (setvbuf(stdout, (char *)NULL, _IOFBF, MYBUFSIZ) != 0)
		abend("setvbuf() failure", NULL);

	/*
	 * Set up signal dispositions.
	 */
	if (created && (oflag || !istty)) {	/* ignore interrupts */
		(void) sigset(SIGHUP, SIG_IGN);
		(void) sigset(SIGINT, SIG_IGN);
		(void) sigset(SIGQUIT, SIG_IGN);
	} else {				/* receive interrupts */
		if (sigset(SIGHUP, SIG_IGN) == SIG_DFL)
			(void) sigset(SIGHUP, intr);
		if (sigset(SIGINT, SIG_IGN) == SIG_DFL)
			(void) sigset(SIGINT, intr);
		if (sigset(SIGQUIT, SIG_IGN) == SIG_DFL)
			(void) sigset(SIGQUIT, intr);
	}
	(void) sigset(SIGTERM, intr);
	(void) sigset(SIGUSR1, intr);
	(void) sigset(SIGUSR2, intr);
	(void) sigset(SIGPIPE, intr);

	/* don't accumulate zombie children */
	(void) sigset(SIGCLD, SIG_IGN);

	/* create shared mem space for global mutexes */

	sharedmem = (fflag || Dynpat != NULL || ngrab > 1);
	gps = (void *)mmap(NULL, sizeof (struct global_psinfo),
	    PROT_READ|PROT_WRITE,
	    MAP_ANON | (sharedmem? MAP_SHARED : MAP_PRIVATE),
	    -1, (off_t)0);
	if (gps == MAP_FAILED)
		abend("cannot allocate ", "memory for counts");
	i = sharedmem? USYNC_PROCESS : USYNC_THREAD;
	(void) mutex_init(&gps->ps_mutex0, i, NULL);
	(void) mutex_init(&gps->ps_mutex1, i, NULL);
	(void) mutex_init(&gps->fork_lock, i, NULL);
	(void) cond_init(&gps->fork_cv, i, NULL);


	/* config tmp file if counting and following */
	if (fflag && cflag) {
		char *tmps = tempnam("/var/tmp", "truss");
		sfd = open(tmps, O_CREAT|O_APPEND|O_EXCL|O_RDWR, 0600);
		if (sfd == -1)
			abend("Error creating tmpfile", NULL);
		if (unlink(tmps) == -1)
			abend("Error unlinking tmpfile", NULL);
		free(tmps);
		tmps = NULL;
	}

	if (created) {
		per_proc_init();
		procadd(created, NULL);
		show_cred(pri, TRUE, FALSE);
	} else {		/* grab the specified processes */
		int gotone = FALSE;

		i = 0;
		while (i < ngrab) {		/* grab first process */
			if (grabit(pri, &grab[i++])) {
				Psp = Pstatus(Proc);
				Lsp = &Psp->pr_lwp;
				gotone = TRUE;
				break;
			}
		}
		if (!gotone)
			abend(NULL, NULL);
		per_proc_init();
		while (i < ngrab) {		/* grab the remainder */
			proc_set_t *set = &grab[i++];

			(void) mutex_lock(&truss_lock);
			switch (fork()) {
			case -1:
				(void) fprintf(stderr,
			"%s: cannot fork to control process, pid# %d\n",
				    command, (int)set->pid);
				/* FALLTHROUGH */
			default:
				(void) mutex_unlock(&truss_lock);
				continue;	/* parent carries on */

			case 0:			/* child grabs process */
				(void) mutex_unlock(&truss_lock);
				Pfree(Proc);
				descendent = TRUE;
				if (grabit(pri, set)) {
					Psp = Pstatus(Proc);
					Lsp = &Psp->pr_lwp;
					per_proc_init();
					break;
				}
				exit(2);
			}
			break;
		}
		free(grab);
	}


	/*
	 * If running setuid-root, become root for real to avoid
	 * affecting the per-user limitation on the maximum number
	 * of processes (one benefit of running setuid-root).
	 */
	if (Rgid != Egid)
		(void) setgid(Egid);
	if (Ruid != Euid)
		(void) setuid(Euid);

	if (!created && aflag && prismember(&trace, SYS_execve)) {
		psargs(pri);
		Flush();
	}

	if (created && Pstate(Proc) != PS_STOP)	/* assertion */
		if (!(interrupt | sigusr1))
			abend("ASSERT error: process is not stopped", NULL);

	traceeven = trace;		/* trace these system calls */

	/* trace these regardless, even if we don't report results */
	praddset(&traceeven, SYS_exit);
	praddset(&traceeven, SYS_lwp_create);
	praddset(&traceeven, SYS_lwp_exit);
	praddset(&traceeven, SYS_execve);
	praddset(&traceeven, SYS_openat);
	praddset(&traceeven, SYS_openat64);
	praddset(&traceeven, SYS_open);
	praddset(&traceeven, SYS_open64);
	praddset(&traceeven, SYS_vfork);
	praddset(&traceeven, SYS_forksys);
	praddset(&traceeven, SYS_upanic);

	/* for I/O buffer dumps, force tracing of read()s and write()s */
	if (!isemptyset(&readfd)) {
		praddset(&traceeven, SYS_read);
		praddset(&traceeven, SYS_readv);
		praddset(&traceeven, SYS_pread);
		praddset(&traceeven, SYS_pread64);
		praddset(&traceeven, SYS_recv);
		praddset(&traceeven, SYS_recvfrom);
		praddset(&traceeven, SYS_recvmsg);
	}
	if (!isemptyset(&writefd)) {
		praddset(&traceeven, SYS_write);
		praddset(&traceeven, SYS_writev);
		praddset(&traceeven, SYS_pwrite);
		praddset(&traceeven, SYS_pwrite64);
		praddset(&traceeven, SYS_send);
		praddset(&traceeven, SYS_sendto);
		praddset(&traceeven, SYS_sendmsg);
	}

	if (cflag || Eflag) {
		Psetsysentry(Proc, &traceeven);
	}
	Psetsysexit(Proc, &traceeven);

	/* special case -- cannot trace sysexit because context is changed */
	if (prismember(&trace, SYS_context)) {
		(void) Psysentry(Proc, SYS_context, TRUE);
		(void) Psysexit(Proc, SYS_context, FALSE);
		prdelset(&traceeven, SYS_context);
	}

	/* special case -- trace exec() on entry to get the args */
	(void) Psysentry(Proc, SYS_execve, TRUE);

	/* special case -- sysexit never reached */
	(void) Psysentry(Proc, SYS_exit, TRUE);
	(void) Psysentry(Proc, SYS_lwp_exit, TRUE);
	(void) Psysentry(Proc, SYS_upanic, TRUE);
	(void) Psysexit(Proc, SYS_exit, FALSE);
	(void) Psysexit(Proc, SYS_lwp_exit, FALSE);
	(void) Psysexit(Proc, SYS_upanic, FALSE);

	Psetsignal(Proc, &signals);	/* trace these signals */
	Psetfault(Proc, &faults);	/* trace these faults */

	/* for function call tracing */
	if (Dynpat != NULL) {
		/* trace these regardless, to deal with function calls */
		(void) Pfault(Proc, FLTBPT, TRUE);
		(void) Pfault(Proc, FLTTRACE, TRUE);

		/* needed for x86 */
		(void) Psetflags(Proc, PR_BPTADJ);

		/*
		 * Find functions and set breakpoints on grabbed process.
		 * A process stopped on exec() gets its breakpoints set below.
		 */
		if ((Lsp->pr_why != PR_SYSENTRY &&
		    Lsp->pr_why != PR_SYSEXIT) ||
		    Lsp->pr_what != SYS_execve) {
			establish_breakpoints();
			establish_stacks();
		}
	}

	/*
	 * Use asynchronous-stop for multithreaded truss.
	 * truss runs one lwp for each lwp in the target process.
	 */
	(void) Psetflags(Proc, PR_ASYNC);

	/* flush out all tracing flags now. */
	Psync(Proc);

	/*
	 * If we grabbed a running process, set it running again.
	 * Since we are tracing lwp_create() and lwp_exit(), the
	 * lwps will not change in the process until we create all
	 * of the truss worker threads.
	 * We leave a created process stopped so its exec() can be reported.
	 */
	first = created? FALSE : TRUE;
	if (!created &&
	    ((Pstate(Proc) == PS_STOP && Lsp->pr_why == PR_REQUESTED) ||
	    (Lsp->pr_flags & PR_DSTOP)))
		first = FALSE;

	main_thread(first);
	return (0);
}

/*
 * Called from main() and from control() after fork().
 */
void
main_thread(int first)
{
	private_t *pri = get_private();
	struct tms tms;
	int flags;
	int retc;
	int i;
	int count;

	/*
	 * Block all signals in the main thread.
	 * Some worker thread will receive signals.
	 */
	(void) thr_sigsetmask(SIG_SETMASK, &fillset, NULL);

	/*
	 * If we are dealing with a previously hung process,
	 * arrange not to leave it hung on the same system call.
	 */
	primary_lwp = (first && Pstate(Proc) == PS_STOP)?
	    Pstatus(Proc)->pr_lwp.pr_lwpid : 0;

	/*
	 * Create worker threads to match the lwps in the target process.
	 */
	truss_nlwp = 0;
	truss_maxlwp = 1;
	truss_lwpid = my_realloc(truss_lwpid, sizeof (lwpid_t), NULL);
	truss_lwpid[0] = 0;
	count = 0;
	(void) Plwp_iter(Proc, create_thread, &count);

	if (count == 0) {
		(void) printf("(Warning: no matching active LWPs found, "
		    "waiting)\n");
		Flush();
	}

	/*
	 * Set all of the truss worker threads running now.
	 */
	(void) mutex_lock(&truss_lock);
	for (i = 0; i < truss_maxlwp; i++) {
		if (truss_lwpid[i])
			(void) thr_continue(truss_lwpid[i]);
	}
	(void) mutex_unlock(&truss_lock);

	/*
	 * Wait until all worker threads terminate.
	 */
	while (thr_join(0, NULL, NULL) == 0)
		continue;

	(void) Punsetflags(Proc, PR_ASYNC);
	Psync(Proc);
	if (sigusr1)
		letgo(pri);
	flags = PRELEASE_CLEAR;
	if (leave_hung)
		flags |= PRELEASE_HANG;
	Prelease(Proc, flags);

	procdel();
	retc = (leave_hung? 0 : wait4all());

	if (!descendent) {
		interrupt = 0;	/* another interrupt kills the report */
		if (cflag) {
			if (fflag)
				file_to_parent();
			report(pri, times(&tms) - starttime);
		}
	} else if (cflag && fflag) {
		child_to_file();
	}

	exit(retc);	/* exit with exit status of created process, else 0 */
}

void *
worker_thread(void *arg)
{
	struct ps_lwphandle *Lwp = (struct ps_lwphandle *)arg;
	const pstatus_t *Psp = Pstatus(Proc);
	const lwpstatus_t *Lsp = Lstatus(Lwp);
	struct syscount *scp;
	lwpid_t who = Lsp->pr_lwpid;
	int first = (who == primary_lwp);
	private_t *pri = get_private();
	int req_flag = 0;
	int leave_it_hung = FALSE;
	int reset_traps = FALSE;
	int gcode;
	int what;
	int ow_in_effect = 0;
	long ow_syscall = 0;
	long ow_subcode = 0;
	char *ow_string = NULL;
	sysset_t full_set;
	sysset_t running_set;
	int dotrace = lwptrace(Psp->pr_pid, Lsp->pr_lwpid);

	pri->Lwp = Lwp;
	pri->lwpstat = Lsp;
	pri->syslast = Lsp->pr_stime;
	pri->usrlast = Lsp->pr_utime;
	make_pname(pri, 0);

	prfillset(&full_set);

	/* we were created with all signals blocked; unblock them */
	(void) thr_sigsetmask(SIG_SETMASK, &emptyset, NULL);

	/*
	 * Run this loop until the victim lwp terminates or we receive
	 * a termination condition (leave_hung | interrupt | sigusr1).
	 */
	for (;;) {
		if (interrupt | sigusr1) {
			(void) Lstop(Lwp, MILLISEC);
			if (Lstate(Lwp) == PS_RUN)
				break;
		}
		if (Lstate(Lwp) == PS_RUN) {
			/* millisecond timeout is for sleeping syscalls */
			uint_t tout = (iflag || req_flag)? 0 : MILLISEC;

			/*
			 * If we are to leave this lwp stopped in sympathy
			 * with another lwp that has been left hung, or if
			 * we have been interrupted or instructed to release
			 * our victim process, and this lwp is stopped but
			 * not on an event of interest to /proc, then just
			 * leave it in that state.
			 */
			if ((leave_hung | interrupt | sigusr1) &&
			    (Lsp->pr_flags & (PR_STOPPED|PR_ISTOP))
			    == PR_STOPPED)
				break;

			(void) Lwait(Lwp, tout);
			if (Lstate(Lwp) == PS_RUN &&
			    tout != 0 && !(interrupt | sigusr1)) {
				(void) mutex_lock(&truss_lock);
				if ((Lsp->pr_flags & PR_STOPPED) &&
				    Lsp->pr_why == PR_JOBCONTROL)
					req_flag = jobcontrol(pri, dotrace);
				else
					req_flag = requested(pri, req_flag,
					    dotrace);
				(void) mutex_unlock(&truss_lock);
			}
			continue;
		}
		data_model = Psp->pr_dmodel;
		if (Lstate(Lwp) == PS_UNDEAD)
			break;
		if (Lstate(Lwp) == PS_LOST) {	/* we lost control */
			/*
			 * After exec(), only one LWP remains in the process.
			 * /proc makes the thread following that LWP receive
			 * EAGAIN (PS_LOST) if the program being exec()ed
			 * is a set-id program.  Every other controlling
			 * thread receives ENOENT (because its LWP vanished).
			 * We are the controlling thread for the exec()ing LWP.
			 * We must wait until all of our siblings terminate
			 * before attempting to reopen the process.
			 */
			(void) mutex_lock(&truss_lock);
			while (truss_nlwp > 1)
				(void) cond_wait(&truss_cv, &truss_lock);
			if (Preopen(Proc) == 0) { /* we got control back */
				/*
				 * We have to free and re-grab the LWP.
				 * The process is guaranteed to be at exit
				 * from exec() or execve() and have only
				 * one LWP, namely this one, and the LWP
				 * is guaranteed to have lwpid == 1.
				 * This "cannot fail".
				 */
				who = 1;
				Lfree(Lwp);
				pri->Lwp = Lwp =
				    Lgrab(Proc, who, &gcode);
				if (Lwp == NULL)
					abend("Lgrab error: ",
					    Lgrab_error(gcode));
				pri->lwpstat = Lsp = Lstatus(Lwp);
				(void) mutex_unlock(&truss_lock);
				continue;
			}

			/* we really lost it */
			if (pri->exec_string && *pri->exec_string) {
				if (pri->exec_pname[0] != '\0')
					(void) fputs(pri->exec_pname, stdout);
				timestamp(pri);
				(void) fputs(pri->exec_string, stdout);
				(void) fputc('\n', stdout);
			} else if (pri->length) {
				(void) fputc('\n', stdout);
			}
			if (pri->sys_valid)
				(void) printf(
			"%s\t*** cannot trace across exec() of %s ***\n",
				    pri->pname, pri->sys_path);
			else
				(void) printf(
				"%s\t*** lost control of process ***\n",
				    pri->pname);
			pri->length = 0;
			Flush();
			(void) mutex_unlock(&truss_lock);
			break;
		}
		if (Lstate(Lwp) != PS_STOP) {
			(void) fprintf(stderr,
			    "%s: state = %d\n", command, Lstate(Lwp));
			abend(pri->pname, "uncaught status of subject lwp");
		}

		make_pname(pri, 0);

		(void) mutex_lock(&truss_lock);

		what = Lsp->pr_what;
		req_flag = 0;

		switch (Lsp->pr_why) {
		case PR_REQUESTED:
			break;
		case PR_SIGNALLED:
			req_flag = signalled(pri, req_flag, dotrace);
			if (Sflag && !first && prismember(&sighang, what))
				leave_it_hung = TRUE;
			break;
		case PR_FAULTED:
			if (what == FLTBPT) {
				int rval;

				(void) Pstop(Proc, 0);
				rval = function_trace(pri, first, 0, dotrace);
				if (rval == 1)
					leave_it_hung = TRUE;
				if (rval >= 0)
					break;
			}
			if (faulted(pri, dotrace) &&
			    Mflag && !first && prismember(&flthang, what))
				leave_it_hung = TRUE;
			break;
		case PR_JOBCONTROL:	/* can't happen except first time */
			req_flag = jobcontrol(pri, dotrace);
			break;
		case PR_SYSENTRY:
			/* protect ourself from operating system error */
			if (what <= 0 || what > PRMAXSYS)
				what = PRMAXSYS;
			pri->length = 0;
			/*
			 * ow_in_effect checks to see whether or not we
			 * are attempting to quantify the time spent in
			 * a one way system call.  This is necessary as
			 * some system calls never return, yet it is desireable
			 * to determine how much time the traced process
			 * spends in these calls.  To do this, a one way
			 * flag is set on SYSENTRY when the call is recieved.
			 * After this, the call mask for the SYSENTRY events
			 * is filled so that the traced process will stop
			 * on the entry to the very next system call.
			 * This appears to the the best way to determine
			 * system time elapsed between a one way system call.
			 * Once the next call occurs, values that have been
			 * stashed are used to record the correct syscall
			 * and time, and the SYSENTRY event mask is restored
			 * so that the traced process may continue.
			 */
			if (dotrace && ow_in_effect) {
				if (cflag) {
					(void) mutex_lock(&count_lock);
					scp = Cp->syscount[ow_syscall];
					if (ow_subcode != -1)
						scp += ow_subcode;
					scp->count++;
					accumulate(&scp->stime,
					    &Lsp->pr_stime, &pri->syslast);
					accumulate(&Cp->usrtotal,
					    &Lsp->pr_utime, &pri->usrlast);
					pri->syslast = Lsp->pr_stime;
					pri->usrlast = Lsp->pr_utime;
					(void) mutex_unlock(&count_lock);
				} else if (Eflag) {
					putpname(pri);
					timestamp(pri);
					(void) printf("%s\n", ow_string);
					free(ow_string);
					ow_string = NULL;
					pri->syslast = Lsp->pr_stime;
				}
				ow_in_effect = 0;
				Psetsysentry(Proc, &running_set);
			}

			/*
			 * Special cases.  Most syscalls are traced on exit.
			 */
			switch (what) {
			case SYS_exit:			/* exit() */
			case SYS_lwp_exit:		/* lwp_exit() */
			case SYS_upanic:		/* upanic() */
			case SYS_context:		/* [get|set]context() */
				if (dotrace && cflag &&
				    prismember(&trace, what)) {
					ow_in_effect = 1;
					ow_syscall = what;
					ow_subcode = getsubcode(pri);
					pri->syslast = Lsp->pr_stime;
					running_set =
					    (Pstatus(Proc))->pr_sysentry;
					Psetsysentry(Proc, &full_set);
				} else if (dotrace && Eflag &&
				    prismember(&trace, what)) {
					(void) sysentry(pri, dotrace);
					ow_in_effect = 1;
					ow_string = my_malloc(
					    strlen(pri->sys_string) + 1, NULL);
					(void) strcpy(ow_string,
					    pri->sys_string);
					running_set =
					    (Pstatus(Proc))->pr_sysentry;
					Psetsysentry(Proc, &full_set);
					pri->syslast = Lsp->pr_stime;
				} else if (dotrace &&
				    prismember(&trace, what)) {
					(void) sysentry(pri, dotrace);
					putpname(pri);
					timestamp(pri);
					pri->length +=
					    printf("%s\n", pri->sys_string);
					Flush();
				}
				pri->sys_leng = 0;
				*pri->sys_string = '\0';

				if (what == SYS_exit)
					exit_called = TRUE;
				break;
			case SYS_execve:
				show_cred(pri, FALSE, TRUE);
				(void) sysentry(pri, dotrace);
				if (dotrace && !cflag &&
				    prismember(&trace, what)) {
					pri->exec_string =
					    my_realloc(pri->exec_string,
					    strlen(pri->sys_string) + 1,
					    NULL);
					(void) strcpy(pri->exec_pname,
					    pri->pname);
					(void) strcpy(pri->exec_string,
					    pri->sys_string);
					pri->length += strlen(pri->sys_string);
					pri->exec_lwpid = Lsp->pr_lwpid;
				}
				pri->sys_leng = 0;
				*pri->sys_string = '\0';
				break;
			default:
				if (dotrace && (cflag || Eflag) &&
				    prismember(&trace, what)) {
					pri->syslast = Lsp->pr_stime;
				}
				break;
			}
			if (dotrace && Tflag && !first &&
			    (prismember(&syshang, what) ||
			    (exit_called && prismember(&syshang, SYS_exit))))
				leave_it_hung = TRUE;
			break;
		case PR_SYSEXIT:
			/* check for write open of a /proc file */
			if (what == SYS_openat || what == SYS_openat64 ||
			    what == SYS_open || what == SYS_open64) {
				int readonly;

				(void) sysentry(pri, dotrace);
				pri->Errno = Lsp->pr_errno;
				pri->ErrPriv = Lsp->pr_errpriv;
				readonly =
				    ((what == SYS_openat ||
				    what == SYS_openat64) &&
				    pri->sys_nargs > 2 &&
				    (pri->sys_args[2]&0x3) == O_RDONLY) ||
				    ((what == SYS_open ||
				    what == SYS_open64) &&
				    pri->sys_nargs > 1 &&
				    (pri->sys_args[1]&0x3) == O_RDONLY);
				if ((pri->Errno == 0 || pri->Errno == EBUSY) &&
				    pri->sys_valid && !readonly) {
					int rv = checkproc(pri);
					if (rv == 1 && Fflag != PGRAB_FORCE) {
						/*
						 * The process opened itself
						 * and no -F flag was specified.
						 * Just print the open() call
						 * and let go of the process.
						 */
						if (dotrace && !cflag &&
						    prismember(&trace, what)) {
							putpname(pri);
							timestamp(pri);
							(void) printf("%s\n",
							    pri->sys_string);
							Flush();
						}
						sigusr1 = TRUE;
						(void) mutex_unlock(
						    &truss_lock);
						goto out;
					}
					if (rv == 2) {
						/*
						 * Process opened someone else.
						 * The open is being reissued.
						 * Don't report this one.
						 */
						pri->sys_leng = 0;
						*pri->sys_string = '\0';
						pri->sys_nargs = 0;
						break;
					}
				}
			}
			if (what == SYS_execve && Lsp->pr_errno == 0) {
				/*
				 * Refresh the data model on exec() in case it
				 * is different from the parent.  Lwait()
				 * doesn't update process-wide status, so we
				 * have to explicitly call Pstopstatus() to get
				 * the new state.
				 */
				(void) Pstopstatus(Proc, PCNULL, 0);
				data_model = Psp->pr_dmodel;
			}
			if (sysexit(pri, dotrace))
				Flush();
			if (what == SYS_lwp_create && pri->Rval1 != 0) {
				struct ps_lwphandle *new_Lwp;
				lwpid_t lwpid;

				if ((new_Lwp = grab_lwp(pri->Rval1)) != NULL) {
					(void) thr_sigsetmask(SIG_SETMASK,
					    &fillset, NULL);
					if (thr_create(NULL, 0, worker_thread,
					    new_Lwp, THR_BOUND | THR_SUSPENDED,
					    &lwpid) != 0)
						abend("cannot create lwp ",
						    "to follow child lwp");
					insert_lwpid(lwpid);
					(void) thr_continue(lwpid);
					(void) thr_sigsetmask(SIG_SETMASK,
					    &emptyset, NULL);
				}
			}
			pri->sys_nargs = 0;
			if (dotrace && Tflag && !first &&
			    prismember(&syshang, what))
				leave_it_hung = TRUE;
			if (what == SYS_execve && pri->Errno == 0) {
				is_vfork_child = FALSE;
				reset_breakpoints();
				/*
				 * exec() resets the calling LWP's lwpid to 1.
				 * If the LWP has changed its lwpid, then
				 * we have to free and re-grab the LWP
				 * in order to keep libproc consistent.
				 * This "cannot fail".
				 */
				if (who != Lsp->pr_lwpid) {
					/*
					 * We must wait for all of our
					 * siblings to terminate.
					 */
					while (truss_nlwp > 1)
						(void) cond_wait(&truss_cv,
						    &truss_lock);
					who = Lsp->pr_lwpid;
					Lfree(Lwp);
					pri->Lwp = Lwp =
					    Lgrab(Proc, who, &gcode);
					if (Lwp == NULL)
						abend("Lgrab error: ",
						    Lgrab_error(gcode));
					pri->lwpstat = Lsp = Lstatus(Lwp);
				}
			}
			break;
		default:
			req_flag = 0;
			(void) fprintf(stderr,
			    "unknown reason for stopping: %d/%d\n",
			    Lsp->pr_why, what);
			abend(NULL, NULL);
		}

		if (pri->child) {	/* controlled process fork()ed */
			if (fflag || Dynpat != NULL)  {
				if (Lsp->pr_why == PR_SYSEXIT &&
				    (Lsp->pr_what == SYS_vfork ||
				    (Lsp->pr_what == SYS_forksys &&
				    Lsp->pr_sysarg[0] == 2))) {
					is_vfork_child = TRUE;
					(void) Pstop(Proc, 0);
				}
				if (control(pri, pri->child)) {
					(void) mutex_unlock(&truss_lock);
					pri->child = 0;
					if (!fflag) {
						/*
						 * If this is vfork(), then
						 * this clears the breakpoints
						 * in the parent's address space
						 * as well as in the child's.
						 */
						clear_breakpoints();
						Prelease(Proc, PRELEASE_CLEAR);
						_exit(0);
					}
					main_thread(FALSE);
					/* NOTREACHED */
				}

				/*
				 * Here, we are still the parent truss.
				 * If the child messes with the breakpoints and
				 * this is vfork(), we have to set them again.
				 */
				if (Dynpat != NULL && is_vfork_child && !fflag)
					reset_traps = TRUE;
				is_vfork_child = FALSE;
			}
			pri->child = 0;
		}

		if (leave_it_hung) {
			(void) mutex_unlock(&truss_lock);
			break;
		}

		if (reset_traps) {
			/*
			 * To recover from vfork, we must catch the lwp
			 * that issued the vfork() when it returns to user
			 * level, with all other lwps remaining stopped.
			 * For this purpose, we have directed all lwps to
			 * stop and we now set the vfork()ing lwp running
			 * with the PRSTEP flag.  We expect to capture it
			 * when it stops again showing PR_FAULTED/FLTTRACE.
			 * We are holding truss_lock, so no other threads
			 * in truss will set any other lwps in the victim
			 * process running.
			 */
			reset_traps = FALSE;
			(void) Lsetrun(Lwp, 0, PRSTEP);
			do {
				(void) Lwait(Lwp, 0);
			} while (Lstate(Lwp) == PS_RUN);
			if (Lstate(Lwp) == PS_STOP &&
			    Lsp->pr_why == PR_FAULTED &&
			    Lsp->pr_what == FLTTRACE) {
				reestablish_traps();
				(void) Lsetrun(Lwp, 0, PRCFAULT|PRSTOP);
			} else {
				(void) printf("%s\t*** Expected PR_FAULTED/"
				    "FLTTRACE stop following vfork()\n",
				    pri->pname);
			}
		}

		if (Lstate(Lwp) == PS_STOP) {
			int flags = 0;

			if (interrupt | sigusr1) {
				(void) mutex_unlock(&truss_lock);
				break;
			}
			/*
			 * If we must leave this lwp hung is sympathy with
			 * another lwp that is being left hung on purpose,
			 * then push the state onward toward PR_REQUESTED.
			 */
			if (leave_hung) {
				if (Lsp->pr_why == PR_REQUESTED) {
					(void) mutex_unlock(&truss_lock);
					break;
				}
				flags |= PRSTOP;
			}
			if (Lsetrun(Lwp, 0, flags) != 0 &&
			    Lstate(Lwp) != PS_LOST &&
			    Lstate(Lwp) != PS_UNDEAD) {
				(void) mutex_unlock(&truss_lock);
				perror("Lsetrun");
				abend("cannot start subject lwp", NULL);
				/* NOTREACHED */
			}
		}
		first = FALSE;

		(void) mutex_unlock(&truss_lock);
	}

out:
	/* block all signals in preparation for exiting */
	(void) thr_sigsetmask(SIG_SETMASK, &fillset, NULL);

	if (Lstate(Lwp) == PS_UNDEAD || Lstate(Lwp) == PS_LOST)
		(void) mutex_lock(&truss_lock);
	else {
		(void) Lstop(Lwp, MILLISEC);
		(void) mutex_lock(&truss_lock);
		if (Lstate(Lwp) == PS_STOP &&
		    Lsp->pr_why == PR_FAULTED &&
		    Lsp->pr_what == FLTBPT)
			(void) function_trace(pri, 0, 1, dotrace);
	}

	if (dotrace && ow_in_effect) {
		if (cflag) {
			(void) mutex_lock(&count_lock);
			scp = Cp->syscount[ow_syscall];
			if (ow_subcode != -1)
				scp += ow_subcode;
			scp->count++;
			accumulate(&scp->stime,
			    &Lsp->pr_stime, &pri->syslast);
			accumulate(&Cp->usrtotal,
			    &Lsp->pr_utime, &pri->usrlast);
			pri->syslast = Lsp->pr_stime;
			pri->usrlast = Lsp->pr_utime;
			(void) mutex_unlock(&count_lock);
		} else if (Eflag) {
			putpname(pri);
			timestamp(pri);
			(void) printf("%s\n", ow_string);
			free(ow_string);
			ow_string = NULL;
			pri->syslast = Lsp->pr_stime;
		}
		ow_in_effect = 0;
		Psetsysentry(Proc, &running_set);
	}

	if (Lstate(Lwp) == PS_UNDEAD || Lstate(Lwp) == PS_LOST) {
		/*
		 * The victim thread has exited or we lost control of
		 * the process.  Remove ourself from the list of all
		 * truss threads and notify everyone waiting for this.
		 */
		lwpid_t my_id = thr_self();
		int i;

		for (i = 0; i < truss_maxlwp; i++) {
			if (truss_lwpid[i] == my_id) {
				truss_lwpid[i] = 0;
				break;
			}
		}
		if (--truss_nlwp != 0) {
			(void) cond_broadcast(&truss_cv);
		} else {
			/*
			 * The last truss worker thread is terminating.
			 * The address space is gone (UNDEAD) or is
			 * inaccessible (LOST) so we cannot clear the
			 * breakpoints.  Just report the htable stats.
			 */
			report_htable_stats();
		}
	} else {
		/*
		 * The victim thread is not a zombie thread, and we have not
		 * lost control of the process.  We must have gotten here due
		 * to (leave_hung || leave_it_hung || interrupt || sigusr1).
		 * In these cases, we must carefully uninstrument the process
		 * and either set it running or leave it stopped and abandoned.
		 */
		static int nstopped = 0;
		static int cleared = 0;

		if (leave_it_hung)
			leave_hung = TRUE;
		if ((leave_hung | interrupt | sigusr1) == 0)
			abend("(leave_hung | interrupt | sigusr1) == 0", NULL);

		/*
		 * The first truss thread through here needs to instruct all
		 * application threads to stop -- they're not necessarily
		 * going to stop on their own.
		 */
		if (nstopped++ == 0)
			(void) Pdstop(Proc);

		/*
		 * Notify all other worker threads about the reason
		 * for being here (leave_hung || interrupt || sigusr1).
		 */
		broadcast_signals();

		/*
		 * Once the last thread has reached this point, then and
		 * only then is it safe to remove breakpoints and other
		 * instrumentation.  Since breakpoints are executed without
		 * truss_lock held, a monitor thread can't exit until all
		 * breakpoints have been removed, and we can't be sure the
		 * procedure to execute a breakpoint won't temporarily
		 * reinstall a breakpont.  Accordingly, we need to wait
		 * until all threads are in a known state.
		 */
		while (nstopped != truss_nlwp)
			(void) cond_wait(&truss_cv, &truss_lock);

		/*
		 * All truss threads have reached this point.
		 * One of them clears the breakpoints and
		 * wakes up everybody else to finish up.
		 */
		if (cleared++ == 0) {
			/*
			 * All threads should already be stopped,
			 * but just to be safe...
			 */
			(void) Pstop(Proc, MILLISEC);
			clear_breakpoints();
			(void) Psysexit(Proc, SYS_vfork, FALSE);
			(void) Psysexit(Proc, SYS_forksys, FALSE);
			(void) Punsetflags(Proc, PR_FORK);
			Psync(Proc);
			fflag = 0;
			(void) cond_broadcast(&truss_cv);
		}

		if (!leave_hung && Lstate(Lwp) == PS_STOP)
			(void) Lsetrun(Lwp, 0, 0);
	}

	(void) Lfree(Lwp);
	(void) mutex_unlock(&truss_lock);
	return (NULL);
}

/*
 * Give a base date for time stamps, adjusted to the
 * stop time of the selected (first or created) process.
 */
void
setup_basetime(hrtime_t basehrtime, struct timeval *basedate)
{
	const pstatus_t *Psp = Pstatus(Proc);
	(void) mutex_lock(&count_lock);
	Cp->basetime = Psp->pr_lwp.pr_tstamp;
	(void) mutex_unlock(&count_lock);

	if ((dflag|Dflag) && !cflag) {
		const struct tm *ptm;
		const char *ptime;
		const char *pdst;
		hrtime_t delta = basehrtime -
		    ((hrtime_t)Cp->basetime.tv_sec * NANOSEC +
		    Cp->basetime.tv_nsec);

		if (delta > 0) {
			basedate->tv_sec -= (time_t)(delta / NANOSEC);
			basedate->tv_usec -= (delta % NANOSEC) / 1000;
			if (basedate->tv_usec < 0) {
				basedate->tv_sec--;
				basedate->tv_usec += MICROSEC;
			}
		}
		ptm = localtime(&basedate->tv_sec);
		ptime = asctime(ptm);
		if ((pdst = tzname[ptm->tm_isdst ? 1 : 0]) == NULL)
			pdst = "???";
		if (dflag) {
			(void) printf(
			    "Base time stamp:  %ld.%4.4ld  [ %.20s%s %.4s ]\n",
			    basedate->tv_sec, basedate->tv_usec / 100,
			    ptime, pdst, ptime + 20);
			Flush();
		}
	}
}

/*
 * Performs per-process initializations. If truss is following a victim
 * process it will fork additional truss processes to follow new processes
 * created.  Here is where each new truss process gets its per-process data
 * initialized.
 */

void
per_proc_init()
{
	void *pmem;
	struct timeval basedate;
	hrtime_t basehrtime;
	struct syscount *scp;
	int i;
	timestruc_t c_basetime;

	/* Make sure we only configure the basetime for the first truss proc */

	if (Cp == NULL) {
		pmem = my_malloc(sizeof (struct counts) + maxsyscalls() *
		    sizeof (struct syscount), NULL);
		Cp = (struct counts *)pmem;
		basehrtime = gethrtime();
		(void) gettimeofday(&basedate, NULL);
		setup_basetime(basehrtime, &basedate);
	}

	c_basetime = Cp->basetime;

	(void) memset(Cp, 0, sizeof (struct counts) + maxsyscalls() *
	    sizeof (struct syscount));

	Cp->basetime = c_basetime;

	if (fcall_tbl != NULL)
		destroy_hash(fcall_tbl);
	fcall_tbl = init_hash(4096);

	(void) mutex_lock(&count_lock);
	scp = (struct syscount *)(Cp + 1);
	for (i = 0; i <= PRMAXSYS; i++) {
		Cp->syscount[i] = scp;
		scp += nsubcodes(i);
	}
	(void) mutex_unlock(&count_lock);
}


/*
 * Writes child state to a tempfile where it can be read and
 * accumulated by the parent process. The file descriptor is shared
 * among the processes.  Ordering of writes does not matter, it is, however,
 * necessary to ensure that all writes are atomic.
 */

void
child_to_file()
{
	hiter_t *itr;
	hentry_t *ntry;
	hdntry_t fentry;
	char *s = NULL;
	char *t = NULL;
	unsigned char *buf = NULL;
	size_t bufsz = 0;
	size_t i = 0;
	size_t j = 0;

	/* ensure that we are in fact a child process */
	if (!descendent)
		return;

	/* enumerate fcall_tbl (tbl locked until freed) */
	if (Dynpat != NULL) {
		itr = iterate_hash(fcall_tbl);

		ntry = iter_next(itr);
		while (ntry != NULL) {
			fentry.type = HD_hashntry;
			fentry.count = ntry->count;
			s = ntry->key;
			t = ntry->lib;
			i = strlen(s) + 1;
			j = strlen(t) + 1;
			fentry.sz_key = i;
			fentry.sz_lib = j;
			if (i + sizeof (fentry) > bufsz) {
				buf = my_realloc(buf, i + j + sizeof (fentry),
				    NULL);
				bufsz = i + j + sizeof (fentry);
			}
			(void) memcpy(buf, &fentry, sizeof (fentry));
			(void) strlcpy((char *)(buf + sizeof (fentry)), t, j);
			(void) strlcpy((char *)(buf + sizeof (fentry) + j),
			    s, i);
			if (write(sfd, buf, sizeof (fentry) + i + j) == -1)
				abend("Error writing to tmp file", NULL);
			ntry = iter_next(itr);
		}
		iter_free(itr);
	}

	/* Now write the count/syscount structs down */
	bufsz = sizeof (fentry) + (sizeof (struct counts) + maxsyscalls() *
	    sizeof (struct syscount));
	buf = my_realloc(buf, bufsz, NULL);
	fentry.type = HD_cts_syscts;
	fentry.count = 0;	/* undefined, really */
	fentry.sz_key = bufsz - sizeof (fentry);
	fentry.sz_lib = 0;	/* also undefined */
	(void) memcpy(buf, &fentry, sizeof (fentry));
	(void) memcpy((char *)(buf + sizeof (fentry)), Cp,
	    bufsz - sizeof (fentry));
	if (write(sfd, buf, bufsz) == -1)
		abend("Error writing cts/syscts to tmpfile", NULL);

	free(buf);
}

/*
 * The following reads entries from the tempfile back to the parent
 * so that information can be collected and summed for overall statistics.
 * This reads records out of the tempfile.  If they are hash table entries,
 * the record is merged with the hash table kept by the parent process.
 * If the information is a struct count/struct syscount pair, they are
 * copied and added into the count/syscount array kept by the parent.
 */

void
file_to_parent()
{
	hdntry_t ntry;
	char *s = NULL;
	char *t = NULL;
	size_t c_offset = 0;
	size_t filesz;
	size_t t_strsz = 0;
	size_t s_strsz = 0;
	struct stat fsi;

	if (descendent)
		return;

	if (fstat(sfd, &fsi) == -1)
		abend("Error stat-ing tempfile", NULL);
	filesz = fsi.st_size;

	while (c_offset < filesz) {
		/* first get hdntry */
		if (pread(sfd, &ntry, sizeof (hdntry_t), c_offset) !=
		    sizeof (hdntry_t))
			abend("Unable to perform full read of hdntry", NULL);
		c_offset += sizeof (hdntry_t);

		switch (ntry.type) {
		case HD_hashntry:

			/* first get lib string */
			if (ntry.sz_lib > t_strsz) {
				t = my_realloc(t, ntry.sz_lib, NULL);
				t_strsz = ntry.sz_lib;
			}

			(void) memset(t, 0, t_strsz);

			/* now actually get the string */
			if (pread(sfd, t, ntry.sz_lib, c_offset) != ntry.sz_lib)
				abend("Unable to perform full read of lib str",
				    NULL);
			c_offset += ntry.sz_lib;

			/* now get key string */

			if (ntry.sz_key > s_strsz) {
				s = my_realloc(s, ntry.sz_key, NULL);
				s_strsz = ntry.sz_key;
			}
			(void) memset(s, 0, s_strsz);
			if (pread(sfd, s, ntry.sz_key, c_offset) != ntry.sz_key)
				abend("Unable to perform full read of key str",
				    NULL);
			c_offset += ntry.sz_key;

			add_fcall(fcall_tbl, t, s, ntry.count);
			break;

		case HD_cts_syscts:
		{
			struct counts *ncp;
			size_t bfsz = sizeof (struct counts) + maxsyscalls()
			    * sizeof (struct syscount);
			int i;
			struct syscount *sscp;

			if (ntry.sz_key != bfsz)
				abend("cts/syscts size does not sanity check",
				    NULL);
			ncp = my_malloc(ntry.sz_key, NULL);

			if (pread(sfd, ncp, ntry.sz_key, c_offset) !=
			    ntry.sz_key)
				abend("Unable to perform full read of cts",
				    NULL);
			c_offset += ntry.sz_key;

			sscp = (struct syscount *)(ncp + 1);

			(void) mutex_lock(&count_lock);

			Cp->usrtotal.tv_sec += ncp->usrtotal.tv_sec;
			Cp->usrtotal.tv_nsec += ncp->usrtotal.tv_nsec;
			if (Cp->usrtotal.tv_nsec >= NANOSEC) {
				Cp->usrtotal.tv_nsec -= NANOSEC;
				Cp->usrtotal.tv_sec++;
			}
			for (i = 0; i <= PRMAXSYS; i++) {
				ncp->syscount[i] = sscp;
				sscp += nsubcodes(i);
			}

			for (i = 0; i <= PRMAXFAULT; i++) {
				Cp->fltcount[i] += ncp->fltcount[i];
			}

			for (i = 0; i <= PRMAXSIG; i++) {
				Cp->sigcount[i] += ncp->sigcount[i];
			}

			for (i = 0; i <= PRMAXSYS; i++) {
				struct syscount *scp = Cp->syscount[i];
				struct syscount *nscp = ncp->syscount[i];
				int n = nsubcodes(i);
				int subcode;

				for (subcode = 0; subcode < n; subcode++,
				    scp++, nscp++) {
					scp->count += nscp->count;
					scp->error += nscp->error;
					scp->stime.tv_sec += nscp->stime.tv_sec;
					scp->stime.tv_nsec +=
					    nscp->stime.tv_nsec;
					if (scp->stime.tv_nsec >= NANOSEC) {
						scp->stime.tv_nsec -= NANOSEC;
						scp->stime.tv_sec++;
					}
				}
			}
			(void) mutex_unlock(&count_lock);
			free(ncp);
			break;
		}
		default:

			abend("Unknown file entry type encountered", NULL);
			break;

		}

		if (fstat(sfd, &fsi) == -1)
			abend("Error stat-ing tempfile", NULL);
		filesz = fsi.st_size;
	}
	if (s != NULL)
		free(s);
	if (t != NULL)
		free(t);
}

void
make_pname(private_t *pri, id_t tid)
{
	if (!cflag) {
		int ff = (fflag || ngrab > 1);
		int lf = (lflag | tid | (Thr_agent != NULL) | (truss_nlwp > 1));
		pid_t pid = Pstatus(Proc)->pr_pid;
		id_t lwpid = pri->lwpstat->pr_lwpid;

		if (ff != pri->pparam.ff ||
		    lf != pri->pparam.lf ||
		    pid != pri->pparam.pid ||
		    lwpid != pri->pparam.lwpid ||
		    tid != pri->pparam.tid) {
			char *s = pri->pname;

			if (ff)
				s += sprintf(s, "%d", (int)pid);
			if (lf)
				s += sprintf(s, "/%d", (int)lwpid);
			if (tid)
				s += sprintf(s, "@%d", (int)tid);
			if (ff || lf)
				*s++ = ':', *s++ = '\t';
			if (ff && lf && s < pri->pname + 9)
				*s++ = '\t';
			*s = '\0';
			pri->pparam.ff = ff;
			pri->pparam.lf = lf;
			pri->pparam.pid = pid;
			pri->pparam.lwpid = lwpid;
			pri->pparam.tid = tid;
		}
	}
}

/*
 * Print the pri->pname[] string, if any.
 */
void
putpname(private_t *pri)
{
	if (pri->pname[0])
		(void) fputs(pri->pname, stdout);
}

/*
 * Print the timestamp, if requested (-d, -D, or -E).
 */
void
timestamp(private_t *pri)
{
	const lwpstatus_t *Lsp = pri->lwpstat;
	int seconds;
	int fraction;

	if (!(dflag|Dflag|Eflag) || !(Lsp->pr_flags & PR_STOPPED))
		return;

	seconds = Lsp->pr_tstamp.tv_sec - Cp->basetime.tv_sec;
	fraction = Lsp->pr_tstamp.tv_nsec - Cp->basetime.tv_nsec;
	if (fraction < 0) {
		seconds--;
		fraction += NANOSEC;
	}
	/* fraction in 1/10 milliseconds, rounded up */
	fraction = (fraction + 50000) / 100000;
	if (fraction >= (MILLISEC * 10)) {
		seconds++;
		fraction -= (MILLISEC * 10);
	}

	if (dflag)		/* time stamp */
		(void) printf("%2d.%4.4d\t", seconds, fraction);

	if (Dflag) {		/* time delta */
		int oseconds = pri->seconds;
		int ofraction = pri->fraction;

		pri->seconds = seconds;
		pri->fraction = fraction;
		seconds -= oseconds;
		fraction -= ofraction;
		if (fraction < 0) {
			seconds--;
			fraction += (MILLISEC * 10);
		}
		(void) printf("%2d.%4.4d\t", seconds, fraction);
	}

	if (Eflag) {
		seconds = Lsp->pr_stime.tv_sec - pri->syslast.tv_sec;
		fraction = Lsp->pr_stime.tv_nsec - pri->syslast.tv_nsec;

		if (fraction < 0) {
			seconds--;
			fraction += NANOSEC;
		}
		/* fraction in 1/10 milliseconds, rounded up */
		fraction = (fraction + 50000) / 100000;
		if (fraction >= (MILLISEC * 10)) {
			seconds++;
			fraction -= (MILLISEC * 10);
		}
		(void) printf("%2d.%4.4d\t", seconds, fraction);
	}
}

/*
 * Create output file, being careful about
 * suid/sgid and file descriptor 0, 1, 2 issues.
 */
int
xcreat(char *path)
{
	int fd;
	int mode = 0666;

	if (Euid == Ruid && Egid == Rgid)	/* not set-id */
		fd = creat(path, mode);
	else if (access(path, F_OK) != 0) {	/* file doesn't exist */
		/* if directory permissions OK, create file & set ownership */

		char *dir;
		char *p;
		char dot[4];

		/* generate path for directory containing file */
		if ((p = strrchr(path, '/')) == NULL) {	/* no '/' */
			p = dir = dot;
			*p++ = '.';		/* current directory */
			*p = '\0';
		} else if (p == path) {			/* leading '/' */
			p = dir = dot;
			*p++ = '/';		/* root directory */
			*p = '\0';
		} else {				/* embedded '/' */
			dir = path;		/* directory path */
			*p = '\0';
		}

		if (access(dir, W_OK|X_OK) != 0) {
			/* not writeable/searchable */
			*p = '/';
			fd = -1;
		} else {	/* create file and set ownership correctly */
			*p = '/';
			if ((fd = creat(path, mode)) >= 0)
				(void) chown(path, (int)Ruid, (int)Rgid);
		}
	} else if (access(path, W_OK) != 0)	/* file not writeable */
		fd = -1;
	else
		fd = creat(path, mode);

	/*
	 * Make sure it's not one of 0, 1, or 2.
	 * This allows truss to work when spawned by init(8).
	 */
	if (0 <= fd && fd <= 2) {
		int dfd = fcntl(fd, F_DUPFD, 3);
		(void) close(fd);
		fd = dfd;
	}

	/*
	 * Mark it close-on-exec so created processes don't inherit it.
	 */
	if (fd >= 0)
		(void) fcntl(fd, F_SETFD, FD_CLOEXEC);

	return (fd);
}

void
setoutput(int ofd)
{
	if (ofd < 0) {
		(void) close(1);
		(void) fcntl(2, F_DUPFD, 1);
	} else if (ofd != 1) {
		(void) close(1);
		(void) fcntl(ofd, F_DUPFD, 1);
		(void) close(ofd);
		/* if no stderr, make it the same file */
		if ((ofd = dup(2)) < 0)
			(void) fcntl(1, F_DUPFD, 2);
		else
			(void) close(ofd);
	}
}

/*
 * Accumulate time differencies:  a += e - s;
 */
void
accumulate(timestruc_t *ap, const timestruc_t *ep, const timestruc_t *sp)
{
	ap->tv_sec += ep->tv_sec - sp->tv_sec;
	ap->tv_nsec += ep->tv_nsec - sp->tv_nsec;
	if (ap->tv_nsec >= NANOSEC) {
		ap->tv_nsec -= NANOSEC;
		ap->tv_sec++;
	} else if (ap->tv_nsec < 0) {
		ap->tv_nsec += NANOSEC;
		ap->tv_sec--;
	}
}

int
lib_sort(const void *p1, const void *p2)
{
	int cmpr = 0;
	long i;
	long j;

	hentry_t *t1 = (hentry_t *)p1;
	hentry_t *t2 = (hentry_t *)p2;

	char *p = t1->lib;
	char *q = t2->lib;

	if ((cmpr = strcmp(p, q)) == 0) {
		i = t1->count;
		j = t2->count;
		if (i > j)
			return (-1);
		else if (i < j)
			return (1);
		else {
			p = t1->key;
			q = t2->key;
			return (strcmp(p, q));
		}
	} else
		return (cmpr);
}

void
report(private_t *pri, time_t lapse)	/* elapsed time, clock ticks */
{
	int i;
	long count;
	const char *name;
	long error;
	long total;
	long errtot;
	timestruc_t tickzero;
	timestruc_t ticks;
	timestruc_t ticktot;

	if (descendent)
		return;

	for (i = 0, total = 0; i <= PRMAXFAULT && !interrupt; i++) {
		if ((count = Cp->fltcount[i]) != 0) {
			if (total == 0)		/* produce header */
				(void) printf("faults -------------\n");

			name = proc_fltname(i, pri->flt_name,
			    sizeof (pri->flt_name));

			(void) printf("%s%s\t%4ld\n", name,
			    (((int)strlen(name) < 8)?
			    (const char *)"\t" : (const char *)""),
			    count);
			total += count;
		}
	}
	if (total && !interrupt)
		(void) printf("total:\t\t%4ld\n\n", total);

	for (i = 0, total = 0; i <= PRMAXSIG && !interrupt; i++) {
		if ((count = Cp->sigcount[i]) != 0) {
			if (total == 0)		/* produce header */
				(void) printf("signals ------------\n");
			name = signame(pri, i);
			(void) printf("%s%s\t%4ld\n", name,
			    (((int)strlen(name) < 8)?
			    (const char *)"\t" : (const char *)""),
			    count);
			total += count;
		}
	}
	if (total && !interrupt)
		(void) printf("total:\t\t%4ld\n\n", total);

	if ((Dynpat != NULL) && !interrupt) {
		size_t elem = elements_in_table(fcall_tbl);
		hiter_t *itr = iterate_hash(fcall_tbl);
		hentry_t *tmp = iter_next(itr);
		hentry_t *stbl = my_malloc(elem * sizeof (hentry_t), NULL);
		i = 0;
		while ((tmp != NULL) && (i < elem)) {
			stbl[i].prev = tmp->prev;
			stbl[i].next = tmp->next;
			stbl[i].lib = tmp->lib;
			stbl[i].key = tmp->key;
			stbl[i].count = tmp->count;
			tmp = iter_next(itr);
			i++;
		}
		qsort((void *)stbl, elem, sizeof (hentry_t),
		    lib_sort);
		(void) printf(
		    "\n%-20s %-40s %s\n", "Library:", "Function", "calls");
		for (i = 0; i < elem; i++) {
			(void) printf("%-20s %-40s %ld\n", stbl[i].lib,
			    stbl[i].key, stbl[i].count);
		}
		iter_free(itr);
		free(stbl);
		itr = NULL;
	}

	if (!interrupt)
		(void) printf(
		"\nsyscall               seconds   calls  errors\n");

	total = errtot = 0;
	tickzero.tv_sec = ticks.tv_sec = ticktot.tv_sec = 0;
	tickzero.tv_nsec = ticks.tv_nsec = ticktot.tv_nsec = 0;
	for (i = 0; i <= PRMAXSYS && !interrupt; i++) {
		struct syscount *scp = Cp->syscount[i];
		int n = nsubcodes(i);
		int subcode;

		for (subcode = 0; subcode < n; subcode++, scp++) {
			if ((count = scp->count) != 0 || scp->error) {
				(void) printf("%-19.19s ",
				    sysname(pri, i, subcode));

				ticks = scp->stime;
				accumulate(&ticktot, &ticks, &tickzero);
				prtim(&ticks);

				(void) printf(" %7ld", count);
				if ((error = scp->error) != 0)
					(void) printf(" %7ld", error);
				(void) fputc('\n', stdout);
				total += count;
				errtot += error;
			}
		}
	}

	if (!interrupt) {
		(void) printf(
		"                     --------  ------   ----\n");
		(void) printf("sys totals:         ");
		prtim(&ticktot);
		(void) printf(" %7ld %6ld\n", total, errtot);
	}

	if (!interrupt) {
		(void) printf("usr time:           ");
		prtim(&Cp->usrtotal);
		(void) fputc('\n', stdout);
	}

	if (!interrupt) {
		int hz = (int)sysconf(_SC_CLK_TCK);

		ticks.tv_sec = lapse / hz;
		ticks.tv_nsec = (lapse % hz) * (1000000000 / hz);
		(void) printf("elapsed:            ");
		prtim(&ticks);
		(void) fputc('\n', stdout);
	}
}

void
prtim(timestruc_t *tp)
{
	time_t sec;

	if ((sec = tp->tv_sec) != 0)			/* whole seconds */
		(void) printf("%5lu", sec);
	else
		(void) printf("     ");

	(void) printf(".%3.3ld", tp->tv_nsec/1000000);	/* fraction */
}

/*
 * Gather process id's.
 * Return 0 on success, != 0 on failure.
 */
void
pids(char *arg, proc_set_t *grab)
{
	pid_t pid = -1;
	int i;
	const char *lwps = NULL;

	if ((pid = proc_arg_xpsinfo(arg, PR_ARG_PIDS, NULL, &i, &lwps)) < 0) {
		(void) fprintf(stderr, "%s: cannot trace '%s': %s\n",
		    command, arg, Pgrab_error(i));
		return;
	}

	for (i = 0; i < ngrab; i++)
		if (grab[i].pid == pid)	/* duplicate */
			break;

	if (i == ngrab) {
		grab[ngrab].pid = pid;
		grab[ngrab].lwps = lwps;
		ngrab++;
	} else {
		(void) fprintf(stderr, "%s: duplicate process-id ignored: %d\n",
		    command, (int)pid);
	}
}

/*
 * Report psargs string.
 */
void
psargs(private_t *pri)
{
	pid_t pid = Pstatus(Proc)->pr_pid;
	psinfo_t psinfo;

	if (proc_get_psinfo(pid, &psinfo) == 0)
		(void) printf("%spsargs: %.64s\n",
		    pri->pname, psinfo.pr_psargs);
	else {
		perror("psargs()");
		(void) printf("%s\t*** Cannot read psinfo file for pid %d\n",
		    pri->pname, (int)pid);
	}
}

char *
fetchstring(private_t *pri, long addr, int maxleng)
{
	int nbyte;
	int leng = 0;
	char string[41];

	string[40] = '\0';
	if (pri->str_bsize == 0)  /* initial allocation of string buffer */
		pri->str_buffer =
		    my_malloc(pri->str_bsize = 16, "string buffer");
	*pri->str_buffer = '\0';

	for (nbyte = 40; nbyte == 40 && leng < maxleng; addr += 40) {
		if ((nbyte = Pread(Proc, string, 40, addr)) <= 0)
			return (leng? pri->str_buffer : NULL);
		if (nbyte > 0 &&
		    (nbyte = strlen(string)) > 0) {
			while (leng + nbyte >= pri->str_bsize)
				pri->str_buffer =
				    my_realloc(pri->str_buffer,
				    pri->str_bsize *= 2, "string buffer");
			(void) strcpy(pri->str_buffer+leng, string);
			leng += nbyte;
		}
	}

	if (leng > maxleng)
		leng = maxleng;
	pri->str_buffer[leng] = '\0';

	return (pri->str_buffer);
}

static priv_set_t *
getset(prpriv_t *p, priv_ptype_t set)
{
	return ((priv_set_t *)
	    &p->pr_sets[priv_getsetbyname(set) * p->pr_setsize]);
}

void
show_cred(private_t *pri, int new, int loadonly)
{
	prcred_t cred;
	prpriv_t *privs;

	if (proc_get_cred(Pstatus(Proc)->pr_pid, &cred, 0) < 0) {
		perror("show_cred() - credential");
		(void) printf("%s\t*** Cannot get credentials\n", pri->pname);
		return;
	}
	if ((privs = proc_get_priv(Pstatus(Proc)->pr_pid)) == NULL) {
		perror("show_cred() - privileges");
		(void) printf("%s\t*** Cannot get privileges\n", pri->pname);
		return;
	}

	if (!loadonly && !cflag && prismember(&trace, SYS_execve)) {
		if (new)
			credentials = cred;
		if ((new && cred.pr_ruid != cred.pr_suid) ||
		    cred.pr_ruid != credentials.pr_ruid ||
		    cred.pr_suid != credentials.pr_suid)
			(void) printf(
		"%s    *** SUID: ruid/euid/suid = %d / %d / %d  ***\n",
			    pri->pname,
			    (int)cred.pr_ruid,
			    (int)cred.pr_euid,
			    (int)cred.pr_suid);
		if ((new && cred.pr_rgid != cred.pr_sgid) ||
		    cred.pr_rgid != credentials.pr_rgid ||
		    cred.pr_sgid != credentials.pr_sgid)
			(void) printf(
		"%s    *** SGID: rgid/egid/sgid = %d / %d / %d  ***\n",
			    pri->pname,
			    (int)cred.pr_rgid,
			    (int)cred.pr_egid,
			    (int)cred.pr_sgid);
		if (privdata != NULL && cred.pr_euid != 0) {
			priv_set_t *npset = getset(privs, PRIV_PERMITTED);
			priv_set_t *opset = getset(privdata, PRIV_PERMITTED);
			char *s, *t;
			if (!priv_issubset(npset, opset)) {
				/* Use the to be freed privdata as scratch */
				priv_inverse(opset);
				priv_intersect(npset, opset);
				s = priv_set_to_str(opset, ',', PRIV_STR_SHORT);
				t = priv_set_to_str(npset, ',', PRIV_STR_SHORT);
				(void) printf("%s    *** FPRIV: P/E: %s ***\n",
				    pri->pname,
				    strlen(s) > strlen(t) ? t : s);
				free(s);
				free(t);
			}
		}
	}

	if (privdata != NULL)
		proc_free_priv(privdata);
	credentials = cred;
	privdata = privs;
}

/*
 * Take control of a child process.
 * We come here with truss_lock held.
 */
int
control(private_t *pri, pid_t pid)
{
	const pstatus_t *Psp;
	const lwpstatus_t *Lsp;
	pid_t childpid = 0;
	long flags;
	int rc;

	(void) mutex_lock(&gps->fork_lock);
	while (gps->fork_pid != 0)
		(void) cond_wait(&gps->fork_cv, &gps->fork_lock);
	gps->fork_pid = getpid();	/* parent pid */
	if ((childpid = fork()) == -1) {
		(void) printf("%s\t*** Cannot fork() to control process #%d\n",
		    pri->pname, (int)pid);
		Flush();
		gps->fork_pid = 0;
		(void) cond_broadcast(&gps->fork_cv);
		(void) mutex_unlock(&gps->fork_lock);
		release(pri, pid);
		return (FALSE);
	}

	if (childpid != 0) {
		/*
		 * The parent carries on, after a brief pause.
		 * The parent must wait until the child executes procadd(pid).
		 */
		while (gps->fork_pid != childpid)
			(void) cond_wait(&gps->fork_cv, &gps->fork_lock);
		gps->fork_pid = 0;
		(void) cond_broadcast(&gps->fork_cv);
		(void) mutex_unlock(&gps->fork_lock);
		return (FALSE);
	}

	childpid = getpid();
	descendent = TRUE;
	exit_called = FALSE;
	Pfree(Proc);	/* forget old process */

	/*
	 * The parent process owns the shared gps->fork_lock.
	 * The child must grab it again.
	 */
	(void) mutex_lock(&gps->fork_lock);

	/*
	 * Child grabs the process and retains the tracing flags.
	 */
	if ((Proc = Pgrab(pid, PGRAB_RETAIN, &rc)) == NULL) {
		(void) fprintf(stderr,
		    "%s: cannot control child process, pid# %d: %s\n",
		    command, (int)pid, Pgrab_error(rc));
		gps->fork_pid = childpid;
		(void) cond_broadcast(&gps->fork_cv);
		(void) mutex_unlock(&gps->fork_lock);
		exit(2);
	}

	per_proc_init();
	/*
	 * Add ourself to the set of truss processes
	 * and notify the parent to carry on.
	 */
	procadd(pid, NULL);
	gps->fork_pid = childpid;
	(void) cond_broadcast(&gps->fork_cv);
	(void) mutex_unlock(&gps->fork_lock);

	/*
	 * We may have grabbed the child before it is fully stopped on exit
	 * from fork.  Wait one second (at most) for it to settle down.
	 */
	(void) Pwait(Proc, MILLISEC);
	if (Rdb_agent != NULL)
		Rdb_agent = Prd_agent(Proc);

	Psp = Pstatus(Proc);
	Lsp = &Psp->pr_lwp;
	pri->lwpstat = Lsp;
	data_model = Psp->pr_dmodel;

	make_pname(pri, 0);

	pri->syslast = Psp->pr_stime;
	pri->usrlast = Psp->pr_utime;

	flags = PR_FORK | PR_ASYNC;
	if (Dynpat != NULL)
		flags |= PR_BPTADJ;	/* needed for x86 */
	(void) Psetflags(Proc, flags);

	return (TRUE);
}

/*
 * Take control of an existing process.
 */
int
grabit(private_t *pri, proc_set_t *set)
{
	const pstatus_t *Psp;
	const lwpstatus_t *Lsp;
	int gcode;

	/*
	 * Don't force the takeover unless the -F option was specified.
	 */
	if ((Proc = Pgrab(set->pid, Fflag, &gcode)) == NULL) {
		(void) fprintf(stderr, "%s: %s: %d\n",
		    command, Pgrab_error(gcode), (int)set->pid);
		pri->lwpstat = NULL;
		return (FALSE);
	}
	Psp = Pstatus(Proc);
	Lsp = &Psp->pr_lwp;
	pri->lwpstat = Lsp;

	make_pname(pri, 0);

	data_model = Psp->pr_dmodel;
	pri->syslast = Psp->pr_stime;
	pri->usrlast = Psp->pr_utime;

	if (fflag || Dynpat != NULL)
		(void) Psetflags(Proc, PR_FORK);
	else
		(void) Punsetflags(Proc, PR_FORK);
	procadd(set->pid, set->lwps);
	show_cred(pri, TRUE, FALSE);
	return (TRUE);
}

/*
 * Release process from control.
 */
void
release(private_t *pri, pid_t pid)
{
	/*
	 * The process in question is the child of a traced process.
	 * We are here to turn off the inherited tracing flags.
	 */
	int fd;
	char ctlname[100];
	long ctl[2];

	ctl[0] = PCSET;
	ctl[1] = PR_RLC;

	/* process is freshly forked, no need for exclusive open */
	(void) sprintf(ctlname, "/proc/%d/ctl", (int)pid);
	if ((fd = open(ctlname, O_WRONLY)) < 0 ||
	    write(fd, (char *)ctl, sizeof (ctl)) < 0) {
		perror("release()");
		(void) printf(
		    "%s\t*** Cannot release child process, pid# %d\n",
		    pri->pname, (int)pid);
		Flush();
	}
	if (fd >= 0)	/* run-on-last-close sets the process running */
		(void) close(fd);
}

void
intr(int sig)
{
	/*
	 * SIGUSR1 is special.  It is used by one truss process to tell
	 * another truss process to release its controlled process.
	 * SIGUSR2 is also special.  It is used to wake up threads waiting
	 * for a victim lwp to stop after an event that will leave the
	 * process hung (stopped and abandoned) has occurred.
	 */
	if (sig == SIGUSR1) {
		sigusr1 = TRUE;
	} else if (sig == SIGUSR2) {
		void *value;
		private_t *pri;
		struct ps_lwphandle *Lwp;

		if (thr_getspecific(private_key, &value) == 0 &&
		    (pri = value) != NULL &&
		    (Lwp = pri->Lwp) != NULL)
			(void) Lstop(Lwp, MILLISEC / 10);
	} else {
		interrupt = sig;
	}
}

void
errmsg(const char *s, const char *q)
{
	char msg[512];

	if (s || q) {
		msg[0] = '\0';
		if (command) {
			(void) strcpy(msg, command);
			(void) strcat(msg, ": ");
		}
		if (s)
			(void) strcat(msg, s);
		if (q)
			(void) strcat(msg, q);
		(void) strcat(msg, "\n");
		(void) write(2, msg, (size_t)strlen(msg));
	}
}

void
abend(const char *s, const char *q)
{
	(void) thr_sigsetmask(SIG_SETMASK, &fillset, NULL);
	if (Proc) {
		Flush();
		errmsg(s, q);
		clear_breakpoints();
		(void) Punsetflags(Proc, PR_ASYNC);
		Prelease(Proc, created? PRELEASE_KILL : PRELEASE_CLEAR);
		procdel();
		(void) wait4all();
	} else {
		errmsg(s, q);
	}
	exit(2);
}

/*
 * Allocate memory.
 * If allocation fails then print a message and abort.
 */
void *
my_realloc(void *buf, size_t size, const char *msg)
{
	if ((buf = realloc(buf, size)) == NULL) {
		if (msg != NULL)
			abend("cannot allocate ", msg);
		else
			abend("memory allocation failure", NULL);
	}

	return (buf);
}

void *
my_calloc(size_t nelem, size_t elsize, const char *msg)
{
	void *buf = NULL;

	if ((buf = calloc(nelem, elsize)) == NULL) {
		if (msg != NULL)
			abend("cannot allocate ", msg);
		else
			abend("memory allocation failure", NULL);
	}

	return (buf);
}

void *
my_malloc(size_t size, const char *msg)
{
	return (my_realloc(NULL, size, msg));
}

int
wait4all()
{
	int i;
	pid_t pid;
	int rc = 0;
	int status;

	for (i = 0; i < 10; i++) {
		while ((pid = wait(&status)) != -1) {
			/* return exit() code of the created process */
			if (pid == created) {
				if (WIFEXITED(status))
					rc = WEXITSTATUS(status);
				else
					rc |= 0x80; /* +128 to indicate sig */
			}
		}
		if (errno != EINTR && errno != ERESTART)
			break;
	}

	if (i >= 10)	/* repeated interrupts */
		rc = 2;

	return (rc);
}

void
letgo(private_t *pri)
{
	(void) printf("%s\t*** process otherwise traced, releasing ...\n",
	    pri->pname);
}

/*
 * Test for empty set.
 * support routine used by isemptyset() macro.
 */
int
is_empty(const uint32_t *sp,	/* pointer to set (array of int32's) */
    size_t n)			/* number of int32's in set */
{
	if (n) {
		do {
			if (*sp++)
				return (FALSE);
		} while (--n);
	}

	return (TRUE);
}

/*
 * OR the second set into the first.
 * The sets must be the same size.
 */
void
or_set(uint32_t *sp1, const uint32_t *sp2, size_t n)
{
	if (n) {
		do {
			*sp1++ |= *sp2++;
		} while (--n);
	}
}



/* ============================================================================
 * SOURCE 57/98: minix4\exokernel\kernel_legacy\cmd\svr4pkg\installf\main.c
 * Size: 12,100 bytes, Lines: 505
 * Hash: a319bb8bebae...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

/* Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T */
/* All Rights Reserved */


#include <stdio.h>
#include <fcntl.h>
#include <ctype.h>
#include <errno.h>
#include <string.h>
#include <signal.h>
#include <stdlib.h>
#include <unistd.h>
#include <pkginfo.h>
#include <pkgstrct.h>
#include <pkglocs.h>
#include <locale.h>
#include <libintl.h>
#include <instzones_api.h>
#include <pkglib.h>
#include <install.h>
#include <libadm.h>
#include <libinst.h>
#include "installf.h"

#define	BASEDIR	"/BASEDIR/"

#define	INSTALF	(*prog == 'i')
#define	REMOVEF	(*prog == 'r')

#define	MSG_MANMOUNT	"Assuming mounts were provided."

#define	ERR_PKGNAME_TOO_LONG	\
"The package name specified on the command line\n" \
"exceeds the maximum package name length: a package name may contain a\n" \
"maximum of <%d> characters; however, the package name specified on\n" \
"the command line contains <%d> characters, which exceeds the maximum\n" \
"package name length by <%d> characters. Please specify a package name\n" \
"that contains no more than <%d> characters."

#define	ERR_DB_GET "unable to retrieve entries from the database."
#define	ERR_DB_PUT "unable to update the package database."
#define	ERR_ROOT_SET	"Could not set install root from the environment."
#define	ERR_ROOT_CMD	"Command line install root contends with environment."
#define	ERR_CLASSLONG	"classname argument too long"
#define	ERR_CLASSCHAR	"bad character in classname"
#define	ERR_INVAL	"package instance <%s> is invalid"
#define	ERR_NOTINST	"package instance <%s> is not installed"
#define	ERR_MERG	"unable to merge contents file"
#define	ERR_SORT	"unable to sort contents file"
#define	ERR_I_FAIL	"installf did not complete successfully"
#define	ERR_R_FAIL	"removef did not complete successfully"
#define	ERR_NOTROOT	"You must be \"root\" for %s to execute properly."
#define	ERR_USAGE0	"usage:\n" \
	"\t%s [[-M|-A] -R host_path] [-V ...] pkginst path " \
	"[path ...]\n" \
	"\t%s [[-M|-A] -R host_path] [-V ...] pkginst path\n"

#define	ERR_USAGE1	"usage:\n" \
	"\t%s [[-M] -R host_path] [-V ...] [-c class] <pkginst> " \
	"<path>\n" \
	"\t%s [[-M] -R host_path] [-V ...] [-c class] <pkginst> " \
	"<path> <specs>\n" \
	"\t   where <specs> may be defined as:\n" \
	"\t\tf <mode> <owner> <group>\n" \
	"\t\tv <mode> <owner> <group>\n" \
	"\t\te <mode> <owner> <group>\n" \
	"\t\td <mode> <owner> <group>\n" \
	"\t\tx <mode> <owner> <group>\n" \
	"\t\tp <mode> <owner> <group>\n" \
	"\t\tc <major> <minor> <mode> <owner> <group>\n" \
	"\t\tb <major> <minor> <mode> <owner> <group>\n" \
	"\t\ts <path>=<srcpath>\n" \
	"\t\tl <path>=<srcpath>\n" \
	"\t%s [[-M] -R host_path] [-V ...] [-c class] -f pkginst\n"

#define	CMD_SORT	"sort +0 -1"

#define	LINK	1

extern char	dbst;			/* libinst/pkgdbmerg.c */

struct cfextra **extlist;
struct pinfo **eptlist;

char	*classname = NULL;
char	*pkginst;
char	*uniTmp;
char	*abi_sym_ptr;
char	*ulim;
char	*script;

int	nosetuid;
int	nocnflct;
int	warnflag = 0;

/* libadm/pkgparam.c */
extern void	set_PKGADM(char *newpath);
extern void	set_PKGLOC(char *newpath);

extern void set_limit(void);

int
main(int argc, char **argv)
{
	VFP_T		*cfTmpVfp;
	PKGserver	pkgserver = NULL;
	char		*tp;
	char		*prog;
	char		*pt;
	char		*vfstab_file = NULL;
	char		*temp_cl_basedir;
	char		outbuf[PATH_MAX];
	int		c;
	int		dbchg;
	int		err;
	int		fflag = 0;
	int		map_client = 1;
	int		n;
	int		pkgrmremote = 0;	/* don't remove remote files */
	struct cfent	*ept;

	/* hookup signals */

	(void) signal(SIGHUP, exit);
	(void) signal(SIGINT, exit);
	(void) signal(SIGQUIT, exit);

	/* initialize locale mechanism */

	(void) setlocale(LC_ALL, "");

#if	!defined(TEXT_DOMAIN)	/* Should be defined by cc -D */
#define	TEXT_DOMAIN "SYS_TEST"
#endif	/* !defined(TEXT_DOMAIN) */

	(void) textdomain(TEXT_DOMAIN);

	/* determine program name */

	prog = set_prog_name(argv[0]);

	/* tell instzones interface how to access package output functions */

	z_set_output_functions(echo, echoDebug, progerr);

	/* only allow root to run this program */

	if (getuid() != 0) {
		progerr(gettext(ERR_NOTROOT), prog);
		exit(1);
	}

	ulim = getenv("PKG_ULIMIT");
	script = getenv("PKG_PROC_SCRIPT");

	if (ulim && script) {
		set_limit();
		clr_ulimit();
	}

	/* bug id 4244631, not ABI compliant */
	abi_sym_ptr = getenv("PKG_NONABI_SYMLINKS");
	if (abi_sym_ptr && strncasecmp(abi_sym_ptr, "TRUE", 4) == 0)
		set_nonABI_symlinks();

	/* bugId 4012147 */
	if ((uniTmp = getenv("PKG_NO_UNIFIED")) != NULL)
		map_client = 0;
	if (!set_inst_root(getenv("PKG_INSTALL_ROOT"))) {
		progerr(gettext(ERR_ROOT_SET));
		exit(1);
	}

	while ((c = getopt(argc, argv, "c:V:fAMR:?")) != EOF) {
		switch (c) {
			case 'f':
			fflag++;
			break;

			case 'c':
			classname = optarg;
			/* validate that classname is acceptable */
			if (strlen(classname) > (size_t)CLSSIZ) {
				progerr(gettext(ERR_CLASSLONG));
				exit(1);
			}
			for (pt = classname; *pt; pt++) {
				if (!isalpha(*pt) && !isdigit(*pt)) {
					progerr(gettext(ERR_CLASSCHAR));
					exit(1);
				}
			}
			break;

		/*
		 * Don't map the client filesystem onto the server's. Assume
		 * the mounts have been made for us.
		 */
			case 'M':
			map_client = 0;
			break;

		/*
		 * Allow admin to establish the client filesystem using a
		 * vfstab-like file of stable format.
		 */
			case 'V':
			vfstab_file = flex_device(optarg, 2);
			map_client = 1;
			break;

			case 'A':
			pkgrmremote++;
			break;

			case 'R':	/* added for newroot option */
			if (!set_inst_root(optarg)) {
				progerr(gettext(ERR_ROOT_CMD));
				exit(1);
			}
			break;

			default:
			usage();
			/*NOTREACHED*/
			/*
			 * Although usage() calls a noreturn function,
			 * needed to add return (1);  so that main() would
			 * pass compilation checks. The statement below
			 * should never be executed.
			 */
			return (1);
		}
	}

	if (pkgrmremote && (!is_an_inst_root() || fflag || INSTALF)) {
		usage();
		/*NOTREACHED*/
	}

	/*
	 * Get the mount table info and store internally.
	 */
	if (get_mntinfo(map_client, vfstab_file))
		exit(1);

	/*
	 * This function defines the standard /var/... directories used later
	 * to construct the paths to the various databases.
	 */
	(void) set_PKGpaths(get_inst_root());

	/*
	 * If this is being installed on a client whose /var filesystem is
	 * mounted in some odd way, remap the administrative paths to the
	 * real filesystem. This could be avoided by simply mounting up the
	 * client now; but we aren't yet to the point in the process where
	 * modification of the filesystem is permitted.
	 */
	if (is_an_inst_root()) {
		int fsys_value;

		fsys_value = fsys(get_PKGLOC());
		if (use_srvr_map_n(fsys_value))
			set_PKGLOC(server_map(get_PKGLOC(), fsys_value));

		fsys_value = fsys(get_PKGADM());
		if (use_srvr_map_n(fsys_value))
			set_PKGADM(server_map(get_PKGADM(), fsys_value));
	}

	/*
	 * get the package name and verify length is not too long
	 */

	pkginst = argv[optind++];
	if (pkginst == NULL) {
		usage();
		/*NOTREACHED*/

	}

	n = strlen(pkginst);
	if (n > PKGSIZ) {
		progerr(gettext(ERR_PKGNAME_TOO_LONG), PKGSIZ, n, n-PKGSIZ,
		    PKGSIZ);
		usage();
		/*NOTREACHED*/
	}

	/*
	 * The following is used to setup the environment. Note that the
	 * variable 'BASEDIR' is only meaningful for this utility if there
	 * is an install root, recorded in PKG_INSTALL_ROOT. Otherwise, this
	 * utility can create a file or directory anywhere unfettered by
	 * the basedir associated with the package instance.
	 */
	if ((err = set_basedirs(0, NULL, pkginst, 1)) != 0)
		exit(err);

	if (INSTALF)
		mkbasedir(0, get_basedir());

	if (fflag) {
		/* installf and removef must only have pkginst */
		if (optind != argc) {
			usage();
			/*NOTREACHED*/
		}
	} else {
		/*
		 * installf and removef must have at minimum
		 * pkginst & pathname specified on command line
		 */
		if (optind >= argc) {
			usage();
			/*NOTREACHED*/
		}
	}
	if (REMOVEF) {
		if (classname) {
			usage();
		}
	}
	if (pkgnmchk(pkginst, "all", 0)) {
		progerr(gettext(ERR_INVAL), pkginst);
		exit(1);
	}
	if (fpkginst(pkginst, NULL, NULL) == NULL) {
		progerr(gettext(ERR_NOTINST), pkginst);
		exit(1);
	}

	/*
	 * This maps the client filesystems into the server's space.
	 */
	if (map_client && !mount_client())
		logerr(gettext(MSG_MANMOUNT));

	/* open the package database (contents) file */

	if (!ocfile(&pkgserver, &cfTmpVfp, 0L)) {
		quit(1);
	}

	if (fflag) {
		dbchg = dofinal(pkgserver, cfTmpVfp, REMOVEF, classname, prog);
	} else {
		if (INSTALF) {
			dbst = INST_RDY;
			if (installf(argc-optind, &argv[optind]))
				quit(1);
		} else {
			dbst = RM_RDY;
			removef(argc-optind, &argv[optind]);
		}

		dbchg = pkgdbmerg(pkgserver, cfTmpVfp, extlist);
		if (dbchg < 0) {
			progerr(gettext(ERR_MERG));
			quit(99);
		}
	}

	if (dbchg) {
		if ((n = swapcfile(pkgserver, &cfTmpVfp, pkginst, 1))
		    == RESULT_WRN) {
			warnflag++;
		} else if (n == RESULT_ERR) {
			quit(99);
		}
	}

	relslock();

	if (REMOVEF && !fflag) {
		for (n = 0; extlist[n]; n++) {
			ept = &(extlist[n]->cf_ent);

			/* Skip duplicated paths */
			if ((n > 0) && (strncmp(ept->path,
			    extlist[n-1]->cf_ent.path, PATH_MAX) == 0)) {
				continue;
			}

			if (!extlist[n]->mstat.shared) {
				/*
				 * Only output paths that can be deleted.
				 * so need to skip if the object is owned
				 * by a remote server and removal is not
				 * being forced.
				 */
				if (ept->pinfo &&
				    (ept->pinfo->status == SERVED_FILE) &&
				    !pkgrmremote)
					continue;

				c = 0;
				if (is_a_cl_basedir() && !is_an_inst_root()) {
					/*
					 * A path in contents db might have
					 * other prefix than BASEDIR of the
					 * package
					 */
					temp_cl_basedir = get_client_basedir();
					if (strncmp(ept->path, temp_cl_basedir,
					    strlen(temp_cl_basedir)) == 0) {
						c = strlen(temp_cl_basedir);
						(void) snprintf(outbuf,
						    sizeof (outbuf), "%s/%s\n",
						    get_basedir(),
						    &(ept->path[c]));
					} else {
						(void) snprintf(outbuf,
						    sizeof (outbuf),
						    "%s\n", &(ept->path[c]));
					}
				} else if (is_an_inst_root()) {
					(void) snprintf(outbuf, sizeof (outbuf),
					    "%s/%s\n", get_inst_root(),
					    &(ept->path[c]));
				} else {
					(void) snprintf(outbuf, sizeof (outbuf),
					    "%s\n", &(ept->path[c]));
				}
				canonize(outbuf);
				(void) printf("%s", outbuf);
			}
		}
	} else if (INSTALF && !fflag) {
		for (n = 0; extlist[n]; n++) {
			ept = &(extlist[n]->cf_ent);

			if (strchr("dxcbp", ept->ftype)) {
				tp = fixpath(ept->path);
				(void) averify(1, &ept->ftype, tp, &ept->ainfo);
			}
		}
	}

	pkgcloseserver(pkgserver);

	z_destroyMountTable();

	quit(warnflag ? 1 : 0);
	/* LINTED: no return */
}

void
quit(int n)
{
	char *prog = get_prog_name();

	unmount_client();

	if (ulim && script) {
		if (REMOVEF) {
			set_ulimit(script, gettext(ERR_R_FAIL));
		} else {
			set_ulimit(script, gettext(ERR_I_FAIL));
		}
	}

	exit(n);
}

void
usage(void)
{
	char *prog = get_prog_name();

	if (REMOVEF) {
		(void) fprintf(stderr, gettext(ERR_USAGE0), prog, prog);
	} else {
		(void) fprintf(stderr, gettext(ERR_USAGE1), prog, prog, prog);
	}
	exit(1);
}



/* ============================================================================
 * SOURCE 58/98: minix4\exokernel\kernel_legacy\cmd\svr4pkg\pkgadd\main.c
 * Size: 112,079 bytes, Lines: 4,219
 * Hash: 8932223f0c36...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (c) 2018 Peter Tribble.
 */

/*
 * Copyright (c) 1989, 2010, Oracle and/or its affiliates. All rights reserved.
 */

/* Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T */
/* All Rights Reserved */


/*
 * Program:	pkgadd / pkgask
 *
 * Function:	public command and private utility functions that
 *		implement the package add and package ask operations.
 *
 */

/*
 * System includes
 */

#include <stdio.h>
#include <limits.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <signal.h>
#include <errno.h>
#include <pkgdev.h>
#include <pkginfo.h>
#include <pkglocs.h>
#include <locale.h>
#include <libintl.h>
#include <pkgtrans.h>
#include <assert.h>

/*
 * consolidation pkg command library includes
 */
#include <pkglib.h>

#include <instzones_api.h>

/*
 * local pkg command library includes
 */
#include <install.h>
#include <libinst.h>
#include <libadm.h>
#include <messages.h>


/*
 * pkgadd local includes
 */

#include "quit.h"

/*
 * imported global variables/functions
 */

/* check.c */
extern int	preinstall_verify(char **a_pkgList, zoneList_t a_zlst,
			char *a_zoneTempDir);

/*
 * ckquit is a global that controls 'ckyorn' (defined in libadm)
 * If ckquit is non-zero, then "quit" is allowed as an answer when
 * ckyorn is called. If is it zero, then "quit" is not an allowed answer.
 */
extern int	ckquit;

/*
 * exported global variables
 */

/* these globals are set by ckreturn and used by quit.c */

int	admnflag = 0;	/* != 0 if any pkg op admin setting failure (4) */
int	doreboot = 0;	/* != 0 if reboot required after installation */
int	failflag = 0;	/* != 0 if fatal error has occurred (1) */
int	intrflag = 0;	/* != 0 if user selected quit (3) */
int	ireboot = 0;	/* != 0 if immediate reboot required */
int	nullflag = 0;	/* != 0 if admin interaction required (5) */
int	warnflag = 0;	/* != 0 if non-fatal error has occurred (2) */

/* imported by quit.c */
int	npkgs = 0;	/* the number of packages yet to be installed */

/* imported by various (many) */
char	*respfile = NULL;	/* response pathname (or NULL) */
char	*tmpdir = NULL;		/* location to place temporary files */

struct admin	adm;		/* holds info about installation admin */
struct pkgdev	pkgdev;		/* holds info about the installation device */

/*
 * internal global variables
 */

static char	*admnfile = NULL;	/* file to use for installation admin */
static char	*ids_name = NULL;	/* name of data stream device */
static char	*pkgcontsrc = NULL;	/* continuation file (-c option) */
static char	*pkgdrtarg = NULL;	/* dry run file (-D option) */
static char	*pkginst = NULL;	/* current pkg/src instance 2 process */
static char	*respdir = NULL;	/* respfile is a directory spec */
static char	*rw_block_size = NULL;
static char	*vfstab_file = NULL;
static int	askflag = 0;		/* non-zero if invoked as "pkgask" */
static int	disableAttributes = 0;	/* Disabling attribute checking */
static int	disableChecksum = 0;	/* Disable checksumming */
static int	disableSaveSpool = 0;	/* Disable partial spool dir create */
static int	init_install = 0;	/* inform scripts initial install */
static int	no_map_client = 0;	/* do not map from vfstab file */
static int	nointeract = 0;		/* non-zero - no user interaction */
static int	pkgverbose = 0;		/* non-zero if verbose mode selected */
static int	saveSpoolInstall = 0;	/* installing from save spool dir */
static int	suppressCopyright = 0;	/* suppress copyright notices */

/* set by ckreturn() */

static int	interrupted = 0;	/* last pkg op was quit (1,2,3,4,5) */
static int	needconsult = 0;	/* essential ask admin now (1,2,3,5) */

/* Set by -O nozones: do not process any zones */

static boolean_t	noZones = B_FALSE;

/* Set by -O zonelist=<names...>: process only named zones */

static boolean_t	usedZoneList = B_FALSE;

/* Set by -O debug: debug output is enabled? */

static boolean_t	debugFlag = B_FALSE;

/* Set by the -G option: install packages in global zone only */

static boolean_t	globalZoneOnly = B_FALSE;

/*
 * Assume the package is ABI and POSIX compliant as regards user
 * interactiion during procedure scripts.
 */

static int	old_pkg = 0;

/* Assume pkg should be installed according to the ABI */

static int	old_symlinks = 0;

/*
 * Default name length will be 32 chars - if this is set,
 * disable the 32 char name limit extension
 */

static int	ABI_namelength = 0;

#if	!defined(TEXT_DOMAIN)	/* Should be defined by cc -D */
#define	TEXT_DOMAIN	"SYS_TEST"
#endif

/* printable string - if string is null results in ??? */

#define	PSTR(STR) (((STR) == (char *)NULL) ? "???" : (STR))

#define	MAX_FDS	20

/*
 * forward declarations
 */

static int		boot_and_pkginstall_check_in_zones(zoneList_t a_zlst,
				char *a_idsName, char *a_altBinDir,
				char *a_zoneAdminFile, char *a_zoneTempDir);
static int		boot_and_install_in_zones(zoneList_t a_zlst,
				char *a_idsName, char *a_altBinDir,
				char *a_zoneAdminFile, char *a_zoneTempDir);
static void		pkginstall_check_in_one_zone(char *a_zoneName,
				char *a_idsName, char *a_zoneAdminFile,
				char *a_zoneTempDir, char *a_altBinDir,
				char *a_scratchName, zone_state_t a_zoneState,
				boolean_t a_tmpzn);
static void		ckreturn(int retcode);
static void		create_zone_adminfile(char **r_zoneAdminFile,
				char *a_zoneTempDir, char *a_admnfile);
static void		create_zone_tempdir(char **r_zoneTempDir,
				char *a_tmpdir);
static void		install_in_one_zone(char *a_zoneName, char *a_idsName,
				char *a_zoneAdminFile, char *a_zoneTempDir,
				char *a_altBinDir, zone_state_t a_zoneState,
				boolean_t a_tmpzn);
static int		pkginstall_check_in_zones(zoneList_t a_zlst,
				char *a_idsName, char *a_altBinDir,
				char *a_zoneAdminFile, char *a_zoneTempDir);
static int		install_in_zones(zoneList_t a_zlst, char *a_idsName,
				char *a_altBinDir, char *a_zoneAdminFile,
				char *a_zoneTempDir);
static int		pkgInstall(char *ir, char *a_idsName, char *a_pkgDir,
				char *a_altBinDir);
static int		pkgZoneCheckInstall(char *a_zoneName,
				zone_state_t a_zoneState,
				char *a_idsName, char *a_altBinDir,
				char *a_adminFile, char *a_stdoutPath,
				boolean_t a_tmpzn);
static int		pkgZoneInstall(char *a_zoneName,
				zone_state_t a_zoneState,
				char *a_idsName, char *a_altBinDir,
				char *a_adminFile, boolean_t a_tmpzn);
static void		resetreturn();
static void		usage(void);
static boolean_t	add_packages(char **a_pkgList,
				char *a_idsName, int a_repeat,
				char *a_altBinDir, char *a_device,
				boolean_t a_noZones);
static boolean_t	add_packages_in_global_no_zones(char **a_pkgList,
				char *a_idsName, int a_repeat,
				char *a_altBinDir, char *a_device);
static boolean_t	add_packages_in_global_with_zones(char **a_pkgList,
				char *a_idsName, int a_repeat,
				char *a_altBinDir, char *a_device,
				zoneList_t a_zlst);
static boolean_t	add_packages_in_nonglobal_zone(char **a_pkgList,
				char *a_idsName, int a_repeat,
				char *a_altBinDir, char *a_device);
static boolean_t	check_applicability(char *a_packageDir,
				char *a_pkgInst, char *a_rootPath,
				CAF_T a_flags);
static boolean_t	get_package_list(char ***r_pkgList, char **a_argv,
				char *a_categories, char **a_categoryList,
				char *a_idsName, int *r_repeat);
static boolean_t	continue_installation(void);
static boolean_t	unpack_and_check_packages(char **a_pkgList,
				char *a_idsName, char *a_packageDir);
/*
 * *****************************************************************************
 * global external (public) functions
 * *****************************************************************************
 */

/*
 * Name:	main
 * Description:	main entry point for pkgadd/pkgask
 * Returns:	int
 *   0        Successful completion
 *   1        Fatal error.
 *   2        Warning.
 *   3        Interruption.
 *   4        Administration.
 *   5        Administration. Interaction is required. Do not use pkgadd -n.
 * In addition, one of the following values may be added to the previous value
 * as appropriate:
 *  10       Reboot after installation of all packages.
 *  20       Reboot after installation of this package.
 * For example, "14" would indicate both "administration" and "reboot after
 * installation of all packages".
 */

int
main(int argc, char **argv)
{
	char			**category = NULL;
	char			*abiPtr;
	char			*altBinDir = (char *)NULL;
	char			*catg_arg = NULL;
	char			*device = NULL;		/* dev pkg stored on */
	char			*p;
	char			*q;
	char			*prog;
	char			*prog_full_name = NULL;
	char			*spoolDir = NULL;	/* specified with -s */
	char			Rpath[PATH_MAX+1] = {'\0'};
	int			c;
	int			n;
	int			repeat;
	struct sigaction	nact;
	struct sigaction	oact;

	/* initialize locale environment */

	(void) setlocale(LC_ALL, "");
	(void) textdomain(TEXT_DOMAIN);

	/* initialize program name */

	prog_full_name = argv[0];
	prog = set_prog_name(argv[0]);

	/* tell spmi zones interface how to access package output functions */

	z_set_output_functions(echo, echoDebug, progerr);

	askflag = (strcmp(prog, "pkgask") == 0);

	/* set sane umask */

	(void) umask(0022);

	/* tell quit which ckreturn function to call */

	quitSetCkreturnFunc(&ckreturn);

	/* initially no source "device" */

	device = NULL;

	/* reset npkgs (used as pkg remaining count in quit.c) */

	npkgs = 0;

	if (z_running_in_global_zone() && !enable_local_fs()) {
		progerr(ERR_CANNOT_ENABLE_LOCAL_FS);
	}

	pkgserversetmode(DEFAULTMODE);

	/*
	 * ********************************************************************
	 * parse command line options
	 * ********************************************************************
	 */

	while ((c = getopt(argc, argv,
	    "?Aa:b:B:Cc:D:d:GhIMnO:R:r:Ss:tV:vY:z")) != EOF) {
		switch (c) {

		/*
		 * Not a public interface: This disables attribute checking.
		 * It speeds up installation a little bit.
		 */
		case 'A':
			disableAttributes++;
			break;

		/*
		 * Public interface: Define an installation administration
		 * file, admin, to be used in place of the default
		 * administration file.	 The token none overrides the use
		 * of any admin file, and thus forces interaction with the
		 * user. Unless a full path name is given, pkgadd first
		 * looks in the current working directory for the
		 * administration file.	 If the specified administration
		 * file is not in the current working directory, pkgadd
		 * looks in the /var/sadm/install/admin directory for the
		 * administration file.
		 */
		case 'a':
			admnfile = flex_device(optarg, 0);
			break;

		/*
		 * Not a public interface: control block size given to
		 * pkginstall - block size used in read()/write() loop;
		 * default is st_blksize from stat() of source file.
		 */
		case 'B':
			if (optarg[0] == '-') {
				usage();
				quit(1);
			}
			rw_block_size = optarg;
			break;

		/*
		 * Not a public interface:  location where package executables
		 * can be found - default is /usr/sadm/install/bin.
		 */
		case 'b':
			if (optarg[0] == '-') {
				usage();
				quit(1);
			}
			if (!path_valid(optarg)) {
				progerr(ERR_PATH, optarg);
				quit(1);
			}
			if (isdir(optarg) != 0) {
				p = strerror(errno);
				progerr(ERR_CANNOT_USE_DIR, optarg, p);
				quit(1);
			}
			altBinDir = optarg;
			break;

		/*
		 * Not a public interface: This disables checksum tests on
		 * the source files. It speeds up installation a little bit.
		 */
		case 'C':
			disableChecksum++;
			break;

		/*
		 * Not a public interface: This allows designation of a
		 * continuation file. It is the same format as a dryrun file
		 * but it is used to take up where the dryrun left off.
		 */
		case 'c':
			pkgcontsrc = flex_device(optarg, 0);
			break;

		/*
		 * Not a public interface: This allows designation of a
		 * dryrun file. This pkgadd will create dryrun files
		 * in the directory provided.
		 */
		case 'D':
			if (optarg[0] == '-') {
				usage();
				quit(1);
			}
			pkgdrtarg = flex_device(optarg, 0);
			break;

		/*
		 * Public interface: Install or copy a package from
		 * device. device can be a full path name to a directory
		 * or the identifiers for tape, floppy disk, or removable
		 * disk - for example, /var/tmp or /floppy/floppy_name.
		 * It can also be a device alias - for example,
		 * /floppy/floppy0, or a datastream created by pkgtrans.
		 */
		case 'd':
			if (optarg[0] == '-') {
				usage();
				quit(1);
			}
			if (!path_valid(optarg)) {
				progerr(ERR_PATH, optarg);
				quit(1);
				/* NOTREACHED */
			}

			device = flex_device(optarg, 1);
			break;

		/*
		 * Public interface: install package in global zone only.
		 */
		case 'G':
			globalZoneOnly = B_TRUE;
			break;

		/*
		 * Not a public interface: Enable hollow package support. When
		 * specified, for any package that has SUNW_PKG_HOLLOW=true:
		 *  Do not calculate and verify package size against target.
		 *  Do not run any package procedure or class action scripts.
		 *  Do not create any target directories.
		 *  Do not perform any script locking.
		 *  Do not install any components of any package.
		 *  Do not output any status or database update messages.
		 */
		case 'h':
			set_depend_pkginfo_DB(B_TRUE);
			break;

		/*
		 * Not a public interface: Informs scripts that this is
		 * an initial install by setting the environment parameter
		 * PKG_INIT_INSTALL=TRUE for all scripts. They may use it as
		 * they see fit, safe in the knowledge that the target
		 * filesystem is tabula rasa.
		 */
		case 'I':
			init_install++;
			break;

		/*
		 * Public interface: Instruct pkgadd not to use the
		 * $root_path/etc/vfstab file for determining the client's
		 * mount points. This option assumes the mount points are
		 * correct on the server and it behaves consistently with
		 * Solaris 2.5 and earlier releases.
		 */
		case 'M':
			no_map_client = 1;
			break;

		/*
		 * Not a public interface: the -O option allows the behavior
		 * of the package tools to be modified. Recognized options:
		 * -> debug
		 * ---> enable debugging output
		 * -> addzonename
		 * ---> add zone name to appropriate messages
		 * -> nozones
		 * ---> act as though in global zone with no non-global zones
		 * -> enable-hollow-package-support
		 * ---> Enable hollow package support. When specified, for any
		 * ---> package that has SUNW_PKG_HOLLOW=true:
		 * ---> Do not calculate and verify package size against target
		 * ---> Do not run any package procedure or class action scripts
		 * ---> Do not create any target directories
		 * ---> Do not perform any script locking
		 * ---> Do not install any components of any package
		 * ---> Do not output any status or database update messages
		 * -> zonelist="<names...>"
		 * ---> add package to space/colon separated list of zones only
		 */

		case 'O':
			for (p = strtok(optarg, ","); p != (char *)NULL;
			    p = strtok(NULL, ",")) {

				if (strcmp(p, "debug") == 0) {
					/* set debug flag/enable debug output */
					debugFlag = B_TRUE;
					(void) echoDebugSetFlag(debugFlag);

					/* debug info on arguments to pkgadd */
					for (n = 0; n < argc && argv[n]; n++) {
						echoDebug(DBG_ARG, n, argv[n]);
					}

					continue;
				}

				if (strcmp(p,
				    "enable-hollow-package-support") == 0) {
					set_depend_pkginfo_DB(B_TRUE);
					continue;
				}

				if (strcmp(p, "addzonename") == 0) {
					quitSetZoneName(z_get_zonename());
					continue;
				}

				if (strcmp(p, "nozones") == 0) {
					noZones = B_TRUE;
					continue;
				}

				if (strncmp(p, "zonelist=", 9) == 0) {
					/*
					 * If colons used as separators,
					 * convert to spaces.
					 */
					q = p + 9;
					while (*q != '\0') {
						if (*q == ':') {
							*q = ' ';
						}
						q++;
					}

					if (z_set_zone_spec(p + 9) == -1)
						quit(1);
					usedZoneList = B_TRUE;
					continue;
				}

				progerr(ERR_INVALID_O_OPTION, p);
				continue;
			}
			break;

		/*
		 * Public interface: installation occurs in
		 * non-interactive mode.  Suppress output of the list of
		 * installed files. The default mode is interactive.
		 */
		case 'n':
			nointeract++;
			(void) echoSetFlag(B_FALSE);
			break;

		/*
		 * Public interface: Define the full path name of a
		 * directory to use as the root_path.  All files,
		 * including package system information files, are
		 * relocated to a directory tree starting in the specified
		 * root_path. The root_path may be specified when
		 * installing to a client from a server (for example,
		 * /export/root/client1).
		 */
		case 'R':
			if (optarg[0] == '-') {
				usage();
				quit(1);
			}
			/* determine the real path specified */

			n = resolvepath(optarg, Rpath, sizeof (Rpath)-1);

			/* use supplied path if not resolvable */

			if (n == -1) {
				(void) strlcpy(Rpath, optarg, sizeof (Rpath));
			} else {
				/* null terminate string */
				Rpath[n] = '\0';
			}

			/* set the alternative root path */

			if (!set_inst_root(Rpath)) {
				progerr(ERR_ROOT_CMD);
				exit(1);
			}
			break;

		/*
		 * Public interface: Identify a file or directory which
		 * contains output from a previous pkgask(8)
		 * session. This file supplies the interaction responses
		 * that would be requested by the package in interactive
		 * mode. response must be a full pathname.
		 */
		case 'r':
			if (optarg[0] == '-') {
				usage();
				quit(1);
			}
			respfile = flex_device(optarg, 2);
			if (isdir(respfile) == 0)
				respdir = respfile;
			break;

		/*
		 * Not a public interface: suppress copyright notice being
		 * output during installation.
		 */
		case 'S':
			suppressCopyright++;
			break;

		/*
		 * Public interface: Write the package into the directory
		 * spool instead of installing it. The default directory
		 * for spooled packages is /var/sadm/pkg.
		 */
		case 's':
			spoolDir = flex_device(optarg, 1);
			break;

		/*
		 * Not a public interface: disable save spool area creation;
		 * suppress the creation and population of the package save
		 * spool area (var/sadm/pkg/PKG/save/pspool/PKG).
		 */
		case 't':
			disableSaveSpool++;
			break;

		/*
		 * Public interface: Specify an alternative fs_file to map
		 * the client's file systems.  For example, used in
		 * situations where the $root_path/etc/vfstab file is
		 * non-existent or unreliable. Informs the pkginstall
		 * portion to mount up a client filesystem based upon the
		 * supplied vfstab-like file of stable format.
		 */
		case 'V':
			vfstab_file = flex_device(optarg, 2);
			no_map_client = 0;
			break;

		/*
		 * Public interface: Trace all of the scripts that get
		 * executed by pkgadd, located in the pkginst/install
		 * directory. This option is used for debugging the
		 * procedural and non-procedural scripts
		 */
		case 'v':
			pkgverbose++;
			break;

		/*
		 * Public interface: Install packages based on the value
		 * of the CATEGORY parameter stored in the package's
		 * pkginfo(5) file. All packages on the source medium
		 * whose CATEGORY matches one of the specified categories
		 * will be selected for installation or spooling. Install
		 * packages that contain the same CATEGORY as the one
		 * provided on the command line.
		 */
		case 'Y':
			if (optarg[0] == '-') {
				usage();
				quit(1);
			}
			catg_arg = strdup(optarg);

			if ((category = get_categories(catg_arg)) == NULL) {
				progerr(ERR_CAT_INV, catg_arg);
				exit(1);
			} else if (is_not_valid_length(category)) {
				progerr(ERR_CAT_LNGTH);
				exit(1);
			}
			break;

		/*
		 * Not a public interface: perform fresh install from
		 * package save spool area. When set, the package contents
		 * are installed from the package spool save area instead
		 * of from the package root area, so that the original
		 * source packages are not required to install the
		 * package. If the -h option is also specified and the
		 * package is hollow, then this option is ignored. When -z
		 * is specified:
		 *  - Editable files are installed from the package instance
		 *    save area.
		 *  - Volatile files are installed from the package instance
		 *    save area.
		 *  - Executable and data files are installed from the final
		 *    installed location as specified in the pkgmap file.
		 *  - Installation scripts are run from the package spool
		 *    save area.
		 */
		case 'z':
			saveSpoolInstall++;
			break;

		/*
		 * unrecognized option
		 */

		default:
			usage();
			return (1);
		}
	}

	/*
	 * ********************************************************************
	 * validate command line options
	 * ********************************************************************
	 */

	/* set "debug echo" flag according to setting of "-O debug" option */

	(void) echoDebugSetFlag(debugFlag);

	/* output entry debugging information */

	if (z_running_in_global_zone()) {
		echoDebug(DBG_ENTRY_IN_GZ, prog_full_name);
	} else {
		echoDebug(DBG_ENTRY_IN_LZ, prog_full_name, getzoneid(),
		    z_get_zonename());
	}

	/*
	 * Later, it may be decided to pursue this ability to continue to an
	 * actual installation based only on the dryrun data. At this time,
	 * it is too risky.
	 */

	if (pkgcontsrc && !pkgdrtarg) {
		progerr(ERR_NO_LIVE_MODE);
		usage();
		return (1);
	}

	/* ignore -G option if not used in the global zone */

	if (!z_running_in_global_zone()) {
		globalZoneOnly = B_FALSE;
	}

	/* if zonelist used, must be in global zone */

	if (usedZoneList && !z_running_in_global_zone()) {
		progerr(ERR_Z_USED_IN_NONGLOBAL_ZONE);
		return (1);
	}

	/* -G and zonelist cannot be used together */

	if (globalZoneOnly && usedZoneList) {
		progerr(ERR_GZ_USED_TOGETHER);
		usage();
		return (1);
	}

	/* -s cannot be used with either -G or zonelist */

	if (spoolDir != NULL) {
		if (globalZoneOnly) {
			progerr(ERR_SPOOLDIR_USED_WITH_G);
			usage();
			return (1);
		}
		if (usedZoneList) {
			progerr(ERR_SPOOLDIR_USED_WITH_Z);
			usage();
			return (1);
		}
		if (strcmp(spoolDir, "/var/sadm/pkg") == 0) {
			progerr(ERR_SPOOLDIR_CANNOT_BE_SYS, "/var/sadm/pkg");
			usage();
			return (1);
		}
	}

	/* pkgask does not support the same options as pkgadd */

	if (askflag && spoolDir) {
		progerr(ERR_PKGASK_AND_SPOOLDIR);
		usage();
		return (1);
	}

	if (askflag && nointeract) {
		progerr(ERR_PKGASK_AND_NOINTERACT);
		usage();
		return (1);
	}

	/* cannot use response file/not-interactive and spool-to directory */

	if (spoolDir && nointeract) {
		progerr(ERR_SPOOLDIR_AND_NOINTERACT);
		usage();
		return (1);
	}

	if (spoolDir && respfile) {
		progerr(ERR_SPOOLDIR_AND_RESPFILE);
		usage();
		return (1);
	}

	if (usedZoneList) {
		/* Verify supplied zone list valid for the target */
		if (z_verify_zone_spec() == -1)
			return (1);

		/* -z zonelist=global is logically the same as -G */
		if (z_global_only() && z_running_in_global_zone())
			globalZoneOnly = B_TRUE;
	}

	/*
	 * hook SIGINT and SIGHUP interrupts into quit.c's trap handler
	 */

	/* hold SIGINT/SIGHUP interrupts */

	(void) sighold(SIGHUP);
	(void) sighold(SIGINT);

	/* connect quit.c:trap() to SIGINT */

	nact.sa_handler = quitGetTrapHandler();
	nact.sa_flags = SA_RESTART;
	(void) sigemptyset(&nact.sa_mask);

	(void) sigaction(SIGINT, &nact, &oact);

	/* connect quit.c:trap() to SIGHUP */

	nact.sa_handler = quitGetTrapHandler();
	nact.sa_flags = SA_RESTART;
	(void) sigemptyset(&nact.sa_mask);

	(void) sigaction(SIGHUP, &nact, &oact);

	/* release hold on signals */

	(void) sigrelse(SIGHUP);
	(void) sigrelse(SIGINT);

	/*
	 * This function is in the libadm library; it sets:
	 * -> get_PKGLOC() = <install_root>/var/sadm/pkg
	 * -> get_PKGADM() = <install_root>/var/sadm/install
	 * -> pkgdir = <install_root>/var/sadm/pkg
	 * -> pkg_install_root = <install_root>
	 * This controls operations of libadm functions such as:
	 * -> pkginfofind, pkginfopen, fpkgparam, pkgparam, get_PKGLOC,
	 * -> get_PKGADM, get_install_root
	 */

	set_PKGpaths(get_inst_root());
	echoDebug(DBG_PKGADD_PKGPATHS,
	    get_PKGLOC() ? get_PKGLOC() : "",
	    get_PKGADM() ? get_PKGADM() : "");

	/*
	 * This function is in the libinst library; it reads the specified
	 * admin(5) file and, using fpkgparam(), sets the global "adm" structure
	 * values to match what is in the specified admin file.
	 */

	echoDebug(DBG_PKGADD_ADMINFILE, admnfile ? admnfile : "");
	setadminFile(admnfile);

	/*
	 * if running in the global zone, and non-global zones exist, then
	 * enable hollow package support so that any packages that are marked
	 * SUNW_PKG_HOLLOW=true will be correctly installed in non-global zones
	 * when added directly in the global zone by the global zone admin.
	 */

	if (is_depend_pkginfo_DB()) {
		echoDebug(DBG_PKGADD_HOLLOW_ENABLED);
	} else if ((z_running_in_global_zone() == B_TRUE) &&
	    (z_non_global_zones_exist() == B_TRUE)) {
		echoDebug(DBG_PKGADD_ENABLING_HOLLOW);
		set_depend_pkginfo_DB(B_TRUE);
	}

	/* if no device, get and validate default device */

	if (device == NULL) {
		device = devattr("spool", "pathname");
		if (device == NULL) {
			progerr(ERR_NODEVICE);
			quit(1);
			/* NOTREACHED */
		}
	}

	/* must be root if not directing results to spool directory */

	if ((getuid() != 0) && (spoolDir == NULL)) {
		progerr(ERR_NOT_ROOT, prog);
		exit(1);
	}

	/*
	 * process response file argument
	 */

	if (respfile) {
		echoDebug(DBG_PKGADD_RESPFILE,
		    respfile, respdir ? respdir : "");

		if (respfile[0] != '/') {
			progerr(ERR_RSP_FILE_NOTFULLPATH, respfile);
			quit(1);
			/* NOTREACHED */
		}
		if (respdir == NULL) {
			if (askflag) {
				if (access(respfile, F_OK) == 0) {
					progerr(ERR_NORESP, respfile);
					quit(1);
					/* NOTREACHED */
				}
			} else if (access(respfile, F_OK) != 0) {
				progerr(ERR_ACCRESP, respfile);
				quit(1);
				/* NOTREACHED */
			}
		}
	} else if (askflag) {
		progerr(ERR_RSP_FILE_NOT_GIVEN);
		usage();
		quit(1);
		/* NOTREACHED */
	}

	/* establish temporary directory to use */

	if ((tmpdir = getenv("TMPDIR")) == NULL) {
		/* use default - no override specified */
		tmpdir = P_tmpdir;
	}

	echoDebug(DBG_PKGADD_TMPDIR, tmpdir);

	/*
	 * See if user wants this to be handled as an old style pkg.
	 * NOTE : the ``exception_pkg()'' stuff is to be used only
	 * through on495. This function comes out for on1095. See
	 * PSARC 1993-546. -- JST
	 */

	if (getenv("NONABI_SCRIPTS") != NULL) {
		old_pkg = 1;
	}

	/*
	 * See if the user wants to process symlinks consistent with
	 * the old behavior.
	 */

	if (getenv("PKG_NONABI_SYMLINKS") != NULL) {
		old_symlinks = 1;
	}

	/*
	 * See if the user wants the package name length restricted.
	 */

	abiPtr = getenv("PKG_ABI_NAMELENGTH");
	if (abiPtr && strncasecmp(abiPtr, "TRUE", 4) == 0) {
		ABI_namelength = 1;
	}

	/*
	 * validate the package source device - return pkgdev info that
	 * describes the package source device.
	 */

	if (devtype(device, &pkgdev)) {
		progerr(ERR_BAD_DEVICE, device);
		quit(1);
		/* NOTREACHED */
	}

	/*
	 * If writing the packages into a spool directory instead of
	 * installing the packages, open the package datastream and
	 * invoke pkgtrans to perform the conversion and exit.
	 */

	if (spoolDir != (char *)NULL) {
		boolean_t	b;
		int		n;

		echoDebug(DBG_INSTALLING_TO_SPOOL, spoolDir);

		b = open_package_datastream(argc, argv, spoolDir, device,
		    &repeat, &ids_name, tmpdir,
		    &pkgdev, optind);

		quitSetIdsName(ids_name);

		if (b != B_TRUE) {
			progerr(ERR_CANNOT_OPEN_PKG_STREAM, PSTR(device));
			quit(1);
		}

		n = pkgtrans(device, spoolDir, &argv[optind], 0);
		quit(n);
		/* NOTREACHED */
	}

	/*
	 * error if there are packages on the command line and a category
	 * was specified
	 */

	if ((optind < argc) && (catg_arg != NULL)) {
		progerr(ERR_PKGS_AND_CAT_PKGADD);
		usage();
		quit(1);
		/* NOTREACHED */
	}

	/*
	 * ********************************************************************
	 * main package processing "loop"
	 * ********************************************************************
	 */

	ids_name = NULL;
	quitSetIdsName(ids_name);

	for (;;) {
		boolean_t	b;
		char		**pkglist;	/* points to array of pkgs */

		/*
		 * open next package data stream
		 */

		b = open_package_datastream(argc, argv, spoolDir, device,
		    &repeat, &ids_name, tmpdir,
		    &pkgdev, optind);

		quitSetIdsName(ids_name);

		if (b == B_FALSE) {
			echoDebug(ERR_CANNOT_OPEN_PKG_STREAM, PSTR(device));
			continue;
		}

		/*
		 * package source data stream open - get the package list
		 */

		b = get_package_list(&pkglist, argv, catg_arg, category,
		    ids_name, &repeat);

		if (b == B_FALSE) {
			echoDebug(DBG_CANNOT_GET_PKGLIST);

			progerr(ERR_NOPKGS, pkgdev.dirname);
			quit(1);
			/* NOTREACHED */
		}

		/*
		 * count the number of packages to install
		 * NOTE: npkgs is a global variable that is referenced by quit.c
		 * when error messages are generated - it is referenced directly
		 * by the other functions called below...
		 */

		for (npkgs = 0; pkglist[npkgs] != (char *)NULL; /* void */) {
			echoDebug(DBG_PKG_SELECTED, npkgs, pkglist[npkgs]);
			npkgs++;
		}

		/* output number of packages to be added */

		echoDebug(DBG_NUM_PKGS_TO_ADD, npkgs);

		/*
		 * if pkgask and response container is a file (not a directory),
		 * and there is more than one package to install, then it is an
		 * error - too many packages to install when response container
		 * is a file.
		 */

		if ((askflag != 0) && (respdir == (char *)NULL) &&
		    (npkgs > 1)) {
			progerr(ERR_TOO_MANY_PKGS);
			quit(1);
			/* NOTREACHED */
		}

		/*
		 * package list generated - add packages
		 */

		b = add_packages(pkglist, ids_name, repeat,
		    altBinDir, device, noZones);

		/*
		 * close open input data stream (source package) if left open.
		 */

		if (ids_name) {
			echoDebug(DBG_CLOSING_STREAM, ids_name,
			    PSTR(pkgdev.dirname));
			(void) ds_close(1);
			rrmdir(pkgdev.dirname);
			ids_name = NULL;
			quitSetIdsName(ids_name);
		}

		/*
		 * continue with next sequence of packages if continue set
		 */

		if (b == B_TRUE) {
			continue;
		}

		/*
		 * not continuing - quit with 0 exit code
		 */

		quit(0);
		/* NOTREACHED */
	}

	/* NOTREACHED */
}

/*
 * *****************************************************************************
 * static internal (private) functions
 * *****************************************************************************
 */

/*
 * Name:	pkgZoneCheckInstall
 * Description:	Invoke pkginstall in a specified zone to perform a preinstall
 *		check of the a single package in the specified zone
 * Arguments:	a_zoneName - pointer to string representing the name of the
 *			zone to check install the package in.
 *		a_zoneState - current state of the zone; must be mounted or
 *			running.
 *		a_idsName - pointer to string representing the data stream
 *			device (input data stream) containing the package to
 *			be check installed.
 *		a_altBinDir - pointer to string representing an alternative
 *			binary location directory to pass to pkginstall.
 *			If this is == NULL no alternative binary location is
 *			passed to pkginstall.
 *		a_adminFile - pointer to string representing the admin
 *			file to pass to pkginstall when installing the package.
 *			If this is == NULL no admin file is given to pkginstall.
 *		a_stdoutPath - pointer to string representing the local path
 *			into which all output written by pkginstall to stdout
 *			is stored.
 *			If this is == NULL stdout is redirected to /dev/null
 *		a_tmpzn - B_TRUE when this zone is booted by the package
 *			command or B_FALSE if it was running before.
 * Returns:	int	(see ckreturn() function for details)
 *		0 - success
 *		1 - package operation failed (fatal error)
 *		2 - non-fatal error (warning)
 *		3 - user selected quit (operation interrupted)
 *		4 - admin settings prevented operation
 *		5 - interaction required and -n (non-interactive) specified
 *		"10" will be added to indicate "immediate reboot required"
 *		"20" will be added to indicate "reboot after install required"
 */

static int
pkgZoneCheckInstall(char *a_zoneName, zone_state_t a_zoneState,
    char *a_idsName, char *a_altBinDir, char *a_adminFile,
    char *a_stdoutPath, boolean_t a_tmpzn)
{
	char	*arg[MAXARGS];
	char	*p;
	char	adminfd_path[PATH_MAX];
	char	path[PATH_MAX];
	char	pkgstreamfd_path[PATH_MAX];
	int	fds[MAX_FDS];
	int	maxfds;
	int	n;
	int	nargs;

	/* entry assertions */

	assert(a_zoneName != (char *)NULL);
	assert(*a_zoneName != '\0');

	/* entry debugging info */

	echoDebug(DBG_PKGZONECHECKINSTALL_ENTRY);
	echoDebug(DBG_PKGZONECHECKINSTALL_ARGS, a_zoneName, PSTR(pkginst),
	    PSTR(pkgdev.dirname), PSTR(pkgdev.mount), PSTR(pkgdev.bdevice),
	    a_zoneState == ZONE_STATE_MOUNTED ? "/a" : "/",
	    PSTR(a_idsName), PSTR(a_adminFile), PSTR(a_stdoutPath));

	/* generate full path to 'phatinstall' to run in zone */

	(void) snprintf(path, sizeof (path), "%s/pkginstall",
	    "/usr/sadm/install/bin");

	/* start at first file descriptor */

	maxfds = 0;

	/*
	 * generate argument list for call to pkginstall
	 */

	/* start at argument 0 */

	nargs = 0;

	/* first argument is always: full path to executable */

	arg[nargs++] = path;

	/*
	 * second argument is always: pass -O debug to pkginstall: debug mode
	 */
	if (debugFlag == B_TRUE) {
		arg[nargs++] = "-O";
		arg[nargs++] = "debug";
	}

	/* pkgadd -G: pass -G to pkginstall */

	if (globalZoneOnly == B_TRUE) {
		arg[nargs++] = "-G";
	}

	/* pkgadd -b dir: pass -b to pkginstall */

	if (a_altBinDir != (char *)NULL) {
		arg[nargs++] = "-b";
		arg[nargs++] = a_altBinDir;
	}

	/* pkgadd -C: pass -C to pkginstall: disable checksum */

	if (disableChecksum) {
		arg[nargs++] = "-C";
	}

	/* pkgadd -A: pass -A to pkginstall: disable attribute checking */

	if (disableAttributes) {
		arg[nargs++] = "-A";
	}

	/*
	 * NONABI_SCRIPTS defined: pass -o to pkginstall; refers to a
	 * pkg requiring operator interaction during a procedure script
	 * (common before on1093)
	 */

	if (old_pkg) {
		arg[nargs++] = "-o";
	}

	/*
	 * PKG_NONABI_SYMLINKS defined: pass -y to pkginstall; process
	 * symlinks consistent with old behavior
	 */

	if (old_symlinks) {
		arg[nargs++] = "-y";
	}

	/*
	 * PKG_ABI_NAMELENGTH defined: pass -e to pkginstall; causes
	 * package name length to be restricted
	 */

	if (ABI_namelength) {
		arg[nargs++] = "-e";
	}

	/* pkgadd -S: pass -S to pkginstall: suppress copyright notices */

	arg[nargs++] = "-S";

	/* pkgadd -M: pass -M to pkginstall: dont mount client file systems */

	arg[nargs++] = "-M";

	/* pkgadd -v: pass -v to pkginstall: never trace scripts */

	/* if running pkgask, pass -i to pkginstall: running pkgask */

	if (askflag) {
		return (0);
	}

	/* pass "-O enable-hollow-package-support" */

	if (is_depend_pkginfo_DB()) {
		arg[nargs++] = "-O";
		arg[nargs++] = "enable-hollow-package-support";
	}

	/* check is always in non-interactive mode */

	arg[nargs++] = "-n";

	/* pkgadd -a admin: pass -a admin to pkginstall in zone: admin file */

	if (a_adminFile) {
		int fd;
		fd = openLocal(a_adminFile, O_RDONLY, tmpdir);
		if (fd < 0) {
			progerr(ERR_CANNOT_COPY_LOCAL, a_adminFile,
			    errno, strerror(errno));
			return (1);
		}
		(void) snprintf(adminfd_path, sizeof (adminfd_path),
		    "/proc/self/fd/%d", fd);
		fds[maxfds++] = fd;
		arg[nargs++] = "-a";
		arg[nargs++] = adminfd_path;
	}

	/* pkgadd -R root: pass -R /a to pkginstall when zone is mounted */

	if (a_zoneState == ZONE_STATE_MOUNTED) {
		arg[nargs++] = "-R";
		arg[nargs++] = "/a";
	}

	/* pass -N to pkginstall: program name to report */

	arg[nargs++] = "-N";
	arg[nargs++] = get_prog_name();

	/* pass "-O preinstallcheck" */

	arg[nargs++] = "-O";
	arg[nargs++] = "preinstallcheck";

	/* add "-O addzonename" */

	arg[nargs++] = "-O";
	arg[nargs++] = "addzonename";

	/*
	 * add parent zone info/type
	 */

	p = z_get_zonename();
	if ((p != NULL) && (*p != '\0')) {
			char	zn[MAXPATHLEN];
			(void) snprintf(zn, sizeof (zn),
			    "parent-zone-name=%s", p);
			arg[nargs++] = "-O";
			arg[nargs++] = strdup(zn);
	}

	/* current zone type */

	arg[nargs++] = "-O";
	if (z_running_in_global_zone() == B_TRUE) {
			char	zn[MAXPATHLEN];
			(void) snprintf(zn, sizeof (zn),
			    "parent-zone-type=%s",
			    TAG_VALUE_GLOBAL_ZONE);
			arg[nargs++] = strdup(zn);
	} else {
			char	zn[MAXPATHLEN];
			(void) snprintf(zn, sizeof (zn),
			    "parent-zone-type=%s",
			    TAG_VALUE_NONGLOBAL_ZONE);
			arg[nargs++] = strdup(zn);
	}

	/* Add the pkgserv options */
	arg[nargs++] = "-O";
	arg[nargs++] = pkgmodeargument(a_tmpzn ? RUN_ONCE : pkgservergetmode());

	/* add in the package stream file */

	if (a_idsName != NULL) {
		int fd;
		fd = openLocal(a_idsName, O_RDONLY, tmpdir);
		if (fd < 0) {
			progerr(ERR_STREAM_UNAVAILABLE, a_idsName,
			    pkginst, strerror(errno));
			quit(1);
		}
		(void) snprintf(pkgstreamfd_path, sizeof (pkgstreamfd_path),
		    "/proc/self/fd/%d", fd);
		fds[maxfds++] = fd;
		arg[nargs++] = pkgstreamfd_path;
	} else {
		progerr(ERR_PKGZONEINSTALL_NO_STREAM);
		quit(1);
	}

	/* add package instance name */

	arg[nargs++] = pkginst;

	/* terminate the argument list */

	arg[nargs++] = NULL;

	/*
	 * run the appropriate pkginstall command in the specified zone
	 */

	if (debugFlag == B_TRUE) {
		echoDebug(DBG_ZONE_EXEC_ENTER, a_zoneName, arg[0]);
		for (n = 0; arg[n]; n++) {
			echoDebug(DBG_ARG, n, arg[n]);
		}
	}

	/* terminate file descriptor list */

	fds[maxfds] = -1;

	/* exec command in zone */

	n = z_zone_exec(a_zoneName, path, arg, a_stdoutPath, (char *)NULL, fds);

	echoDebug(DBG_ZONE_EXEC_EXIT, a_zoneName, arg[0], n,
	    PSTR(a_stdoutPath));

	/*
	 * close any files that were opened for use by the
	 * /proc/self/fd interface so they could be passed to programs
	 * via the z_zone_exec() interface
	 */

	for (; maxfds > 0; maxfds--) {
		(void) close(fds[maxfds-1]);
	}

	/* return results of pkginstall in zone execution */

	return (n);
}

/*
 * Name:	pkgZoneInstall
 * Description:	Invoke pkginstall in a specified zone to perform an install
 *		of a single package in the specified zone
 * Arguments:	a_zoneName - pointer to string representing the name of the
 *			zone to install the package in.
 *		a_zoneState - current state of the zone; must be mounted or
 *			running.
 *		a_idsName - pointer to string representing the data stream
 *			device (input data stream) containing the package to
 *			be installed.
 *		a_altBinDir - pointer to string representing an alternative
 *			binary location directory to pass to pkginstall.
 *			If this is == NULL no alternative binary location is
 *			passed to pkginstall.
 *		a_adminFile - pointer to string representing the admin
 *			file to pass to pkginstall when installing the package.
 *			If this is == NULL no admin file is given to pkginstall.
 *		a_stdoutPath - pointer to string representing the local path
 *			into which all output written by pkginstall to stdout
 *			is stored.
 *			If this is == NULL stdout is redirected to /dev/null
 *		a_tmpzn - B_TRUE when this zone is booted by the package
 *			command or B_FALSE if it was running before.
 * Returns:	int	(see ckreturn() function for details)
 *		0 - success
 *		1 - package operation failed (fatal error)
 *		2 - non-fatal error (warning)
 *		3 - user selected quit (operation interrupted)
 *		4 - admin settings prevented operation
 *		5 - interaction required and -n (non-interactive) specified
 *		"10" will be added to indicate "immediate reboot required"
 *		"20" will be added to indicate "reboot after install required"
 */

static int
pkgZoneInstall(char *a_zoneName, zone_state_t a_zoneState, char *a_idsName,
    char *a_altBinDir, char *a_adminFile, boolean_t a_tmpzn)
{
	char	*arg[MAXARGS];
	char	*p;
	char	adminfd_path[PATH_MAX];
	char	path[PATH_MAX];
	char	pkgstreamfd_path[PATH_MAX];
	char	respfilefd_path[PATH_MAX];
	int	fds[MAX_FDS];
	int	maxfds;
	int	n;
	int	nargs;

	/* entry assertions */

	assert(a_zoneName != (char *)NULL);
	assert(*a_zoneName != '\0');

	/* entry debugging info */

	echoDebug(DBG_PKGZONEINSTALL_ENTRY);
	echoDebug(DBG_PKGZONEINSTALL_ARGS, a_zoneName, PSTR(pkginst),
	    PSTR(pkgdev.dirname), PSTR(pkgdev.mount), PSTR(pkgdev.bdevice),
	    a_zoneState == ZONE_STATE_MOUNTED ? "/a" : "", PSTR(a_idsName),
	    a_adminFile);

	/* generate path to pkginstall */

	(void) snprintf(path, sizeof (path), "%s/pkginstall", PKGBIN);

	/* start at first file descriptor */

	maxfds = 0;

	/*
	 * generate argument list for call to pkginstall
	 */

	/* start at argument 0 */

	nargs = 0;

	/* first argument is path to executable */

	arg[nargs++] = path;

	/*
	 * second argument is always: pass -O debug to pkginstall: debug mode
	 */
	if (debugFlag == B_TRUE) {
		arg[nargs++] = "-O";
		arg[nargs++] = "debug";
	}

	/* pkgadd -G: pass -G to pkginstall */

	if (globalZoneOnly == B_TRUE) {
		arg[nargs++] = "-G";
	}

	/* pkgadd -b dir: pass -b to pkginstall in zone */

	if (a_altBinDir != (char *)NULL) {
		arg[nargs++] = "-b";
		arg[nargs++] = a_altBinDir;
	}

	/* pkgadd -B blocksize: pass -B to pkginstall in zone */

	if (rw_block_size != NULL) {
		arg[nargs++] = "-B";
		arg[nargs++] = rw_block_size;
	}

	/* pkgadd -C: pass -C to pkgadd in zone: disable checksum */

	if (disableChecksum) {
		arg[nargs++] = "-C";
	}

	/* pkgadd -A: pass -A to pkgadd in zone: disable attribute checking */

	if (disableAttributes) {
		arg[nargs++] = "-A";
	}

	/* pkgadd -S: pass -S to pkgadd in zone: suppress copyright notices */

	arg[nargs++] = "-S";

	/* pkgadd -I: pass -I to pkgadd in zone: initial install */

	if (init_install) {
		arg[nargs++] = "-I";
	}

	/* pkgadd -M: pass -M to pkgadd in zone: dont mount client file sys */

	arg[nargs++] = "-M";

	/* pkgadd -v: pass -v to pkgadd in zone: trace scripts */

	if (pkgverbose) {
		arg[nargs++] = "-v";
	}

	/* pkgadd -z: pass -z to pkgadd in zone fresh inst from pkg save area */

	if (saveSpoolInstall) {
		arg[nargs++] = "-z";
	}

	/* pass "-O enable-hollow-package-support" */

	if (is_depend_pkginfo_DB()) {
		arg[nargs++] = "-O";
		arg[nargs++] = "enable-hollow-package-support";
	}

	/* pkgadd -t pass -t to pkgadd in zone disable save spool area create */

	if (disableSaveSpool) {
		arg[nargs++] = "-t";
	}

	/* if running pkgask, pass -i to pkgadd in zone: running pkgask */

	if (askflag) {
		echo(MSG_BYPASSING_ZONE, a_zoneName);
		return (0);
	}

	/*
	 * pkgadd -n (not pkgask): pass -n to pkginstall: noninteractive mode
	 */
	if (nointeract && !askflag) {
		arg[nargs++] = "-n";
	}

	/* pkgadd -a admin: pass -a admin to pkginstall in zone: admin file */

	if (a_adminFile) {
		int fd;
		fd = openLocal(a_adminFile, O_RDONLY, tmpdir);
		if (fd < 0) {
			progerr(ERR_CANNOT_COPY_LOCAL, a_adminFile,
			    errno, strerror(errno));
			return (1);
		}
		(void) snprintf(adminfd_path, sizeof (adminfd_path),
		    "/proc/self/fd/%d", fd);
		fds[maxfds++] = fd;
		arg[nargs++] = "-a";
		arg[nargs++] = adminfd_path;
	}

	/* pkgadd -R root: pass -R /a to pkginstall when zone is mounted */
	if (a_zoneState == ZONE_STATE_MOUNTED) {
		arg[nargs++] = "-R";
		arg[nargs++] = "/a";
	}

	/*
	 * pkgadd -D arg: pass -D dryrun to pkginstall in zone: dryrun
	 * mode/file
	 */
	if (pkgdrtarg) {
		arg[nargs++] = "-D";
		arg[nargs++] = pkgdrtarg;
	}

	/*
	 * pkgadd -c cont: pass -c cont to pkginstall in zone: continuation
	 * file
	 */
	if (pkgcontsrc) {
		arg[nargs++] = "-c";
		arg[nargs++] = pkgcontsrc;
	}

	/* pkgadd -r resp: pass -r resp to pkginstall in zone: response file */

	if (respfile) {
		int fd;
		fd = openLocal(respfile, O_RDONLY, tmpdir);
		if (fd < 0) {
			progerr(ERR_CANNOT_COPY_LOCAL, a_adminFile,
			    errno, strerror(errno));
			return (1);
		}
		(void) snprintf(respfilefd_path,
		    sizeof (respfilefd_path),
		    "/proc/self/fd/%d", fd);
		fds[maxfds++] = fd;
		arg[nargs++] = "-r";
		arg[nargs++] = respfilefd_path;
	}

	/* add "-O addzonename" */

	arg[nargs++] = "-O";
	arg[nargs++] = "addzonename";

	/*
	 * add parent zone info/type
	 */

	p = z_get_zonename();
	if ((p != NULL) && (*p != '\0')) {
			char	zn[MAXPATHLEN];
			(void) snprintf(zn, sizeof (zn),
			    "parent-zone-name=%s", p);
			arg[nargs++] = "-O";
			arg[nargs++] = strdup(zn);
	}

	/* current zone type */

	arg[nargs++] = "-O";
	if (z_running_in_global_zone() == B_TRUE) {
			char	zn[MAXPATHLEN];
			(void) snprintf(zn, sizeof (zn),
			    "parent-zone-type=%s",
			    TAG_VALUE_GLOBAL_ZONE);
			arg[nargs++] = strdup(zn);
	} else {
			char	zn[MAXPATHLEN];
			(void) snprintf(zn, sizeof (zn),
			    "parent-zone-type=%s",
			    TAG_VALUE_NONGLOBAL_ZONE);
			arg[nargs++] = strdup(zn);
	}

	/* Add the pkgserv options */
	arg[nargs++] = "-O";
	arg[nargs++] = pkgmodeargument(a_tmpzn ? RUN_ONCE : pkgservergetmode());

	/* add in the package stream file */

	if (a_idsName != NULL) {
		int fd;
		fd = openLocal(a_idsName, O_RDONLY, tmpdir);
		if (fd < 0) {
			progerr(ERR_STREAM_UNAVAILABLE, a_idsName,
			    pkginst, strerror(errno));
			quit(1);
		}
		(void) snprintf(pkgstreamfd_path, sizeof (pkgstreamfd_path),
		    "/proc/self/fd/%d", fd);
		fds[maxfds++] = fd;
		arg[nargs++] = pkgstreamfd_path;
	} else {
		progerr(ERR_PKGZONEINSTALL_NO_STREAM);
		quit(1);
	}

	/* add package instance name */

	arg[nargs++] = pkginst;

	/* terminate the argument list */

	arg[nargs++] = NULL;

	/*
	 * run the appropriate pkginstall command in the specified zone
	 */

	if (debugFlag == B_TRUE) {
		echoDebug(DBG_ZONE_EXEC_ENTER, a_zoneName, arg[0]);
		for (n = 0; arg[n]; n++) {
			echoDebug(DBG_ARG, n, arg[n]);
		}
	}

	/* terminate file descriptor list */

	fds[maxfds] = -1;

	/* exec command in zone */

	n = z_zone_exec(a_zoneName, path, arg, (char *)NULL, (char *)NULL, fds);

	echoDebug(DBG_ZONE_EXEC_EXIT, a_zoneName, arg[0], n, "");

	/*
	 * close any files that were opened for use by the
	 * /proc/self/fd interface so they could be passed to programs
	 * via the z_zone_exec() interface
	 */

	for (; maxfds > 0; maxfds--) {
		(void) close(fds[maxfds-1]);
	}

	/* return results of pkginstall in zone execution */

	return (n);
}

/*
 * Name:	pkgInstall
 * Description:	Invoke pkginstall in the current zone to perform an install
 *		of a single package to the current zone or standalone system
 * Arguments:	a_altRoot - pointer to string representing the alternative
 *			root to use for the install
 *		a_idsName - pointer to string representing the data stream
 *			device (input data stream) containing the package to
 *			be installed.
 *		a_pkgDir - pointer to string representing the path to the
 *			directory containing the package
 *		a_altBinDir - pointer to string representing location of the
 *			pkginstall executable to run. If not NULL, then pass
 *			the path specified to the -b option to pkginstall.
 * Returns:	int	(see ckreturn() function for details)
 *		0 - success
 *		1 - package operation failed (fatal error)
 *		2 - non-fatal error (warning)
 *		3 - user selected quit (operation interrupted)
 *		4 - admin settings prevented operation
 *		5 - interaction required and -n (non-interactive) specified
 *		"10" will be added to indicate "immediate reboot required"
 *		"20" will be added to indicate "reboot after install required"
 * NOTE:	Both a_idsName and a_pkgDir are used to determine where the
 *		package to be installed is located. If a_idsName is != NULL
 *		then it must be the path to a device containing a package
 *		stream that contains the package to be installed. If a_idsName
 *		is == NULL then a_pkgDir must contain a full path to a directory
 *		that contains the package to be installed.
 */

static int
pkgInstall(char *a_altRoot, char *a_idsName, char *a_pkgDir, char *a_altBinDir)
{
	char	*arg[MAXARGS];
	char	*p;
	char	path[PATH_MAX];
	char	buffer[256];
	int	n, nargs;

	/* entry debugging info */

	echoDebug(DBG_PKGINSTALL_ENTRY);
	echoDebug(DBG_PKGINSTALL_ARGS, PSTR(pkginst), PSTR(pkgdev.dirname),
	    PSTR(pkgdev.mount), PSTR(pkgdev.bdevice), PSTR(a_altRoot),
	    PSTR(a_idsName), PSTR(a_pkgDir));

	/* generate full path to 'pkginstall' to run in zone */

	(void) snprintf(path, sizeof (path), "%s/pkginstall",
	    a_altBinDir == (char *)NULL ? PKGBIN : a_altBinDir);
	/*
	 * generate argument list for call to pkginstall
	 */

	/* start at argument 0 */

	nargs = 0;

	/* first argument is path to executable */

	arg[nargs++] = path;

	/*
	 * second argument is always: pass -O debug to pkginstall: debug mode
	 */
	if (debugFlag == B_TRUE) {
		arg[nargs++] = "-O";
		arg[nargs++] = "debug";
	}

	arg[nargs++] = "-O";
	arg[nargs++] = pkgmodeargument(pkgservergetmode());

	/*
	 * pkgadd -G: pass -G to pkginstall if:
	 *  - the -G option is specified on the pkgadd command line
	 *  - this package is marked 'this zone only':
	 *  -- package has SUNW_PKG_THISZONE=true, or
	 *  -- package has a request script
	 * Setting -G for pkginstall causes pkginstall to install the package
	 * in the target zone. If running in the global zone, will install the
	 * package and mark the package as installed "in the global zone only".
	 * If running in a non-global zone, will just install the package.
	 */

	if (globalZoneOnly == B_TRUE) {
		arg[nargs++] = "-G";
	} else if (pkgPackageIsThisZone(pkginst) == B_TRUE) {
		arg[nargs++] = "-G";
	}

	/* pkgadd -b dir: pass -b to pkginstall */

	if (a_altBinDir != (char *)NULL) {
		arg[nargs++] = "-b";
		arg[nargs++] = a_altBinDir;
	}

	/* pkgadd -B blocksize: pass -B to pkginstall */

	if (rw_block_size != NULL) {
		arg[nargs++] = "-B";
		arg[nargs++] = rw_block_size;
	}

	/* pkgadd -C: pass -C to pkginstall: disable checksum */

	if (disableChecksum) {
		arg[nargs++] = "-C";
	}

	/* pkgadd -A: pass -A to pkginstall: disable attribute checking */

	if (disableAttributes) {
		arg[nargs++] = "-A";
	}

	/*
	 * NONABI_SCRIPTS defined: pass -o to pkginstall; refers to a
	 * pkg requiring operator interaction during a procedure script
	 * (common before on1093)
	 */

	if (old_pkg) {
		arg[nargs++] = "-o";
	}

	/*
	 * PKG_NONABI_SYMLINKS defined: pass -y to pkginstall; process
	 * symlinks consistent with old behavior
	 */

	if (old_symlinks) {
		arg[nargs++] = "-y";
	}

	/*
	 * PKG_ABI_NAMELENGTH defined: pass -e to pkginstall; causes
	 * package name length to be restricted
	 */

	if (ABI_namelength) {
		arg[nargs++] = "-e";
	}

	/* pkgadd -S: pass -S to pkginstall: suppress copyright notices */

	if (suppressCopyright) {
		arg[nargs++] = "-S";
	}

	/* pkgadd -I: pass -I to pkginstall: initial install being performed */

	if (init_install) {
		arg[nargs++] = "-I";
	}

	/* pkgadd -M: pass -M to pkginstall: dont mount client file systems */

	if (no_map_client) {
		arg[nargs++] = "-M";
	}

	/* pkgadd -v: pass -v to pkginstall: trace scripts */

	if (pkgverbose) {
		arg[nargs++] = "-v";
	}

	/* pkgadd -z: pass -z to pkginstall: fresh install from pkg save area */

	if (saveSpoolInstall) {
		arg[nargs++] = "-z";
	}

	/*
	 * if running in a non-global zone and the 'hollow' attribute is
	 * passed in, then pass -h to pkginstall so that it knows how to
	 * handle hollow packages for this local zone.
	 */

	if (!z_running_in_global_zone() && is_depend_pkginfo_DB()) {
		arg[nargs++] = "-h";
	}

	/* pkgadd -t: pass -t to pkginstall: disable save spool area creation */

	if (disableSaveSpool) {
		arg[nargs++] = "-t";
	}

	/* if running pkgask, pass -i to pkginstall: running pkgask */

	if (askflag) {
		arg[nargs++] = "-i";
	}

	/* pkgadd -n (not pkgask): pass -n to pkginstall: noninteractive mode */

	if (nointeract && !askflag) {
		arg[nargs++] = "-n";
	}

	/* pkgadd -a admin: pass -a admin to pkginstall: admin file */

	if (admnfile) {
		arg[nargs++] = "-a";
		arg[nargs++] = admnfile;
	}

	/* pkgadd -D dryrun: pass -D dryrun to pkginstall: dryrun mode/file */

	if (pkgdrtarg) {
		arg[nargs++] = "-D";
		arg[nargs++] = pkgdrtarg;
	}

	/* pkgadd -c cont: pass -c cont to pkginstall: continuation file */

	if (pkgcontsrc) {
		arg[nargs++] = "-c";
		arg[nargs++] = pkgcontsrc;
	}

	/* pkgadd -V vfstab: pass -V vfstab to pkginstall: alternate vfstab */

	if (vfstab_file) {
		arg[nargs++] = "-V";
		arg[nargs++] = vfstab_file;
	}

	/* pkgadd -r resp: pass -r resp to pkginstall: response file */

	if (respfile) {
		arg[nargs++] = "-r";
		arg[nargs++] = respfile;
	}

	/* pkgadd -R root: pass -R root to pkginstall: alternative root */

	if (a_altRoot && *a_altRoot) {
		arg[nargs++] = "-R";
		arg[nargs++] = a_altRoot;
	}

	/*
	 * If input data stream is available,
	 * - add: -d ids_name -p number_of_parts
	 * else,
	 * - add: -d device -m mount [-f type]
	 */

	if (a_idsName != NULL) {
		arg[nargs++] = "-d";
		arg[nargs++] = a_idsName;
		arg[nargs++] = "-p";
		ds_close(1);
		ds_putinfo(buffer, sizeof (buffer));
		arg[nargs++] = buffer;
	} else if (pkgdev.mount != NULL) {
		arg[nargs++] = "-d";
		arg[nargs++] = pkgdev.bdevice;
		arg[nargs++] = "-m";
		arg[nargs++] = pkgdev.mount;
		if (pkgdev.fstyp != NULL) {
			arg[nargs++] = "-f";
			arg[nargs++] = pkgdev.fstyp;
		}
	}

	/*
	 * add parent zone info/type
	 */

	p = z_get_zonename();
	if ((p != NULL) && (*p != '\0')) {
			char	zn[MAXPATHLEN];
			(void) snprintf(zn, sizeof (zn),
			    "parent-zone-name=%s", p);
			arg[nargs++] = "-O";
			arg[nargs++] = strdup(zn);
	}

	/* current zone type */

	arg[nargs++] = "-O";
	if (z_running_in_global_zone() == B_TRUE) {
			char	zn[MAXPATHLEN];
			(void) snprintf(zn, sizeof (zn),
			    "parent-zone-type=%s",
			    TAG_VALUE_GLOBAL_ZONE);
			arg[nargs++] = strdup(zn);
	} else {
			char	zn[MAXPATHLEN];
			(void) snprintf(zn, sizeof (zn),
			    "parent-zone-type=%s",
			    TAG_VALUE_NONGLOBAL_ZONE);
			arg[nargs++] = strdup(zn);
	}

	/* pass -N to pkginstall: program name to report */

	arg[nargs++] = "-N";
	arg[nargs++] = get_prog_name();

	/* add package directory name */

	arg[nargs++] = a_pkgDir;

	/* add package instance name */

	arg[nargs++] = pkginst;

	/* terminate the argument list */

	arg[nargs++] = NULL;

	/*
	 * run the appropriate pkginstall command in the specified zone
	 */

	if (debugFlag == B_TRUE) {
		echoDebug(DBG_ZONE_EXEC_ENTER, "global", arg[0]);
		for (n = 0; arg[n]; n++) {
			echoDebug(DBG_ARG, n, arg[n]);
		}
	}

	/* execute pkginstall command */

	n = pkgexecv(NULL, NULL, NULL, NULL, arg);

	/* return results of pkginstall execution */

	return (n);
}

/*
 *  function to clear out any exisiting error return conditions that may have
 *  been set by previous calls to ckreturn()
 */
static void
resetreturn()
{
	admnflag = 0;	/* != 0 if any pkg op admin setting failure (4) */
	doreboot = 0;	/* != 0 if reboot required after installation (>= 10) */
	failflag = 0;	/* != 0 if fatal error has occurred (1) */
	intrflag = 0;	/* != 0 if user selected quit (3) */
	ireboot = 0;	/* != 0 if immediate reboot required (>= 20) */
	nullflag = 0;	/* != 0 if admin interaction required (5) */
	warnflag = 0;	/* != 0 if non-fatal error has occurred (2) */
	interrupted = 0;	/* last pkg op was quit (1,2,3,4,5) */
	needconsult = 0;	/* essential ask admin now (1,2,3,5) */
}

/*
 *  function which checks the indicated return value
 *  and indicates disposition of installation
 */
static void
ckreturn(int retcode)
{
	/*
	 * entry debugging info
	 */

	echoDebug(DBG_PKGADD_CKRETURN, retcode, PSTR(pkginst));

	/* reset needconsult so it only reflects this call to ckreturn */
	needconsult = 0;

	switch (retcode) {
	case  0:	/* successful */
	case 10:
	case 20:
		break; /* empty case */

	case  1:	/* package operation failed (fatal error) */
	case 11:
	case 21:
		failflag++;
		interrupted++;
		needconsult++;
		break;

	case  2:	/* non-fatal error (warning) */
	case 12:
	case 22:
		warnflag++;
		interrupted++;
		needconsult++;
		break;

	case  3:	/* user selected quit; operation interrupted */
	case 13:
	case 23:
		intrflag++;
		interrupted++;
		needconsult++;
		break;

	case  4:	/* admin settings prevented operation */
	case 14:
	case 24:
		admnflag++;
		interrupted++;
		break;

	case  5:	/* administration: interaction req (no -n) */
	case 15:
	case 25:
		nullflag++;
		interrupted++;
		needconsult++;
		break;

	default:
		failflag++;
		interrupted++;
		needconsult++;
		return;
	}

	if (retcode >= 20) {
		ireboot++;
	} else if (retcode >= 10) {
		doreboot++;
	}
}

static void
usage(void)
{
	char *prog = get_prog_name();

	if (askflag) {
		(void) fprintf(stderr, ERR_USAGE_PKGASK, prog);
	} else if (z_running_in_global_zone() == B_FALSE) {
		(void) fprintf(stderr, ERR_USAGE_PKGADD_NONGLOBALZONE,
		    prog, prog);
	} else {
		(void) fprintf(stderr, ERR_USAGE_PKGADD_GLOBALZONE,
		    prog, prog);
	}
}

/*
 * Name:	check_applicability
 * Description:	determine if a package is installable in this zone; that is,
 *		does the scope of install conflict with existing installation
 *		or can the package be installed
 * Arguments:	a_packageDir - [RO, *RO] - (char *)
 *			Pointer to string representing the directory where the
 *			package is located
 *		a_pkgInst - [RO, *RO] - (char *)
 *			Pointer to string representing the name of the package
 *			to check
 *		a_rootPath - [RO, *RO] - (char *)
 *			Pointer to string representing path to the root of the
 *			file system where the package is to be installed - this
 *			is usually the same as the "-R" argument to pkgadd
 *		a_flags - [RO, *RO] - (CAF_T)
 *			Flags set by the caller to indicate the conditions
 *			under which the package is to be installed:
 *				CAF_IN_GLOBAL_ZONE - in global zone
 *				CAF_SCOPE_GLOBAL - -G specified
 * Returns:	boolean_t
 *			B_TRUE - the package can be installed
 *			B_FALSE - the package can not be installed
 */

static boolean_t
check_applicability(char *a_packageDir, char *a_pkgInst, char *a_rootPath,
    CAF_T a_flags)
{
	FILE		*pkginfoFP;
	FILE		*pkgmapFP;
	boolean_t	all_zones;	/* pkg is "all zones" only */
	boolean_t	in_gz_only;	/* pkg installed in global zone only */
	boolean_t	is_hollow;	/* pkg is "hollow" */
	boolean_t	pkg_installed;	/* pkg is installed */
	boolean_t	this_zone;	/* pkg is "this zone" only */
	boolean_t	reqfile_found = B_FALSE;
	char		instPkg[PKGSIZ+1];	/* installed pkg instance nam */
	char		instPkgPath[PATH_MAX];	/* installed pkg toplevel dir */
	char		pkginfoPath[PATH_MAX];	/* pkg 2 install pkginfo file */
	char		pkgmapPath[PATH_MAX];	/* pkg 2 install pkgmap file */
	char		pkgpath[PATH_MAX];	/* pkg 2 install toplevel dir */
	int		len;
	char		line[LINE_MAX];

	/* entry assertions */

	assert(a_packageDir != (char *)NULL);
	assert(*a_packageDir != '\0');
	assert(a_pkgInst != (char *)NULL);
	assert(*a_pkgInst != '\0');

	/* normalize root path */

	if (a_rootPath == (char *)NULL) {
		a_rootPath = "";
	}

	/* entry debugging info */

	echoDebug(DBG_CHECKAPP_ENTRY);
	echoDebug(DBG_CHECKAPP_ARGS, a_pkgInst, a_packageDir, a_rootPath);

	/*
	 * calculate paths to various objects
	 */

	/* path to package to be installed top level (main) directory */

	len = snprintf(pkgpath, sizeof (pkgpath), "%s/%s", a_packageDir,
	    a_pkgInst);
	if (len > sizeof (pkgpath)) {
		progerr(ERR_CREATE_PATH_2, a_packageDir, a_pkgInst);
		return (B_FALSE);
	}

	/* error if package top level directory does not exist */

	if (isdir(pkgpath) != 0) {
		progerr(ERR_NO_PKGDIR, pkgpath, a_pkgInst, strerror(errno));
		return (B_FALSE);
	}

	/* path to pkginfo file within the package to be installed */

	len = snprintf(pkginfoPath, sizeof (pkginfoPath), "%s/pkginfo",
	    pkgpath);
	if (len > sizeof (pkginfoPath)) {
		progerr(ERR_CREATE_PATH_2, pkgpath, "pkginfo");
		return (B_FALSE);
	}

	/* path to highest instance of package currently installed */

	pkgLocateHighestInst(instPkgPath, sizeof (instPkgPath),
	    instPkg, sizeof (instPkg), a_rootPath, a_pkgInst);

	/*
	 * gather information from this package's pkginfo file
	 */

	pkginfoFP = fopen(pkginfoPath, "r");

	if (pkginfoFP == (FILE *)NULL) {
		progerr(ERR_NO_PKG_INFOFILE, a_pkgInst, pkginfoPath,
		    strerror(errno));
		return (B_FALSE);
	}

	/* determine "HOLLOW" setting for this package */

	is_hollow = pkginfoParamTruth(pkginfoFP, PKG_HOLLOW_VARIABLE,
	    "true", B_FALSE);

	/* determine "ALLZONES" setting for this package */

	all_zones = pkginfoParamTruth(pkginfoFP, PKG_ALLZONES_VARIABLE,
	    "true", B_FALSE);

	/* determine "THISZONE" setting for this package */

	this_zone = pkginfoParamTruth(pkginfoFP, PKG_THISZONE_VARIABLE,
	    "true", B_FALSE);

	/* close pkginfo file */

	(void) fclose(pkginfoFP);

	/*
	 * If request file is not found, it may be in the datastream which
	 * is not yet unpacked. Check in the pkgmap file.
	 */
	if (isfile(pkgpath, REQUEST_FILE) != 0) {

		/* path to pkgmap file within the package to be installed */
		(void) snprintf(pkgmapPath, sizeof (pkgmapPath), "%s/pkgmap",
		    pkgpath);

		pkgmapFP = fopen(pkgmapPath, "r");

		if (pkgmapFP == NULL) {
			progerr(ERR_NO_PKG_MAPFILE, a_pkgInst,
			    pkgmapPath, strerror(errno));
			return (B_FALSE);
		}

		while (fgets(line, LINE_MAX, pkgmapFP) != NULL) {
			if (strstr(line, " i request") != NULL) {
				reqfile_found = B_TRUE;
				break;
			}
		}
		(void) fclose(pkgmapFP);
	} else {
		reqfile_found = B_TRUE;
	}

	/*
	 * If this package is not marked for installation in this zone only,
	 * check to see if this package has a request script. If this package
	 * does have a request script, then mark the package for installation
	 * in this zone only. Any package with a request script cannot be
	 * installed outside of the zone the pkgadd command is being run in,
	 * nor can such a package be installed as part of a new zone install.
	 * A new zone install must be non-interactive, which is required
	 * by all packages integrated into the Solaris WOS.
	 */

	if ((!this_zone) && (reqfile_found)) {
		if (a_flags & CAF_IN_GLOBAL_ZONE) {
			echoDebug(DBG_CHECKAPP_THISZONE_REQUEST, a_pkgInst);
		}
		this_zone = B_TRUE;
	}

	/*
	 * If this package is already installed, see if the current installation
	 * of the package has a request file - if it does, then act as though
	 * the current package to be added has a request file - install the
	 * package in the current zone only.
	 */

	if ((!this_zone) && (instPkgPath[0] != '\0') &&
	    (isfile(instPkgPath, REQUEST_FILE) == 0)) {
		if (a_flags & CAF_IN_GLOBAL_ZONE) {
			echoDebug(DBG_CHECKAPP_THISZONE_INSTREQ,
			    a_pkgInst, instPkg);
		}
		this_zone = B_TRUE;
	}

	/* gather information from the global zone only file */

	in_gz_only = B_FALSE;
	if (a_flags & CAF_IN_GLOBAL_ZONE) {
		in_gz_only = pkgIsPkgInGzOnly(a_rootPath, a_pkgInst);
	}

	/* determine if this package is currently installed */

	pkg_installed = pkginfoIsPkgInstalled((struct pkginfo **)NULL,
	    a_pkgInst);

	/*
	 * verify package applicability based on information gathered,
	 * and validate the three SUNW_PKG_ options:
	 *
	 * -----------|--------------|-------------|-------------|-----------
	 * - - - - - -| GLOBAL ZONE -| GLOBAL ZONE | LOCAL ZONE	 | LOCAL ZONE
	 * - - - - - -|	- - pkgadd - | pkgadd -G   | pkgadd	 | pkgadd -G
	 * ----1------|--------------|-------------|-------------|------------
	 * ALLZONES f | add to gz    | add to gz   | add to ls	 | add to ls
	 * HOLLOW   f | current lz   | not to curr | only - - - -| only - - -
	 * THISZONE f | futr lz - - -| or futr lz  | - - - - - - | - - - - - -
	 * ----2------|--------------|-------------|-------------|------------
	 * ALLZONES T | add to gz    | operation   | operation	 | operation
	 * HOLLOW   f | current lz   | not allowed | not allowed | not allowed
	 * THISZONE f | future lz    | - - - - - - | - - - - - - | - - - - - -
	 * ----3------|--------------|-------------|-------------|------------
	 * ALLZONES T | add to gz    | operation   | operation	 | operation
	 * HOLLOW   T | pkg db only  | not allowed | not allowed | not allowed
	 * THISZONE f | curr/futr lz | - - - - - - | - - - - - - | - - - - - -
	 * ----4------|--------------|-------------|-------------|------------
	 * ALLZONES T | bad option   | bad option  | bad option	 | bad option
	 * HOLLOW   * | combo - - - -| combo - - - | combo - - - | combo - -
	 * THISZONE T |	- - - - - - -|- - - - - - -|- - - - - - -|- - - - - -
	 * ----5------|--------------|-------------|-------------|------------
	 * ALLZONES f | bad option   | bad option  | bad option	 | bad option
	 * HOLLOW   T | combo - - - -| combo - - - | combo - - - | combo - - -
	 * THISZONE * | - - - - - - -| - - - - - - | - - - - - - | - - - - - -
	 * ----6------|--------------|-------------|-------------|------------
	 * ALLZONES f | add to gz    | add to gz   | add to lz	 | add to lz
	 * HOLLOW   f | not current  | not current | only - - -	 | only - - -
	 * THISZONE T | or future lz | or futr lz  | - - - - - - | - - - - - -
	 * -----------|--------------|-------------|-------------|-----------
	 */

	/* pkg "all zones" && "this zone" (#4) */

	if (all_zones && this_zone) {
		progerr(ERR_ALLZONES_AND_THISZONE, a_pkgInst,
		    PKG_ALLZONES_VARIABLE, PKG_THISZONE_VARIABLE);
		return (B_FALSE);
	}

	/* pkg "!all zones" && "hollow" (#5) */

	if ((!all_zones) && is_hollow) {
		progerr(ERR_NOW_ALLZONES_AND_HOLLOW, a_pkgInst,
		    PKG_ALLZONES_VARIABLE, PKG_HOLLOW_VARIABLE);
		return (B_FALSE);
	}

	/* pkg ALLZONES=true & not running in global zone (#2/#3) */

	if (all_zones && (!(a_flags & CAF_IN_GLOBAL_ZONE))) {
		progerr(ERR_ALLZONES_AND_IN_LZ, a_pkgInst);
		return (B_FALSE);
	}

	/* pkg "in gz only" & pkg "NOT installed" */

	if (in_gz_only && (!pkg_installed)) {
		/* MAKE A WARNING */
		echo(ERR_IN_GZ_AND_NOT_INSTALLED, a_pkgInst,
		    pkgGetGzOnlyPath());
	}

	/* pkg ALLZONES=true & pkg "in gz only" & pkg "is installed" */

	if (all_zones && in_gz_only && pkg_installed) {
		progerr(ERR_IN_GZ_AND_ALLZONES_AND_INSTALLED, a_pkgInst);
		return (B_FALSE);
	}

	/* pkg ALLZONES=true && -G specified (#2/#3) */

	if (all_zones && (a_flags & CAF_SCOPE_GLOBAL)) {
		progerr(ERR_ALLZONES_AND_G_USED, a_pkgInst);
		return (B_FALSE);
	}

	/* pkg "!this zone" && "in gz only" & -G not specified */

	if ((!this_zone) && in_gz_only && (!(a_flags & CAF_SCOPE_GLOBAL))) {
		progerr(ERR_IN_GZ_AND_NO_G_USED, a_pkgInst);
		return (B_FALSE);
	}

	/*
	 * If this package is marked 'this zone only', then mark the package
	 * as "add to this zone only". This is referenced by the various
	 * add_package_... functions to determine if the package should be
	 * added to the current zone, or to all zones, depending on the
	 * zone in which the command is being run.
	 */

	if (this_zone) {
		pkgAddThisZonePackage(a_pkgInst);
	}

	return (B_TRUE);
}

/*
 * Name:	create_zone_adminfile
 * Description: Given a zone temporary directory and optionally an existing
 *		administration file, generate an administration file that
 *		can be used to perform "non-interactive" operations in a
 *		non-global zone.
 * Arguments:	r_zoneAdminFile - pointer to handle that will contain a
 *			string representing the path to the temporary
 *			administration file created - this must be NULL
 *			before the first call to this function - on
 *			subsequent calls if the pointer is NOT null then
 *			the existing string will NOT be overwritten.
 *		a_zoneTempDir - pointer to string representing the path
 *			to the zone temporary directory to create the
 *			temporary administration file in
 *		a_admnfile - pointer to string representing the path to
 *			an existing "user" administration file - the
 *			administration file created will contain the
 *			settings contained in this file, modified as
 *			appropriate to supress any interaction;
 *			If this is == NULL then the administration file
 *			created will not contain any extra settings
 * Returns:	void
 * NOTE:	Any string returned is placed in new storage for the
 *		calling method. The caller must use 'free' to dispose
 *		of the storage once the string is no longer needed.
 * NOTE:	On any error this function will call 'quit(1)'
 */

static void
create_zone_adminfile(char **r_zoneAdminFile, char *a_zoneTempDir,
    char *a_admnfile)
{
	boolean_t	b;

	/* entry assertions */

	assert(r_zoneAdminFile != (char **)NULL);
	assert(a_zoneTempDir != (char *)NULL);
	assert(*a_zoneTempDir != '\0');

	/* entry debugging info */

	echoDebug(DBG_CREATE_ZONE_ADMINFILE, a_zoneTempDir, PSTR(a_admnfile));

	/* if temporary name already exists, do not overwrite */

	if (*r_zoneAdminFile != (char *)NULL) {
		return;
	}

	/* create temporary name */

	*r_zoneAdminFile = tempnam(a_zoneTempDir, "zadmn");
	b = z_create_zone_admin_file(*r_zoneAdminFile, a_admnfile);
	if (b == B_FALSE) {
		progerr(ERR_CREATE_TMPADMIN, *r_zoneAdminFile,
		    strerror(errno));
		quit(1);
		/* NOTREACHED */
	}

	echoDebug(DBG_CREATED_ZONE_ADMINFILE, *r_zoneAdminFile);
}

/*
 * Name:	create_zone_tempdir
 * Description: Given a system temporary directory, create a "zone" specific
 *		temporary directory and return the path to the directory
 *		created.
 * Arguments:	r_zoneTempDir - pointer to handle that will contain a
 *			string representing the path to the temporary
 *			directory created - this must be NULL before the
 *			first call to this function - on subsequent calls
 *			if the pointer is NOT null then the existing string
 *			will NOT be overwritten.
 *		a_zoneTempDir - pointer to string representing the path
 *			to the system temporary directory to create the
 *			temporary zone directory in
 * Returns:	void
 * NOTE:	Any string returned is placed in new storage for the
 *		calling method. The caller must use 'free' to dispose
 *		of the storage once the string is no longer needed.
 * NOTE:	On any error this function will call 'quit(1)'
 * NOTE:	This function calls "quitSetZoneTmpdir" on success to
 *		register the directory created with quit() so that the
 *		directory will be automatically deleted on exit.
 */

static void
create_zone_tempdir(char **r_zoneTempDir, char *a_tmpdir)
{
	boolean_t	b;

	/* entry assertions */

	assert(r_zoneTempDir != (char **)NULL);
	assert(a_tmpdir != (char *)NULL);
	assert(*a_tmpdir != '\0');

	/* entry debugging info */

	echoDebug(DBG_CREATE_ZONE_TEMPDIR, a_tmpdir);

	/* if temporary directory already exists, do not overwrite */

	if (*r_zoneTempDir != (char *)NULL) {
		return;
	}

	/* create temporary directory */

	b = setup_temporary_directory(r_zoneTempDir, a_tmpdir, "ztemp");
	if (b == B_FALSE) {
		progerr(ERR_ZONETEMPDIR, a_tmpdir, strerror(errno));
		quit(1);
		/* NOTREACHED */
	}

	/* register with quit() so directory is removed on exit */

	quitSetZoneTmpdir(*r_zoneTempDir);

	/* exit debugging info */

	echoDebug(DBG_CREATED_ZONE_TEMPDIR, *r_zoneTempDir);
}

/*
 * Name:	continue_installation
 * Description: Called from within a loop that is installing packages,
 *		this function examines various global variables and decides
 *		whether or not to ask an appropriate question, and wait for
 *		and appropriate reply.
 * Arguments:	<<global variables>>
 * Returns:	B_TRUE - continue processing with next package
 *		B_FALSE - do not continue processing with next package
 */

static boolean_t
continue_installation(void)
{
	char	ans[MAX_INPUT];
	int	n;

	/* return TRUE if not interrupted */

	if (!interrupted) {
		return (B_TRUE);
	}

	/*
	 * process interrupted - determine whether or not to continue
	 */

	/* output appropriate interrupted message */

	if (askflag) {
		echo(npkgs == 1 ? MSG_1MORE_PROC : MSG_MORE_PROC, npkgs);
	} else {
		echo(npkgs == 1 ? MSG_1MORE_INST : MSG_MORE_INST, npkgs);
	}

	/* if running with no interaction (-n) do not ask question */

	if (nointeract) {
		/* if admin required return 'dont continue' */
		if (needconsult) {
			return (B_FALSE);
		}
		ckquit = 1;
		return (B_TRUE);
	}

	/* interaction possible: ask question */

	ckquit = 0;
	n = ckyorn(ans, NULL, NULL, NULL, ASK_CONTINUE_ADD);
	if (n != 0) {
		quit(n);
		/* NOTREACHED */
	}
	ckquit = 1;
	if (strchr("yY", *ans) == NULL) {
		return (B_FALSE);
	}
	return (B_TRUE);
}

/*
 * package can be in a number of formats:
 * - file containing package stream (pkgadd -d file [pkgs])
 * - directory containing packages (pkgadd -d /dir [pkgs])
 * - device containing packages (pkgadd -d diskette1 [pkgs])
 * non-global zones can be passed open files and strings as arguments
 * - for file containing package stream
 * -- the stream can be passed directly to the non-global zone
 * - for directory
 * -- convert packages to datastream to pass to the non-global zone
 * - for device
 * -- ?
 */

static boolean_t
unpack_and_check_packages(char **a_pkgList, char *a_idsName, char *a_packageDir)
{
	int	savenpkgs = npkgs;
	int	i;
	CAF_T	flags = 0;

	/* entry assertions */

	assert(a_pkgList != (char **)NULL);

	/* entry debugging info */

	echoDebug(DBG_UNPACKCHECK_ENTRY);
	echoDebug(DBG_UNPACKCHECK_ARGS, PSTR(a_idsName), PSTR(a_packageDir));

	/*
	 * set flags for applicability check
	 */

	/* determine if running in the global zone */

	if (z_running_in_global_zone() == B_TRUE) {
		flags |= CAF_IN_GLOBAL_ZONE;
	}

	/* set -G flag */

	if (globalZoneOnly == B_TRUE) {
		flags |= CAF_SCOPE_GLOBAL;
	}

	/*
	 * for each package to install:
	 * - if packages from datastream, unpack package into package dir
	 * - check applicability of installing package on this system/zone
	 */

	for (i = 0; (pkginst = a_pkgList[i]) != NULL; i++) {
		if (a_idsName != (char *)NULL) {
			/* create stream out of package if not already one */
			if (unpack_package_from_stream(a_idsName, pkginst,
			    a_packageDir) == B_FALSE) {
				progerr(ERR_CANNOT_UNPACK_PKGSTRM,
				    PSTR(pkginst), PSTR(a_idsName),
				    PSTR(a_packageDir));

				npkgs = savenpkgs;
				return (B_FALSE);
			}
		} else {
			echoDebug(DBG_PKG_IN_DIR, pkginst, a_packageDir);
		}

		/* check package applicability */
		if (check_applicability(a_packageDir,
		    pkginst, get_inst_root(), flags) == B_FALSE) {
			progerr(ERR_PKG_NOT_INSTALLABLE, pkginst);
			npkgs = savenpkgs;
			return (B_FALSE);
		}
		npkgs--;
	}

	npkgs = savenpkgs;
	return (B_TRUE);
}

/*
 * returns:
 *	B_TRUE - package list generated
 *	B_FALSE - failed to generate package list
 *	Will call quit(n) on fatal error.
 */

static boolean_t
get_package_list(char ***r_pkgList, char **a_argv, char *a_categories,
    char **a_categoryList, char *a_idsName, int *r_repeat)
{
	int		n;

	/* entry assertions */

	assert(r_repeat != (int *)NULL);

	/* entry debugging info */

	echoDebug(DBG_GETPKGLIST_ENTRY);
	echoDebug(DBG_GETPKGLIST_ARGS, PSTR(a_idsName), PSTR(pkgdev.dirname),
	    *r_repeat);

	/*
	 * get the list of the packages to add
	 */

	n = pkgGetPackageList(r_pkgList, a_argv, optind, a_categories,
	    a_categoryList, &pkgdev);

	switch (n) {
		case -1:	/* no packages found */
			echoDebug(DBG_PKGLIST_NONFOUND, PSTR(a_idsName),
			    pkgdev.dirname);
			return (B_FALSE);

		case 0:		/* packages found */
			break;

		default:	/* "quit" error */
			echoDebug(DBG_PKGLIST_ERROR, PSTR(a_idsName),
			    pkgdev.dirname, n);
			quit(n);
			/* NOTREACHED */
	}

	/* order package list if input data stream specified */

	if (a_idsName) {
		ds_order(*r_pkgList);
	}

	return (B_TRUE);
}

/*
 * Name:	install_in_one_zone
 * Description:	Install a single package in a single zone
 * Arguments:	a_zoneName - pointer to string representing the name of the
 *			zone to install the package into.
 *		a_idsName - pointer to string representing the data stream
 *			device (input data stream) containing the package to
 *			be installed.
 *			If this is == NULL the package is assumed to be
 *			spooled in the zone temporary directory.
 *		a_zoneAdminFile - pointer to string representing the admin
 *			file to pass to pkginstall when installing the package.
 *			If this is == NULL no admin file is given to pkginstall.
 *		a_zoneTempDir - pointer to string representing the temporary
 *			directory in which spooled packages can be found if
 *			a_idsName is == NULL.
 *		a_altBinDir - pointer to string representing an alternative
 *			binary location directory to pass to pkginstall.
 *			If this is == NULL no alternative binary location is
 *			passed to pkginstall.
 *		a_scratchName - pointer to string representing the name of the
 *			scratch zone to use for installation.
 *		a_zoneState - state of the zone; must be mounted or running.
 *		a_tmpzn - B_TRUE when this zone is booted by the package
 *			command or B_FALSE if it was running before.
 * Returns:	void
 * NOTE:	As a side effect, "ckreturn" is called on the result returned
 *		from running 'pkginstall' in the zone; this sets several global
 *		variables which allows the caller to determine the result of
 *		the installation operation.
 */

static void
install_in_one_zone(char *a_zoneName, char *a_idsName,
    char *a_zoneAdminFile, char *a_zoneTempDir,
    char *a_altBinDir, zone_state_t a_zoneState, boolean_t a_tmpzn)
{
	char	zoneStreamName[PATH_MAX] = {'\0'};
	int	n;

	/* entry assertions */

	assert(a_zoneName != (char *)NULL);
	assert(*a_zoneName != '\0');

	/* entry debugging info */

	echoDebug(DBG_INSTINONEZONE_ENTRY);
	echoDebug(DBG_INSTINONEZONE_ARGS, a_zoneName, PSTR(a_idsName),
	    PSTR(a_zoneAdminFile), PSTR(a_zoneTempDir),
	    PSTR(a_altBinDir));

	/* echo operation to perform to stdout */

	echo(MSG_INSTALL_PKG_IN_ZONE, pkginst, a_zoneName);

	/* determine path to the package stream */

	if (a_idsName == (char *)NULL) {
		/* locate temp stream created earlier */
		(void) snprintf(zoneStreamName, sizeof (zoneStreamName),
		    "%s/%s.dstream", a_zoneTempDir, pkginst);
	} else {
		/* use stream passed in on command line */
		(void) snprintf(zoneStreamName, sizeof (zoneStreamName),
		    "%s", a_idsName);
	}

	echoDebug(DBG_INSTALL_IN_ZONE, pkginst, a_zoneName, zoneStreamName);

	n = pkgZoneInstall(a_zoneName, a_zoneState, zoneStreamName,
	    a_altBinDir, a_zoneAdminFile, a_tmpzn);

	/* set success/fail condition variables */

	ckreturn(n);

	/* exit debugging info */

	echoDebug(DBG_INSTALL_FLAG_VALUES, "after install", admnflag, doreboot,
	    failflag, interrupted, intrflag, ireboot, needconsult,
	    nullflag, warnflag);
}

/*
 * Name:	install_in_zones
 * Description:	Install a single package in the zones that are running from
 *		a list of zones
 * Arguments:	a_zlst - list of zones to install the package into
 *		a_idsName - pointer to string representing the data stream
 *			device (input data stream) containing the package to
 *			be installed.
 *			If this is == NULL the package is assumed to be
 *			spooled in the zone temporary directory.
 *		a_altBinDir - pointer to string representing an alternative
 *			binary location directory to pass to pkginstall.
 *			If this is == NULL no alternative binary location is
 *			passed to pkginstall.
 *		a_zoneAdminFile - pointer to string representing the admin
 *			file to pass to pkginstall when installing the package.
 *			If this is == NULL no admin file is given to pkginstall.
 *		a_zoneTempDir - pointer to string representing the temporary
 *			directory in which spooled packages can be found if
 *			a_idsName is == NULL.
 */

static int
install_in_zones(zoneList_t a_zlst, char *a_idsName, char *a_altBinDir,
    char *a_zoneAdminFile, char *a_zoneTempDir)
{
	char		*zoneName;
	int		zoneIndex;
	int		zonesSkipped = 0;
	zone_state_t	zst;

	/* entry assertions */

	assert(a_zlst != (zoneList_t)NULL);

	/* entry debugging info */

	echoDebug(DBG_INSTALLINZONES_ENTRY);
	echoDebug(DBG_INSTALLINZONES_ARGS, PSTR(a_idsName),
	    PSTR(a_zoneAdminFile), PSTR(a_zoneTempDir));

	/* process each zone in the list */

	for (zoneIndex = 0;
	    (zoneName = z_zlist_get_zonename(a_zlst, zoneIndex)) != NULL;
	    zoneIndex++) {

		/* skip the zone if it is NOT running */

		zst = z_zlist_get_current_state(a_zlst, zoneIndex);
		if (zst != ZONE_STATE_RUNNING && zst != ZONE_STATE_MOUNTED) {
			zonesSkipped++;
			echoDebug(DBG_SKIPPING_ZONE, zoneName);
			continue;
		}

		/* install the package in this zone */

		install_in_one_zone(z_zlist_get_scratch(a_zlst, zoneIndex),
		    a_idsName, a_zoneAdminFile, a_zoneTempDir, a_altBinDir,
		    zst, B_FALSE);
	}

	return (zonesSkipped);
}

/*
 * Name:	boot_and_install_in_zones
 * Description:	Install a single package in the zones that are NOT running from
 *		a list of zones - each zone is booted, the package installed,
 *		and the zone is halted
 * Arguments:	a_zlst - list of zones to install the package into
 *		a_idsName - pointer to string representing the data stream
 *			device (input data stream) containing the package to
 *			be installed.
 *			If this is == NULL the package is assumed to be
 *			spooled in the zone temporary directory.
 *		a_altBinDir - pointer to string representing an alternative
 *			binary location directory to pass to pkginstall.
 *			If this is == NULL no alternative binary location is
 *			passed to pkginstall.
 *		a_zoneAdminFile - pointer to string representing the admin
 *			file to pass to pkginstall when installing the package.
 *			If this is == NULL no admin file is given to pkginstall.
 *		a_zoneTempDir - pointer to string representing the temporary
 *			directory in which spooled packages can be found if
 *			a_idsName is == NULL.
 */

static int
boot_and_install_in_zones(zoneList_t a_zlst, char *a_idsName, char *a_altBinDir,
    char *a_zoneAdminFile, char *a_zoneTempDir)
{
	boolean_t	b;
	char		*zoneName;
	int		zoneIndex;
	int		zonesSkipped = 0;
	zone_state_t	zst;

	/* entry assertions */

	assert(a_zlst != (zoneList_t)NULL);

	/* entry debugging info */

	echoDebug(DBG_BOOTINSTALLINZONES_ENTRY);
	echoDebug(DBG_BOOTINSTALLINZONES_ARGS, PSTR(a_idsName),
	    PSTR(a_zoneAdminFile), PSTR(a_zoneTempDir));

	/* process each zone in the list */

	for (zoneIndex = 0;
	    (zoneName = z_zlist_get_zonename(a_zlst, zoneIndex)) != NULL;
	    zoneIndex++) {

		/* skip the zone if it IS running */

		zst = z_zlist_get_current_state(a_zlst, zoneIndex);
		if (zst == ZONE_STATE_RUNNING || zst == ZONE_STATE_MOUNTED) {
			echoDebug(DBG_SKIPPING_ZONE_BOOT, zoneName);
			continue;
		}

		/* skip the zone if it is NOT bootable */

		if (z_zlist_is_zone_runnable(a_zlst, zoneIndex) == B_FALSE) {
			echo(MSG_SKIPPING_ZONE_NOT_RUNNABLE, zoneName);
			echoDebug(DBG_SKIPPING_ZONE_NOT_RUNNABLE, zoneName);
			continue;
		}

		/* mount up the zone */

		echo(MSG_BOOTING_ZONE, zoneName);
		echoDebug(DBG_BOOTING_ZONE, zoneName);

		b = z_zlist_change_zone_state(a_zlst, zoneIndex,
		    ZONE_STATE_MOUNTED);
		if (b == B_FALSE) {
			progerr(ERR_CANNOT_BOOT_ZONE, zoneName);
			/* set fatal error return condition */
			ckreturn(1);
			zonesSkipped++;
			continue;
		}

		/* install the package in this zone */

		install_in_one_zone(z_zlist_get_scratch(a_zlst, zoneIndex),
		    a_idsName, a_zoneAdminFile, a_zoneTempDir, a_altBinDir,
		    ZONE_STATE_MOUNTED, B_TRUE);

		/* restore original state of zone */

		echo(MSG_RESTORE_ZONE_STATE, zoneName);
		echoDebug(DBG_RESTORE_ZONE_STATE, zoneName);

		b = z_zlist_restore_zone_state(a_zlst, zoneIndex);
	}

	return (zonesSkipped);
}

/*
 * Name:	pkginstall_check_in_one_zone
 * Description:	Do a pre install check of a single package in a single zone
 * Arguments:	a_zoneName - pointer to string representing the name of the
 *			zone to check install the package in.
 *		a_idsName - pointer to string representing the data stream
 *			device (input data stream) containing the package to
 *			be check installed.
 *			If this is == NULL the package is assumed to be
 *			spooled in the zone temporary directory.
 *		a_zoneAdminFile - pointer to string representing the admin
 *			file to pass to pkginstall when installing the package.
 *			If this is == NULL no admin file is given to pkginstall.
 *		a_zoneTempDir - pointer to string representing the temporary
 *			directory in which spooled packages can be found if
 *			a_idsName is == NULL.
 *		a_altBinDir - pointer to string representing an alternative
 *			binary location directory to pass to pkginstall.
 *			If this is == NULL no alternative binary location is
 *			passed to pkginstall.
 *		a_scratchName - pointer to string representing the name of the
 *			scratch zone to use for installation.
 *		a_zoneState - state of the zone; must be mounted or running.
 *		a_tmpzn - B_TRUE when this zone is booted by the package
 *			command or B_FALSE if it was running before.
 * Returns:	void
 * NOTE:	As a side effect, "ckreturn" is called on the result returned
 *		from running 'pkginstall' in the zone; this sets several global
 *		variables which allows the caller to determine the result of
 *		the pre installation check operation.
 */

static void
pkginstall_check_in_one_zone(char *a_zoneName,
    char *a_idsName, char *a_zoneAdminFile, char *a_zoneTempDir,
    char *a_altBinDir, char *a_scratchName, zone_state_t a_zoneState,
    boolean_t a_tmpzn)
{
	char	preinstallcheckPath[PATH_MAX+1];
	char	zoneStreamName[PATH_MAX] = {'\0'};
	int	n;

	echo(MSG_CHECKINSTALL_PKG_IN_ZONE, pkginst, a_zoneName);
	echoDebug(MSG_CHECKINSTALL_PKG_IN_ZONE, pkginst, a_zoneName);

	(void) snprintf(preinstallcheckPath, sizeof (preinstallcheckPath),
	    "%s/%s.%s.preinstallcheck.txt", a_zoneTempDir, pkginst,
	    a_zoneName);

	if (a_idsName == (char *)NULL) {
		/* locate temporary stream created earlier */
		(void) snprintf(zoneStreamName, sizeof (zoneStreamName),
		    "%s/%s.dstream", a_zoneTempDir, pkginst);
	} else {
		(void) snprintf(zoneStreamName, sizeof (zoneStreamName),
		    "%s", a_idsName);
	}

	echoDebug(DBG_CHECKINSTALL_IN_ZONE, pkginst, a_zoneName,
	    zoneStreamName);

	n = pkgZoneCheckInstall(a_scratchName, a_zoneState, zoneStreamName,
	    a_altBinDir, a_zoneAdminFile, preinstallcheckPath, a_tmpzn);

	/* set success/fail condition variables */

	ckreturn(n);

	echoDebug(DBG_INSTALL_FLAG_VALUES, "after preinstall check",
	    admnflag, doreboot, failflag, interrupted, intrflag,
	    ireboot, needconsult, nullflag, warnflag);
}

/*
 * Name:	pkginstall_check_in_zones
 * Description:	Check installation of a single package in the zones that
 *		are running from a list of zones
 * Arguments:	a_zlst - list of zones to check install the package
 *		a_idsName - pointer to string representing the data stream
 *			device (input data stream) containing the package to
 *			be check installed.
 *			If this is == NULL the package is assumed to be
 *			spooled in the zone temporary directory.
 *		a_altBinDir - pointer to string representing an alternative
 *			binary location directory to pass to pkginstall.
 *			If this is == NULL no alternative binary location is
 *			passed to pkginstall.
 *		a_zoneAdminFile - pointer to string representing the admin
 *			file to pass to pkginstall when checking the installing
 *			of the package.
 *			If this is == NULL no admin file is given to pkginstall.
 *		a_zoneTempDir - pointer to string representing the temporary
 *			directory in which spooled packages can be found if
 *			a_idsName is == NULL.
 */

static int
pkginstall_check_in_zones(zoneList_t a_zlst, char *a_idsName, char *a_altBinDir,
    char *a_zoneAdminFile, char *a_zoneTempDir)
{
	char		*zoneName;
	int		zoneIndex;
	int		zonesSkipped = 0;
	zone_state_t	zst;

	for (zoneIndex = 0;
	    (zoneName = z_zlist_get_zonename(a_zlst, zoneIndex)) != NULL;
	    zoneIndex++) {

		zst = z_zlist_get_current_state(a_zlst, zoneIndex);
		if (zst != ZONE_STATE_RUNNING && zst != ZONE_STATE_MOUNTED) {
			zonesSkipped++;
			echoDebug(DBG_SKIPPING_ZONE, zoneName);
			continue;
		}

		pkginstall_check_in_one_zone(zoneName, a_idsName,
		    a_zoneAdminFile, a_zoneTempDir, a_altBinDir,
		    z_zlist_get_scratch(a_zlst, zoneIndex), zst, B_FALSE);
	}

	return (zonesSkipped);
}

/*
 * Name:	boot_and_pkginstall_check_in_zones
 * Description:	Check installation of a single package in the zones that
 *		are NOT running from a list of zones - each zone is booted,
 *		the package installation is checked, and the zone is halted.
 * Arguments:	a_zlst - list of zones to install the package into
 *		a_idsName - pointer to string representing the data stream
 *			device (input data stream) containing the package to
 *			be check installed.
 *			If this is == NULL the package is assumed to be
 *			spooled in the zone temporary directory.
 *		a_altBinDir - pointer to string representing an alternative
 *			binary location directory to pass to pkginstall.
 *			If this is == NULL no alternative binary location is
 *			passed to pkginstall.
 *		a_zoneAdminFile - pointer to string representing the admin
 *			file to pass to pkginstall when check installing the
 *			package.
 *			If this is == NULL no admin file is given to pkginstall.
 *		a_zoneTempDir - pointer to string representing the temporary
 *			directory in which spooled packages can be found if
 *			a_idsName is == NULL.
 */

static int
boot_and_pkginstall_check_in_zones(zoneList_t a_zlst, char *a_idsName,
    char *a_altBinDir, char *a_zoneAdminFile, char *a_zoneTempDir)
{
	int		zoneIndex;
	int		zonesSkipped = 0;
	char		*zoneName;
	boolean_t	b;
	zone_state_t	zst;

	/* entry assertions */

	assert(a_zlst != (zoneList_t)NULL);

	/* entry debugging info */

	echoDebug(DBG_BOOTCHECKINSTALLINZONES_ENTRY);
	echoDebug(DBG_BOOTCHECKINSTALLINZONES_ARGS, PSTR(a_idsName),
	    PSTR(a_zoneAdminFile), PSTR(a_zoneTempDir));

	/* process each zone in the list */

	for (zoneIndex = 0;
	    (zoneName = z_zlist_get_zonename(a_zlst, zoneIndex)) != NULL;
	    zoneIndex++) {

		/* skip the zone if it IS running */

		zst = z_zlist_get_current_state(a_zlst, zoneIndex);
		if (zst == ZONE_STATE_RUNNING || zst == ZONE_STATE_MOUNTED) {
			echoDebug(DBG_SKIPPING_ZONE_BOOT, zoneName);
			continue;
		}

		/* skip the zone if it is NOT bootable */

		if (z_zlist_is_zone_runnable(a_zlst, zoneIndex) == B_FALSE) {
			echo(MSG_SKIPPING_ZONE_NOT_RUNNABLE, zoneName);
			echoDebug(DBG_SKIPPING_ZONE_NOT_RUNNABLE, zoneName);
			continue;
		}

		/* mount up the zone */

		echo(MSG_BOOTING_ZONE, zoneName);
		echoDebug(DBG_BOOTING_ZONE, zoneName);

		b = z_zlist_change_zone_state(a_zlst, zoneIndex,
		    ZONE_STATE_MOUNTED);
		if (b == B_FALSE) {
			progerr(ERR_CANNOT_BOOT_ZONE, zoneName);
			/* set fatal error return condition */
			ckreturn(1);
			zonesSkipped++;
			continue;
		}

		/* pre-installation check of the package in this zone */

		pkginstall_check_in_one_zone(zoneName, a_idsName,
		    a_zoneAdminFile, a_zoneTempDir, a_altBinDir,
		    z_zlist_get_scratch(a_zlst, zoneIndex),
		    ZONE_STATE_MOUNTED, B_TRUE);

		/* restore original state of zone */

		echo(MSG_RESTORE_ZONE_STATE, zoneName);
		echoDebug(DBG_RESTORE_ZONE_STATE, zoneName);

		b = z_zlist_restore_zone_state(a_zlst, zoneIndex);
	}

	return (zonesSkipped);
}

/*
 * Function:	add_packages_in_global_with_zones
 * Description: call this function to add a list of packages in the global zone
 *		when one or more non-global zones exist
 * returns:
 *	B_TRUE to process next data stream
 *	B_FALSE to exit
 */

static boolean_t
add_packages_in_global_with_zones(char **a_pkgList,
    char *a_idsName, int a_repeat, char *a_altBinDir,
    char *a_device, zoneList_t a_zlst)
{
static	char		*zoneTempDir = (char *)NULL;
static	char		*zoneAdminFile = (char *)NULL;

	boolean_t	b;
	char		*packageDir;
	char		instdir[PATH_MAX];
	char		respfile_path[PATH_MAX];
	char		zoneStreamName[PATH_MAX] = {'\0'};
	int		i;
	int		n;
	int		savenpkgs = npkgs;
	int		zonesSkipped;
	boolean_t	globalPresent;

	/* entry assertions */

	assert(a_pkgList != (char **)NULL);
	assert(a_zlst != (zoneList_t)NULL);

	echoDebug(DBG_ADDPACKAGES_GZ_W_LZ_ENTRY);
	echoDebug(DBG_ADDPACKAGES_GZ_W_LZ_ARGS, npkgs,
	    PSTR(a_idsName), a_repeat, PSTR(a_device));

	/* create temporary directory for use by zone operations */

	create_zone_tempdir(&zoneTempDir, tmpdir);

	/* create hands off settings admin file for use in a non-global zone */

	create_zone_adminfile(&zoneAdminFile, zoneTempDir, admnfile);

	/* determine directory where packages can be found */

	if (a_idsName == (char *)NULL) {
		/* no stream - directory containing packages provided */
		packageDir = pkgdev.dirname;
	} else {
		packageDir = zoneTempDir;
	}

	/* unpack and check all packages */

	b = unpack_and_check_packages(a_pkgList, a_idsName, packageDir);
	if (b != B_TRUE) {
		quit(1);
	}

	/*
	 * if the packages are contained in a directory, convert the
	 * packages into individual streams because pkgZoneInstall is only able
	 * to pass a stream to the non-global zone's pkginstall command.
	 * After this code is executed:
	 * if the original input was a datastream:
	 * -> that datastream has been unpacked into "instdir"
	 * if the original input was a directory with packages in it:
	 * -> those packages have been placed into a single datastream
	 */

	if (a_idsName == (char *)NULL) {
		for (i = 0; (pkginst = a_pkgList[i]) != NULL; i++) {
			char	*pkgs[2];

			/* package is not a stream - create one */

			(void) snprintf(zoneStreamName, sizeof (zoneStreamName),
			    "%s/%s.dstream", zoneTempDir, pkginst);

			echoDebug(DBG_CONVERTING_PKG, packageDir, pkginst,
			    zoneStreamName);

			/* set up list of packages to be this package only */

			pkgs[0] = pkginst;
			pkgs[1] = (char *)NULL;

			n = pkgtrans(packageDir, zoneStreamName, pkgs,
			    PT_SILENT|PT_ODTSTREAM);
			if (n != 0) {
				progerr(ERR_CANNOT_CONVERT_PKGSTRM,
				    pkginst, packageDir, zoneStreamName);
				quit(1);
			}
			npkgs--;
		}
		npkgs = savenpkgs;
	}

	/*
	 * Phase I - run collect dependency information for all packages for all
	 * zones - this involves running pkginstall with the "preinstallcheck"
	 * option which causes all dependency checks to be performed without
	 * actually doing the installation of the packages. This information is
	 * gathered in the zone temporary directory and is used later to present
	 * the dependency check results to the system administrator depending
	 * on the administration settings.
	 */

	for (i = 0; (pkginst = a_pkgList[i]) != NULL; i++) {

		/* reset interrupted flag before calling pkginstall */

		interrupted = 0;	/* last action was NOT quit */

		/*
		 * if this package is marked "install in this zone only", then
		 * do not check dependencies in any other zone
		 */

		if (pkgPackageIsThisZone(pkginst) == B_TRUE) {
			echoDebug(DBG_VERIFY_SKIP_THISZONE, pkginst);
			npkgs--;
			continue;
		}

		/*
		 * if operation failed in global zone do not propagate
		 * to any non-global zones
		 */

		if (interrupted != 0) {
			echo(MSG_CHECKINSTALL_INTERRUPT_B4_Z, pkginst);
			echoDebug(MSG_CHECKINSTALL_INTERRUPT_B4_Z, pkginst);
			break;
		}

		echoDebug(DBG_INSTALL_FLAG_VALUES, "after pkginstall",
		    admnflag, doreboot, failflag, interrupted, intrflag,
		    ireboot, needconsult, nullflag, warnflag);

		/*
		 * call pkginstall to verify this package for all non-global
		 * zones that are currently booted
		 */

		zonesSkipped = pkginstall_check_in_zones(a_zlst, a_idsName,
		    a_altBinDir, admnfile, zoneTempDir);

		/*
		 * if any zones were skipped (becuase they are not currently
		 * booted), boot each zone one at a time and call pkginstall
		 * to verify this package for each such non-global zone
		 */

		if (zonesSkipped > 0) {
			echoDebug(DBG_ZONES_SKIPPED, zonesSkipped);

			zonesSkipped =
			    boot_and_pkginstall_check_in_zones(a_zlst,
			    a_idsName, a_altBinDir, admnfile,
			    zoneTempDir);

			if (zonesSkipped > 0) {
				progerr(ERR_INSTALL_ZONES_SKIPPED,
				    zonesSkipped);
			}
		}

		npkgs--;
	}

	/*
	 * At this point, all of the dependency information has been gathered
	 * and is ready to be analyzed. This function processes all of that
	 * dependency information and presents the results to the system
	 * administrator, depending on the current administration settings.
	 */

	i = preinstall_verify(a_pkgList, a_zlst, zoneTempDir);
	if (i != 0) {
		/* dependency checks failed - exit */
		quit(i);
	}

	npkgs = savenpkgs;

	/*
	 * reset all error return condition variables that may have been
	 * set during package installation dependency checking so that they
	 * do not reflect on the success/failure of the actual package
	 * installation operations
	 */

	resetreturn();

	/*
	 * At this point, all of the dependency checking is completed, and
	 * the installation of the packages can proceed. Install each package
	 * one at a time, starting with the global zone, and the for each
	 * non-global zone that is booted, and then for each non-global zone
	 * that is not currently booted.
	 */

	globalPresent = z_on_zone_spec(GLOBAL_ZONENAME);

	for (i = 0; (pkginst = a_pkgList[i]) != NULL; i++) {
		/*
		 * if immediate reboot required from last package and this is
		 * not 'pkgask' then suspend installation of remaining packages
		 */

		if ((ireboot != 0) && (askflag == 0)) {
			ptext(stderr, MSG_SUSPEND_ADD, pkginst);
				continue;
		}

		/*
		 * handle interrupt if the previous pkginstall was interrupted
		 */

		if (continue_installation() == B_FALSE) {
			return (B_FALSE);
		}

		/*
		 * if pkgask, handle response file creation:
		 * - if the response file is a directory, then create a path to
		 * -- a package instance within the response file directory.
		 * - If the response file is NOT a directory, if more than one
		 * -- package is to be installed.
		 */

		if ((askflag != 0) && (respdir != (char *)NULL)) {
			(void) snprintf(respfile_path, sizeof (respfile_path),
			    "%s/%s", respdir, pkginst);
			respfile = respfile_path;
		}

		echo(MSG_PROC_INST, pkginst, a_device);

		/*
		 * If we're installing another package in the same
		 * session, the second through nth pkginstall, must
		 * continue from where the prior one left off. For this
		 * reason, the continuation feature (implied by the
		 * nature of the command) is used for the remaining
		 * packages.
		 */

		if ((i == 1) && (pkgdrtarg != (char *)NULL)) {
			pkgcontsrc = pkgdrtarg;
		}

		if (globalPresent) {
			/*
			 * call pkginstall for this package for the global zone
			 */

			echo(MSG_INSTALLING_PKG_IN_GZ, pkginst);

			/* reset interrupted flag before calling pkginstall */

			interrupted = 0;	/* last action was NOT quit */

			n = pkgInstall(get_inst_root(), NULL, packageDir,
			    a_altBinDir);

			/* set success/fail condition variables */

			ckreturn(n);

			/*
			 * if operation failed in global zone do not propagate
			 * to any non-global zones
			 */

			if (interrupted != 0) {
				echo(MSG_INSTALL_INTERRUPT_B4_ZONES, pkginst);
				echoDebug(MSG_INSTALL_INTERRUPT_B4_ZONES,
				    pkginst);
				break;
			}
		}

		/*
		 * if this package is marked "install in this zone only",
		 * then only need to install the package in the global zone;
		 * skip installation in any non-global zones.
		 */

		if (pkgPackageIsThisZone(pkginst) == B_TRUE) {
			echoDebug(DBG_INSTALL_SKIP_THISZONE, pkginst);
			npkgs--;
			continue;
		}

		echoDebug(DBG_INSTALL_FLAG_VALUES, "install in running zones",
		    admnflag, doreboot, failflag, interrupted, intrflag,
		    ireboot, needconsult, nullflag, warnflag);

		/* install package in currently booted zones */

		zonesSkipped = install_in_zones(a_zlst, a_idsName, a_altBinDir,
		    zoneAdminFile, zoneTempDir);

		/* install package in zones that are not currently booted */

		if (zonesSkipped > 0) {
			echoDebug(DBG_ZONES_SKIPPED, zonesSkipped);

			zonesSkipped = boot_and_install_in_zones(a_zlst,
			    a_idsName, a_altBinDir, zoneAdminFile,
			    zoneTempDir);

			if (zonesSkipped > 0) {
				progerr(ERR_INSTALL_ZONES_SKIPPED,
				    zonesSkipped);
			}
		}

		/*
		 * package completely installed - remove any temporary stream
		 * of the package that might have been created
		 */

		if (a_idsName == (char *)NULL) {
			/* locate temporary stream created earlier */
			(void) snprintf(zoneStreamName, sizeof (zoneStreamName),
			    "%s/%s.dstream", zoneTempDir, pkginst);
			/* remove stream - no longer needed */
			echoDebug(DBG_REMOVING_DSTREAM_PKGDIR, zoneStreamName,
			    pkginst);
			(void) remove(zoneStreamName);
		} else {
			/* remove package - no longer needed */
			if (snprintf(instdir, sizeof (instdir), "%s/%s",
			    zoneTempDir, pkginst) >= PATH_MAX) {
				progerr(ERR_CANNOT_CREATE_PKGPATH, tmpdir);
				quit(1);
			}
			echoDebug(DBG_REMOVING_PKG_TMPDIR, instdir, pkginst);
			(void) remove(instdir);
		}

		/* decrement number of packages left to install */

		npkgs--;

		/*
		 * if no packages left to install, unmount package source
		 * device if appropriate
		 */

		if ((npkgs <= 0) && (pkgdev.mount || a_idsName)) {
			(void) chdir("/");
			if (!a_idsName) {
				echoDebug(DBG_UNMOUNTING_DEV,
				    PSTR(pkgdev.mount));
				(void) pkgumount(&pkgdev);
			}
		}
	}

	/*
	 * all packages in the package list have been installed.
	 * Continue with installation if:
	 * -- immediate reboot is NOT required
	 * -- there are more packages to install
	 * -- the package source is a path to a file
	 * else return do NOT continue.
	 */

	if ((ireboot == 0) && (a_repeat != 0) &&
	    (pkgdev.pathname == (char *)NULL)) {
		return (B_TRUE);
	}

	/* return 'dont continue' */

	return (B_FALSE);
}

/*
 * Function:	add_packages_in_nonglobal_zone
 * Description: call this function to add a list of packages in a non-global
 *		zone
 * returns:
 *	B_TRUE to process next data stream
 *	B_FALSE to exit
 */

static boolean_t
add_packages_in_nonglobal_zone(char **a_pkgList,
    char *a_idsName, int a_repeat, char *a_altBinDir, char *a_device)
{
static	char		*zoneTempDir = (char *)NULL;

	char		*packageDir;
	char		respfile_path[PATH_MAX];
	int		i;
	int		n;
	boolean_t	b;
	int		savenpkgs = npkgs;

	/* entry assertions */

	assert(a_pkgList != (char **)NULL);

	/* entry debugging info */

	echoDebug(DBG_ADDPACKAGES_LZ_ENTRY);
	echoDebug(DBG_ADDPACKAGES_LZ_ARGS, npkgs, PSTR(a_idsName),
	    a_repeat, PSTR(a_device));

	/* create temporary directory for use by zone operations */

	create_zone_tempdir(&zoneTempDir, tmpdir);

	/*
	 * package can be in a number of formats:
	 * - file containing package stream (pkgadd -d file [pkgs])
	 * - directory containing packages (pkgadd -d /dir [pkgs])
	 * - device containing packages (pkgadd -d diskette1 [pkgs])
	 * non-global zones can be passed open file drescriptors and
	 * strings as arguments
	 * - for file containing package stream
	 * -- the stream can be passed directly to the non-global zone
	 * - for directory
	 * -- convert packages to datastream to pass to the non-global zone
	 * - for device
	 */

	/* determine directory where packages can be found */

	if (a_idsName == (char *)NULL) {
		/* no stream - directory containing packages provided */
		packageDir = pkgdev.dirname;
	} else {
		packageDir = zoneTempDir;
	}

	b = unpack_and_check_packages(a_pkgList, a_idsName, packageDir);
	if (b != B_TRUE) {
		quit(1);
	}

	/*
	 * this is the main loop where all of the packages (as listed in the
	 * package list) are added one at a time.
	 */

	for (i = 0; (pkginst = a_pkgList[i]) != NULL; i++) {
		npkgs--;
	}

	npkgs = savenpkgs;

	/*
	 * this is the main loop where all of the packages (as listed in the
	 * package list) are added one at a time.
	 */

	for (i = 0; (pkginst = a_pkgList[i]) != NULL; i++) {
		/*
		 * if immediate reboot required from last package and this is
		 * not 'pkgask' then suspend installation of remaining packages
		 */

		if ((ireboot != 0) && (askflag == 0)) {
			ptext(stderr, MSG_SUSPEND_ADD, pkginst);
				continue;
		}

		/*
		 * handle interrupt if the previous pkginstall was interrupted
		 */

		if (continue_installation() == B_FALSE) {
			return (B_FALSE);
		}

		/*
		 * if pkgask, handle response file creation:
		 * - if the response file is a directory, then create a path to
		 * -- a package instance within the response file directory.
		 * - If the response file is NOT a directory, if more than one
		 * -- package is to be installed.
		 */

		if ((askflag != 0) && (respdir != (char *)NULL)) {
			(void) snprintf(respfile_path, sizeof (respfile_path),
			    "%s/%s", respdir, pkginst);
			respfile = respfile_path;
		}

		echo(MSG_PROC_INST, pkginst, a_device);

		/*
		 * If we're installing another package in the same
		 * session, the second through nth pkginstall, must
		 * continue from where the prior one left off. For this
		 * reason, the continuation feature (implied by the
		 * nature of the command) is used for the remaining
		 * packages.
		 */

		if ((i == 1) && (pkgdrtarg != (char *)NULL)) {
			pkgcontsrc = pkgdrtarg;
		}

		/* reset interrupted flag before calling pkginstall */

		interrupted = 0;	/* last action was NOT quit */

		/* call pkginstall for this package */

		n = pkgInstall(get_inst_root(), NULL,
		    packageDir, a_altBinDir);

		/* set success/fail condition variables */

		ckreturn(n);

		/* decrement number of packages left to install */

		npkgs--;

		/*
		 * if no packages left to install, unmount package source
		 * device if appropriate
		 */

		if ((npkgs <= 0) && (pkgdev.mount || a_idsName)) {
			(void) chdir("/");
			if (!a_idsName) {
				(void) pkgumount(&pkgdev);
			}
		}
	}

	/*
	 * all packages in the package list have been installed.
	 * Continue with installation if:
	 * -- immediate reboot is NOT required
	 * -- there are more packages to install
	 * -- the package source is a path to a file
	 * else return do NOT continue.
	 */

	if ((ireboot == 0) && (a_repeat != 0) &&
	    (pkgdev.pathname == (char *)NULL)) {
		return (B_TRUE);
	}

	/* return 'dont continue' */

	return (B_FALSE);
}

/*
 * Function:	add_packages_in_global_no_zones
 * Description: call this function to add a list of packages in the global zone
 *		when no non-global zones exist
 * returns:
 *	B_TRUE to process next data stream
 *	B_FALSE to exit
 */

static boolean_t
add_packages_in_global_no_zones(char **a_pkgList,
    char *a_idsName, int a_repeat, char *a_altBinDir, char *a_device)
{
	int		n;
	int		i;
	char		respfile_path[PATH_MAX];
	CAF_T		flags = 0;

	/* entry assertions */

	assert(a_pkgList != (char **)NULL);

	echoDebug(DBG_ADDPACKAGES_GZ_NO_LZ_ENTRY);
	echoDebug(DBG_ADDPACKAGES_GZ_NO_LZ_ARGS, npkgs,
	    PSTR(a_idsName), a_repeat, PSTR(a_device));

	/*
	 * set flags for applicability check
	 */

	/* in the global zone */

	flags |= CAF_IN_GLOBAL_ZONE;

	/* set -G flag */

	if (globalZoneOnly == B_TRUE) {
		flags |= CAF_SCOPE_GLOBAL;
	}

	/*
	 * this is the main loop where all of the packages (as listed in the
	 * package list) are added one at a time.
	 */

	for (i = 0; (pkginst = a_pkgList[i]) != NULL; i++) {
		/*
		 * if immediate reboot required from last package and this is
		 * not 'pkgask' then suspend installation of remaining packages
		 */

		if ((ireboot != 0) && (askflag == 0)) {
			ptext(stderr, MSG_SUSPEND_ADD, pkginst);
				continue;
		}

		/*
		 * handle interrupt if the previous pkginstall was interrupted
		 */

		if (continue_installation() == B_FALSE) {
			return (B_FALSE);
		}

		/*
		 * check package applicability to install in this context
		 */

		if (check_applicability(pkgdev.dirname,
		    pkginst, get_inst_root(), flags) == B_FALSE) {
			progerr(ERR_PKG_NOT_APPLICABLE, pkginst);
			quit(1);
		}

		/*
		 * if pkgask, handle response file creation:
		 * - if the response file is a directory, then create a path to
		 * -- a package instance within the response file directory.
		 * - If the response file is NOT a directory, if more than one
		 * -- package is to be installed.
		 */

		if ((askflag != 0) && (respdir != (char *)NULL)) {
			(void) snprintf(respfile_path, sizeof (respfile_path),
			    "%s/%s", respdir, pkginst);
			respfile = respfile_path;
		}

		echo(MSG_PROC_INST, pkginst, a_device);

		/*
		 * If we're installing another package in the same
		 * session, the second through nth pkginstall, must
		 * continue from where the prior one left off. For this
		 * reason, the continuation feature (implied by the
		 * nature of the command) is used for the remaining
		 * packages.
		 */

		if ((i == 1) && (pkgdrtarg != (char *)NULL)) {
			pkgcontsrc = pkgdrtarg;
		}

		/* reset interrupted flag before calling pkginstall */

		interrupted = 0;	/* last action was NOT quit */

		/* call pkginstall for this package */

		n = pkgInstall(get_inst_root(), a_idsName,
		    pkgdev.dirname, a_altBinDir);

		/* set success/fail condition variables */

		ckreturn(n);

		/* decrement number of packages left to install */

		npkgs--;

		/*
		 * if no packages left to install, unmount package source
		 * device if appropriate
		 */

		if ((npkgs <= 0) && (pkgdev.mount || a_idsName)) {
			(void) chdir("/");
			if (!a_idsName) {
				(void) pkgumount(&pkgdev);
			}
		}
	}

	/*
	 * all packages in the package list have been installed.
	 * Continue with installation if:
	 * -- immediate reboot is NOT required
	 * -- there are more packages to install
	 * -- the package source is a path to a file
	 * else return do NOT continue.
	 */

	if ((ireboot == 0) && (a_repeat != 0) &&
	    (pkgdev.pathname == (char *)NULL)) {
		return (B_TRUE);
	}

	/* return 'dont continue' */

	return (B_FALSE);
}

/*
 * returns:
 *	B_TRUE to process next data stream
 *	B_FALSE to exit
 */

static boolean_t
add_packages(char **a_pkgList,
    char *a_idsName, int a_repeat, char *a_altBinDir, char *a_device,
    boolean_t a_noZones)
{
	zoneList_t	zlst;
	boolean_t	b;

	/* entry assertions */

	assert(a_pkgList != (char **)NULL);

	echoDebug(DBG_ADDPACKAGES_ENTRY);
	echoDebug(DBG_ADDPACKAGES_ARGS, npkgs, PSTR(a_idsName),
	    a_repeat, PSTR(a_altBinDir), PSTR(a_device));

	/*
	 * if running in the global zone AND one or more non-global
	 * zones exist, add packages in a 'zones aware' manner, else
	 * add packages in the standard 'non-zones aware' manner.
	 */

	if ((a_noZones == B_FALSE) && (z_running_in_global_zone() == B_FALSE)) {
		/* in non-global zone */

		echoDebug(DBG_IN_LZ);

		b = z_lock_this_zone(ZLOCKS_PKG_ADMIN);
		if (b != B_TRUE) {
			progerr(ERR_CANNOT_LOCK_THIS_ZONE);
			/* set fatal error return condition */
			ckreturn(1);
			return (B_FALSE);
		}

		b = add_packages_in_nonglobal_zone(a_pkgList, a_idsName,
		    a_repeat, a_altBinDir, a_device);

		(void) z_unlock_this_zone(ZLOCKS_ALL);

		return (B_FALSE);
	}

	/* running in the global zone */

	b = z_non_global_zones_exist();
	if ((a_noZones == B_FALSE) && (b == B_TRUE) &&
	    (globalZoneOnly == B_FALSE)) {

		echoDebug(DBG_IN_GZ_WITH_LZ);

		/* error if -V specified - what to use in non-global zone? */

		if (vfstab_file) {
			progerr(ERR_V_USED_WITH_GZS);
			quit(1);
		}

		/* get a list of all non-global zones */
		zlst = z_get_nonglobal_zone_list();
		if (zlst == (zoneList_t)NULL) {
			progerr(ERR_CANNOT_GET_ZONE_LIST);
			quit(1);
		}

		/* need to lock all of the zones */

		quitSetZonelist(zlst);
		b = z_lock_zones(zlst, ZLOCKS_PKG_ADMIN);
		if (b == B_FALSE) {
			z_free_zone_list(zlst);
			progerr(ERR_CANNOT_LOCK_ZONES);
			/* set fatal error return condition */
			ckreturn(1);
			return (B_FALSE);
		}

		/* add packages to all zones */

		b = add_packages_in_global_with_zones(a_pkgList,
		    a_idsName, a_repeat, a_altBinDir, a_device, zlst);

		/* unlock all zones */

		(void) z_unlock_zones(zlst, ZLOCKS_ALL);
		quitSetZonelist((zoneList_t)NULL);

		/* free list of all non-global zones */

		z_free_zone_list(zlst);

		return (B_FALSE);
	}

	/* in global zone no non-global zones */

	echoDebug(DBG_IN_GZ_NO_LZ);

	b = z_lock_this_zone(ZLOCKS_PKG_ADMIN);
	if (b != B_TRUE) {
		progerr(ERR_CANNOT_LOCK_THIS_ZONE);
		/* set fatal error return condition */
		ckreturn(1);
		return (B_FALSE);
	}

	b = add_packages_in_global_no_zones(a_pkgList, a_idsName,
	    a_repeat, a_altBinDir, a_device);

	(void) z_unlock_this_zone(ZLOCKS_ALL);

	return (B_FALSE);
}



/* ============================================================================
 * SOURCE 59/98: minix4\exokernel\kernel_legacy\cmd\svr4pkg\pkgadm\main.c
 * Size: 5,706 bytes, Lines: 269
 * Hash: dc71f91f261a...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (c) 2017 Peter Tribble.
 */

/*
 * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */


/* unix system includes */

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <unistd.h>
#include <locale.h>
#include <sys/param.h>

#include <pkglib.h>
#include "pkgadm.h"
#include "pkgadm_msgs.h"
#include "libadm.h"

/* Local Function Prototypes */

static void			print_version();
int				get_dbstatus(int argc, char **argv);
int				sync_server(int argc, char **argv);

/* holds subcommands and their definitions */
struct cmd {
	char		*c_name;
	int		(*c_func)(int, char **);
};

struct cmd  cmds[] = {
	{ "dbstatus",		get_dbstatus},
	{ "lock",		admin_lock},
	{ "sync",		sync_server},
	/* last one must be all NULLs */
	{ NULL, NULL }
};

/*
 * Function:	main
 *
 * Return:	0	- subprocessing successful
 *			  scripts and reboot
 *	[other]	- subprocessing-specific failure
 */
int
main(int argc, char **argv)
{
	int	cur_cmd;
	int	newargc;
	char	**newargv;
	int	i;

	/* Should be defined by cc -D */
#if	!defined(TEXT_DOMAIN)
#define	TEXT_DOMAIN "SYS_TEST"
#endif

	/* set the default text domain for messaging */
	(void) setlocale(LC_ALL, "");
	(void) textdomain(TEXT_DOMAIN);

	if (getenv("PKGADM_VERBOSE")) {
		set_verbose(B_TRUE);
	}

	/* Superficial check of the arguments. */
	if (argc <= 1) {
		log_msg(LOG_MSG_INFO, MSG_USAGE);
		return (1);
	}

	/* first, process any arguments that can appear before the subcommand */
	while ((i = getopt(argc, argv, "vV?")) != EOF) {
		switch (i) {
		case 'v':	/* verbose mode enabled */
			set_verbose(B_TRUE);
			break;
		case 'V':
			print_version();
			return (0);
		case '?':
			log_msg(LOG_MSG_INFO, MSG_USAGE);
			return (0);
		}
	}

	/* OK, hand it off to the subcommand processors */
	for (cur_cmd = 0; cmds[cur_cmd].c_name != NULL; cur_cmd++) {
		if (ci_streq(argv[optind], cmds[cur_cmd].c_name)) {
			/* make subcommand the first option */
			newargc = argc - optind;
			newargv = argv + optind;
			opterr = optind = 1; optopt = 0;
			return (cmds[cur_cmd].c_func(newargc, newargv));
		}
	}

	/* bad subcommand */
	log_msg(LOG_MSG_ERR, MSG_BAD_SUB, argv[optind]);
	log_msg(LOG_MSG_INFO, MSG_USAGE);
	return (1);
}

/*
 * Name:	set_verbose
 * Description:	Turns on verbose output
 * Scope:	public
 * Arguments:	verbose = B_TRUE indicates verbose mode
 * Returns:	none
 */
void
set_verbose(boolean_t setting)
{
	log_set_verbose(setting);
}

/*
 * Name:	get_verbose
 * Description:	Returns whether or not to output verbose messages
 * Scope:	public
 * Arguments:	none
 * Returns:	B_TRUE - verbose messages should be output
 */
boolean_t
get_verbose()
{
	return (log_get_verbose());
}

/*
 * Name:	print_Version
 * Desc:  Prints Version of packaging tools
 * Arguments: none
 * Returns: none
 */
static void
print_version()
{
	/* ignore any and all arguments, print version only */
	(void) fprintf(stdout, "%s\n", SUNW_PKGVERS);
}

/*
 * usage
 *
 * Outputs the usage string.
 *
 * Return:1
 * Side effects: none
 */
static int
usage()
{
	log_msg(LOG_MSG_INFO, MSG_USAGE);
	return (1);
}

/*
 * get_dbstatus
 *
 * Return 'text' as the db status.
 * Use the command line to determine if there is an alternate root.
 *
 * Return: 0 on success, nonzero on failure
 * Side effects: none
 */
int
get_dbstatus(int argc, char **argv)
{
	/* Either accept 1 argument or 3 arguments where the second is -R */
	if (argc != 1 && (argc != 3 || strcmp(argv[1], "-R")))
		return (usage());

	(void) printf("%s\n", PKGADM_DBSTATUS_TEXT);

	return (0);
}

/*
 * sync
 *
 * Use the command line to determine if there is an alternate root.
 *
 * Return: 0 on success, nonzero on failure
 * Flush the pkgserv's log.
 */
int
sync_server(int argc, char **argv)
{
	int c;
	char *root = NULL;
	char *dryrundir = NULL;
	boolean_t quit = B_FALSE;

	/*
	 * Options:
	 *   -q: Tell pkgserv daemon to quit.
	 *   -R: Alternate root specification.
	 *   -D: Dryrun directory specification.
	 *
	 * -R and -D help pkgadm to locate IPC files used for communication
	 * with pkgserv daemon. They should not be used together, though
	 * nothing prevents you from doing so. If you use both at once
	 * then IPC files will be searched in $ROOTDIR/$DRYRUNDIR directory.
	 * So if you want to terminate dryrun pkgserv process, you should
	 * always use only -D option.
	 */
	while ((c = getopt(argc, argv, "D:R:q")) != EOF) {
		switch (c) {
		case 'D':
			dryrundir = optarg;
			break;
		case 'R':
			root = optarg;
			break;
		case 'q':
			quit = B_TRUE;
			break;
		default:
			return (usage());
		}
	}

	if (!pkgsync_needed(root, dryrundir, quit))
		return (0);

	set_PKGpaths(root);
	set_cfdir(dryrundir);

	if (pkgWlock(1) == 1) {
		/* Flush the log file */
		(void) pkgsync(root, dryrundir, quit);
		(void) relslock();
		return (0);
	}

	return (1);
}



/* ============================================================================
 * SOURCE 60/98: minix4\exokernel\kernel_legacy\cmd\svr4pkg\pkgchk\main.c
 * Size: 13,769 bytes, Lines: 611
 * Hash: 9470926cce3c...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (c) 2017 Peter Tribble.
 */

/*
 * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

/* Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T */
/* All Rights Reserved */


#include <stdio.h>
#include <limits.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <dirent.h>
#include <sys/stat.h>
#include <pkginfo.h>
#include <pkglocs.h>
#include <sys/types.h>
#include <pkgstrct.h>
#include <pkgtrans.h>
#include <locale.h>
#include <libintl.h>
#include <pkglib.h>
#include <libadm.h>
#include <libinst.h>

#define	MAXPATHS	1024

#define	MSG_CHK_STRM	"Checking uninstalled stream format package " \
				"<%s> from <%s>\n"
#define	MSG_CHK_DIR	"Checking uninstalled directory format package " \
				"<%s> from <%s>\n"
#define	MSG_NOTROOT	"NOTE: \"root\" permission may be required to " \
				"validate all objects in the client filesystem."
#define	MSG_CONT	"Continuing."

#define	WRN_F_SPOOL	"WARNING: %s is spooled. Ignoring \"f\" argument"

#define	ERR_ROOT_SET	"Could not set install root from the environment."
#define	ERR_ROOT_CMD	"Command line install root contends with environment."
#define	ERR_IOPEN	"unable to open input file <%s>"
#define	ERR_IEMPTY	"no pathnames in file specified by -i option"
#define	ERR_POPTION	"no pathname included with -p option"
#define	ERR_PARTIAL_POPTION	"no pathname included with -P option"
#define	ERR_MAXPATHS	"too many pathnames in option list (limit is %d)"
#define	ERR_NOTROOT	"You must be \"root\" for \"%s -f\" to" \
					"execute properly."
#define	ERR_SEL_PKG "No packages selected for verification."
#define	ERR_CAT_LNGTH "The category argument exceeds the SVr4 ABI\n" \
		"        defined maximum supported length of 16 characters."
#define	ERR_CAT_FND "Category argument <%s> cannot be found."
#define	ERR_CAT_INV "Category argument <%s> is invalid."
#define	ERR_TOO_MANY "too many pathnames in list, limit is %d"
#define	ERR_PATHS_INVALID "Pathnames in %s are not valid."
#define	ERR_MKDIR "unable to make directory <%s>"
#define	ERR_USAGE	"usage:\n" \
		"\t%s [-l|vqacnxf] [-R rootdir] [-p path[, ...] | " \
		"-P path[, ...]]\n" \
		"\t\t[-i file] [options]\n" \
		"\t%s -d device [-f][-l|v] [-p path[, ...] | " \
		"-P path[, ...]]\n" \
		"\t\t[-V ...] [-M] [-i file] [-Y category[, ...] | " \
		"pkginst [...]]\n" \
		"\twhere options may include ONE of the " \
		"following:\n " \
		"\t\t-m pkgmap [-e envfile]\n" \
		"\t\tpkginst [...]\n" \
		"\t\t-Y category[, ...]\n"

#define	LINK	1

char	**pkg = NULL;
int	pkgcnt = 0;
char	*basedir;
char	*pathlist[MAXPATHS], *ppathlist[MAXPATHS], pkgspool[PATH_MAX];
short	used[MAXPATHS];
short	npaths;
struct cfent **eptlist;

int	aflag = (-1);
int	cflag = (-1);
int	vflag = 0;
int	nflag = 0;
int	lflag = 0;
int	Lflag = 0;
int	fflag = 0;
int	xflag = 0;
int	qflag = 0;
int	Rflag = 0;
int	dflag = 0;
char	*device;

char	*uniTmp;

static char	*mapfile,
		*spooldir,
		*tmpdir,
		*envfile;
static int	errflg = 0;
static int	map_client = 1;

void	quit(int);
static void	setpathlist(char *);
static void	usage(void);

extern	char	**environ;
extern	char	*pkgdir;

/* checkmap.c */
extern int	checkmap(int, int, char *, char *, char *, char *, int);
/* scriptvfy.c */
extern int	checkscripts(char *inst_dir, int silent);

int
main(int argc, char *argv[])
{
	int	pkgfmt = 0;	/* Makes more sense as a pointer, but */
				/*	18N is compromised. */
	char	file[PATH_MAX+1],
	    *abi_sym_ptr,
	    *vfstab_file = NULL;
	char *all_pkgs[4] = {"all", NULL};
	char **category = NULL;
	char *catg_arg = NULL;
	int	c;
	int	n = 0;
	char	*prog, *Rvalue = NULL, *dvalue = NULL;
	int pathtype;

	/* initialize locale mechanism */

	(void) setlocale(LC_ALL, "");

#if !defined(TEXT_DOMAIN)	/* Should be defined by cc -D */
#define	TEXT_DOMAIN "SYS_TEST"
#endif
	(void) textdomain(TEXT_DOMAIN);

	/* determine program name */

	prog = set_prog_name(argv[0]);

	/* establish installation root directory */

	if (!set_inst_root(getenv("PKG_INSTALL_ROOT"))) {
		progerr(gettext(ERR_ROOT_SET));
		quit(1);
	}

	/* check if not ABI compliant mode */
	abi_sym_ptr = getenv("PKG_NONABI_SYMLINKS");
	if (abi_sym_ptr && strncasecmp(abi_sym_ptr, "TRUE", 4) == 0) {
		set_nonABI_symlinks();
	}

	/* bugId 4012147 */
	if ((uniTmp = getenv("PKG_NO_UNIFIED")) != NULL)
		map_client = 0;

	while ((c = getopt(argc, argv, "Y:R:e:p:d:nLli:vaV:Mm:cqxfP:?"))
	    != EOF) {
		switch (c) {
		case 'p':
			pathlist[npaths] = strtok(optarg, " , ");
			if (pathlist[npaths++] == NULL) {
				progerr(gettext(ERR_POPTION));
				quit(1);
			}
			while (pathlist[npaths] = strtok(NULL, " , ")) {
				if (npaths++ >= MAXPATHS) {
					progerr(gettext(ERR_MAXPATHS),
					    MAXPATHS);
					quit(1);
				}
			}
			break;

		case 'd':
			dvalue = optarg;
			dflag = 1;
			break;

		case 'n':
			nflag++;
			break;

		case 'M':
			map_client = 0;
			break;

		/*
		 * Allow admin to establish the client filesystem using a
		 * vfstab-like file of stable format.
		 */
		case 'V':
			vfstab_file = flex_device(optarg, 2);
			map_client = 1;
			break;

		case 'f':
			if (getuid()) {
				progerr(gettext(ERR_NOTROOT), prog);
				quit(1);
			}
			fflag++;
			break;

		case 'i':
			setpathlist(optarg);
			break;

		case 'v':
			vflag++;
			break;

		case 'l':
			lflag++;
			break;

		case 'L':
			Lflag++;
			break;

		case 'x':
			if (aflag < 0)
				aflag = 0;
			if (cflag < 0)
				cflag = 0;
			xflag++;
			break;

		case 'q':
			qflag++;
			break;

		case 'a':
			if (cflag < 0)
				cflag = 0;
			aflag = 1;
			break;

		case 'c':
			if (aflag < 0)
				aflag = 0;
			cflag = 1;
			break;

		case 'e':
			envfile = optarg;
			break;

		case 'm':
			mapfile = optarg;
			break;

		case 'R':
			Rvalue = optarg;
			Rflag = 1;
			break;

		case 'Y':
			catg_arg = strdup(optarg);

			if ((category = get_categories(catg_arg)) == NULL) {
				progerr(gettext(ERR_CAT_INV), catg_arg);
				quit(1);
			} else if (is_not_valid_length(category)) {
				progerr(gettext(ERR_CAT_LNGTH));
				quit(1);
			}
			break;

		case 'P':
			ppathlist[npaths] = strtok(optarg, " , ");
			if ((ppathlist[npaths] == NULL) ||
			    (ppathlist[npaths][0] == '-')) {
				progerr(gettext(ERR_PARTIAL_POPTION));
				quit(1);
			}
			npaths++;
			while (ppathlist[npaths] = strtok(NULL, " , ")) {
				if (npaths++ >= MAXPATHS) {
					progerr(gettext(ERR_MAXPATHS),
					    MAXPATHS);
					quit(1);
				}
			}
			break;

		default:
			usage();
			/*NOTREACHED*/
			/*
			 * Although usage() calls a noreturn function,
			 * needed to add return (1);  so that main() would
			 * pass compilation checks. The statement below
			 * should never be executed.
			 */
			return (1);
		}
	}

	/* Check for incompatible options */
	if (dflag && Rflag)
		usage();

	/* Check for root dir and device dir if set */
	if (Rflag) {
		if (!set_inst_root(Rvalue)) {
			progerr(gettext(ERR_ROOT_CMD));
			quit(1);
		}
	}

	if (dflag)
		device = flex_device(dvalue, 1);

	if (lflag || Lflag) {
		/* we're only supposed to list information */
		if ((cflag >= 0) || (aflag >= 0) ||
		    qflag || xflag || fflag || nflag || vflag)
			usage();
	}

	set_PKGpaths(get_inst_root());

	if (catg_arg != NULL && device == NULL) {
		if (argc - optind) {
			usage();
		}
		pkg = gpkglist(pkgdir, all_pkgs, category);
		if (pkg == NULL) {
			progerr(gettext(ERR_CAT_FND), catg_arg);
			quit(1);
		} else {
			for (pkgcnt = 0; pkg[pkgcnt] != NULL; pkgcnt++)
				;
		}
	} else if (catg_arg != NULL && optind < argc) {
		usage();
	} else {
		pkg = &argv[optind];
		pkgcnt = (argc - optind);
	}

	/* read the environment for the pkgserver */
	pkgserversetmode(DEFAULTMODE);

	environ = NULL;		/* Sever the parent environment. */

	if (vcfile() == 0) {
		quit(99);
	}

	errflg = 0;
	if (mapfile) {
		/* check for incompatible options */
		if (device || pkgcnt)
			usage();
		put_path_params();	/* Restore what's needed. */

		/* send pathtype if partial path */
		pathtype = (ppathlist[0] != NULL) ? 1 : 0;
		if (checkmap(0, (device != NULL), mapfile, envfile, NULL,
		    NULL, pathtype))
			errflg++;
	} else if (device) {
		/* check for incompatible options */
		if ((cflag >= 0) || (aflag >= 0))
			usage();
		if (qflag || xflag || nflag || envfile)
			usage();
		tmpdir = NULL;
		if ((spooldir = devattr(device, "pathname")) == NULL)
			spooldir = device;
		if (isdir(spooldir)) {
			tmpdir = spooldir = qstrdup(tmpnam(NULL));
			if (fflag) {
				logerr(gettext(WRN_F_SPOOL), *pkg);
				fflag = 0;
			}
			if (mkdir(spooldir, 0755)) {
				progerr(gettext(ERR_MKDIR), spooldir);
				quit(99);
			}
			if (n = pkgtrans(device, spooldir, pkg, PT_SILENT))
				quit(n);
			if (catg_arg != NULL)
				pkg = gpkglist(spooldir, all_pkgs, category);
			else
				pkg = gpkglist(spooldir, all_pkgs, NULL);
			pkgfmt = 0;
		} else {
			if (catg_arg != NULL)
				pkg = gpkglist(spooldir,
				    pkgcnt ? pkg : all_pkgs, category);
			else
				pkg = gpkglist(spooldir,
				    pkgcnt ? pkg : all_pkgs, NULL);
			pkgfmt = 1;
		}

		/*
		 * At this point pkg[] is the list of packages to check. They
		 * are in directory format in spooldir.
		 */
		if (pkg == NULL) {
			if (catg_arg != NULL) {
				progerr(gettext(ERR_CAT_FND), catg_arg);
				quit(1);
			} else {
				progerr(gettext(ERR_SEL_PKG));
				quit(1);
			}
		}

		aflag = 0;

		for (n = 0; pkg[n]; n++) {
			char locenv[PATH_MAX];

			if (pkgfmt)
				(void) printf(
				    gettext(MSG_CHK_DIR), pkg[n], device);
			else
				(void) printf(
				    gettext(MSG_CHK_STRM), pkg[n], device);

			(void) snprintf(pkgspool, sizeof (pkgspool),
			    "%s/%s", spooldir, pkg[n]);
			(void) snprintf(file, sizeof (file),
			    "%s/install", pkgspool);
			/* Here we check the install scripts. */
			(void) printf(
			    gettext("## Checking control scripts.\n"));
			(void) checkscripts(file, 0);
			/* Verify consistency with the pkgmap. */
			(void) printf(
			    gettext("## Checking package objects.\n"));
			(void) snprintf(file, sizeof (file),
			    "%s/pkgmap", pkgspool);
			(void) snprintf(locenv, sizeof (locenv),
			    "%s/pkginfo", pkgspool);
			envfile = locenv;

			/*
			 * NOTE : checkmap() frees the environ data and
			 * pointer when it's through with them.
			 */
			if (checkmap(0, (device != NULL), file, envfile,
			    pkg[n], NULL, 0))
				errflg++;
			(void) printf(
			    gettext("## Checking is complete.\n"));
		}
	} else {
		if (envfile)
			usage();

		put_path_params();	/* Restore what's needed. */

		/*
		 * If this is a check of a client of some sort, we'll need to
		 * mount up the client's filesystems. If the caller isn't
		 * root, this may not be possible.
		 */
		if (is_an_inst_root()) {
			if (getuid()) {
				logerr(gettext(MSG_NOTROOT));
				logerr(gettext(MSG_CONT));
			} else {
				if (get_mntinfo(map_client, vfstab_file))
					map_client = 0;
				if (map_client)
					mount_client();
			}
		}

		(void) snprintf(file, sizeof (file),
		    "%s/contents", get_PKGADM());
		if (ppathlist[0] != NULL) {
			for (n = 0; ppathlist[n]; n++) {
				if (checkmap(1, (device != NULL), file, NULL,
				    NULL, ppathlist[n], 1))
					errflg++;
			}
		} else if (pkg[0] != NULL) {
				if (checkmap(1, (device != NULL), file, NULL,
				    pkg[0], NULL, 0)) {
					errflg++;
				}
		} else {
			if (checkmap(1, (device != NULL), file, NULL,
			    NULL, NULL, 0)) {
				errflg++;
			}
		}

		if (map_client) {
			unmount_client();
		}
	}
	quit(errflg ? 1 : 0);
	/* LINTED: no return */
}

static void
setpathlist(char *file)
{
	int fd;
	struct stat st;
	FILE *fplist;
	char pathname[PATH_MAX];
	/*
	 * This trap laid to catch a mismatch between the declaration above and
	 * the hard-coded constant in the fscanf below
	 */
#if PATH_MAX != 1024
#error "PATH_MAX changed, so we have a bug to fix"
#endif

	if (strcmp(file, "-") == 0) {
		fplist = stdin;
	} else {
		if ((fd = open(file, O_RDONLY)) == -1) {
			progerr(gettext(ERR_IOPEN), file);
			quit(1);
		}
		if (fstat(fd, &st) == -1) {
			progerr(gettext(ERR_IOPEN), file);
			quit(1);
		}
		if (S_ISDIR(st.st_mode) || S_ISBLK(st.st_mode)) {
			progerr(gettext(ERR_PATHS_INVALID), file);
			quit(1);
		}
		if ((fplist = fdopen(fd, "r")) == NULL) {
			progerr(gettext(ERR_IOPEN), file);
			quit(1);
		}
	}
	while (fscanf(fplist, "%1024s", pathname) == 1) {
		if (*pathname == '\0') {
			progerr(gettext(ERR_PATHS_INVALID), file);
			quit(1);
		}
		pathlist[npaths] = qstrdup(pathname);
		if (npaths++ > MAXPATHS) {
			progerr(gettext(ERR_TOO_MANY), MAXPATHS);
			quit(1);
		}
	}
	if (npaths == 0) {
		progerr(gettext(ERR_IEMPTY));
		quit(1);
	}
	(void) fclose(fplist);
}

void
quit(int n)
{
	/* cleanup any temporary directories */
	(void) chdir("/");
	if (tmpdir != NULL) {
		(void) rrmdir(tmpdir);
		free(tmpdir);
		tmpdir = NULL;
	}
	(void) pkghead(NULL);
	exit(n);
	/*NOTREACHED*/
}

static void
usage(void)
{
	char *prog = get_prog_name();

	(void) fprintf(stderr, gettext(ERR_USAGE), prog, prog);
	quit(1);
	/*NOTREACHED*/
}



/* ============================================================================
 * SOURCE 61/98: minix4\exokernel\kernel_legacy\cmd\svr4pkg\pkgcond\main.c
 * Size: 97,479 bytes, Lines: 4,038
 * Hash: 590c1401fc48...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (c) 2017 Peter Tribble.
 */

/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 */


/*
 * Program:	pkgcond
 *
 * Function:	Implements the package command suite public utility pkgcond(8)
 *
 * Usage:	pkgcond [-nv] [-O debug] condition [ argument ]
 *
 *		command options:
 *			-n - negate results of condition test
 *			-v - verbose output of condition testing
 *
 *		<condition> may be any one of:
 *			can_add_driver [path]
 *			can_remove_driver [path]
 *			can_update_driver [path]
 *			is_alternative_root [path]
 *			is_boot_environment [path]
 *			is_diskless_client [path]
 *			is_global_zone [path]
 *			is_mounted_miniroot [path]
 *			is_netinstall_image [path]
 *			is_nonglobal_zone [path]
 *			is_path_writable path
 *			is_running_system [path]
 *			is_what [path]
 *			is_whole_root_nonglobal_zone [path]
 *
 *		<option(s)> are specific to the condition used
 *
 * Input:	depends on command
 *
 * Output:	depends on command
 *
 * Exit status:	If the -n option is not specified:
 *		== 0 - the specified condition is true (or exists).
 *		== 1 - the specified condition is false (or does not exist).
 *		== 2 - command line usage errors (including bad keywords)
 *		== 3 - command failed to perform the test due to a fatal error
 *
 *		If the -n option is specified:
 *		== 0 - the specified condition is false (or does not exist).
 *		== 1 - the specified condition is true (or exists).
 *		== 2 - command line usage errors (including bad keywords)
 *		== 3 - command failed to perform the test due to a fatal error
 */

#include <stdio.h>
#include <sys/mnttab.h>
#include <sys/mntent.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <fcntl.h>
#include <ctype.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <locale.h>
#include <errno.h>
#include <sys/param.h>
#include <assert.h>

#include <instzones_api.h>
#include <pkglib.h>
#include <install.h>
#include <libinst.h>
#include <libadm.h>
#include <messages.h>
#include "pkgcond.h"
#include "pkgcond_msgs.h"

/* Should be defined by cc -D */

#if	!defined(TEXT_DOMAIN)
#define	TEXT_DOMAIN "SYS_TEST"
#endif

/* commands to execute */

#define	LS_CMD		"/usr/bin/ls"

/*
 * type definition and "types" for testPath()
 */

typedef enum {
	TEST_EXISTS = 0x01,
	TEST_NOT_EXISTS = 0x02,
	TEST_IS_DIRECTORY = 0x04,
	TEST_IS_FILE = 0x08,
	TEST_NOT_DIRECTORY = 0x10,
	TEST_NOT_FILE = 0x20,
	TEST_IS_SYMBOLIC_LINK = 0x40,
	TEST_NOT_SYMBOLIC_LINK = 0x80,
	TEST_GLOBAL_TOKEN_IN_FILE = 0x100
} TEST_TYPES;

/* holds file system info */

struct fsi_t {
	char	*fsi_mntOptions;
	char	*fsi_fsType;
	char	*fsi_mntPoint;
};
typedef struct fsi_t	FSI_T;

/* holds parsed global data */

struct globalData_t {
		/* initial install: PKG_INIT_INSTALL=true */
	boolean_t gd_initialInstall;
		/* global zone install: SUNW_PKG_INSTALL_ZONENAME=global */
	boolean_t gd_globalZoneInstall;
		/* non-global zone install: SUNW_PKG_INSTALL_ZONENAME!=global */
	boolean_t gd_nonglobalZoneInstall;
		/* non-global zone is in a mounted state */
	boolean_t inMountedState;
		/* sorted list of all mounted file systems */
	FSI_T	*gd_fileSystemConfig;
		/* number of mounted file systems in list */
	long	gd_fileSystemConfigLen;
		/* current zone name */
	char	*gd_zoneName;
		/* SUNW_PKGCOND_GLOBAL_DATA:parentZone:zoneName */
	char	*gd_parentZoneName;
		/* SUNW_PKGCOND_GLOBAL_DATA:parentZone:zoneType */
	char	*gd_parentZoneType;
		/* root path to target: PKG_INSTALL_ROOT */
	char	*gd_installRoot;
		/* SUNW_PKGCOND_GLOBAL_DATA:currentZone:zoneName */
	char	*gd_currentZoneName;
		/* SUNW_PKGCOND_GLOBAL_DATA:currentZone:zoneType */
	char	*gd_currentZoneType;
		/* path provided on command line */
	char	*gd_cmdline_path;
};
typedef struct globalData_t	GLOBALDATA_T;

/* holds subcommands and their definitions */

struct cmd_t {
	char		*c_name;
	char		*c_args;
	int		(*c_func)(int argc, char **argv, GLOBALDATA_T *a_gdt);
};
typedef struct cmd_t	CMD_T;

/* Command function prototypes */

static int		cmd_can_add_driver(int argc, char **argv,
				GLOBALDATA_T *a_gdt);
static int		cmd_can_remove_driver(int argc, char **argv,
				GLOBALDATA_T *a_gdt);
static int		cmd_can_update_driver(int argc, char **argv,
				GLOBALDATA_T *a_gdt);
static int		cmd_is_alternative_root(int argc, char **argv,
				GLOBALDATA_T *a_gdt);
static int		cmd_is_boot_environment(int argc, char **argv,
				GLOBALDATA_T *a_gdt);
static int		cmd_is_diskless_client(int argc, char **argv,
				GLOBALDATA_T *a_gdt);
static int		cmd_is_global_zone(int argc, char **argv,
				GLOBALDATA_T *a_gdt);
static int		cmd_is_mounted_miniroot(int argc, char **argv,
				GLOBALDATA_T *a_gdt);
static int		cmd_is_netinstall_image(int argc, char **argv,
				GLOBALDATA_T *a_gdt);
static int		cmd_is_nonglobal_zone(int argc, char **argv,
				GLOBALDATA_T *a_gdt);
static int		cmd_is_path_writable(int argc, char **argv,
				GLOBALDATA_T *a_gdt);
static int		cmd_is_running_system(int argc, char **argv,
				GLOBALDATA_T *a_gdt);
static int		cmd_is_what(int argc, char **argv,
				GLOBALDATA_T *a_gdt);

/* Utility function Prototypes */

static boolean_t	getNegateResults(void);
static boolean_t	recursionCheck(int *r_recursion, char *a_function);
static int		adjustResults(int a_result);
static int		calculateFileSystemConfig(GLOBALDATA_T *a_gdt);
static int		getRootPath(char **r_rootPath);
static int		getZoneName(char **r_zoneName);
static int		mountOptionPresent(char *a_mntOptions, char *a_opt);
static int		parseGlobalData(char *a_envVar, GLOBALDATA_T **a_gdt);
static int		resolvePath(char **r_path);
static int		setRootPath(char *a_path, char *a_envVar,
    boolean_t a_mustExist);
static int		testPath(TEST_TYPES a_tt, char *format, ...);
static int		usage(char *a_format, ...);
static int		findToken(char *path, char *token);
static char		*getMountOption(char **p);
static void		dumpGlobalData(GLOBALDATA_T *a_gdt);
static void		removeLeadingWhitespace(char **a_str);
static void		setNegateResults(boolean_t setting);
static void		setVerbose(boolean_t);
static void		sortedInsert(FSI_T **r_list, long *a_listSize,
    char *a_mntPoint, char *a_fsType, char *a_mntOptions);
static void		setCmdLinePath(char **a_path, char **args,
    int num_args);

/* local static data */

static boolean_t	_negateResults = B_FALSE;
static char		*_rootPath = "/";

/* define subcommand data structure */

static CMD_T cmds[] = {
	{ "can_add_driver",		" [path]",
		cmd_can_add_driver },
	{ "can_remove_driver",		" [path]",
		cmd_can_remove_driver },
	{ "can_update_driver",		" [path]",
		cmd_can_update_driver },
	{ "is_alternative_root",	" [path]",
		cmd_is_alternative_root },
	{ "is_boot_environment",	" [path]",
		cmd_is_boot_environment },
	{ "is_diskless_client",		" [path]",
		cmd_is_diskless_client },
	{ "is_global_zone",		" [path]",
		cmd_is_global_zone },
	{ "is_mounted_miniroot",	" [path]",
		cmd_is_mounted_miniroot },
	{ "is_netinstall_image",	" [path]",
		cmd_is_netinstall_image },
	{ "is_nonglobal_zone",		" [path]",
		cmd_is_nonglobal_zone },
	{ "is_path_writable",		" path",
		cmd_is_path_writable },
	{ "is_running_system",		" [path]",
		cmd_is_running_system },
	{ "is_what", " [path]",
		cmd_is_what },
	/* last one must be all NULLs */
	{ NULL, NULL, NULL }
};

/*
 * *****************************************************************************
 * main
 * *****************************************************************************
 */

/*
 * Name:	main
 * Description:	main processing loop for pkgcond *
 * Return:	0 - condition is satisfied (true)
 *		1 - condition is not satisfied (false)
 *		2 - command line usage errors
 *		3 - failure to determine condition
 */

int
main(int argc, char **argv)
{
	GLOBALDATA_T	*gdt = NULL;
	char		**newargv;
	char		*p;
	int		cur_cmd;
	int		i;
	int		newargc;

	/* make standard output non-buffered */

	setbuf(stdout, NULL);

	/* set the default text domain for messaging */

	(void) setlocale(LC_ALL, "");
	(void) textdomain(TEXT_DOMAIN);

	/* remember command name */

	set_prog_name(argv[0]);

	/* tell spmi zones interface how to access package output functions */

	z_set_output_functions(echo, echoDebug, progerr);

	/* set verbose mode if appropriate environment variable is set */

	if (getenv(ENV_VAR_VERBOSE)) {
		/* same as -v */
		setVerbose(B_TRUE);
	}

	/* set debug mode if appropriate environment variable is set */

	if (getenv(ENV_VAR_DEBUG)) {
		/* same as -O debug */

		/* set sml tracing (sml.c) */
		smlSetVerbose(B_TRUE);

		/* set log and echo (interactive) message tracing */
		setVerbose(B_TRUE);

		/* enable echoDebug debugging messages */
		echoDebugSetFlag(B_TRUE);
	}

	/* generate usage if no options or arguments specified */

	if (argc <= 1) {
		(void) usage(MSG_NO_ARGUMENTS_SPECIFIED);
		return (R_USAGE);
	}

	/*
	 * process any arguments that can appear before the subcommand
	 */

	while ((i = getopt(argc, argv, ":O:vn?")) != EOF) {
		switch (i) {
		/*
		 * Not a public interface: the -O option allows the behavior
		 * of the package tools to be modified. Recognized options:
		 * -> debug
		 * ---> enable debugging output
		 */

		case 'O':
			for (p = strtok(optarg, ","); p != NULL;
			    p = strtok(NULL, ",")) {

				/* debug - enable all tracing */

				if (strcmp(p, "debug") == 0) {
					/* set sml tracing */
					smlSetVerbose(B_TRUE);
					/* set log/echo tracing */
					setVerbose(B_TRUE);
					/* enable debugging messages */
					echoDebugSetFlag(B_TRUE);
					continue;
				}

				progerr(ERR_INVALID_O_OPTION, p);
				return (adjustResults(R_USAGE));
			}
			break;

		/*
		 * Public interface: enable verbose (debug) output.
		 */

		case 'v':	/* verbose mode enabled */
			/* set command tracing only */
			setVerbose(B_TRUE);
			break;

		/*
		 * Public interface: negate output results.
		 */

		case 'n':
			setNegateResults(B_TRUE);
			break;

		/*
		 * unrecognized option
		 */

		case '?':
		default:
			(void) usage(MSG_INVALID_OPTION_SPECIFIED, optopt);
			return (R_USAGE);
		}
	}

	/*
	 * done processing options that can preceed subcommand
	 */

	/* error if no subcommand specified */

	if ((argc-optind) <= 0) {
		(void) usage(MSG_NO_ARGUMENTS_SPECIFIED);
		return (R_USAGE);
	}

	/* parse global data if environment variable set */

	if (parseGlobalData(PKGCOND_GLOBAL_VARIABLE, &gdt) != R_SUCCESS) {
		log_msg(LOG_MSG_ERR, ERR_CANNOT_USE_GLOBAL_DATA,
		    PKGCOND_GLOBAL_VARIABLE);
		return (R_ERROR);
	}

	if (setRootPath(gdt->gd_installRoot,
	    (strcmp(gdt->gd_installRoot, "/") == 0) ? NULL :
	    ENV_VAR_SET, B_TRUE) != R_SUCCESS) {
		log_msg(LOG_MSG_ERR, ERR_CANNOT_SET_ROOT_PATH,
		    ENV_VAR_PKGROOT);
		return (R_ERROR);
	}

	/* set path provided on the command line */

	setCmdLinePath(&(gdt->gd_cmdline_path), argv, argc);
	echoDebug(DBG_CMDLINE_PATH,
	    gdt->gd_cmdline_path == NULL ? "" : gdt->gd_cmdline_path);

	/* determine how file systems are layered in this zone */

	if (calculateFileSystemConfig(gdt) != R_SUCCESS) {
		log_msg(LOG_MSG_ERR, ERR_CANNOT_CALC_FS_CONFIG);
		return (R_ERROR);
	}

	/* dump global data read in (only if debugging) */

	dumpGlobalData(gdt);

	/* search for specified subcommand and execute if found */

	for (cur_cmd = 0; cmds[cur_cmd].c_name != NULL; cur_cmd++) {
		if (ci_streq(argv[optind], cmds[cur_cmd].c_name)) {
			int	result;

			/* make subcommand the first option */

			newargc = argc - optind;
			newargv = argv + optind;
			opterr = optind = 1; optopt = 0;


			/* call subcommand with its own argc/argv */

			result = cmds[cur_cmd].c_func(newargc, newargv, gdt);

			/* process result code and exit */

			result = adjustResults(result);
			log_msg(LOG_MSG_DEBUG, DBG_RESULTS, result);
			return (result);
		}
	}

	/* subcommand not found - output error message and exit with error */

	log_msg(LOG_MSG_ERR, ERR_BAD_SUB, argv[optind]);
	(void) usage(MSG_UNRECOGNIZED_CONDITION_SPECIFIED);
	return (R_USAGE);
}

/*
 * *****************************************************************************
 * command implementation functions
 * *****************************************************************************
 */

/*
 * Name:	cmd_is_diskless_client
 * Description:	determine if target is a diskless client
 * Scope:	public
 * Arguments:	argc,argv:
 *		  - optional path to target to test
 * Returns:	int
 *			== 0 - success
 *			!= 0 - failure
 * IMPLEMENTATION:
 *  - must not be initial installation to the install root
 *  - must not be installation of a zone
 *  - must not be a whole root non-global zone
 *  - must not be a non-global zone
 *  - must not be a mounted mini-root
 *  - must not be a netinstall image
 *  - must not be a boot environment
 *  - The package "SUNWdclnt" must be installed at "/"
 *  - The root path must not be "/"
 *  - The path "/export/exec/Solaris_\*\/usr" must exist at "/"
 *  - The directory "$ROOTDIR/../templates" must exist
 */

static int
cmd_is_diskless_client(int argc, char **argv, GLOBALDATA_T *a_gdt)
{
	char	*rootPath = NULL;
	char	cmd[MAXPATHLEN+1];
	int	c;
	int	r;
	int	rc;
static	char	*cmdName = "is_diskless_client";
static	int	recursion = 0;

	/* process any command line options */

	while ((c = getopt(argc, argv, ":")) != EOF) {
		switch (c) {
		case '\0':	/* prevent end-of-loop not reached warning */
			break;
		case '?':
		default:
			(void) usage(MSG_IS_INVALID_OPTION, optopt, cmdName);
			return (R_USAGE);
		}
	}

	/* prevent recursion */

	if (recursionCheck(&recursion, cmdName) == B_FALSE) {

		/*
		 * a diskless client cannot be any of the following
		 */

		/* cannot be non-global zone */

		r = cmd_is_nonglobal_zone(argc, argv, a_gdt);

		/* cannot be mounted miniroot */

		if (r != R_SUCCESS) {
			r = cmd_is_mounted_miniroot(argc, argv, a_gdt);
		}

		/* cannot be a netinstall image */

		if (r != R_SUCCESS) {
			r = cmd_is_netinstall_image(argc, argv, a_gdt);
		}

		/* cannot be a boot environment */

		if (r != R_SUCCESS) {
			r = cmd_is_boot_environment(argc, argv, a_gdt);
		}

		/* no need to guard against recursion any more */

		recursion--;

		/* return failure if any of the preceeding are true */

		switch (r) {
			case R_SUCCESS:
				return (R_FAILURE);
			case R_FAILURE:
				break;
			case R_USAGE:
			case R_ERROR:
			default:
				return (r);
		}
	}

	/* normalize argc/argv */

	argc -= optind;
	argv += optind;

	/* error if more than one argument */

	if (argc > 1) {
		log_msg(LOG_MSG_ERR, ERR_UNRECOGNIZED_OPTION, argv[1]);
		(void) usage(MSG_IS_INVALID_OPTION, argv[1]);
		return (R_USAGE);
	}

	/* process root path if first argument present */

	if (argc == 1) {
		if (setRootPath(argv[0], "argv[0]", B_TRUE) != R_SUCCESS) {
			return (R_ERROR);
		}
	}

	/* get current root path */

	r = getRootPath(&rootPath);
	if (r != R_SUCCESS) {
		return (r);
	}

	/* start of command debugging information */

	echoDebug(DBG_ROOTPATH_IS, rootPath);

	/* SUNWdclnt must be installed */

	if (pkgTestInstalled("SUNWdclnt", "/") != B_TRUE) {
		log_msg(LOG_MSG_DEBUG, DBG_IDLC_PKG_NOT_INSTALLED,
		    rootPath, "SUNWdclnt", "/");
		return (R_FAILURE);
	}

	/*   - $ROOTDIR must not be "/" */

	if (strcmp(rootPath, "/") == 0) {
		log_msg(LOG_MSG_DEBUG, DBG_IDLC_ROOTPATH_BAD, rootPath, "/");
		return (R_FAILURE);
	}

	/*   - zone name must be global */

	if (strcmp(a_gdt->gd_zoneName, GLOBAL_ZONENAME) != 0) {
		log_msg(LOG_MSG_DEBUG, DBG_IDLC_ZONE_BAD, rootPath,
		    GLOBAL_ZONENAME);
		return (R_FAILURE);
	}

	/*
	 * /export/exec/Solaris_"*"/usr must exist;
	 * create ls command to test:
	 * /usr/bin/ls /export/exec/Solaris_"*"/usr
	 */

	(void) snprintf(cmd, sizeof (cmd), "%s %s >/dev/null 2>&1",
	    LS_CMD, "/export/exec/Solaris_*/usr");

	/* execute command */

	rc = system(cmd);

	/* return error if ls returns something other than "0" */

	if (rc != 0) {
		log_msg(LOG_MSG_DEBUG, DBG_IDLC_PATH_MISSING,
		    rootPath, "/export/exec/Solaris_*/usr");
		return (R_FAILURE);
	}

	/*
	 * /usr must be empty on a diskless client:
	 * create ls command to test:
	 * /usr/bin/ls -d1 $ROOTDIR/usr/\*
	 */
	(void) snprintf(cmd, sizeof (cmd), "%s %s %s/%s >/dev/null 2>&1",
	    LS_CMD, "-1d", rootPath, "usr/*");

	/* execute command */

	rc = system(cmd);

	/* return error if ls returns "0" */

	if (rc == 0) {
		log_msg(LOG_MSG_DEBUG, DBG_IDLC_USR_IS_NOT_EMPTY,
		    rootPath);
		return (R_FAILURE);
	}

	/* there must be a templates directory at ${ROOTPATH}/../templates */

	r = testPath(TEST_EXISTS|TEST_IS_DIRECTORY,
	    "%s/%s", rootPath, "../templates");
	if (r != R_SUCCESS) {
		log_msg(LOG_MSG_DEBUG, DBG_IDLC_NO_TEMPLATES_PATH,
		    rootPath, rootPath, "../templates");
		return (R_FAILURE);
	}

	/* must not be initial installation to the install root */

	if ((a_gdt->gd_initialInstall == B_TRUE) &&
	    (strcmp(a_gdt->gd_installRoot, rootPath) == 0)) {
		/* initial install: install root cannot be diskless client */
		log_msg(LOG_MSG_DEBUG, DBG_IDLC_INITIAL_INSTALL, rootPath);
		return (R_FAILURE);
	}

	/* must not be installation of a zone */

	if ((a_gdt->gd_globalZoneInstall == B_TRUE) ||
	    (a_gdt->gd_nonglobalZoneInstall == B_TRUE)) {
		/* initial zone install: no path can be diskless client */
		log_msg(LOG_MSG_DEBUG, DBG_IDLC_ZONE_INSTALL, rootPath);
		return (R_FAILURE);
	}

	/* the path is a diskless client */

	log_msg(LOG_MSG_DEBUG, DBG_IDLC_PATH_IS_DISKLESS_CLIENT, rootPath);

	return (R_SUCCESS);
}

/*
 * Name:	cmd_is_global_zone
 * Description:	determine if target is a global zone
 * Scope:	public
 * Arguments:	argc,argv:
 *		  - optional path to target to test
 * Returns:	int
 *			== 0 - success
 *			!= 0 - failure
 * IMPLEMENTATION:
 *  - must not be initial installation to the install root
 *  - must not be installation of a non-global zone
 *  - must not be a non-global zone
 *  - must not be a mounted mini-root
 *  - must not be a netinstall image
 *  - must not be a diskless client
 *  - if $ROOTDIR is "/":
 *  -- if zone name is "GLOBAL", then is a global zone;
 *  -- else not a global zone.
 *  - $ROOTDIR/etc/zones must exist and be a directory
 *  - $ROOTDIR/.tmp_proto must not exist
 *  - $ROOTDIR/var must exist and must not be a symbolic link
 */

static int
cmd_is_global_zone(int argc, char **argv, GLOBALDATA_T *a_gdt)
{
	char	*rootPath = NULL;
	int	c;
	int	r;
static	char	*cmdName = "is_global_zone";
static	int	recursion = 0;

	/* process any command line options */

	while ((c = getopt(argc, argv, ":")) != EOF) {
		switch (c) {
		case '\0':	/* prevent end-of-loop not reached warning */
			break;
		case '?':
		default:
			(void) usage(MSG_IS_INVALID_OPTION, optopt, cmdName);
			return (R_USAGE);
		}
	}

	/* prevent recursion */

	if (recursionCheck(&recursion, cmdName) == B_FALSE) {

		/*
		 * a global zone cannot be any of the following
		 */

		/* cannot be a non-global zone */

		r = cmd_is_nonglobal_zone(argc, argv, a_gdt);

		/* cannot be a mounted miniroot */

		if (r != R_SUCCESS) {
			r = cmd_is_mounted_miniroot(argc, argv, a_gdt);
		}

		/* cannot be a netinstall image */

		if (r != R_SUCCESS) {
			r = cmd_is_netinstall_image(argc, argv, a_gdt);
		}

		/* cannot be a diskless client */

		if (r != R_SUCCESS) {
			r = cmd_is_diskless_client(argc, argv, a_gdt);
		}

		/* no need to guard against recursion any more */

		recursion--;

		/* return failure if any of the preceeding are true */

		switch (r) {
			case R_SUCCESS:
				return (R_FAILURE);
			case R_FAILURE:
				break;
			case R_USAGE:
			case R_ERROR:
			default:
				return (r);
		}
	}

	/* normalize argc/argv */

	argc -= optind;
	argv += optind;

	/* error if more than one argument */

	if (argc > 1) {
		log_msg(LOG_MSG_ERR, ERR_UNRECOGNIZED_OPTION, argv[1]);
		(void) usage(MSG_IS_INVALID_OPTION, argv[1]);
		return (R_USAGE);
	}

	/* process root path if first argument present */

	if (argc == 1) {
		if (setRootPath(argv[0], "argv[0]", B_TRUE) != R_SUCCESS) {
			return (R_ERROR);
		}
	}

	/* get current root path */

	r = getRootPath(&rootPath);
	if (r != R_SUCCESS) {
		return (r);
	}

	/* start of command debugging information */

	echoDebug(DBG_ROOTPATH_IS, rootPath);

	/* must not be initial installation to the install root */

	if ((a_gdt->gd_initialInstall == B_TRUE) &&
	    (strcmp(a_gdt->gd_installRoot, rootPath) == 0)) {
		/* initial install: install root cannot be global zone */
		log_msg(LOG_MSG_DEBUG, DBG_ISGZ_INITIAL_INSTALL, rootPath);
		return (R_FAILURE);
	}

	/* must not be installation of a non-global zone */

	if (a_gdt->gd_nonglobalZoneInstall == B_TRUE) {
		/* initial nonglobal zone install: no path can be global zone */
		log_msg(LOG_MSG_DEBUG, DBG_ISGZ_NGZ_ZONE_INSTALL, rootPath);
		return (R_FAILURE);
	}

	/* handle if global zone installation to the install root */

	if ((a_gdt->gd_globalZoneInstall == B_TRUE) &&
	    (strcmp(a_gdt->gd_installRoot, rootPath) == 0)) {
			/* the path is a global zone */

			log_msg(LOG_MSG_DEBUG, DBG_ISGZ_PATH_IS_GLOBAL_ZONE,
			    rootPath);

			return (R_SUCCESS);
	}

	/* true if current root is "/" and zone name is GLOBAL_ZONENAME */

	if (strcmp(rootPath, "/") == 0) {
		if (strcmp(a_gdt->gd_zoneName, GLOBAL_ZONENAME) == 0) {
			/* the path is a global zone */

			log_msg(LOG_MSG_DEBUG, DBG_ISGZ_PATH_IS_GLOBAL_ZONE,
			    rootPath);

			return (R_SUCCESS);
		}

		/* inside a non-global zone */

		log_msg(LOG_MSG_DEBUG, DBG_ISGZ_ZONENAME_ISNT_GLOBAL,
		    rootPath, a_gdt->gd_zoneName);

		return (R_FAILURE);
	}

	/*
	 * current root is not "/" - see if target looks like a global zone
	 *
	 * - rootpath is not "/"
	 * - and $ROOTDIR/etc/zones exists
	 * - and $ROOTDIR/.tmp_proto does not exist
	 * - and $ROOTDIR/var is not a symbolic link
	 */

	/* not global zone if /etc/zones does not exist */

	r = testPath(TEST_EXISTS|TEST_IS_DIRECTORY,
	    "%s/%s", rootPath, "/etc/zones");
	if (r != R_SUCCESS) {
		log_msg(LOG_MSG_DEBUG, DBG_ISGZ_PATH_ISNT_DIRECTORY,
		    rootPath, "/etc/zones");
		return (R_FAILURE);
	}

	/* .tmp_proto must not exist */

	r = testPath(TEST_NOT_EXISTS,
	    "%s/%s", rootPath, ".tmp_proto");
	if (r != R_SUCCESS) {
		log_msg(LOG_MSG_DEBUG, DBG_ISGZ_PATH_EXISTS,
		    rootPath, "/.tmp_proto");
		return (R_FAILURE);
	}

	/* /var must not be a symbolic link */

	r = testPath(TEST_EXISTS|TEST_NOT_SYMBOLIC_LINK,
	    "%s/%s", rootPath, "/var");
	if (r != R_SUCCESS) {
		log_msg(LOG_MSG_DEBUG, DBG_ISGZ_PATH_IS_SYMLINK,
		    rootPath, "/var");
		return (R_FAILURE);
	}

	/* the path is a global zone */

	log_msg(LOG_MSG_DEBUG, DBG_ISGZ_PATH_IS_GLOBAL_ZONE, rootPath);

	return (R_SUCCESS);
}

/*
 * Name:	cmd_is_netinstall_image
 * Description:	determine if target is a net install image
 * Scope:	public
 * Arguments:	argc,argv:
 *		  - optional path to target to test
 * Returns:	int
 *			== 0 - success
 *			!= 0 - failure
 * IMPLEMENTATION:
 *  - must not be initial installation to the install root
 *  - must not be installation of a zone
 *  - must not be a global zone
 *  - must not be a mounted mini-root
 *  - zone name must be "global"
 *  - $ROOTDIR/.tmp_proto must exist and must be a directory
 *  - $ROOTDIR/var must exist and must be a symbolic link
 *  - $ROOTDIR/tmp/kernel must exist and must be a directory
 *  - $ROOTDIR/.tmp_proto/kernel must exist and must be a symbolic link
 */

static int
cmd_is_netinstall_image(int argc, char **argv, GLOBALDATA_T *a_gdt)
{
	char	*rootPath = NULL;
	int	c;
	int	r;
static	char	*cmdName = "is_netinstall_image";
static	int	recursion = 0;

	/* process any command line options */

	while ((c = getopt(argc, argv, ":")) != EOF) {
		switch (c) {
		case '\0':	/* prevent end-of-loop not reached warning */
			break;
		case '?':
		default:
			(void) usage(MSG_IS_INVALID_OPTION, optopt, cmdName);
			return (R_USAGE);
		}
	}

	/* prevent recursion */

	if (recursionCheck(&recursion, cmdName) == B_FALSE) {

		/* a netinstall image cannot be a global zone */

		r = cmd_is_global_zone(argc, argv, a_gdt);

		/* no need to guard against recursion any more */

		recursion--;

		switch (r) {
			case R_SUCCESS:
				return (R_FAILURE);
			case R_FAILURE:
				break;
			case R_USAGE:
			case R_ERROR:
			default:
				return (r);
		}
	}

	/* normalize argc/argv */

	argc -= optind;
	argv += optind;

	/* error if more than one argument */

	if (argc > 1) {
		log_msg(LOG_MSG_ERR, ERR_UNRECOGNIZED_OPTION, argv[1]);
		(void) usage(MSG_IS_INVALID_OPTION, argv[1]);
		return (R_USAGE);
	}

	/* process root path if first argument present */

	if (argc == 1) {
		if (setRootPath(argv[0], "argv[0]", B_TRUE) != R_SUCCESS) {
			return (R_ERROR);
		}
	}

	/* get current root path */

	r = getRootPath(&rootPath);
	if (r != R_SUCCESS) {
		return (r);
	}

	/* start of command debugging information */

	echoDebug(DBG_ROOTPATH_IS, rootPath);

	/* current zone name must be "global" */

	if (strcmp(a_gdt->gd_zoneName, GLOBAL_ZONENAME) != 0) {
		log_msg(LOG_MSG_DEBUG, DBG_INIM_BAD_CURRENT_ZONE,
		    rootPath, GLOBAL_ZONENAME);
		return (R_FAILURE);
	}

	/* cannot be a mounted_miniroot */

	if (cmd_is_mounted_miniroot(argc, argv, a_gdt) == R_SUCCESS) {
		log_msg(LOG_MSG_DEBUG, DBG_IMRT_PATH_IS_MOUNTED_MINIROOT,
		    rootPath);
		return (R_FAILURE);
	}

	/* $ROOTDIR/.tmp_proto exists */

	r = testPath(TEST_EXISTS|TEST_IS_DIRECTORY,
	    "%s/%s", rootPath, ".tmp_proto");
	if (r != R_SUCCESS) {
		log_msg(LOG_MSG_DEBUG, DBG_INIM_PATH_ISNT_DIRECTORY,
		    rootPath, "/.tmp_proto");
		return (R_FAILURE);
	}

	/* $ROOTDIR/var is a symbolic link */

	r = testPath(TEST_IS_SYMBOLIC_LINK,
	    "%s/%s", rootPath, "/var");
	if (r != R_SUCCESS) {
		log_msg(LOG_MSG_DEBUG, DBG_INIM_PATH_ISNT_SYMLINK,
		    rootPath, "/var");
		return (R_FAILURE);
	}

	/* $ROOTDIR/tmp/kernel does exist */

	r = testPath(TEST_EXISTS|TEST_IS_DIRECTORY,
	    "%s/%s", rootPath, "/tmp/kernel");
	if (r != R_SUCCESS) {
		log_msg(LOG_MSG_DEBUG, DBG_INIM_PATH_ISNT_DIRECTORY,
		    rootPath, "/tmp/kernel");
		return (R_FAILURE);
	}

	/* $ROOTDIR/.tmp_proto/kernel is a symbolic link */

	r = testPath(TEST_IS_SYMBOLIC_LINK,
	    "%s/%s", rootPath, "/.tmp_proto/kernel");
	if (r != R_SUCCESS) {
		log_msg(LOG_MSG_DEBUG, DBG_INIM_PATH_ISNT_SYMLINK,
		    rootPath, "/.tmp_proto/kernel");
		return (R_FAILURE);
	}

	/* must not be initial installation to the install root */

	if ((a_gdt->gd_initialInstall == B_TRUE) &&
	    (strcmp(a_gdt->gd_installRoot, rootPath) == 0)) {
		/* initial install: install root cannot be netinstall image */
		log_msg(LOG_MSG_DEBUG, DBG_INIM_INITIAL_INSTALL, rootPath);
		return (R_FAILURE);
	}

	/* must not be installation of a zone */

	if ((a_gdt->gd_globalZoneInstall == B_TRUE) ||
	    (a_gdt->gd_nonglobalZoneInstall == B_TRUE)) {
		/* initial zone install: no path can be netinstall image */
		log_msg(LOG_MSG_DEBUG, DBG_INIM_ZONE_INSTALL, rootPath);
		return (R_FAILURE);
	}

	/* target is a netinstall image */

	log_msg(LOG_MSG_DEBUG, DBG_INIM_PATH_IS_NETINSTALL_IMAGE, rootPath);

	return (R_SUCCESS);
}

/*
 * Name:	cmd_is_mounted_miniroot
 * Description:	determine if target is a mounted miniroot image
 * Scope:	public
 * Arguments:	argc,argv:
 *		  - optional path to target to test
 * Returns:	int
 *			== 0 - success
 *			!= 0 - failure
 * IMPLEMENTATION:
 *  - must not be initial installation to the install root
 *  - must not be installation of a zone
 *  - zone name must be "global"
 *  - $ROOTDIR/tmp/kernel must exist and must be a symbolic link
 *  - $ROOTDIR/tmp/root/kernel must exist and must be a directory
 */

static int
cmd_is_mounted_miniroot(int argc, char **argv, GLOBALDATA_T *a_gdt)
{
	char	*rootPath = NULL;
	int	c;
	int	r;
static	char	*cmdName = "is_mounted_miniroot";
static	int	recursion = 0;

	/* process any command line options */

	while ((c = getopt(argc, argv, ":")) != EOF) {
		switch (c) {
		case '\0':	/* prevent end-of-loop not reached warning */
			break;
		case '?':
		default:
			(void) usage(MSG_IS_INVALID_OPTION, optopt, cmdName);
			return (R_USAGE);
		}
	}

	/* prevent recursion */

	if (recursionCheck(&recursion, cmdName) == B_FALSE) {
		recursion--;
	}

	/* normalize argc/argv */

	argc -= optind;
	argv += optind;

	/* error if more than one argument */

	if (argc > 1) {
		log_msg(LOG_MSG_ERR, ERR_UNRECOGNIZED_OPTION, argv[1]);
		(void) usage(MSG_IS_INVALID_OPTION, argv[1]);
		return (R_USAGE);
	}

	/* process root path if first argument present */

	if (argc == 1) {
		if (setRootPath(argv[0], "argv[0]", B_TRUE) != R_SUCCESS) {
			return (R_ERROR);
		}
	}

	/* get current root path */

	r = getRootPath(&rootPath);
	if (r != R_SUCCESS) {
		return (r);
	}

	/* start of command debugging information */

	echoDebug(DBG_ROOTPATH_IS, rootPath);

	/* current zone name must be "global" */

	if (strcmp(a_gdt->gd_zoneName, GLOBAL_ZONENAME) != 0) {
		log_msg(LOG_MSG_DEBUG, DBG_IMRT_BAD_CURRENT_ZONE,
		    rootPath, GLOBAL_ZONENAME);
		return (R_FAILURE);
	}

	/* $ROOTDIR/tmp/kernel is a symbolic link */

	r = testPath(TEST_IS_SYMBOLIC_LINK,
	    "%s/%s", rootPath, "/tmp/kernel");
	if (r != R_SUCCESS) {
		log_msg(LOG_MSG_DEBUG, DBG_IMRT_PATH_ISNT_SYMLINK,
		    rootPath, "/tmp/kernel");
		return (R_FAILURE);
	}

	/* $ROOTDIR/tmp/root/kernel is a directory */

	r = testPath(TEST_EXISTS|TEST_IS_DIRECTORY,
	    "%s/%s", rootPath, "/tmp/root/kernel");
	if (r != R_SUCCESS) {
		log_msg(LOG_MSG_DEBUG, DBG_IMRT_PATH_ISNT_DIRECTORY,
		    rootPath, "/tmp/root/kernel");
		return (R_FAILURE);
	}

	/* must not be initial installation to the install root */

	if ((a_gdt->gd_initialInstall == B_TRUE) &&
	    (strcmp(a_gdt->gd_installRoot, rootPath) == 0)) {
		/* initial install: install root cannot be mounted miniroot */
		log_msg(LOG_MSG_DEBUG, DBG_IMRT_INITIAL_INSTALL, rootPath);
		return (R_FAILURE);
	}

	/* must not be installation of a zone */

	if ((a_gdt->gd_globalZoneInstall == B_TRUE) ||
	    (a_gdt->gd_nonglobalZoneInstall == B_TRUE)) {
		/* initial zone install: no path can be mounted miniroot */
		log_msg(LOG_MSG_DEBUG, DBG_IMRT_ZONE_INSTALL, rootPath);
		return (R_FAILURE);
	}

	/* target is a mounted miniroot */

	log_msg(LOG_MSG_DEBUG, DBG_IMRT_PATH_IS_MOUNTED_MINIROOT, rootPath);

	return (R_SUCCESS);
}

/*
 * Name:	cmd_is_nonglobal_zone
 * Description:	determine if target is a global zone
 * Scope:	public
 * Arguments:	argc,argv:
 *		  - optional path to target to test
 * Returns:	int
 *			== 0 - success
 *			!= 0 - failure
 *  - must not be initial installation to the install root
 *  - must not be installation of a global zone
 *  - success if installation of a non-global zone
 */

static int
cmd_is_nonglobal_zone(int argc, char **argv, GLOBALDATA_T *a_gdt)
{
	char	*rootPath = NULL;
	int	c;
	int	r;
static	char	*cmdName = "is_nonglobal_zone";
static	int	recursion = 0;

	/* process any command line options */

	while ((c = getopt(argc, argv, ":")) != EOF) {
		switch (c) {
		case '\0':	/* prevent end-of-loop not reached warning */
			break;
		case '?':
		default:
			(void) usage(MSG_IS_INVALID_OPTION, optopt, cmdName);
			return (R_USAGE);
		}
	}

	/* prevent recursion */

	if (recursionCheck(&recursion, cmdName) == B_FALSE) {
		recursion--;
	}

	/* normalize argc/argv */

	argc -= optind;
	argv += optind;

	/* error if more than one argument */

	if (argc > 1) {
		log_msg(LOG_MSG_ERR, ERR_UNRECOGNIZED_OPTION, argv[1]);
		(void) usage(MSG_IS_INVALID_OPTION, argv[1]);
		return (R_USAGE);
	}

	/* process root path if first argument present */

	if (argc == 1) {
		if (setRootPath(argv[0], "argv[0]", B_TRUE) != R_SUCCESS) {
			return (R_ERROR);
		}
	}

	/* get current root path */

	r = getRootPath(&rootPath);
	if (r != R_SUCCESS) {
		return (r);
	}

	/* start of command debugging information */

	echoDebug(DBG_ROOTPATH_IS, rootPath);

	/* handle if non-global zone installation to the install root */

	if ((a_gdt->gd_nonglobalZoneInstall == B_TRUE) &&
	    (strcmp(a_gdt->gd_installRoot, rootPath) == 0)) {
		log_msg(LOG_MSG_DEBUG, DBG_NGZN_INSTALL_ZONENAME_IS_NGZ,
		    rootPath, a_gdt->gd_zoneName);
		return (R_SUCCESS);
	}

	/* must not be initial installation to the install root */

	if ((a_gdt->gd_initialInstall == B_TRUE) &&
	    (strcmp(a_gdt->gd_installRoot, rootPath) == 0)) {
		/* initial install: install root cannot be non-global zone */
		log_msg(LOG_MSG_DEBUG, DBG_NGZN_INITIAL_INSTALL, rootPath);
		return (R_FAILURE);
	}

	/* must not be installation of a global zone */

	if ((a_gdt->gd_globalZoneInstall == B_TRUE) ||
	    (a_gdt->gd_nonglobalZoneInstall == B_TRUE)) {
		/* initial global zone install: no path can be nonglobal zone */
		log_msg(LOG_MSG_DEBUG, DBG_NGZN_GLOBAL_ZONE_INSTALL, rootPath);
		return (R_FAILURE);
	}

	/*
	 * *********************************************************************
	 * if root directory is "/" then the only thing that needs to be done is
	 * to test the zone name directly - if the zone name is "global" then
	 * the target is not a non-global zone; otherwise if the zone name is
	 * not "global" then the target IS a non-global zone.
	 * *********************************************************************
	 */

	if (strcmp(rootPath, "/") == 0) {
		/* target is current running root */
		if (strcmp(a_gdt->gd_zoneName, GLOBAL_ZONENAME) == 0) {
			/* in the global zone */
			log_msg(LOG_MSG_DEBUG, DBG_NGZN_ZONENAME_ISNT_NGZ,
			    rootPath, a_gdt->gd_zoneName);
			return (R_FAILURE);
		}
		/* in a non-global zone */
		log_msg(LOG_MSG_DEBUG, DBG_NGZN_ZONENAME_IS_NGZ,
		    rootPath, a_gdt->gd_zoneName);
		return (R_SUCCESS);
	}

	/*
	 * $ROOTDIR/etc/zones/index must exist in a global zone. It also
	 * exists in a non-global zone after s10u4 but we can't check that
	 * since it is undeterministic for all releases so we only check
	 * for the global zone here.
	 */

	r = testPath(TEST_EXISTS, "%s/%s", rootPath, "/etc/zones/index");
	if (r == R_SUCCESS) {

		/* See if "global" exists in .../etc/zones/index */

		if (testPath(TEST_GLOBAL_TOKEN_IN_FILE, "%s/%s", rootPath,
		    "/etc/zones/index") != R_SUCCESS) {
			log_msg(LOG_MSG_DEBUG, DBG_NGZN_ZONENAME_ISNT_NGZ,
			    rootPath, GLOBAL_ZONENAME);
			return (R_FAILURE);
		}
	}

	/*
	 * *********************************************************************
	 * If the root directory is "/" then you can use only the zone
	 * name to determine if the zone is non-global or not since the
	 * package is being installed or removed to the current "zone".
	 *
	 * Since the root directory being tested is not "/" then you have to
	 * look into the target to try and infer zone type using means other
	 * than the zone name only.
	 * *********************************************************************
	 */

	/* reject if any items found that cannot be in a non-global zone */

	/* .tmp_proto must not exist */

	r = testPath(TEST_NOT_EXISTS, "%s/%s", rootPath, ".tmp_proto");
	if (r != R_SUCCESS) {
		/* $R/.tmp_proto cannot exist in a non-global zone */
		log_msg(LOG_MSG_DEBUG, DBG_NGZN_PATH_EXISTS,
		    rootPath, "/.tmp_proto");
		return (R_FAILURE);
	}

	/* /var must not be a symbolic link */

	r = testPath(TEST_EXISTS|TEST_NOT_SYMBOLIC_LINK,
	    "%s/%s", rootPath, "/var");
	if (r != R_SUCCESS) {
		/* $R/var cannot be a symbolic link in a non-global zone */
		log_msg(LOG_MSG_DEBUG, DBG_NGZN_PATH_DOES_NOT_EXIST,
		    rootPath, "/var");
		return (R_FAILURE);
	}

	/* $ROOTDIR/tmp/root/kernel must not exist */

	r = testPath(TEST_NOT_EXISTS,
	    "%s/%s", rootPath, "/tmp/root/kernel");
	if (r != R_SUCCESS) {
		/* $R/tmp/root/kernel cannot exist in a non-global zone */
		log_msg(LOG_MSG_DEBUG, DBG_NGZN_PATH_EXISTS,
		    rootPath, "/tmp/root/kernel");
		return (R_FAILURE);
	}

	/*
	 * *********************************************************************
	 * no items exist in $ROOTDIR that identify something other than
	 * a non-global zone.
	 *
	 * if in global zone no more tests possible: is a non-global zone
	 * *********************************************************************
	 */

	if (strcmp(a_gdt->gd_zoneName, GLOBAL_ZONENAME) == 0) {
		/* in the global zone */
		log_msg(LOG_MSG_DEBUG, DBG_NGZN_IN_GZ_IS_NONGLOBAL_ZONE,
		    rootPath);
		return (R_SUCCESS);
	}

	/*
	 * *********************************************************************
	 * In non-global zone: interrogate zone name and type.
	 *
	 * The parent zone is the zone that the "pkgadd" or "pkgrm" command was
	 * run in. The child zone is the zone that the "pkginstall" or
	 * "pkgremove" command was run in.
	 * *********************************************************************
	 */

	/*
	 * If parent zone name and current zone name defined, and
	 * both zone names are the same, since pkgcond is running
	 * inside of a non-global zone, this is how the scratch
	 * zone is implemented, so target is a non-global zone
	 */

	if ((a_gdt->gd_parentZoneName != NULL) &&
	    (a_gdt->gd_currentZoneName != NULL) &&
	    (strcmp(a_gdt->gd_parentZoneName,
	    a_gdt->gd_currentZoneName) == 0)) {
			/* parent and current zone name identical: non-gz */
			log_msg(LOG_MSG_DEBUG, DBG_NGZN_PARENT_CHILD_SAMEZONE,
			    rootPath, a_gdt->gd_parentZoneName);
			return (R_SUCCESS);
	}

	/*
	 * In non-global zone if zone specific read only FS's exist
	 * or it is in a mounted state.
	 */

	if (a_gdt->inMountedState) {
		log_msg(LOG_MSG_DEBUG, DBG_NGZN_IS_NONGLOBAL_ZONE, rootPath);
		return (R_SUCCESS);
	}

	/*
	 * the parent and current zone name are not the same;
	 * interrogate the zone types: the parent must be global
	 * and the current must be non-global, which would be set
	 * when a package command is run in the global zone that in
	 * turn runs a package command within the non-global zone.
	 */

	/* if defined, parent zone type must be "global" */

	if ((a_gdt->gd_parentZoneType != NULL) &&
	    (strcmp(a_gdt->gd_parentZoneType, "nonglobal") == 0)) {
		log_msg(LOG_MSG_DEBUG, DBG_NGZN_BAD_PARENT_ZONETYPE,
		    rootPath, "nonglobal");
		return (R_FAILURE);
	}

	/* if defined, current zone type must be "nonglobal" */

	if ((a_gdt->gd_currentZoneType != NULL) &&
	    (strcmp(a_gdt->gd_currentZoneType, GLOBAL_ZONENAME) == 0)) {
		log_msg(LOG_MSG_DEBUG, DBG_NGZN_BAD_CURRENT_ZONETYPE,
		    rootPath, GLOBAL_ZONENAME);
		return (R_FAILURE);
	}

	/*
	 * *********************************************************************
	 * no other tests possible: target is a non-global zone
	 * *********************************************************************
	 */

	log_msg(LOG_MSG_DEBUG, DBG_NGZN_IS_NONGLOBAL_ZONE, rootPath);

	return (R_SUCCESS);
}

/*
 * Name:	cmd_is_running_system
 * Description:	determine if target is a global zone
 * Scope:	public
 * Arguments:	argc,argv:
 *		  - optional path to target to test
 * Returns:	int
 *			== 0 - success
 *			!= 0 - failure
 * IMPLEMENTATION:
 *  - must not be initial installation to the install root
 *  - must not be installation of a zone
 *  - must not be a diskless client
 *  - $ROOTDIR must be "/"
 *  - zone name must be "global"
 */

static int
cmd_is_running_system(int argc, char **argv, GLOBALDATA_T *a_gdt)
{
	char	*rootPath = NULL;
	int	c;
	int	r;
static	char	*cmdName = "is_running_system";
static	int	recursion = 0;

	/* process any command line options */

	while ((c = getopt(argc, argv, ":")) != EOF) {
		switch (c) {
		case '\0':	/* prevent end-of-loop not reached warning */
			break;
		case '?':
		default:
			(void) usage(MSG_IS_INVALID_OPTION, optopt, cmdName);
			return (R_USAGE);
		}
	}

	/* prevent recursion */

	if (recursionCheck(&recursion, cmdName) == B_FALSE) {

		/* a running system cannot be a diskless client */

		r = cmd_is_diskless_client(argc, argv, a_gdt);

		/* no need to guard against recursion any more */

		recursion--;

		switch (r) {
			case R_SUCCESS:
				return (R_FAILURE);
			case R_FAILURE:
				break;
			case R_USAGE:
			case R_ERROR:
			default:
				return (r);
		}
	}

	/* normalize argc/argv */

	argc -= optind;
	argv += optind;

	/* error if more than one argument */

	if (argc > 1) {
		log_msg(LOG_MSG_ERR, ERR_UNRECOGNIZED_OPTION, argv[1]);
		(void) usage(MSG_IS_INVALID_OPTION, argv[1]);
		return (R_USAGE);
	}

	/* process root path if first argument present */

	if (argc == 1) {
		if (setRootPath(argv[0], "argv[0]", B_TRUE) != R_SUCCESS) {
			return (R_ERROR);
		}
	}

	/* get current root path */

	r = getRootPath(&rootPath);
	if (r != R_SUCCESS) {
		return (r);
	}

	/* start of command debugging information */

	echoDebug(DBG_ROOTPATH_IS, rootPath);

	/* if root path is "/" then check zone name */

	if (strcmp(rootPath, "/") != 0) {
		log_msg(LOG_MSG_DEBUG, DBG_IRST_ROOTPATH_BAD, rootPath, "/");
		return (R_FAILURE);
	}

	/* zone name must be global */

	if (strcmp(a_gdt->gd_zoneName, GLOBAL_ZONENAME) != 0) {
		log_msg(LOG_MSG_DEBUG, DBG_IRST_ZONE_BAD, rootPath,
		    GLOBAL_ZONENAME);
		return (R_FAILURE);
	}

	/* must not be initial installation to the install root */

	if ((a_gdt->gd_initialInstall == B_TRUE) &&
	    (strcmp(a_gdt->gd_installRoot, rootPath) == 0)) {
		/* initial install: install root cannot be the running system */
		log_msg(LOG_MSG_DEBUG, DBG_IRST_INITIAL_INSTALL, rootPath);
		return (R_FAILURE);
	}

	/* must not be installation of a zone */

	if ((a_gdt->gd_globalZoneInstall == B_TRUE) ||
	    (a_gdt->gd_nonglobalZoneInstall == B_TRUE)) {
		/* initial zone install: no path can be running system */
		log_msg(LOG_MSG_DEBUG, DBG_IRST_ZONE_INSTALL, rootPath);
		return (R_FAILURE);
	}

	/* target is a running system */

	log_msg(LOG_MSG_DEBUG, DBG_IRST_PATH_IS_RUNNING_SYSTEM, rootPath);

	return (R_SUCCESS);
}

/*
 * Name:	cmd_can_add_driver
 * Description:	determine if target is a global zone
 * Scope:	public
 * Arguments:	argc,argv:
 *		  - optional path to target to test
 * Returns:	int
 *			== 0 - success
 *			!= 0 - failure
 * Implementation:
 * A driver can be added to the system if the components of a Solaris
 * instance capable of loading drivers is present and it is not the
 * currently running system.
 */

static int
cmd_can_add_driver(int argc, char **argv, GLOBALDATA_T *a_gdt)
{
	char	*rootPath = NULL;
	int	c;
	int	r;
static	char	*cmdName = "can_add_driver";
static	int	recursion = 0;

	/* process any command line options */

	while ((c = getopt(argc, argv, ":")) != EOF) {
		switch (c) {
		case '\0':	/* prevent end-of-loop not reached warning */
			break;
		case '?':
		default:
			(void) usage(MSG_IS_INVALID_OPTION, optopt, cmdName);
			return (R_USAGE);
		}
	}

	/* prevent recursion */

	if (recursionCheck(&recursion, cmdName) == B_FALSE) {

		/* see if this is the current running system */

		r = cmd_is_running_system(argc, argv, a_gdt);

		/* cannot be a diskless client */

		if (r != R_SUCCESS) {
			r = cmd_is_diskless_client(argc, argv, a_gdt);
		}

		/* no need to guard against recursion any more */

		recursion--;

		switch (r) {
			case R_SUCCESS:
				/* is a running system */
				return (R_FAILURE);
			case R_FAILURE:
				/* not a running syste */
				break;
			case R_USAGE:
			case R_ERROR:
			default:
				/* cannot determine if is a running system */
				return (r);
		}
	}

	/* normalize argc/argv */

	argc -= optind;
	argv += optind;

	/* error if more than one argument */

	if (argc > 1) {
		log_msg(LOG_MSG_ERR, ERR_UNRECOGNIZED_OPTION, argv[1]);
		(void) usage(MSG_IS_INVALID_OPTION, argv[1]);
		return (R_USAGE);
	}

	/* process root path if first argument present */

	if (argc == 1) {
		if (setRootPath(argv[0], "argv[0]", B_TRUE) != R_SUCCESS) {
			return (R_ERROR);
		}
	}

	/* get current root path */

	r = getRootPath(&rootPath);
	if (r != R_SUCCESS) {
		return (r);
	}

	/* start of command debugging information */

	echoDebug(DBG_ROOTPATH_IS, rootPath);

	/* /etc must exist and must not be a symbolic link */

	r = testPath(TEST_EXISTS|TEST_NOT_SYMBOLIC_LINK,
	    "%s/%s", rootPath, "/etc");
	if (r != R_SUCCESS) {
		log_msg(LOG_MSG_DEBUG, DBG_ADDV_PATH_IS_SYMLINK,
		    rootPath, "/etc");
		return (R_FAILURE);
	}

	/* /platform must exist and must not be a symbolic link */

	r = testPath(TEST_EXISTS|TEST_NOT_SYMBOLIC_LINK,
	    "%s/%s", rootPath, "/platform");
	if (r != R_SUCCESS) {
		log_msg(LOG_MSG_DEBUG, DBG_ADDV_PATH_IS_SYMLINK,
		    rootPath, "/platform");
		return (R_FAILURE);
	}

	/* /kernel must exist and must not be a symbolic link */

	r = testPath(TEST_EXISTS|TEST_NOT_SYMBOLIC_LINK,
	    "%s/%s", rootPath, "/kernel");
	if (r != R_SUCCESS) {
		log_msg(LOG_MSG_DEBUG, DBG_ADDV_PATH_IS_SYMLINK,
		    rootPath, "/kernel");
		return (R_FAILURE);
	}

	/* can add a driver */

	log_msg(LOG_MSG_DEBUG, DBG_ADDV_YES, rootPath);

	return (R_SUCCESS);
}

/*
 * Name:	cmd_can_update_driver
 * Description:	determine if target is a global zone
 * Scope:	public
 * Arguments:	argc,argv:
 *		  - optional path to target to test
 * Returns:	int
 *			== 0 - success
 *			!= 0 - failure
 * Implementation:
 * A driver can be added to the system if the components of a Solaris
 * instance capable of loading drivers is present and it is not the
 * currently running system.
 */

static int
cmd_can_update_driver(int argc, char **argv, GLOBALDATA_T *a_gdt)
{
	char	*rootPath = NULL;
	int	c;
	int	r;
static	char	*cmdName = "can_update_driver";
static	int	recursion = 0;

	/* process any command line options */

	while ((c = getopt(argc, argv, ":")) != EOF) {
		switch (c) {
		case '\0':	/* prevent end-of-loop not reached warning */
			break;
		case '?':
		default:
			(void) usage(MSG_IS_INVALID_OPTION, optopt, cmdName);
			return (R_USAGE);
		}
	}

	/* prevent recursion */

	if (recursionCheck(&recursion, cmdName) == B_FALSE) {

		/* see if this is the current running system */

		r = cmd_is_running_system(argc, argv, a_gdt);

		/* cannot be a diskless client */

		if (r != R_SUCCESS) {
			r = cmd_is_diskless_client(argc, argv, a_gdt);
		}

		/* no need to guard against recursion any more */

		recursion--;

		switch (r) {
			case R_SUCCESS:
				/* is a running system */
				return (R_FAILURE);
			case R_FAILURE:
				/* not a running syste */
				break;
			case R_USAGE:
			case R_ERROR:
			default:
				/* cannot determine if is a running system */
				return (r);
		}
	}

	/* normalize argc/argv */

	argc -= optind;
	argv += optind;

	/* error if more than one argument */

	if (argc > 1) {
		log_msg(LOG_MSG_ERR, ERR_UNRECOGNIZED_OPTION, argv[1]);
		(void) usage(MSG_IS_INVALID_OPTION, argv[1]);
		return (R_USAGE);
	}

	/* process root path if first argument present */

	if (argc == 1) {
		if (setRootPath(argv[0], "argv[0]", B_TRUE) != R_SUCCESS) {
			return (R_ERROR);
		}
	}

	/* get current root path */

	r = getRootPath(&rootPath);
	if (r != R_SUCCESS) {
		return (r);
	}

	/* start of command debugging information */

	echoDebug(DBG_ROOTPATH_IS, rootPath);

	/* /etc must exist and must not be a symbolic link */

	r = testPath(TEST_EXISTS|TEST_NOT_SYMBOLIC_LINK,
	    "%s/%s", rootPath, "/etc");
	if (r != R_SUCCESS) {
		log_msg(LOG_MSG_DEBUG, DBG_UPDV_PATH_IS_SYMLINK,
		    rootPath, "/etc");
		return (R_FAILURE);
	}

	/* /platform must exist and must not be a symbolic link */

	r = testPath(TEST_EXISTS|TEST_NOT_SYMBOLIC_LINK,
	    "%s/%s", rootPath, "/platform");
	if (r != R_SUCCESS) {
		log_msg(LOG_MSG_DEBUG, DBG_UPDV_PATH_IS_SYMLINK,
		    rootPath, "/platform");
		return (R_FAILURE);
	}

	/* /kernel must exist and must not be a symbolic link */

	r = testPath(TEST_EXISTS|TEST_NOT_SYMBOLIC_LINK,
	    "%s/%s", rootPath, "/kernel");
	if (r != R_SUCCESS) {
		log_msg(LOG_MSG_DEBUG, DBG_UPDV_PATH_IS_SYMLINK,
		    rootPath, "/kernel");
		return (R_FAILURE);
	}

	/* can update driver */

	log_msg(LOG_MSG_DEBUG, DBG_UPDV_YES, rootPath);

	return (R_SUCCESS);
}

/*
 * Name:	cmd_can_remove_driver
 * Description:	determine if target is a global zone
 * Scope:	public
 * Arguments:	argc,argv:
 *		  - optional path to target to test
 * Returns:	int
 *			== 0 - success
 *			!= 0 - failure
 * Implementation:
 * A driver can be added to the system if the components of a Solaris
 * instance capable of loading drivers is present and it is not the
 * currently running system.
 */

static int
cmd_can_remove_driver(int argc, char **argv, GLOBALDATA_T *a_gdt)
{
	char	*rootPath = NULL;
	int	c;
	int	r;
static	char	*cmdName = "can_remove_driver";
static	int	recursion = 0;

	/* process any command line options */

	while ((c = getopt(argc, argv, ":")) != EOF) {
		switch (c) {
		case '\0':	/* prevent end-of-loop not reached warning */
			break;
		case '?':
		default:
			(void) usage(MSG_IS_INVALID_OPTION, optopt, cmdName);
			return (R_USAGE);
		}
	}

	/* prevent recursion */

	if (recursionCheck(&recursion, cmdName) == B_FALSE) {

		/* see if this is the current running system */

		r = cmd_is_running_system(argc, argv, a_gdt);

		/* cannot be a diskless client */

		if (r != R_SUCCESS) {
			r = cmd_is_diskless_client(argc, argv, a_gdt);
		}

		/* no need to guard against recursion any more */

		recursion--;

		switch (r) {
			case R_SUCCESS:
				/* is a running system */
				return (R_FAILURE);
			case R_FAILURE:
				/* not a running syste */
				break;
			case R_USAGE:
			case R_ERROR:
			default:
				/* cannot determine if is a running system */
				return (r);
		}
	}

	/* normalize argc/argv */

	argc -= optind;
	argv += optind;

	/* error if more than one argument */

	if (argc > 1) {
		log_msg(LOG_MSG_ERR, ERR_UNRECOGNIZED_OPTION, argv[1]);
		(void) usage(MSG_IS_INVALID_OPTION, argv[1]);
		return (R_USAGE);
	}

	/* process root path if first argument present */

	if (argc == 1) {
		if (setRootPath(argv[0], "argv[0]", B_TRUE) != R_SUCCESS) {
			return (R_ERROR);
		}
	}

	/* get current root path */

	r = getRootPath(&rootPath);
	if (r != R_SUCCESS) {
		return (r);
	}

	/* start of command debugging information */

	echoDebug(DBG_ROOTPATH_IS, rootPath);

	/* /etc must exist and must not be a symbolic link */

	r = testPath(TEST_EXISTS|TEST_NOT_SYMBOLIC_LINK,
	    "%s/%s", rootPath, "/etc");
	if (r != R_SUCCESS) {
		log_msg(LOG_MSG_DEBUG, DBG_RMDV_PATH_IS_SYMLINK,
		    rootPath, "/etc");
		return (R_FAILURE);
	}

	/* /platform must exist and must not be a symbolic link */

	r = testPath(TEST_EXISTS|TEST_NOT_SYMBOLIC_LINK,
	    "%s/%s", rootPath, "/platform");
	if (r != R_SUCCESS) {
		log_msg(LOG_MSG_DEBUG, DBG_RMDV_PATH_IS_SYMLINK,
		    rootPath, "/platform");
		return (R_FAILURE);
	}

	/* /kernel must exist and must not be a symbolic link */

	r = testPath(TEST_EXISTS|TEST_NOT_SYMBOLIC_LINK,
	    "%s/%s", rootPath, "/kernel");
	if (r != R_SUCCESS) {
		log_msg(LOG_MSG_DEBUG, DBG_RMDV_PATH_IS_SYMLINK,
		    rootPath, "/kernel");
		return (R_FAILURE);
	}

	/* can remove driver */

	log_msg(LOG_MSG_DEBUG, DBG_RMDV_YES, rootPath);

	return (R_SUCCESS);
}

/*
 * Name:	cmd_is_path_writable
 * Description:	determine if target path is writable
 * Scope:	public
 * Arguments:	argc,argv:
 *		  - optional path to target to test
 * Returns:	int
 *			== 0 - success
 *			!= 0 - failure
 * IMPLEMENTATION:
 * - path must be found in the file systems configured
 * - mount options must not include "read only"
 */

static int
cmd_is_path_writable(int argc, char **argv, GLOBALDATA_T *a_gdt)
{
	FSI_T	*list;
	char	*rootPath = NULL;
	int	c;
	int	n;
	int	nn;
	int	r;
	long	listSize;
	long	rootPathLen;
static	char	*cmdName = "is_path_writable";
static	int	recursion = 0;

	/* process any command line options */

	while ((c = getopt(argc, argv, ":")) != EOF) {
		switch (c) {
		case '\0':	/* prevent end-of-loop not reached warning */
			break;
		case '?':
		default:
			(void) usage(MSG_IS_INVALID_OPTION, optopt, cmdName);
			return (R_USAGE);
		}
	}

	/* prevent recursion */

	if (recursionCheck(&recursion, cmdName) == B_FALSE) {
		recursion--;
	}

	/* normalize argc/argv */

	argc -= optind;
	argv += optind;

	/* error if more than one argument */

	if (argc > 1) {
		log_msg(LOG_MSG_ERR, ERR_UNRECOGNIZED_OPTION, argv[1]);
		(void) usage(MSG_IS_INVALID_OPTION, argv[1]);
		return (R_USAGE);
	}

	/* process root path if first argument present */

	if (argc != 1) {
		(void) usage(ERR_REQUIRED_ROOTPATH_MISSING, cmdName);
		return (R_USAGE);
	}

	if (setRootPath(argv[0], "argv[0]", B_TRUE) != R_SUCCESS) {
		return (R_ERROR);
	}

	/* get current root path */

	r = getRootPath(&rootPath);
	if (r != R_SUCCESS) {
		return (r);
	}

	/* start of command debugging information */

	echoDebug(DBG_ROOTPATH_IS, rootPath);

	/* search file system conf for this path */

	rootPathLen = strlen(rootPath);
	list = a_gdt->gd_fileSystemConfig;
	listSize = a_gdt->gd_fileSystemConfigLen;
	for (nn = 0, n = 0; n < listSize; n++) {
		long	mplen = strlen(list[n].fsi_mntPoint);
		if (rootPathLen < mplen) {
			/* root path is longer than target, ignore */
			continue;
		}
		if (strncmp(rootPath, list[n].fsi_mntPoint, mplen) == 0) {
			/* remember last partial match */
			nn = n;
		}
	}

	log_msg(LOG_MSG_DEBUG, DBG_PWRT_INFO,
	    rootPath, list[nn].fsi_mntPoint, list[nn].fsi_fsType,
	    list[nn].fsi_mntOptions);

	/*
	 * need to determine if the mount point is writeable:
	 */

	/* see if the file system is mounted with the "read only" option */

	r = mountOptionPresent(list[nn].fsi_mntOptions, MNTOPT_RO);
	if (r == R_SUCCESS) {
		log_msg(LOG_MSG_DEBUG, DBG_PWRT_READONLY,
		    rootPath, list[nn].fsi_mntOptions);
		return (R_FAILURE);
	}

	/* target path is writable */

	log_msg(LOG_MSG_DEBUG, DBG_PWRT_IS, rootPath);

	return (R_SUCCESS);
}

/*
 * Name:	cmd_is_alternative_root
 * Description:	determine if target is an alternative root
 * Scope:	public
 * Arguments:	argc,argv:
 *		  - optional path to target to test
 * Returns:	int
 *			== 0 - success
 *			!= 0 - failure
 * Implementation:
 *  - success if an initial installation to the install root
 *	(an initial install to $PKG_INSTALL_ROOT means that $PKG_INSTALL_ROOT
 *	points to an alternative root that is under construction)
 *  - must not be installation of a zone
 *  - must not be a boot environment
 *  - must not be a diskless client
 *  - must not be a mounted miniroot
 *  - must not be a netinstall image
 *  - must not be a nonglobal zone
 *  - must not be a running system
 *  - $ROOTDIR must not be "/"
 *  - $ROOTDIR/var must exist
 */

static int
cmd_is_alternative_root(int argc, char **argv, GLOBALDATA_T *a_gdt)
{
	char	*rootPath = NULL;
	int	c;
	int	r;
static	char	*cmdName = "is_alternative_root";
static	int	recursion = 0;

	/* process any command line options */

	while ((c = getopt(argc, argv, ":")) != EOF) {
		switch (c) {
		case '\0':	/* prevent end-of-loop not reached warning */
			break;
		case '?':
		default:
			(void) usage(MSG_IS_INVALID_OPTION, optopt, cmdName);
			return (R_USAGE);
		}
	}

	/* prevent recursion */

	if (recursionCheck(&recursion, cmdName) == B_FALSE) {

		/*
		 * an alternative root cannot be any of the following
		 */

		/* cannot be a boot_environment */

		r = cmd_is_boot_environment(argc, argv, a_gdt);

		/* cannot be a diskless_client */

		if (r != R_SUCCESS) {
			r = cmd_is_diskless_client(argc, argv, a_gdt);
		}

		/* cannot be a mounted_miniroot */

		if (r != R_SUCCESS) {
			r = cmd_is_mounted_miniroot(argc, argv, a_gdt);
		}

		/* cannot be a netinstall_image */

		if (r != R_SUCCESS) {
			r = cmd_is_netinstall_image(argc, argv, a_gdt);
		}

		/* cannot be a nonglobal_zone */

		if (r != R_SUCCESS) {
			r = cmd_is_nonglobal_zone(argc, argv, a_gdt);
		}

		/* cannot be a running_system */

		if (r != R_SUCCESS) {
			r = cmd_is_running_system(argc, argv, a_gdt);
		}

		/* no need to guard against recursion any more */

		recursion--;

		/* return failure if any of the preceeding are true */

		switch (r) {
			case R_SUCCESS:
				return (R_FAILURE);
			case R_FAILURE:
				break;
			case R_USAGE:
			case R_ERROR:
			default:
				return (r);
		}
	}

	/* normalize argc/argv */

	argc -= optind;
	argv += optind;

	/* error if more than one argument */

	if (argc > 1) {
		log_msg(LOG_MSG_ERR, ERR_UNRECOGNIZED_OPTION, argv[1]);
		(void) usage(MSG_IS_INVALID_OPTION, argv[1]);
		return (R_USAGE);
	}

	/* process root path if first argument present */

	if (argc == 1) {
		if (setRootPath(argv[0], "argv[0]", B_TRUE) != R_SUCCESS) {
			return (R_ERROR);
		}
	}

	/* get current root path */

	r = getRootPath(&rootPath);
	if (r != R_SUCCESS) {
		return (r);
	}

	/* start of command debugging information */

	echoDebug(DBG_ROOTPATH_IS, rootPath);

	/* return success if initial installation */

	if ((a_gdt->gd_initialInstall == B_TRUE) &&
	    (strcmp(a_gdt->gd_installRoot, rootPath) == 0)) {
		log_msg(LOG_MSG_DEBUG, DBG_IALR_INITIAL_INSTALL, rootPath);
		return (R_SUCCESS);
	}

	/* root path must not be "/" */

	if (strcmp(rootPath, "/") == 0) {
		log_msg(LOG_MSG_DEBUG, DBG_IALR_BAD_ROOTPATH, rootPath, "/");
		return (R_FAILURE);
	}

	/* /var must exist */

	r = testPath(TEST_EXISTS,
	    "%s/%s", rootPath, "/var");
	if (r != R_SUCCESS) {
		log_msg(LOG_MSG_DEBUG, DBG_IALR_PATH_DOES_NOT_EXIST,
		    rootPath, "/var");
		return (R_FAILURE);
	}

	/* must not be installation of a zone */

	if ((a_gdt->gd_globalZoneInstall == B_TRUE) ||
	    (a_gdt->gd_nonglobalZoneInstall == B_TRUE)) {
		/* initial zone install: no path can be alternative root */
		log_msg(LOG_MSG_DEBUG, DBG_IALR_ZONE_INSTALL, rootPath);
		return (R_FAILURE);
	}

	/* target is an alternative root */

	log_msg(LOG_MSG_DEBUG, DBG_IALR_IS, rootPath);

	return (R_SUCCESS);
}

/*
 * Name:	cmd_is_boot_environment
 * Description:	determine if target is an alternative, inactive boot environment
 * Scope:	public
 * Arguments:	argc,argv:
 *		  - optional path to target to test
 * Returns:	int
 *			== 0 - success
 *			!= 0 - failure
 * IMPLEMENTATION:
 *  - must not be initial installation to the install root
 *  - must not be installation of a zone
 *  - must not be a diskless client
 *  - must not be a netinstall image
 *  - must not be a mounted miniroot
 *  - $ROOTDIR must not be "/"
 *  - $ROOTDIR/etc/lutab must exist
 *  - $ROOTDIR/etc/lu must exist and must be a directory
 */

static int
cmd_is_boot_environment(int argc, char **argv, GLOBALDATA_T *a_gdt)
{
	char	*rootPath = NULL;
	int	c;
	int	r;
static	char	*cmdName = "is_boot_environment";
static	int	recursion = 0;

	/* process any command line options */

	while ((c = getopt(argc, argv, ":")) != EOF) {
		switch (c) {
		case '\0':	/* prevent end-of-loop not reached warning */
			break;
		case '?':
		default:
			(void) usage(MSG_IS_INVALID_OPTION, optopt, cmdName);
			return (R_USAGE);
		}
	}

	/* prevent recursion */

	if (recursionCheck(&recursion, cmdName) == B_FALSE) {
		/*
		 * a boot environment cannot be any of the following
		 */

		/* cannot be a diskless client */

		r = cmd_is_diskless_client(argc, argv, a_gdt);

		/* cannot be a netinstall_image */

		if (r != R_SUCCESS) {
			r = cmd_is_netinstall_image(argc, argv, a_gdt);
		}

		/* cannot be a mounted_miniroot */

		if (r != R_SUCCESS) {
			r = cmd_is_mounted_miniroot(argc, argv, a_gdt);
		}

		/* no need to guard against recursion any more */

		recursion--;

		/* return failure if any of the preceeding are true */

		switch (r) {
			case R_SUCCESS:
				return (R_FAILURE);
			case R_FAILURE:
				break;
			case R_USAGE:
			case R_ERROR:
			default:
				return (r);
		}
	}

	/* normalize argc/argv */

	argc -= optind;
	argv += optind;

	/* error if more than one argument */

	if (argc > 1) {
		log_msg(LOG_MSG_ERR, ERR_UNRECOGNIZED_OPTION, argv[1]);
		(void) usage(MSG_IS_INVALID_OPTION, argv[1]);
		return (R_USAGE);
	}

	/* process root path if first argument present */

	if (argc == 1) {
		if (setRootPath(argv[0], "argv[0]", B_TRUE) != R_SUCCESS) {
			return (R_ERROR);
		}
	}

	/* get current root path */

	r = getRootPath(&rootPath);
	if (r != R_SUCCESS) {
		return (r);
	}

	/* start of command debugging information */

	echoDebug(DBG_ROOTPATH_IS, rootPath);

	/* root path must not be "/" */

	if (strcmp(rootPath, "/") == 0) {
		log_msg(LOG_MSG_DEBUG, DBG_BENV_BAD_ROOTPATH, rootPath, "/");
		return (R_FAILURE);
	}

	/* zone name must be global */

	if (strcmp(a_gdt->gd_zoneName, GLOBAL_ZONENAME) != 0) {
		log_msg(LOG_MSG_DEBUG, DBG_BENV_BAD_ZONE, rootPath,
		    GLOBAL_ZONENAME);
		return (R_FAILURE);
	}

	/* $ROOTDIR/etc/lutab must exist */

	r = testPath(TEST_EXISTS, "%s/%s", rootPath, "/etc/lutab");
	if (r != R_SUCCESS) {
		log_msg(LOG_MSG_DEBUG, DBG_BENV_NO_ETCLUTAB, rootPath,
		    "/etc/lutab");
		return (R_FAILURE);
	}

	/* $ROOTDIR/etc/lu must exist */

	r = testPath(TEST_EXISTS|TEST_IS_DIRECTORY,
	    "%s/%s", rootPath, "/etc/lu");
	if (r != R_SUCCESS) {
		log_msg(LOG_MSG_DEBUG, DBG_BENV_NO_ETCLU, rootPath, "/etc/lu");
		return (R_FAILURE);
	}

	/* must not be initial installation */

	if ((a_gdt->gd_initialInstall == B_TRUE) &&
	    (strcmp(a_gdt->gd_installRoot, rootPath) == 0)) {
		log_msg(LOG_MSG_DEBUG, DBG_BENV_INITIAL_INSTALL, rootPath);
		return (R_FAILURE);
	}

	/* must not be installation of a zone */

	if ((a_gdt->gd_globalZoneInstall == B_TRUE) ||
	    (a_gdt->gd_nonglobalZoneInstall == B_TRUE)) {
		/* initial zone install: no path can be boot environment */
		log_msg(LOG_MSG_DEBUG, DBG_BENV_ZONE_INSTALL, rootPath);
		return (R_FAILURE);
	}

	/* target is a boot environment */

	log_msg(LOG_MSG_DEBUG, DBG_BENV_IS, rootPath);

	return (R_SUCCESS);
}

/*
 * Name:	cmd_is_what
 * Description:	determine what the target is
 * Scope:	public
 * Arguments:	argc,argv:
 *		  - optional path to target to test
 * Returns:	int
 *			== 0 - success
 *			!= 0 - failure
 */

static int
cmd_is_what(int argc, char **argv, GLOBALDATA_T *a_gdt)
{
	char	*rootPath = NULL;
	int	c;
	int	cur_cmd;
	int	r;
static	char	*cmdName = "is_what";

	/* process any command line options */

	while ((c = getopt(argc, argv, ":")) != EOF) {
		switch (c) {
		case '\0':	/* prevent end-of-loop not reached warning */
			break;
		case '?':
		default:
			(void) usage(MSG_IS_INVALID_OPTION, optopt, cmdName);
			return (R_USAGE);
		}
	}

	/* normalize argc/argv */

	argc -= optind;
	argv += optind;

	/* error if more than one argument */

	if (argc > 1) {
		log_msg(LOG_MSG_ERR, ERR_UNRECOGNIZED_OPTION, argv[1]);
		(void) usage(MSG_IS_INVALID_OPTION, argv[1]);
		return (R_USAGE);
	}

	/* process root path if first argument present */

	if (argc == 1) {
		if (setRootPath(argv[0], "argv[0]", B_TRUE) != R_SUCCESS) {
			return (R_ERROR);
		}
	}

	/* get current root path */

	r = getRootPath(&rootPath);
	if (r != R_SUCCESS) {
		return (r);
	}

	/*
	 * construct the command line for all of the packages
	 */

	argc = 0;
	argv[argc++] = strdup(get_prog_name());
	argv[argc++] = strdup(rootPath);

	/* start of command debugging information */

	echoDebug(DBG_ROOTPATH_IS, rootPath);

	/* search for specified subcommand and execute if found */

	for (cur_cmd = 0; cmds[cur_cmd].c_name != NULL; cur_cmd++) {
		int	result;

		/* do not recursively call this function */

		if (cmds[cur_cmd].c_func == cmd_is_what) {
			continue;
		}

		/* call subcommand with its own argc/argv */

		result = cmds[cur_cmd].c_func(argc, argv, a_gdt);

		/* process result code and exit */

		result = adjustResults(result);
		log_msg(LOG_MSG_INFO, MSG_IS_WHAT_RESULT,
		    cmds[cur_cmd].c_name, result);
	}
	return (R_SUCCESS);
}

/*
 * *****************************************************************************
 * utility support functions
 * *****************************************************************************
 */

/*
 * Name:	getMountOption
 * Description:	return next mount option in a string
 * Arguments:	p - pointer to string containing mount options
 * Output:	none
 * Returns:	char * - pointer to next option in string "p"
 * Side Effects: advances input "p" and inserts \0 in place of the
 *		option separator found.
 */

static char *
getMountOption(char **p)
{
	char *cp = *p;
	char *retstr;

	/* advance past all white space */

	while (*cp && isspace(*cp))
		cp++;

	/* remember start of next option */

	retstr = cp;

	/* advance to end of string or option separator */

	while (*cp && *cp != ',')
		cp++;

	/* replace separator with '\0' if not at end of string */
	if (*cp) {
		*cp = '\0';
		cp++;
	}

	/* reset caller's pointer and return pointer to option */

	*p = cp;
	return (retstr);
}

/*
 * Name:	mountOptionPresent
 * Description:	determine if specified mount option is present in list
 *		of mount point options
 * Arguments:	a_mntOptions - pointer to string containing list of mount
 *			point options to search
 *		a_opt - pointer to string containing option to search for
 * Output:	none
 * Returns:	R_SUCCESS - option is present in list of mount point options
 *		R_FAILURE - options is not present
 *		R_ERROR - unable to determine if option is present or not
 */

static int
mountOptionPresent(char *a_mntOptions, char *a_opt)
{
	char tmpopts[MNT_LINE_MAX];
	char *f, *opts = tmpopts;

	/* return false if no mount options present */

	if ((a_opt == NULL) || (*a_opt == '\0')) {
		return (R_FAILURE);
	}

	/* return not present if no list of options to search */

	if (a_mntOptions == NULL) {
		return (R_FAILURE);
	}

	/* return not present if list of options to search is empty */

	if (*a_mntOptions == '\0') {
		return (R_FAILURE);
	}

	/* make local copy of option list to search */

	(void) strcpy(opts, a_mntOptions);

	/* scan each option looking for the specified option */

	f = getMountOption(&opts);
	for (; *f; f = getMountOption(&opts)) {
		/* return success if option matches target */
		if (strncmp(a_opt, f, strlen(a_opt)) == 0) {
			return (R_SUCCESS);
		}
	}

	/* option not found */

	return (R_FAILURE);
}

/*
 * Name:	sortedInsert
 * Description:	perform an alphabetical sorted insert into a list
 * Arguments:	r_list - pointer to list to insert next entry into
 *		a_listSize - pointer to current list size
 *		a_mntPoint - mount point to insert (is sort key)
 *		a_fsType - file system type for mount point
 *		a_mntOptions - file syste mount options for mount point
 * Output:	None
 * Returns:	None
 */

static void
sortedInsert(FSI_T **r_list, long *a_listSize, char *a_mntPoint,
    char *a_fsType, char *a_mntOptions)
{
	int	listSize;
	FSI_T	*list;
	int	n;

	/* entry assertions */

	assert(a_listSize != (long *)NULL);
	assert(a_mntPoint != NULL);
	assert(a_fsType != NULL);
	assert(a_mntOptions != NULL);

	/* entry debugging info */

	echoDebug(DBG_SINS_ENTRY, a_mntPoint, a_fsType, a_mntOptions);

	/* localize references to the list and list size */

	listSize = *a_listSize;
	list = *r_list;

	/*
	 * if list empty insert this entry as the first one in the list
	 */

	if (listSize == 0) {
		/* allocate new entry for list */
		listSize++;
		list = (FSI_T *)realloc(list, sizeof (FSI_T)*(listSize+1));

		/* first entry is data passed to this function */
		list[0].fsi_mntPoint = strdup(a_mntPoint);
		list[0].fsi_fsType = strdup(a_fsType);
		list[0].fsi_mntOptions = strdup(a_mntOptions);

		/* second entry is all NULL - end of entry marker */
		list[1].fsi_mntPoint = NULL;
		list[1].fsi_fsType = NULL;
		list[1].fsi_mntOptions = NULL;

		/* restore list and list size references to caller */
		*a_listSize = listSize;
		*r_list = list;

		return;
	}

	/*
	 * list not empty - scan looking for largest match
	 */

	for (n = 0; n < listSize; n++) {
		int	c;

		/* compare target with current list entry */

		c = strcmp(list[n].fsi_mntPoint, a_mntPoint);

		if (c == 0) {
			char	*me;
			long	len;

			/* entry already in list -- merge entries */

			len = strlen(list[n].fsi_mntOptions) +
			    strlen(a_mntOptions) + 2;
			me = (char *)calloc(1, len);

			/* merge two mount options lists into one */

			(void) strlcat(me, list[n].fsi_mntOptions, len);
			(void) strlcat(me, ",", len);
			(void) strlcat(me, a_mntOptions, len);

			/* free old list, replace with merged one */

			free(list[n].fsi_mntOptions);
			list[n].fsi_mntOptions = me;

			echoDebug(DBG_SORTEDINS_SKIPPED,
			    n, list[n].fsi_mntPoint, a_fsType,
			    list[n].fsi_fsType, a_mntOptions,
			    list[n].fsi_mntOptions);

			continue;
		} else if (c < 0) {
			/* entry before this one - skip */
			continue;
		}

		/*
		 * entry after this one - insert new entry
		 */

		/* allocate one more entry and make space for new entry */
		listSize++;
		list = (FSI_T *)realloc(list,
		    sizeof (FSI_T)*(listSize+1));
		(void) memmove(&(list[n+1]), &(list[n]),
		    sizeof (FSI_T)*(listSize-n));

		/* insert this entry into list */
		list[n].fsi_mntPoint = strdup(a_mntPoint);
		list[n].fsi_fsType = strdup(a_fsType);
		list[n].fsi_mntOptions = strdup(a_mntOptions);

		/* restore list and list size references to caller */
		*a_listSize = listSize;
		*r_list = list;

		return;
	}

	/*
	 * all entries are before this one - append to end of list
	 */

	/* allocate new entry at end of list */
	listSize++;
	list = (FSI_T *)realloc(list, sizeof (FSI_T)*(listSize+1));

	/* append this entry to the end of the list */
	list[listSize-1].fsi_mntPoint = strdup(a_mntPoint);
	list[listSize-1].fsi_fsType = strdup(a_fsType);
	list[listSize-1].fsi_mntOptions = strdup(a_mntOptions);

	/* restore list and list size references to caller */
	*a_listSize = listSize;
	*r_list = list;
}

/*
 * Name:	calculateFileSystemConfig
 * Description:	generate sorted list of all mounted file systems
 * Arguments:	a_gdt - global data structure to place sorted entries into
 * Output:	None
 * Returns:	R_SUCCESS - successfully generated mounted file systems list
 *		R_FAILURE - options is not present
 *		R_ERROR - unable to determine if option is present or not
 */

static int
calculateFileSystemConfig(GLOBALDATA_T *a_gdt)
{
	FILE		*fp;
	struct mnttab	mntbuf;
	FSI_T		*list;
	long		listSize;

	/* entry assetions */

	assert(a_gdt != (GLOBALDATA_T *)NULL);

	/* allocate a list that has one termination entry */

	list = (FSI_T *)calloc(1, sizeof (FSI_T));
	list[0].fsi_mntPoint = NULL;
	list[0].fsi_fsType = NULL;
	list[0].fsi_mntOptions = NULL;
	listSize = 0;

	/* open the mount table for reading */

	fp = fopen(MNTTAB, "r");
	if (fp == (FILE *)NULL) {
		return (R_ERROR);
	}

	/* debugging info */

	echoDebug(DBG_CALCSCFG_MOUNTED);

	/* go through all the specials looking for the device */

	while (getmntent(fp, &mntbuf) == 0) {
		if (mntbuf.mnt_mountp[0] == '/') {
			sortedInsert(&list, &listSize,
			    strdup(mntbuf.mnt_mountp),
			    strdup(mntbuf.mnt_fstype),
			    strdup(mntbuf.mnt_mntopts ?
			    mntbuf.mnt_mntopts : ""));
		}

		/*
		 * Set flag if we are in a non-global zone and it is in
		 * the mounted state.
		 */

		if (strcmp(mntbuf.mnt_mountp, "/a") == 0 &&
		    strcmp(mntbuf.mnt_special, "/a") == 0 &&
		    strcmp(mntbuf.mnt_fstype, "lofs") == 0) {
			a_gdt->inMountedState = B_TRUE;
		}

	}

	/* close mount table file */

	(void) fclose(fp);

	/* store list pointers in global data structure */

	a_gdt->gd_fileSystemConfig = list;
	a_gdt->gd_fileSystemConfigLen = listSize;

	return (R_SUCCESS);
}

/*
 * Name: 	adjustResults
 * Description:	adjust output result code before existing
 * Arguments:	a_result - result code to adjust
 * Returns:	int - adjusted result code
 */

static int
adjustResults(int a_result)
{
	boolean_t	negate = getNegateResults();
	int		realResult;

	/* adjust code as appropriate */

	switch (a_result) {
	case R_SUCCESS:		/* condition satisfied */
		realResult = ((negate == B_TRUE) ? 1 : 0);
		break;
	case R_FAILURE:		/* condition not satisfied */
		realResult = ((negate == B_TRUE) ? 0 : 1);
		break;
	case R_USAGE:		/* usage errors */
		realResult = 2;
		break;
	case R_ERROR:		/* condition could not be determined */
	default:
		realResult = 3;
		break;
	}

	/* debugging output */

	log_msg(LOG_MSG_DEBUG, DBG_ADJUST_RESULTS, a_result, negate,
	    realResult);

	/* return results */

	return (realResult);
}

/*
 * Name:        setCmdLinePath
 * Description:	set global command line path
 * Arguments:   path - path to set from the command line
 *              args - command line args
 *              num_args - number of command line args
 * Returns:     R_SUCCESS - root path successfully set
 *              R_FAILURE - root path could not be set
 *              R_ERROR - fatal error attempting to set root path
 */

static void
setCmdLinePath(char **path, char **args, int num_args)
{
	char   rp[PATH_MAX] = { '\0' };
	struct stat statbuf;

	if (*path != NULL) {
		return;
	}

	/*
	 * If a path "pkgcond is_global_zone [path]" is provided on the
	 * command line it must be the last argument.
	 */

	if (realpath(args[num_args - 1], rp) != NULL) {
		if (stat(rp, &statbuf) == 0) {
			/* make sure the target is a directory */
			if ((statbuf.st_mode & S_IFDIR)) {
				*path = strdup(rp);
			} else {
				*path = NULL;
			}
		}
	}
}

/*
 * Name:	setRootPath
 * Description:	set global root path returned by getRootPath
 * Arguments:	a_path - root path to set
 *		a_mustExist - B_TRUE if path must exist (else error)
 *			- B_FALSE if path may not exist
 * Returns:	R_SUCCESS - root path successfully set
 *		R_FAILURE - root path could not be set
 *		R_ERROR - fatal error attempting to set root path
 */

static int
setRootPath(char *a_path, char *a_envVar, boolean_t a_mustExist)
{
	char		rp[PATH_MAX] = { '\0' };
	struct stat	statbuf;

	/* if no data then issue warning and return success */

	if ((a_path == NULL) || (*a_path == '\0')) {
		echoDebug(DBG_NO_DEFAULT_ROOT_PATH_SET);
		return (R_SUCCESS);
	}

	/* path present - resolve to absolute path */

	if (realpath(a_path, rp) == NULL) {
		if (a_mustExist == B_TRUE) {
			/* must exist ... error */
			log_msg(LOG_MSG_ERR, ERR_DEFAULT_ROOT_INVALID,
			    a_path, strerror(errno));
			return (R_ERROR);
		} else {
			/* may not exist - use path as specified */
			(void) strcpy(rp, a_path);
		}
	}

	/* debugging output */

	echoDebug(DBG_DEFAULT_ROOT_PATH_SET, rp, a_envVar ? a_envVar : "");

	/* validate path existence if it must exist */

	if (a_mustExist == B_TRUE) {

		/* get node status */

		if (stat(rp, &statbuf) != 0) {
			log_msg(LOG_MSG_ERR, ERR_DEFAULT_ROOT_INVALID,
			    rp, strerror(errno));
			return (R_ERROR);
		}

		/* make sure the target is a directory */

		if (!(statbuf.st_mode & S_IFDIR)) {
			log_msg(LOG_MSG_ERR, ERR_DEFAULT_ROOT_NOT_DIR, rp);
			return (R_ERROR);
		}
	}

	/* target exists and is a directory - set */

	echoDebug(DBG_SET_ROOT_PATH_TO, rp);

	/* store copy of resolved root path */

	_rootPath = strdup(rp);

	/* success! */

	return (R_SUCCESS);
}

/*
 * Name:	testPath
 * Description:	determine if a path meets the specified conditions
 * Arguments:	a_tt - conditions to test path against
 * 		a_format - format to use to generate path
 *		arguments following a_format - as needed for a_format
 * Returns:	R_SUCCESS - the path meets all of the specified conditions
 *		R_FAILURE - the path does not meet all of the conditions
 *		R_ERROR - error attempting to test path
 */

/*PRINTFLIKE2*/
static int
testPath(TEST_TYPES a_tt, char *a_format, ...)
{
	char		*mbPath;	/* copy for the path to be returned */
	char		bfr[1];
	int		r;
	size_t		vres = 0;
	struct stat	statbuf;
	va_list		ap;
	int		fd;

	/* entry assertions */

	assert(a_format != NULL);
	assert(*a_format != '\0');

	/* determine size of the message in bytes */

	va_start(ap, a_format);
	vres = vsnprintf(bfr, 1, a_format, ap);
	va_end(ap);

	assert(vres > 0);

	/* allocate storage to hold the message */

	mbPath = (char *)calloc(1, vres+2);
	assert(mbPath != NULL);

	/* generate the results of the printf conversion */

	va_start(ap, a_format);
	vres = vsnprintf(mbPath, vres+1, a_format, ap);
	va_end(ap);

	assert(vres > 0);

	echoDebug(DBG_TEST_PATH, mbPath, (unsigned long)a_tt);

	/*
	 * When a path given to open(2) contains symbolic links, the
	 * open system call first resolves all symbolic links and then
	 * opens that final "resolved" path. As a result, it is not
	 * possible to check the result of an fstat(2) against the
	 * file descriptor returned by open(2) for S_IFLNK (a symbolic
	 * link) since all symbolic links are resolved before the
	 * target is opened.
	 *
	 * When testing the target as being (or not being) a symbolic
	 * link, first use lstat(2) against the target to determine
	 * whether or not the specified target itself is (or is not) a
	 * symbolic link.
	 */

	if (a_tt & (TEST_IS_SYMBOLIC_LINK|TEST_NOT_SYMBOLIC_LINK)) {
		/*
		 * testing target is/is not a symbolic link; use lstat
		 * to determine the status of the target itself rather
		 * than what the target might finally address.
		 */

		if (lstat(mbPath, &statbuf) != 0) {
			echoDebug(DBG_CANNOT_LSTAT_PATH, mbPath,
			    strerror(errno));
			free(mbPath);
			return (R_FAILURE);
		}

		/* Is the target required to be a symbolic link? */

		if (a_tt & TEST_IS_SYMBOLIC_LINK) {
			/* target must be a symbolic link */
			if (!(statbuf.st_mode & S_IFLNK)) {
				/* failure: target is not a symbolic link */
				echoDebug(DBG_IS_NOT_A_SYMLINK, mbPath);
				free(mbPath);
				return (R_FAILURE);
			}
			/* success: target is a symbolic link */
			echoDebug(DBG_SYMLINK_IS, mbPath);
		}

		/* Is the target required to not be a symbolic link? */

		if (a_tt & TEST_NOT_SYMBOLIC_LINK) {
			/* target must not be a symbolic link */
			if (statbuf.st_mode & S_IFLNK) {
				/* failure: target is a symbolic link */
				echoDebug(DBG_IS_A_SYMLINK, mbPath);
				free(mbPath);
				return (R_FAILURE);
			}
			/* success: target is not a symbolic link */
			echoDebug(DBG_SYMLINK_NOT, mbPath);
		}

		/*
		 * if only testing is/is not a symbolic link, then
		 * no need to open the target: return success.
		 */

		if (!(a_tt &
		    (~(TEST_IS_SYMBOLIC_LINK|TEST_NOT_SYMBOLIC_LINK)))) {
			free(mbPath);
			return (R_SUCCESS);
		}
	}

	/* resolve path and remove any whitespace */

	r = resolvePath(&mbPath);
	if (r != R_SUCCESS) {
		echoDebug(DBG_TEST_PATH_NO_RESOLVE, mbPath);
		free(mbPath);
		if (a_tt & TEST_NOT_EXISTS) {
			return (R_SUCCESS);
		}
		return (r);
	}

	echoDebug(DBG_TEST_PATH_RESOLVE, mbPath);

	/* open the file - this is the basic existence test */

	fd = open(mbPath, O_RDONLY|O_LARGEFILE, 0);

	/* existence test failed if file cannot be opened */

	if (fd < 0) {
		/*
		 * target could not be opened - if testing for non-existence,
		 * return success, otherwise return failure
		 */
		if (a_tt & TEST_NOT_EXISTS) {
			echoDebug(DBG_CANNOT_ACCESS_PATH_OK, mbPath);
			free(mbPath);
			return (R_SUCCESS);
		}

		echoDebug(DBG_CANNOT_ACCESS_PATH_BUT_SHOULD,
		    mbPath, strerror(errno));
		free(mbPath);

		return (R_FAILURE);
	}

	/*
	 * target successfully opened - if testing for non-existence,
	 * return failure, otherwise continue with specified tests
	 */

	if (a_tt & TEST_NOT_EXISTS) {
		/* testing for non-existence: return failure */
		echoDebug(DBG_TEST_EXISTS_SHOULD_NOT, mbPath);
		free(mbPath);
		(void) close(fd);
		return (R_FAILURE);
	}

	/* get the file status */

	r = fstat(fd, &statbuf);
	if (r != 0) {
		echoDebug(DBG_PATH_DOES_NOT_EXIST, mbPath, strerror(errno));
		(void) close(fd);
		free(mbPath);
		return (R_FAILURE);
	}

	/* required to be a directory? */

	if (a_tt & TEST_IS_DIRECTORY) {
		if (!(statbuf.st_mode & S_IFDIR)) {
			/* is not a directory */
			echoDebug(DBG_IS_NOT_A_DIRECTORY, mbPath);
			free(mbPath);
			return (R_FAILURE);
		}
		/* a directory */
		echoDebug(DBG_DIRECTORY_IS, mbPath);
	}

	/* required to not be a directory? */

	if (a_tt & TEST_NOT_DIRECTORY) {
		if (statbuf.st_mode & S_IFDIR) {
			/* is a directory */
			echoDebug(DBG_IS_A_DIRECTORY, mbPath);
			free(mbPath);
			return (R_FAILURE);
		}
		/* not a directory */
		echoDebug(DBG_DIRECTORY_NOT, mbPath);
	}

	/* required to be a file? */

	if (a_tt & TEST_IS_FILE) {
		if (!(statbuf.st_mode & S_IFREG)) {
			/* is not a regular file */
			echoDebug(DBG_IS_NOT_A_FILE, mbPath);
			free(mbPath);
			return (R_FAILURE);
		}
		/* a regular file */
		echoDebug(DBG_FILE_IS, mbPath);
	}

	/* required to not be a file? */

	if (a_tt & TEST_NOT_FILE) {
		if (statbuf.st_mode & S_IFREG) {
			/* is a regular file */
			echoDebug(DBG_IS_A_FILE, mbPath);
			free(mbPath);
			return (R_FAILURE);
		}
		/* not a regular file */
		echoDebug(DBG_FILE_NOT, mbPath);
	}

	/*
	 * Find token (global) in file pointed to by mbPath.
	 * token is only compared to first word in mbPath.
	 */

	if (a_tt & TEST_GLOBAL_TOKEN_IN_FILE) {
		if (!(statbuf.st_mode & S_IFREG)) {
			/* is not a regular file */
			echoDebug(DBG_IS_NOT_A_FILE, mbPath);
			free(mbPath);
			return (R_FAILURE);
		}
		/* If global exists then we're not in a non-global zone */
		if (findToken(mbPath, GLOBAL_ZONENAME) == R_SUCCESS) {
			echoDebug(DBG_TOKEN__EXISTS, GLOBAL_ZONENAME, mbPath);
			free(mbPath);
			return (R_FAILURE);
		}
	}

	(void) close(fd);

	/* success! */

	echoDebug(DBG_TESTPATH_OK, mbPath);

	/* free up temp storage used to hold path to test */

	free(mbPath);

	return (R_SUCCESS);
}

/*
 * Name:        findToken
 * Description:	Find first token in file.
 * Arguments:
 *              path - file to search for token
 *              token - string to search for
 * Returns:
 *              R_SUCCESS - the token exists
 *              R_FAILURE - the token does not exist
 *              R_ERROR - fatal error attempting to find token
 */

static int
findToken(char *path, char *token)
{
	FILE	*fp;
	char	*cp;
	char	line[MAXPATHLEN];

	if (path == NULL || token == NULL) {
		return (R_ERROR);
	}
	if ((fp = fopen(path, "r")) == NULL) {
		return (R_ERROR);
	}

	while (fgets(line, sizeof (line), fp) != NULL) {
		for (cp = line; *cp && isspace(*cp); cp++)
			;
		/* skip comments */
		if (*cp == '#') {
			continue;
		}
		if (pkgstrContainsToken(cp, token, ":")) {
			(void) fclose(fp);
			return (R_SUCCESS);
		}
	}
	(void) fclose(fp);
	return (R_FAILURE);
}


/*
 * Name:	resolvePath
 * Description:	fully resolve a path to an absolute real path
 * Arguments:	r_path - pointer to pointer to malloc()ed storage containing
 *			the path to resolve - this path may be reallocated
 *			as necessary to hold the fully resolved path
 * Output:	r_path - is realloc()ed as necessary
 * Returns:	R_SUCCESS - the path is fully resolved
 *		R_FAILURE - the path could not be resolved
 *		R_ERROR - fatal error attempting to resolve path
 */

static int
resolvePath(char **r_path)
{
	int		i;
	char		resolvedPath[MAXPATHLEN+1] = {'\0'};
	size_t		mbPathlen;	/* length of multi-byte path */
	size_t		wcPathlen;	/* length of wide-character path */
	wchar_t		*wcPath;	/* wide-character version of the path */
	wchar_t		*wptr;		/* scratch pointer */

	/* entry assertions */

	assert(r_path != NULL);

	/* return error if the path is completely empty */

	if (**r_path == '\0') {
		return (R_FAILURE);
	}

	/* remove all leading whitespace */

	removeLeadingWhitespace(r_path);

	/*
	 * convert to real path: an absolute pathname that names the same file,
	 * whose resolution does not involve ".", "..",  or  symbolic links.
	 */

	if (realpath(*r_path, resolvedPath) != NULL) {
		free(*r_path);
		*r_path = strdup(resolvedPath);
	}

	/*
	 *  convert the multi-byte version of the path to a
	 *  wide-character rendering, for doing our figuring.
	 */

	mbPathlen = strlen(*r_path);

	if ((wcPath = (wchar_t *)
	    calloc(1, sizeof (wchar_t)*(mbPathlen+1))) == NULL) {
		return (R_FAILURE);
	}

	/*LINTED*/
	if ((wcPathlen = mbstowcs(wcPath, *r_path, mbPathlen)) == -1) {
		free(wcPath);
		return (R_FAILURE);
	}

	/*
	 *  remove duplicate slashes first ("//../" -> "/")
	 */

	for (wptr = wcPath, i = 0; i < wcPathlen; i++) {
		*wptr++ = wcPath[i];

		if (wcPath[i] == '/') {
			i++;

			while (wcPath[i] == '/') {
				i++;
			}

			i--;
		}
	}

	*wptr = '\0';

	/*
	 *  now convert back to the multi-byte format.
	 */

	/*LINTED*/
	if (wcstombs(*r_path, wcPath, mbPathlen) == -1) {
		free(wcPath);
		return (R_FAILURE);
	}

	/* at this point have a path */

	/* free up temporary storage */

	free(wcPath);

	return (R_SUCCESS);
}

/*
 * Name:	removeLeadingWhitespace
 * Synopsis:	Remove leading whitespace from string
 * Description:	Remove all leading whitespace characters from a string
 * Arguments:	a_str - [RO, *RW] - (char **)
 *			Pointer to handle to string (in allocated storage) to
 *			remove all leading whitespace from
 * Returns:	void
 *			The input string is modified as follows:
 *			== NULL:
 *				- input string was NULL
 *				- input string is all whitespace
 *			!= NULL:
 *				- copy of input string with leading
 *				  whitespace removed
 * CAUTION:	The input string must be allocated space (via malloc() or
 *		strdup()) - it must not be a static or inline character string
 * NOTE:	The input string a_str will be freed with 'free'
 *		if it is all whitespace, or if it contains any leading
 *		whitespace characters
 * NOTE:    	Any string returned is placed in new storage for the
 *		calling method. The caller must use 'free' to dispose
 *		of the storage once the string is no longer needed.
 * Errors:	If the string cannot be created, the process exits
 */

static void
removeLeadingWhitespace(char **a_str)
{
	char	*o_str;

	/* entry assertions */

	assert(a_str != (char **)NULL);

	/* if string is null, just return */

	if (*a_str == NULL) {
		return;
	}
	o_str = *a_str;

	/* if string is empty, deallocate and return NULL */

	if (*o_str == '\0') {
		/* free string */
		free(*a_str);
		*a_str = NULL;
		return;
	}

	/* if first character is not a space, just return */

	if (!isspace(*o_str)) {
		return;
	}

	/* advance past all space characters */

	while ((*o_str != '\0') && (isspace(*o_str))) {
		o_str++;
	}

	/* if string was all space characters, deallocate and return NULL */

	if (*o_str == '\0') {
		/* free string */
		free(*a_str);
		*a_str = NULL;
		return;
	}

	/* have non-space/null byte, return dup, deallocate original */

	o_str = strdup(o_str);
	free(*a_str);
	*a_str = o_str;
}

/*
 * Name:	getZoneName
 * Description:	get the name of the zone this process is running in
 * Arguments:	r_zoneName - pointer to pointer to receive zone name
 * Output:	r_zoneName - a pointer to malloc()ed storage containing
 *			the zone name this process is running in is stored
 *			in the location pointed to by r_zoneName
 * Returns:	R_SUCCESS - the zone name is successfully returned
 *		R_FAILURE - the zone name is not successfully returned
 *		R_ERROR - error attempting to get the zone name
 */

static int
getZoneName(char **r_zoneName)
{
static char zoneName[ZONENAME_MAX] = { '\0' };

	/* if zone name not already present, retrieve and cache name */

	if (zoneName[0] == '\0') {
		if (getzonenamebyid(getzoneid(), zoneName,
		    sizeof (zoneName)) < 0) {
			log_msg(LOG_MSG_ERR, ERR_CANNOT_GET_ZONENAME);
			return (R_ERROR);
		}
	}

	/* return cached zone name */

	*r_zoneName = zoneName;
	return (R_SUCCESS);
}

/*
 * Name:	getRootPath
 * Description:	get the root path being tested by this process
 * Arguments:	r_rootPath - pointer to pointer to receive root path
 * Output:	r_rootPath - a pointer to malloc()ed storage containing
 *			the root path name this process is testing
 * Returns:	R_SUCCESS - the root path is successfully returned
 *		R_FAILURE - the root path is not successfully returned
 *		R_ERROR - error attempting to get the root path
 */

static int
getRootPath(char **r_rootPath)
{
	*r_rootPath = _rootPath;
	return (R_SUCCESS);
}

/*
 * Name:	setVerbose
 * Description:	Turns on verbose output
 * Scope:	public
 * Arguments:	verbose = B_TRUE indicates verbose mode
 * Returns:	none
 */

static void
setVerbose(boolean_t setting)
{
	/* set log verbose messages */

	log_set_verbose(setting);

	/* set interactive messages */

	echoSetFlag(setting);
}

/*
 * Name:	negate_results
 * Description:	control negation of results
 * Scope:	public
 * Arguments:	setting
 *		== B_TRUE indicates negated results mode
 *		== B_FALSE indicates non-negated results mode
 * Returns:	none
 */

static void
setNegateResults(boolean_t setting)
{
	log_msg(LOG_MSG_DEBUG, DBG_SET_NEGATE_RESULTS,
	    _negateResults, setting);

	_negateResults = setting;
}

/*
 * Name:	getNegateResults
 * Description:	Returns whether or not to results are negated
 * Scope:	public
 * Arguments:	none
 * Returns:	B_TRUE - results are negated
 *		B_FALSE - results are not negated
 */

static boolean_t
getNegateResults(void)
{
	return (_negateResults);
}

/*
 * Name:	usage
 * Description:	output usage string
 * Arguments:	a_format - format to use to generate message
 *		arguments following a_format - as needed for a_format
 * Output:	Outputs the usage string to stderr.
 * Returns:	R_ERROR
 */

static int
usage(char *a_format, ...)
{
	int		cur_cmd;
	char		cmdlst[LINE_MAX+1] = { '\0' };
	char		*message;
	char		bfr[1];
	char		*p = get_prog_name();
	size_t		vres = 0;
	va_list		ap;

	/* entry assertions */

	assert(a_format != NULL);
	assert(*a_format != '\0');

	/* determine size of the message in bytes */

	va_start(ap, a_format);
	/* LINTED warning: variable format specifier to vsnprintf(); */
	vres = vsnprintf(bfr, 1, a_format, ap);
	va_end(ap);

	assert(vres > 0);

	/* allocate storage to hold the message */

	message = (char *)calloc(1, vres+2);
	assert(message != NULL);

	/* generate the results of the printf conversion */

	va_start(ap, a_format);
	/* LINTED warning: variable format specifier to vsnprintf(); */
	vres = vsnprintf(message, vres+1, a_format, ap);
	va_end(ap);

	assert(vres > 0);

	/* generate list of all defined conditions */

	for (cur_cmd = 0; cmds[cur_cmd].c_name != NULL; cur_cmd++) {
		(void) strlcat(cmdlst, "\t", sizeof (cmdlst));
		(void) strlcat(cmdlst, cmds[cur_cmd].c_name, sizeof (cmdlst));
		if (cmds[cur_cmd].c_args != NULL) {
			(void) strlcat(cmdlst, cmds[cur_cmd].c_args,
			    sizeof (cmdlst));
		}
		(void) strlcat(cmdlst, "\n", sizeof (cmdlst));
	}

	/* output usage with conditions */

	log_msg(LOG_MSG_INFO, MSG_USAGE, message, p ? p : "pkgcond", cmdlst);

	return (R_ERROR);
}

/*
 * Name:	parseGlobalData
 * Description:	parse environment global data and store in global data structure
 * Arguments:	a_envVar - pointer to string representing the name of the
 *			environment variable to get and parse
 *		r_gdt - pointer to pointer to global data structure to fill in
 *			using the parsed data from a_envVar
 * Output:	none
 * Returns:	R_SUCCESS - the global data is successfully parsed
 *		R_FAILURE - problem parsing global data
 *		R_ERROR - fatal error attempting to parse global data
 */

static int
parseGlobalData(char *a_envVar, GLOBALDATA_T **r_gdt)
{
	int		r;
	char		*a;
	SML_TAG		*tag;
	SML_TAG		*ntag;

	assert(r_gdt != (GLOBALDATA_T **)NULL);

	/*
	 * allocate space for global data structure if needed
	 */

	if (*r_gdt == (GLOBALDATA_T *)NULL) {
		*r_gdt = (GLOBALDATA_T *)calloc(1, sizeof (GLOBALDATA_T));
	}

	/*
	 * get initial installation indication:
	 * If the initial install variable is set to "true", then an initial
	 * installation of Solaris is underway. When this condition is true:
	 * - if the path being checked is the package install root, then
	 *   the path is considered to be an 'alternative root' which is
	 *   currently being installed.
	 * - if the path being checked is not the package install root, then
	 *   the path needs to be further analyzed to determine what it may
	 *   be referring to.
	 */

	a = getenv(ENV_VAR_INITIAL_INSTALL);
	if ((a != NULL) && (strcasecmp(a, "true") == 0)) {
		(*r_gdt)->gd_initialInstall = B_TRUE;
	}

	/* get current zone name */

	r = getZoneName(&(*r_gdt)->gd_zoneName);
	if (r != R_SUCCESS) {
		(*r_gdt)->gd_zoneName = "";
	}

	/*
	 * get zone installation status:
	 * - If the package install zone name is not set, then an installation
	 *   of a global zone, or of a non-global zone, is not underway.
	 * - If the package install zone name is set to "global", then an
	 *   installation of a global zone is underway. In this case, no path
	 *   can be a netinstall image, diskless client, mounted miniroot,
	 *   non-global zone, the current running system, alternative root,
	 *   or alternative boot environment.
	 * - If the package install zone name is set to a value other than
	 *   "global", then an installation of a non-global zone with that name
	 *   is underway.  In this case, no path can be a netinstall image,
	 *   diskless client, mounted miniroot, global zone, the current
	 *   running system, alternative root, or alternative boot environment.
	 */

	a = getenv(ENV_VAR_PKGZONENAME);
	if ((a == NULL) || (*a == '\0')) {
		/* not installing a zone */
		(*r_gdt)->gd_globalZoneInstall = B_FALSE;
		(*r_gdt)->gd_nonglobalZoneInstall = B_FALSE;
	} else if (strcmp(a, GLOBAL_ZONENAME) == 0) {
		/* installing a global zone */
		(*r_gdt)->gd_globalZoneInstall = B_TRUE;
		(*r_gdt)->gd_nonglobalZoneInstall = B_FALSE;
		(*r_gdt)->gd_zoneName = a;
	} else {
		/* installing a non-global zone by that name */
		(*r_gdt)->gd_globalZoneInstall = B_FALSE;
		(*r_gdt)->gd_nonglobalZoneInstall = B_TRUE;
		(*r_gdt)->gd_zoneName = a;
	}

	/*
	 * get package install root.
	 */

	a = getenv(ENV_VAR_PKGROOT);
	if ((a != NULL) && (*a != '\0')) {
		(*r_gdt)->gd_installRoot = a;
	} else {
		(*r_gdt)->gd_installRoot = "/";
	}

	/* get the global data environment variable */

	a = getenv(a_envVar);

	/* if no data then issue warning and return success */

	if ((a == NULL) || (*a_envVar == '\0')) {
		log_msg(LOG_MSG_DEBUG, DBG_NO_GLOBAL_DATA_AVAILABLE, a_envVar);
		return (R_SUCCESS);
	}

	/* data present - parse into SML structure */

	log_msg(LOG_MSG_DEBUG, DBG_PARSE_GLOBAL, a);

	r = smlConvertStringToTag(&tag, a);
	if (r != R_SUCCESS) {
		log_msg(LOG_MSG_ERR, ERR_CANNOT_PARSE_GLOBAL_DATA, a);
		return (R_FAILURE);
	}

	smlDbgPrintTag(tag, DBG_PARSED_ENVIRONMENT, a_envVar);

	/* fill in global data structure */

	/* find the environment condition information structure */

	ntag = smlGetTagByName(tag, 0, TAG_COND_TOPLEVEL);
	if (ntag == SML_TAG__NULL) {
		log_msg(LOG_MSG_WRN, WRN_PARSED_DATA_MISSING,
		    TAG_COND_TOPLEVEL);
		return (R_FAILURE);
	}

	/*
	 * data found - extract what we know about
	 */

	/* parent zone name */

	a = smlGetParamByTag(ntag, 0, TAG_COND_PARENT_ZONE, TAG_COND_ZONE_NAME);
	(*r_gdt)->gd_parentZoneName = a;

	/* parent zone type */

	a = smlGetParamByTag(ntag, 0, TAG_COND_PARENT_ZONE, TAG_COND_ZONE_TYPE);
	(*r_gdt)->gd_parentZoneType = a;

	/* current zone name */

	a = smlGetParamByTag(ntag, 0, TAG_COND_CURRENT_ZONE,
	    TAG_COND_ZONE_NAME);
	(*r_gdt)->gd_currentZoneName = a;

	/* current zone type */

	a = smlGetParamByTag(ntag, 0, TAG_COND_CURRENT_ZONE,
	    TAG_COND_ZONE_TYPE);
	(*r_gdt)->gd_currentZoneType = a;

	return (R_SUCCESS);
}

/*
 * Name:	dumpGlobalData
 * Description:	dump global data structure using echoDebug
 * Arguments:	a_gdt - pointer to global data structure to dump
 * Outputs:	echoDebug is called to output global data strucutre information
 * Returns:	void
 */

static void
dumpGlobalData(GLOBALDATA_T *a_gdt)
{
	/* entry assertions */

	assert(a_gdt != (GLOBALDATA_T *)NULL);

	/* debugging enabled, dump the global data structure */

	echoDebug(DBG_DUMP_GLOBAL_ENTRY);
	echoDebug(DBG_DUMP_GLOBAL_PARENT_ZONE,
	    a_gdt->gd_parentZoneName ? a_gdt->gd_parentZoneName : "",
	    a_gdt->gd_parentZoneType ? a_gdt->gd_parentZoneType : "");
	echoDebug(DBG_DUMP_GLOBAL_CURRENT_ZONE,
	    a_gdt->gd_currentZoneName ? a_gdt->gd_currentZoneName : "",
	    a_gdt->gd_currentZoneType ? a_gdt->gd_currentZoneType : "");

}

/*
 * Name:	recursionCheck
 * Description:	prevent recursive calling of functions
 * Arguments:	r_recursion - pointer to int recursion counter
 *		a_function - pointer to name of function
 * Returns:	B_TRUE - function is recursively called
 *		B_FALSE - function not recursively called
 */

static boolean_t
recursionCheck(int *r_recursion, char *a_function)
{
	/* prevent recursion */

	(*r_recursion)++;
	if (*r_recursion > 1) {
		echoDebug(DBG_RECURSION, a_function, *r_recursion);
		(*r_recursion)--;
		return (B_TRUE);
	}

	echoDebug(DBG_NO_RECURSION, a_function);
	return (B_FALSE);
}

/*
 * Name:	quit
 * Description:	cleanup and exit
 * Arguments:	a_retcode - the code to use to determine final exit status;
 *			if this is NOT "99" and if a "ckreturnFunc" is
 *			set, then that function is called with a_retcode
 *			to set the final exit status.
 *		Valid values are:
 *		0 - success
 *		1 - package operation failed (fatal error)
 *		2 - non-fatal error (warning)
 *		3 - user selected quit (operation interrupted)
 *		4 - admin settings prevented operation
 *		5 - interaction required and -n (non-interactive) specified
 *		"10" is added to indicate "immediate reboot required"
 *		"20" is be added to indicate "reboot after install required"
 *		99 - do not interpret the code - just exit "99"
 * Returns:	<<this function does not return - calls exit()>>
 * NOTE:	This is needed because libinst functions can call "quit(99)"
 *		to force an error exit.
 */

void
quit(int a_retcode)
{
	/* process return code if not quit(99) */

	if (a_retcode == 99) {
		exit(0x7f);	/* processing error (127) */
	}

	exit(R_FAILURE);
}



/* ============================================================================
 * SOURCE 62/98: minix4\exokernel\kernel_legacy\cmd\svr4pkg\pkginstall\main.c
 * Size: 71,558 bytes, Lines: 2,891
 * Hash: 479f255a9a6b...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (c) 2017 Peter Tribble.
 */

/*
 * Copyright (c) 1989, 2010, Oracle and/or its affiliates. All rights reserved.
 */

/* Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T */
/* All Rights Reserved */


#include <stdio.h>
#include <time.h>
#include <wait.h>
#include <stdlib.h>
#include <unistd.h>
#include <ulimit.h>
#include <sys/stat.h>
#include <sys/statvfs.h>
#include <fcntl.h>
#include <errno.h>
#include <ctype.h>
#include <dirent.h>
#include <string.h>
#include <signal.h>
#include <locale.h>
#include <libintl.h>
#include <pkgstrct.h>
#include <pkginfo.h>
#include <pkgdev.h>
#include <pkglocs.h>
#include <pwd.h>
#include <assert.h>
#include <instzones_api.h>
#include <pkglib.h>
#include <install.h>
#include <libinst.h>
#include <libadm.h>
#include <dryrun.h>
#include <messages.h>
#include "pkginstall.h"

/* imported globals */

extern char	**environ;
extern char	*pkgabrv;
extern char	*pkgname;
extern char	*pkgarch;
extern char	*pkgvers;
extern char	pkgwild[];

/* libadm(3LIB) */

extern char	*get_install_root(void);

/* quit.c */

extern sighdlrFunc_t	*quitGetTrapHandler(void);
extern void		quitSetDstreamTmpdir(char *a_dstreamTempDir);
extern void		quitSetInstallStarted(boolean_t a_installStarted);
extern void		quitSetPkgask(boolean_t a_pkgaskFlag);
extern void		quitSetSilentExit(boolean_t a_silentExit);
extern void		quitSetUpdatingExisting(boolean_t a_updatingExisting);
extern void		quitSetZoneName(char *a_zoneName);


/* static globals */

static char	path[PATH_MAX];
static int	ck_instbase(void);
static int	cp_pkgdirs(void);
static int	merg_pkginfos(struct cl_attr **pclass,
		struct cl_attr ***mpclass);
static int	merg_respfile(void);
static int	mv_pkgdirs(void);
static int	rdonly(char *p);
static void	ck_w_dryrun(int (*func)(), int type);
static void	copyright(void);
static void	usage(void) __NORETURN;
static void	do_pkgask(boolean_t a_run_request_as_root);
static void	rm_icas(char *casdir);
static void	set_dryrun_dir_loc(void);
static void	unpack(void);

void	ckreturn(int retcode, char *msg);

static char	*ro_params[] = {
	"PATH", "NAME", "PKG", "PKGINST",
	"VERSION", "ARCH",
	"INSTDATE", "CATEGORY",
	NULL
};

/*
 * The following variable is the name of the device to which stdin
 * is connected during execution of a procedure script. PROC_STDIN is
 * correct for all ABI compliant packages. For non-ABI-compliant
 * packages, the '-o' command line switch changes this to PROC_XSTDIN
 * to allow user interaction during these scripts. -- JST
 */
static char	*script_in = PROC_STDIN;	/* assume ABI compliance */

static char	*pkgdrtarg = NULL;
static char	*pkgcontsrc = NULL;
static int	non_abi_scripts = 0;
static char	*respfile = NULL;
static char	*srcinst = NULL;
static int	suppressCopyright = 0;
static int	nointeract = 0;

/* exported globals */

char		*msgtext;
char		*pkginst = (char *)NULL;
char		*rw_block_size = NULL;
char		ilockfile[PATH_MAX];
char		instdir[PATH_MAX];
char		saveSpoolInstallDir[PATH_MAX];
char		pkgbin[PATH_MAX];
char		pkgloc[PATH_MAX];
char		pkgloc_sav[PATH_MAX];
char		pkgsav[PATH_MAX];
char		rlockfile[PATH_MAX];
char		savlog[PATH_MAX];
char		tmpdir[PATH_MAX];
int		dbchg;
int		dparts = 0;
int		dreboot = 0;
int		failflag = 0;
static int	askflag = 0;		/* non-zero if invoked as "pkgask" */
int		ireboot = 0;
int		maxinst = 1;
int		nocnflct;
int		nosetuid;
int		pkgverbose = 0;
int		rprcflag;
int		warnflag = 0;
struct admin	adm;
struct cfextra	**extlist; /* pkgmap structure and other path info */
struct pkgdev	pkgdev;
fsblkcnt_t	pkgmap_blks = 0LL;

/*
 * this global is referenced by:
 * getinst - [RW] - incremented if:
 * - installing same instance again
 * - overwriting an existing instance
 * - not installing a new instance
 * quit - [RO] - if non-zero and started non-zero:
 * - the new <PKGINST>/install directory and rename <PKGINST>/install.save
 * - back to <PKGINST>/install
 * main.c - [RO] - if non-zero:
 * - alter manner in which parameters are setup for scripts
 * - set UPDATE=yes in environment
 */
static int		update = 0;

/* Set by -O debug: debug output is enabled? */

static boolean_t	debugFlag = B_FALSE;

/* Set by the -G option: install packages in global zone only */

static boolean_t	globalZoneOnly = B_FALSE;

/* Set by -O preinstallcheck */

static boolean_t	preinstallCheck = B_FALSE;

/* Set by -O parent-zone-name= */

static char		*parentZoneName = (char *)NULL;

/* Set by -O parent-zone-type= */

static char		*parentZoneType = (char *)NULL;

#define	DEFPATH		"/sbin:/usr/sbin:/usr/bin"
#define	MALSIZ	4	/* best guess at likely maximum value of MAXINST */
#define	LSIZE	256	/* maximum line size supported in copyright file */

#if !defined(TEXT_DOMAIN)	/* Should be defined by cc -D */
#define	TEXT_DOMAIN "SYS_TEST"
#endif

/* This is the text for the "-O parent-zone-name=" option */

#define	PARENTZONENAME	"parent-zone-name="
#define	PARENTZONENAME_LEN	((sizeof (PARENTZONENAME))-1)

/* This is the text for the "-O parent-zone-type=" option */

#define	PARENTZONETYPE	"parent-zone-type="
#define	PARENTZONETYPE_LEN	((sizeof (PARENTZONETYPE))-1)

static char *cpio_names[] = {
	"root",
	"root.cpio",
	"reloc",
	"reloc.cpio",
	"root.Z",
	"root.cpio.Z",
	"reloc.Z",
	"reloc.cpio.Z",
	0
};

int
main(int argc, char *argv[])
{
	VFP_T			*cfTmpVfp = NULL;	/* temporary */
	VFP_T			*pkgmapVfp;	/* "../pkgmap" file */
	boolean_t		run_request_as_root = B_FALSE;
	char			**np;
	char			*abi_comp_ptr;
	char			*abi_nm_ptr;
	char			*abi_sym_ptr;
	char			*admnfile = NULL;
	char			*device;
	char			*p;
	char			*prog_full_name = NULL;
	char			*pt;
	char			*updated = (char *)NULL;
	char			*vfstab_file = NULL;
	char			*zoneName = (char *)NULL;
	char			cbuf[MAX_PKG_PARAM_LENGTH];
	char			cmdbin[PATH_MAX];
	char			p_pkginfo[PATH_MAX];
	char			p_pkgmap[PATH_MAX];
	char			param[MAX_PKG_PARAM_LENGTH];
	char			script[PATH_MAX];
	char			altscript[PATH_MAX];
	char			*temp;
	int			c;
	int			disableAttributes = 0;
	int			err;
	int			init_install = 0;
	int			is_comp_arch;
	int			live_continue = 0;
	int			map_client = 1;
	int			n;
	int			nparts;
	int			npkgs;
	int			part;
	int			saveSpoolInstall = 0;
	boolean_t		cont_file_read;
	struct cl_attr		**pclass = NULL;
	struct cl_attr		**mergd_pclass = NULL;
	struct pkginfo		*prvinfo;
	struct sigaction	nact;
	struct sigaction	oact;
	struct stat		statb;
	struct statvfs64	svfsb;
	time_t			clock;
	PKGserver		pkgserver = NULL;

	/* reset contents of all default paths */

	(void) memset(path, '\0', sizeof (path));
	(void) memset(cmdbin, '\0', sizeof (cmdbin));
	(void) memset(script, '\0', sizeof (script));
	(void) memset(cbuf, '\0', sizeof (cbuf));
	(void) memset(param, '\0', sizeof (param));

	/* initialize locale environment */

	(void) setlocale(LC_ALL, "");
	(void) textdomain(TEXT_DOMAIN);

	/* initialize program name */

	prog_full_name = argv[0];
	(void) set_prog_name(argv[0]);

	/* tell spmi zones interface how to access package output functions */

	z_set_output_functions(echo, echoDebug, progerr);

	/* exit if not root */

	if (getuid()) {
		progerr(ERR_NOT_ROOT, get_prog_name());
		exit(1);
		/* NOTREACHED */
	}

	/*
	 * determine how pkgmap() deals with environment variables:
	 *  - MAPALL - resolve all variables
	 *  - MAPBUILD - map only build variables
	 *  - MAPINSTALL - map only install variables
	 *  - MAPNONE - map no variables
	 */

	setmapmode(MAPINSTALL);

	/* set sane umask */

	(void) umask(0022);

	/* initially no source "device" */

	device = NULL;

	/* reset npkgs (used as pkg remaining count in quit.c) */

	npkgs = 0;

	/* Read PKG_INSTALL_ROOT from the environment, if it's there. */

	if (!set_inst_root(getenv("PKG_INSTALL_ROOT"))) {
		progerr(ERR_ROOT_SET);
		exit(1);
	}

	pkgserversetmode(DEFAULTMODE);

	/* parse command line options */

	while ((c = getopt(argc, argv,
		"?Aa:B:b:Cc:D:d:eFf:GhIiMm:N:noO:p:R:r:StV:vyz")) != EOF) {

		switch (c) {

		/*
		 * Same as pkgadd: This disables attribute checking.
		 * It speeds up installation a little bit.
		 */
		case 'A':
			disableAttributes++;
			break;

		/*
		 * Same as pkgadd: Define an installation administration
		 * file, admin, to be used in place of the default
		 * administration file.  The token none overrides the use
		 * of any admin file, and thus forces interaction with the
		 * user. Unless a full path name is given, pkgadd first
		 * looks in the current working directory for the
		 * administration file.  If the specified administration
		 * file is not in the current working directory, pkgadd
		 * looks in the /var/sadm/install/admin directory for the
		 * administration file.
		 */
		case 'a':
			admnfile = flex_device(optarg, 0);
			break;

		/*
		 * Same as pkgadd: control block size given to
		 * pkginstall - block size used in read()/write() loop;
		 * default is st_blksize from stat() of source file.
		 */
		case 'B':
			rw_block_size = optarg;
			break;

		/*
		 * Same as pkgadd: location where executables needed
		 * by procedure scripts can be found
		 * default is /usr/sadm/install/bin.
		 */
		case 'b':
			if (!path_valid(optarg)) {
				progerr(ERR_PATH, optarg);
				exit(1);
			}
			if (isdir(optarg) != 0) {
				char *p = strerror(errno);
				progerr(ERR_CANNOT_USE_DIR, optarg, p);
				exit(1);
			}
			(void) strlcpy(cmdbin, optarg, sizeof (cmdbin));
			break;

		/*
		 * Same as pkgadd: This disables checksum tests on
		 * the source files. It speeds up installation a little bit.
		 */
		case 'C':
			(void) checksum_off();
			break;

		/*
		 * Same as pkgadd: This allows designation of a
		 * continuation file. It is the same format as a dryrun file
		 * but it is used to take up where the dryrun left off.
		 */
		case 'c':
			pkgcontsrc = optarg;
			set_continue_mode();
			set_dr_info(DR_TYPE, INSTALL_TYPE);
			init_contfile(pkgcontsrc);
			break;

		/*
		 * Same as pkgadd: This allows designation of a
		 * dryrun file. This pkgadd will create dryrun files
		 * in the directory provided.
		 */
		case 'D':
			pkgdrtarg = optarg;
			set_dryrun_mode();
			set_dr_info(DR_TYPE, INSTALL_TYPE);
			break;

		/*
		 * Same as pkgadd: Install or copy a package from
		 * device. device can be a full path name to a directory
		 * or the identifiers for tape, floppy disk, or removable
		 * disk - for example, /var/tmp or /floppy/floppy_name.
		 * It can also be a device alias - for example,
		 * /floppy/floppy0, or a datastream created by pkgtrans.
		 */
		case 'd':
			device = flex_device(optarg, 1);
			break;

		/*
		 * Different from pkgadd: disable the 32 char name
		 * limit extension
		 */
		case 'e':
			(void) set_ABI_namelngth();
			break;

		/*
		 * Different from pkgadd: specify file system type for
		 * the package device. Must be used with -m.
		 */
		case 'f':
			pkgdev.fstyp = optarg;
			break;

		/*
		 * Same as pkgadd: install package in global zone only.
		 */
		case 'G':
			globalZoneOnly = B_TRUE;
			break;

		/*
		 * Same as pkgadd: Enable hollow package support. When
		 * specified, for any package that has SUNW_PKG_HOLLOW=true:
		 *  Do not calculate and verify package size against target.
		 *  Do not run any package procedure or class action scripts.
		 *  Do not create any target directories.
		 *  Do not perform any script locking.
		 *  Do not install any components of any package.
		 *  Do not output any status or database update messages.
		 */
		case 'h':
			set_depend_pkginfo_DB(B_TRUE);
			break;

		/*
		 * Same as pkgadd: Informs scripts that this is
		 * an initial install by setting the environment parameter
		 * PKG_INIT_INSTALL=TRUE for all scripts. They may use it as
		 * they see fit, safe in the knowledge that the target
		 * filesystem is tabula rasa.
		 */
		case 'I':
			init_install++;
			break;

		/*
		 * Different from pkgadd: use by pkgask.
		 */
		case 'i':
			askflag++;
			quitSetPkgask(B_TRUE);
			break;

		/*
		 * Same as pkgadd: Instruct pkgadd not to use the
		 * $root_path/etc/vfstab file for determining the client's
		 * mount points. This option assumes the mount points are
		 * correct on the server and it behaves consistently with
		 * Solaris 2.5 and earlier releases.
		 */
		case 'M':
			map_client = 0;
			break;

		/*
		 * Different from pkgadd: specify device to use for package
		 * source.
		 */
		case 'm':
			pkgdev.mount = optarg;
			pkgdev.rdonly++;
			pkgdev.mntflg++;
			break;

		/*
		 * Different from pkgadd: specify program name to use
		 * for messages.
		 */
		case 'N':
			(void) set_prog_name(optarg);
			break;

		/*
		 * Same as pkgadd: installation occurs in
		 * non-interactive mode.  Suppress output of the list of
		 * installed files. The default mode is interactive.
		 */
		case 'n':
			nointeract++;
			(void) echoSetFlag(B_FALSE);
			break;

		/*
		 * Almost same as pkgadd: the -O option allows the behavior
		 * of the package tools to be modified. Recognized options:
		 * -> debug
		 * ---> enable debugging output
		 * -> preinstallcheck
		 * ---> perform a "pre installation" check of the specified
		 * ---> package - suppress all regular output and cause a
		 * ---> series of one or more "name=value" pair format lines
		 * ---> to be output that describes the "installability" of
		 * ---> the specified package
		 * -> enable-hollow-package-support
		 * --> Enable hollow package support. When specified, for any
		 * --> package that has SUNW_PKG_HOLLOW=true:
		 * --> Do not calculate and verify package size against target
		 * --> Do not run any package procedure or class action scripts
		 * --> Do not create or remove any target directories
		 * --> Do not perform any script locking
		 * --> Do not install or uninstall any components of any package
		 * --> Do not output any status or database update messages
		 */
		case 'O':
			for (p = strtok(optarg, ","); p != (char *)NULL;
				p = strtok(NULL, ",")) {

				/* process debug option */

				if (strcmp(p, "debug") == 0) {
					/* set debug flag/enable debug output */
					if (debugFlag == B_TRUE) {
						smlSetVerbose(B_TRUE);
					}
					debugFlag = B_TRUE;
					(void) echoDebugSetFlag(debugFlag);

					/* debug info on arguments to pkgadd */
					for (n = 0; n < argc && argv[n]; n++) {
						echoDebug(DBG_ARG, n, argv[n]);
					}

					continue;
				}

				/* process enable-hollow-package-support opt */

				if (strcmp(p,
					"enable-hollow-package-support") == 0) {
					set_depend_pkginfo_DB(B_TRUE);
					continue;
				}

				/* process preinstallcheck option */

				if (strcmp(p, "preinstallcheck") == 0) {
					preinstallCheck = B_TRUE;
					nointeract++;	/* -n */
					suppressCopyright++;	/* -S */
					quitSetSilentExit(B_TRUE);
					continue;
				}

				/* process addzonename option */

				if (strcmp(p, "addzonename") == 0) {
					/*
					 * set zone name to add to messages;
					 * first look in the current environment
					 * and use the default package zone name
					 * if it is set; otherwise, use the name
					 * of the current zone
					 */
					zoneName =
						getenv(PKG_ZONENAME_VARIABLE);

					if ((zoneName == (char *)NULL) ||
							(*zoneName == '\0')) {
						zoneName = z_get_zonename();
					}

					if (zoneName != (char *)NULL) {
						if (*zoneName != '\0') {
							quitSetZoneName(
								zoneName);
						} else {
							zoneName = (char *)NULL;
						}
					}
					continue;
				}

				/* process parent-zone-name option */

				if (strncmp(p, PARENTZONENAME,
						PARENTZONENAME_LEN) == 0) {
					parentZoneName = p+PARENTZONENAME_LEN;
					continue;
				}

				/* process parent-zone-type option */

				if (strncmp(p, PARENTZONETYPE,
						PARENTZONETYPE_LEN) == 0) {
					parentZoneType = p+PARENTZONETYPE_LEN;
					continue;
				}

				if (strncmp(p, PKGSERV_MODE,
				    PKGSERV_MODE_LEN) == 0) {
					pkgserversetmode(pkgparsemode(p +
					    PKGSERV_MODE_LEN));
					continue;
				}

				/* option not recognized - issue warning */

				progerr(ERR_INVALID_O_OPTION, p);
				continue;

			}
			break;

		/*
		 * Different from pkgadd: This is an old non-ABI package
		 */
		case 'o':
			non_abi_scripts++;
			break;

		/*
		 * Different from pkgadd: specify number of parts to package.
		 */
		case 'p':
			dparts = ds_getinfo(optarg);
			break;

		/*
		 * Same as pkgadd: Define the full path name of a
		 * directory to use as the root_path.  All files,
		 * including package system information files, are
		 * relocated to a directory tree starting in the specified
		 * root_path. The root_path may be specified when
		 * installing to a client from a server (for example,
		 * /export/root/client1).
		 */
		case 'R':
			if (!set_inst_root(optarg)) {
				progerr(ERR_ROOT_CMD);
				exit(1);
			}
			break;

		/*
		 * Same as pkgadd: Identify a file or directory which
		 * contains output from a previous pkgask(8)
		 * session. This file supplies the interaction responses
		 * that would be requested by the package in interactive
		 * mode. response must be a full pathname.
		 */
		case 'r':
			respfile = flex_device(optarg, 2);
			break;

		/*
		 * Same as pkgadd: suppress copyright notice being
		 * output during installation.
		 */
		case 'S':
			suppressCopyright++;
			break;

		/*
		 * Same as pkgadd: disable save spool area creation;
		 * do not spool any partial package contents, that is,
		 * suppress the creation and population of the package save
		 * spool area (var/sadm/pkg/PKG/save/pspool/PKG).
		 */
		case 't':
			disable_spool_create();
			break;

		/*
		 * Same as pkgadd: Specify an alternative fs_file to map
		 * the client's file systems.  For example, used in
		 * situations where the $root_path/etc/vfstab file is
		 * non-existent or unreliable. Informs the pkginstall
		 * portion to mount up a client filesystem based upon the
		 * supplied vfstab-like file of stable format.
		 */
		case 'V':
			vfstab_file = flex_device(optarg, 2);
			map_client = 1;
			break;

		/*
		 * Same as pkgadd: Trace all of the scripts that get
		 * executed by pkgadd, located in the pkginst/install
		 * directory. This option is used for debugging the
		 * procedural and non-procedural scripts
		 */
		case 'v':
			pkgverbose++;
			break;

		/*
		 * Different from pkgadd: process this package using
		 * old non-ABI symlinks
		 */
		case 'y':
			set_nonABI_symlinks();
			break;

		/*
		 * Same as pkgadd: perform fresh install from
		 * package save spool area. When set, the package contents
		 * are installed from the package spool save area instead
		 * of from the package root area, so that the original
		 * source packages are not required to install the
		 * package. If the -h option is also specified and the
		 * package is hollow, then this option is ignored. When -z
		 * is specified:
		 *  - Editable files are installed from the package instance
		 *    save area.
		 *  - Volatile files are installed from the package instance
		 *    save area.
		 *  - Executable and data files are installed from the final
		 *    installed location as specified in the pkgmap file.
		 *  - Installation scripts are run from the package spool
		 *    save area.
		 */
		case 'z':
			saveSpoolInstall++;
			break;

		/*
		 * unrecognized option
		 */
		default:
			usage();
			/*NOTREACHED*/
			/*
			 * Although usage() calls a noreturn function,
			 * needed to add return (1);  so that main() would
			 * pass compilation checks. The statement below
			 * should never be executed.
			 */
			return (1);
		}
	}

	/*
	 * ********************************************************************
	 * validate command line options
	 * ********************************************************************
	 */

	/* set "debug echo" flag according to setting of "-O debug" option */

	(void) echoDebugSetFlag(debugFlag);
	(void) log_set_verbose(debugFlag);

	/* output entry debugging information */

	if (z_running_in_global_zone()) {
		echoDebug(DBG_ENTRY_IN_GZ, prog_full_name);
	} else {
		echoDebug(DBG_ENTRY_IN_LZ, prog_full_name, getzoneid(),
		    z_get_zonename());
	}

	if (in_continue_mode() && !in_dryrun_mode()) {
		progerr(ERR_LIVE_CONTINUE_NOT_SUPPORTED);
		usage();
		/*NOTREACHED*/
	}

	/* pkgask requires a response file */

	if (askflag && (respfile == NULL)) {
		usage();
		/*NOTREACHED*/
	}

	/* if device specified, set appropriate device in pkgdev */

	if (device) {
		if (pkgdev.mount) {
			pkgdev.bdevice = device;
		} else {
			pkgdev.cdevice = device;
		}
	}

	/* if file system type specified, must have a device to mount */

	if (pkgdev.fstyp && !pkgdev.mount) {
		progerr(ERR_F_REQUIRES_M);
		usage();
		/*NOTREACHED*/
	}

	/* BEGIN DATA GATHERING PHASE */

	/*
	 * Get the mount table info and store internally.
	 */
	cont_file_read = B_FALSE;
	if (in_continue_mode()) {
		int error;
		cont_file_read = read_continuation(&error);
		if (error == -1) {
			quit(99);
			/*NOTREACHED*/
		}
		if (!in_dryrun_mode()) {
			live_continue = 1;
		}
	}
	/* Read the mount table if not done in continuation mode */
	if (!cont_file_read) {
		if (get_mntinfo(map_client, vfstab_file)) {
			quit(99);
			/*NOTREACHED*/
		}
	}

	/*
	 * This function defines the standard /var/... directories used later
	 * to construct the paths to the various databases.
	 */

	set_PKGpaths(get_inst_root());

	/*
	 * If this is being installed on a client whose /var filesystem is
	 * mounted in some odd way, remap the administrative paths to the
	 * real filesystem. This could be avoided by simply mounting up the
	 * client now; but we aren't yet to the point in the process where
	 * modification of the filesystem is permitted.
	 */
	if (is_an_inst_root()) {
		int fsys_value;

		fsys_value = fsys(get_PKGLOC());
		if (use_srvr_map_n(fsys_value))
			set_PKGLOC(server_map(get_PKGLOC(), fsys_value));

		fsys_value = fsys(get_PKGADM());
		if (use_srvr_map_n(fsys_value))
			set_PKGADM(server_map(get_PKGADM(), fsys_value));
	}

	/*
	 * Initialize pkginfo PKGSAV entry, just in case we dryrun to
	 * somewhere else.
	 */
	set_infoloc(get_PKGLOC());

	/* pull off directory and package name from end of command line */

	switch (argc-optind) {
	case 0:	/* missing directory and package instance */
		progerr(ERR_MISSING_DIR_AND_PKG);
		usage();
		/*NOTREACHED*/
	case 1: /* missing package instance */
		progerr(ERR_MISSING_PKG_INSTANCE);
		usage();
		/*NOTREACHED*/
	case 2:	/* just right! */
		pkgdev.dirname = argv[optind++];
		srcinst = argv[optind++];
		break;
	default:	/* too many args! */
		progerr(ERR_TOO_MANY_CMD_ARGS);
		usage();
		break;
	}

	(void) pkgparam(NULL, NULL);  /* close up prior pkg file if needed */

	/*
	 * Initialize installation admin parameters by reading
	 * the adminfile.
	 */

	if (!askflag && !live_continue) {
		echoDebug(DBG_PKGINSTALL_ADMINFILE, admnfile ? admnfile : "");
		setadminFile(admnfile);
	}

	/*
	 * about to perform first operation that could be modified by the
	 * preinstall check option - if preinstall check is selected (that is,
	 * only gathering dependencies), then output a debug message to
	 * indicate that the check is beginning. Also turn echo() output
	 * off and set various other flags.
	 */

	if (preinstallCheck == B_TRUE) {
		(void) echoSetFlag(B_FALSE);
		echoDebug(DBG_PKGINSTALL_PREINSCHK,
			pkginst ? pkginst : (srcinst ? srcinst : ""),
			zoneName ? zoneName : "global");
		cksetPreinstallCheck(B_TRUE);
		cksetZoneName(zoneName);
		/* inform quit that the install has started */
		quitSetInstallStarted(B_TRUE);
	}

	/*
	 * validate the "rscriptalt" admin file setting
	 * The rscriptalt admin file parameter may be set to either
	 * RSCRIPTALT_ROOT or RSCRIPTALT_NOACCESS:
	 * --> If rscriptalt is not set, or is set to RSCRIPTALT_NOACCESS,
	 * --> or is set to any value OTHER than RSCRIPTALT_ROOT, then
	 * --> assume that the parameter is set to RSCRIPTALT_NOACCESS
	 * If rscriptalt is set to RSCRIPTALT_ROOT, then run request scripts
	 * as the "root" user if user "install" is not defined.
	 * Otherwise, assume rscriptalt is set to RSCRIPTALT_NOACCESS, and run
	 * request scripts as the "alternative" user if user "install" is not
	 * defined, as appropriate for the current setting of the NONABI_SCRIPTS
	 * environment variable.
	 */

	if (ADMSET(RSCRIPTALT)) {
		p = adm.RSCRIPTALT;
		echoDebug(DBG_PKGINSTALL_RSCRIPT_SET_TO, RSCRIPTALT_KEYWORD, p);
		if (strcasecmp(p, RSCRIPTALT_ROOT) == 0) {
			/* rscriptalt=root */
			run_request_as_root = B_TRUE;
		} else if (strcasecmp(p, RSCRIPTALT_NOACCESS) == 0) {
			/* rscriptalt=noaccess */
			run_request_as_root = B_FALSE;
		} else {
			/* rscriptalt=??? */
			logerr(WRN_RSCRIPTALT_BAD, RSCRIPTALT_KEYWORD, p,
				RSCRIPTALT_ROOT, RSCRIPTALT_NOACCESS);
			logerr(WRN_RSCRIPTALT_USING, RSCRIPTALT_KEYWORD,
				RSCRIPTALT_NOACCESS);
			run_request_as_root = B_FALSE;
		}
	} else {
		/* rscriptalt not set - assume rscriptalt=noaccess */
		echoDebug(DBG_PKGINSTALL_RSCRIPT_NOT_SET, RSCRIPTALT_KEYWORD);
		run_request_as_root = B_FALSE;
	}

	echoDebug(DBG_PKGINSTALL_RSCRIPT_IS_ROOT, run_request_as_root);

	/*
	 * hook SIGINT and SIGHUP interrupts into quit.c's trap handler
	 */

	/* hold SIGINT/SIGHUP interrupts */

	(void) sighold(SIGHUP);
	(void) sighold(SIGINT);

	/* connect quit.c:trap() to SIGINT */

	nact.sa_handler = quitGetTrapHandler();
	nact.sa_flags = SA_RESTART;
	(void) sigemptyset(&nact.sa_mask);

	(void) sigaction(SIGINT, &nact, &oact);

	/* connect quit.c:trap() to SIGHUP */

	nact.sa_handler = quitGetTrapHandler();
	nact.sa_flags = SA_RESTART;
	(void) sigemptyset(&nact.sa_mask);

	(void) sigaction(SIGHUP, &nact, &oact);

	/* release hold on signals */

	(void) sigrelse(SIGHUP);
	(void) sigrelse(SIGINT);

	/*
	 * create required /var... directories if they do not exist;
	 * this function will call quit(99) if any required path cannot
	 * be created.
	 */

	ckdirs();

	tzset();

	/*
	 * create path to temporary directory "installXXXXXX" - if TMPDIR
	 * environment variable is set, create the directory in $TMPDIR;
	 * otherwise, create the directory in P_tmpdir.
	 */

	pt = getenv("TMPDIR");
	(void) snprintf(tmpdir, sizeof (tmpdir), "%s/installXXXXXX",
		((pt != (char *)NULL) && (*pt != '\0')) ? pt : P_tmpdir);

	echoDebug(DBG_PKGINSTALL_TMPDIR, tmpdir);

	if ((mktemp(tmpdir) == NULL) || mkdir(tmpdir, 0771)) {
		progerr(ERR_MKDIR, tmpdir);
		quit(99);
		/*NOTREACHED*/
	}

	/*
	 * if the package device is a file containing a package stream,
	 * unpack the stream into a temporary directory
	 */

	if ((isdir(pkgdev.dirname) != 0) &&
		(pkgdev.cdevice == (char *)NULL) &&
		(pkgdev.bdevice == (char *)NULL) &&
		(isfile((char *)NULL, pkgdev.dirname) == 0)) {

		char		*idsName = (char *)NULL;
		char		*pkgnames[2];
		char		*device = pkgdev.dirname;
		boolean_t	b;

		echoDebug(DBG_PKGINSTALL_DS_ISFILE, pkgdev.dirname);

		/*
		 * validate the package source device - return pkgdev info that
		 * describes the package source device.
		 */

		if (devtype(device, &pkgdev)) {
			progerr(ERR_BAD_DEVICE, device);
			quit(99);
			/* NOTREACHED */
		}

		/* generate the list of packages to verify */

		pkgnames[0] = srcinst;
		pkgnames[1] = (char *)NULL;

		b = open_package_datastream(1, pkgnames, (char *)NULL,
			pkgdev.dirname, (int *)NULL, &idsName, tmpdir, &pkgdev,
			1);

		if (b == B_FALSE) {
			progerr(ERR_CANNOT_OPEN_PKG_STREAM,
				pkgdev.dirname ? pkgdev.dirname : "?");
			quit(99);
			/*NOTREACHED*/
		}

		/* make sure temporary directory is removed on exit */

		quitSetDstreamTmpdir(pkgdev.dirname);

		/* unpack the package instance from the data stream */

		b = unpack_package_from_stream(idsName, srcinst,
							pkgdev.dirname);
		if (b == B_FALSE) {
			progerr(ERR_CANNOT_UNPACK_PKGSTRM,
				srcinst ? srcinst : "?",
				idsName ? idsName : "?",
				pkgdev.dirname ? pkgdev.dirname : "?");
			quit(99);
			/*NOTREACHED*/
		}

		/* close the datastream - no longer needed */

		echoDebug(DBG_CLOSING_STREAM, idsName, pkgdev.dirname);
		(void) ds_close(1);
	}

	if (snprintf(instdir, PATH_MAX, "%s/%s", pkgdev.dirname, srcinst)
	    >= PATH_MAX) {
		progerr(ERR_SNPRINTF, instdir);
		quit(99);
		/*NOTREACHED*/
	}

	zoneName = getenv(PKG_ZONENAME_VARIABLE);

	/*
	 * If the environment has a CLIENT_BASEDIR, that takes precedence
	 * over anything we will construct. We need to save it here because
	 * in three lines, the current environment goes away.
	 */
	(void) set_env_cbdir();	/* copy over environ */

	getuserlocale();

	/*
	 * current environment has been read; clear environment out
	 * so putparam() can be used to populate the new environment
	 * to be passed to any executables/scripts.
	 */

	environ = NULL;

	/* write parent condition information to environment */

	putConditionInfo(parentZoneName, parentZoneType);

	putuserlocale();

	if (init_install) {
		putparam("PKG_INIT_INSTALL", "TRUE");
	}

	if (is_an_inst_root()) {
		export_client_env(get_inst_root());
	}

	if (zoneName != (char *)NULL) {
		putparam(PKG_ZONENAME_VARIABLE, zoneName);
	}

	putparam("INST_DATADIR", pkgdev.dirname);

	if (non_abi_scripts) {
		putparam("NONABI_SCRIPTS", "TRUE");
	}

	if (nonABI_symlinks()) {
		putparam("PKG_NONABI_SYMLINKS", "TRUE");
	}

	if (get_ABI_namelngth()) {
		putparam("PKG_ABI_NAMELENGTH", "TRUE");
	}

	/* establish path and oambase */

	if (cmdbin[0] == '\0') {
		(void) strlcpy(cmdbin, PKGBIN, sizeof (cmdbin));
	}

	(void) snprintf(path, sizeof (path), "%s:%s", DEFPATH, cmdbin);

	putparam("PATH", path);

	putparam("OAMBASE", OAMBASE);

	(void) snprintf(p_pkginfo, sizeof (p_pkginfo),
			"%s/%s", instdir, PKGINFO);
	(void) snprintf(p_pkgmap, sizeof (p_pkgmap),
			"%s/%s", instdir, PKGMAP);

	/* Read the environment (from pkginfo or '-e') ... */
	abi_nm_ptr = getenv("PKG_ABI_NAMELENGTH");

	/* Disable the 32 char name limit extension */
	if (abi_nm_ptr && strncasecmp(abi_nm_ptr, "TRUE", 4) == 0) {
		(void) set_ABI_namelngth();
	}

	/*
	 * This tests the pkginfo and pkgmap files for validity and
	 * puts all delivered pkginfo variables (except for PATH) into
	 * our environment. This is where a delivered pkginfo BASEDIR
	 * would come from. See set_basedirs() below.
	 */

	if (pkgenv(srcinst, p_pkginfo, p_pkgmap)) {
		quit(1);
		/*NOTREACHED*/
	}

	echo("\n%s(%s) %s", pkgname, pkgarch, pkgvers);

	/*
	 * If this script was invoked by 'pkgask', just
	 * execute request script and quit (do_pkgask()).
	 */

	if (askflag) {
		do_pkgask(run_request_as_root);
	}

	/* validate package contents file */

	if (vcfile() == 0) {
		quit(99);
	}

	/* if not in dryrun mode aquire packaging lock */

	if (!in_dryrun_mode()) {
		/* acquire the package lock - at install initialization */
		if (!lockinst(get_prog_name(), srcinst, "install-initial")) {
			quit(99);
			/*NOTREACHED*/
		}
	}

	/*
	 * Now do all the various setups based on ABI compliance
	 */

	/* Read the environment (from pkginfo or '-o') ... */
	abi_comp_ptr = getenv("NONABI_SCRIPTS");

	/* Read the environment (from pkginfo or '-y') ... */
	abi_sym_ptr = getenv("PKG_NONABI_SYMLINKS");

	/* bug id 4244631, not ABI compliant */
	if (abi_comp_ptr && strncasecmp(abi_comp_ptr, "TRUE", 4) == 0) {
		script_in = PROC_XSTDIN;
		non_abi_scripts = 1;
	}

	/* Set symlinks to be processed the old way */
	if (abi_sym_ptr && strncasecmp(abi_sym_ptr, "TRUE", 4) == 0) {
		set_nonABI_symlinks();
	}

	/*
	 * At this point, script_in, non_abi_scripts & the environment are
	 * all set correctly for the ABI status of the package.
	 */

	if (pt = getenv("MAXINST")) {
		maxinst = atol(pt);
	}

	/*
	 * See if were are installing a package that only wants to update
	 * the database or only install files associated with CAS's. We
	 * only check the PKG_HOLLOW_VARIABLE variable if told to do so by
	 * the caller.
	 */

	if (is_depend_pkginfo_DB()) {
		pt = getenv(PKG_HOLLOW_VARIABLE);
		if ((pt != NULL) && (strncasecmp(pt, "true", 4) == 0)) {
			echoDebug(DBG_PKGREMOVE_HOLLOW_ENABLED);
			if (disableAttributes) {
				disable_attribute_check();
			}

			/*
			 * this is a hollow package and hollow package support
			 * is enabled -- override admin settings to suppress
			 * checks that do not make sense since no scripts will
			 * be executed and no files will be installed.
			 */

			setadminSetting("conflict", "nocheck");
			setadminSetting("setuid", "nocheck");
			setadminSetting("action", "nocheck");
			setadminSetting("partial", "nocheck");
			setadminSetting("space", "nocheck");
			setadminSetting("authentication", "nocheck");
		} else {
			echoDebug(DBG_PKGREMOVE_HOLLOW_DISABLED);
			set_depend_pkginfo_DB(B_FALSE);
		}
	}

	/*
	 * if performing a fresh install to a non-global zone, and doing
	 * more than just updating the package database (that is, the
	 * package to install is NOT "hollow"), then set the global flag
	 * that directs installation is from partially spooled packages
	 * (that is, packages installed in the global zone).
	 */

	if (saveSpoolInstall && (!is_depend_pkginfo_DB())) {
		set_partial_inst();
	} else {
		saveSpoolInstall = 0;
	}

	/*
	 * verify that we are not trying to install an
	 * INTONLY package with no interaction
	 */

	if (pt = getenv("INTONLY")) {
		if (askflag || nointeract) {
			progerr(ERR_INTONLY, pkgabrv ? pkgabrv : "?");
			quit(1);
			/*NOTREACHED*/
		}
	}

	if (!suppressCopyright && !pkgdev.cdevice) {
		copyright();
	}

	/*
	 * inspect the system to determine if any instances of the
	 * package being installed already exist on the system
	 */

	prvinfo = (struct pkginfo *)calloc(MALSIZ, sizeof (struct pkginfo));
	if (prvinfo == NULL) {
		progerr(ERR_MEMORY, errno);
		quit(99);
		/*NOTREACHED*/
	}

	for (;;) {
		if (pkginfo(&prvinfo[npkgs], pkgwild, NULL, NULL)) {
			if ((errno == ESRCH) || (errno == ENOENT)) {
				break;
			}
			progerr(ERR_SYSINFO, errno);
			quit(99);
			/*NOTREACHED*/
		}
		if ((++npkgs % MALSIZ) == 0) {
			prvinfo = (struct pkginfo *)realloc(prvinfo,
				(npkgs+MALSIZ) * sizeof (struct pkginfo));
			if (prvinfo == NULL) {
				progerr(ERR_MEMORY, errno);
				quit(99);
				/*NOTREACHED*/
			}
		}
	}

	/*
	 * Determine the correct package instance based on how many packages are
	 * already installed. If there are none (npkgs == 0), getinst() just
	 * returns the package abbreviation. Otherwise, getinst() interacts with
	 * the user (or reads the admin file) to determine if an instance which
	 * is already installed should be overwritten, or possibly install a new
	 * instance of this package
	 */

	pkginst = getinst(&update, prvinfo, npkgs, preinstallCheck);

	/* set "update flag" if updating an existing instance of this package */

	if (update) {
		setUpdate();
	}

	/*
	 * Some pkgs (SUNWcsr) already spooled to the zone, check the
	 * value of UPDATE in their postinstall script.  After a pkg
	 * has been patched UPDATE exists statically in the pkginfo
	 * file and this value must be reset when installing a zone.
	 */

	if (saveSpoolInstall != 0 && !isUpdate()) {
		putparam("UPDATE", "");
	}

	/* inform quit() if updating existing or installing new instance */

	quitSetUpdatingExisting(update ? B_TRUE : B_FALSE);

	if (respfile) {
		(void) set_respfile(respfile, pkginst, RESP_RO);
	}

	(void) snprintf(pkgloc, sizeof (pkgloc),
			"%s/%s", get_PKGLOC(), pkginst);

	(void) snprintf(pkgbin, sizeof (pkgbin),
			"%s/install", pkgloc);

	(void) snprintf(pkgsav, sizeof (pkgsav),
			"%s/save", pkgloc);

	if (snprintf(saveSpoolInstallDir, PATH_MAX, "%s/pspool/%s", pkgsav,
			pkginst) < 0) {
		progerr(ERR_SNPRINTF, saveSpoolInstallDir);
		quit(99);
		/*NOTREACHED*/
	}

	(void) snprintf(ilockfile, sizeof (ilockfile),
			"%s/!I-Lock!", pkgloc);
	(void) snprintf(rlockfile, sizeof (rlockfile),
			"%s/!R-Lock!", pkgloc);
	(void) snprintf(savlog, sizeof (savlog),
			"%s/logs/%s", get_PKGADM(), pkginst);

	putparam("PKGINST", pkginst);
	putparam("PKGSAV", pkgsav);

	/*
	 * Be sure request script has access to PKG_INSTALL_ROOT if there is
	 * one
	 */

	put_path_params();

	if (!map_client) {
		putparam("PKG_NO_UNIFIED", "TRUE");
	}

	/*
	 * This maps the client filesystems into the server's space.
	 */

	if (map_client && !mount_client()) {
		logerr(MSG_MANMOUNT);
	}

	/*
	 * If this is an UPDATE then either this is exactly the same version
	 * and architecture of an installed package or a different package is
	 * intended to entirely replace an installed package of the same name
	 * with a different VERSION or ARCH string.
	 * Don't merge any databases if only gathering dependencies.
	 */

	if ((preinstallCheck == B_FALSE) && (update)) {
		/*
		 * If this version and architecture is already installed,
		 * merge the installed and installing parameters and inform
		 * all procedure scripts by defining UPDATE in the
		 * environment.
		 */

		if (is_samepkg()) {
			/*
			 * If it's the same ARCH and VERSION, then a merge
			 * and copy operation is necessary.
			 */

			if (n = merg_pkginfos(pclass, &mergd_pclass)) {
				quit(n);
				/*NOTREACHED*/
			}

			if (n = cp_pkgdirs()) {
				quit(n);
				/*NOTREACHED*/
			}

		} else {
			/*
			 * If it's a different ARCH and/or VERSION then this
			 * is an "instance=overwrite" situation. The
			 * installed base needs to be confirmed and the
			 * package directories renamed.
			 */

			if (n = ck_instbase()) {
				quit(n);
				/*NOTREACHED*/
			}

			if (n = mv_pkgdirs()) {
				quit(n);
				/*NOTREACHED*/
			}
		}

		putparam("UPDATE", "yes");

	}

	if (in_dryrun_mode()) {
		set_dryrun_dir_loc();
	}

	if (preinstallCheck == B_FALSE) {
		/*
		 * Determine if the package has been partially installed on or
		 * removed from this system.
		 */
		ck_w_dryrun(ckpartial, PARTIAL);

		/*
		 * make sure current runlevel is appropriate
		 */
		ck_w_dryrun(ckrunlevel, RUNLEVEL);
	} else {
		int	r;

		/*
		 * Just gathering dependencies - determine if the package has
		 * been partially installed on or removed from this system and
		 * output information to stdout
		 */
		r = ckpartial();
		(void) fprintf(stdout, "ckpartialinstall=%d\n", r == 8 ? 1 : 0);
		(void) fprintf(stdout, "ckpartialremove=%d\n", r == 9 ? 1 : 0);

		/*
		 * make sure current runlevel is appropriate
		 */
		r = ckrunlevel();
		(void) fprintf(stdout, "ckrunlevel=%d\n", r);
	}

	if (pkgdev.cdevice) {
		/* get first volume which contains info files */
		unpack();
		if (!suppressCopyright) {
			copyright();
		}
	}

	/* update the lock - at the request script */

	lockupd("request");

	/*
	 * If no response file has been provided, initialize response file by
	 * executing any request script provided by this package. Initialize
	 * the response file if not gathering dependencies only.
	 */

	if ((!rdonly_respfile()) && (preinstallCheck == B_FALSE)) {
		(void) snprintf(path, sizeof (path),
			"%s/%s", instdir, REQUEST_FILE);
		n = reqexec(update, path, non_abi_scripts,
			run_request_as_root);
		if (in_dryrun_mode()) {
			set_dr_info(REQUESTEXITCODE, n);
		}

		ckreturn(n, ERR_REQUEST);
	}

	/*
	 * Look for all parameters in response file which begin with a
	 * capital letter, and place them in the environment.
	 */

	if ((is_a_respfile()) && (preinstallCheck == B_FALSE)) {
		if (n = merg_respfile()) {
			quit(n);
			/*NOTREACHED*/
		}
	}

	/*
	 * Run a checkinstall script if one is provided by the package.
	 * Don't execute checkinstall script if we are only updating the DB.
	 * Don't execute checkinstall script if only gathering dependencies.
	 */

	/* update the lock - at the checkinstall script */
	lockupd("checkinstall");

	/* Execute checkinstall script if one is provided. */
	(void) snprintf(script, sizeof (script), "%s/install/checkinstall",
			instdir);
	if (access(script, F_OK) != 0) {
		/* no script present */
		echoDebug(DBG_PKGINSTALL_COC_NONE, pkginst, script,
			zoneName ? zoneName : "global");
	} else if (is_depend_pkginfo_DB()) {
		/* updating db only: skip checkinstall script */
		echoDebug(DBG_PKGINSTALL_COC_DBUPD, pkginst, script,
			zoneName ? zoneName : "global");
	} else if (preinstallCheck == B_TRUE) {
		/* only gathering dependencies: skip checkinstall script */
		echoDebug(DBG_PKGINSTALL_COC_NODEL, pkginst, script,
			zoneName ? zoneName : "global");
	} else {
		/* script present and ok to run: run the script */
		if (zoneName == (char *)NULL) {
			echo(MSG_PKGINSTALL_EXECOC_GZ);
			echoDebug(DBG_PKGINSTALL_EXECOC_GZ, pkginst, script);
		} else {
			echo(MSG_PKGINSTALL_EXECOC_LZ, zoneName);
			echoDebug(DBG_PKGINSTALL_EXECOC_LZ, pkginst, script,
				zoneName);
		}
		n = chkexec(update, script);
		if (in_dryrun_mode()) {
			set_dr_info(CHECKEXITCODE, n);
		}

		if (n == 3) {
			echo(WRN_CHKINSTALL);
			ckreturn(4, NULL);
		} else if (n == 7) {
			/* access returned error */
			progerr(ERR_CHKINSTALL_NOSCRIPT, script);
			ckreturn(4, ERR_CHKINSTALL);
		} else {
			ckreturn(n, ERR_CHKINSTALL);
		}
	}

	/*
	 * Now that the internal data structures are initialized, we can
	 * initialize the dryrun files (which may be the same files).
	 */

	if (pkgdrtarg) {
		init_dryrunfile(pkgdrtarg);
	}

	/*
	 * Look for all parameters in response file which begin with a
	 * capital letter, and place them in the environment.
	 */
	if (is_a_respfile()) {
		if (n = merg_respfile()) {
			quit(n);
			/*NOTREACHED*/
		}
	}

	/* update the lock - doing analysis */

	lockupd("analysis");

	/*
	 * Determine package base directory and client base directory
	 * if appropriate. Then encapsulate them for future retrieval.
	 */
	if ((err = set_basedirs(isreloc(instdir), adm.basedir, pkginst,
		nointeract)) != 0) {
		quit(err);
		/*NOTREACHED*/
	}

	/*
	 * Create the base directory if specified.
	 * Don't create if we are only updating the DB.
	 * Don't create if only gathering dependencies.
	 */

	if (!is_depend_pkginfo_DB() &&
		!preinstallCheck && is_a_basedir()) {
		mkbasedir(!nointeract, get_basedir());
		echo(MSG_BASE_USED, get_basedir());
	}

	/*
	 * Store PKG_INSTALL_ROOT, BASEDIR & CLIENT_BASEDIR in our
	 * environment for later use by procedure scripts.
	 */
	put_path_params();

	/*
	 * the following two checks are done in the corresponding
	 * ck() routine, but are repeated here to avoid re-processing
	 * the database if we are administered to not include these
	 * processes
	 */
	if (ADM(setuid, "nochange")) {
		nosetuid++;	/* Clear setuid/gid bits. */
	}

	if (ADM(conflict, "nochange")) {
		nocnflct++;	/* Don't install conflicting files. */
	}

	/*
	 * Get the filesystem space information for the filesystem on which
	 * the "contents" file resides.
	 */

	svfsb.f_bsize = 8192;
	svfsb.f_frsize = 1024;

	if (statvfs64(get_PKGADM(), &svfsb) == -1) {
		int	lerrno = errno;
		if (!access(get_PKGADM(), F_OK)) {
			progerr(ERR_PKGINSTALL_STATVFS, get_PKGADM(),
				strerror(errno));
			logerr("(errno %d)", lerrno);
			quit(99);
			/*NOTREACHED*/
		}
	}

	/*
	 * Get the number of blocks used by the pkgmap, ocfile()
	 * needs this to properly determine its space requirements.
	 */

	if (stat(p_pkgmap, &statb) == -1) {
		progerr(ERR_PKGINSTALL_STATOF, p_pkgmap, strerror(errno));
		quit(99);
		/*NOTREACHED*/
	}

	pkgmap_blks = nblk(statb.st_size, svfsb.f_bsize, svfsb.f_frsize);

	/*
	 * Merge information in memory with the "contents" file; this creates
	 * a temporary version of the "contents" file. Note that in dryrun
	 * mode, we still need to record the contents file data somewhere,
	 * but we do it in the dryrun directory.
	 */

	if (in_dryrun_mode()) {
		if (n = set_cfdir(pkgdrtarg)) {
			quit(n);
			/*NOTREACHED*/
		}
	} else {
		if (n = set_cfdir(NULL)) {
			quit(n);
			/*NOTREACHED*/
		}
	}
	if (!ocfile(&pkgserver, &cfTmpVfp, pkgmap_blks)) {
		quit(99);
		/*NOTREACHED*/
	}

	/*
	 * if cpio is being used,  tell pkgdbmerg since attributes will
	 * have to be check and repaired on all file and directories
	 */
	for (np = cpio_names; *np != NULL; np++) {
		(void) snprintf(path, sizeof (path),
			"%s/%s", instdir, *np);
		if (iscpio(path, &is_comp_arch)) {
			is_WOS_arch();
			break;
		}
	}

	/* Establish the class list and the class attributes. */
	cl_sets(getenv("CLASSES"));
	find_CAS(I_ONLY, pkgbin, instdir);

	if (vfpOpen(&pkgmapVfp, p_pkgmap, "r", VFP_NEEDNOW) != 0) {
		progerr(ERR_PKGMAP, p_pkgmap);
		quit(99);
		/*NOTREACHED*/
	}

	/*
	 * This modifies the path list entries in memory to reflect
	 * how they should look after the merg is complete
	 */

	nparts = sortmap(&extlist, pkgmapVfp, pkgserver, cfTmpVfp, zoneName);

	if ((n = files_installed()) > 0) {
		if (n > 1) {
			echo(MSG_INST_MANY, n);
		} else {
			echo(MSG_INST_ONE, n);
		}
	}

	/*
	 * Check ulimit requirement (provided in pkginfo). The purpose of
	 * this limit is to terminate pathological file growth resulting from
	 * file edits in scripts. It does not apply to files in the pkgmap
	 * and it does not apply to any database files manipulated by the
	 * installation service.
	 */
	if (pt = getenv("ULIMIT")) {
		if (assign_ulimit(pt) == -1) {
			progerr(ERR_BADULIMIT, pt);
			quit(99);
			/*NOTREACHED*/
		}
		putparam("PKG_ULIMIT", "TRUE");
	}

	/*
	 * If only gathering dependencies, check and output status of all
	 * remaining dependencies and exit.
	 */

	if (preinstallCheck == B_TRUE) {
		/* update the lock file - final checking */

		lockupd("preinstallcheck");

		/* verify package information files are not corrupt */

		(void) fprintf(stdout, "ckpkgfiles=%d\n", ckpkgfiles());

		/* verify package dependencies */

		(void) fprintf(stdout, "ckdepend=%d\n", ckdepend());

		/* Check space requirements */

		(void) fprintf(stdout, "ckspace=%d\n", ckspace());

		/*
		 * Determine if any objects provided by this package conflict
		 * with the files of previously installed packages.
		 */

		(void) fprintf(stdout, "ckconflict=%d\n", ckconflct());

		/*
		 * Determine if any objects provided by this package will be
		 * installed with setuid or setgid enabled.
		 */

		(void) fprintf(stdout, "cksetuid=%d\n", cksetuid());

		/*
		 * Determine if any packaging scripts provided with this package
		 * will execute as a priviledged user.
		 */

		(void) fprintf(stdout, "ckpriv=%d\n", ckpriv());

		/* Verify neccessary package installation directories exist */

		(void) fprintf(stdout, "ckpkgdirs=%d\n", ckpkgdirs());

		/*
		 * ****** preinstall check done - exit ******
		 */

		echoDebug(DBG_PKGINSTALL_PREINSCHK_OK);
		quit(0);
		/*NOTREACHED*/
	}

	/*
	 * Not gathering dependencies only, proceed to check dependencies
	 * and continue with the package installation operation.
	 */

	/*
	 * verify package information files are not corrupt
	 */
	ck_w_dryrun(ckpkgfiles, PKGFILES);

	/*
	 * verify package dependencies
	 */
	ck_w_dryrun(ckdepend, DEPEND);

	/*
	 * Check space requirements.
	 */
	ck_w_dryrun(ckspace, SPACE);

	/*
	 * Determine if any objects provided by this package conflict with
	 * the files of previously installed packages.
	 */
	ck_w_dryrun(ckconflct, CONFLICT);

	/*
	 * Determine if any objects provided by this package will be
	 * installed with setuid or setgid enabled.
	 */
	ck_w_dryrun(cksetuid, SETUID);

	/*
	 * Determine if any packaging scripts provided with this package will
	 * execute as a priviledged user.
	 */
	ck_w_dryrun(ckpriv, PRIV);

	/*
	 * Verify neccessary package installation directories exist.
	 */
	ck_w_dryrun(ckpkgdirs, PKGDIRS);

	/*
	 * If we have assumed that we were installing setuid or conflicting
	 * files, and the user chose to do otherwise, we need to read in the
	 * package map again and re-merg with the "contents" file
	 */

	if (rprcflag) {
		nparts = sortmap(&extlist, pkgmapVfp, pkgserver,
				cfTmpVfp, zoneName);
	}

	(void) vfpClose(&pkgmapVfp);

	/* BEGIN INSTALLATION PHASE */
	if (in_dryrun_mode()) {
		echo(MSG_PKGINSTALL_DRYRUN, pkgname, pkginst);
	} else if (zoneName == (char *)NULL) {
		echo(MSG_PKGINSTALL_INSIN_GZ, pkgname, pkginst);
	} else {
		echo(MSG_PKGINSTALL_INSIN_LZ, pkgname, pkginst, zoneName);
	}

	/* inform quit that the install has started */

	quitSetInstallStarted(B_TRUE);

	/*
	 * This replaces the contents file with recently created temp version
	 * which contains information about the objects being installed.
	 * Under old lock protocol it closes both files and releases the
	 * locks. Beginning in Solaris 2.7, this lock method should be
	 * reviewed.
	 */

	n = swapcfile(pkgserver, &cfTmpVfp, pkginst, dbchg);
	if (n == RESULT_WRN) {
		warnflag++;
	} else if (n == RESULT_ERR) {
		quit(99);
		/*NOTREACHED*/
	}

	/*
	 * Create install-specific lockfile to indicate start of
	 * installation. This is really just an information file. If the
	 * process dies, the initial lockfile (from lockinst(), is
	 * relinquished by the kernel, but this one remains in support of the
	 * post-mortem.
	 */

	if (access(ilockfile, F_OK) == 0) {
		(void) remove(ilockfile);
	}

	if (open(ilockfile, O_WRONLY|O_CREAT|O_TRUNC|O_EXCL, 0644) < 0) {
		progerr(ERR_LOCKFILE, ilockfile);
		quit(99);
		/*NOTREACHED*/
	}

	(void) time(&clock);

	/*
	 * We do not want the time in locale in the pkginfo.
	 * save the LC_TIME and set it to C. Reset it with saved one
	 * after cftime().
	 */
	temp = setlocale(LC_TIME, NULL);
	(void) setlocale(LC_TIME, "C");

	/* LINTED warning: do not use cftime(); ... */
	(void) cftime(cbuf, "%b %d \045Y \045H:\045M", &clock);
	putparam("INSTDATE", qstrdup(cbuf));
	(void) setlocale(LC_TIME, temp);

	/*
	 * Store information about package being installed;
	 * modify installation parameters as neccessary and
	 * copy contents of 'install' directory into $pkgloc
	 */
	merginfo(mergd_pclass, saveSpoolInstall);

	/* If this was just a dryrun, then quit() will write out that file. */
	if (in_dryrun_mode()) {
		quit(0);
		/*NOTREACHED*/
	}

	/*
	 * Execute preinstall script, if one was provided with the
	 * package. We check the package to avoid running an old
	 * preinstall script if one was provided with a prior instance.
	 * Don't execute preinstall script if we are only updating the DB.
	 */

	/* update the lock - at the preinstall altscript */
	lockupd("preinstall");

	/* preinstall script in the media (package source) */
	(void) snprintf(altscript, sizeof (altscript), "%s/install/preinstall",
			instdir);

	/* preinstall script in the pkgbin instead of media */
	(void) snprintf(script, sizeof (script), "%s/preinstall", pkgbin);

	if (access(altscript, F_OK) != 0) {
		/* no script present */
		echoDebug(DBG_PKGINSTALL_POCALT_NONE, pkginst, altscript,
			zoneName ? zoneName : "global");
	} else if (access(script, F_OK) != 0) {
		/* no script present */
		echoDebug(DBG_PKGINSTALL_POC_NONE, pkginst, script,
			zoneName ? zoneName : "global");
	} else if (is_depend_pkginfo_DB()) {
		/* updating db only: skip preinstall script */
		echoDebug(DBG_PKGINSTALL_POC_DBUPD, pkginst, script,
			zoneName ? zoneName : "global");
	} else {
		/* script present and ok to run: run the script */
		assert(preinstallCheck == B_FALSE);

		set_ulimit("preinstall", ERR_PREINSTALL);
		if (zoneName == (char *)NULL) {
			echo(MSG_PKGINSTALL_EXEPOC_GZ);
			echoDebug(DBG_PKGINSTALL_EXEPOC_GZ, pkginst, script);
		} else {
			echo(MSG_PKGINSTALL_EXEPOC_LZ, zoneName);
			echoDebug(DBG_PKGINSTALL_EXEPOC_LZ, pkginst, script,
				zoneName);
		}
		putparam("PKG_PROC_script", "preinstall");
		if (pkgverbose) {
			ckreturn(pkgexecl(script_in, PROC_STDOUT,
				PROC_USER, PROC_GRP, SHELL, "-x",
				script, NULL), ERR_PREINSTALL);
		} else {
			ckreturn(pkgexecl(script_in, PROC_STDOUT,
				PROC_USER, PROC_GRP, SHELL, script,
				NULL), ERR_PREINSTALL);
		}

		clr_ulimit();
		(void) remove(script);	/* no longer needed. */
	}

	/*
	 * Check delivered package for a postinstall script while
	 * we're still on volume 1.
	 */

	(void) snprintf(script, sizeof (script),
			"%s/install/postinstall", instdir);
	if (access(script, F_OK) == 0) {
		(void) snprintf(script, sizeof (script),
					"%s/postinstall", pkgbin);
	} else {
		script[0] = '\0';
	}

	/* update the lock - at the install phase */

	lockupd("install");

	/*
	 * install package one part (volume) at a time
	 */

	part = 1;
	while (part <= nparts) {
		if ((part > 1) && pkgdev.cdevice) {
			unpack();
		}

		instvol(extlist, srcinst, part, nparts,
			pkgserver, &cfTmpVfp, &updated, zoneName);

		if (part++ >= nparts) {
			break;
		}
	}

	z_destroyMountTable();

	/*
	 * Now that all install class action scripts have been used, we
	 * delete them from the package directory.
	 */
	rm_icas(pkgbin);

	if (globalZoneOnly) {
		boolean_t   b;
		b = pkgAddPackageToGzonlyList(pkginst, get_inst_root());
		if (b == B_FALSE) {
			progerr(ERR_PKGINSTALL_GZONLY_ADD, pkginst);
			ckreturn(1, NULL);
		}
	}

	/*
	 * Execute postinstall script, if any
	 * Don't execute postinstall script if we are only updating the DB.
	 */

	echoDebug(DBG_PKGINSTALL_INSDONE, is_depend_pkginfo_DB(),
		is_depend_pkginfo_DB(), saveSpoolInstall,
		updated ? updated : "",
		script ? script : "",
		script ? access(script, F_OK) : -1);

	/* update the lock - at the postinstall script */
	lockupd("postinstall");

	if ((script == (char *)NULL) || (*script == '\0')) {
		echoDebug(DBG_PKGINSTALL_POIS_NOPATH, pkginst,
			zoneName ? zoneName : "global");
	} else if (access(script, F_OK) != 0) {
		echoDebug(DBG_PKGINSTALL_POIS_NONE, pkginst, script,
			zoneName ? zoneName : "global");
	} else if (is_depend_pkginfo_DB()) {
		echoDebug(DBG_PKGINSTALL_POIS_DBUPD, pkginst, script,
			zoneName ? zoneName : "global");
	} else if ((saveSpoolInstall != 0) && (updated == (char *)NULL)) {
		/*
		 * fresh installing into non-global zone, no object was
		 * updated (installed/verified in area), so do not run
		 * the postinstall script.
		 */
		echoDebug(DBG_PKGINSTALL_POIS_NOUPDATING,
			zoneName ? zoneName : "global", pkginst, script);
	} else {
		/* script present and ok to run: run the script */
		set_ulimit("postinstall", ERR_POSTINSTALL);
		if (zoneName == (char *)NULL) {
			echo(MSG_PKGINSTALL_EXEPIC_GZ);
			echoDebug(DBG_PKGINSTALL_EXEPIC_GZ, pkginst, script);
		} else {
			echo(MSG_PKGINSTALL_EXEPIC_LZ, zoneName);
			echoDebug(DBG_PKGINSTALL_EXEPIC_LZ, pkginst, script,
				zoneName);
		}
		putparam("PKG_PROC_SCRIPT", "postinstall");
		putparam("TMPDIR", tmpdir);
		if (pkgverbose) {
			ckreturn(pkgexecl(script_in, PROC_STDOUT,
				PROC_USER, PROC_GRP, SHELL, "-x",
				script, NULL), ERR_POSTINSTALL);
		} else {
			ckreturn(pkgexecl(script_in, PROC_STDOUT,
				PROC_USER, PROC_GRP, SHELL, script,
				NULL), ERR_POSTINSTALL);
		}

		clr_ulimit();
		(void) remove(script);	/* no longer needed */
	}

	if (!warnflag && !failflag) {
		(void) remove(rlockfile);
		(void) remove(ilockfile);
		(void) remove(savlog);
	}

	/* release the generic package lock */

	(void) unlockinst();

	pkgcloseserver(pkgserver);

	quit(0);
	/* LINTED: no return */
}

/*
 * This function merges the environment data in the response file with the
 * current environment.
 */
static int
merg_respfile()
{
	int retcode = 0;
	char *resppath = get_respfile();
	char *locbasedir;
	char param[MAX_PKG_PARAM_LENGTH], *value;
	FILE *fp;

	if ((fp = fopen(resppath, "r")) == NULL) {
		progerr(ERR_RESPONSE, resppath);
		return (99);
	}

	param[0] = '\0';

	while (value = fpkgparam(fp, param)) {
		if (!isupper(param[0])) {
			param[0] = '\0';
			continue;
		}

		if (rdonly(param)) {
			progerr(ERR_RDONLY, param);
			param[0] = '\0';
			continue;
		}

		/*
		 * If this is an update, and the response file
		 * specifies the BASEDIR, make sure it matches the
		 * existing installation base. If it doesn't, we have
		 * to quit.
		 */
		if (update && strcmp("BASEDIR", param) == 0) {
			locbasedir = getenv("BASEDIR");
			if (locbasedir && strcmp(value, locbasedir) != 0) {
				char *dotptr;
				/* Get srcinst down to a name. */
				if (dotptr = strchr(srcinst, '.'))
					*dotptr = '\000';
				progerr(ERR_NEWBD, srcinst,
					locbasedir, value);
				retcode = 99;
			}
		}

		putparam(param, value);
		param[0] = '\0';
	}
	(void) fclose(fp);

	return (retcode);
}

/*
 * This scans the installed pkginfo file for the current BASEDIR. If this
 * BASEDIR is different from the current BASEDIR, there will definitely be
 * problems.
 */
static int
ck_instbase(void)
{
	int retcode = 0;
	char param[MAX_PKG_PARAM_LENGTH], *value;
	char pkginfo_path[PATH_MAX];
	FILE *fp;

	/* Open the old pkginfo file. */
	(void) snprintf(pkginfo_path, sizeof (pkginfo_path),
			"%s/%s", pkgloc, PKGINFO);
	if ((fp = fopen(pkginfo_path, "r")) == NULL) {
		progerr(ERR_PKGINFO, pkginfo_path);
		return (99);
	}

	param[0] = '\000';

	while (value = fpkgparam(fp, param)) {
		if (strcmp("BASEDIR", param) == 0) {
			if (adm.basedir && *(adm.basedir) &&
				strchr("/$", *(adm.basedir))) {
				char *dotptr;

				/*
				 * Get srcinst down to a name.
				 */
				if (dotptr = strchr(srcinst, '.'))
					*dotptr = '\000';
				if (strcmp(value,
					adm.basedir) != 0) {
					progerr(ERR_ADMBD, srcinst,
						value, adm.basedir);
					retcode = 4;
					break;
				}
			} else if (ADM(basedir, "ask"))
				/*
				 * If it's going to ask later, let it know
				 * that it *must* agree with the BASEDIR we
				 * just picked up.
				 */
				adm.basedir = "update";

			putparam(param, value);
			break;
		}

		param[0] = '\0';
	}
	(void) fclose(fp);

	return (retcode);
}

/*
 * Since this is an overwrite of a different version of the package, none of
 * the old files should remain, so we rename them.
 */
static int
mv_pkgdirs(void)
{
	/*
	 * If we're not in dryrun mode and we can find an old set of package
	 * files over which the new ones will be written, do the rename.
	 */
	if (!in_dryrun_mode() && pkgloc[0] && !access(pkgloc, F_OK)) {
		(void) snprintf(pkgloc_sav, sizeof (pkgloc_sav),
			"%s/.save.%s", get_PKGLOC(),
			pkginst);
		if (pkgloc_sav[0] && !access(pkgloc_sav, F_OK)) {
			(void) rrmdir(pkgloc_sav);
		}

		if (rename(pkgloc, pkgloc_sav) == -1) {
			progerr(ERR_PKGBINREN, pkgloc, pkgloc_sav);
			return (99);
		}
	}

	return (0);
}

/*
 * Name:	merg_pkginfos
 * Description:	This function scans the installed pkginfo and merges that
 *		environment with the installing environment according to
 *		the following rules:
 *
 *		1. CLASSES is a union of the installed and installing CLASSES
 *			lists.
 *		2. The installed BASEDIR takes precedence. If it doesn't agree
 *		   with an administratively imposed BASEDIR, an ERROR is issued.
 *		3. All other installing parameters are preserved.
 *		4. All installed parameters are added if they do not overwrite
 *		   an existing installing parameter.
 *
 *		The current environment contains the pkginfo settings for the
 *		new package to be installed or to be updated.
 *
 * Arguments:	pclass - returned list of current classes involved in install
 *		mpclass - pointer to returned list of current install classes
 * Returns:	int
 *		== 0 - all OK
 *		!= 0 - an error code if a fatal error occurred
 */

static int
merg_pkginfos(struct cl_attr **pclass, struct cl_attr ***mpclass)
{
	FILE	*fp;
	char	SUNW_PKG_ALLZONES[MAX_PKG_PARAM_LENGTH] = {'\0'};
	char	SUNW_PKG_HOLLOW[MAX_PKG_PARAM_LENGTH] = {'\0'};
	char	SUNW_PKG_THISZONE[MAX_PKG_PARAM_LENGTH] = {'\0'};
	char	*newValue;
	char	*oldValue;
	char	*pkgName;
	char	*pkgVersion;
	char	param[MAX_PKG_PARAM_LENGTH];
	char	pkginfo_path[PATH_MAX];
	int	retcode = 0;

	/* obtain the name of the package (for error messages) */

	pkgName = getenv("PKG");
	if (pkgName == NULL) {
		pkgName = "*current*";	/* default name */
	}

	/* obtain the version of the package (for error messages) */

	pkgVersion = getenv("VERSION");
	if (pkgVersion == NULL) {
		pkgVersion = "*current*";	/* default version */
	}

	/* open installed package pkginfo file */

	(void) snprintf(pkginfo_path, sizeof (pkginfo_path),
			"%s/%s", pkgloc, PKGINFO);
	if ((fp = fopen(pkginfo_path, "r")) == NULL) {
		progerr(ERR_PKGINFO, pkginfo_path);
		return (99);
	}

	/* entry debugging info */

	echoDebug(DBG_MERGINFOS_ENTRY, pkginfo_path);

	/*
	 * cycle through the currently installed package's pkginfo parameters
	 * and let the currently installed package's settings survive if the
	 * update to the package does not provide an overriding value
	 */

	for (param[0] = '\0'; (oldValue = fpkgparam(fp, param)) != NULL;
		param[0] = '\0') {

		boolean_t	setZoneAttribute = B_FALSE;

		/* debug info - attribute currently set to value */

		echoDebug(DBG_MERGINFOS_SET_TO, param, oldValue);

		/*
		 * if zone package attribute is present in the currently
		 * installed package, then remember the value for the
		 * specific zone package attribute, and set the flag that
		 * indicates a zone package attribute is being processed.
		 */

		if (strcmp(param, PKG_THISZONE_VARIABLE) == 0) {
			/* SUNW_PKG_THISZONE currently set */
			setZoneAttribute = B_TRUE;
			(void) strlcpy(SUNW_PKG_THISZONE, oldValue,
					sizeof (SUNW_PKG_THISZONE));
		} else if (strcmp(param, PKG_ALLZONES_VARIABLE) == 0) {
			/* SUNW_PKG_ALLZONES currently set */
			setZoneAttribute = B_TRUE;
			(void) strlcpy(SUNW_PKG_ALLZONES, oldValue,
					sizeof (SUNW_PKG_ALLZONES));
		} else if (strcmp(param, PKG_HOLLOW_VARIABLE) == 0) {
			/* SUNW_PKG_THISZONE currently set */
			setZoneAttribute = B_TRUE;
			(void) strlcpy(SUNW_PKG_HOLLOW, oldValue,
					sizeof (SUNW_PKG_HOLLOW));
		}

		/* handle CLASSES currently being set */

		if (strcmp(param, "CLASSES") == 0) {
			echoDebug(DBG_MERGINFOS_SET_CLASSES, oldValue);
			/* create a list of the current classes */
			(void) setlist(&pclass, qstrdup(oldValue));
			/* set pointer to list of current classes */
			*mpclass = pclass;
			continue;
		}

		/* handle BASEDIR currently being set */

		if (strcmp("BASEDIR", param) == 0) {
			if (adm.basedir && *(adm.basedir) &&
				strchr("/$", *(adm.basedir))) {
				char *dotptr;

				/* Get srcinst down to a* name */

				if (dotptr = strchr(srcinst, '.')) {
					*dotptr = '\000';
				}
				if (strcmp(oldValue, adm.basedir) != 0) {
					progerr(ERR_ADMBD, srcinst,
						oldValue, adm.basedir);
					/* administration */
					retcode = 4;
					break;
				}
			} else if (ADM(basedir, "ask")) {
				/*
				 * If it's going to ask
				 * later, let it know that it
				 * *must* agree with the
				 * BASEDIR we just picked up.
				 */
				adm.basedir = "update";
				echoDebug(DBG_MERGINFOS_ASK_BASEDIR);
			}

			echoDebug(DBG_MERGINFOS_SET_BASEDIR, oldValue);
			putparam(param, oldValue);
			continue;
		}

		/*
		 * determine if there is a new value for this attribute.
		 */

		newValue = getenv(param);

		/*
		 * If there is no new value, and a zone attribute
		 * is being changed, it is the same as setting the zone package
		 * attribute to 'false' - make sure current setting is 'false'.
		 */

		if ((newValue == NULL) &&
		    (setZoneAttribute == B_TRUE) &&
		    (strcasecmp(oldValue, "false") != 0)) {

			/* unset existing non-"false" zone pkg attr */
			progerr(ERR_MERGINFOS_UNSET_ZONEATTR,
				pkgName, pkgVersion, param, oldValue);
			retcode = 1;
			break;
		}

		/* retain old value if no new value specified */

		if (newValue == NULL) {
			/* no new value - retain the old value */
			echoDebug(DBG_MERGINFOS_RETAIN_OLD, param, oldValue);
			putparam(param, oldValue);
			continue;
		}

		/* note if the old and new values are the same */

		if (strcmp(newValue, oldValue) == 0) {
			/* set existing package parameter to same value */
			echoDebug(DBG_MERGINFOS_SET_DUPLICATE, param, oldValue);
			continue;
		}

		/*
		 * Check if old and new values differ.
		 * Error if zone parameter
		 */

		if (setZoneAttribute == B_TRUE) {
			/* illegal change to zone attribute */

			progerr(ERR_MERGINFOS_CHANGE_ZONEATTR, pkgName,
				pkgVersion, param, oldValue, newValue);

			/* set return code to "fatal error" */
			retcode = 1;
			break;
		}

		/* note valid change to existing package parameter */

		echoDebug(DBG_MERGINFOS_SET_CHANGE, param,
				oldValue, newValue);
	}

	/* close handle on currently installed package's pkginfo file */

	(void) fclose(fp);

	/* return error if not successful up to this point */

	if (retcode != 0) {
		echoDebug(DBG_MERGINFOS_EXIT, pkginfo_path, retcode);

		return (retcode);
	}

	/*
	 * verify that no zone attribute has been
	 * set to an invalid value
	 */

	/* SUNW_PKG_ALLZONES */

	newValue = getenv(PKG_ALLZONES_VARIABLE);

	/*
	 * complain if setting SUNW_PKG_ALLZONES to other than "false"
	 */


	if ((newValue != NULL) && (*SUNW_PKG_ALLZONES == '\0') &&
	    (strcasecmp(newValue, "false") != 0)) {
		/* change ALLZONES from "true" to "false" (unset) */
		progerr(ERR_MERGINFOS_SET_ZONEATTR, pkgName,
		    pkgVersion, PKG_ALLZONES_VARIABLE, newValue);
		return (1);
	}

	/* SUNW_PKG_THISZONE */

	newValue = getenv(PKG_THISZONE_VARIABLE);

	/*
	 * complain if setting SUNW_PKG_THISZONE to other than "false"
	 */

	if ((newValue != NULL) && (*SUNW_PKG_THISZONE == '\0') &&
	    (strcasecmp(newValue, "false") != 0)) {
		/* change THISZONE from "true" to "false" (unset) */
		progerr(ERR_MERGINFOS_SET_ZONEATTR, pkgName,
		    pkgVersion, PKG_THISZONE_VARIABLE, newValue);
		return (1);
	}

	/* SUNW_PKG_HOLLOW */

	newValue = getenv(PKG_HOLLOW_VARIABLE);

	/* complain if setting SUNW_PKG_HOLLOW to other than "false" */

	if ((newValue != NULL) && (*SUNW_PKG_HOLLOW == '\0') &&
	    (strcasecmp(newValue, "false") != 0)) {
		/* change HOLLOW from "true" to 'false" (unset) */
		progerr(ERR_MERGINFOS_SET_ZONEATTR, pkgName,
		    pkgVersion, PKG_HOLLOW_VARIABLE, newValue);
		return (1);
	}

	echoDebug(DBG_MERGINFOS_EXIT, pkginfo_path, 0);

	return (0);
}

static void
set_dryrun_dir_loc(void)
{
	/* Set pkg location to the dryrun directory */
	set_PKGLOC(pkgdrtarg);
	(void) snprintf(pkgloc, sizeof (pkgloc),
			"%s/%s", get_PKGLOC(), pkginst);
	(void) snprintf(pkgbin, sizeof (pkgbin),
			"%s/install", pkgloc);
	(void) snprintf(pkgsav, sizeof (pkgsav),
			"%s/save", pkgloc);
	(void) snprintf(ilockfile, sizeof (ilockfile),
			"%s/!I-Lock!", pkgloc);
	(void) snprintf(rlockfile, sizeof (rlockfile),
			"%s/!R-Lock!", pkgloc);
	(void) snprintf(savlog, sizeof (savlog),
			"%s/logs/%s", get_PKGADM(), pkginst);
}

/*
 * If we are updating a pkg, then we need to copy the "old" pkgloc so that
 * any scripts that got removed in the new version aren't left around.  So we
 * copy it here to .save.pkgloc, then in quit() we can restore our state, or
 * remove it.
 */
static int
cp_pkgdirs(void)
{
	if (in_dryrun_mode()) {
		set_dryrun_dir_loc();
	}

	/*
	 * If we're not in dryrun mode and we can find an old set of package
	 * files over which the new ones will be written, do the copy.
	 */
	if (!in_dryrun_mode() && pkgloc[0] && !access(pkgloc, F_OK)) {
		int status;
		int r;

		(void) snprintf(pkgloc_sav, sizeof (pkgloc_sav), "%s/.save.%s",
			get_PKGLOC(), pkginst);

		/*
		 * Even though it takes a while, we use a recursive copy here
		 * because if the current pkgadd fails for any reason, we
		 * don't want to lose this data.
		 */
		r = e_ExecCmdList(&status, (char **)NULL, (char *)NULL,
			"/usr/bin/cp", "cp", "-r", pkgloc, pkgloc_sav,
			(char *)NULL);

		if ((r != 0) || (status == -1) || (WEXITSTATUS(status) != 0)) {
			progerr(ERR_PKGBINCP, pkgloc, pkgloc_sav);
			return (99);
		}
	}

	return (0);
}

/*
 * This implements the pkgask function. It just executes the request script
 * and stores the results in a response file.
 */
static void
do_pkgask(boolean_t a_run_request_as_root)
{
	if (pkgdev.cdevice) {
		unpack();
		if (!suppressCopyright) {
			copyright();
		}
	}
	(void) snprintf(path, sizeof (path), "%s/%s", instdir, REQUEST_FILE);
	if (access(path, F_OK)) {
		progerr(ERR_NOREQUEST);
		quit(1);
		/*NOTREACHED*/
	}

	(void) set_respfile(respfile, srcinst, RESP_WR);

	if (is_a_respfile()) {
		ckreturn(reqexec(update, path, non_abi_scripts,
			a_run_request_as_root), ERR_REQUEST);
	} else {
		failflag++;
	}

	if (warnflag || failflag) {
		(void) remove(respfile);
		echo("\nResponse file <%s> was not created.",
			get_respfile());
	} else {
		echo("\nResponse file <%s> was created.",
			get_respfile());
	}

	quit(0);
	/*NOTREACHED*/
}

/*
 * This function runs a check utility and acts appropriately based upon the
 * return code. It deals appropriately with the dryrun file if it is present.
 */
static void
ck_w_dryrun(int (*func)(), int type)
{
	int n;

	n = func();
	if (in_dryrun_mode())
		set_dr_info(type, !n);

	if (n) {
		quit(n);
		/*NOTREACHED*/
	}
}

/*
 * This function deletes all install class action scripts from the package
 * directory on the root filesystem.
 */
static void
rm_icas(char *cas_dir)
{
	DIR	*pdirfp;
	struct	dirent *dp;
	char path[PATH_MAX];

	if ((pdirfp = opendir(cas_dir)) == NULL)
		return;

	while ((dp = readdir(pdirfp)) != NULL) {
		if (dp->d_name[0] == '.')
			continue;

		if (dp->d_name[0] == 'i' && dp->d_name[1] == '.') {
			(void) snprintf(path, sizeof (path),
				"%s/%s", cas_dir, dp->d_name);
			(void) remove(path);
		}
	}
	(void) closedir(pdirfp);
}

void
ckreturn(int retcode, char *msg)
{
	switch (retcode) {
		case 2:
		case 12:
		case 22:
		warnflag++;
		if (msg) {
			progerr("%s", msg);
		}
		/*FALLTHRU*/
		case 10:
		case 20:
		if (retcode >= 10 && retcode < 20) {
			dreboot++;
		}
		if (retcode >= 20) {
			ireboot++;
		}
		/*FALLTHRU*/
		case 0:
		break; /* okay */

		case -1:
		retcode = 99;
		/*FALLTHRU*/
		case 99:
		case 1:
		case 11:
		case 21:
		case 4:
		case 14:
		case 24:
		case 5:
		case 15:
		case 25:
		if (msg) {
			progerr("%s", msg);
		}
		/*FALLTHRU*/
		case 3:
		case 13:
		case 23:
		quit(retcode);
		/*NOTREACHED*/
		default:
		if (msg) {
			progerr("%s", msg);
		}
		quit(1);
		/*NOTREACHED*/
	}
}

static void
copyright(void)
{
	FILE	*fp;
	char	line[LSIZE];
	char	path[PATH_MAX];

	/* Compose full path for copyright file */
	(void) snprintf(path, sizeof (path), "%s/%s", instdir, COPYRIGHT_FILE);

	if ((fp = fopen(path, "r")) == NULL) {
		if (getenv("VENDOR") != NULL)
			echo(getenv("VENDOR"));
	} else {
		while (fgets(line, LSIZE, fp))
			(void) fprintf(stdout, "%s", line); /* bug #1083713 */
		(void) fclose(fp);
	}
}

static int
rdonly(char *p)
{
	int	i;

	for (i = 0; ro_params[i]; i++) {
		if (strcmp(p, ro_params[i]) == 0)
			return (1);
	}
	return (0);
}

static void
unpack(void)
{
	/*
	 * read in next part from stream, even if we decide
	 * later that we don't need it
	 */
	if (dparts < 1) {
		progerr(ERR_DSTREAMCNT);
		quit(99);
		/*NOTREACHED*/
	}
	if ((access(instdir, F_OK) == 0) && rrmdir(instdir)) {
		progerr(ERR_RMDIR, instdir);
		quit(99);
		/*NOTREACHED*/
	}
	if (mkdir(instdir, 0755)) {
		progerr(ERR_MKDIR, instdir);
		quit(99);
		/*NOTREACHED*/
	}
	if (chdir(instdir)) {
		progerr(ERR_CHDIR, instdir);
		quit(99);
		/*NOTREACHED*/
	}
	if (!ds_fd_open()) {
		dparts = ds_findpkg(pkgdev.cdevice, srcinst);
		if (dparts < 1) {
			progerr(ERR_DSARCH, srcinst);
			quit(99);
			/*NOTREACHED*/
		}
	}

	dparts--;

	if (ds_next(pkgdev.cdevice, instdir)) {
		progerr(ERR_DSTREAM);
		quit(99);
		/*NOTREACHED*/
	}
	if (chdir(get_PKGADM())) {
		progerr(ERR_CHDIR, get_PKGADM());
		quit(99);
		/*NOTREACHED*/
	}
	ds_close(1);
}

static void
usage(void)
{
	(void) fprintf(stderr, ERR_USAGE_PKGINSTALL);
	exit(1);
	/*NOTREACHED*/
}



/* ============================================================================
 * SOURCE 63/98: minix4\exokernel\kernel_legacy\cmd\svr4pkg\pkgmk\main.c
 * Size: 24,350 bytes, Lines: 973
 * Hash: 0d4a54985c52...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

/* Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T */
/* All Rights Reserved */


#include <stdio.h>
#include <string.h>
#include <signal.h>
#include <errno.h>
#include <malloc.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/param.h>
#include <ctype.h>
#include <sys/mman.h>
#include <sys/sysmacros.h>
#include <strings.h>
#include <pkgstrct.h>
#include <pkgdev.h>
#include <pkginfo.h>
#include <pkglocs.h>
#include <locale.h>
#include <libintl.h>
#include <sys/statvfs.h>
#include <sys/utsname.h>
#include <instzones_api.h>
#include <pkglib.h>
#include <libadm.h>
#include <libinst.h>

extern char	**environ, *pkgdir;

/* mkpkgmap.c */
extern int	mkpkgmap(char *outfile, char *protofile, char **cmdparam);
/* splpkgmap.c */
extern int	splpkgmap(struct cfent **eptlist, unsigned int eptnum,
    char *order[], ulong_t bsize, ulong_t frsize, fsblkcnt_t *plimit,
    fsfilcnt_t *pilimit, fsblkcnt_t *pllimit);
/* scriptvfy.c */
extern int	checkscripts(char *inst_dir, int silent);

/* libpkg/gpkgmap.c */
extern void	setmapmode(int mode_no);

static boolean_t valid_zone_attr(struct cfent **eptlist);

#define	MALSIZ	16
#define	NROOT	8
#define	SPOOLDEV	"spool"

#define	MSG_PROTOTYPE	"## Building pkgmap from package prototype file.\n"
#define	MSG_PKGINFO	"## Processing pkginfo file.\n"
#define	MSG_VOLUMIZE	"## Attempting to volumize %d entries in pkgmap.\n"
#define	MSG_PACKAGE1	"## Packaging one part.\n"
#define	MSG_PACKAGEM	"## Packaging %d parts.\n"
#define	MSG_VALSCRIPTS	"## Validating control scripts.\n"

/* Other problems */
#define	ERR_MEMORY	"memory allocation failure, errno=%d"
#define	ERR_NROOT	"too many paths listed with -r option, limit is %d"
#define	ERR_PKGINST	"invalid package instance identifier <%s>"
#define	ERR_PKGABRV	"invalid package abbreviation <%s>"
#define	ERR_BADDEV	"unknown or invalid device specified <%s>"
#define	ERR_TEMP	"unable to obtain temporary file resources, errno=%d"
#define	ERR_DSTREAM	"invalid device specified (datastream) <%s>"
#define	ERR_SPLIT	"unable to volumize package"
#define	ERR_MKDIR	"unable to make directory <%s>"
#define	ERR_SYMLINK	"unable to create symbolic link for <%s>"
#define	ERR_OVERWRITE	"must use -o option to overwrite <%s>"
#define	ERR_UMOUNT	"unable to unmount device <%s>"
#define	ERR_NOPKGINFO	"required pkginfo file is not specified in prototype " \
			"file"
#define	ERR_RDPKGINFO	"unable to process pkginfo file <%s>"
#define	ERR_PROTOTYPE	"unable to locate prototype file"
#define	ERR_STATVFS	"unable to stat filesystem <%s>"
#define	ERR_WHATVFS	"unable to determine or access output filesystem for " \
			"device <%s>"
#define	ERR_DEVICE	"unable to find info for device <%s>"
#define	ERR_BUILD	"unable to build pkgmap from prototype file"
#define	ERR_ONEVOL	"other packages found - package must fit on a single " \
			"volume"
#define	ERR_NOPARAM	"parameter <%s> is not defined in <%s>"
#define	ERR_PKGMTCH	"PKG parameter <%s> does not match instance <%s>"
#define	ERR_NO_PKG_INFOFILE	"unable to open pkginfo file <%s>: %s"
#define	ERR_ALLZONES_AND_THISZONE	"The package <%s> has <%s> = true " \
					"and <%s> = true: the package may " \
					"set either parameter to true, but " \
					"may not set both parameters to " \
					"true. NOTE: if the package " \
					"contains a request script, it is " \
					"treated as though it has " \
					"<SUNW_PKG_THISZONE> = true"
#define	ERR_NO_ALLZONES_AND_HOLLOW	"The package <%s> has <%s> = false " \
					"and <%s> = true: a hollow package " \
					"must also be set to install in all " \
					"zones"
#define	ERR_PKGINFO_INVALID_OPTION_COMB	"Invalid combinations of zone " \
					"parameters in pkginfo file"

#define	ERR_USAGE	"usage: %s [options] [VAR=value [VAR=value]] " \
			"[pkginst]\n" \
			"   where options may include:\n" \
			"\t-o\n" \
			"\t-a arch\n" \
			"\t-v version\n" \
			"\t-p pstamp\n" \
			"\t-l limit\n" \
			"\t-r rootpath\n" \
			"\t-b basedir\n" \
			"\t-d device\n" \
			"\t-f protofile\n"
#define	WRN_MISSINGDIR	"WARNING: missing directory entry for <%s>"
#define	WRN_SETPARAM	"WARNING: parameter <%s> set to \"%s\""
#define	WRN_CLASSES	"WARNING: unreferenced class <%s> in prototype file"

#define	LINK    1

struct pkgdev pkgdev; 	/* holds info about the installation device */
int	started;
char	pkgloc[PATH_MAX];
char	*basedir;
char	*root;
char	*rootlist[NROOT];
char	*t_pkgmap;
char	*t_pkginfo;

static struct cfent *svept;
static char	*protofile,
		*device;
static fsblkcnt_t limit = 0;
static fsblkcnt_t llimit = 0;
static fsfilcnt_t ilimit = 0;
static int	overwrite,
		nflag,
		sflag;
static void	ckmissing(char *path, char type);
static void	outvol(struct cfent **eptlist, unsigned int eptnum, int part,
			int nparts);
static void	trap(int n);
static void	usage(void);

static int	slinkf(char *from, char *to);

int
main(int argc, char *argv[])
{
	struct utsname utsbuf;
	struct statvfs64 svfsb;
	struct cfent	**eptlist;
	FILE	*fp;
	VFP_T	*vfp;
	int	c, n, found;
	int	part, nparts, npkgs, objects;
	char	buf[MAX_PKG_PARAM_LENGTH];
	char	temp[MAX_PKG_PARAM_LENGTH];
	char	param[MAX_PKG_PARAM_LENGTH];
	char	*pt, *value, *pkginst, *tmpdir, *abi_sym_ptr,
		**cmdparam;
	char	*pkgname;
	char	*pkgvers;
	char	*pkgarch;
	char	*pkgcat;
	void	(*func)();
	time_t	clock;
	ulong_t	bsize = 0;
	ulong_t	frsize = 0;
	struct cl_attr	**allclass = NULL;
	struct cl_attr	**order;
	unsigned int eptnum, i;

	/* initialize locale environment */

	(void) setlocale(LC_ALL, "");

#if !defined(TEXT_DOMAIN)	/* Should be defined by cc -D */
#define	TEXT_DOMAIN "SYS_TEST"
#endif
	(void) textdomain(TEXT_DOMAIN);

	/* initialize program name */

	(void) set_prog_name(argv[0]);

	/* tell spmi zones interface how to access package output functions */

	z_set_output_functions(echo, echoDebug, progerr);

	func = sigset(SIGINT, trap);
	if (func != SIG_DFL)
		func = sigset(SIGINT, func);
	func = sigset(SIGHUP, trap);
	setmapmode(MAPBUILD);	/* variable binding */
	if (func != SIG_DFL)
		func = sigset(SIGHUP, func);

	environ = NULL;
	while ((c = getopt(argc, argv, "osnp:l:r:b:d:f:a:v:?")) != EOF) {
		switch (c) {
		    case 'n':
			nflag++;
			break;

		    case 's':
			sflag++;
			break;

		    case 'o':
			overwrite++;
			break;

		    case 'p':
			putparam("PSTAMP", optarg);
			break;

		    case 'l':
			llimit = strtoull(optarg, NULL, 10);
			break;

		    case 'r':
			pt = strtok(optarg, " \t\n, ");
			n = 0;
			do {
				rootlist[n++] = flex_device(pt, 0);
				if (n >= NROOT) {
					progerr(gettext(ERR_NROOT), NROOT);
					quit(1);
				}
			} while (pt = strtok(NULL, " \t\n, "));
			rootlist[n] = NULL;
			break;

		    case 'b':
			basedir = optarg;
			break;

		    case 'f':
			protofile = optarg;
			break;

		    case 'd':
			device = flex_device(optarg, 1);
			break;

		    case 'a':
			putparam("ARCH", optarg);
			break;

		    case 'v':
			putparam("VERSION", optarg);
			break;

		    default:
			usage();
			/*NOTREACHED*/
			/*
			 * Although usage() calls a noreturn function,
			 * needed to add return (1);  so that main() would
			 * pass compilation checks. The statement below
			 * should never be executed.
			 */
			return (1);
		}
	}

	/*
	 * Store command line variable assignments for later
	 * incorporation into the environment.
	 */
	cmdparam = &argv[optind];

	/* Skip past equates. */
	while (argv[optind] && strchr(argv[optind], '='))
		optind++;

	/* Confirm that the instance name is valid */
	if ((pkginst = argv[optind]) != NULL) {
		if (pkgnmchk(pkginst, "all", 0)) {
			progerr(gettext(ERR_PKGINST), pkginst);
			quit(1);
		}
		argv[optind++] = NULL;
	}
	if (optind != argc)
		usage();

	tmpdir = getenv("TMPDIR");
	if (tmpdir == NULL)
		tmpdir = P_tmpdir;

	/* bug id 4244631, not ABI compliant */
	abi_sym_ptr = getenv("PKG_NONABI_SYMLINKS");
	if (abi_sym_ptr && (strncasecmp(abi_sym_ptr, "TRUE", 4) == 0)) {
		set_nonABI_symlinks();
	}

	if (device == NULL) {
		device = devattr(SPOOLDEV, "pathname");
		if (device == NULL) {
			progerr(gettext(ERR_DEVICE), SPOOLDEV);
			exit(99);
		}
	}

	if (protofile == NULL) {
		if (access("prototype", 0) == 0)
			protofile = "prototype";
		else if (access("Prototype", 0) == 0)
			protofile = "Prototype";
		else {
			progerr(gettext(ERR_PROTOTYPE));
			quit(1);
		}
	}

	if (devtype(device, &pkgdev)) {
		progerr(gettext(ERR_BADDEV), device);
		quit(1);
	}
	if (pkgdev.norewind) {
		/* initialize datastream */
		progerr(gettext(ERR_DSTREAM), device);
		quit(1);
	}
	if (pkgdev.mount) {
		if (n = pkgmount(&pkgdev, NULL, 0, 0, 1))
			quit(n);
	}

	/*
	 * convert prototype file to a pkgmap, while locating
	 * package objects in the current environment
	 */
	t_pkgmap = tempnam(tmpdir, "tmpmap");
	if (t_pkgmap == NULL) {
		progerr(gettext(ERR_TEMP), errno);
		exit(99);
	}

	(void) fprintf(stderr, gettext(MSG_PROTOTYPE));
	if (n = mkpkgmap(t_pkgmap, protofile, cmdparam)) {
		progerr(gettext(ERR_BUILD));
		quit(1);
	}

	setmapmode(MAPNONE);	/* All appropriate variables are now bound */

	if (vfpOpen(&vfp, t_pkgmap, "r", VFP_NEEDNOW) != 0) {
		progerr(gettext(ERR_TEMP), errno);
		quit(99);
	}

	eptlist = procmap(vfp, 0, NULL);

	if (eptlist == NULL) {
		quit(1);
	}

	(void) vfpClose(&vfp);

	/* Validate the zone attributes in pkginfo, before creation */
	if (!valid_zone_attr(eptlist)) {
		progerr(ERR_PKGINFO_INVALID_OPTION_COMB);
		quit(1);
	}

	(void) fprintf(stderr, gettext(MSG_PKGINFO));
	pt = NULL;
	for (i = 0; eptlist[i]; i++) {
		ckmissing(eptlist[i]->path, eptlist[i]->ftype);
		if (eptlist[i]->ftype != 'i')
			continue;
		if (strcmp(eptlist[i]->path, "pkginfo") == 0)
			svept = eptlist[i];
	}
	if (svept == NULL) {
		progerr(gettext(ERR_NOPKGINFO));
		quit(99);
	}
	eptnum = i;

	/*
	 * process all parameters from the pkginfo file
	 * and place them in the execution environment
	 */

	if ((fp = fopen(svept->ainfo.local, "r")) == NULL) {
		progerr(gettext(ERR_RDPKGINFO), svept->ainfo.local);
		quit(99);
	}
	param[0] = '\0';
	while (value = fpkgparam(fp, param)) {
		if (getenv(param) == NULL)
			putparam(param, value);
		free((void *)value);
		param[0] = '\0';
	}
	(void) fclose(fp);

	/* add command line variables */
	while (*cmdparam && (value = strchr(*cmdparam, '=')) != NULL) {
		*value = '\0';	/* terminate the parameter */
		value++;	/* value is now the value (not '=') */
		putparam(*cmdparam++, value);  /* store it in environ */
	}

	/* make sure parameters are valid */
	(void) time(&clock);
	if (pt = getenv("PKG")) {
		if (pkgnmchk(pt, NULL, 0) || strchr(pt, '.')) {
			progerr(gettext(ERR_PKGABRV), pt);
			quit(1);
		}
		if (pkginst == NULL)
			pkginst = pt;
	} else {
		progerr(gettext(ERR_NOPARAM), "PKG", svept->path);
		quit(1);
	}
	/*
	 * verify consistency between PKG parameter and pkginst
	 */
	(void) snprintf(param, sizeof (param), "%s.*", pt);
	if (pkgnmchk(pkginst, param, 0)) {
		progerr(gettext(ERR_PKGMTCH), pt, pkginst);
		quit(1);
	}

	if ((pkgname = getenv("NAME")) == NULL) {
		progerr(gettext(ERR_NOPARAM), "NAME", svept->path);
		quit(1);
	}
	if (ckparam("NAME", pkgname))
		quit(1);
	if ((pkgvers = getenv("VERSION")) == NULL) {
		/* XXX - I18n */
		/* LINTED do not use cftime(); use strftime instead */
		(void) cftime(buf, "\045m/\045d/\045Y", &clock);
		(void) snprintf(temp, sizeof (temp),
			gettext("Dev Release %s"), buf);
		putparam("VERSION", temp);
		pkgvers = getenv("VERSION");
		logerr(gettext(WRN_SETPARAM), "VERSION", temp);
	}
	if (ckparam("VERSION", pkgvers))
		quit(1);
	if ((pkgarch = getenv("ARCH")) == NULL) {
		(void) uname(&utsbuf);
		putparam("ARCH", utsbuf.machine);
		pkgarch = getenv("ARCH");
		logerr(gettext(WRN_SETPARAM), "ARCH", utsbuf.machine);
	}
	if (ckparam("ARCH", pkgarch))
		quit(1);
	if (getenv("PSTAMP") == NULL) {
		/* use octal value of '%' to fight sccs expansion */
		/* XXX - I18n */
		/* LINTED do not use cftime(); use strftime instead */
		(void) cftime(buf, "\045Y\045m\045d\045H\045M\045S", &clock);
		(void) uname(&utsbuf);
		(void) snprintf(temp, sizeof (temp), "%s%s",
			utsbuf.nodename, buf);
		putparam("PSTAMP", temp);
		logerr(gettext(WRN_SETPARAM), "PSTAMP", temp);
	}
	if ((pkgcat = getenv("CATEGORY")) == NULL) {
		progerr(gettext(ERR_NOPARAM), "CATEGORY", svept->path);
		quit(1);
	}
	if (ckparam("CATEGORY", pkgcat))
		quit(1);

	/*
	 * warn user of classes listed in package which do
	 * not appear in CLASSES variable in pkginfo file
	 */
	objects = 0;
	for (i = 0; eptlist[i]; i++) {
		if (eptlist[i]->ftype != 'i') {
			objects++;
			addlist(&allclass, eptlist[i]->pkg_class);
		}
	}

	if ((pt = getenv("CLASSES")) == NULL) {
		if (allclass && *allclass) {
			cl_setl(allclass);
			cl_putl("CLASSES", allclass);
			logerr(gettext(WRN_SETPARAM), "CLASSES",
			    getenv("CLASSES"));
		}
	} else {
		cl_sets(qstrdup(pt));
		if (allclass && *allclass) {
			for (i = 0; allclass[i]; i++) {
				found = 0;
				if (cl_idx(allclass[i]->name) != -1) {
					found++;
					break;
				}
				if (!found) {
					logerr(gettext(WRN_CLASSES),
					    (char *)allclass[i]);
				}
			}
		}
	}

	(void) fprintf(stderr, gettext(MSG_VOLUMIZE), objects);
	order = (struct cl_attr **)0;
	if (pt = getenv("ORDER")) {
		pt = qstrdup(pt);
		(void) setlist(&order, pt);
		cl_putl("ORDER", order);
	}

	/* stat the intended output filesystem to get blocking information */
	if (pkgdev.dirname == NULL) {
		progerr(gettext(ERR_WHATVFS), device);
		quit(99);
	}
	if (statvfs64(pkgdev.dirname, &svfsb)) {
		progerr(gettext(ERR_STATVFS), pkgdev.dirname);
		quit(99);
	}

	if (bsize == 0) {
		bsize = svfsb.f_bsize;
	}
	if (frsize == 0) {
		frsize = svfsb.f_frsize;
	}

	if (limit == 0)
		/*
		 * bavail is in terms of fragment size blocks - change
		 * to 512 byte blocks
		 */
		limit = (fsblkcnt_t)(((fsblkcnt_t)frsize > 0) ?
			howmany(frsize, DEV_BSIZE) :
			howmany(bsize, DEV_BSIZE)) * svfsb.f_bavail;

	if (ilimit == 0) {
		ilimit = (svfsb.f_favail > 0) ?
		    svfsb.f_favail : svfsb.f_ffree;
	}

	nparts = splpkgmap(eptlist, eptnum, (char **)order, bsize, frsize,
	    &limit, &ilimit, &llimit);

	if (nparts <= 0) {
		progerr(gettext(ERR_SPLIT));
		quit(1);
	}

	if (nflag) {
		for (i = 0; eptlist[i]; i++)
			(void) ppkgmap(eptlist[i], stdout);
		exit(0);
		/*NOTREACHED*/
	}

	(void) snprintf(pkgloc, sizeof (pkgloc), "%s/%s",
			pkgdev.dirname, pkginst);
	if (!isdir(pkgloc) && !overwrite) {
		progerr(gettext(ERR_OVERWRITE), pkgloc);
		quit(1);
	}

	/* output all environment install parameters */
	t_pkginfo = tempnam(tmpdir, "pkginfo");
	if ((fp = fopen(t_pkginfo, "w")) == NULL) {
		progerr(gettext(ERR_TEMP), errno);
		exit(99);
	}
	for (i = 0; environ[i]; i++) {
		if (isupper(*environ[i])) {
			(void) fputs(environ[i], fp);
			(void) fputc('\n', fp);
		}
	}
	(void) fclose(fp);

	started++;
	(void) rrmdir(pkgloc);
	if (mkdir(pkgloc, 0755)) {
		progerr(gettext(ERR_MKDIR), pkgloc);
		quit(1);
	}

	/* determine how many packages already reside on the medium */
	pkgdir = pkgdev.dirname;
	npkgs = 0;
	while (pt = fpkginst("all", NULL, NULL))
		npkgs++;
	(void) fpkginst(NULL); /* free resource usage */

	if (nparts > 1) {
		if (pkgdev.mount && npkgs) {
			progerr(gettext(ERR_ONEVOL));
			quit(1);
		}
	}

	/*
	 *  update pkgmap entry for pkginfo file, since it may
	 *  have changed due to command line or failure to
	 *  specify all neccessary parameters
	 */
	for (i = 0; eptlist[i]; i++) {
		if (eptlist[i]->ftype != 'i')
			continue;
		if (strcmp(eptlist[i]->path, "pkginfo") == 0) {
			svept = eptlist[i];
			svept->ftype = '?';
			svept->ainfo.local = t_pkginfo;
			(void) cverify(0, &svept->ftype, t_pkginfo,
				&svept->cinfo, 1);
			svept->ftype = 'i';
			break;
		}
	}

	if (nparts > 1)
		(void) fprintf(stderr, gettext(MSG_PACKAGEM), nparts);
	else
		(void) fprintf(stderr, gettext(MSG_PACKAGE1));

	for (part = 1; part <= nparts; part++) {
		if ((part > 1) && pkgdev.mount) {
			if (pkgumount(&pkgdev)) {
				progerr(gettext(ERR_UMOUNT), pkgdev.mount);
				quit(99);
			}
			if (n = pkgmount(&pkgdev, NULL, part, nparts, 1))
				quit(n);
			(void) rrmdir(pkgloc);
			if (mkdir(pkgloc, 0555)) {
				progerr(gettext(ERR_MKDIR), pkgloc);
				quit(99);
			}
		}
		outvol(eptlist, eptnum, part, nparts);

		/* Validate (as much as possible) the control scripts. */
		if (part == 1) {
			char inst_path[PATH_MAX];

			(void) fprintf(stderr, gettext(MSG_VALSCRIPTS));
			(void) snprintf(inst_path, sizeof (inst_path),
					"%s/install", pkgloc);
			checkscripts(inst_path, 0);
		}
	}

	quit(0);
	/* LINTED: no return */
}

static void
trap(int n)
{
	(void) signal(SIGINT, SIG_IGN);
	(void) signal(SIGHUP, SIG_IGN);

	if (n == SIGINT)
		quit(3);
	else {
		(void) fprintf(stderr, gettext("%s terminated (signal %d).\n"),
				get_prog_name(), n);
		quit(99);
	}
}

static void
outvol(struct cfent **eptlist, unsigned int eptnum, int part, int nparts)
{
	FILE	*fp;
	char	*svpt, *path, temp[PATH_MAX];
	unsigned int	i;


	if (nparts > 1)
		(void) fprintf(stderr, gettext(" -- part %2d:\n"), part);
	if (part == 1) {
		/* re-write pkgmap, but exclude local pathnames */
		(void) snprintf(temp, sizeof (temp), "%s/pkgmap", pkgloc);
		if ((fp = fopen(temp, "w")) == NULL) {
			progerr(gettext(ERR_TEMP), errno);
			quit(99);
		}
		(void) fprintf(fp, ": %d %llu\n", nparts, limit);
		for (i = 0; eptlist[i]; i++) {
			svpt = eptlist[i]->ainfo.local;
			if (!strchr("sl", eptlist[i]->ftype))
				eptlist[i]->ainfo.local = NULL;
			if (ppkgmap(eptlist[i], fp)) {
				progerr(gettext(ERR_TEMP), errno);
				quit(99);
			}
			eptlist[i]->ainfo.local = svpt;
		}
		(void) fclose(fp);
		(void) fprintf(stderr, "%s\n", temp);
	}

	(void) snprintf(temp, sizeof (temp), "%s/pkginfo", pkgloc);
	if (copyf(svept->ainfo.local, temp, svept->cinfo.modtime))
		quit(1);
	(void) fprintf(stderr, "%s\n", temp);

	for (i = 0; i < eptnum; i++) {
		if (eptlist[i]->volno != part)
			continue;
		if (strchr("dxslcbp", eptlist[i]->ftype))
			continue;
		if (eptlist[i]->ftype == 'i') {
			if (eptlist[i] == svept)
				continue; /* don't copy pkginfo file */
			(void) snprintf(temp, sizeof (temp),
				"%s/install/%s", pkgloc,
				eptlist[i]->path);
			path = temp;
		} else
			path = srcpath(pkgloc, eptlist[i]->path, part, nparts);
		if (sflag) {
			if (slinkf(eptlist[i]->ainfo.local, path))
				quit(1);
		} else if (copyf(eptlist[i]->ainfo.local, path,
				eptlist[i]->cinfo.modtime)) {
			quit(1);
		}

		/*
		 * If the package file attributes can be sync'd up with
		 * the pkgmap, we fix the attributes here.
		 */
		if (*(eptlist[i]->ainfo.owner) != '$' &&
		    *(eptlist[i]->ainfo.group) != '$') {
			/* Clear dangerous bits. */
			eptlist[i]->ainfo.mode=
			    (eptlist[i]->ainfo.mode & S_IAMB);
			/*
			 * Make sure it can be read by the world and written
			 * by the owner.
			 */
			eptlist[i]->ainfo.mode |= 0644;
			if (!strchr("in", eptlist[i]->ftype)) {
				/* Set the safe attributes. */
				averify(1, &(eptlist[i]->ftype),
				    path, &(eptlist[i]->ainfo));
			}
		}

		(void) fprintf(stderr, "%s\n", path);
	}
}

static void
ckmissing(char *path, char type)
{
	static char	**dir;
	static int	ndir;
	char	*pt;
	int	i, found;

	if (dir == NULL) {
		dir = (char **)calloc(MALSIZ, sizeof (char *));
		if (dir == NULL) {
			progerr(gettext(ERR_MEMORY), errno);
			quit(99);
		}
	}

	if (strchr("dx", type)) {
		dir[ndir] = path;
		if ((++ndir % MALSIZ) == 0) {
			dir = (char **)realloc((void *)dir,
				(ndir+MALSIZ)*sizeof (char *));
			if (dir == NULL) {
				progerr(gettext(ERR_MEMORY), errno);
				quit(99);
			}
		}
		dir[ndir] = (char *)NULL;
	}

	pt = path;
	if (*pt == '/')
		pt++;
	while (pt = strchr(pt, '/')) {
		*pt = '\0';
		found = 0;
		for (i = 0; i < ndir; i++) {
			if (strcmp(path, dir[i]) == 0) {
				found++;
				break;
			}
		}
		if (!found) {
			logerr(gettext(WRN_MISSINGDIR), path);
			ckmissing(qstrdup(path), 'd');
		}
		*pt++ = '/';
	}
}

static int
slinkf(char *from, char *to)
{
	char	*pt;

	pt = to;
	while (pt = strchr(pt+1, '/')) {
		*pt = '\0';
		if (isdir(to) && mkdir(to, 0755)) {
			progerr(gettext(ERR_MKDIR), to);
			*pt = '/';
			return (-1);
		}
		*pt = '/';
	}
	if (symlink(from, to)) {
		progerr(gettext(ERR_SYMLINK), to);
		return (-1);
	}
	return (0);
}

static void
usage(void)
{
	(void) fprintf(stderr, gettext(ERR_USAGE), get_prog_name());
	exit(1);
	/*NOTREACHED*/
}

/*
 * valid_zone_attr:	Validates the zone attributes specified in
 *			pkginfo file for this package. The package
 *			can not be created with certain combinations
 *			of the attributes.
 */
static boolean_t
valid_zone_attr(struct cfent **eptlist)
{
	FILE		*pkginfoFP;
	boolean_t	all_zones;	/* pkg is "all zones" only */
	boolean_t	is_hollow;	/* pkg is "hollow" */
	boolean_t	this_zone;	/* pkg is "this zone" only */
	char 		pkginfoPath[PATH_MAX];	/* pkginfo file path */
	char		*pkgInst;
	int i;

	/* Path to pkginfo file within the package to be installed */

	this_zone = B_FALSE;
	for (i = 0; eptlist[i]; i++) {
		if (eptlist[i]->ftype != 'i')
			continue;
		if (strcmp(eptlist[i]->path, "pkginfo") == 0)
			(void) strcpy(pkginfoPath, eptlist[i]->ainfo.local);

		/*
		 * Check to see if this package has a request script. If this
		 * package does have a request script, then mark the package
		 * for installation in this zone only. Any package with a
		 * request script cannot be installed outside of the zone the
		 * pkgadd command is being run in, nor can such a package be
		 * installed as part of a new zone install. A new zone install
		 * must be non-interactive, which is required by all packages
		 * integrated into the Solaris WOS.
		 * If request file is set in prototype, then this_zone is TRUE.
		 */
		if (strcmp(eptlist[i]->path, "request") == 0)
			this_zone = B_TRUE;
	}

	/* Gather information from the pkginfo file */

	pkginfoFP = fopen(pkginfoPath, "r");

	if (pkginfoFP == NULL) {
		progerr(ERR_NO_PKG_INFOFILE, pkginfoPath, strerror(errno));
		return (B_FALSE);
	}

	if ((pkgInst = fpkgparam(pkginfoFP, "PKG")) == NULL) {
		progerr(gettext(ERR_NOPARAM), "PKG", pkginfoPath);
		return (B_FALSE);
	}


	/* Determine "HOLLOW" setting for this package */
	is_hollow = pkginfoParamTruth(pkginfoFP, PKG_HOLLOW_VARIABLE,
			"true", B_FALSE);

	/* Determine "ALLZONES" setting for this package */
	all_zones = pkginfoParamTruth(pkginfoFP, PKG_ALLZONES_VARIABLE,
			"true", B_FALSE);

	/* Determine "THISZONE" setting for this package, if no request file */
	if (!this_zone)
		this_zone = pkginfoParamTruth(pkginfoFP, PKG_THISZONE_VARIABLE,
			"true", B_FALSE);

	/* Close pkginfo file */
	(void) fclose(pkginfoFP);

	/*
	 * Validate zone attributes based on information gathered,
	 * and validate the three SUNW_PKG_ options:
	 *
	 * -----------------------------|---------------|
	 * <ALLZONES><HOLLOW><THISZONE> |  If Allowed   |
	 * ----1------------------------|---------------|
	 *		F F F		|	OK	|
	 *		F F T		|	OK	|
	 *		F T *		|	NO	|
	 * ----2------------------------|---------------|
	 *		T F F		|	OK	|
	 *		T T F		|	OK	|
	 *		T * T		|	NO	|
	 * -----------------------------|---------------|
	 */

	/* pkg "all zones" && "this zone" (#2) */

	if (all_zones && this_zone) {
		progerr(ERR_ALLZONES_AND_THISZONE, pkgInst,
		    PKG_ALLZONES_VARIABLE, PKG_THISZONE_VARIABLE);
		return (B_FALSE);
	}

	/* pkg "!all zones" && "hollow" (#1) */

	if ((!all_zones) && is_hollow) {
		progerr(ERR_NO_ALLZONES_AND_HOLLOW, pkgInst,
		    PKG_ALLZONES_VARIABLE, PKG_HOLLOW_VARIABLE);
		return (B_FALSE);
	}

	return (B_TRUE);
}



/* ============================================================================
 * SOURCE 64/98: minix4\exokernel\kernel_legacy\cmd\svr4pkg\pkgproto\main.c
 * Size: 12,559 bytes, Lines: 513
 * Hash: df0b74e70402...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

/* Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T */
/* All Rights Reserved */


#include <stdio.h>
#include <ctype.h>
#include <dirent.h>
#include <limits.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <pkgstrct.h>
#include <errno.h>
#include <locale.h>
#include <libintl.h>
#include <pkglib.h>
#include "libadm.h"
#include "libinst.h"

extern int	holdcinfo;

#define	WRN_SCARYLINK	"WARNING: <%s>, target of symlink <%s>, does not exist."

#define	ERR_PATHLONG	"path argument too long"
#define	ERR_CLASSLONG	"classname argument too long"
#define	ERR_CLASSCHAR	"bad character in classname"
#define	ERR_STAT	"unable to stat <%s>"
#define	ERR_WRITE	"write of entry failed"
#define	ERR_POPEN	"unable to create pipe to <%s>"
#define	ERR_PCLOSE	"unable to close pipe to <%s>"
#define	ERR_RDLINK	"unable to read link for <%s>"
#define	ERR_MEMORY	"memory allocation failure, errno=%d"

#define	LINK	1

struct link {
	char	*path;
	ino_t	ino;
	dev_t	dev;
	struct link *next;
};

static struct link *firstlink = (struct link *)0;
static struct link *lastlink = (struct link *)0;
static char *scan_raw_ln(char *targ_name, char *link_name);

static char	*def_class = "none";

static int	errflg = 0;
static int	iflag = 0;	/* follow symlinks */
static int	xflag = 0;	/* confirm contents of files */
static int	nflag = 0;
static char	construction[PATH_MAX], mylocal[PATH_MAX];

static void	findlink(struct cfent *ept, char *path, char *svpath);
static void	follow(char *path);
static void	output(char *path, int n, char *local);
static void	usage(void);

int
main(int argc, char *argv[])
{
	int c;
	char *pt, path[PATH_MAX];
	char	*abi_sym_ptr;
	extern char	*optarg;
	extern int	optind;

	(void) setlocale(LC_ALL, "");

#if !defined(TEXT_DOMAIN)	/* Should be defined by cc -D */
#define	TEXT_DOMAIN "SYS_TEST"
#endif
	(void) textdomain(TEXT_DOMAIN);

	(void) set_prog_name(argv[0]);

	while ((c = getopt(argc, argv, "xnic:?")) != EOF) {
		switch (c) {
		    case 'x':	/* include content info */
			xflag++;
			break;

		    case 'n':
			nflag++;
			break;

		    case 'c':	/* assign class */
			def_class = optarg;
			/* validate that classname is acceptable */
			if (strlen(def_class) > (size_t)CLSSIZ) {
				progerr(gettext(ERR_CLASSLONG));
				exit(1);
			}
			for (pt = def_class; *pt; pt++) {
				if (!isalpha(*pt) && !isdigit(*pt)) {
					progerr(gettext(ERR_CLASSCHAR));
					exit(1);
				}
			}
			break;

		    case 'i':	/* follow symlinks */
			iflag++;
			break;

		    default:
			usage();
		}
	}

	if (iflag) {
		/* follow symlinks */
		set_nonABI_symlinks();
	} else {
		/* bug id 4244631, not ABI compliant */
		abi_sym_ptr = getenv("PKG_NONABI_SYMLINKS");
		if (abi_sym_ptr && strncasecmp(abi_sym_ptr, "TRUE", 4) == 0) {
			set_nonABI_symlinks();
		}
	}
	holdcinfo = !xflag;
	if (optind == argc) {
		/* take path list from stdin */
		while (fgets(path, sizeof (path), stdin) != (char *)NULL) {
			output(path, 0, NULL);
		}
	} else {
		while (optind < argc) {
			follow(argv[optind++]);
		}
	}

	return (errflg ? 1 : 0);
}

static void
output(char *path, int n, char *local)
{
	char		mypath[PATH_MAX];
	int		len;
	int		s;
	struct cfent	entry;

	/*
	 * remove any trailing newline characters from the end of path
	 */

	len = strlen(path);
	while ((len > 0) && (path[len-1] == '\n')) {
		path[--len] = '\0';
	}

	entry.volno = 0;
	entry.ftype = '?';
	entry.path = mypath;
	(void) strlcpy(entry.pkg_class, def_class, sizeof (entry.pkg_class));
	(void) strlcpy(entry.path, path, PATH_MAX);
	entry.ainfo.local = NULL;
	entry.ainfo.mode = BADMODE;
	(void) strlcpy(entry.ainfo.owner, BADOWNER, sizeof (entry.ainfo.owner));
	(void) strlcpy(entry.ainfo.group, BADGROUP, sizeof (entry.ainfo.group));
	errflg = 0;

	if (xflag) {
		entry.ftype = '?';
		if (cverify(0, &entry.ftype, path, &entry.cinfo, 1)) {
			errflg++;
			logerr(gettext("ERROR: %s"), path);
			logerr(getErrbufAddr());
			return;
		}
	}

	/*
	 * Use averify to figure out the attributes. This has trouble
	 * divining the identity of a symlink which points to a
	 * non-existant target. For that reason, if it comes back as
	 * an existence problem, we fake in a symlink and see if averify
	 * likes that. If it does, all we have is a risky symlink.
	 */
	if ((s = averify(0, &entry.ftype, path, &entry.ainfo)) == VE_EXIST &&
	    !iflag) {
		entry.ftype = 's';	/* try again assuming symlink */
		/* try to read what it points to */
		if ((s = readlink(path, mylocal, PATH_MAX)) > 0) {
			mylocal[s] = '\000';	/* terminate it */
			entry.ainfo.local = mylocal;
			if (averify(0, &entry.ftype, path, &entry.ainfo)) {
				errflg++;
			} else
				/* It's a link to a file not in this package. */
				ptext(stderr, gettext(WRN_SCARYLINK),
				    mylocal, path);
		} else {
			errflg++;
		}
	} else if (s != 0 && s != VE_CONT)
		errflg++;

	if (errflg) {
		logerr(gettext("ERROR: %s"), path);
		logerr(getErrbufAddr());
		return;
	}

	if (n) {
		/* replace first n characters with 'local' */
		if (strchr("fev", entry.ftype)) {
			entry.ainfo.local = mylocal;
			(void) strlcpy(entry.ainfo.local, entry.path,
				PATH_MAX);
			canonize(entry.ainfo.local);
		}
		if (local[0]) {
			entry.ainfo.local = mylocal;
			(void) strlcpy(entry.path, local, PATH_MAX);
			(void) strcat(entry.path, path+n);
		} else
			(void) strlcpy(entry.path,
				(path[n] == '/') ? path+n+1 : path+n,
				PATH_MAX);
	}

	canonize(entry.path);
	if (entry.path[0]) {
		findlink(&entry, path, entry.path);
		if (strchr("dcbp", entry.ftype) ||
		(nflag && !strchr("sl", entry.ftype)))
			entry.ainfo.local = NULL;
		if (ppkgmap(&entry, stdout)) {
			progerr(gettext(ERR_WRITE));
			exit(99);
		}
	}
}

static void
follow(char *path)
{
	struct stat stbuf;
	FILE	*pp;
	char	*pt,
		local[PATH_MAX],
		newpath[PATH_MAX],
		cmd[PATH_MAX+32];
	int n;

	errflg = 0;

	if (pt = strchr(path, '=')) {
		*pt++ = '\0';
		n = ((unsigned int)pt - (unsigned int)path - 1);
		if (n >= PATH_MAX) {
			progerr(gettext(ERR_PATHLONG));
			errflg++;
			return;
		}

		n = strlen(pt);

		if (n < PATH_MAX) {
			(void) strlcpy(local, pt, sizeof (local));
			n = strlen(path);
		} else {
			progerr(gettext(ERR_PATHLONG));
			errflg++;
			return;
		}
	} else {
		n = 0;
		local[0] = '\0';
	}

	if (stat(path, &stbuf)) {
		progerr(gettext(ERR_STAT), path);
		errflg++;
		return;
	}

	if (stbuf.st_mode & S_IFDIR) {
		(void) snprintf(cmd, sizeof (cmd), "find %s -print", path);
		if ((pp = popen(cmd, "r")) == NULL) {
			progerr(gettext(ERR_POPEN), cmd);
			exit(1);
		}
		while (fscanf(pp, "%[^\n]\n", newpath) == 1)
			output(newpath, n, local);
		if (pclose(pp)) {
			progerr(gettext(ERR_PCLOSE), cmd);
			errflg++;
		}
	} else
		output(path, n, local);
}

/*
 * Scan a raw link for origination errors. Given
 *	targ_name = hlink/path/file1
 *		and
 *	link_name = hlink/path/file2
 * we don't want the link to be verbatim since link_name must be relative
 * to it's source. This functions checks for identical directory paths
 * and if it's clearly a misplaced relative path, the duplicate
 * directories are stripped. This is necessary because pkgadd is actually
 * in the source directory (hlink/path) when it creates the link.
 *
 * NOTE : The buffer we get with targ_name is going to be used later
 * and cannot be modified. That's why we have yet another PATH_MAX
 * size buffer in this function.
 */
static char *
scan_raw_ln(char *targ_name, char *link_name)
{
	char *const_ptr;	/* what we return */
	char *file_name;	/* name of the file in link_name */
	char *this_dir;		/* current directory in targ_name */
	char *next_dir;		/* next directory in targ_name  */
	char *targ_ptr;		/* current character in targ_name */

	const_ptr = targ_name;	/* Point to here 'til we know it's different. */

	/*
	 * If the link is absolute or it is in the current directory, no
	 * further testing necessary.
	 */
	if (RELATIVE(targ_name) &&
	    (file_name = strrchr(link_name, '/')) != NULL) {

		/*
		 * This will be walked down to the highest directory
		 * not common to both the link and the target.
		 */
		targ_ptr = targ_name;

		/*
		 * At this point targ_name is a relative path through at
		 * least one directory.
		 */
		this_dir = targ_ptr;	/* first directory in targ_name */
		file_name++;		/* point to the name not the '/' */

		/*
		 * Scan across the pathname until we reach a different
		 * directory or the final file name.
		 */
		do {
			size_t str_size;

			next_dir = strchr(targ_ptr, '/');
			if (next_dir)
				next_dir++;	/* point to name not '/' */
			else	/* point to the end of the string */
				next_dir = targ_ptr+strlen(targ_ptr);

			/* length to compare */
			str_size = ((ptrdiff_t)next_dir - (ptrdiff_t)this_dir);

			/*
			 * If both paths begin with the same directory, then
			 * skip that common directory in both the link and
			 * the target.
			 */
			if (strncmp(this_dir, link_name, str_size) == 0) {
				/* point to the target so far */
				const_ptr = this_dir = next_dir;
				/* Skip past it in the target */
				targ_ptr = (char *)(targ_ptr+str_size);
				/* Skip past it in the link */
				link_name = (char *)(link_name+str_size);
			/*
			 * If these directories don't match then the
			 * directory above is the lowest common directory. We
			 * need to construct a relative path from the lowest
			 * child up to that directory.
			 */
			} else {
				int d = 0;
				char *dptr = link_name;

				/* Count the intermediate directories. */
				while ((dptr = strchr(dptr, '/')) != NULL) {
					dptr++;
					d++;
				}
				/*
				 * Now targ_ptr is pointing to the fork in
				 * the path and dptr is pointing to the lowest
				 * child in the link. We now insert the
				 * appropriate number of "../'s" to get to
				 * the first common directory. We'll
				 * construct this in the construction
				 * buffer.
				 */
				if (d) {
					char *tptr;

					const_ptr = tptr = construction;
					while (d--) {
						(void) strlcpy(tptr,
							"../", PATH_MAX);
						tptr += 3;
					}
					(void) strlcpy(tptr, targ_ptr,
						PATH_MAX);
				}
				break;		/* done */
			}
		} while (link_name != file_name);	/* at file name */
	}

	return (const_ptr);
}

static void
findlink(struct cfent *ept, char *path, char *svpath)
{
	struct stat	statbuf;
	struct link	*link, *new;
	char		buf[PATH_MAX];
	int		n;

	if (lstat(path, &statbuf)) {
		progerr(gettext(ERR_STAT), path);
		errflg++;
	}
	if ((statbuf.st_mode & S_IFMT) == S_IFLNK) {
		if (!iflag) {
			ept->ainfo.local = mylocal;
			ept->ftype = 's';
			n = readlink(path, buf, PATH_MAX);
			if (n <= 0) {
				progerr(gettext(ERR_RDLINK), path);
				errflg++;
				(void) strlcpy(ept->ainfo.local,
					"unknown", PATH_MAX);
			} else {
				(void) strncpy(ept->ainfo.local, buf, n);
				ept->ainfo.local[n] = '\0';
			}
		}
		return;
	}

	if (stat(path, &statbuf))
		return;
	if (statbuf.st_nlink <= 1)
		return;

	for (link = firstlink; link; link = link->next) {
		if ((statbuf.st_ino == link->ino) &&
		(statbuf.st_dev == link->dev)) {
			ept->ftype = 'l';
			ept->ainfo.local = mylocal;
			(void) strlcpy(ept->ainfo.local,
					scan_raw_ln(link->path, ept->path),
					PATH_MAX);
			return;
		}
	}
	if ((new = (struct link *)calloc(1, sizeof (struct link))) == NULL) {
		progerr(gettext(ERR_MEMORY), errno);
		exit(1);
	}

	if (firstlink) {
		lastlink->next = new;
		lastlink = new;
	} else
		firstlink = lastlink = new;

	new->path = strdup(svpath);
	new->ino = statbuf.st_ino;
	new->dev = statbuf.st_dev;
}

static void
usage(void)
{
	(void) fprintf(stderr,
	    gettext("usage: %s [-i] [-c class] [path ...]\n"), get_prog_name());
	exit(1);
	/*NOTREACHED*/
}



/* ============================================================================
 * SOURCE 65/98: minix4\exokernel\kernel_legacy\cmd\svr4pkg\pkgremove\main.c
 * Size: 32,793 bytes, Lines: 1,350
 * Hash: c824f76d2f64...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (c) 2018 Peter Tribble.
 */

/*
 * Copyright (c) 1989, 2010, Oracle and/or its affiliates. All rights reserved.
 */

/* Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T */
/* All Rights Reserved */


#include <stdio.h>
#include <limits.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <signal.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <pkgstrct.h>
#include <pkginfo.h>
#include <pkglocs.h>
#include <locale.h>
#include <libintl.h>
#include <assert.h>
#include <cfext.h>
#include <instzones_api.h>
#include <pkglib.h>
#include <install.h>
#include <libinst.h>
#include <libadm.h>
#include <messages.h>

struct cfent **eptlist;
extern int	eptnum;

extern char	*pkgdir;
extern char	**environ;

/* quit.c */
extern sighdlrFunc_t	*quitGetTrapHandler(void);
extern void		quitSetSilentExit(boolean_t a_silentExit);
extern void		quitSetZoneName(char *a_zoneName);



/* check.c */
extern void	rcksetPreremoveCheck(boolean_t);
extern void	rcksetZoneName(char *);
extern int	rckpriv(void);
extern int	rckdepend(void);
extern int	rckrunlevel(void);

/* delmap.c */
extern int delmap(int flag, char *pkginst, PKGserver *server, VFP_T **tfp);

#define	DEFPATH		"/sbin:/usr/sbin:/usr/bin"

#if !defined(TEXT_DOMAIN)	/* Should be defined by cc -D */
#define	TEXT_DOMAIN "SYS_TEST"
#endif

/* This is the text for the "-O parent-zone-name=" option */

#define	PARENTZONENAME	"parent-zone-name="
#define	PARENTZONENAME_LEN	((sizeof (PARENTZONENAME))-1)

/* This is the text for the "-O parent-zone-type=" option */

#define	PARENTZONETYPE	"parent-zone-type="
#define	PARENTZONETYPE_LEN	((sizeof (PARENTZONETYPE))-1)

struct	admin adm;	/* holds info about installation admin */
int	dreboot;	/* non-zero if reboot required after installation */
int	ireboot;	/* non-zero if immediate reboot required */
int	failflag;	/* non-zero if fatal error has occurred */
int	warnflag;	/* non-zero if non-fatal error has occurred */
int	pkgverbose;	/* non-zero if verbose mode is selected */
int	started;
int	nocnflct = 0;	/* pkgdbmerg needs this defined */
int	nosetuid = 0;	/* pkgdbmerg needs this defined */

char	*pkginst;	/* current package (source) instance to process */

int	dbchg;
char	*msgtext;
char	pkgloc[PATH_MAX];

/*
 * The following variable is the name of the device to which stdin
 * is connected during execution of a procedure script. /dev/null is
 * correct for all ABI compliant packages. For non-ABI-compliant
 * packages, the '-o' command line switch changes this to /dev/tty
 * to allow user interaction during these scripts. -- JST
 */
static char	*script_in = PROC_STDIN;	/* assume ABI compliance */

static char	*client_mntdir;		/* mount point for client's basedir */
static char	pkgbin[PATH_MAX],
		rlockfile[PATH_MAX],
		*admnfile,		/* file to use for installation admin */
		*tmpdir;		/* location to place temporary files */

static void		ckreturn(int retcode, char *msg);
static void		rmclass(char *aclass, int rm_remote, char *a_zoneName);
static void		usage(void);

/*
 * Set by -O debug: debug output is enabled?
 */
static boolean_t	debugFlag = B_FALSE;

/*
 * Set by -O preremovecheck: do remove dependency checking only
 */
static boolean_t	preremoveCheck = B_FALSE;

/* Set by -O parent-zone-name= */

static char		*parentZoneName = (char *)NULL;

/* Set by -O parent-zone-type= */

static char		*parentZoneType = (char *)NULL;

static int	nointeract;	/* != 0 no interaction with user should occur */



int
main(int argc, char *argv[])
{
	FILE		*fp;
	char		*abi_comp_ptr;
	char		*abi_sym_ptr;
	char		*p;
	char		*prog_full_name = NULL;
	char		*pt;
	char		*value;
	char		*vfstab_file = NULL;
	char		*zoneName = (char *)NULL;
	char		cmdbin[PATH_MAX];
	char		param[MAX_PKG_PARAM_LENGTH];
	char		path[PATH_MAX];
	char		script[PATH_MAX];
	int		c;
	int		err;
	int		fd;
	int		i;
	int		map_client = 1;
	int		n;
	int		nodelete = 0;	/* do not delete file or run scripts */
	int		pkgrmremote = 0;	/* dont remove remote objects */
	struct sigaction	nact;
	struct sigaction	oact;
	PKGserver	pkgserver = NULL;
	VFP_T		*tmpfp;

	/* reset contents of all default paths */

	(void) memset(cmdbin, '\0', sizeof (cmdbin));

	/* initialize locale environment */

	(void) setlocale(LC_ALL, "");
	(void) textdomain(TEXT_DOMAIN);

	/* initialize program name */

	prog_full_name = argv[0];
	(void) set_prog_name(argv[0]);

	/* tell spmi zones interface how to access package output functions */

	z_set_output_functions(echo, echoDebug, progerr);

	/* exit if not root */

	if (getuid()) {
		progerr(ERR_NOT_ROOT, get_prog_name());
		exit(1);
		/* NOTREACHED */
	}

	/* Read PKG_INSTALL_ROOT from the environment, if it's there. */

	if (!set_inst_root(getenv("PKG_INSTALL_ROOT"))) {
		progerr(ERR_ROOT_SET);
		exit(1);
	}

	pkgserversetmode(DEFAULTMODE);

	/* parse command line options */

	while ((c = getopt(argc, argv, "?Aa:b:FMN:nO:oR:V:vy")) != EOF) {
		switch (c) {
		/*
		 * Same as pkgrm: Allow admin to remove package objects from
		 * a shared area from a reference client.
		 */
		case 'A':
			pkgrmremote++;
			break;

		/*
		 * Same as pkgrm: Use the installation
		 * administration file, admin, in place of the
		 * default admin file. pkgrm first looks in the
		 * current working directory for the administration
		 * file.  If the specified administration file is not
		 * in the current working directory, pkgrm looks in
		 * the /var/sadm/install/admin directory for the
		 * administration file.
		 */
		case 'a':
			admnfile = flex_device(optarg, 0);
			break;

		/*
		 * Same as pkgrm: location where package executables
		 * can be found - default is /usr/sadm/install/bin.
		 */
		case 'b':
			if (!path_valid(optarg)) {
				progerr(ERR_PATH, optarg);
				exit(1);
			}
			if (isdir(optarg) != 0) {
				char *p = strerror(errno);
				progerr(ERR_CANNOT_USE_DIR, optarg, p);
				exit(1);
			}
			(void) strlcpy(cmdbin, optarg, sizeof (cmdbin));
			break;

		/*
		 * Same as pkgrm: suppresses the removal of any
		 * files and any class action scripts, and suppresses
		 * the running of any class action scripts.  The
		 * package files remain but the package looks like it
		 * is not installed. This is mainly for use by the
		 * upgrade process.
		 */
		case 'F':
			nodelete++;
			break;

		/*
		 * Same as pkgrm: Instruct pkgrm not to use the
		 * $root_path/etc/vfstab file for determining the
		 * client's mount points. This option assumes the
		 * mount points are correct on the server and it
		 * behaves consistently with Solaris 2.5 and earlier
		 * releases.
		 */
		case 'M':
			map_client = 0;
			break;

		/*
		 * Different from pkgrm: specify program name to use
		 * for messages.
		 */
		case 'N':
			(void) set_prog_name(optarg);
			break;

		/*
		 * Same as pkgrm: package removal occurs in
		 * non-interactive mode.  Suppress output of the list of
		 * removed files. The default mode is interactive.
		 */
		case 'n':
			nointeract++;
			(void) echoSetFlag(B_FALSE);
			break;

		/*
		 * Almost same as pkgrm: the -O option allows the behavior
		 * of the package tools to be modified. Recognized options:
		 * -> debug
		 * ---> enable debugging output
		 * -> preremovecheck
		 * ---> perform a "pre removal" check of the specified
		 * ---> package - suppress all regular output and cause a
		 * ---> series of one or more "name=value" pair format lines
		 * ---> to be output that describes the "removability" of
		 * ---> the specified package
		 * -> enable-hollow-package-support
		 * --> Enable hollow package support. When specified, for any
		 * --> package that has SUNW_PKG_HOLLOW=true:
		 * --> Do not calculate and verify package size against target
		 * --> Do not run any package procedure or class action scripts
		 * --> Do not create or remove any target directories
		 * --> Do not perform any script locking
		 * --> Do not install or uninstall any components of any package
		 * --> Do not output any status or database update messages
		 */
		case 'O':
			for (p = strtok(optarg, ","); p != (char *)NULL;
			    p = strtok(NULL, ",")) {

				/* process debug option */

				if (strcmp(p, "debug") == 0) {
					/* set debug flag/enable debug output */
					debugFlag = B_TRUE;
					(void) echoDebugSetFlag(debugFlag);

					/* debug info on arguments to pkgadd */
					for (n = 0; n < argc && argv[n]; n++) {
						echoDebug(DBG_ARG, n, argv[n]);
					}

					continue;
				}

				/* process enable-hollow-package-support opt */

				if (strcmp(p,
				    "enable-hollow-package-support") == 0) {
					set_depend_pkginfo_DB(B_TRUE);
					continue;
				}

				/* process preremovecheck option */

				if (strcmp(p, "preremovecheck") == 0) {
					preremoveCheck = B_TRUE;
					nointeract++;	/* -n */
					nodelete++;	/* -F */
					quitSetSilentExit(B_TRUE);
					continue;
				}

				/* process addzonename option */

				if (strcmp(p, "addzonename") == 0) {
					zoneName = z_get_zonename();
					quitSetZoneName(zoneName);
					continue;
				}

				/* process parent-zone-name option */

				if (strncmp(p, PARENTZONENAME,
				    PARENTZONENAME_LEN) == 0) {
					parentZoneName = p+PARENTZONENAME_LEN;
					continue;
				}

				/* process parent-zone-type option */

				if (strncmp(p, PARENTZONETYPE,
				    PARENTZONETYPE_LEN) == 0) {
					parentZoneType = p+PARENTZONETYPE_LEN;
					continue;
				}

				if (strncmp(p, PKGSERV_MODE,
				    PKGSERV_MODE_LEN) == 0) {
					pkgserversetmode(pkgparsemode(p +
					    PKGSERV_MODE_LEN));
					continue;
				}
				/* option not recognized - issue warning */

				progerr(ERR_INVALID_O_OPTION, p);
				continue;
			}
			break;

		/*
		 * Different from pkgrm: This is an old non-ABI package
		 */

		case 'o':
			script_in = PROC_XSTDIN;
			break;

		/*
		 * Same as pkgrm: defines the full path name of a
		 * directory to use as the root_path.  All files,
		 * including package system information files, are
		 * relocated to a directory tree starting in the
		 * specified root_path.
		 */
		case 'R':
			if (!set_inst_root(optarg)) {
				progerr(ERR_ROOT_CMD);
				exit(1);
			}
			break;

		/*
		 * Same as pkgrm: allow admin to establish the client
		 * filesystem using a vfstab-like file of stable format.
		 */
		case 'V':
			vfstab_file = flex_device(optarg, 2);
			map_client = 1;
			break;

		/*
		 * Same as pkgrm: trace all of the scripts that
		 * get executed by pkgrm, located in the
		 * pkginst/install directory. This option is used for
		 * debugging the procedural and non-procedural
		 * scripts.
		 */
		case 'v':
			pkgverbose++;
			break;

		/*
		 * Different from pkgrm: process this package using
		 * old non-ABI symlinks
		 */
		case 'y':
			set_nonABI_symlinks();
			break;

		default:
			usage();
			/*NOTREACHED*/
			/*
			 * Although usage() calls a noreturn function,
			 * needed to add return (1);  so that main() would
			 * pass compilation checks. The statement below
			 * should never be executed.
			 */
			return (1);
		}
	}

	/*
	 * ********************************************************************
	 * validate command line options
	 * ********************************************************************
	 */

	(void) echoDebugSetFlag(debugFlag);
	(void) log_set_verbose(debugFlag);

	if (z_running_in_global_zone()) {
		echoDebug(DBG_ENTRY_IN_GZ, prog_full_name);
	} else {
		echoDebug(DBG_ENTRY_IN_LZ, prog_full_name, getzoneid(),
		    z_get_zonename());
	}

	/* establish cmdbin path */

	if (cmdbin[0] == '\0') {
		(void) strlcpy(cmdbin, PKGBIN, sizeof (cmdbin));
	}

	/* Read the mount table */

	if (get_mntinfo(map_client, vfstab_file)) {
		quit(99);
	}

	/*
	 * This function defines the standard /var/... directories used later
	 * to construct the paths to the various databases.
	 */

	set_PKGpaths(get_inst_root());

	/*
	 * If this is being removed from a client whose /var filesystem is
	 * mounted in some odd way, remap the administrative paths to the
	 * real filesystem. This could be avoided by simply mounting up the
	 * client now; but we aren't yet to the point in the process where
	 * modification of the filesystem is permitted.
	 */
	if (is_an_inst_root()) {
		int fsys_value;

		fsys_value = fsys(get_PKGLOC());
		if (use_srvr_map_n(fsys_value))
			set_PKGLOC(server_map(get_PKGLOC(), fsys_value));

		fsys_value = fsys(get_PKGADM());
		if (use_srvr_map_n(fsys_value))
			set_PKGADM(server_map(get_PKGADM(), fsys_value));
	} else {
		pkgrmremote = 0;	/* Makes no sense on local host. */
	}

	/*
	 * hook SIGINT and SIGHUP interrupts into quit.c's trap handler
	 */

	/* hold SIGINT/SIGHUP interrupts */

	(void) sighold(SIGHUP);
	(void) sighold(SIGINT);

	/* connect quit.c:trap() to SIGINT */

	nact.sa_handler = quitGetTrapHandler();
	nact.sa_flags = SA_RESTART;
	(void) sigemptyset(&nact.sa_mask);

	(void) sigaction(SIGINT, &nact, &oact);

	/* connect quit.c:trap() to SIGHUP */

	nact.sa_handler = quitGetTrapHandler();
	nact.sa_flags = SA_RESTART;
	(void) sigemptyset(&nact.sa_mask);

	(void) sigaction(SIGHUP, &nact, &oact);

	/* release hold on signals */

	(void) sigrelse(SIGHUP);
	(void) sigrelse(SIGINT);

	pkginst = argv[optind++];
	if (optind != argc) {
		usage();
	}

	/* validate package software database (contents) file */

	if (vcfile() == 0) {
		quit(99);
	}

	/*
	 * Acquire the package lock - currently at "remove initialization"
	 */

	if (!lockinst(get_prog_name(), pkginst, "remove-initial")) {
		quit(99);
	}

	/* establish temporary directory to use */

	tmpdir = getenv("TMPDIR");
	if (tmpdir == NULL) {
		tmpdir = P_tmpdir;
	}

	echoDebug(DBG_PKGREMOVE_TMPDIR, tmpdir);

	/*
	 * Initialize installation admin parameters by reading
	 * the adminfile.
	 */

	echoDebug(DBG_PKGREMOVE_ADMINFILE, admnfile ? admnfile : "");
	setadminFile(admnfile);

	/*
	 * about to perform first operation that could be modified by the
	 * preremove check option - if preremove check is selected (that is,
	 * only gathering dependencies), then output a debug message to
	 * indicate that the check is beginning. Also turn echo() output
	 * off and set various other flags.
	 */

	if (preremoveCheck == B_TRUE) {
		(void) echoSetFlag(B_FALSE);
		echoDebug(DBG_PKGREMOVE_PRERMCHK, pkginst ? pkginst : "",
		    zoneName ? zoneName : "global");
		rcksetPreremoveCheck(B_TRUE);
		rcksetZoneName(zoneName);
	}

	(void) snprintf(pkgloc, sizeof (pkgloc), "%s/%s", get_PKGLOC(),
	    pkginst);
	(void) snprintf(pkgbin, sizeof (pkgbin), "%s/install", pkgloc);
	(void) snprintf(rlockfile, sizeof (rlockfile), "%s/!R-Lock!", pkgloc);

	if (chdir(pkgbin)) {
		progerr(ERR_CHDIR, pkgbin);
		quit(99);
	}

	echo(MSG_PREREMOVE_REMINST, pkginst);

	/*
	 * if a lock file is present, then a previous attempt to remove this
	 * package may have been unsuccessful.
	 */

	if (access(rlockfile, F_OK) == 0) {
		echo(ERR_UNSUCC);
		echoDebug(DBG_PKGINSTALL_HAS_LOCKFILE, pkginst, rlockfile,
		    zoneName ? zoneName : "global");
	}

	/*
	 * Process all parameters from the pkginfo file
	 * and place them in the execution environment
	 */

	/* Add DB retreival of the pkginfo parameters here */
	(void) snprintf(path, sizeof (path), "%s/pkginfo", pkgloc);
	if ((fp = fopen(path, "r")) == NULL) {
		progerr(ERR_PKGINFO, path);
		quit(99);
	}

	/* Mount up the client if necessary. */
	if (map_client && !mount_client()) {
		logerr(MSG_MANMOUNT);
	}

	/* Get mount point of client */
	client_mntdir = getenv("CLIENT_MNTDIR");

	getuserlocale();

	/*
	 * current environment has been read; clear environment out
	 * so putparam() can be used to populate the new environment
	 * to be passed to any executables/scripts.
	 */

	environ = NULL;

	if (nonABI_symlinks()) {
		putparam("PKG_NONABI_SYMLINKS", "TRUE");
	}

	/*
	 * read the pkginfo file and fix any PKGSAV path - the correct
	 * install_root will be prepended to the existing path.
	 */

	param[0] = '\0';
	while (value = fpkgparam(fp, param)) {
		int validx = 0;
		char *newvalue;

		/* strip out any setting of PATH */

		if (strcmp(param, "PATH") == 0) {
			free(value);
			param[0] = '\0';
			continue;
		}

		/* if not PKGSAV then write out unchanged */

		if (strcmp(param, "PKGSAV") != 0) {
			putparam(param, value);
			free(value);
			param[0] = '\0';
			continue;
		}

		/*
		 * PKGSAV parameter found - interpret the directory:
		 * If in host:path format or marked with the leading "//",
		 * then there is no client-relative translation - take it
		 * literally later rather than use fixpath().
		 */

		if (strstr(value, ":/")) {
			/* no modification needed */
			validx = 0;
		} else if (strstr(value, "//") == value) {
			validx = 1;
		} else if (is_an_inst_root()) {
			/* This PKGSAV needs to be made client-relative. */
			newvalue = fixpath(value);
			free(value);
			value = newvalue;
		}
		putparam(param, value+validx);
		free(value);
		param[0] = '\0';
	}

	(void) fclose(fp);

	/* write parent condition information to environment */

	putConditionInfo(parentZoneName, parentZoneType);

	putuserlocale();

	/*
	 * Now do all the various setups based on ABI compliance
	 */

	/* Read the environment provided by the pkginfo file */
	abi_comp_ptr = getenv("NONABI_SCRIPTS");

	/* if not ABI compliant set global flag */
	abi_sym_ptr = getenv("PKG_NONABI_SYMLINKS");
	if (abi_sym_ptr && strncasecmp(abi_sym_ptr, "TRUE", 4) == 0) {
		set_nonABI_symlinks();
	}

	/*
	 * If pkginfo says it's not compliant then set non_abi_scripts.
	 */
	if (abi_comp_ptr && strncmp(abi_comp_ptr, "TRUE", 4) == 0) {
		script_in = PROC_XSTDIN;
	}

	/*
	 * Since this is a removal, we can tell whether it's absolute or
	 * not from the resident pkginfo file read above.
	 */
	if ((err = set_basedirs((getenv("BASEDIR") != NULL), adm.basedir,
	    pkginst, nointeract)) != 0) {
		quit(err);
	}

	/*
	 * See if were are removing a package that only wants to update
	 * the database or only remove files associated with CAS's. We
	 * only check the PKG_HOLLOW_VARIABLE variable if told to do so by
	 * the caller.
	 */

	if (is_depend_pkginfo_DB()) {
		pt = getenv(PKG_HOLLOW_VARIABLE);

		if ((pt != NULL) && (strncasecmp(pt, "true", 4) == 0)) {
			echoDebug(DBG_PKGREMOVE_HOLLOW_ENABLED);

			/*
			 * this is a hollow package and hollow package support
			 * is enabled -- override admin settings to suppress
			 * checks that do not make sense since no scripts will
			 * be executed and no files will be removed.
			 */

			setadminSetting("conflict", "nocheck");
			setadminSetting("setuid", "nocheck");
			setadminSetting("action", "nocheck");
			setadminSetting("partial", "nocheck");
			setadminSetting("space", "nocheck");
			setadminSetting("authentication", "nocheck");
		} else {
			echoDebug(DBG_PKGREMOVE_HOLLOW_DISABLED);
			set_depend_pkginfo_DB(B_FALSE);
		}
	}

	put_path_params();

	/* If client mount point, add it to pkgremove environment */

	if (client_mntdir != NULL) {
		putparam("CLIENT_MNTDIR", client_mntdir);
	}

	/* Establish the class list and the class attributes. */

	if ((value = getenv("CLASSES")) != NULL) {
		cl_sets(qstrdup(value));
	} else {
		progerr(ERR_CLASSES, path);
		quit(99);
	}

	/* establish path and tmpdir */

	if (cmdbin[0] == '\0') {
		(void) strlcpy(cmdbin, PKGBIN, sizeof (cmdbin));
	}

	(void) snprintf(path, sizeof (path), "%s:%s", DEFPATH, cmdbin);
	putparam("PATH", path);

	putparam("TMPDIR", tmpdir);

	/*
	 * Check ulimit requirement (provided in pkginfo). The purpose of
	 * this limit is to terminate pathological file growth resulting from
	 * file edits in scripts. It does not apply to files in the pkgmap
	 * and it does not apply to any database files manipulated by the
	 * installation service.
	 */
	if (value = getenv("ULIMIT")) {
		if (assign_ulimit(value) == -1) {
			progerr(ERR_BADULIMIT, value);
			warnflag++;
		}
		putparam("PKG_ULIMIT", "TRUE");
	}

	/*
	 * If only gathering dependencies, check and output status of all
	 * remaining dependencies and exit.
	 */

	if (preremoveCheck == B_TRUE) {
		/*
		 * make sure current runlevel is appropriate
		 */

		(void) fprintf(stdout, "rckrunlevel=%d\n", rckrunlevel());

		/*
		 * determine if any packaging scripts provided with
		 * this package will execute as a priviledged user
		 */

		(void) fprintf(stdout, "rckpriv=%d\n", rckpriv());

		/*
		 * verify package dependencies
		 */

		(void) fprintf(stdout, "rckdepend=%d\n", rckdepend());

		/*
		 * ****** preremove check done - exit ******
		 */

		echoDebug(DBG_PKGREMOVE_PRERMCHK_OK);
		quit(0);
		/*NOTREACHED*/
	}

	/*
	 * Not gathering dependencies only, proceed to check dependencies
	 * and continue with the package removal operation.
	 */

	/*
	 * make sure current runlevel is appropriate
	 */

	n = rckrunlevel();

	if (n != 0) {
		quit(n);
		/* NOTREACHED */
	}

	/*
	 * determine if any packaging scripts provided with
	 * this package will execute as a priviledged user
	 */

	n = rckpriv();

	if (n != 0) {
		quit(n);
		/* NOTREACHED */
	}

	/*
	 * verify package dependencies
	 */
	n = rckdepend();

	if (n != 0) {
		quit(n);
		/* NOTREACHED */
	}

	/*
	 * *********************************************************************
	 * the actual removal of the package begins here
	 * *********************************************************************
	 */

	/*
	 * create lockfile to indicate start of removal
	 */
	started++;
	if ((fd = open(rlockfile, O_WRONLY|O_CREAT|O_TRUNC, 0644)) < 0) {
		progerr(ERR_LOCKFILE, rlockfile);
		quit(99);
	} else {
		(void) close(fd);
	}

	if (zoneName == (char *)NULL) {
		echo(MSG_PKGREMOVE_PROCPKG_GZ);
		echoDebug(DBG_PKGREMOVE_PROCPKG_GZ, pkginst, rlockfile);
	} else {
		echo(MSG_PKGREMOVE_PROCPKG_LZ, zoneName);
		echoDebug(DBG_PKGREMOVE_PROCPKG_LZ, pkginst, rlockfile,
		    zoneName);
	}
	if (delmap(0, pkginst, &pkgserver, &tmpfp) != 0) {
		progerr(ERR_DB_QUERY, pkginst);
		quit(99);
	}

	/*
	 * Run a preremove script if one is provided by the package.
	 * Don't execute preremove script if only updating the DB.
	 * Don't execute preremove script if files are not being deleted.
	 */

	/* update the lock - at the preremove script */
	lockupd("preremove");

	/* execute preremove script if one is provided */
	(void) snprintf(script, sizeof (script), "%s/preremove", pkgbin);
	if (access(script, F_OK) != 0) {
		/* no script present */
		echoDebug(DBG_PKGREMOVE_POC_NONE, pkginst,
		    zoneName ? zoneName : "global");
	} else if (nodelete) {
		/* not deleting files: skip preremove script */
		echoDebug(DBG_PKGREMOVE_POC_NODEL, pkginst, script,
		    zoneName ? zoneName : "global");
	} else if (is_depend_pkginfo_DB()) {
		/* updating db only: skip preremove script */
		echoDebug(DBG_PKGREMOVE_POC_DBUPD, pkginst, script,
		    zoneName ? zoneName : "global");
	} else {
		/* script present and ok to run: run the script */
		set_ulimit("preremove", ERR_PREREMOVE);
		if (zoneName == (char *)NULL) {
			echo(MSG_PKGREMOVE_EXEPOC_GZ);
			echoDebug(DBG_PKGREMOVE_EXEPOC_GZ, pkginst, script);
		} else {
			echo(MSG_PKGREMOVE_EXEPOC_LZ, zoneName);
			echoDebug(DBG_PKGREMOVE_EXEPOC_LZ, pkginst, script,
			    zoneName);
		}
		putparam("PKG_PROC_SCRIPT", "preremove");
		if (pkgverbose) {
			ckreturn(pkgexecl(script_in, PROC_STDOUT,
			    PROC_USER, PROC_GRP, SHELL, "-x",
			    script, NULL), ERR_PREREMOVE);
		} else {
			ckreturn(pkgexecl(script_in, PROC_STDOUT,
			    PROC_USER, PROC_GRP, SHELL, script,
			    NULL), ERR_PREREMOVE);
		}
		clr_ulimit();
	}

	/* update the lock - doing removal */

	lockupd("remove");

	/*
	 * Remove all components belonging to this package.
	 * Don't remove components if only updating the DB.
	 * Don't remove components if files are not being deleted.
	 */

	if (nodelete) {
		echoDebug(DBG_PKGREMOVE_REM_NODEL, pkginst,
		    zoneName ? zoneName : "global");
	} else if (is_depend_pkginfo_DB()) {
		echoDebug(DBG_PKGREMOVE_REM_DBUPD, pkginst,
		    zoneName ? zoneName : "global");
	} else {
		echoDebug(DBG_PKGREMOVE_REM, pkginst,
		    zoneName ? zoneName : "global");
		/*
		 * remove package one class at a time
		 */

		/* reverse order of classes */
		for (i = cl_getn() - 1; i >= 0; i--) {
			rmclass(cl_nam(i), pkgrmremote, zoneName);
		}

		rmclass(NULL, pkgrmremote, zoneName);
	}

	z_destroyMountTable();

	/*
	 * Execute postremove script, if any
	 * Don't execute postremove script if only updating the DB.
	 * Don't execute postremove script if files are not being deleted.
	 */

	/* update the lock - at the postremove script */
	lockupd("postremove");

	/* execute postremove script if one is provided */
	(void) snprintf(script, sizeof (script), "%s/postremove", pkgbin);
	if (access(script, F_OK) != 0) {
		/* no script present */
		echoDebug(DBG_PKGREMOVE_PIC_NONE, pkginst,
		    zoneName ? zoneName : "global");
	} else if (nodelete) {
		/* not deleting files: skip postremove script */
		echoDebug(DBG_PKGREMOVE_PIC_NODEL, pkginst, script,
		    zoneName ? zoneName : "global");
	} else if (is_depend_pkginfo_DB()) {
		/* updating db only: skip postremove script */
		echoDebug(DBG_PKGREMOVE_PIC_DBUPD, pkginst, script,
		    zoneName ? zoneName : "global");
	} else {
		/* script present and ok to run: run the script */
		set_ulimit("postremove", ERR_POSTREMOVE);
		if (zoneName == (char *)NULL) {
			echo(MSG_PKGREMOVE_EXEPIC_GZ);
			echoDebug(DBG_PKGREMOVE_EXEPIC_GZ, pkginst, script);
		} else {
			echo(MSG_PKGREMOVE_EXEPIC_LZ, zoneName);
			echoDebug(DBG_PKGREMOVE_EXEPIC_LZ, pkginst, script,
			    zoneName);
		}
		putparam("PKG_PROC_SCRIPT", "postremove");
		putparam("TMPDIR", tmpdir);
		if (pkgverbose) {
			ckreturn(pkgexecl(script_in, PROC_STDOUT, PROC_USER,
			    PROC_GRP, SHELL, "-x", script, NULL),
			    ERR_POSTREMOVE);
		} else {
			ckreturn(pkgexecl(script_in, PROC_STDOUT, PROC_USER,
			    PROC_GRP, SHELL, script, NULL),
			    ERR_POSTREMOVE);
		}
		clr_ulimit();
	}

	if (zoneName == (char *)NULL) {
		echo(MSG_PKGREMOVE_UPDINF_GZ);
	} else {
		echo(MSG_PKGREMOVE_UPDINF_LZ, zoneName);
	}

	if (delmap(1, pkginst, &pkgserver, &tmpfp) != 0) {
		progerr(ERR_DB_QUERY, pkginst);
		quit(99);
	}

	if (!warnflag && !failflag) {
		(void) chdir("/");
		if (rrmdir(pkgloc))
			warnflag++;
	}

	if ((z_running_in_global_zone() == B_TRUE) &&
	    (pkgIsPkgInGzOnly(get_inst_root(), pkginst) == B_TRUE)) {
		boolean_t	b;

		b = pkgRemovePackageFromGzonlyList(get_inst_root(), pkginst);
		if (b == B_FALSE) {
			progerr(ERR_PKGREMOVE_GZONLY_REMOVE, pkginst);
			ckreturn(1, NULL);
		}
	}

	/* release the generic package lock */

	(void) unlockinst();

	pkgcloseserver(pkgserver);

	quit(0);
	/* LINTED: no return */
}

int
issymlink(char *path)
{
	struct stat statbuf;

	/*
	 * Obtain status of path; if symbolic link get link's status
	 */

	if (lstat(path, &statbuf) != 0) {
		return (1);	/* not symlink */
	}

	/*
	 * Status obtained - if symbolic link, return 0
	 */

	if ((statbuf.st_mode & S_IFMT) == S_IFLNK) {
		return (0);	/* is a symlink */
	}

	/*
	 * Not a symbolic link - return 1
	 */

	return (1);		/* not symlink */
}

static void
rmclass(char *aclass, int rm_remote, char *a_zoneName)
{
	struct cfent	*ept;
	FILE	*fp = NULL;
	char	tmpfile[PATH_MAX];
	char	script[PATH_MAX];
	int	i;
	char	*tmp_path;
	char	*save_path = NULL;
	struct stat st;

	if (aclass == NULL) {
		for (i = 0; i < eptnum; i++) {
			if (eptlist[i] != NULL) {
				rmclass(eptlist[i]->pkg_class,
				    rm_remote, a_zoneName);
			}
		}
		return;
	}

	/* locate class action script to execute */
	(void) snprintf(script, sizeof (script), "%s/r.%s", pkgbin, aclass);
	if (access(script, F_OK) != 0) {
		(void) snprintf(script, sizeof (script), "%s/r.%s",
		    PKGSCR, aclass);
		if (access(script, F_OK) != 0)
			script[0] = '\0';
	}
	if (script[0] != '\0') {
		int td;

		(void) snprintf(tmpfile, sizeof (tmpfile), "%s/RMLISTXXXXXX",
		    tmpdir);
		td = mkstemp(tmpfile);
		if (td == -1) {
			progerr(ERR_TMPFILE);
			quit(99);
		}
		if ((fp = fdopen(td, "w")) == NULL) {
			progerr(ERR_WTMPFILE, tmpfile);
			quit(99);
		}
	}

	if (a_zoneName == (char *)NULL) {
		echo(MSG_PKGREMOVE_REMPATHCLASS_GZ, aclass);
	} else {
		echo(MSG_PKGREMOVE_REMPATHCLASS_LZ, aclass, a_zoneName);
	}

	/* process paths in reverse order */
	i = eptnum;
	while (--i >= 0) {
		ept = eptlist[i];

		if ((ept == NULL) || strcmp(aclass, ept->pkg_class)) {
			continue;
		}

		/* save the path, and prepend the ir */
		if (is_an_inst_root()) {
			save_path = ept->path;
			tmp_path = fixpath(ept->path);
			ept->path = tmp_path;
		}

		if (!ept->ftype || (ept->ftype == '^' && !script[0])) {
			/*
			 * A path owned by more than one package is marked with
			 * a NULL ftype (seems odd, but that's how it's
			 * done). Such files are sacro sanct. Shared editable
			 * files are a special case, and are marked with an
			 * ftype of '^'. These files should only be ignored if
			 * no class action script is present. It is the CAS's
			 * responsibility to not remove the editable object.
			 */
			echo(MSG_SHARED, ept->path);
		} else if (ept->pinfo->status == SERVED_FILE && !rm_remote) {
			/*
			 * If the path is provided to the client from a
			 * server, don't remove anything unless explicitly
			 * requested through the "-f" option.
			 */
			echo(MSG_SERVER, ept->path);
		} else if (script[0]) {
			/*
			 * If there's a class action script, just put the
			 * path name into the list.
			 */
			(void) fprintf(fp, "%s\n", ept->path);
		} else if (strchr("dx", ept->ftype) != NULL ||
		    (lstat(ept->path, &st) == 0 && S_ISDIR(st.st_mode))) {
			/* Directories are rmdir()'d. */

			if (rmdir(ept->path)) {
				if (errno == EBUSY) {
					echo(MSG_DIRBUSY, ept->path);
				} else if (errno == EEXIST) {
					echo(MSG_NOTEMPTY, ept->path);
				} else if (errno != ENOENT) {
					progerr(ERR_RMDIR, ept->path);
					warnflag++;
				}
			} else {
				if (ept->pinfo->status == SERVED_FILE) {
					echo(MSG_RMSRVR, ept->path);
				} else {
					echo("%s", ept->path);
				}
			}

		} else {
			/*
			 * Before removing this object one more
			 * check should be done to assure that a
			 * shared object is not removed.
			 * This can happen if the original object
			 * was incorrectly updated with the
			 * incorrect class identifier.
			 * This handles pathologcal cases that
			 * weren't handled above.
			 */
			if (ept->npkgs > 1) {
				echo(MSG_SHARED, ept->path);
				continue;
			}

			/* Regular files are unlink()'d. */

			if (unlink(ept->path)) {
				if (errno != ENOENT) {
					progerr(ERR_RMPATH, ept->path);
					warnflag++;
				}
			} else {
				if (ept->pinfo->status == SERVED_FILE) {
					echo(MSG_RMSRVR, ept->path);
				} else {
					echo("%s", ept->path);
				}
			}
		}

		/* restore the original path */

		if (is_an_inst_root()) {
			ept->path = save_path;
		}

		/*
		 * free memory allocated for this entry memory used for
		 * pathnames will be freed later by a call to pathdup()
		 */

		if (eptlist[i]) {
			free(eptlist[i]);
		}
		eptlist[i] = NULL;
	}
	if (script[0]) {
		(void) fclose(fp);
		set_ulimit(script, ERR_CASFAIL);
		if (pkgverbose)
			ckreturn(pkgexecl(tmpfile, CAS_STDOUT, CAS_USER,
			    CAS_GRP, SHELL, "-x", script, NULL),
			    ERR_CASFAIL);
		else
			ckreturn(pkgexecl(tmpfile, CAS_STDOUT, CAS_USER,
			    CAS_GRP, SHELL, script, NULL),
			    ERR_CASFAIL);
		clr_ulimit();
		if (isfile(NULL, tmpfile) == 0) {
			if (unlink(tmpfile) == -1)
				progerr(ERR_RMPATH, tmpfile);
		}
	}
}

static void
ckreturn(int retcode, char *msg)
{
	switch (retcode) {
	case 2:
	case 12:
	case 22:
		warnflag++;
		if (msg)
			progerr(msg);
		/* FALLTHROUGH */
	case 10:
	case 20:
		if (retcode >= 10)
			dreboot++;
		if (retcode >= 20)
			ireboot++;
		/* FALLTHROUGH */
	case 0:
		break; /* okay */

	case -1:
		retcode = 99;
		/* FALLTHROUGH */
	case 99:
	case 1:
	case 11:
	case 21:
	case 4:
	case 14:
	case 24:
	case 5:
	case 15:
	case 25:
		if (msg)
			progerr(msg);
		/* FALLTHROUGH */
	case 3:
	case 13:
	case 23:
		quit(retcode);
		/* NOT REACHED */
	default:
		if (msg)
			progerr(msg);
		quit(1);
	}
}

static void
usage(void)
{
	(void) fprintf(stderr, ERR_USAGE_PKGREMOVE);

	exit(1);
}



/* ============================================================================
 * SOURCE 66/98: minix4\exokernel\kernel_legacy\cmd\svr4pkg\pkgrm\main.c
 * Size: 76,025 bytes, Lines: 2,969
 * Hash: 423bab2e1655...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (c) 2017 Peter Tribble.
 */

/*
 * Copyright (c) 1989, 2010, Oracle and/or its affiliates. All rights reserved.
 */

/* Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T */
/* All Rights Reserved */


/*
 * System includes
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <signal.h>
#include <errno.h>
#include <locale.h>
#include <libintl.h>
#include <pkgstrct.h>
#include <pkgdev.h>
#include <pkginfo.h>
#include <pkglocs.h>
#include <pkglib.h>
#include <assert.h>

/*
 * libinstzones includes
 */

#include <instzones_api.h>

/*
 * consolidation pkg command library includes
 */

#include <pkglib.h>

/*
 * local pkg command library includes
 */

#include "install.h"
#include "libinst.h"
#include "libadm.h"
#include "messages.h"

/*
 * pkgrm local includes
 */

#include "quit.h"

/*
 * exported global variables
 */

/* these globals are set by ckreturn and used by quit.c */

int	admnflag = 0;	/* != 0 if any pkg op admin setting failure (4) */
int	doreboot = 0;	/* != 0 if reboot required after installation */
int	failflag = 0;	/* != 0 if fatal error has occurred (1) */
int	intrflag = 0;	/* != 0 if user selected quit (3) */
int	ireboot = 0;	/* != 0 if immediate reboot required */
int	nullflag = 0;	/* != 0 if admin interaction required (5) */
int	warnflag = 0;	/* != 0 if non-fatal error has occurred (2) */

/* imported by quit.c */
int	npkgs = 0;	/* the number of packages yet to be installed */

/* imported by presvr4.c */
int	started = 0;
char	*tmpdir = NULL;	/* location to place temporary files */

/* imported by various (many) */
struct admin	adm;	/* holds info about installation admin */
struct pkgdev	pkgdev;	/* holds info about the installation device */

/*
 * internal global variables
 */

static char	*admnfile = NULL;	/* file to use for installation admin */
static char	*pkginst = NULL;	/* current pkg/src instance 2 process */
static char	*vfstab_file = NULL;
static char	*zoneTempDir = (char *)NULL;

/* set by ckreturn() */

static int	interrupted = 0;	/* last pkg op was quit (1,2,3,4,5) */

static int	nointeract = 0;		/* non-zero - no user interaction */
static int	pkgrmremote = 0;	/* remove pkg objs stored remotely  */
static int	pkgverbose = 0;		/* non-zero if verbose mode selected */

/*
 * Assume the package complies with the standards as regards user
 * interaction during procedure scripts.
 */

static int	old_pkg = 0;
static int	old_symlinks = 0;
static int	no_map_client = 0;

/* Set by -O nozones: do not process any zones */

static boolean_t	noZones = B_FALSE;

/* Set by -O zonelist=<names...>: process only named zones */

static boolean_t	usedZoneList = B_FALSE;

/* Set by -O debug: debug output is enabled? */

static boolean_t	debugFlag = B_FALSE;

/*
 * imported (external) functions
 */

/* check.c */

extern int	preremove_verify(char **a_pkgList, zoneList_t a_zlst,
			char *a_zoneTempDir);
/* quit.c */

extern void	quitSetZonelist(zoneList_t a_zlst);

/*
 * imported (external) variables
 */

extern char	*pkgdir;

/* printable string - if string is null results in ??? */

#define	PSTR(STR) (((STR) == (char *)NULL) ? "???" : (STR))

#define	MAX_FDS	20

#if !defined(TEXT_DOMAIN)	/* Should be defined by cc -D */
#define	TEXT_DOMAIN "SYS_TEST"
#endif

/*
 * forward declarations
 */

static void		ckreturn(int retcode);
static void		create_zone_adminfile(char **r_zoneAdminFile,
				char *a_zoneTempDir, char *a_admnfile);
static void		create_zone_tempdir(char **r_zoneTempDir,
				char *a_tmpdir);
static int		doRemove(int a_nodelete, char *a_altBinDir,
				int a_longestPkg, char *a_adminFile,
				char *a_zoneAdminFile, zoneList_t zlst);
static int		pkgRemove(int a_nodelete, char *a_altBinDir,
				char *a_adminFile);
static int		pkgZoneCheckRemove(char *a_zoneName, char *a_altBinDir,
				char *a_adminFile, char *a_stdoutPath,
				zone_state_t a_zoneState, boolean_t tmpzone);
static int		pkgZoneRemove(char *a_zoneName, int a_nodelete,
				char *a_altBinDir, char *a_adminFile,
				zone_state_t a_zoneState, boolean_t tmpzone);
static void		resetreturn();
static void		usage(void);
static boolean_t	check_applicability(char *a_packageDir,
				char *a_pkgInst, char *a_rootPath,
				CAF_T a_flags);
static boolean_t	check_packages(char **a_pkgList, char *a_packageDir);
static boolean_t	remove_packages(char **a_pkgList, int a_nodelete,
				int a_longestPkg, int a_repeat,
				char *a_altBinDir, char *a_pkgdir,
				char *a_spoolDir, boolean_t a_noZones);
static boolean_t	remove_packages_from_spool_directory(char **a_pkgList,
				int a_nodelete, int a_longestPkg, int a_repeat,
				char *a_altBinDir);
static boolean_t	remove_packages_in_global_no_zones(char **a_pkgList,
				int a_nodelete, int a_longestPkg, int a_repeat,
				char *a_altBinDir);
static boolean_t	remove_packages_in_global_with_zones(char **a_pkgList,
				int a_nodelete, int a_longestPkg, int a_repeat,
				char *a_altBinDir, char *a_pkgdir,
				zoneList_t a_zlst);
static boolean_t	remove_packages_in_nonglobal_zone(char **a_pkgList,
				int a_nodelete, int a_longestPkg, int a_repeat,
				char *a_altBinDir, char *a_pkgdir);
static boolean_t	shall_we_continue(char *a_pkgInst, int a_npkgs);

/*
 * *****************************************************************************
 * global external (public) functions
 * *****************************************************************************
 */

/*
 * Name:	main
 * Description:	main entry point for pkgrm
 * Returns:	int
 *   0        Successful completion
 *   1        Fatal error.
 *   2        Warning.
 *   3        Interruption.
 *   4        Administration.
 *   5        Administration. Interaction is required. Do not use pkgrm -n.
 *  10       Reboot after removal of all packages.
 *  20       Reboot after removal of this package.
 */

int
main(int argc, char **argv)
{
	char			**category = NULL;
	char			*altBinDir = (char *)NULL;
	char			*catg_arg = NULL;
	char			*p;
	char			*prog_full_name = NULL;
	char			*spoolDir = 0;
	int			c;
	int			longestPkg = 0;
	int			n;
	int			nodelete = 0;	/* dont rm files/run scripts */
	int			pkgLgth = 0;
	int			repeat;
	struct sigaction	nact;
	struct sigaction	oact;

	/* initialize locale environment */

	(void) setlocale(LC_ALL, "");
	(void) textdomain(TEXT_DOMAIN);

	/* initialize program name */

	prog_full_name = argv[0];
	(void) set_prog_name(argv[0]);

	/* tell spmi zones interface how to access package output functions */

	z_set_output_functions(echo, echoDebug, progerr);

	/* tell quit which ckreturn function to call */

	quitSetCkreturnFunc(&ckreturn);

	/* Read PKG_INSTALL_ROOT from the environment, if it's there. */

	if (!set_inst_root(getenv("PKG_INSTALL_ROOT"))) {
		progerr(ERR_ROOT_SET);
		exit(1);
	}

	if (z_running_in_global_zone() && !enable_local_fs()) {
		progerr(ERR_CANNOT_ENABLE_LOCAL_FS);
	}

	pkgserversetmode(DEFAULTMODE);

	/*
	 * ********************************************************************
	 * parse command line options
	 * ********************************************************************
	 */

	while ((c = getopt(argc, argv, "?Aa:b:FMnO:R:s:V:vY:Z")) != EOF) {
		switch (c) {
		/*
		 * Public interface: Allow admin to remove objects
		 * from a service area via a reference client.
		 * Remove the package files from the client's file
		 * system, absolutely. If a file is shared with other
		 * packages, the default behavior is to not remove
		 * the file from the client's file system.
		 */
		case 'A':
		    pkgrmremote++;
		    break;

		/*
		 * Public interface: Use the installation
		 * administration file, admin, in place of the
		 * default admin file. pkgrm first looks in the
		 * current working directory for the administration
		 * file.  If the specified administration file is not
		 * in the current working directory, pkgrm looks in
		 * the /var/sadm/install/admin directory for the
		 * administra- tion file.
		 */
		case 'a':
		    admnfile = flex_device(optarg, 0);
		    break;

		/*
		 * Not a public interface:  location where package executables
		 * can be found - default is /usr/sadm/install/bin.
		 */
		case 'b':
			if (!path_valid(optarg)) {
				progerr(ERR_PATH, optarg);
				quit(1);
			}
			if (isdir(optarg) != 0) {
				p = strerror(errno);
				progerr(ERR_CANNOT_USE_DIR, optarg, p);
				quit(1);
			}
			altBinDir = optarg;
			break;

		/*
		 * Not a public interface: pass -F option to
		 * pkgremove which suppresses the removal of any
		 * files and any class action scripts, and suppresses
		 * the running of any class action scripts.  The
		 * package files remain but the package looks like it
		 * is not installed. This is mainly for use by the
		 * upgrade process.
		 */
		case 'F':
		    nodelete++;
		    break;

		/*
		 * Public interface: Instruct pkgrm not to use the
		 * $root_path/etc/vfstab file for determining the
		 * client's mount points. This option assumes the
		 * mount points are correct on the server and it
		 * behaves consistently with Solaris 2.5 and earlier
		 * releases.
		 */
		case 'M':
		    no_map_client = 1;
		    break;

		/*
		 * Public interface: package removal occurs in
		 * non-interactive mode.  Suppress output of the list of
		 * removed files. The default mode is interactive.
		 */
		case 'n':
		    nointeract++;
		    (void) echoSetFlag(B_FALSE);
		    break;

		/*
		 * Not a public interface: the -O option allows the behavior
		 * of the package tools to be modified. Recognized options:
		 * -> debug
		 * ---> enable debugging output
		 * -> nozones
		 * ---> act as though in global zone with no non-global zones
		 * -> enable-hollow-package-support
		 * --> Enable hollow package support. When specified, for any
		 * --> package that has SUNW_PKG_HOLLOW=true:
		 * --> Do not calculate and verify package size against target
		 * --> Do not run any package procedure or class action scripts
		 * --> Do not create or remove any target directories
		 * --> Do not perform any script locking
		 * --> Do not install or uninstall any components of any package
		 * --> Do not output any status or database update messages
		 * -> zonelist="<names...>"
		 * ---> add package to space-separated list of zones only
		 */

		case 'O':
			for (p = strtok(optarg, ","); p != (char *)NULL;
				p = strtok(NULL, ",")) {

				if (strcmp(p, "nozones") == 0) {
					noZones = B_TRUE;
					continue;
				}

				if (strcmp(p,
					"enable-hollow-package-support") == 0) {
					set_depend_pkginfo_DB(B_TRUE);
					continue;
				}

				if (strcmp(p, "debug") == 0) {
					/* set debug flag/enable debug output */
					debugFlag = B_TRUE;
					(void) echoDebugSetFlag(debugFlag);

					/* debug info on arguments to pkgadd */
					for (n = 0; n < argc && argv[n]; n++) {
						echoDebug(DBG_ARG, n, argv[n]);
					}

					continue;
				}

				if (strncmp(p, "zonelist=", 9) == 0) {
					if (z_set_zone_spec(p + 9) == -1)
						quit(1);
					usedZoneList = B_TRUE;
					continue;
				}

				/* -O option not recognized - issue warning */

				progerr(ERR_INVALID_O_OPTION, p);
				continue;
			}
			break;

		/*
		 * Public interface: defines the full path name of a
		 * directory to use as the root_path.  All files,
		 * including package system information files, are
		 * relocated to a directory tree starting in the
		 * specified root_path.
		 */
		case 'R':
		    if (!set_inst_root(optarg)) {
			    progerr(ERR_ROOT_CMD);
			    exit(1);
		    }
		    break;

		/*
		 * Public interface: remove the specified package(s)
		 * from the directory spool.  The default directory
		 * for spooled packages is /var/sadm/pkg.
		 */
		case 's':
		    spoolDir = flex_device(optarg, 1);
		    break;

		/*
		 * Public interface: Allow admin to establish the client
		 * filesystem using a vfstab-like file of stable format.
		 */
		case 'V':
		    vfstab_file = flex_device(optarg, 2);
		    no_map_client = 0;
		    break;

		/*
		 * Public interface: trace all of the scripts that
		 * get executed by pkgrm, located in the
		 * pkginst/install directory. This option is used for
		 * debugging the procedural and non- procedural
		 * scripts.
		 */
		case 'v':
		    pkgverbose++;
		    break;

		/*
		 * Public interface: remove packages based on the
		 * CATEGORY variable from the installed/spooled
		 * pkginfo file
		 */
		case 'Y':
		    catg_arg = strdup(optarg);

		    if ((category = get_categories(catg_arg)) == NULL) {
			    progerr(ERR_CAT_INV, catg_arg);
			    exit(1);
		    } else if (is_not_valid_category(category,
				    get_prog_name())) {
			    progerr(ERR_CAT_SYS);
			    exit(1);
		    } else if (is_not_valid_length(category)) {
			    progerr(ERR_CAT_LNGTH);
			    exit(1);
		    }

		    break;

		/*
		 * unrecognized option
		 */
		default:
		    usage();
		    /* NOTREACHED */
		}
	}

	/*
	 * ********************************************************************
	 * validate command line options
	 * ********************************************************************
	 */

	/* set "debug echo" flag according to setting of "-O debug" option */

	(void) echoDebugSetFlag(debugFlag);

	/* output entry debugging information */

	if (z_running_in_global_zone()) {
		echoDebug(DBG_ENTRY_IN_GZ, prog_full_name);
	} else {
		echoDebug(DBG_ENTRY_IN_LZ, prog_full_name, getzoneid(),
			z_get_zonename());
	}

	/* -s cannot be used with several */

	if (spoolDir != (char *)NULL) {
		if (admnfile != (char *)NULL) {
			progerr(ERR_SPOOLDIR_AND_ADMNFILE);
			usage();
			/* NOTREACHED */
		}

		if (pkgrmremote != 0) {
			progerr(ERR_SPOOLDIR_AND_PKGRMREMOTE);
			usage();
			/* NOTREACHED */
		}

		if (pkgverbose != 0) {
			progerr(ERR_SPOOLDIR_AND_PKGVERBOSE);
			usage();
			/* NOTREACHED */
		}

		if (is_an_inst_root() != 0) {
			progerr(ERR_SPOOLDIR_AND_INST_ROOT);
			usage();
			/* NOTREACHED */
		}
	}

	/* -V cannot be used with -A */

	if (no_map_client && pkgrmremote) {
		progerr(ERR_V_USED_AND_PKGRMREMOTE);
		usage();
		/* NOTREACHED */
	}

	/* -n used without pkg names or category */

	if (nointeract && (optind == argc) && (catg_arg == NULL)) {
		progerr(ERR_BAD_N_PKGRM);
		usage();
		/* NOTREACHED */
	}

	/* Error if specified zone list isn't valid on target */
	if (usedZoneList && z_verify_zone_spec() == -1)
		usage();

	/*
	 * hook SIGINT and SIGHUP interrupts into quit.c's trap handler
	 */

	/* hold SIGINT/SIGHUP interrupts */

	(void) sighold(SIGHUP);
	(void) sighold(SIGINT);

	/* connect quit.c:trap() to SIGINT */

	nact.sa_handler = quitGetTrapHandler();
	nact.sa_flags = SA_RESTART;
	(void) sigemptyset(&nact.sa_mask);

	(void) sigaction(SIGINT, &nact, &oact);

	/* connect quit.c:trap() to SIGHUP */

	nact.sa_handler = quitGetTrapHandler();
	nact.sa_flags = SA_RESTART;
	(void) sigemptyset(&nact.sa_mask);

	(void) sigaction(SIGHUP, &nact, &oact);

	/* release hold on signals */

	(void) sigrelse(SIGHUP);
	(void) sigrelse(SIGINT);

	/* establish temporary directory to use */

	tmpdir = getenv("TMPDIR");
	if (tmpdir == NULL) {
		tmpdir = P_tmpdir;
	}

	echoDebug(DBG_PKGRM_TMPDIR, tmpdir);

	/* initialize path parameters */

	set_PKGpaths(get_inst_root());

	/*
	 * initialize installation admin parameters - if removing from a spool
	 * directory then the admin file is ignore.
	 */

	if (spoolDir == NULL) {
		echoDebug(DBG_PKGRM_ADMINFILE, admnfile ? admnfile : "");
		setadminFile(admnfile);
	}

	/*
	 * if running in the global zone, and non-global zones exist, then
	 * enable hollow package support so that any packages that are marked
	 * SUNW_PKG_HOLLOW=true will be correctly removed in non-global zones
	 * when removed directly in the global zone by the global zone admin.
	 */

	if (is_depend_pkginfo_DB()) {
		echoDebug(DBG_PKGRM_HOLLOW_ENABLED);
	} else if ((z_running_in_global_zone() == B_TRUE) &&
		(z_non_global_zones_exist() == B_TRUE)) {
		echoDebug(DBG_PKGRM_ENABLING_HOLLOW);
		set_depend_pkginfo_DB(B_TRUE);
	}

	/*
	 * See if user wants this to be handled as an old style pkg.
	 * NOTE : the ``exception_pkg()'' stuff is to be used only
	 * through on495. This function comes out for on1095. See
	 * PSARC 1993-546. -- JST
	 */
	if (getenv("NONABI_SCRIPTS") != NULL) {
		old_pkg = 1;
	}

	/*
	 * See if the user wants to process symlinks consistent with
	 * the old behavior.
	 */

	if (getenv("PKG_NONABI_SYMLINKS") != NULL) {
		old_symlinks = 1;
	}

	if (devtype((spoolDir ? spoolDir : get_PKGLOC()), &pkgdev) ||
	    pkgdev.dirname == NULL) {
		progerr(ERR_BAD_DEVICE, spoolDir ? spoolDir : get_PKGLOC());
		quit(1);
		/* NOTREACHED */
	}

	pkgdir = pkgdev.dirname;
	repeat = ((optind >= argc) && pkgdev.mount);

	/*
	 * error if there are packages on the command line and a category
	 * was specified
	 */

	if (optind < argc && catg_arg != NULL) {
		progerr(ERR_PKGS_AND_CAT_PKGRM);
		usage();
		/* NOTREACHED */
	}

	/*
	 * ********************************************************************
	 * main package processing "loop"
	 * ********************************************************************
	 */

	for (;;) {
		boolean_t	b;
		char		**pkglist;	/* points to array of pkgs */

		/*
		 * mount the spool device if required
		 */

		if (pkgdev.mount) {
			if (n = pkgmount(&pkgdev, NULL, 0, 0, 1)) {
				quit(n);
				/* NOTREACHED */
			}
		}

		if (chdir(pkgdev.dirname)) {
			progerr(ERR_CHDIR, pkgdev.dirname);
			quit(1);
			/* NOTREACHED */
		}

		/*
		 * spool device mounted/available - get the list of the
		 * packages to remove
		 */

		n = pkgGetPackageList(&pkglist, argv, optind,
			catg_arg, category, &pkgdev);

		switch (n) {
			case -1:	/* no packages found */
				echoDebug(DBG_PKGLIST_RM_NONFOUND,
					PSTR(pkgdev.dirname));
				progerr(ERR_NOPKGS, pkgdev.dirname);
				quit(1);
				/* NOTREACHED */

			case 0:		/* packages found */
				break;

			default:	/* "quit" error */
				echoDebug(DBG_PKGLIST_RM_ERROR,
					pkgdev.dirname, n);
				quit(n);
				/* NOTREACHED */
		}

		/*
		 * count the number of packages to remove
		 * NOTE: npkgs is a global variable that is referenced by quit.c
		 * when error messages are generated - it is referenced directly
		 * by the other functions called below...
		 */

		for (npkgs = 0; pkglist[npkgs] != (char *)NULL; /* void */) {
			pkgLgth = strlen(pkglist[npkgs]);
			if (pkgLgth > longestPkg) {
				longestPkg = pkgLgth;
			}
			echoDebug(DBG_PKG_SELECTED, npkgs, pkglist[npkgs]);
			npkgs++;
		}

		/* output number of packages to be removed */

		echoDebug(DBG_NUM_PKGS_TO_REMOVE, npkgs, longestPkg);

		/*
		 * package list generated - remove packages
		 */

		b = remove_packages(pkglist, nodelete, longestPkg, repeat,
			altBinDir, pkgdev.dirname, spoolDir, noZones);

		/*
		 * unmount the spool directory if necessary
		 */

		if (pkgdev.mount) {
			(void) chdir("/");
			if (pkgumount(&pkgdev)) {
				progerr(ERR_PKGUNMOUNT, pkgdev.bdevice);
				quit(99);
				/* NOTREACHED */

			}
		}

		/*
		 * continue with next sequence of packages if continue set
		 */

		if (b == B_TRUE) {
			continue;
		}

		/*
		 * not continuing - quit with 0 exit code
		 */

		quit(0);
		/* NOTREACHED */
#ifdef lint
		return (0);
#endif	/* lint */
	}
}

/*
 * *****************************************************************************
 * static internal (private) functions
 * *****************************************************************************
 */

/*
 * Name:	doRemove
 * Description:	Remove a package from the global zone, and optionally from one
 *		or more non-global zones.
 * Arguments:	a_nodelete: should the files and scripts remain installed?
 *			- if != 0 pass -F flag to pkgremove - suppress
 *			the removal of any files and any class action scripts
 *			and suppress the running of any class action scripts.
 *			The package files remain but the package looks like it
 *			is not installed. This is mainly for use by upgrade.
 *			- if == 0 do not pass -F flag to pkgremove - all
 *			files and class action scripts are removed, and any
 *			appropriate class action scripts are run.
 *		a_altBinDir - pointer to string representing location of the
 *			pkgremove executable to run. If not NULL, then pass
 *			the path specified to the -b option to pkgremove.
 *		a_longestPkg - length of the longest package "name" (for
 *			output format alignment)
 *		a_adminFile - pointer to string representing the admin
 *			file to pass to pkgremove when removing a package from
 *			the global zone only. Typically the admin file used for
 *			the global zone is the admin file passed in by the user.
 *			If this is == NULL no admin file is given to pkgremove.
 *		a_zoneAdminFile - pointer to string representing the admin
 *			file to pass to pkgremove when removing the package
 *			from a non-global zone only. Typically the admin file
 *			used for non-global zones supresses all checks since
 *			the dependency checking is done for all zones first
 *			before proceeding.
 *			A zoneAdminFile MUST be specified if a_zlst != NULL.
 *			A zoneAdminFile must NOT be specified if a_zlst == NULL.
 *		a_zlst - list of zones to process; NULL if no zones to process.
 * Returns:	int	(see ckreturn() function for details)
 *		0 - success
 *		1 - package operation failed (fatal error)
 *		2 - non-fatal error (warning)
 *		3 - user selected quit (operation interrupted)
 *		4 - admin settings prevented operation
 *		5 - interaction required and -n (non-interactive) specified
 *		"10" will be added to indicate "immediate reboot required"
 *		"20" will be added to indicate "reboot after install required"
 */

static int
doRemove(int a_nodelete, char *a_altBinDir, int a_longestPkg, char *a_adminFile,
	char *a_zoneAdminFile, zoneList_t a_zlst)
{
	boolean_t	b;
	char		*zoneName;
	char		ans[MAX_INPUT];
	int		n;
	int		zoneIndex;
	int		zonesSkipped;
	struct pkginfo	*pinfo = (struct pkginfo *)NULL;
	zone_state_t	zst;

	/* entry assertions */

	if (a_zlst != (zoneList_t)NULL) {
		/* zone list specified - zone admin file required */
		assert(a_zoneAdminFile != (char *)NULL);
		assert(*a_zoneAdminFile != '\0');
	} else {
		/* no zone list specified - no zone admin file needed */
		assert(a_zoneAdminFile == (char *)NULL);
	}

	/* NOTE: required 'pkgdir' set to spool directory or NULL */
	b = pkginfoIsPkgInstalled(&pinfo, pkginst);
	if (b == B_FALSE) {
		progerr(ERR_NO_SUCH_INSTANCE, pkginst);
		pkginfoFree(&pinfo);
		return (2);
	}

	/* entry debugging info */

	echoDebug(DBG_DOREMOVE_ENTRY);
	echoDebug(DBG_DOREMOVE_ARGS, PSTR(pinfo->pkginst), PSTR(pinfo->name),
		PSTR(pinfo->arch), PSTR(pinfo->version), PSTR(pinfo->basedir),
		PSTR(pinfo->catg), pinfo->status);

	if (!nointeract) {
		char	fmt1[100];

		/* create format based on max pkg name length */

		(void) snprintf(fmt1, sizeof (fmt1), "   %%-%d.%ds  %%s",
				a_longestPkg, a_longestPkg);

		if (pinfo->status == PI_SPOOLED) {
			echo(INFO_SPOOLED);
		} else {
			if (getuid()) {
				progerr(ERR_NOT_ROOT, get_prog_name());
				exit(1);
			}
			echo(INFO_INSTALL);
		}

		echo(fmt1, pinfo->pkginst, pinfo->name);

		if (pinfo->arch || pinfo->version) {
			char	fmt2[100];

			/* create format based on max pkg name length */

			(void) snprintf(fmt2, sizeof (fmt2), "   %%%d.%ds  ",
					a_longestPkg, a_longestPkg);

			/* LINTED variable format specifier to fprintf() */
			(void) fprintf(stderr, fmt2, "");

			if (pinfo->arch) {
				(void) fprintf(stderr, "(%s) ", pinfo->arch);
			}

			if (pinfo->version) {
				(void) fprintf(stderr, "%s", pinfo->version);
			}

			(void) fprintf(stderr, "\n");
		}

		n = ckyorn(ans, NULL, NULL, NULL, ASK_CONFIRM);
		if (n != 0) {
			quit(n);
			/* NOTREACHED */
		}

		if (strchr("yY", *ans) == NULL) {
			pkginfoFree(&pinfo);
			return (0);
		}
	}

	if (pinfo->status == PI_SPOOLED) {
		/* removal from a directory */
		echo(INFO_RMSPOOL, pkginst);
		pkginfoFree(&pinfo);
		return (rrmdir(pkginst));
	}

	/* exit if not root */

	if (getuid()) {
		progerr(ERR_NOT_ROOT, get_prog_name());
		exit(1);
	}

	pkginfoFree(&pinfo);

	zonesSkipped = 0;

	if (interrupted != 0) {
		echo(MSG_DOREMOVE_INTERRUPTED_B4_Z, pkginst);
		echoDebug(MSG_DOREMOVE_INTERRUPTED_B4_Z, pkginst);
		return (n);
	}

	echoDebug(DBG_REMOVE_FLAG_VALUES, "before pkgZoneRemove",
		admnflag, doreboot, failflag, interrupted,
		intrflag, ireboot, nullflag, warnflag);

	for (zoneIndex = 0;
	    a_zlst != NULL &&
	    (zoneName = z_zlist_get_zonename(a_zlst, zoneIndex)) != NULL;
	    zoneIndex++) {

		/* skip the zone if it is NOT running */

		zst = z_zlist_get_current_state(a_zlst, zoneIndex);
		if (zst != ZONE_STATE_RUNNING && zst != ZONE_STATE_MOUNTED) {
			zonesSkipped++;
			echoDebug(DBG_SKIPPING_ZONE, zoneName);
			continue;
		}

		echo(MSG_REMOVE_PKG_FROM_ZONE, pkginst, zoneName);
		echoDebug(DBG_REMOVE_PKG_FROM_ZONE, pkginst, zoneName);

		/*
		 * remove package from zone; use the zone admin file which
		 * suppresses all checks.
		 */

		n = pkgZoneRemove(z_zlist_get_scratch(a_zlst, zoneIndex),
			a_nodelete, a_altBinDir, a_zoneAdminFile,
			zst, B_FALSE);

		/* set success/fail condition variables */

		ckreturn(n);

		echoDebug(DBG_REMOVE_FLAG_VALUES, "after pkgZoneRemove",
			admnflag, doreboot, failflag, interrupted, intrflag,
			ireboot, nullflag, warnflag);
	}

	if (zonesSkipped > 0) {
		echoDebug(DBG_ZONES_SKIPPED, zonesSkipped);

		for (zoneIndex = 0;
			(zoneName = z_zlist_get_zonename(a_zlst, zoneIndex)) !=
				(char *)NULL; zoneIndex++) {

			/* skip the zone if it IS running */

			zst = z_zlist_get_current_state(a_zlst, zoneIndex);
			if (zst == ZONE_STATE_RUNNING ||
			    zst == ZONE_STATE_MOUNTED) {
				zonesSkipped++;
				echoDebug(DBG_SKIPPING_ZONE_BOOT, zoneName);
				continue;
			}

			/* skip the zone if it is NOT bootable */

			if (z_zlist_is_zone_runnable(a_zlst,
						zoneIndex) == B_FALSE) {
				echo(MSG_SKIPPING_ZONE_NOT_RUNNABLE, zoneName);
				echoDebug(DBG_SKIPPING_ZONE_NOT_RUNNABLE,
					zoneName);
				continue;
			}

			/* mount up the zone */

			echo(MSG_BOOTING_ZONE, zoneName);
			echoDebug(DBG_BOOTING_ZONE, zoneName);

			b = z_zlist_change_zone_state(a_zlst, zoneIndex,
				ZONE_STATE_MOUNTED);
			if (b == B_FALSE) {
				progerr(ERR_CANNOT_BOOT_ZONE, zoneName);
				/* set fatal error return condition */
				ckreturn(1);
				continue;
			}

			echo(MSG_REMOVE_PKG_FROM_ZONE, pkginst, zoneName);

			/*
			 * remove package from zone; use the zone admin file
			 * which suppresses all checks.
			 */

			n = pkgZoneRemove(z_zlist_get_scratch(a_zlst,
				zoneIndex), a_nodelete, a_altBinDir,
				a_zoneAdminFile, ZONE_STATE_MOUNTED, B_TRUE);

			/* set success/fail condition variables */

			ckreturn(n);

			echoDebug(DBG_REMOVE_FLAG_VALUES, "after pkgZoneRemove",
				admnflag, doreboot, failflag, interrupted,
				intrflag, ireboot, nullflag, warnflag);

			/* restore original state of zone */

			echo(MSG_RESTORE_ZONE_STATE, zoneName);
			echoDebug(DBG_RESTORE_ZONE_STATE, zoneName);

			b = z_zlist_restore_zone_state(a_zlst, zoneIndex);
		}
	}

	/*
	 * Process global zone if it was either the only possible
	 * target (no list of zones specified) or it appears in the list
	 */
	if (a_zlst == NULL || z_on_zone_spec(GLOBAL_ZONENAME)) {
		/* reset interrupted flag before calling pkgremove */
		interrupted = 0;	/* last action was NOT quit */

		/*
		 * call pkgremove for this package for the global zone;
		 * use the admin file passed in by the user via -a.
		 */
		n = pkgRemove(a_nodelete, a_altBinDir, a_adminFile);

		/* set success/fail condition variables */
		ckreturn(n);
	}

	return (n);
}

/*
 *  function to clear out any exisiting error return conditions that may have
 *  been set by previous calls to ckreturn()
 */
static void
resetreturn()
{
	admnflag = 0;	/* != 0 if any pkg op admin setting failure (4) */
	doreboot = 0;	/* != 0 if reboot required after installation (>= 10) */
	failflag = 0;	/* != 0 if fatal error has occurred (1) */
	intrflag = 0;	/* != 0 if user selected quit (3) */
	ireboot = 0;	/* != 0 if immediate reboot required (>= 20) */
	nullflag = 0;	/* != 0 if admin interaction required (5) */
	warnflag = 0;	/* != 0 if non-fatal error has occurred (2) */
	interrupted = 0;	/* last pkg op was quit (1,2,3,4,5) */
}

/*
 *  function which checks the indicated return value
 *  and indicates disposition of installation
 */
static void
ckreturn(int retcode)
{
	/*
	 * entry debugging info
	 */

	echoDebug(DBG_PKGRM_CKRETURN, retcode, PSTR(pkginst));

	switch (retcode) {
	    case  0:		/* successful */
	    case 10:
	    case 20:
		break; /* empty case */

	    case  1:		/* package operation failed (fatal error) */
	    case 11:
	    case 21:
		failflag++;
		interrupted++;
		break;

	    case  2:		/* non-fatal error (warning) */
	    case 12:
	    case 22:
		warnflag++;
		interrupted++;
		break;

	    case  3:		/* user selected quit; operation interrupted */
	    case 13:
	    case 23:
		intrflag++;
		interrupted++;
		break;

	    case  4:		/* admin settings prevented operation */
	    case 14:
	    case 24:
		admnflag++;
		interrupted++;
		break;

	    case  5:		/* administration: interaction req (no -n) */
	    case 15:
	    case 25:
		nullflag++;
		interrupted++;
		break;

	    default:
		failflag++;
		interrupted++;
		return;
	}

	if (retcode >= 20) {
		ireboot++;
	} else if (retcode >= 10) {
		doreboot++;
	}
}

static int
pkgZoneCheckRemove(char *a_zoneName, char *a_altBinDir, char *a_adminFile,
	char *a_stdoutPath, zone_state_t a_zoneState, boolean_t tmpzone)
{
	char	*arg[MAXARGS];
	char	*p;
	char	adminfd_path[PATH_MAX];
	char	path[PATH_MAX];
	int	fds[MAX_FDS];
	int	maxfds;
	int	n;
	int	nargs;

	/* entry assertions */

	assert(a_zoneName != (char *)NULL);
	assert(*a_zoneName != '\0');

	/* entry debugging info */

	echoDebug(DBG_PKGZONECHECKREMOVE_ENTRY);
	echoDebug(DBG_PKGZONECHECKREMOVE_ARGS, a_zoneName, PSTR(pkginst),
		PSTR(pkgdev.dirname), PSTR(a_adminFile), PSTR(a_stdoutPath));

	/* generate path to pkgremove */

	(void) snprintf(path, sizeof (path), "%s/pkgremove",
		a_altBinDir == (char *)NULL ? PKGBIN : a_altBinDir);

	/* start at first file descriptor */

	maxfds = 0;

	/*
	 * generate argument list for call to pkgremove
	 */

	/* start at argument 0 */

	nargs = 0;

	/* first argument is path to executable */

	arg[nargs++] = strdup(path);

	/* second argument is always: pass -O debug to pkgremove: debug mode */

	if (debugFlag == B_TRUE) {
		arg[nargs++] = "-O";
		arg[nargs++] = "debug";
	}

	/* pkgrm -b dir: pass -b to pkgremove */

	if (a_altBinDir != (char *)NULL) {
		arg[nargs++] = "-b";
		arg[nargs++] = a_altBinDir;
	}

	/*
	 * NONABI_SCRIPTS defined: pass -o to pkgremove; refers to a
	 * pkg requiring operator interaction during a procedure script
	 * (common before on1093)
	 */

	if (old_pkg) {
		arg[nargs++] = "-o";
	}

	/*
	 * PKG_NONABI_SYMLINKS defined: pass -y to pkgremove; process
	 * symlinks consistent with old behavior
	 */

	if (old_symlinks) {
		arg[nargs++] = "-y";
	}

	/* pkgrm -M: pass -M to pkgremove: don't mount client file systems */

	arg[nargs++] = "-M";

	/* pkgrm -A: pass -A to pkgremove */

	if (pkgrmremote) {
		arg[nargs++] = "-A";
	}

	/* pkgrm -v: pass -v to pkgremove: never trace scripts */

	/* pass "-O enable-hollow-package-support" */

	if (is_depend_pkginfo_DB()) {
		arg[nargs++] = "-O";
		arg[nargs++] = "enable-hollow-package-support";
	}

	/* pass -n to pkgremove: always in noninteractive mode */

	arg[nargs++] = "-n";

	/* pkgrm -a admin: pass -a admin to pkgremove: admin file */

	if (a_adminFile) {
		int fd;
		fd = openLocal(a_adminFile, O_RDONLY, tmpdir);
		if (fd < 0) {
			progerr(ERR_CANNOT_COPY_LOCAL, a_adminFile,
				errno, strerror(errno));
			return (1);
		}
		(void) snprintf(adminfd_path, sizeof (adminfd_path),
			"/proc/self/fd/%d", fd);
		fds[maxfds++] = fd;
		arg[nargs++] = "-a";
		arg[nargs++] = strdup(adminfd_path);
	}

	/*
	 * pkgadd -R root: pass -R /a to pkgremove in mounted zone
	 */
	if (a_zoneState == ZONE_STATE_MOUNTED) {
		arg[nargs++] = "-R";
		arg[nargs++] = "/a";
	}

	/* pkgrm -F: pass -F to pkgremove: always update DB only */

	arg[nargs++] = "-F";

	/* pass "-O preremovecheck" */

	arg[nargs++] = "-O";
	arg[nargs++] = "preremovecheck";

	/* add "-O addzonename" */

	arg[nargs++] = "-O";
	arg[nargs++] = "addzonename";

	/*
	 * add parent zone info/type
	 */

	p = z_get_zonename();
	if ((p != NULL) && (*p != '\0')) {
			char	zn[MAXPATHLEN];
			(void) snprintf(zn, sizeof (zn),
				"parent-zone-name=%s", p);
			arg[nargs++] = "-O";
			arg[nargs++] = strdup(zn);
	}

	/* current zone type */

	arg[nargs++] = "-O";
	if (z_running_in_global_zone() == B_TRUE) {
			char	zn[MAXPATHLEN];
			(void) snprintf(zn, sizeof (zn),
				"parent-zone-type=%s",
				TAG_VALUE_GLOBAL_ZONE);
			arg[nargs++] = strdup(zn);
	} else {
			char	zn[MAXPATHLEN];
			(void) snprintf(zn, sizeof (zn),
				"parent-zone-type=%s",
				TAG_VALUE_NONGLOBAL_ZONE);
			arg[nargs++] = strdup(zn);
	}

	/* Add arguments how to start the pkgserv */

	arg[nargs++] = "-O";
	arg[nargs++] = pkgmodeargument(tmpzone ? RUN_ONCE : pkgservergetmode());

	/* pass -N to pkgremove: program name to report */

	arg[nargs++] = "-N";
	arg[nargs++] = get_prog_name();

	/* add package instance name */

	arg[nargs++] = pkginst;

	/* terminate argument list */

	arg[nargs++] = NULL;

	/* execute pkgremove command */

	if (debugFlag == B_TRUE) {
		echoDebug(DBG_ZONE_EXEC_ENTER, a_zoneName, arg[0]);
		for (n = 0; arg[n]; n++) {
			echoDebug(DBG_ARG, n, arg[n]);
		}
	}

	/* terminate file descriptor list */

	fds[maxfds] = -1;

	/* exec command in zone */

	n = z_zone_exec(a_zoneName, path, arg, a_stdoutPath, (char *)NULL, fds);

	echoDebug(DBG_ZONE_EXEC_EXIT, a_zoneName, arg[0], n,
			PSTR(a_stdoutPath));

	/*
	 * close any files that were opened for use by the
	 * /proc/self/fd interface so they could be passed to programs
	 * via the z_zone_exec() interface
	 */

	for (; maxfds > 0; maxfds--) {
		(void) close(fds[maxfds-1]);
	}

	/* return results of pkgremove in zone execution */

	return (n);
}

static int
pkgZoneRemove(char *a_zoneName, int a_nodelete, char *a_altBinDir,
	char *a_adminFile, zone_state_t a_zoneState, boolean_t tmpzone)
{
	char	*arg[MAXARGS];
	char	*p;
	char	adminfd_path[PATH_MAX];
	char	path[PATH_MAX];
	int	fds[MAX_FDS];
	int	maxfds;
	int	n;
	int	nargs;

	/* entry assertions */

	assert(a_zoneName != (char *)NULL);
	assert(*a_zoneName != '\0');

	/* entry debugging info */

	echoDebug(DBG_PKGZONEREMOVE_ENTRY);
	echoDebug(DBG_PKGZONEREMOVE_ARGS, a_zoneName, PSTR(pkginst),
		PSTR(pkgdev.dirname), a_nodelete, PSTR(a_adminFile));

	/* generate path to pkgremove */

	(void) snprintf(path, sizeof (path), "%s/pkgremove",
		a_altBinDir == (char *)NULL ? PKGBIN : a_altBinDir);

	/* start at first file descriptor */

	maxfds = 0;

	/*
	 * generate argument list for call to pkgremove
	 */

	/* start at argument 0 */

	nargs = 0;

	/* first argument is path to executable */

	arg[nargs++] = strdup(path);

	/* second argument is always: pass -O debug to pkgremove: debug mode */

	if (debugFlag == B_TRUE) {
		arg[nargs++] = "-O";
		arg[nargs++] = "debug";
	}

	/* pkgrm -b dir: pass -b to pkgremove */

	if (a_altBinDir != (char *)NULL) {
		arg[nargs++] = "-b";
		arg[nargs++] = a_altBinDir;
	}

	/*
	 * NONABI_SCRIPTS defined: pass -o to pkgremove; refers to a
	 * pkg requiring operator interaction during a procedure script
	 * (common before on1093)
	 */

	if (old_pkg) {
		arg[nargs++] = "-o";
	}

	/*
	 * PKG_NONABI_SYMLINKS defined: pass -y to pkgremove; process
	 * symlinks consistent with old behavior
	 */

	if (old_symlinks) {
		arg[nargs++] = "-y";
	}

	/* pkgrm -M: pass -M to pkgremove: don't mount client file systems */

	arg[nargs++] = "-M";

	/* pkgrm -A: pass -A to pkgremove */

	if (pkgrmremote) {
		arg[nargs++] = "-A";
	}

	/* pkgrm -v: pass -v to pkgremove: trace scripts */

	if (pkgverbose) {
		arg[nargs++] = "-v";
	}

	/* pass "-O enable-hollow-package-support" */

	if (is_depend_pkginfo_DB()) {
		arg[nargs++] = "-O";
		arg[nargs++] = "enable-hollow-package-support";
	}

	/* pkgrm -n: pass -n to pkgremove: noninteractive mode */

	if (nointeract) {
		arg[nargs++] = "-n";
	}

	/* pkgrm -a admin: pass -a admin to pkgremove: admin file */

	if (a_adminFile) {
		int fd;
		fd = openLocal(a_adminFile, O_RDONLY, tmpdir);
		if (fd < 0) {
			progerr(ERR_CANNOT_COPY_LOCAL, a_adminFile,
				errno, strerror(errno));
			return (1);
		}
		(void) snprintf(adminfd_path, sizeof (adminfd_path),
			"/proc/self/fd/%d", fd);
		fds[maxfds++] = fd;
		arg[nargs++] = "-a";
		arg[nargs++] = adminfd_path;
	}

	/*
	 * pkgadd -R root: pass -R /a to pkgremove in mounted zone
	 */
	if (a_zoneState == ZONE_STATE_MOUNTED) {
		arg[nargs++] = "-R";
		arg[nargs++] = "/a";
	}

	/* pkgrm -F: pass -F to pkgremove: update DB only */

	if (a_nodelete) {
		arg[nargs++] = "-F";
	}

	/* add "-O addzonename" */

	arg[nargs++] = "-O";
	arg[nargs++] = "addzonename";

	/*
	 * add parent zone info/type
	 */

	p = z_get_zonename();
	if ((p != NULL) && (*p != '\0')) {
			char	zn[MAXPATHLEN];
			(void) snprintf(zn, sizeof (zn),
				"parent-zone-name=%s", p);
			arg[nargs++] = "-O";
			arg[nargs++] = strdup(zn);
	}

	/* current zone type */

	arg[nargs++] = "-O";
	if (z_running_in_global_zone() == B_TRUE) {
			char	zn[MAXPATHLEN];
			(void) snprintf(zn, sizeof (zn),
				"parent-zone-type=%s",
				TAG_VALUE_GLOBAL_ZONE);
			arg[nargs++] = strdup(zn);
	} else {
			char	zn[MAXPATHLEN];
			(void) snprintf(zn, sizeof (zn),
				"parent-zone-type=%s",
				TAG_VALUE_NONGLOBAL_ZONE);
			arg[nargs++] = strdup(zn);
	}

	/* Add arguments how to start the pkgserv */

	arg[nargs++] = "-O";
	arg[nargs++] = pkgmodeargument(tmpzone ? RUN_ONCE : pkgservergetmode());

	/* pass -N to pkgremove: program name to report */

	arg[nargs++] = "-N";
	arg[nargs++] = get_prog_name();

	/* add package instance name */

	arg[nargs++] = pkginst;

	/* terminate argument list */

	arg[nargs++] = NULL;

	/* execute pkgremove command */

	if (debugFlag == B_TRUE) {
		echoDebug(DBG_ZONE_EXEC_ENTER, a_zoneName, arg[0]);
		for (n = 0; arg[n]; n++) {
			echoDebug(DBG_ARG, n, arg[n]);
		}
	}

	/* terminate file descriptor list */

	fds[maxfds] = -1;

	/* exec command in zone */

	n = z_zone_exec(a_zoneName, path, arg, (char *)NULL, (char *)NULL, fds);

	/*
	 * close any files that were opened for use by the
	 * /proc/self/fd interface so they could be passed to programs
	 * via the z_zone_exec() interface
	 */

	for (; maxfds > 0; maxfds--) {
		(void) close(fds[maxfds-1]);
	}

	return (n);
}

/*
 * Name:	pkgRemove
 * Description:	Invoke pkgremove in the current zone to perform a remove
 *		of a single package from the current zone or standalone system
 * Arguments:	a_nodelete: should the files and scripts remain installed?
 *			- if != 0 pass -F flag to pkgremove - suppress
 *			the removal of any files and any class action scripts
 *			and suppress the running of any class action scripts.
 *			The package files remain but the package looks like it
 *			is not installed. This is mainly for use by upgrade.
 *			- if == 0 do not pass -F flag to pkgremove - all
 *			files and class action scripts are removed, and any
 *			appropriate class action scripts are run.
 *		a_altBinDir - pointer to string representing location of the
 *			pkgremove executable to run. If not NULL, then pass
 *			the path specified to the -b option to pkgremove.
 *		a_adminFile - pointer to string representing the admin
 *			file to pass to pkgremove when removing the package.
 *			If this is == NULL no admin file is given to pkgremove.
 * Returns:	int	(see ckreturn() function for details)
 *		0 - success
 *		1 - package operation failed (fatal error)
 *		2 - non-fatal error (warning)
 *		3 - user selected quit (operation interrupted)
 *		4 - admin settings prevented operation
 *		5 - interaction required and -n (non-interactive) specified
 *		"10" will be added to indicate "immediate reboot required"
 *		"20" will be added to indicate "reboot after install required"
 */

static int
pkgRemove(int a_nodelete, char *a_altBinDir, char *a_adminFile)
{
	char	*arg[MAXARGS];
	char	*p;
	char	path[PATH_MAX];
	int	n;
	int	nargs;

	/* entry debugging info */

	echoDebug(DBG_PKGREMOVE_ENTRY);
	echoDebug(DBG_PKGREMOVE_ARGS, PSTR(pkginst), PSTR(pkgdev.dirname),
		a_nodelete, PSTR(a_adminFile));

	(void) snprintf(path, sizeof (path), "%s/pkgremove",
		a_altBinDir == (char *)NULL ? PKGBIN : a_altBinDir);

	nargs = 0;

	/* first argument is path to executable */

	arg[nargs++] = strdup(path);

	/* second argument is always: pass -O debug to pkgremove: debug mode */

	if (debugFlag == B_TRUE) {
		arg[nargs++] = "-O";
		arg[nargs++] = "debug";
	}

	/* Add arguments how to start the pkgserv */

	arg[nargs++] = "-O";
	arg[nargs++] = pkgmodeargument(pkgservergetmode());

	/* pkgrm -b dir: pass -b to pkgremove */

	if (a_altBinDir != (char *)NULL) {
		arg[nargs++] = "-b";
		arg[nargs++] = a_altBinDir;
	}

	/*
	 * NONABI_SCRIPTS defined: pass -o to pkgremove; refers to a
	 * pkg requiring operator interaction during a procedure script
	 * (common before on1093)
	 */

	if (old_pkg) {
		arg[nargs++] = "-o";
	}

	/*
	 * PKG_NONABI_SYMLINKS defined: pass -y to pkgremove; process
	 * symlinks consistent with old behavior
	 */

	if (old_symlinks) {
		arg[nargs++] = "-y";
	}

	/* pkgrm -M: pass -M to pkgrm: dont mount client file systems */

	if (no_map_client) {
		arg[nargs++] = "-M";
	}

	/* pkgrm -A: pass -A to pkgrm */

	if (pkgrmremote) {
		arg[nargs++] = "-A";
	}

	/* pkgrm -v: pass -v to pkgremove: trace scripts */

	if (pkgverbose) {
		arg[nargs++] = "-v";
	}

	/* pkgrm -n: pass -n to pkgremove: noninteractive mode */

	if (nointeract) {
		arg[nargs++] = "-n";
	}

	/* pkgrm -a admin: pass -a admin to pkgremove: admin file */

	if (a_adminFile) {
		arg[nargs++] = "-a";
		arg[nargs++] = strdup(a_adminFile);
	}

	/* pkgrm -V vfstab: pass -V vfstab to pkgremove: alternate vfstab */

	if (vfstab_file) {
		arg[nargs++] = "-V";
		arg[nargs++] = vfstab_file;
	}

	/* pkgrm -R root: pass -R root to pkgremove: alternative root */

	if (is_an_inst_root()) {
		arg[nargs++] = "-R";
		arg[nargs++] = get_inst_root();
	}

	/* pkgrm -F: pass -F to pkgremove: update DB only */

	if (a_nodelete) {
		arg[nargs++] = "-F";
	}

	/*
	 * add parent zone info/type
	 */

	p = z_get_zonename();
	if ((p != NULL) && (*p != '\0')) {
			char	zn[MAXPATHLEN];
			(void) snprintf(zn, sizeof (zn),
				"parent-zone-name=%s", p);
			arg[nargs++] = "-O";
			arg[nargs++] = strdup(zn);
	}

	/* current zone type */

	arg[nargs++] = "-O";
	if (z_running_in_global_zone() == B_TRUE) {
			char	zn[MAXPATHLEN];
			(void) snprintf(zn, sizeof (zn),
				"parent-zone-type=%s",
				TAG_VALUE_GLOBAL_ZONE);
			arg[nargs++] = strdup(zn);
	} else {
			char	zn[MAXPATHLEN];
			(void) snprintf(zn, sizeof (zn),
				"parent-zone-type=%s",
				TAG_VALUE_NONGLOBAL_ZONE);
			arg[nargs++] = strdup(zn);
	}

	/* pass -N to pkgremove: program name to report */

	arg[nargs++] = "-N";
	arg[nargs++] = get_prog_name();

	/* add package instance name */

	arg[nargs++] = pkginst;

	/* terminate argument list */

	arg[nargs++] = NULL;

	/*
	 * run the appropriate pkgremove command in the specified zone
	 */

	if (debugFlag == B_TRUE) {
		echoDebug(DBG_ZONE_EXEC_ENTER, "global", arg[0]);
		for (n = 0; arg[n]; n++) {
			echoDebug(DBG_ARG, n, arg[n]);
		}
	}

	/* execute pkgremove command */

	n = pkgexecv(NULL, NULL, NULL, NULL, arg);

	/* return results of pkgrm in this zone */

	return (n);
}

static void
usage(void)
{
	char	*prog = get_prog_name();

	(void) fprintf(stderr, ERR_USAGE_PKGRM, prog, prog);
	exit(1);
}

/*
 * Name:	remove_packages_in_global_with_zones
 * Description:	Remove packages from the global zone and from non-global zones
 *		when run from the global zone and when non-global zones are
 *		present.
 * Arguments:	a_pkgList - pointer to array of strings, each string specifying
 *			the name of one package to be removed.
 *		a_nodelete: should the files and scripts remain installed?
 *			- if != 0 pass -F flag to pkgremove - suppress
 *			the removal of any files and any class action scripts
 *			and suppress the running of any class action scripts.
 *			The package files remain but the package looks like it
 *			is not installed. This is mainly for use by upgrade.
 *			- if == 0 do not pass -F flag to pkgremove - all
 *			files and class action scripts are removed, and any
 *			appropriate class action scripts are run.
 *		a_longestPkg - length of the longest package "name" (for
 *			output format alignment)
 *		a_repeat - are there more packages avialable in "optind"
 *			- B_TRUE - process packages from optind
 *			- B_FALSE - do not process packages from optind
 *		a_altBinDir - pointer to string representing location of the
 *			pkgremove executable to run. If not NULL, then pass
 *			the path specified to the -b option to pkgremove.
 *		a_pkgdir - pointer to string representing the directory
 *			where the packages to be removed are located.
 *		a_zlst - list of zones to process; NULL if no zones to process.
 * Returns:	int	(see ckreturn() function for details)
 *		0 - success
 *		1 - package operation failed (fatal error)
 *		2 - non-fatal error (warning)
 *		3 - user selected quit (operation interrupted)
 *		4 - admin settings prevented operation
 *		5 - interaction required and -n (non-interactive) specified
 *		"10" will be added to indicate "immediate reboot required"
 *		"20" will be added to indicate "reboot after install required"
 */

static boolean_t
remove_packages_in_global_with_zones(char **a_pkgList, int a_nodelete,
	int a_longestPkg, int a_repeat, char *a_altBinDir, char *a_pkgdir,
	zoneList_t a_zlst)
{
static	char		*zoneAdminFile = (char *)NULL;

	boolean_t	b;
	char		*zoneName;
	char		*scratchName;
	char		preremovecheckPath[PATH_MAX+1];
	int		i;
	int		n;
	int		savenpkgs = npkgs;
	int		zoneIndex;
	int		zonesSkipped;
	zone_state_t	zst;

	/* entry assertions */

	assert(a_zlst != (zoneList_t)NULL);
	assert(a_pkgList != (char **)NULL);
	assert(a_longestPkg > 0);
	assert(a_pkgdir != (char *)NULL);
	assert(*a_pkgdir != '\0');

	/* entry debugging info */

	echoDebug(DBG_PKGREMPKGSGZWNGZ_ENTRY);
	echoDebug(DBG_PKGREMPKGSGZWNGZ_ARGS, a_nodelete, a_longestPkg,
		a_repeat, PSTR(a_altBinDir), PSTR(a_pkgdir));

	/* check all packages */

	if (check_packages(a_pkgList, a_pkgdir) != B_TRUE) {
		quit(1);
	}

	/* create temporary directory for use by zone operations */

	create_zone_tempdir(&zoneTempDir, tmpdir);

	/* create hands off settings admin file for use in a non-global zone */

	create_zone_adminfile(&zoneAdminFile, zoneTempDir, admnfile);

	/*
	 * all of the packages (as listed in the package list) are
	 * removed one at a time from all non-global zones and then
	 * from the global zone.
	 */

	for (i = 0; (pkginst = a_pkgList[i]) != NULL; i++) {
		/* reset interrupted flag before calling pkgremove */

		interrupted = 0;	/* last action was NOT quit */

		/* skip package if it is "in the global zone only" */

		if (pkgIsPkgInGzOnly(get_inst_root(), pkginst) == B_TRUE) {
			continue;
		}

		/*
		 * if operation failed in global zone do not propagate to
		 * non-global zones
		 */

		zonesSkipped = 0;

		if (interrupted != 0) {
			echo(MSG_DOREMOVE_INTERRUPTED, pkginst);
			echoDebug(DBG_DOREMOVE_INTERRUPTED, pkginst);
			break;
		}

		echoDebug(DBG_REMOVE_FLAG_VALUES, "before loop",
			admnflag, doreboot, failflag, interrupted,
			intrflag, ireboot, nullflag, warnflag);

		for (zoneIndex = 0;
			(zoneName = z_zlist_get_zonename(a_zlst, zoneIndex)) !=
				(char *)NULL; zoneIndex++) {

			/* skip the zone if it is NOT running */

			zst = z_zlist_get_current_state(a_zlst, zoneIndex);
			if (zst != ZONE_STATE_RUNNING &&
			    zst != ZONE_STATE_MOUNTED) {
				zonesSkipped++;
				echoDebug(DBG_SKIPPING_ZONE, zoneName);
				continue;
			}

			echo(MSG_CHECKREMOVE_PKG_IN_ZONE, pkginst, zoneName);
			echoDebug(DBG_CHECKREMOVE_PKG_IN_ZONE, pkginst,
				zoneName);

			scratchName = z_zlist_get_scratch(a_zlst, zoneIndex);

			(void) snprintf(preremovecheckPath,
				sizeof (preremovecheckPath),
				"%s/%s.%s.preremovecheck.txt",
				zoneTempDir, pkginst, scratchName);

			/*
			 * dependency check this package this zone; use the
			 * user supplied admin file so that the appropriate
			 * level of dependency checking is (or is not) done.
			 */

			n = pkgZoneCheckRemove(scratchName, a_altBinDir,
				admnfile, preremovecheckPath,
				zst, B_FALSE);

			/* set success/fail condition variables */

			ckreturn(n);

			echoDebug(DBG_REMOVE_FLAG_VALUES,
				"after pkgzonecheckremove",
				admnflag, doreboot, failflag, interrupted,
				intrflag, ireboot, nullflag, warnflag);
		}

		if (zonesSkipped == 0) {
			continue;
		}

		echoDebug(DBG_ZONES_SKIPPED, zonesSkipped);

		for (zoneIndex = 0;
			(zoneName = z_zlist_get_zonename(a_zlst, zoneIndex)) !=
				(char *)NULL; zoneIndex++) {

			/* skip the zone if it IS running */

			zst = z_zlist_get_current_state(a_zlst, zoneIndex);
			if (zst == ZONE_STATE_RUNNING ||
			    zst == ZONE_STATE_MOUNTED) {
				zonesSkipped++;
				echoDebug(DBG_SKIPPING_ZONE_BOOT, zoneName);
				continue;
			}

			/* skip the zone if it is NOT bootable */

			if (z_zlist_is_zone_runnable(a_zlst,
						zoneIndex) == B_FALSE) {
				echo(MSG_SKIPPING_ZONE_NOT_RUNNABLE, zoneName);
				echoDebug(DBG_SKIPPING_ZONE_NOT_RUNNABLE,
					zoneName);
				continue;
			}

			/* mount up the zone */

			echo(MSG_BOOTING_ZONE, zoneName);
			echoDebug(DBG_BOOTING_ZONE, zoneName);

			b = z_zlist_change_zone_state(a_zlst, zoneIndex,
				ZONE_STATE_MOUNTED);
			if (b == B_FALSE) {
				progerr(ERR_CANNOT_BOOT_ZONE, zoneName);
				/* set fatal error return condition */
				ckreturn(1);
				continue;
			}

			echo(MSG_CHECKREMOVE_PKG_IN_ZONE, pkginst, zoneName);
			echoDebug(DBG_CHECKREMOVE_PKG_IN_ZONE, pkginst,
					zoneName);

			scratchName = z_zlist_get_scratch(a_zlst, zoneIndex);

			(void) snprintf(preremovecheckPath,
				sizeof (preremovecheckPath),
				"%s/%s.%s.preremovecheck.txt",
				zoneTempDir, pkginst, scratchName);

			/*
			 * dependency check this package this zone; use the
			 * user supplied admin file so that the appropriate
			 * level of dependency checking is (or is not) done.
			 */

			n = pkgZoneCheckRemove(scratchName, a_altBinDir,
				admnfile, preremovecheckPath,
				ZONE_STATE_MOUNTED, B_TRUE);

			/* set success/fail condition variables */

			ckreturn(n);

			echoDebug(DBG_REMOVE_FLAG_VALUES,
				"after pkgzonecheckremove",
				admnflag, doreboot, failflag, interrupted,
				intrflag, ireboot, nullflag, warnflag);

			/* restore original state of zone */

			echo(MSG_RESTORE_ZONE_STATE, zoneName);
			echoDebug(DBG_RESTORE_ZONE_STATE, zoneName);

			b = z_zlist_restore_zone_state(a_zlst, zoneIndex);
		}
		npkgs--;
	}

	/*
	 * look at all pre-remove check files
	 */

	i = preremove_verify(a_pkgList, a_zlst, zoneTempDir);
	if (i != 0) {
		quit(i);
	}

	npkgs = savenpkgs;

	/*
	 * reset all error return condition variables that may have been
	 * set during package removal dependency checking so that they
	 * do not reflect on the success/failure of the actual package
	 * removal operations
	 */

	resetreturn();

	/*
	 * all of the packages (as listed in the package list) are
	 * removed one at a time.
	 */

	interrupted = 0;
	for (i = 0; (pkginst = a_pkgList[i]) != NULL; i++) {
		boolean_t	in_gz_only;
		started = 0;

		if (shall_we_continue(pkginst, npkgs) == B_FALSE) {
			continue;
		}

		in_gz_only = pkgIsPkgInGzOnly(get_inst_root(), pkginst);

		/* reset interrupted flag before calling pkgremove */

		interrupted = 0;

		/*
		 * pkgrm invoked from within the global zone and there are
		 * non-global zones configured:
		 * Remove the package from the global zone.
		 * If not removing the package from the global zone only,
		 * then remove the package from the list of zones specified.
		 */

		if (in_gz_only) {
			/* global zone only */
			n = doRemove(a_nodelete, a_altBinDir, a_longestPkg,
				admnfile, (char *)NULL, (zoneList_t)NULL);
		} else {
			/* global zone and non-global zones */
			n = doRemove(a_nodelete, a_altBinDir, a_longestPkg,
				zoneAdminFile, zoneAdminFile, a_zlst);
		}

		/* set success/fail condition variables */

		ckreturn(n);

		npkgs--;
	}

	/*
	 * all packages in the package list have been removed.
	 * Continue with removal if:
	 * -- immediate reboot is NOT required
	 * -- there are more packages to remove
	 * else return do NOT continue.
	 */

	if ((ireboot == 0) && (a_repeat != 0)) {
		return (B_TRUE);
	}

	/* return 'dont continue' */

	return (B_FALSE);
}

/*
 * Name:	remove_packages_in_nonglobal_zone
 * Description:	Remove packages in a non-global zone when run from a
 *		non-global zone.
 * Arguments:	a_pkgList - pointer to array of strings, each string specifying
 *			the name of one package to be removed.
 *		a_nodelete: should the files and scripts remain installed?
 *			- if != 0 pass -F flag to pkgremove - suppress
 *			the removal of any files and any class action scripts
 *			and suppress the running of any class action scripts.
 *			The package files remain but the package looks like it
 *			is not installed. This is mainly for use by upgrade.
 *			- if == 0 do not pass -F flag to pkgremove - all
 *			files and class action scripts are removed, and any
 *			appropriate class action scripts are run.
 *		a_longestPkg - length of the longest package "name" (for
 *			output format alignment)
 *		a_repeat - are there more packages avialable in "optind"
 *			- B_TRUE - process packages from optind
 *			- B_FALSE - do not process packages from optind
 *		a_altBinDir - pointer to string representing location of the
 *			pkgremove executable to run. If not NULL, then pass
 *			the path specified to the -b option to pkgremove.
 *		a_pkgdir - pointer to string representing the directory
 *			where the packages to be removed are located.
 * Returns:	int	(see ckreturn() function for details)
 *		0 - success
 *		1 - package operation failed (fatal error)
 *		2 - non-fatal error (warning)
 *		3 - user selected quit (operation interrupted)
 *		4 - admin settings prevented operation
 *		5 - interaction required and -n (non-interactive) specified
 *		"10" will be added to indicate "immediate reboot required"
 *		"20" will be added to indicate "reboot after install required"
 */

static boolean_t
remove_packages_in_nonglobal_zone(char **a_pkgList, int a_nodelete,
	int a_longestPkg, int a_repeat, char *a_altBinDir, char *a_pkgdir)
{
static	char		*zoneAdminFile = (char *)NULL;

	int		n;
	int		i;

	/* entry assertions */

	assert(a_pkgList != (char **)NULL);
	assert(a_longestPkg > 0);
	assert(a_pkgdir != (char *)NULL);
	assert(*a_pkgdir != '\0');

	/* entry debugging info */

	echoDebug(DBG_PKGREMPKGSNGZ_ENTRY);
	echoDebug(DBG_PKGREMPKGSNGZ_ARGS, a_nodelete, a_longestPkg,
		a_repeat, PSTR(a_altBinDir), PSTR(a_pkgdir));

	/* check all package */

	if (check_packages(a_pkgList, a_pkgdir) != B_TRUE) {
		quit(1);
	}

	/* create temporary directory for use by zone operations */

	create_zone_tempdir(&zoneTempDir, tmpdir);

	/* create hands off settings admin file for use in a non-global zone */

	create_zone_adminfile(&zoneAdminFile, zoneTempDir, admnfile);

	/*
	 * all of the packages (as listed in the package list) are
	 * removed one at a time.
	 */

	interrupted = 0;
	for (i = 0; (pkginst = a_pkgList[i]) != NULL; i++) {
		started = 0;

		if (shall_we_continue(pkginst, npkgs) == B_FALSE) {
			continue;
		}

		interrupted = 0;

		/*
		 * pkgrm invoked from within a non-global zone: remove
		 * the package from the current zone only - no non-global
		 * zones are possible.
		 */

		n = doRemove(a_nodelete, a_altBinDir, a_longestPkg,
			admnfile, (char *)NULL, (zoneList_t)NULL);

		/* set success/fail condition variables */

		ckreturn(n);

		npkgs--;
	}

	/*
	 * all packages in the package list have been removed.
	 * Continue with removal if:
	 * -- immediate reboot is NOT required
	 * -- there are more packages to remove
	 * else return do NOT continue.
	 */

	if ((ireboot == 0) && (a_repeat != 0)) {
		return (B_TRUE);
	}

	/* return 'dont continue' */

	return (B_FALSE);
}

/*
 * Name:	remove_packages_in_global_no_zones
 * Description:	Remove packages from the global zone only when run in the
 *		global zone and no non-global zones are installed.
 * Arguments:	a_pkgList - pointer to array of strings, each string specifying
 *			the name of one package to be removed.
 *		a_nodelete: should the files and scripts remain installed?
 *			- if != 0 pass -F flag to pkgremove - suppress
 *			the removal of any files and any class action scripts
 *			and suppress the running of any class action scripts.
 *			The package files remain but the package looks like it
 *			is not installed. This is mainly for use by upgrade.
 *			- if == 0 do not pass -F flag to pkgremove - all
 *			files and class action scripts are removed, and any
 *			appropriate class action scripts are run.
 *		a_longestPkg - length of the longest package "name" (for
 *			output format alignment)
 *		a_repeat - are there more packages avialable in "optind"
 *			- B_TRUE - process packages from optind
 *			- B_FALSE - do not process packages from optind
 *		a_altBinDir - pointer to string representing location of the
 *			pkgremove executable to run. If not NULL, then pass
 *			the path specified to the -b option to pkgremove.
 * Returns:	int	(see ckreturn() function for details)
 *		0 - success
 *		1 - package operation failed (fatal error)
 *		2 - non-fatal error (warning)
 *		3 - user selected quit (operation interrupted)
 *		4 - admin settings prevented operation
 *		5 - interaction required and -n (non-interactive) specified
 *		"10" will be added to indicate "immediate reboot required"
 *		"20" will be added to indicate "reboot after install required"
 */

static boolean_t
remove_packages_in_global_no_zones(char **a_pkgList, int a_nodelete,
	int a_longestPkg, int a_repeat, char *a_altBinDir)
{
	int	n;
	int	i;

	/* entry assertions */

	assert(a_pkgList != (char **)NULL);
	assert(a_longestPkg > 0);

	/* entry debugging info */

	echoDebug(DBG_PKGREMPKGSGZNNGZ_ENTRY);
	echoDebug(DBG_PKGREMPKGSGZNNGZ_ARGS, a_nodelete, a_longestPkg,
		a_repeat, PSTR(a_altBinDir));

	/*
	 * all of the packages (as listed in the package list) are
	 * removed one at a time.
	 */

	interrupted = 0;
	for (i = 0; (pkginst = a_pkgList[i]) != NULL; i++) {
		started = 0;

		if (shall_we_continue(pkginst, npkgs) == B_FALSE) {
			continue;
		}

		interrupted = 0;

		/*
		 * pkgrm invoked from within the global zone and there are
		 * NO non-global zones configured:
		 * Remove the package from the global zone only.
		 */

		n = doRemove(a_nodelete, a_altBinDir, a_longestPkg,
				admnfile, (char *)NULL, (zoneList_t)NULL);

		/* set success/fail condition variables */

		ckreturn(n);

		npkgs--;
	}

	/*
	 * all packages in the package list have been removed.
	 * Continue with removal if:
	 * -- immediate reboot is NOT required
	 * -- there are more packages to remove
	 * else return do NOT continue.
	 */

	if ((ireboot == 0) && (a_repeat != 0)) {
		return (B_TRUE);
	}

	/* return 'dont continue' */

	return (B_FALSE);
}

/*
 * Name:	remove_packages_from_spool_directory
 * Description:	Remove packages from a spool directory only.
 * Arguments:	a_pkgList - pointer to array of strings, each string specifying
 *			the name of one package to be removed.
 *		a_nodelete: should the files and scripts remain installed?
 *			- if != 0 pass -F flag to pkgremove - suppress
 *			the removal of any files and any class action scripts
 *			and suppress the running of any class action scripts.
 *			The package files remain but the package looks like it
 *			is not installed. This is mainly for use by upgrade.
 *			- if == 0 do not pass -F flag to pkgremove - all
 *			files and class action scripts are removed, and any
 *			appropriate class action scripts are run.
 *		a_longestPkg - length of the longest package "name" (for
 *			output format alignment)
 *		a_repeat - are there more packages avialable in "optind"
 *			- B_TRUE - process packages from optind
 *			- B_FALSE - do not process packages from optind
 *		a_altBinDir - pointer to string representing location of the
 *			pkgremove executable to run. If not NULL, then pass
 *			the path specified to the -b option to pkgremove.
 * Returns:	int	(see ckreturn() function for details)
 *		0 - success
 *		1 - package operation failed (fatal error)
 *		2 - non-fatal error (warning)
 *		3 - user selected quit (operation interrupted)
 *		4 - admin settings prevented operation
 *		5 - interaction required and -n (non-interactive) specified
 *		"10" will be added to indicate "immediate reboot required"
 *		"20" will be added to indicate "reboot after install required"
 */

static boolean_t
remove_packages_from_spool_directory(char **a_pkgList, int a_nodelete,
	int a_longestPkg, int a_repeat, char *a_altBinDir)
{
	int	n;
	int	i;

	/* entry assertions */

	assert(a_pkgList != (char **)NULL);
	assert(a_longestPkg > 0);

	/*
	 * all of the packages (as listed in the package list) are
	 * removed one at a time.
	 */

	interrupted = 0;
	for (i = 0; (pkginst = a_pkgList[i]) != NULL; i++) {
		started = 0;

		if (shall_we_continue(pkginst, npkgs) == B_FALSE) {
			continue;
		}

		interrupted = 0;

		/*
		 * pkgrm invoked from any type of zone BUT the target
		 * to be removed is a local spool directory: remove the
		 * packages from the spool directory only.
		 */

		n = doRemove(a_nodelete, a_altBinDir, a_longestPkg,
			admnfile, (char *)NULL, (zoneList_t)NULL);

		/* set success/fail condition variables */

		ckreturn(n);

		npkgs--;
	}

	/*
	 * all packages in the package list have been removed.
	 * Continue with removal if:
	 * -- immediate reboot is NOT required
	 * -- there are more packages to remove
	 * else return do NOT continue.
	 */

	if ((ireboot == 0) && (a_repeat != 0)) {
		return (B_TRUE);
	}

	/* return 'dont continue' */

	return (B_FALSE);
}

/*
 * Name:	remove_packages
 * Description:	Remove packages from the global zone, and optionally from one
 *		or more non-global zones, or from a specified spool directory.
 * Arguments:	a_pkgList - pointer to array of strings, each string specifying
 *			the name of one package to be removed.
 *		a_nodelete: should the files and scripts remain installed?
 *			- if != 0 pass -F flag to pkgremove - suppress
 *			the removal of any files and any class action scripts
 *			and suppress the running of any class action scripts.
 *			The package files remain but the package looks like it
 *			is not installed. This is mainly for use by upgrade.
 *			- if == 0 do not pass -F flag to pkgremove - all
 *			files and class action scripts are removed, and any
 *			appropriate class action scripts are run.
 *		a_longestPkg - length of the longest package "name" (for
 *			output format alignment)
 *		a_repeat - are there more packages avialable in "optind"
 *			- B_TRUE - process packages from optind
 *			- B_FALSE - do not process packages from optind
 *		a_altBinDir - pointer to string representing location of the
 *			pkgremove executable to run. If not NULL, then pass
 *			the path specified to the -b option to pkgremove.
 *		a_pkgdir - pointer to string representing the directory
 *			where the packages to be removed are located.
 *		a_spoolDir - pointer to string specifying spool directory
 *			to remove packages from. If != NULL then all zones
 *			processing is bypassed and the packages are removed
 *			from the specified spool directory only.
 *		a_noZones - if non-global zones are configured, should the
 *			packages be removed from the non-global zones?
 *			- B_TRUE - do NOT remove packages from non-global zones
 *			- B_FALSE - remove packages from non-global zones
 * Returns:	int	(see ckreturn() function for details)
 *		0 - success
 *		1 - package operation failed (fatal error)
 *		2 - non-fatal error (warning)
 *		3 - user selected quit (operation interrupted)
 *		4 - admin settings prevented operation
 *		5 - interaction required and -n (non-interactive) specified
 *		"10" will be added to indicate "immediate reboot required"
 *		"20" will be added to indicate "reboot after install required"
 */

static boolean_t
remove_packages(char **a_pkgList, int a_nodelete, int a_longestPkg,
	int a_repeat, char *a_altBinDir, char *a_pkgdir, char *a_spoolDir,
	boolean_t a_noZones)
{
	zoneList_t	zlst;
	boolean_t	b;

	/* entry assertions */

	assert(a_pkgList != (char **)NULL);

	echoDebug(DBG_REMOVEPKGS_ENTRY);
	echoDebug(DBG_REMOVEPKGS_ARGS, npkgs, a_nodelete, a_longestPkg,
		a_repeat, PSTR(a_pkgdir), PSTR(a_spoolDir));

	/*
	 * if removing from spool directory, bypass all zones checks
	 */

	if (a_spoolDir != (char *)NULL) {
		/* in non-global zone */

		echoDebug(DBG_REMOVE_PKGS_FROM_SPOOL, a_spoolDir);

		b = remove_packages_from_spool_directory(a_pkgList, a_nodelete,
			a_longestPkg, a_repeat, a_altBinDir);

		return (B_FALSE);
	}

	/* exit if not root */

	if (getuid()) {
		progerr(ERR_NOT_ROOT, get_prog_name());
		exit(1);
	}

	/*
	 * if running in the global zone AND one or more non-global
	 * zones exist, add packages in a 'zones aware' manner, else
	 * add packages in the standard 'non-zones aware' manner.
	 */

	if ((a_noZones == B_FALSE) && (z_running_in_global_zone() == B_FALSE)) {
		/* in non-global zone */

		echoDebug(DBG_IN_LZ);

		b = z_lock_this_zone(ZLOCKS_PKG_ADMIN);
		if (b != B_TRUE) {
			progerr(ERR_CANNOT_LOCK_THIS_ZONE);
			/* set fatal error return condition */
			ckreturn(1);
			return (B_FALSE);
		}

		b = remove_packages_in_nonglobal_zone(a_pkgList, a_nodelete,
			a_longestPkg, a_repeat, a_altBinDir, a_pkgdir);

		(void) z_unlock_this_zone(ZLOCKS_ALL);

		return (B_FALSE);
	}

	/* running in the global zone */

	b = z_non_global_zones_exist();
	if ((a_noZones == B_FALSE) && (b == B_TRUE)) {

		echoDebug(DBG_IN_GZ_WITH_LZ);

		/* get a list of all non-global zones */
		zlst = z_get_nonglobal_zone_list();
		if (zlst == (zoneList_t)NULL) {
			progerr(ERR_CANNOT_GET_ZONE_LIST);
			quit(1);
		}

		/* need to lock all of the zones */

		quitSetZonelist(zlst);
		b = z_lock_zones(zlst, ZLOCKS_PKG_ADMIN);
		if (b == B_FALSE) {
			z_free_zone_list(zlst);
			progerr(ERR_CANNOT_LOCK_ZONES);
			/* set fatal error return condition */
			ckreturn(1);
			return (B_FALSE);
		}

		/* add packages to all zones */

		b = remove_packages_in_global_with_zones(a_pkgList, a_nodelete,
			a_longestPkg, a_repeat, a_altBinDir, a_pkgdir, zlst);

		/* unlock all zones */

		(void) z_unlock_zones(zlst, ZLOCKS_ALL);
		quitSetZonelist((zoneList_t)NULL);

		/* free list of all non-global zones */

		z_free_zone_list(zlst);

		return (B_FALSE);
	}

	/* in global zone no non-global zones */

	echoDebug(DBG_IN_GZ_NO_LZ);

	b = z_lock_this_zone(ZLOCKS_PKG_ADMIN);
	if (b != B_TRUE) {
		progerr(ERR_CANNOT_LOCK_THIS_ZONE);
		/* set fatal error return condition */
		ckreturn(1);
		return (B_FALSE);
	}

	b = remove_packages_in_global_no_zones(a_pkgList, a_nodelete,
			a_longestPkg, a_repeat, a_altBinDir);

	(void) z_unlock_this_zone(ZLOCKS_ALL);

	return (B_FALSE);
}

/*
 */

static boolean_t
check_packages(char **a_pkgList, char *a_packageDir)
{
	int	savenpkgs = npkgs;
	int	i;
	CAF_T	flags = 0;

	/* set flags for applicability check */

	if (z_running_in_global_zone() == B_TRUE) {
		flags |= CAF_IN_GLOBAL_ZONE;
	}

	/*
	 * for each package to remove, verify that the package is installed
	 * and is removable.
	 */

	for (i = 0; (pkginst = a_pkgList[i]) != NULL; i++) {
		/* check package applicability */
		if (check_applicability(a_packageDir, pkginst, get_inst_root(),
			flags) == B_FALSE) {
			progerr(ERR_PKG_NOT_REMOVABLE, pkginst);
			npkgs = savenpkgs;
			return (B_FALSE);
		}
		npkgs--;
	}

	npkgs = savenpkgs;
	return (B_TRUE);
}

/*
 * - is this package removable from this zone?
 * - does the scope of remove conflict with existing installation
 */

static boolean_t
check_applicability(char *a_packageDir, char *a_pkgInst,
	char *a_rootPath, CAF_T a_flags)
{
	FILE		*pkginfoFP;
	boolean_t	all_zones;	/* pkg is "all zones" only */
	char		pkginfoPath[PATH_MAX];
	char		pkgpath[PATH_MAX];
	int		len;

	/* entry assertions */

	assert(a_packageDir != (char *)NULL);
	assert(*a_packageDir != '\0');
	assert(a_pkgInst != (char *)NULL);
	assert(*a_pkgInst != '\0');

	/* normalize root path */

	if (a_rootPath == (char *)NULL) {
		a_rootPath = "";
	}

	/*
	 * determine if this package is currently installed
	 * if not installed return success - operation will fail
	 * when the removal is attempted
	 */

	if (pkginfoIsPkgInstalled((struct pkginfo **)NULL, a_pkgInst) !=
		B_TRUE) {
		return (B_TRUE);
	}

	/*
	 * calculate paths to various objects
	 */

	len = snprintf(pkgpath, sizeof (pkgpath), "%s/%s", a_packageDir,
			a_pkgInst);
	if (len > sizeof (pkgpath)) {
		progerr(ERR_CREATE_PATH_2, a_packageDir, a_pkgInst);
		return (B_FALSE);
	}

	/* if not installed then just return */

	if (isdir(pkgpath) != 0) {
		progerr(ERR_NO_PKGDIR, pkgpath, a_pkgInst, strerror(errno));
		return (B_TRUE);
	}

	len = snprintf(pkginfoPath, sizeof (pkginfoPath),
			"%s/pkginfo", pkgpath);
	if (len > sizeof (pkgpath)) {
		progerr(ERR_CREATE_PATH_2, pkgpath, "pkginfo");
		return (B_FALSE);
	}

	/*
	 * gather information from this packages pkginfo file
	 */

	pkginfoFP = fopen(pkginfoPath, "r");

	if (pkginfoFP == (FILE *)NULL) {
		progerr(ERR_NO_PKG_INFOFILE, a_pkgInst, pkginfoPath,
							strerror(errno));
		return (B_FALSE);
	}

	/* determine "ALLZONES" setting for this package */

	all_zones = pkginfoParamTruth(pkginfoFP, PKG_ALLZONES_VARIABLE,
			"true", B_FALSE);

	/* close pkginfo file */

	(void) fclose(pkginfoFP);

	/* gather information from the global zone only file */

	/*
	 * verify package applicability based on information gathered;
	 * the package IS currently installed....
	 */

	/* pkg ALLZONES=true & not running in global zone */

	if ((all_zones == B_TRUE) && (!(a_flags & CAF_IN_GLOBAL_ZONE))) {
		progerr(ERR_ALLZONES_AND_IN_LZ_PKGRM, a_pkgInst);
		return (B_FALSE);
	}

	return (B_TRUE);
}

/*
 * Name:	shall_we_continue
 * Description: Called from within a loop that is installing packages,
 *		this function examines various global variables and decides
 *		whether or not to ask an appropriate question, and wait for
 *		and appropriate reply.
 * Arguments:	<<global variables>>
 * Returns:	B_TRUE - continue processing with next package
 *		B_FALSE - do not continue processing with next package
 */

static boolean_t
shall_we_continue(char *a_pkgInst, int a_npkgs)
{
	char	ans[MAX_INPUT];
	int	n;

	/* return FALSE if immediate reboot required */

	if (ireboot) {
		ptext(stderr, MSG_SUSPEND_RM, a_pkgInst);
		return (B_FALSE);
	}

	/* return TRUE if not interrupted */

	if (!interrupted) {
		return (B_TRUE);
	}

	/* output appropriate interrupt message */

	echo(a_npkgs == 1 ? MSG_1MORETODO : MSG_MORETODO, a_npkgs);

	/* if running with no interaction (-n) do not ask question */

	if (nointeract) {
		quit(0);
		/* NOTREACHED */
	}

	/* interaction possible: ask question */

	n = ckyorn(ans, NULL, NULL, NULL, ASK_CONTINUE_RM);
	if (n != 0) {
		quit(n);
		/* NOTREACHED */
	}

	if (strchr("yY", *ans) == NULL) {
		quit(0);
		/* NOTREACHED */
	}
	return (B_TRUE);
}

/*
 * Name:	create_zone_adminfile
 * Description: Given a zone temporary directory and optionally an existing
 *		administration file, generate an administration file that
 *		can be used to perform "non-interactive" operations in a
 *		non-global zone.
 * Arguments:	r_zoneAdminFile - pointer to handle that will contain a
 *			string representing the path to the temporary
 *			administration file created - this must be NULL
 *			before the first call to this function - on
 *			subsequent calls if the pointer is NOT null then
 *			the existing string will NOT be overwritten.
 *		a_zoneTempDir - pointer to string representing the path
 *			to the zone temporary directory to create the
 *			temporary administration file in
 *		a_admnfile - pointer to string representing the path to
 *			an existing "user" administration file - the
 *			administration file created will contain the
 *			settings contained in this file, modified as
 *			appropriate to supress any interaction;
 *			If this is == NULL then the administration file
 *			created will not contain any extra settings
 * Returns:	void
 * NOTE:	Any string returned is placed in new storage for the
 *		calling method. The caller must use 'free' to dispose
 *		of the storage once the string is no longer needed.
 * NOTE:	On any error this function will call 'quit(1)'
 */

static void
create_zone_adminfile(char **r_zoneAdminFile, char *a_zoneTempDir,
	char *a_admnfile)
{
	boolean_t	b;

	/* entry assertions */

	assert(r_zoneAdminFile != (char **)NULL);
	assert(a_zoneTempDir != (char *)NULL);
	assert(*a_zoneTempDir != '\0');

	/* entry debugging info */

	echoDebug(DBG_CREATE_ZONE_ADMINFILE, a_zoneTempDir, PSTR(a_admnfile));

	/* if temporary name already exists, do not overwrite */

	if (*r_zoneAdminFile != (char *)NULL) {
		return;
	}

	/* create temporary name */

	*r_zoneAdminFile = tempnam(a_zoneTempDir, "zadmn");
	b = z_create_zone_admin_file(*r_zoneAdminFile, a_admnfile);
	if (b == B_FALSE) {
		progerr(ERR_CREATE_TMPADMIN, *r_zoneAdminFile,
			strerror(errno));
		quit(1);
		/* NOTREACHED */
	}

	echoDebug(DBG_CREATED_ZONE_ADMINFILE, *r_zoneAdminFile);
}

/*
 * Name:	create_zone_tempdir
 * Description: Given a system temporary directory, create a "zone" specific
 *		temporary directory and return the path to the directory
 *		created.
 * Arguments:	r_zoneTempDir - pointer to handle that will contain a
 *			string representing the path to the temporary
 *			directory created - this must be NULL before the
 *			first call to this function - on subsequent calls
 *			if the pointer is NOT null then the existing string
 *			will NOT be overwritten.
 *		a_zoneTempDir - pointer to string representing the path
 *			to the system temporary directory to create the
 *			temporary zone directory in
 * Returns:	void
 * NOTE:	Any string returned is placed in new storage for the
 *		calling method. The caller must use 'free' to dispose
 *		of the storage once the string is no longer needed.
 * NOTE:	On any error this function will call 'quit(1)'
 * NOTE:	This function calls "quitSetZoneTmpdir" on success to
 *		register the directory created with quit() so that the
 *		directory will be automatically deleted on exit.
 */

static void
create_zone_tempdir(char **r_zoneTempDir, char *a_tmpdir)
{
	boolean_t	b;

	/* entry assertions */

	assert(r_zoneTempDir != (char **)NULL);
	assert(a_tmpdir != (char *)NULL);
	assert(*a_tmpdir != '\0');

	/* entry debugging info */

	echoDebug(DBG_CREATE_ZONE_TEMPDIR, a_tmpdir);

	/* if temporary directory already exists, do not overwrite */

	if (*r_zoneTempDir != (char *)NULL) {
		return;
	}

	/* create temporary directory */

	b = setup_temporary_directory(r_zoneTempDir, a_tmpdir, "ztemp");
	if (b == B_FALSE) {
		progerr(ERR_ZONETEMPDIR, a_tmpdir, strerror(errno));
		quit(1);
		/* NOTREACHED */
	}

	/* register with quit() to directory is removed on exit */

	quitSetZoneTmpdir(*r_zoneTempDir);

	/* exit debugging info */

	echoDebug(DBG_CREATED_ZONE_TEMPDIR, *r_zoneTempDir);
}



/* ============================================================================
 * SOURCE 67/98: minix4\exokernel\kernel_legacy\cmd\svr4pkg\pkgtrans\main.c
 * Size: 3,047 bytes, Lines: 149
 * Hash: 8c74b1291223...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (c) 2017 Peter Tribble.
 */

/*
 * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

/* Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T */
/* All Rights Reserved */

/*
 * Copyright 2010 Nexenta Systems, Inc.  All rights reserved.
 */

#include <locale.h>
#include <libintl.h>
#include <stdio.h>
#include <signal.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pkgtrans.h>
#include <pkglib.h>
#include <pkglocs.h>
#include <libadm.h>
#include <libinst.h>
#include <messages.h>

static int	options;

static void	usage(void);
static void	trap(int signo);

int
main(int argc, char *argv[])
{
	int	c;
	void	(*func)();
	extern int	optind;
	int		ret;

	(void) setlocale(LC_ALL, "");

#if !defined(TEXT_DOMAIN)	/* Should be defined by cc -D */
#define	TEXT_DOMAIN "SYS_TEST"
#endif
	(void) textdomain(TEXT_DOMAIN);

	(void) set_prog_name(argv[0]);

	while ((c = getopt(argc, argv, "snio?")) != EOF) {
		switch (c) {
		case 'n':
			options |= PT_RENAME;
			break;

		case 'i':
			options |= PT_INFO_ONLY;
			break;

		case 'o':
			options |= PT_OVERWRITE;
			break;

		case 's':
			options |= PT_ODTSTREAM;
			break;

		default:
			usage();
			return (1);
		}
	}
	func = signal(SIGINT, trap);
	if (func != SIG_DFL)
		(void) signal(SIGINT, func);
	(void) signal(SIGHUP, trap);
	(void) signal(SIGQUIT, trap);
	(void) signal(SIGTERM, trap);
	(void) signal(SIGPIPE, trap);
	(void) signal(SIGPWR, trap);

	if ((argc-optind) < 2) {
		usage();
		return (1);
	}

	ret = pkgtrans(flex_device(argv[optind], 1),
	    flex_device(argv[optind+1], 1), &argv[optind+2], options);

	quit(ret);
	/*NOTREACHED*/
}

void
quit(int retcode)
{
	(void) signal(SIGINT, SIG_IGN);
	(void) signal(SIGHUP, SIG_IGN);
	(void) ds_close(1);
	(void) pkghead(NULL);
	exit(retcode);
}

static void
trap(int signo)
{
	(void) signal(SIGINT, SIG_IGN);
	(void) signal(SIGHUP, SIG_IGN);

	if (signo == SIGINT) {
		progerr(gettext("aborted at user request.\n"));
		quit(3);
	}
	progerr(gettext("aborted by signal %d\n"), signo);
	quit(1);
}

static void
usage(void)
{
	(void) fprintf(stderr,
	    gettext("usage: %s [-ions] srcdev dstdev [pkg [pkg...]]\n"),
	    get_prog_name());
}



/* ============================================================================
 * SOURCE 68/98: minix4\exokernel\kernel_legacy\cmd\sgs\size\common\main.c
 * Size: 5,540 bytes, Lines: 246
 * Hash: cafa83bc885b...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 1988 AT&T
 * Copyright (c) 1989 AT&T
 * All Rights Reserved
 *
 * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

/* UNIX HEADERS */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <libelf.h>

/* SIZE HEADER */
#include "defs.h"

/* RELEASE STRING */
#include "conv.h"
#include "sgs.h"


/* EXTERNAL VARIABLES DEFINED */
int		fflag = 0,	/* print full output if -f option is supplied */
		Fflag = 0,	/* print full output if -F option is supplied */
		nflag = 0;	/* include NOLOAD sections in size if -n */
				/* option  is supplied */
int		numbase = DECIMAL;
static int	errflag = 0;	/* Global error flag */
int		oneflag = 0;
int		exitcode = 0;   /* Global exit code */
char		*fname;
char		*archive;
int		is_archive = 0;

static char	*tool_name;

static void	usagerr();

#define	OPTSTR "VoxnfF"		/* option string for usage error message */
#define	GETOPTSTR "VoxnfF?"	/* option string for getopt */

static Elf	*elf;
static Elf_Arhdr	*arhdr;

/*
 *  main(argc, argv)
 *
 *  parses the command line
 *  opens, processes and closes each object file command line argument
 *
 *  defines:
 *      - int	numbase = HEX if the -x flag is in the command line
 *			= OCTAL if the -o flag is in the command line
 *			= DECIMAL if the -d flag is in the command line
 *
 *  calls:
 *      - process(filename) to print the size information in the object file
 *        filename
 *
 *  prints:
 *      - an error message if any unknown options appear on the command line
 *      - a usage message if no object file args appear on the command line
 *      - an error message if it can't open an object file
 *	      or if the object file has the wrong magic number
 *
 *  exits 1 - errors found, 0 - no errors
 */
int
main(int argc, char ** argv, char ** envp)
{
	/* UNIX FUNCTIONS CALLED */
	extern	void	error();

	/* SIZE FUNCTIONS CALLED */
	extern void process();

	/* EXTERNAL VARIABLES USED */
	extern int	numbase;
	extern int	errflag;
	extern int	oneflag;
	extern int	optind;
	extern char	*fname;

	int c;
	static int	fd;
	extern char	*archive;
	Elf_Cmd		cmd;
	Elf		*arf;
	unsigned	Vflag = 0;

	tool_name = argv[0];

	while ((c = getopt(argc, argv, GETOPTSTR)) != EOF) {
		switch (c) {
		case 'o':
			if (numbase != HEX)
				numbase = OCTAL;
			else
				(void) fprintf(stderr,
				"size: -x set, -o ignored\n");
			break;

		case 'd':
			numbase = DECIMAL;
			break;

		case 'x':
			if (numbase != OCTAL)
				numbase = HEX;
			else
				(void) fprintf(stderr,
				"size: -o set, -x ignored\n");
			break;

		case 'f':
			fflag++;
			break;

		case 'F':
			Fflag++;
			break;

		case 'n':
			nflag++;
			break;
		case 'V':
			(void) fprintf(stderr, "size: %s %s\n",
			    (const char *)SGU_PKG,
			    (const char *)SGU_REL);
			Vflag++;
			break;
		case '?':
			errflag++;
			break;
		default:
			break;
		}
	}
	if (errflag || (optind >= argc)) {
		if (!(Vflag && (argc == 2) && !errflag)) {
			usagerr();
		}
	}
	if ((argc - optind) == 1) {
		oneflag++;	/* only one file to process */
	}

	if (elf_version(EV_CURRENT) == EV_NONE) {
		(void) fprintf(stderr, "size: Libelf is out of date");
		exit(FATAL);	/* library out of date */
	}

	for (; optind < argc; optind++) {
		fname = argv[optind];
		if ((fd = open(argv[optind], O_RDONLY)) == -1) {
			error(fname, "cannot open");
		} else {
			cmd = ELF_C_READ;
			arf = 0;

			if ((arf = elf_begin(fd, cmd, arf)) == 0) {
				/* error(fname, "cannot open"); */
				(void) fprintf(stderr,
				"size: %s: %s\n", fname, elf_errmsg(-1));
				return (FATAL);
			}

			if (elf_kind(arf) == ELF_K_AR) {
				archive = argv[optind];
			} else {
				archive = "";
			}

			while ((elf = elf_begin(fd, cmd, arf)) != 0) {
				if ((arhdr = elf_getarhdr(elf)) == 0) {
					if (elf_kind(arf) == ELF_K_NONE) {
						/* BEGIN CSTYLED */
						(void) fprintf(stderr,
						  "%s: %s: invalid file type\n",
						    tool_name, fname);
						/* END CSTYLED */
						exitcode++;
						break;
					} else {
						process(elf);
					}
				} else if (arhdr->ar_name[0] != '/') {
					fname = arhdr->ar_name;
					if (elf_kind(arf) == ELF_K_NONE) {
						/* BEGIN CSTYLED */
						(void) fprintf(stderr,
					    "%s: %s[%s]: invalid file type\n",
						    tool_name, archive, fname);
						/* END CSTYLED */
						exitcode++;
						break;
					} else {
						is_archive++;
						process(elf);
					}
				}
				cmd = elf_next(elf);
				(void) elf_end(elf);
			}
			(void) elf_end(arf);
			(void) close(fd);
		}
	}
	if (exitcode)
		exit(FATAL);
	else
		exit(0);
	return (0);
}

static void
usagerr()
{
	(void) fprintf(stderr,
	"usage: %s [-%s] file(s)...\n", tool_name, OPTSTR);
	exitcode++;
}



/* ============================================================================
 * SOURCE 69/98: minix4\exokernel\kernel_legacy\cmd\sgs\mcs\common\main.c
 * Size: 7,906 bytes, Lines: 369
 * Hash: eaa93f7f204c...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright 2012 Nexenta Systems, Inc.  All rights reserved.
 *
 *	Copyright (c) 1988 AT&T
 *	  All Rights Reserved
 *
 *
 * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */
/*
 * Copyright 2022 OmniOS Community Edition (OmniOSce) Association.
 */

#include "stdlib.h"
#include "conv.h"
#include "mcs.h"
#include "extern.h"
#define	OPTUNIT	100

static size_t optcnt = 0;
static size_t optbufsz = OPTUNIT;

/*
 * Function prototypes.
 */
static void usage(int);
static void sigexit(int);
static int setup_sectname(char *, int);
static void queue(int, char *);

int
main(int argc, char ** argv, char ** envp)
{
	const char	*opt;
	char		*str;
	int		error_count = 0, num_sect = 0, errflag = 0;
	int		c, i, my_prog;
	Cmd_Info	*cmd_info;

	/*
	 * Check for a binary that better fits this architecture.
	 */
	(void) conv_check_native(argv, envp);

	/*
	 * mcs(1) and strip() are hard linked together, determine which command
	 * was invoked.
	 */
	prog = argv[0];
	if ((str = strrchr(prog, '/')) != NULL)
		str++;
	else
		str = prog;

	if (strcmp(str, "mcs") == 0) {
		my_prog = MCS;
		opt = "a:cdn:pVz?";
	} else if (strcmp(str, "strip") == 0) {
		my_prog = STRIP;
		opt = "lxV?";
	} else
		exit(FAILURE);

	(void) setlocale(LC_ALL, "");
#if !defined(TEXT_DOMAIN)
#define	TEXT_DOMAIN "SYS_TEST"
#endif
	(void) textdomain(TEXT_DOMAIN);

	for (i = 0; signum[i]; i++)
		if (signal(signum[i], SIG_IGN) != SIG_IGN)
			(void) signal(signum[i], sigexit);

	if ((Action =
	    malloc(optbufsz * sizeof (struct action))) == NULL) {
		error_message(MALLOC_ERROR, PLAIN_ERROR, (char *)0, prog);
		exit(FAILURE);
	}

	/*
	 * Allocate command info structure
	 */
	cmd_info = (Cmd_Info *) calloc(1, sizeof (Cmd_Info));
	if (cmd_info == NULL) {
		error_message(MALLOC_ERROR, PLAIN_ERROR, (char *)0, prog);
		exit(FAILURE);
	}
	if (my_prog == STRIP)
		SET_OPT(cmd_info, I_AM_STRIP);

	while ((c = getopt(argc, argv, (char *)opt)) != EOF) {
		switch (c) {
		case 'a':
			optcnt++;
			queue(ACT_APPEND, optarg);
			SET_OPT(cmd_info, MIGHT_CHG | aFLAG);
			cmd_info->str_size += strlen(optarg) + 1;
			break;
		case 'c':
			optcnt++;
			queue(ACT_COMPRESS, NULL);
			SET_OPT(cmd_info, MIGHT_CHG | cFLAG);
			break;
		case 'd':
			optcnt++;
			if (!CHK_OPT(cmd_info, dFLAG))
				queue(ACT_DELETE, NULL);
			SET_OPT(cmd_info, MIGHT_CHG | dFLAG);
			break;
		case 'z':
			optcnt++;
			queue(ACT_ZAP, NULL);
			SET_OPT(cmd_info, MIGHT_CHG | zFLAG);
			break;
		case 'n':
			(void) setup_sectname(optarg, my_prog);
			num_sect++;
			break;
		case 'l':
			optcnt++;
			SET_OPT(cmd_info, lFLAG);
			break;
		case 'p':
			optcnt++;
			queue(ACT_PRINT, NULL);
			SET_OPT(cmd_info, pFLAG);
			break;
		case 'x':
			optcnt++;
			SET_OPT(cmd_info, xFLAG);
			break;
		case 'V':
			SET_OPT(cmd_info, VFLAG);
			(void) fprintf(stderr, "%s: %s %s\n", prog,
			    (const char *)SGU_PKG, (const char *)SGU_REL);
			break;
		case '?':
			errflag++;
			break;
		default:
			break;
		}
	}

	if (errflag) {
		usage(my_prog);
		exit(FAILURE);
	}

	/*
	 * strip command may not take any options.
	 */
	if (my_prog != STRIP) {
		if (argc == optind &&
		    (CHK_OPT(cmd_info, MIGHT_CHG) || CHK_OPT(cmd_info, pFLAG) ||
		    argc == 1))
			usage(my_prog);
		else if (!CHK_OPT(cmd_info, MIGHT_CHG) &&
		    !CHK_OPT(cmd_info, pFLAG) && !CHK_OPT(cmd_info, VFLAG))
			usage(my_prog);
	}

	/*
	 * This version only allows multiple section names
	 * only for -d option.
	 */
	if ((num_sect >= 2) && (CHK_OPT(cmd_info, pFLAG) ||
	    CHK_OPT(cmd_info, aFLAG) ||
	    CHK_OPT(cmd_info, cFLAG))) {
		error_message(USAGE_ERROR, PLAIN_ERROR, (char *)0,  prog);
		exit(FAILURE);
	}

	/*
	 * If no -n was specified,
	 * set the default, ".comment".
	 * This is for mcs only.
	 */
	if (num_sect == 0 && my_prog == MCS) {
		(void) setup_sectname(".comment", MCS);
	}

	/*
	 * If I am strip command, then add needed
	 * section names.
	 */
	if (my_prog == STRIP) {
		(void) setup_sectname(".line", MCS);
		if (CHK_OPT(cmd_info, lFLAG) == 0) {
			(void) setup_sectname(".debug", STRIP);
			(void) setup_sectname(".stab", STRIP);
		}
		if (CHK_OPT(cmd_info, dFLAG) == 0) {
			queue(ACT_DELETE, NULL);
			SET_OPT(cmd_info, MIGHT_CHG | dFLAG);
		}
	}

	(void) elf_version(EV_NONE);
	if (elf_version(EV_CURRENT) == EV_NONE) {
		error_message(ELFVER_ERROR, LIBelf_ERROR, elf_errmsg(-1), prog);
		exit(FAILURE);
	}

	if (CHK_OPT(cmd_info, pFLAG) || CHK_OPT(cmd_info, MIGHT_CHG)) {
		for (; optind < argc; optind++) {
			error_count = error_count +
			    (each_file(argv[optind], cmd_info));
		}
	}

	mcs_exit(error_count);
	/*NOTREACHED*/
	return (0);
}

/*
 * Supplementary functions
 */
static void
queue(int activity, char *string)
{
	if (optcnt > optbufsz) {
		optbufsz = optbufsz * 2;
		if ((Action = realloc((struct action *)Action,
		    optbufsz * sizeof (struct action))) == NULL) {
		    error_message(MALLOC_ERROR, PLAIN_ERROR, (char *)0, prog);
		    mcs_exit(FAILURE);
		}
	}
	Action[actmax].a_action = activity;
	Action[actmax].a_cnt = 0;
	Action[actmax].a_string = string;
	actmax++;
}

/*
 * Reset a temporary file descriptor for reuse.
 * If the file requires unlinking, that is done first.
 */
void
free_tempfile(Tmp_File *temp_file)
{
	if ((temp_file->tmp_name != NULL) && (temp_file->tmp_unlink))
		(void) unlink(temp_file->tmp_name);
	(void) memset(temp_file, 0, sizeof (*temp_file));
}

/*ARGSUSED0*/
static void
sigexit(int i)
{
	free_tempfile(&artmpfile);
	free_tempfile(&elftmpfile);
	exit(100);
}

static void
usage(int me)
{
	if (me == MCS)
		(void) fprintf(stderr, gettext(
		"usage: %s [-cdpVz] [-a string] [-n name] file ...\n"), prog);
	else
		(void) fprintf(stderr, gettext(
		"usage: %s [-lVx] file ...\n"), prog);
	mcs_exit(FAILURE);
}

void
mcs_exit(int val)
{
	free_tempfile(&artmpfile);
	free_tempfile(&elftmpfile);
	exit(val);
}

/*
 * Insert the section name 'name' into the
 * section list.
 */
static int
setup_sectname(char *name, int whoami)
{
	S_Name *new;

	/*
	 * Check if the name is already specified or not.
	 */
	if ((whoami == MCS) && (sectcmp(name) == 0))
		return (0);

	/*
	 * Allocate one
	 */
	if ((new = malloc(sizeof (S_Name))) == NULL) {
		error_message(MALLOC_ERROR, PLAIN_ERROR, (char *)0, prog);
		exit(FAILURE);
	}
	new->name = strdup(name);
	if (new->name == NULL) {
		error_message(USAGE_ERROR, PLAIN_ERROR, (char *)0, prog);
		exit(FAILURE);
	}
	if (whoami == STRIP)
		new->flags = SNAME_FLG_STRNCMP;
	new->next = NULL;

	/*
	 * Put this one in the list
	 */
	new->next = sect_head;
	sect_head = new;

	return (0);
}

/*
 * Check if the 'name' exists in the section list.
 *
 * If found
 *	return 0;
 * else
 *	return 1
 */
int
sectcmp(char *name)
{
	/*
	 * Check if the name is already specified or not.
	 */
	if (sect_head != NULL) {
		S_Name *p1 = sect_head;
		while (p1 != NULL) {
			if (p1->flags & SNAME_FLG_STRNCMP) {
				if (strncmp(p1->name,
				    name, strlen(p1->name)) == 0)
					return (0);
			} else if (strcmp(p1->name, name) == 0) {
				return (0);	/* silently ignore */
			}
			p1 = p1->next;
		}
	}
	return (1);
}



/* ============================================================================
 * SOURCE 70/98: minix4\exokernel\kernel_legacy\cmd\sgs\lex\common\main.c
 * Size: 8,731 bytes, Lines: 390
 * Hash: 48d9f1def445...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2024 MNX Cloud, Inc.
 * Copyright (c) 2014 Gary Mills
 * Copyright (c) 2013, joyent, Inc.  All rights reserved.
 *
 * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

/* Copyright (c) 1988 AT&T */
/* All Rights Reserved */

/* Copyright 1976, Bell Telephone Laboratories, Inc. */

#include <string.h>
#include "once.h"
#include "sgs.h"
#include <locale.h>
#include <limits.h>

static wchar_t  L_INITIAL[] = {'I', 'N', 'I', 'T', 'I', 'A', 'L', 0};
static void get1core(void);
static void free1core(void);
static void get2core(void);
static void free2core(void);
static void get3core(void);
#ifdef DEBUG
static void free3core(void);
#endif

/*
 * construct path to file and open it.
 */
static FILE *
lex_open_driver(const char *fname, const char *dir)
{
	FILE *fp;
	char path[PATH_MAX];

	if (dir == NULL)
		dir = NBASE;
	(void) snprintf(path, PATH_MAX, "%s/%s", dir, fname);
	fp = fopen(path, "r");
	if (fp == NULL)
		error("Lex driver missing, file %s", path);
	return (fp);
}

int
main(int argc, char **argv)
{
	int i;
	int c;
	char *apath = NULL;
	char *ypath;
	Boolean eoption = 0, woption = 0;

	sargv = argv;
	sargc = argc;
	(void) setlocale(LC_ALL, "");
#ifdef DEBUG
	while ((c = getopt(argc, argv, "dyctvnewVQ:Y:")) != EOF) {
#else
	while ((c = getopt(argc, argv, "ctvnewVQ:Y:")) != EOF) {
#endif
		switch (c) {
#ifdef DEBUG
			case 'd':
				debug++;
				break;
			case 'y':
				yydebug = TRUE;
				break;
#endif
			case 'V':
				(void) fprintf(stderr, "lex: %s %s\n",
				    (const char *)SGU_PKG,
				    (const char *)SGU_REL);
				break;
			case 'Q':
				v_stmp = optarg;
				if (*v_stmp != 'y' && *v_stmp != 'n')
					error(
					"lex: -Q should be followed by [y/n]");
				break;
			case 'Y':
				apath = optarg;
				break;
			case 'c':
				ratfor = FALSE;
				break;
			case 't':
				fout = stdout;
				break;
			case 'v':
				report = 1;
				break;
			case 'n':
				report = 0;
				break;
			case 'w':
			case 'W':
				woption = 1;
				handleeuc = 1;
				widecio = 1;
				break;
			case 'e':
			case 'E':
				eoption = 1;
				handleeuc = 1;
				widecio = 0;
				break;
			default:
				(void) fprintf(stderr,
				"Usage: lex [-ewctvnV] [-Y directory] "
				"[-Q(y/n)] [file]\n");
				exit(1);
		}
	}
	if (woption && eoption) {
		error(
		"You may not specify both -w and -e simultaneously.");
	}
	no_input = argc - optind;
	if (no_input) {
		/* XCU4: recognize "-" file operand for stdin */
		if (strcmp(argv[optind], "-") == 0)
			fin = stdin;
		else {
			fin = fopen(argv[optind], "r");
			if (fin == NULL)
				error(
				"Can't open input file -- %s", argv[optind]);
		}
	} else
		fin = stdin;

	/* may be gotten: def, subs, sname, schar, ccl, dchar */
	(void) gch();

	/* may be gotten: name, left, right, nullstr, parent */
	get1core();

	scopy(L_INITIAL, sp);
	sname[0] = sp;
	sp += slength(L_INITIAL) + 1;
	sname[1] = 0;

	/* XCU4: %x exclusive start */
	exclusive[0] = 0;

	if (!handleeuc) {
		/*
		 * Set ZCH and ncg to their default values
		 * as they may be needed to handle %t directive.
		 */
		ZCH = ncg = NCH; /* ncg behaves as constant in this mode. */
	}

	/* may be disposed of: def, subs, dchar */
	if (yyparse())
		exit(1);	/* error return code */

	if (handleeuc) {
		ncg = ncgidtbl * 2;
		ZCH = ncg;
		if (ncg >= MAXNCG)
			error(
			"Too complex rules -- requires too many char groups.");
		sortcgidtbl();
	}
	repbycgid(); /* Call this even in ASCII compat. mode. */

	/*
	 * maybe get:
	 *		tmpstat, foll, positions, gotof, nexts,
	 *		nchar, state, atable, sfall, cpackflg
	 */
	free1core();
	get2core();
	ptail();
	mkmatch();
#ifdef DEBUG
	if (debug)
		pccl();
#endif
	sect  = ENDSECTION;
	if (tptr > 0)
		cfoll(tptr-1);
#ifdef DEBUG
	if (debug)
		pfoll();
#endif
	cgoto();
#ifdef DEBUG
	if (debug) {
		(void) printf("Print %d states:\n", stnum + 1);
		for (i = 0; i <= stnum; i++)
			stprt(i);
	}
#endif
	/*
	 * may be disposed of:
	 *		positions, tmpstat, foll, state, name,
	 *		left, right, parent, ccl, schar, sname
	 * maybe get:	 verify, advance, stoff
	 */
	free2core();
	get3core();
	layout();
	/*
	 * may be disposed of:
	 *		verify, advance, stoff, nexts, nchar,
	 *		gotof, atable, ccpackflg, sfall
	 */

#ifdef DEBUG
	free3core();
#endif

	if (handleeuc) {
		if (ratfor)
			error("Ratfor is not supported by -w or -e option.");
		ypath = EUCNAME;
	}
	else
		ypath = ratfor ? RATNAME : CNAME;

	fother = lex_open_driver(ypath, apath);
	while ((i = getc(fother)) != EOF)
		(void) putc((char)i, fout);
	(void) fclose(fother);
	(void) fclose(fout);
	if (report == 1)
		statistics();
	(void) fclose(stdout);
	(void) fclose(stderr);
	return (0);	/* success return code */
}

static void
get1core(void)
{
	/*LINTED: E_BAD_PTR_CAST_ALIGN*/
	ccptr =	ccl = (CHR *)myalloc(CCLSIZE, sizeof (*ccl));
	/*LINTED: E_BAD_PTR_CAST_ALIGN*/
	pcptr = pchar = (CHR *)myalloc(pchlen, sizeof (*pchar));
	/*LINTED: E_BAD_PTR_CAST_ALIGN*/
	def = (CHR **)myalloc(DEFSIZE, sizeof (*def));
	/*LINTED: E_BAD_PTR_CAST_ALIGN*/
	subs = (CHR **)myalloc(DEFSIZE, sizeof (*subs));
	/*LINTED: E_BAD_PTR_CAST_ALIGN*/
	dp = dchar = (CHR *)myalloc(DEFCHAR, sizeof (*dchar));
	/*LINTED: E_BAD_PTR_CAST_ALIGN*/
	sname = (CHR **)myalloc(STARTSIZE, sizeof (*sname));
	/* XCU4: exclusive start array */
	/*LINTED: E_BAD_PTR_CAST_ALIGN*/
	exclusive = (int *)myalloc(STARTSIZE, sizeof (*exclusive));
	/*LINTED: E_BAD_PTR_CAST_ALIGN*/
	sp = schar = (CHR *)myalloc(STARTCHAR, sizeof (*schar));
	if (ccl == 0 || def == 0 ||
	    pchar == 0 || subs == 0 || dchar == 0 ||
	    sname == 0 || exclusive == 0 || schar == 0)
		error("Too little core to begin");
}

static void
free1core(void)
{
	free(def);
	free(subs);
	free(dchar);
}

static void
get2core(void)
{
	int i;
	/*LINTED: E_BAD_PTR_CAST_ALIGN*/
	gotof = (int *)myalloc(nstates, sizeof (*gotof));
	/*LINTED: E_BAD_PTR_CAST_ALIGN*/
	nexts = (int *)myalloc(ntrans, sizeof (*nexts));
	/*LINTED: E_BAD_PTR_CAST_ALIGN*/
	nchar = (CHR *)myalloc(ntrans, sizeof (*nchar));
	/*LINTED: E_BAD_PTR_CAST_ALIGN*/
	state = (int **)myalloc(nstates, sizeof (*state));
	/*LINTED: E_BAD_PTR_CAST_ALIGN*/
	atable = (int *)myalloc(nstates, sizeof (*atable));
	/*LINTED: E_BAD_PTR_CAST_ALIGN*/
	sfall = (int *)myalloc(nstates, sizeof (*sfall));
	cpackflg = (Boolean *)myalloc(nstates, sizeof (*cpackflg));
	/*LINTED: E_BAD_PTR_CAST_ALIGN*/
	tmpstat = (CHR *)myalloc(tptr+1, sizeof (*tmpstat));
	/*LINTED: E_BAD_PTR_CAST_ALIGN*/
	foll = (int **)myalloc(tptr+1, sizeof (*foll));
	/*LINTED: E_BAD_PTR_CAST_ALIGN*/
	nxtpos = positions = (int *)myalloc(maxpos, sizeof (*positions));
	if (tmpstat == 0 || foll == 0 || positions == 0 ||
	    gotof == 0 || nexts == 0 || nchar == 0 ||
	    state == 0 || atable == 0 || sfall == 0 || cpackflg == 0)
		error("Too little core for state generation");
	for (i = 0; i <= tptr; i++)
		foll[i] = 0;
}

static void
free2core(void)
{
	free(positions);
	free(tmpstat);
	free(foll);
	free(name);
	free(left);
	free(right);
	free(parent);
	free(nullstr);
	free(state);
	free(sname);
	/* XCU4: exclusive start array */
	free(exclusive);
	free(schar);
	free(ccl);
}

static void
get3core(void)
{
	/*LINTED: E_BAD_PTR_CAST_ALIGN*/
	verify = (int *)myalloc(outsize, sizeof (*verify));
	/*LINTED: E_BAD_PTR_CAST_ALIGN*/
	advance = (int *)myalloc(outsize, sizeof (*advance));
	/*LINTED: E_BAD_PTR_CAST_ALIGN*/
	stoff = (int *)myalloc(stnum+2, sizeof (*stoff));
	if (verify == 0 || advance == 0 || stoff == 0)
		error("Too little core for final packing");
}

#ifdef DEBUG
static void
free3core(void)
{
	free(advance);
	free(verify);
	free(stoff);
	free(gotof);
	free(nexts);
	free(nchar);
	free(atable);
	free(sfall);
	free(cpackflg);
}
#endif

BYTE *
myalloc(int a, int b)
{
	BYTE *i;
	i = calloc(a,  b);
	if (i == 0)
		warning("calloc returns a 0");
	return (i);
}

void
yyerror(char *s)
{
	(void) fprintf(stderr,
	    "\"%s\":line %d: Error: %s\n", sargv[optind], yyline, s);
}



/* ============================================================================
 * SOURCE 71/98: minix4\exokernel\kernel_legacy\cmd\sgs\elfwrap\common\main.c
 * Size: 4,621 bytes, Lines: 182
 * Hash: a5b1e4814079...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

/*
 * Wrap data in an elf file.
 */
#include	<fcntl.h>
#include	<unistd.h>
#include	<libgen.h>
#include	<errno.h>
#include	<stdio.h>
#include	<string.h>
#include	<locale.h>
#include	<libintl.h>
#include	<conv.h>
#include	<msg.h>
#include	<_elfwrap.h>

const char *
_elfwrap_msg(Msg mid)
{
	return (gettext(MSG_ORIG(mid)));
}

int
main(int argc, char **argv, char **envp)
{
	const char	*prog, *ofile = NULL, *pstr = NULL;
	int		fd, var;
	uchar_t		class = ELFCLASS32;
	ushort_t	mach = EM_NONE;
	ObjDesc_t	odesc = { NULL, 0, 0, 0 };

	/*
	 * If we're on a 64-bit kernel, try to exec a full 64-bit version of
	 * the binary.  If successful, conv_check_native() won't return.
	 */
	(void) conv_check_native(argv, envp);

	/*
	 * Establish locale.
	 */
	(void) setlocale(LC_MESSAGES, MSG_ORIG(MSG_STR_EMPTY));
	(void) textdomain(MSG_ORIG(MSG_SUNW_OST_SGS));

	(void) setvbuf(stdout, NULL, _IOLBF, 0);
	(void) setvbuf(stderr, NULL, _IOLBF, 0);

	prog = basename(argv[0]);
	opterr = 0;
	while ((var = getopt(argc, argv, MSG_ORIG(MSG_ARG_OPTIONS))) != EOF) {
		switch (var) {
		case '6':			/* Create a 64-bit object */
			if (optarg[0] != '4') {
				(void) fprintf(stderr,
				    MSG_INTL(MSG_ARG_ILLEGAL), prog,
				    MSG_ORIG(MSG_ARG_6), optarg);
				return (1);
			}
			class = ELFCLASS64;
			break;
		case 'o':			/* output file name */
			ofile = optarg;
			break;
		case 'z':			/* output file platform */
			if (strncmp(optarg, MSG_ORIG(MSG_ARG_TARGET),
			    MSG_ARG_TARGET_SIZE) == 0)
				pstr = optarg + MSG_ARG_TARGET_SIZE;
			else {
				(void) fprintf(stderr,
				    MSG_INTL(MSG_ARG_ILLEGAL), prog,
				    MSG_ORIG(MSG_ARG_Z), optarg);
				return (1);
			}
			break;
		case '?':
			(void) fprintf(stderr, MSG_INTL(MSG_USAGE_BRIEF),
			    prog);
			return (1);
		default:
			break;
		}
	}

	/*
	 * Verify that we have at least one input data file, and if no output
	 * file has been specified, provide a default.  Update argc and argv
	 * for input() to continue processing any input files.
	 */
	argv += optind;
	argc -= optind;
	if (argc == 0) {
		(void) fprintf(stderr, MSG_INTL(MSG_USAGE_BRIEF), prog);
		return (1);
	}
	if (ofile == NULL)
		ofile = MSG_ORIG(MSG_STR_AWRAPO);

	/*
	 * If the user specified a target, use it to determine the machine type
	 * for the output object.  If no target is specified, we leave "mach" as
	 * EM_NONE.  output() will replace EM_NONE with the appropriate machine
	 * code for the system running elfwrap(1).
	 */
	if (pstr) {
		if (strcasecmp(pstr, MSG_ORIG(MSG_TARG_SPARC)) == 0) {
			if (class == ELFCLASS64)
				mach = EM_SPARCV9;
			else
				mach = EM_SPARC;

		} else if (strcasecmp(pstr, MSG_ORIG(MSG_TARG_X86)) == 0) {
			if (class == ELFCLASS64)
				mach = EM_AMD64;
			else
				mach = EM_386;

		} else {
			(void) fprintf(stderr, MSG_INTL(MSG_ARG_BADTARG), prog,
			    pstr);
			return (1);
		}
	}

	/*
	 * Create the input information for the new image.
	 */
	if (class == ELFCLASS64) {
		if (input64(argc, argv, prog, ofile, &odesc) == 1)
			return (1);
	} else {
		if (input32(argc, argv, prog, ofile, &odesc) == 1)
			return (1);
	}

	/*
	 * Create and truncate the output file.
	 */
	if ((fd = open(ofile, (O_RDWR | O_CREAT | O_TRUNC), 0666)) < 0) {
		int err = errno;
		(void) fprintf(stderr, MSG_INTL(MSG_ERR_OPEN), prog,
		    ofile, strerror(err));
		return (1);
	}

	/*
	 * Initialize libelf, and create the new ELF file as the class dictates.
	 */
	if (elf_version(EV_CURRENT) == EV_NONE) {
		(void) fprintf(stderr, MSG_INTL(MSG_ERR_LIBELF), prog,
		    EV_CURRENT);
		return (1);
	}
	if (class == ELFCLASS64)
		return (output64(prog, fd, ofile, mach, &odesc));
	else
		return (output32(prog, fd, ofile, mach, &odesc));
}



/* ============================================================================
 * SOURCE 72/98: minix4\exokernel\kernel_legacy\cmd\sgs\elfdump\common\main.c
 * Size: 24,975 bytes, Lines: 962
 * Hash: b84596f2e678...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (c) 2006, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright 2024 Oxide Computer Company
 */

/*
 * Dump an elf file.
 */
#include	<sys/param.h>
#include	<fcntl.h>
#include	<stdio.h>
#include	<stdlib.h>
#include	<ctype.h>
#include	<_libelf.h>
#include	<link.h>
#include	<stdarg.h>
#include	<unistd.h>
#include	<libgen.h>
#include	<libintl.h>
#include	<locale.h>
#include	<errno.h>
#include	<strings.h>
#include	<debug.h>
#include	<conv.h>
#include	<msg.h>
#include	<_elfdump.h>
#include	<sys/elf_SPARC.h>
#include	<sys/elf_amd64.h>
#include	<sys/hexdump.h>


const Cache	cache_init = {NULL, NULL, NULL, NULL, 0};



/*
 * The -I, -N, and -T options are called "match options", because
 * they allow selecting the items to be displayed based on matching
 * their index, name, or type.
 *
 * The ELF information to which -I, -N, or -T are applied in
 * the current invocation is called the "match item".
 */
typedef enum {
	MATCH_ITEM_PT,		/* Program header (PT_) */
	MATCH_ITEM_SHT		/* Section header (SHT_) */
} match_item_t;

/* match_opt_t is  used to note which match option was used */
typedef enum {
	MATCH_OPT_NAME,		/* Record contains a name */
	MATCH_OPT_NDX,		/* Record contains a single index */
	MATCH_OPT_RANGE,	/* Record contains an index range */
	MATCH_OPT_TYPE,		/* Record contains a type (shdr or phdr) */
} match_opt_t;

typedef struct _match {
	struct _match	*next;		/* Pointer to next item in list */
	match_opt_t	opt_type;
	union {
		const char	*name;	/* MATCH_OPT_NAME */
		struct {		/* MATCH_OPT_NDX and MATCH_OPT_RANGE */
			int	start;
			int	end;	/* Only for MATCH_OPT_RANGE */
		} ndx;
		uint32_t	type;	/* MATCH_OPT_TYPE */
	} value;
} match_rec_t;

static struct {
	match_item_t	item_type;	/* Type of item being matched */
	match_rec_t	*list;		/* Records for (-I, -N, -T) options */
} match_state;



const char *
_elfdump_msg(Msg mid)
{
	return (gettext(MSG_ORIG(mid)));
}

/*
 * Determine whether a symbol name should be demangled.
 */
const char *
demangle(const char *name, uint_t flags)
{
	if (flags & FLG_CTL_DEMANGLE)
		return (Elf_demangle_name(name));
	else
		return ((char *)name);
}

/*
 * Define our own standard error routine.
 */
void
failure(const char *file, const char *func)
{
	(void) fprintf(stderr, MSG_INTL(MSG_ERR_FAILURE),
	    file, func, elf_errmsg(elf_errno()));
}

/*
 * The full usage message
 */
static void
detail_usage()
{
	(void) fprintf(stderr, MSG_INTL(MSG_USAGE_DETAIL1));
	(void) fprintf(stderr, MSG_INTL(MSG_USAGE_DETAIL2));
	(void) fprintf(stderr, MSG_INTL(MSG_USAGE_DETAIL3));
	(void) fprintf(stderr, MSG_INTL(MSG_USAGE_DETAIL4));
	(void) fprintf(stderr, MSG_INTL(MSG_USAGE_DETAIL5));
	(void) fprintf(stderr, MSG_INTL(MSG_USAGE_DETAIL6));
	(void) fprintf(stderr, MSG_INTL(MSG_USAGE_DETAIL7));
	(void) fprintf(stderr, MSG_INTL(MSG_USAGE_DETAIL8));
	(void) fprintf(stderr, MSG_INTL(MSG_USAGE_DETAIL9));
	(void) fprintf(stderr, MSG_INTL(MSG_USAGE_DETAIL10));
	(void) fprintf(stderr, MSG_INTL(MSG_USAGE_DETAIL11));
	(void) fprintf(stderr, MSG_INTL(MSG_USAGE_DETAIL12));
	(void) fprintf(stderr, MSG_INTL(MSG_USAGE_DETAIL13));
	(void) fprintf(stderr, MSG_INTL(MSG_USAGE_DETAIL14));
	(void) fprintf(stderr, MSG_INTL(MSG_USAGE_DETAIL15));
	(void) fprintf(stderr, MSG_INTL(MSG_USAGE_DETAIL16));
	(void) fprintf(stderr, MSG_INTL(MSG_USAGE_DETAIL17));
	(void) fprintf(stderr, MSG_INTL(MSG_USAGE_DETAIL18));
	(void) fprintf(stderr, MSG_INTL(MSG_USAGE_DETAIL19));
	(void) fprintf(stderr, MSG_INTL(MSG_USAGE_DETAIL20));
	(void) fprintf(stderr, MSG_INTL(MSG_USAGE_DETAIL21));
	(void) fprintf(stderr, MSG_INTL(MSG_USAGE_DETAIL22));
	(void) fprintf(stderr, MSG_INTL(MSG_USAGE_DETAIL23));
	(void) fprintf(stderr, MSG_INTL(MSG_USAGE_DETAIL24));
	(void) fprintf(stderr, MSG_INTL(MSG_USAGE_DETAIL25));
	(void) fprintf(stderr, MSG_INTL(MSG_USAGE_DETAIL26));
}

/*
 * Output a block of raw data as hex bytes. Each row is given
 * the index of the first byte in the row.
 *
 * entry:
 *	data - Pointer to first byte of data to be displayed
 *	n - # of bytes of data
 *	bytes_per_col - # of space separated bytes to output in each column.
 *	col_per_row - # of columns to output per row
 *
 * exit:
 *	The formatted data has been sent to stdout.
 */
typedef struct {
	uint_t	dd_indent;
} dump_data_t;

static int
dump_hex_bytes_cb(void *arg, uint64_t addr, const char *str,
    size_t len __unused)
{
	char index[MAXNDXSIZE];
	dump_data_t *dd = arg;
	size_t index_width;

	(void) snprintf(index, sizeof (index), MSG_ORIG(MSG_FMT_INDEX2),
	    EC_WORD(addr));
	index_width = strlen(index);
	index_width = S_ROUND(index_width, 8);
	dbg_print(0, MSG_ORIG(MSG_HEXDUMP_ROW),
	    dd->dd_indent, MSG_ORIG(MSG_STR_EMPTY),
	    index_width, index, str);
	return (0);
}

void
dump_hex_bytes(const void *data, size_t n, int indent, int bytes_per_col,
    int col_per_row)
{
	hexdump_t h;
	dump_data_t dd = {
		.dd_indent = indent
	};
	hexdump_init(&h);
	hexdump_set_grouping(&h, bytes_per_col);
	hexdump_set_width(&h, bytes_per_col * col_per_row);
	(void) hexdumph(&h, data, n, HDF_DOUBLESPACE, dump_hex_bytes_cb, &dd);
	hexdump_fini(&h);
}

/*
 * Convert the ASCII representation of an index, or index range, into
 * binary form, and store it in rec:
 *
 *	index: An positive or 0 valued integer
 *	range: Two indexes, separated by a ':' character, denoting
 *		a range of allowed values. If the second value is omitted,
 *		any values equal to or greater than the first will match.
 *
 * exit:
 *	On success, *rec is filled in with a MATCH_OPT_NDX or MATCH_OPT_RANGE
 *	value, and this function returns (1). On failure, the contents
 *	of *rec are undefined, and (0) is returned.
 */
int
process_index_opt(const char *str, match_rec_t *rec)
{
#define	SKIP_BLANK for (; *str && isspace(*str); str++)

	char	*endptr;

	rec->value.ndx.start = strtol(str, &endptr, 10);
	/* Value must use some of the input, and be 0 or positive */
	if ((str == endptr) || (rec->value.ndx.start < 0))
		return (0);
	str = endptr;

	SKIP_BLANK;
	if (*str != ':') {
		rec->opt_type = MATCH_OPT_NDX;
	} else {
		str++;					/* Skip the ':' */
		rec->opt_type = MATCH_OPT_RANGE;
		SKIP_BLANK;
		if (*str == '\0') {
			rec->value.ndx.end = -1;	/* Indicates "to end" */
		} else {
			rec->value.ndx.end = strtol(str, &endptr, 10);
			if ((str == endptr) || (rec->value.ndx.end < 0))
				return (0);
			str = endptr;
			SKIP_BLANK;
		}
	}

	/* Syntax error if anything is left over */
	if (*str != '\0')
		return (0);

	return (1);

#undef	SKIP_BLANK
}

/*
 * Convert a string containing a specific type of ELF constant, or an ASCII
 * representation of a number, to an integer. Strings starting with '0'
 * are taken to be octal, those staring with '0x' are hex, and all
 * others are decimal.
 *
 * entry:
 *	str - String to be converted
 *	ctype - Constant type
 *	v - Address of variable to receive resulting value.
 *
 * exit:
 *	On success, returns True (1) and *v is set to the value.
 *	On failure, returns False (0) and *v is undefined.
 */
typedef enum {
	ATOUI_PT,
	ATOUI_SHT,
	ATOUI_OSABI
} atoui_type_t;

static int
atoui(const char *str, atoui_type_t type, uint32_t *v)
{
	conv_strtol_uvalue_t	uvalue;
	char			*endptr;

	if (conv_iter_strtol_init(str, &uvalue) != 0) {
		switch (type) {
		case ATOUI_PT:
			if (conv_iter_phdr_type(CONV_OSABI_ALL, CONV_FMT_ALT_CF,
			    conv_iter_strtol, &uvalue) == CONV_ITER_DONE)
				break;
			(void) conv_iter_phdr_type(CONV_OSABI_ALL,
			    CONV_FMT_ALT_NF, conv_iter_strtol, &uvalue);
			break;
		case ATOUI_SHT:
			if (conv_iter_sec_type(CONV_OSABI_ALL, CONV_MACH_ALL,
			    CONV_FMT_ALT_CF, conv_iter_strtol, &uvalue) ==
			    CONV_ITER_DONE)
				break;
			(void) conv_iter_sec_type(CONV_OSABI_ALL, CONV_MACH_ALL,
			    CONV_FMT_ALT_NF, conv_iter_strtol, &uvalue);
			break;
		case ATOUI_OSABI:
			if (conv_iter_ehdr_osabi(CONV_FMT_ALT_CF,
			    conv_iter_strtol, &uvalue) == CONV_ITER_DONE)
				break;
			(void) conv_iter_ehdr_osabi(CONV_FMT_ALT_NF,
			    conv_iter_strtol, &uvalue);
			break;
		}
		if (uvalue.csl_found) {
			*v = uvalue.csl_value;
			return (1);
		}
	}

	*v = strtoull(str, &endptr, 0);

	/* If the left over part contains anything but whitespace, fail */
	for (; *endptr; endptr++)
		if (!isspace(*endptr))
			return (0);
	return (1);
}

/*
 * Called after getopt() processing is finished if there is a non-empty
 * match list. Prepares the matching code for use.
 *
 * exit:
 *	Returns True (1) if no errors are encountered. Writes an
 *	error string to stderr and returns False (0) otherwise.
 */
static int
match_prepare(char *argv0, uint_t flags)
{
	match_rec_t	*list;
	const char	*str;
	int		minus_p = (flags & FLG_SHOW_PHDR) != 0;
	atoui_type_t	atoui_type;

	/*
	 * Flag ambiguous attempt to use match option with both -p and
	 * and one or more section SHOW options. In this case, we
	 * can't tell what type of item we're supposed to match against.
	 */
	if (minus_p && (flags & FLG_MASK_SHOW_SHDR)) {
		(void) fprintf(stderr, MSG_INTL(MSG_ERR_AMBIG_MATCH),
		    basename(argv0));
		return (0);
	}

	/* Set the match type, based on the presence of the -p option */
	if (minus_p) {
		match_state.item_type = MATCH_ITEM_PT;
		atoui_type = ATOUI_PT;
	} else {
		match_state.item_type = MATCH_ITEM_SHT;
		atoui_type = ATOUI_SHT;
	}

	/*
	 * Scan match list and perform any necessary fixups:
	 *
	 * MATCH_OPT_NAME: If -p is specified, convert MATCH_OPT_NAME (-N)
	 *	requests into MATCH_OPT_TYPE (-T).
	 *
	 * MATCH_OPT_TYPE: Now that we know item type we are matching
	 *	against, we can convert the string saved in the name
	 *	field during getopt() processing into an integer and
	 *	write it into the type field.
	 */
	for (list = match_state.list; list; list = list->next) {
		if ((list->opt_type == MATCH_OPT_NAME) && minus_p)
			list->opt_type = MATCH_OPT_TYPE;

		if (list->opt_type != MATCH_OPT_TYPE)
			continue;

		str = list->value.name;
		if (atoui(str, atoui_type, &list->value.type) == 0) {
			const char *fmt = minus_p ?
			    MSG_INTL(MSG_ERR_BAD_T_PT) :
			    MSG_INTL(MSG_ERR_BAD_T_SHT);

			(void) fprintf(stderr, fmt, basename(argv0), str);
			return (0);
		}
	}

	return (1);
}


/*
 * Returns True (1) if the item with the given name or index should
 * be displayed, and False (0) if it should not be.
 *
 * entry:
 *	match_flags - Bitmask specifying matching options, as described
 *		in _elfdump.h.
 *	name - If MATCH_F_NAME flag is set, name of item under
 *		consideration. Otherwise ignored.
 *		should not be considered.
 *	ndx - If MATCH_F_NDX flag is set, index of item under consideration.
 *	type - If MATCH_F_TYPE is set, type of item under consideration.
 *		If MATCH_F_PHDR is set, this would be a program
 *		header type (PT_). Otherwise, a section header type (SHT_).
 *
 * exit:
 *	True will be returned if the given name/index matches those given
 *	by one of the (-I, -N -T) command line options, or if no such option
 *	was used in the command invocation and MATCH_F_STRICT is not
 *	set.
 */
int
match(match_flags_t match_flags, const char *name, uint_t ndx, uint_t type)
{
	match_item_t item_type = (match_flags & MATCH_F_PHDR) ?
	    MATCH_ITEM_PT  : MATCH_ITEM_SHT;
	match_rec_t *list;

	/*
	 * If there is no match list, then we use the MATCH_F_STRICT
	 * flag to decide what to return. In the strict case, we return
	 * False (0), in the normal case, True (1).
	 */
	if (match_state.list == NULL)
		return ((match_flags & MATCH_F_STRICT) == 0);

	/*
	 * If item being checked is not the current match type,
	 * then allow it.
	 */
	if (item_type != match_state.item_type)
		return (1);

	/* Run through the match records and check for a hit */
	for (list = match_state.list; list; list = list->next) {
		switch (list->opt_type) {
		case MATCH_OPT_NAME:
			if (((match_flags & MATCH_F_NAME) == 0) ||
			    (name == NULL))
				break;
			if (strcmp(list->value.name, name) == 0)
				return (1);
			break;
		case MATCH_OPT_NDX:
			if ((match_flags & MATCH_F_NDX) &&
			    (ndx == list->value.ndx.start))
				return (1);
			break;
		case MATCH_OPT_RANGE:
			/*
			 * A range end value less than 0 means that any value
			 * above the start is acceptible.
			 */
			if ((match_flags & MATCH_F_NDX) &&
			    (ndx >= list->value.ndx.start) &&
			    ((list->value.ndx.end < 0) ||
			    (ndx <= list->value.ndx.end)))
				return (1);
			break;

		case MATCH_OPT_TYPE:
			if ((match_flags & MATCH_F_TYPE) &&
			    (type == list->value.type))
				return (1);
			break;
		}
	}

	/* Nothing matched */
	return (0);
}

/*
 * Add an entry to match_state.list for use by match(). This routine is for
 * use during getopt() processing. It should not be called once
 * match_prepare() has been called.
 *
 * Return True (1) for success. On failure, an error is written
 * to stderr, and False (0) is returned.
 */
static int
add_match_record(char *argv0, match_rec_t *data)
{
	match_rec_t	*rec;
	match_rec_t	*list;

	if ((rec = malloc(sizeof (*rec))) == NULL) {
		int err = errno;
		(void) fprintf(stderr, MSG_INTL(MSG_ERR_MALLOC),
		    basename(argv0), strerror(err));
		return (0);
	}

	*rec = *data;

	/* Insert at end of match_state.list */
	if (match_state.list == NULL) {
		match_state.list = rec;
	} else {
		for (list = match_state.list; list->next != NULL;
		    list = list->next)
			;
		list->next = rec;
	}

	rec->next = NULL;
	return (1);
}

static int
decide(const char *file, int fd, Elf *elf, uint_t flags,
    const char *wname, int wfd, uchar_t osabi)
{
	int r;

	if (gelf_getclass(elf) == ELFCLASS64)
		r = regular64(file, fd, elf, flags, wname, wfd, osabi);
	else
		r = regular32(file, fd, elf, flags, wname, wfd, osabi);

	return (r);
}

static int
archive(const char *file, int fd, Elf *elf, uint_t flags,
    const char *wname, int wfd, uchar_t osabi)
{
	Elf_Cmd		cmd = ELF_C_READ;
	Elf_Arhdr	*arhdr;
	Elf		*_elf = NULL;
	size_t		ptr;
	Elf_Arsym	*arsym = NULL;

	/*
	 * Determine if the archive symbol table itself is required.
	 */
	if ((flags & FLG_SHOW_SYMBOLS) &&
	    match(MATCH_F_NAME, MSG_ORIG(MSG_ELF_ARSYM), 0, 0)) {
		/*
		 * Get the archive symbol table.
		 */
		if (((arsym = elf_getarsym(elf, &ptr)) == 0) && elf_errno()) {
			/*
			 * The arsym could be 0 even though there was no error.
			 * Print the error message only when there was
			 * real error from elf_getarsym().
			 */
			failure(file, MSG_ORIG(MSG_ELF_GETARSYM));
			return (0);
		}
	}

	/*
	 * Print the archive symbol table only when the archive symbol
	 * table exists and it was requested to print.
	 */
	if (arsym) {
		size_t		cnt;
		char		index[MAXNDXSIZE];
		size_t		offset = 0, _offset = 0;
		const char	*fmt_arsym1, *fmt_arsym2;

		/*
		 * Print out all the symbol entries. The format width used
		 * corresponds to whether the archive symbol table is 32
		 * or 64-bit. We see them via Elf_Arhdr as size_t values
		 * in either case with no information loss (see the comments
		 * in libelf/getarsym.c) so this is done simply to improve
		 * the user presentation.
		 */
		if (_elf_getarsymwordsize(elf) == 8) {
			dbg_print(0, MSG_INTL(MSG_ARCHIVE_SYMTAB_64));
			dbg_print(0, MSG_INTL(MSG_ARCHIVE_FIELDS_64));

			fmt_arsym1 = MSG_ORIG(MSG_FMT_ARSYM1_64);
			fmt_arsym2 = MSG_ORIG(MSG_FMT_ARSYM2_64);
		} else {
			dbg_print(0, MSG_INTL(MSG_ARCHIVE_SYMTAB_32));
			dbg_print(0, MSG_INTL(MSG_ARCHIVE_FIELDS_32));

			fmt_arsym1 = MSG_ORIG(MSG_FMT_ARSYM1_32);
			fmt_arsym2 = MSG_ORIG(MSG_FMT_ARSYM2_32);
		}

		for (cnt = 0; cnt < ptr; cnt++, arsym++) {
			/*
			 * For each object obtain an elf descriptor so that we
			 * can establish the members name.  Note, we have had
			 * archives where the archive header has not been
			 * obtainable so be lenient with errors.
			 */
			if ((offset == 0) || ((arsym->as_off != 0) &&
			    (arsym->as_off != _offset))) {

				if (_elf)
					(void) elf_end(_elf);

				if (elf_rand(elf, arsym->as_off) !=
				    arsym->as_off) {
					failure(file, MSG_ORIG(MSG_ELF_RAND));
					arhdr = NULL;
				} else if ((_elf = elf_begin(fd,
				    ELF_C_READ, elf)) == 0) {
					failure(file, MSG_ORIG(MSG_ELF_BEGIN));
					arhdr = NULL;
				} else if ((arhdr = elf_getarhdr(_elf)) == 0) {
					failure(file,
					    MSG_ORIG(MSG_ELF_GETARHDR));
					arhdr = NULL;
				}

				_offset = arsym->as_off;
				if (offset == 0)
					offset = _offset;
			}

			(void) snprintf(index, MAXNDXSIZE,
			    MSG_ORIG(MSG_FMT_INDEX), EC_XWORD(cnt));
			if (arsym->as_off)
				dbg_print(0, fmt_arsym1, index,
				    EC_XWORD(arsym->as_off),
				    arhdr ? arhdr->ar_name :
				    MSG_INTL(MSG_STR_UNKNOWN), (arsym->as_name ?
				    demangle(arsym->as_name, flags) :
				    MSG_INTL(MSG_STR_NULL)));
			else
				dbg_print(0, fmt_arsym2, index,
				    EC_XWORD(arsym->as_off));
		}

		if (_elf)
			(void) elf_end(_elf);

		/*
		 * If we only need the archive symbol table return.
		 */
		if ((flags & FLG_SHOW_SYMBOLS) &&
		    match(MATCH_F_STRICT | MATCH_F_NAME,
		    MSG_ORIG(MSG_ELF_ARSYM), -1, -1))
			return (0);

		/*
		 * Reset elf descriptor in preparation for processing each
		 * member.
		 */
		if (offset)
			(void) elf_rand(elf, offset);
	}

	/*
	 * Process each object within the archive.
	 */
	while ((_elf = elf_begin(fd, cmd, elf)) != NULL) {
		char	name[MAXPATHLEN];

		if ((arhdr = elf_getarhdr(_elf)) == NULL) {
			failure(file, MSG_ORIG(MSG_ELF_GETARHDR));
			return (0);
		}
		if (*arhdr->ar_name != '/') {
			(void) snprintf(name, MAXPATHLEN,
			    MSG_ORIG(MSG_FMT_ARNAME), file, arhdr->ar_name);
			dbg_print(0, MSG_ORIG(MSG_FMT_NLSTR), name);

			switch (elf_kind(_elf)) {
			case ELF_K_AR:
				if (archive(name, fd, _elf, flags,
				    wname, wfd, osabi) == 1)
					return (1);
				break;
			case ELF_K_ELF:
				if (decide(name, fd, _elf, flags,
				    wname, wfd, osabi) == 1)
					return (1);
				break;
			default:
				(void) fprintf(stderr,
				    MSG_INTL(MSG_ERR_BADFILE), name);
				break;
			}
		}

		cmd = elf_next(_elf);
		(void) elf_end(_elf);
	}

	return (0);
}

int
main(int argc, char **argv, char **envp)
{
	Elf		*elf;
	int		var, fd, wfd = 0;
	char		*wname = NULL;
	uint_t		flags = 0;
	match_rec_t	match_data;
	int		ret;
	uchar_t		osabi = ELFOSABI_NONE;

	/*
	 * Establish locale.
	 */
	(void) setlocale(LC_MESSAGES, MSG_ORIG(MSG_STR_EMPTY));
	(void) textdomain(MSG_ORIG(MSG_SUNW_OST_SGS));

	(void) setvbuf(stdout, NULL, _IOLBF, 0);
	(void) setvbuf(stderr, NULL, _IOLBF, 0);

	opterr = 0;
	while ((var = getopt(argc, argv, MSG_ORIG(MSG_STR_OPTIONS))) != EOF) {
		switch (var) {
		case 'C':
			flags |= FLG_CTL_DEMANGLE;
			break;
		case 'c':
			flags |= FLG_SHOW_SHDR;
			break;
		case 'd':
			flags |= FLG_SHOW_DYNAMIC;
			break;
		case 'e':
			flags |= FLG_SHOW_EHDR;
			break;
		case 'G':
			flags |= FLG_SHOW_GOT;
			break;
		case 'g':
			flags |= FLG_SHOW_GROUP;
			break;
		case 'H':
			flags |= FLG_SHOW_CAP;
			break;
		case 'h':
			flags |= FLG_SHOW_HASH;
			break;
		case 'I':
			if (!process_index_opt(optarg, &match_data))
				goto usage_brief;
			if (!add_match_record(argv[0], &match_data))
				return (1);
			flags |= FLG_CTL_MATCH;
			break;
		case 'i':
			flags |= FLG_SHOW_INTERP;
			break;
		case 'k':
			flags |= FLG_CALC_CHECKSUM;
			break;
		case 'l':
			flags |= FLG_CTL_LONGNAME;
			break;
		case 'm':
			flags |= FLG_SHOW_MOVE;
			break;
		case 'N':
			match_data.opt_type = MATCH_OPT_NAME;
			match_data.value.name = optarg;
			if (!add_match_record(argv[0], &match_data))
				return (1);
			flags |= FLG_CTL_MATCH;
			break;
		case 'n':
			flags |= FLG_SHOW_NOTE;
			break;
		case 'O':
			{
				uint32_t val;

				/*
				 * osabi is a uchar_t in the ELF header.
				 * Don't accept any value that exceeds
				 * that range.
				 */
				if ((atoui(optarg, ATOUI_OSABI, &val) == 0) ||
				    (val > 255)) {
					(void) fprintf(stderr,
					    MSG_INTL(MSG_ERR_BAD_T_OSABI),
					    basename(argv[0]), optarg);
					return (1);
				}
				osabi = val;
			}
			flags |= FLG_CTL_OSABI;
			break;
		case 'P':
			flags |= FLG_CTL_FAKESHDR;
			break;
		case 'p':
			flags |= FLG_SHOW_PHDR;
			break;
		case 'r':
			flags |= FLG_SHOW_RELOC;
			break;
		case 'S':
			flags |= FLG_SHOW_SORT;
			break;
		case 's':
			flags |= FLG_SHOW_SYMBOLS;
			break;
		case 'T':
			/*
			 * We can't evaluate the value yet, because
			 * we need to know if -p is used or not in
			 * order to tell if we're seeing section header
			 * or program header types. So, we save the
			 * string in the name field, and then convert
			 * it to a type integer in a following pass.
			 */
			match_data.opt_type = MATCH_OPT_TYPE;
			match_data.value.name = optarg;
			if (!add_match_record(argv[0], &match_data))
				return (1);
			flags |= FLG_CTL_MATCH;
			break;
		case 'u':
			flags |= FLG_SHOW_UNWIND;
			break;
		case 'v':
			flags |= FLG_SHOW_VERSIONS;
			break;
		case 'w':
			wname = optarg;
			break;
		case 'y':
			flags |= FLG_SHOW_SYMINFO;
			break;
		case '?':
			(void) fprintf(stderr, MSG_INTL(MSG_USAGE_BRIEF),
			    basename(argv[0]));
			detail_usage();
			return (1);
		default:
			break;
		}
	}

	/* -p and -w are mutually exclusive. -w only works with sections */
	if (((flags & FLG_SHOW_PHDR) != 0) && (wname != NULL))
		goto usage_brief;

	/* If a match argument is present, prepare the match state */
	if ((match_state.list != NULL) && (match_prepare(argv[0], flags) == 0))
		return (1);

	/*
	 * Decide what to do if no options specifying something to
	 * show or do are present.
	 *
	 * If there is no -w and no match options, then we will set all
	 * the show flags, causing a full display of everything in the
	 * file that we know how to handle.
	 *
	 * Otherwise, if there is no match list, we generate a usage
	 * error and quit.
	 *
	 * In the case where there is a match list, we go ahead and call
	 * regular() anyway, leaving it to decide what to do. If -w is
	 * present, regular() will use the match list to handle it.
	 * In addition, in the absence of explicit show/calc flags, regular()
	 * will compare the section headers to the match list and use
	 * that to generate the FLG_ bits that will display the information
	 * specified by the match list.
	 */
	if ((flags & ~FLG_MASK_CTL) == 0) {
		if (!wname && (match_state.list == NULL))
			flags |= FLG_MASK_SHOW;
		else if (match_state.list == NULL)
			goto usage_brief;
	}

	/* There needs to be at least 1 filename left following the options */
	if ((var = argc - optind) == 0)
		goto usage_brief;

	/*
	 * If the -l/-C option is specified, set up the liblddbg.so.
	 */
	if (flags & FLG_CTL_LONGNAME)
		dbg_desc->d_extra |= DBG_E_LONG;
	if (flags & FLG_CTL_DEMANGLE)
		dbg_desc->d_extra |= DBG_E_DEMANGLE;

	/*
	 * If the -w option has indicated an output file open it.  It's
	 * arguable whether this option has much use when multiple files are
	 * being processed.
	 *
	 * If wname is non-NULL, we know that -p was not specified, due
	 * to the test above.
	 */
	if (wname) {
		if ((wfd = open(wname, (O_RDWR | O_CREAT | O_TRUNC),
		    0666)) < 0) {
			int err = errno;
			(void) fprintf(stderr, MSG_INTL(MSG_ERR_OPEN),
			    wname, strerror(err));
			return (1);
		}
	}

	/*
	 * Open the input file, initialize the elf interface, and
	 * process it.
	 */
	ret = 0;
	for (; (optind < argc) && (ret == 0); optind++) {
		const char	*file = argv[optind];

		if ((fd = open(argv[optind], O_RDONLY)) == -1) {
			int err = errno;
			(void) fprintf(stderr, MSG_INTL(MSG_ERR_OPEN),
			    file, strerror(err));
			continue;
		}
		(void) elf_version(EV_CURRENT);
		if ((elf = elf_begin(fd, ELF_C_READ, NULL)) == NULL) {
			failure(file, MSG_ORIG(MSG_ELF_BEGIN));
			(void) close(fd);
			continue;
		}

		if (var > 1)
			dbg_print(0, MSG_ORIG(MSG_FMT_NLSTRNL), file);

		switch (elf_kind(elf)) {
		case ELF_K_AR:
			ret = archive(file, fd, elf, flags, wname, wfd, osabi);
			break;
		case ELF_K_ELF:
			ret = decide(file, fd, elf, flags, wname, wfd, osabi);
			break;
		default:
			(void) fprintf(stderr, MSG_INTL(MSG_ERR_BADFILE), file);
			break;
		}

		(void) close(fd);
		(void) elf_end(elf);
	}

	if (wfd)
		(void) close(wfd);
	return (ret);

usage_brief:
	/* Control comes here for a simple usage message and exit */
	(void) fprintf(stderr, MSG_INTL(MSG_USAGE_BRIEF),
	    basename(argv[0]));
	return (1);

}



/* ============================================================================
 * SOURCE 73/98: minix4\exokernel\kernel_legacy\cmd\sgs\demo_rdb\common\main.c
 * Size: 6,890 bytes, Lines: 314
 * Hash: f7a50651f057...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (c) 1995, 2010, Oracle and/or its affiliates. All rights reserved.
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/uio.h>
#include <fcntl.h>
#include <string.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/signal.h>
#include <sys/fault.h>
#include <sys/syscall.h>
#include <procfs.h>
#include <sys/auxv.h>
#include <libelf.h>
#include <sys/param.h>
#include <sys/machelf.h>
#include <stdarg.h>

#include <proc_service.h>

#include "rdb.h"
#include "disasm.h"
#include "gram.h"

#define	PROCSIZE	20

static void
init_proc()
{
	int		pfd;
	char		procname[PROCSIZE];
	sigset_t	sigset;
	fltset_t	fltset;
	sysset_t	sysset;
	long		oper, pflags;
	struct iovec	piov[2];

	/*
	 * open our own /proc file and set tracing flags
	 */
	(void) snprintf(procname, PROCSIZE, "/proc/%d/ctl", EC_SWORD(getpid()));
	if ((pfd = open(procname, O_WRONLY)) < 0) {
		(void) fprintf(stderr, "can't open %s\n", procname);
		exit(1);
	}

	/*
	 * inherit on fork, and kill-on-last-close
	 */
	oper = PCSET;
	piov[0].iov_base = (caddr_t)(&oper);
	piov[0].iov_len = sizeof (oper);
	pflags = PR_FORK;
	piov[1].iov_base = (caddr_t)&pflags;
	piov[1].iov_len = sizeof (pflags);

	if (writev(pfd, piov, 2) == -1)
		perr("init_proc: PCSET");

	/*
	 * no signal tracing
	 */
	oper = PCSTRACE;
	premptyset(&sigset);
	piov[1].iov_base = (caddr_t)&sigset;
	piov[1].iov_len = sizeof (sigset);
	if (writev(pfd, piov, 2) == -1)
		perr("PCSTRACE");

	/*
	 * no fault tracing
	 */
	oper = PCSFAULT;
	premptyset(&fltset);
	piov[1].iov_base = (caddr_t)&fltset;
	piov[1].iov_len = sizeof (fltset);
	if (writev(pfd, piov, 2) == -1)
		perr("PCSFAULT");

	/*
	 * no syscall tracing
	 */
	oper = PCSENTRY;
	premptyset(&sysset);
	piov[1].iov_base = (caddr_t)&sysset;
	piov[1].iov_len = sizeof (sysset);
	if (writev(pfd, piov, 2) == -1)
		perr("PSENTRY");

	/*
	 * except exit from exec() or execve()
	 */
	oper = PCSEXIT;
	premptyset(&sysset);
	praddset(&sysset, SYS_execve);
	if (writev(pfd, piov, 2) == -1)
		perr("PCSEXIT");

	(void) close(pfd);
}

int
main(int argc, char *argv[])
{
	int			pctlfd;
	int			pstatusfd;
	char			procname[PROCSIZE];
	char			*command;
	char			*rdb_commands = NULL;
	pid_t			cpid;
	pstatus_t		pstatus;
	sysset_t		sysset;
	int			c;
	int			error = 0;
	long			oper;
	struct iovec		piov[2];
	extern FILE		*yyin;

	command = argv[0];

	while ((c = getopt(argc, argv, "f:")) != EOF)
		switch (c) {
		case 'f':
			rdb_commands = optarg;
			break;
		case '?':
			break;
		}

	if (error || (optind == argc)) {
		(void) printf("usage: %s [-f file] executable "
		    "[executable arguments ...]\n", command);
		(void) printf("\t-f	command file\n");
		exit(1);
	}

	/*
	 * set up for tracing the child.
	 */
	init_proc();

	/*
	 * create a child to fork and exec from.
	 */
	if ((cpid = fork()) == 0) {
		(void) execv(argv[optind], &argv[optind]);
		perr(argv[optind]);
	}

	if (cpid == -1)	/* fork() failure */
		perr(command);

	/*
	 * initialize libelf
	 */
	if (elf_version(EV_CURRENT) == EV_NONE) {
		(void) fprintf(stderr, "elf_version() failed: %s\n",
		    elf_errmsg(0));
		exit(1);
	}

	/*
	 * initialize librtld_db
	 */
	if (rd_init(RD_VERSION) != RD_OK) {
		(void) fprintf(stderr, "librtld_db::rd_init() failed: version "
		    "submitted: %d\n", RD_VERSION);
		exit(1);
	}

	/* rd_log(1); */

	/*
	 * Child should now be waiting after the successful
	 * exec.
	 */
	(void) snprintf(procname, PROCSIZE, "/proc/%d/ctl", EC_SWORD(cpid));
	(void) printf("parent: %d child: %d child procname: %s\n",
	    EC_SWORD(getpid()), EC_SWORD(cpid), procname);
	if ((pctlfd = open(procname, O_WRONLY)) < 0) {
		perror(procname);
		(void) fprintf(stderr, "%s: can't open child %s\n",
		    command, procname);
		exit(1);
	}

	/*
	 * wait for child process.
	 */
	oper = PCWSTOP;
	piov[0].iov_base = (caddr_t)&oper;
	piov[0].iov_len = sizeof (oper);
	if (writev(pctlfd, piov, 1) == -1)
		perr("PCWSTOP");

	/*
	 * open /proc/<cpid>/status
	 */
	(void) snprintf(procname, PROCSIZE, "/proc/%d/status", EC_SWORD(cpid));
	if ((pstatusfd = open(procname, O_RDONLY)) == -1)
		perr(procname);

	if (read(pstatusfd, &pstatus, sizeof (pstatus)) == -1)
		perr("status read failed");

	/*
	 * Make sure that it stopped where we expected.
	 */
	while ((pstatus.pr_lwp.pr_why == PR_SYSEXIT) &&
	    (pstatus.pr_lwp.pr_what == SYS_execve)) {
		long	pflags = 0;
		if (!(pstatus.pr_lwp.pr_reg[R_PS] & ERRBIT)) {
			/* successfull exec(2) */
			break;
		}

		oper = PCRUN;
		piov[1].iov_base = (caddr_t)&pflags;
		piov[1].iov_len = sizeof (pflags);
		if (writev(pctlfd, piov, 2) == -1)
			perr("PCRUN1");

		oper = PCWSTOP;
		if (writev(pctlfd, piov, 1) == -1)
			perr("PCWSTOP");

		if (read(pstatusfd, &pstatus, sizeof (pstatus)) == -1)
			perr("status read failed");
	}

	premptyset(&sysset);
	oper = PCSEXIT;
	piov[1].iov_base = (caddr_t)&sysset;
	piov[1].iov_len = sizeof (sysset);
	if (writev(pctlfd, piov, 2) == -1)
		perr("PIOCSEXIT");

	/*
	 * Did we stop where we expected ?
	 */
	if ((pstatus.pr_lwp.pr_why != PR_SYSEXIT) ||
	    (pstatus.pr_lwp.pr_what != SYS_execve)) {
		long	pflags = 0;

		(void) fprintf(stderr, "Didn't catch the exec, why: %d "
		    "what: %d\n", pstatus.pr_lwp.pr_why,
		    pstatus.pr_lwp.pr_what);

		oper = PCRUN;
		piov[1].iov_base = (caddr_t)&pflags;
		piov[1].iov_len = sizeof (pflags);
		if (writev(pctlfd, piov, 2) == -1)
			perr("PCRUN2");
		exit(1);
	}

	(void) ps_init(pctlfd, pstatusfd, cpid, &proch);

	if (rdb_commands) {
		if ((yyin = fopen(rdb_commands, "r")) == NULL) {
			(void) printf("unable to open %s for input\n",
			    rdb_commands);
			perr("fopen");
		}
	} else {
		proch.pp_flags |= FLG_PP_PROMPT;
		rdb_prompt();
	}
	(void) yyparse();

	if (proch.pp_flags & FLG_PP_PACT) {
		long	pflags = PRCFAULT;

		(void) printf("\ncontinuing the hung process...\n");

		pctlfd = proch.pp_ctlfd;
		(void) ps_close(&proch);

		oper = PCRUN;
		piov[1].iov_base = (caddr_t)&pflags;
		piov[1].iov_len = sizeof (pflags);
		if (writev(pctlfd, piov, 2) == -1)
			perr("PCRUN2");
		(void) close(pctlfd);
	}

	return (0);
}



/* ============================================================================
 * SOURCE 74/98: minix4\exokernel\kernel_legacy\cmd\sgs\ar\common\main.c
 * Size: 9,294 bytes, Lines: 412
 * Hash: e1d3987ae1fa...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*	Copyright (c) 1988 AT&T	*/
/*	  All Rights Reserved   */

/*
 * Copyright (c) 1995, 2010, Oracle and/or its affiliates. All rights reserved.
 */

/*
 * Copyright (c) 2018, Joyent, Inc.
 * Copyright 2022 Oxide Computer Company
 */

#include "inc.h"
#include "conv.h"

/*
 * Forward declarations
 */
static void setup(int, char **, Cmd_info *);
static void setcom(Cmd_info *, Cmd_func);
static void usage(void);
static void sigexit(int sig);
static int notfound(Cmd_info *);
static void check_swap();

const char *
_ar_msg(Msg mid)
{
	return (gettext(MSG_ORIG(mid)));
}


void
establish_sighandler(void (*handler)())
{
	static const int signum[] = {SIGHUP, SIGINT, SIGQUIT, 0};
	int i;

	if (handler == SIG_IGN) {
		/* Ignore all the specified signals */
		for (i = 0; signum[i]; i++)
			(void) signal(signum[i], SIG_IGN);

	} else {
		/*
		 * Set any signal that doesn't default to being ignored
		 * to our signal handler.
		 */
		for (i = 0; signum[i]; i++)
			if (signal(signum[i], SIG_IGN) != SIG_IGN)
				(void) signal(signum[i], handler);
	}
}

int
main(int argc, char **argv, char *envp[])
{
	int fd;
	Cmd_info *cmd_info;
	int ret;
	char *new = NULL;

#ifndef	XPG4
	/*
	 * Check for a binary that better fits this architecture.
	 */
	(void) conv_check_native(argv, envp);
#endif

	/*
	 * Establish locale.
	 */
	(void) setlocale(LC_ALL, MSG_ORIG(MSG_STR_EMPTY));
	(void) textdomain(MSG_ORIG(MSG_SUNW_OST_SGS));

	/* Allow a graceful exit up until we start to write an archive */
	establish_sighandler(sigexit);

	/*
	 * Initialize cmd_info
	 */
	cmd_info = (Cmd_info *)calloc(1, sizeof (Cmd_info));
	if (cmd_info == NULL) {
		int err = errno;
		(void) fprintf(stderr, MSG_INTL(MSG_MALLOC), strerror(err));
		exit(1);
	}

	if (argc < 2)
		usage();

	/*
	 * Option handling.
	 */
	if (argv[1][0] != '-') {
		new = (char *)malloc(strlen(argv[1]) + 2);
		if (new == NULL) {
			int err = errno;
			(void) fprintf(stderr, MSG_INTL(MSG_MALLOC),
			    strerror(err));
			exit(1);
		}
		(void) strcpy(new, MSG_ORIG(MSG_STR_HYPHEN));
		(void) strcat(new, argv[1]);
		argv[1] = new;
	}
	setup(argc, argv, cmd_info);

	/*
	 * Check SWAP
	 */
	if (cmd_info->opt_flgs & z_FLAG)
		check_swap();

	cmd_info->modified = (cmd_info->opt_flgs & s_FLAG);
	fd = getaf(cmd_info);

	if (fd == -1) {
		boolean_t req_arg = (cmd_info->opt_flgs & (d_FLAG | m_FLAG |
		    p_FLAG | t_FLAG | x_FLAG)) != 0;
		boolean_t req_r = (cmd_info->opt_flgs & r_FLAG) &&
		    (cmd_info->opt_flgs & (a_FLAG | b_FLAG));
		boolean_t req_s = (cmd_info->opt_flgs & s_FLAG) &&
		    (cmd_info->opt_flgs & (r_FLAG | q_FLAG)) == 0;

		if (req_arg || req_r || req_s) {
			(void) fprintf(stderr, MSG_INTL(MSG_NOT_FOUND_AR),
			    cmd_info->arnam);
			exit(1);
		}
	}

	(*cmd_info->comfun)(cmd_info);
	if (cmd_info->modified) {
		writefile(cmd_info);
	} else
		(void) close(fd);

	ret = notfound(cmd_info);

	/*
	 * Check SWAP
	 */
	if (cmd_info->opt_flgs & z_FLAG)
		check_swap();

	free(new);
	free(cmd_info);
	return (ret);

}

/*
 * Option handing function.
 *	Using getopt(), following xcu4 convention.
 */
static void
setup(int argc, char *argv[], Cmd_info *cmd_info)
{
	int Vflag = 0;
	int c;
	int usage_err = 0;

	while ((c = getopt(argc, argv, MSG_ORIG(MSG_STR_OPTIONS))) != -1) {
		switch (c) {
		case 'a': /* position after named archive member file */
			cmd_info->opt_flgs |= a_FLAG;
			cmd_info->ponam = trim(optarg);
			break;
		case 'b': /* position before named archive member file */
		case 'i': /* position before named archive member: same as b */
			cmd_info->opt_flgs |= b_FLAG;
			cmd_info->ponam = trim(optarg);
			break;
		case 'c': /* supress messages */
			cmd_info->opt_flgs |= c_FLAG;
			break;
		case 'd':
			/*
			 * key operation:
			 * delete files from the archive
			 */
			setcom(cmd_info, dcmd);
			cmd_info->opt_flgs |= d_FLAG;
			break;
		case 'l': /* ignored */
			break;
		case 'm':
			/*
			 * key operation:
			 * move files to end of the archive
			 * or as indicated by position flag
			 */
			setcom(cmd_info, mcmd);
			cmd_info->opt_flgs |= m_FLAG;
			break;
		case 'p':
			/*
			 * key operation:
			 * print files in the archive
			 */
			setcom(cmd_info, pcmd);
			cmd_info->opt_flgs |= p_FLAG;
			break;
		case 'q':
			/*
			 * key operation:
			 * quickly append files to end of the archive
			 */
			setcom(cmd_info, qcmd);
			cmd_info->opt_flgs |= q_FLAG;
			break;
		case 'r':
			/*
			 * key operation:
			 * replace or add files to the archive
			 */
			setcom(cmd_info, rcmd);
			cmd_info->opt_flgs |= r_FLAG;
			break;
		case 's': /* force symbol table regeneration */
			cmd_info->opt_flgs |= s_FLAG;
			break;
		case 'S': /* Build SYM64 symbol table */
			cmd_info->opt_flgs |= S_FLAG;
			break;
		case 't':
			/*
			 * key operation:
			 * print table of contents
			 */
			setcom(cmd_info, tcmd);
			cmd_info->opt_flgs |= t_FLAG;
			break;
		case 'u': /* update: change archive dependent on file dates */
			cmd_info->opt_flgs |= u_FLAG;
			break;
		case 'v': /* verbose */
			cmd_info->opt_flgs |= v_FLAG;
			break;
		case 'x':
			/*
			 * key operation:
			 * extract files from the archive
			 */
			setcom(cmd_info, xcmd);
			cmd_info->opt_flgs |= x_FLAG;
			break;
		case 'z':
			cmd_info->opt_flgs |= z_FLAG;
			break;
		case 'V':
			/*
			 * print version information.
			 * adjust command line access accounting
			 */
			if (Vflag == 0) {
				(void) fprintf(stderr,
				    MSG_ORIG(MSG_FMT_VERSION),
				    (const char *)SGU_PKG,
				    (const char *)SGU_REL);
				Vflag++;
			}
			break;
		case 'C':
			cmd_info->opt_flgs |= C_FLAG;
			break;
		case 'M':
			/*
			 * -M was an original undocumented AT&T feature that
			 * would force the use of mmap() instead of read()
			 * for pulling file data into the process before
			 * writing it to the archive. Ignored.
			 */
			break;
		case 'T':
			cmd_info->opt_flgs |= T_FLAG;
			break;
		case ':':
			(void) fprintf(stderr, MSG_INTL(MSG_USAGE_OPERAND),
			    optopt);
			usage_err++;
			break;
		case '?':
			(void) fprintf(stderr, MSG_INTL(MSG_USAGE_OPTION),
			    optopt);
			usage_err++;
			break;
		}
	}

	if (usage_err || argc - optind < 1)
		usage();

	cmd_info->arnam = argv[optind];
	cmd_info->namv = &argv[optind+1];
	cmd_info->namc = argc - optind - 1;

	/*
	 * GNU ar popularized the use of -s on its own which previously used to
	 * require another command function. As such, we don't set a command
	 * function when we encounter the -s flag because that might otherwise
	 * clobber an existing one being set and would interrupt the detection
	 * of multiple flags being used that way.
	 *
	 * If after processing everything, we find there's no command function
	 * set and the -s flag has been set, then we can finally set a command
	 * function. The command function for -t 'tcmd' is used in this case. It
	 * knows to only print out data if -t has been specified.
	 *
	 * While ar has not traditionally been very stringent about using flags
	 * in circumstances they aren't called for, we go ahead and check for
	 * that now for this newer option.
	 */
	if (cmd_info->comfun == NULL) {
		if ((cmd_info->opt_flgs & s_FLAG) != 0) {
			if ((cmd_info->opt_flgs & ~(s_FLAG | v_FLAG)) != 0) {
				(void) fprintf(stderr,
				    MSG_INTL(MSG_USAGE_S_BAD_ARG));
				exit(1);
			}

			if (cmd_info->namc > 0) {
				(void) fprintf(stderr,
				    MSG_INTL(MSG_USAGE_S_EXTRA_AR));
				exit(1);
			}

			setcom(cmd_info, tcmd);
		} else if ((cmd_info->opt_flgs & (d_FLAG | r_FLAG | q_FLAG |
		    s_FLAG | t_FLAG | p_FLAG | m_FLAG | x_FLAG)) == 0) {
			(void) fprintf(stderr, MSG_INTL(MSG_USAGE_REQ_FLAG));
			exit(1);
		}
	}
}


/*
 * Set the function to be called to do the key operation.
 * Check that only one key is indicated.
 */
static void
setcom(Cmd_info *cmd_info, Cmd_func *fun)
{
	if (cmd_info->comfun != NULL) {
		(void) fprintf(stderr, MSG_INTL(MSG_USAGE_TOO_MANY));
		exit(1);
	}
	cmd_info->comfun = fun;
}

static void
usage(void)
{
	(void) fprintf(stderr, MSG_INTL(MSG_USAGE));
	exit(1);
}

/*ARGSUSED0*/
static void
sigexit(int sig)
{
	exit(100);
}

/* tells the user which of the listed files were not found in the archive */

static int
notfound(Cmd_info *cmd_info)
{
	int i, n;

	n = 0;
	for (i = 0; i < cmd_info->namc; i++)
		if (cmd_info->namv[i]) {
			(void) fprintf(stderr, MSG_INTL(MSG_NOT_FOUND_FILE),
			    cmd_info->namv[i]);
			n++;
		}
	return (n);
}

/*
 * Debugging info
 */
static void
check_swap(void)
{
	(void) system(MSG_ORIG(MSG_CMD_SWAP));
}



/* ============================================================================
 * SOURCE 75/98: minix4\exokernel\kernel_legacy\cmd\sendmail\libmilter\main.c
 * Size: 4,417 bytes, Lines: 248
 * Hash: 5060ca0e9179...
 * ============================================================================ */

/*
 *  Copyright (c) 1999-2003, 2006, 2007 Sendmail, Inc. and its suppliers.
 *	All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sm/gen.h>
SM_RCSID("@(#)$Id: main.c,v 8.84 2008/09/02 05:37:06 ca Exp $")

#define _DEFINE	1
#include "libmilter.h"
#include <fcntl.h>
#include <sys/stat.h>


static smfiDesc_ptr smfi = NULL;

/*
**  SMFI_REGISTER -- register a filter description
**
**	Parameters:
**		smfilter -- description of filter to register
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

int
smfi_register(smfilter)
	smfiDesc_str smfilter;
{
	size_t len;

	if (smfi == NULL)
	{
		smfi = (smfiDesc_ptr) malloc(sizeof *smfi);
		if (smfi == NULL)
			return MI_FAILURE;
	}
	(void) memcpy(smfi, &smfilter, sizeof *smfi);
	if (smfilter.xxfi_name == NULL)
		smfilter.xxfi_name = "Unknown";

	len = strlen(smfilter.xxfi_name) + 1;
	smfi->xxfi_name = (char *) malloc(len);
	if (smfi->xxfi_name == NULL)
		return MI_FAILURE;
	(void) sm_strlcpy(smfi->xxfi_name, smfilter.xxfi_name, len);

	/* compare milter version with hard coded version */
	if ((SM_LM_VRS_MAJOR(smfi->xxfi_version) != SM_LM_VRS_MAJOR(SMFI_VERSION) ||
	     SM_LM_VRS_MINOR(smfi->xxfi_version) != SM_LM_VRS_MINOR(SMFI_VERSION)) &&
	    smfi->xxfi_version != 2 &&
	    smfi->xxfi_version != 3 &&
	    smfi->xxfi_version != 4)
	{
		/* hard failure for now! */
		smi_log(SMI_LOG_ERR,
			"%s: smfi_register: version mismatch application: %d != milter: %d",
			smfi->xxfi_name, smfi->xxfi_version,
			(int) SMFI_VERSION);

		/* XXX how about smfi? */
		free(smfi->xxfi_name);
		return MI_FAILURE;
	}

	return MI_SUCCESS;
}

/*
**  SMFI_STOP -- stop milter
**
**	Parameters:
**		none.
**
**	Returns:
**		success.
*/

int
smfi_stop()
{
	mi_stop_milters(MILTER_STOP);
	return MI_SUCCESS;
}

/*
**  Default values for some variables.
**	Most of these can be changed with the functions below.
*/

static int dbg = 0;
static char *conn = NULL;
static int timeout = MI_TIMEOUT;
static int backlog = MI_SOMAXCONN;

/*
**  SMFI_OPENSOCKET -- try the socket setup to make sure we'll be
**		       able to start up
**
**	Parameters:
**		rmsocket -- if true, instructs libmilter to attempt
**			to remove the socket before creating it;
**			only applies for "local:" or "unix:" sockets
**
**	Return:
**		MI_SUCCESS/MI_FAILURE
*/

int
smfi_opensocket(rmsocket)
	bool rmsocket;
{
	if (smfi == NULL || conn == NULL)
		return MI_FAILURE;

	return mi_opensocket(conn, backlog, dbg, rmsocket, smfi);
}

/*
**  SMFI_SETDBG -- set debug level.
**
**	Parameters:
**		odbg -- new debug level.
**
**	Returns:
**		MI_SUCCESS
*/

int
smfi_setdbg(odbg)
	int odbg;
{
	dbg = odbg;
	return MI_SUCCESS;
}

/*
**  SMFI_SETTIMEOUT -- set timeout (for read/write).
**
**	Parameters:
**		otimeout -- new timeout.
**
**	Returns:
**		MI_SUCCESS
*/

int
smfi_settimeout(otimeout)
	int otimeout;
{
	timeout = otimeout;
	return MI_SUCCESS;
}

/*
**  SMFI_SETCONN -- set connection information (socket description)
**
**	Parameters:
**		oconn -- new connection information.
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

int
smfi_setconn(oconn)
	char *oconn;
{
	size_t l;

	if (oconn == NULL || *oconn == '\0')
		return MI_FAILURE;
	l = strlen(oconn) + 1;
	if ((conn = (char *) malloc(l)) == NULL)
		return MI_FAILURE;
	if (sm_strlcpy(conn, oconn, l) >= l)
		return MI_FAILURE;
	return MI_SUCCESS;
}

/*
**  SMFI_SETBACKLOG -- set backlog
**
**	Parameters:
**		obacklog -- new backlog.
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

int
smfi_setbacklog(obacklog)
	int obacklog;
{
	if (obacklog <= 0)
		return MI_FAILURE;
	backlog = obacklog;
	return MI_SUCCESS;
}


/*
**  SMFI_MAIN -- setup milter connnection and start listener.
**
**	Parameters:
**		none.
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

int
smfi_main()
{
	int r;

	(void) signal(SIGPIPE, SIG_IGN);
	if (conn == NULL)
	{
		smi_log(SMI_LOG_FATAL, "%s: missing connection information",
			smfi->xxfi_name);
		return MI_FAILURE;
	}

	(void) atexit(mi_clean_signals);
	if (mi_control_startup(smfi->xxfi_name) != MI_SUCCESS)
	{
		smi_log(SMI_LOG_FATAL,
			"%s: Couldn't start signal thread",
			smfi->xxfi_name);
		return MI_FAILURE;
	}
	r = MI_MONITOR_INIT();

	/* Startup the listener */
	if (mi_listener(conn, dbg, smfi, timeout, backlog) != MI_SUCCESS)
		r = MI_FAILURE;

	return r;
}




/* ============================================================================
 * SOURCE 76/98: minix4\exokernel\kernel_legacy\cmd\sendmail\src\main.c
 * Size: 108,073 bytes, Lines: 4,582
 * Hash: c9ca79f1ea7e...
 * ============================================================================ */

/*
 * Copyright (c) 1998-2006, 2008, 2009 Sendmail, Inc. and its suppliers.
 *	All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

/*
 * Copyright 1996-2006 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

#define _DEFINE
#include <sendmail.h>
#include <sm/sendmail.h>
#include <sm/xtrap.h>
#include <sm/signal.h>

#ifndef lint
SM_UNUSED(static char copyright[]) =
"@(#) Copyright (c) 1998-2003 Sendmail, Inc. and its suppliers.\n\
@(#)	All rights reserved.\n\
@(#) Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.\n\
@(#) Copyright (c) 1988, 1993\n\
@(#)	The Regents of the University of California.  All rights reserved.\n\
@(#) Copyright 1996-2006 Sun Microsystems, Inc.  All rights reserved.\n\
@(#) Use is subject to license terms.\n";
#endif /* ! lint */

SM_RCSID("@(#)$Id: main.c,v 8.971 2009/12/18 17:08:01 ca Exp $")

#if NETINET || NETINET6
# include <arpa/inet.h>
#endif /* NETINET || NETINET6 */

/* for getcfname() */
#include <sendmail/pathnames.h>

static SM_DEBUG_T
DebugNoPRestart = SM_DEBUG_INITIALIZER("no_persistent_restart",
	"@(#)$Debug: no_persistent_restart - don't restart, log only $");

static void	dump_class __P((STAB *, int));
static void	obsolete __P((char **));
static void	testmodeline __P((char *, ENVELOPE *));
static char	*getextenv __P((const char *));
static void	sm_printoptions __P((char **));
static SIGFUNC_DECL	intindebug __P((int));
static SIGFUNC_DECL	sighup __P((int));
static SIGFUNC_DECL	sigpipe __P((int));
static SIGFUNC_DECL	sigterm __P((int));
#ifdef SIGUSR1
static SIGFUNC_DECL	sigusr1 __P((int));
#endif /* SIGUSR1 */

/*
**  SENDMAIL -- Post mail to a set of destinations.
**
**	This is the basic mail router.  All user mail programs should
**	call this routine to actually deliver mail.  Sendmail in
**	turn calls a bunch of mail servers that do the real work of
**	delivering the mail.
**
**	Sendmail is driven by settings read in from /etc/mail/sendmail.cf
**	(read by readcf.c).
**
**	Usage:
**		/usr/lib/sendmail [flags] addr ...
**
**		See the associated documentation for details.
**
**	Authors:
**		Eric Allman, UCB/INGRES (until 10/81).
**			     Britton-Lee, Inc., purveyors of fine
**				database computers (11/81 - 10/88).
**			     International Computer Science Institute
**				(11/88 - 9/89).
**			     UCB/Mammoth Project (10/89 - 7/95).
**			     InReference, Inc. (8/95 - 1/97).
**			     Sendmail, Inc. (1/98 - present).
**		The support of my employers is gratefully acknowledged.
**			Few of them (Britton-Lee in particular) have had
**			anything to gain from my involvement in this project.
**
**		Gregory Neil Shapiro,
**			Worcester Polytechnic Institute	(until 3/98).
**			Sendmail, Inc. (3/98 - present).
**
**		Claus Assmann,
**			Sendmail, Inc. (12/98 - present).
*/

char		*FullName;	/* sender's full name */
ENVELOPE	BlankEnvelope;	/* a "blank" envelope */
static ENVELOPE	MainEnvelope;	/* the envelope around the basic letter */
ADDRESS		NullAddress =	/* a null address */
		{ "", "", NULL, "" };
char		*CommandLineArgs;	/* command line args for pid file */
bool		Warn_Q_option = false;	/* warn about Q option use */
static int	MissingFds = 0;	/* bit map of fds missing on startup */
char		*Mbdb = "pw";	/* mailbox database defaults to /etc/passwd */

#ifdef NGROUPS_MAX
GIDSET_T	InitialGidSet[NGROUPS_MAX];
#endif /* NGROUPS_MAX */

#define MAXCONFIGLEVEL	10	/* highest config version level known */

#if SASL
static sasl_callback_t srvcallbacks[] =
{
	{	SASL_CB_VERIFYFILE,	&safesaslfile,	NULL	},
	{	SASL_CB_PROXY_POLICY,	&proxy_policy,	NULL	},
	{	SASL_CB_LIST_END,	NULL,		NULL	}
};
#endif /* SASL */

unsigned int	SubmitMode;
int		SyslogPrefixLen; /* estimated length of syslog prefix */
#define PIDLEN		6	/* pid length for computing SyslogPrefixLen */
#ifndef SL_FUDGE
# define SL_FUDGE	10	/* fudge offset for SyslogPrefixLen */
#endif /* ! SL_FUDGE */
#define SLDLL		8	/* est. length of default syslog label */


/* Some options are dangerous to allow users to use in non-submit mode */
#define CHECK_AGAINST_OPMODE(cmd)					\
{									\
	if (extraprivs &&						\
	    OpMode != MD_DELIVER && OpMode != MD_SMTP &&		\
	    OpMode != MD_ARPAFTP && OpMode != MD_CHECKCONFIG &&		\
	    OpMode != MD_VERIFY && OpMode != MD_TEST)			\
	{								\
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,		\
				     "WARNING: Ignoring submission mode -%c option (not in submission mode)\n", \
		       (cmd));						\
		break;							\
	}								\
	if (extraprivs && queuerun)					\
	{								\
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,		\
				     "WARNING: Ignoring submission mode -%c option with -q\n", \
		       (cmd));						\
		break;							\
	}								\
}

int
main(argc, argv, envp)
	int argc;
	char **argv;
	char **envp;
{
	register char *p;
	char **av;
	extern char Version[];
	char *ep, *from;
	STAB *st;
	register int i;
	int j;
	int dp;
	int fill_errno;
	int qgrp = NOQGRP;		/* queue group to process */
	bool safecf = true;
	BITMAP256 *p_flags = NULL;	/* daemon flags */
	bool warn_C_flag = false;
	bool auth = true;		/* whether to set e_auth_param */
	char warn_f_flag = '\0';
	bool run_in_foreground = false;	/* -bD mode */
	bool queuerun = false, debug = false;
	struct passwd *pw;
	struct hostent *hp;
	char *nullserver = NULL;
	char *authinfo = NULL;
	char *sysloglabel = NULL;	/* label for syslog */
	char *conffile = NULL;		/* name of .cf file */
	char *queuegroup = NULL;	/* queue group to process */
	char *quarantining = NULL;	/* quarantine queue items? */
	bool extraprivs;
	bool forged, negate;
	bool queuepersistent = false;	/* queue runner process runs forever */
	bool foregroundqueue = false;	/* queue run in foreground */
	bool save_val;			/* to save some bool var. */
	int cftype;			/* which cf file to use? */
	SM_FILE_T *smdebug;
	static time_t starttime = 0;	/* when was process started */
	struct stat traf_st;		/* for TrafficLog FIFO check */
	char buf[MAXLINE];
	char jbuf[MAXHOSTNAMELEN];	/* holds MyHostName */
	static char rnamebuf[MAXNAME];	/* holds RealUserName */
	char *emptyenviron[1];
#if STARTTLS
	bool tls_ok;
#endif /* STARTTLS */
	QUEUE_CHAR *new;
	ENVELOPE *e;
	extern int DtableSize;
	extern int optind;
	extern int opterr;
	extern char *optarg;
	extern char **environ;
#if SASL
	extern void sm_sasl_init __P((void));
#endif /* SASL */

#if USE_ENVIRON
	envp = environ;
#endif /* USE_ENVIRON */

	/* turn off profiling */
	SM_PROF(0);

	/* install default exception handler */
	sm_exc_newthread(fatal_error);

	/* set the default in/out channel so errors reported to screen */
	InChannel = smioin;
	OutChannel = smioout;

	/*
	**  Check to see if we reentered.
	**	This would normally happen if e_putheader or e_putbody
	**	were NULL when invoked.
	*/

	if (starttime != 0)
	{
		syserr("main: reentered!");
		abort();
	}
	starttime = curtime();

	/* avoid null pointer dereferences */
	TermEscape.te_rv_on = TermEscape.te_under_on = TermEscape.te_normal = "";

	RealUid = getuid();
	RealGid = getgid();

	/* Check if sendmail is running with extra privs */
	extraprivs = (RealUid != 0 &&
		      (geteuid() != getuid() || getegid() != getgid()));

	CurrentPid = getpid();

	/* get whatever .cf file is right for the opmode */
	cftype = SM_GET_RIGHT_CF;

	/* in 4.4BSD, the table can be huge; impose a reasonable limit */
	DtableSize = getdtsize();
	if (DtableSize > 256)
		DtableSize = 256;

	/*
	**  Be sure we have enough file descriptors.
	**	But also be sure that 0, 1, & 2 are open.
	*/

	/* reset errno and fill_errno; the latter is used way down below */
	errno = fill_errno = 0;
	fill_fd(STDIN_FILENO, NULL);
	if (errno != 0)
		fill_errno = errno;
	fill_fd(STDOUT_FILENO, NULL);
	if (errno != 0)
		fill_errno = errno;
	fill_fd(STDERR_FILENO, NULL);
	if (errno != 0)
		fill_errno = errno;

	sm_closefrom(STDERR_FILENO + 1, DtableSize);
	errno = 0;
	smdebug = NULL;

#if LOG
# ifndef SM_LOG_STR
#  define SM_LOG_STR	"sendmail"
# endif /* ! SM_LOG_STR */
#  ifdef LOG_MAIL
	openlog(SM_LOG_STR, LOG_PID, LOG_MAIL);
#  else /* LOG_MAIL */
	openlog(SM_LOG_STR, LOG_PID);
#  endif /* LOG_MAIL */
#endif /* LOG */

	/*
	**  Seed the random number generator.
	**  Used for queue file names, picking a queue directory, and
	**  MX randomization.
	*/

	seed_random();

	/* do machine-dependent initializations */
	init_md(argc, argv);


	SyslogPrefixLen = PIDLEN + (MAXQFNAME - 3) + SL_FUDGE + SLDLL;

	/* reset status from syserr() calls for missing file descriptors */
	Errors = 0;
	ExitStat = EX_OK;

	SubmitMode = SUBMIT_UNKNOWN;
#if _FFR_LOCAL_DAEMON
	LocalDaemon = false;
#endif /* _FFR_LOCAL_DAEMON */
#if XDEBUG
	checkfd012("after openlog");
#endif /* XDEBUG */

	tTsetup(tTdvect, sizeof(tTdvect), "0-99.1,*_trace_*.1");

#ifdef NGROUPS_MAX
	/* save initial group set for future checks */
	i = getgroups(NGROUPS_MAX, InitialGidSet);
	if (i <= 0)
	{
		InitialGidSet[0] = (GID_T) -1;
		i = 0;
	}
	while (i < NGROUPS_MAX)
		InitialGidSet[i++] = InitialGidSet[0];
#endif /* NGROUPS_MAX */

	/* drop group id privileges (RunAsUser not yet set) */
	dp = drop_privileges(false);
	setstat(dp);

#ifdef SIGUSR1
	/* Only allow root (or non-set-*-ID binaries) to use SIGUSR1 */
	if (!extraprivs)
	{
		/* arrange to dump state on user-1 signal */
		(void) sm_signal(SIGUSR1, sigusr1);
	}
	else
	{
		/* ignore user-1 signal */
		(void) sm_signal(SIGUSR1, SIG_IGN);
	}
#endif /* SIGUSR1 */

	/* initialize for setproctitle */
	initsetproctitle(argc, argv, envp);

	/* Handle any non-getoptable constructions. */
	obsolete(argv);

	/*
	**  Do a quick prescan of the argument list.
	*/


	/* find initial opMode */
	OpMode = MD_DELIVER;
	av = argv;
	p = strrchr(*av, '/');
	if (p++ == NULL)
		p = *av;
	if (strcmp(p, "newaliases") == 0)
		OpMode = MD_INITALIAS;
	else if (strcmp(p, "mailq") == 0)
		OpMode = MD_PRINT;
	else if (strcmp(p, "smtpd") == 0)
		OpMode = MD_DAEMON;
	else if (strcmp(p, "hoststat") == 0)
		OpMode = MD_HOSTSTAT;
	else if (strcmp(p, "purgestat") == 0)
		OpMode = MD_PURGESTAT;

#if defined(__osf__) || defined(_AIX3)
# define OPTIONS	"A:B:b:C:cD:d:e:F:f:Gh:IiL:M:mN:nO:o:p:Q:q:R:r:sTtV:vX:x"
#endif /* defined(__osf__) || defined(_AIX3) */
#if defined(sony_news)
# define OPTIONS	"A:B:b:C:cD:d:E:e:F:f:Gh:IiJ:L:M:mN:nO:o:p:Q:q:R:r:sTtV:vX:"
#endif /* defined(sony_news) */
#ifndef OPTIONS
# define OPTIONS	"A:B:b:C:cD:d:e:F:f:Gh:IiL:M:mN:nO:o:p:Q:q:R:r:sTtV:vX:"
#endif /* ! OPTIONS */

	/* Set to 0 to allow -b; need to check optarg before using it! */
	opterr = 0;
	while ((j = getopt(argc, argv, OPTIONS)) != -1)
	{
		switch (j)
		{
		  case 'b':	/* operations mode */
			j = (optarg == NULL) ? ' ' : *optarg;
			switch (j)
			{
			  case MD_DAEMON:
			  case MD_FGDAEMON:
			  case MD_SMTP:
			  case MD_INITALIAS:
			  case MD_DELIVER:
			  case MD_VERIFY:
			  case MD_TEST:
			  case MD_PRINT:
			  case MD_PRINTNQE:
			  case MD_HOSTSTAT:
			  case MD_PURGESTAT:
			  case MD_ARPAFTP:
#if _FFR_CHECKCONFIG
			  case MD_CHECKCONFIG:
#endif /* _FFR_CHECKCONFIG */
				OpMode = j;
				break;

#if _FFR_LOCAL_DAEMON
			  case MD_LOCAL:
				OpMode = MD_DAEMON;
				LocalDaemon = true;
				break;
#endif /* _FFR_LOCAL_DAEMON */

			  case MD_FREEZE:
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Frozen configurations unsupported\n");
				return EX_USAGE;

			  default:
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Invalid operation mode %c\n",
						     j);
				return EX_USAGE;
			}
			break;

		  case 'D':
			if (debug)
			{
				errno = 0;
				syserr("-D file must be before -d");
				ExitStat = EX_USAGE;
				break;
			}
			dp = drop_privileges(true);
			setstat(dp);
			smdebug = sm_io_open(SmFtStdio, SM_TIME_DEFAULT,
					    optarg, SM_IO_APPEND, NULL);
			if (smdebug == NULL)
			{
				syserr("cannot open %s", optarg);
				ExitStat = EX_CANTCREAT;
				break;
			}
			sm_debug_setfile(smdebug);
			break;

		  case 'd':
			debug = true;
			tTflag(optarg);
			(void) sm_io_setvbuf(sm_debug_file(), SM_TIME_DEFAULT,
					     (char *) NULL, SM_IO_NBF,
					     SM_IO_BUFSIZ);
			break;

		  case 'G':	/* relay (gateway) submission */
			SubmitMode = SUBMIT_MTA;
			break;

		  case 'L':
			if (optarg == NULL)
			{
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "option requires an argument -- '%c'",
						     (char) j);
				return EX_USAGE;
			}
			j = SM_MIN(strlen(optarg), 32) + 1;
			sysloglabel = xalloc(j);
			(void) sm_strlcpy(sysloglabel, optarg, j);
			SyslogPrefixLen = PIDLEN + (MAXQFNAME - 3) +
					  SL_FUDGE + j;
			break;

		  case 'Q':
		  case 'q':
			/* just check if it is there */
			queuerun = true;
			break;
		}
	}
	opterr = 1;

	/* Don't leak queue information via debug flags */
	if (extraprivs && queuerun && debug)
	{
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "WARNING: Can not use -d with -q.  Disabling debugging.\n");
		sm_debug_close();
		sm_debug_setfile(NULL);
		(void) memset(tTdvect, '\0', sizeof(tTdvect));
	}

#if LOG
	if (sysloglabel != NULL)
	{
		/* Sanitize the string */
		for (p = sysloglabel; *p != '\0'; p++)
		{
			if (!isascii(*p) || !isprint(*p) || *p == '%')
				*p = '*';
		}
		closelog();
#  ifdef LOG_MAIL
		openlog(sysloglabel, LOG_PID, LOG_MAIL);
#  else /* LOG_MAIL */
		openlog(sysloglabel, LOG_PID);
#  endif /* LOG_MAIL */
	}
#endif /* LOG */

	/* set up the blank envelope */
	BlankEnvelope.e_puthdr = putheader;
	BlankEnvelope.e_putbody = putbody;
	BlankEnvelope.e_xfp = NULL;
	STRUCTCOPY(NullAddress, BlankEnvelope.e_from);
	CurEnv = &BlankEnvelope;
	STRUCTCOPY(NullAddress, MainEnvelope.e_from);

	/*
	**  Set default values for variables.
	**	These cannot be in initialized data space.
	*/

	setdefaults(&BlankEnvelope);
	initmacros(&BlankEnvelope);

	/* reset macro */
	set_op_mode(OpMode);
	if (OpMode == MD_DAEMON)
		DaemonPid = CurrentPid;	/* needed for finis() to work */

	pw = sm_getpwuid(RealUid);
	if (pw != NULL)
		(void) sm_strlcpy(rnamebuf, pw->pw_name, sizeof(rnamebuf));
	else
		(void) sm_snprintf(rnamebuf, sizeof(rnamebuf), "Unknown UID %d",
				   (int) RealUid);

	RealUserName = rnamebuf;

	if (tTd(0, 101))
	{
		sm_dprintf("Version %s\n", Version);
		finis(false, true, EX_OK);
		/* NOTREACHED */
	}

	/*
	**  if running non-set-user-ID binary as non-root, pretend
	**  we are the RunAsUid
	*/

	if (RealUid != 0 && geteuid() == RealUid)
	{
		if (tTd(47, 1))
			sm_dprintf("Non-set-user-ID binary: RunAsUid = RealUid = %d\n",
				   (int) RealUid);
		RunAsUid = RealUid;
	}
	else if (geteuid() != 0)
		RunAsUid = geteuid();

	EffGid = getegid();
	if (RealUid != 0 && EffGid == RealGid)
		RunAsGid = RealGid;

	if (tTd(47, 5))
	{
		sm_dprintf("main: e/ruid = %d/%d e/rgid = %d/%d\n",
			   (int) geteuid(), (int) getuid(),
			   (int) getegid(), (int) getgid());
		sm_dprintf("main: RunAsUser = %d:%d\n",
			   (int) RunAsUid, (int) RunAsGid);
	}

	/* save command line arguments */
	j = 0;
	for (av = argv; *av != NULL; )
		j += strlen(*av++) + 1;
	SaveArgv = (char **) xalloc(sizeof(char *) * (argc + 1));
	CommandLineArgs = xalloc(j);
	p = CommandLineArgs;
	for (av = argv, i = 0; *av != NULL; )
	{
		int h;

		SaveArgv[i++] = newstr(*av);
		if (av != argv)
			*p++ = ' ';
		(void) sm_strlcpy(p, *av++, j);
		h = strlen(p);
		p += h;
		j -= h + 1;
	}
	SaveArgv[i] = NULL;

	if (tTd(0, 1))
	{
		extern char *CompileOptions[];

		sm_dprintf("Version %s\n Compiled with:", Version);
		sm_printoptions(CompileOptions);
	}
	if (tTd(0, 10))
	{
		extern char *OsCompileOptions[];

		sm_dprintf("    OS Defines:");
		sm_printoptions(OsCompileOptions);
#ifdef _PATH_UNIX
		sm_dprintf("Kernel symbols:\t%s\n", _PATH_UNIX);
#endif /* _PATH_UNIX */

		sm_dprintf("     Conf file:\t%s (default for MSP)\n",
			   getcfname(OpMode, SubmitMode, SM_GET_SUBMIT_CF,
				     conffile));
		sm_dprintf("     Conf file:\t%s (default for MTA)\n",
			   getcfname(OpMode, SubmitMode, SM_GET_SENDMAIL_CF,
				     conffile));
		sm_dprintf("      Pid file:\t%s (default)\n", PidFile);
	}

	if (tTd(0, 12))
	{
		extern char *SmCompileOptions[];

		sm_dprintf(" libsm Defines:");
		sm_printoptions(SmCompileOptions);
	}

	if (tTd(0, 13))
	{
		extern char *FFRCompileOptions[];

		sm_dprintf("   FFR Defines:");
		sm_printoptions(FFRCompileOptions);
	}

	/* clear sendmail's environment */
	ExternalEnviron = environ;
	emptyenviron[0] = NULL;
	environ = emptyenviron;

	/*
	**  restore any original TZ setting until TimeZoneSpec has been
	**  determined - or early log messages may get bogus time stamps
	*/

	if ((p = getextenv("TZ")) != NULL)
	{
		char *tz;
		int tzlen;

		/* XXX check for reasonable length? */
		tzlen = strlen(p) + 4;
		tz = xalloc(tzlen);
		(void) sm_strlcpyn(tz, tzlen, 2, "TZ=", p);

		/* XXX check return code? */
		(void) putenv(tz);
	}

	/* prime the child environment */
	sm_setuserenv("AGENT", "sendmail");

	(void) sm_signal(SIGPIPE, SIG_IGN);
	OldUmask = umask(022);
	FullName = getextenv("NAME");
	if (FullName != NULL)
		FullName = newstr(FullName);

	/*
	**  Initialize name server if it is going to be used.
	*/

#if NAMED_BIND
	if (!bitset(RES_INIT, _res.options))
		(void) res_init();
	if (tTd(8, 8))
		_res.options |= RES_DEBUG;
	else
		_res.options &= ~RES_DEBUG;
# ifdef RES_NOALIASES
	_res.options |= RES_NOALIASES;
# endif /* RES_NOALIASES */
	TimeOuts.res_retry[RES_TO_DEFAULT] = _res.retry;
	TimeOuts.res_retry[RES_TO_FIRST] = _res.retry;
	TimeOuts.res_retry[RES_TO_NORMAL] = _res.retry;
	TimeOuts.res_retrans[RES_TO_DEFAULT] = _res.retrans;
	TimeOuts.res_retrans[RES_TO_FIRST] = _res.retrans;
	TimeOuts.res_retrans[RES_TO_NORMAL] = _res.retrans;
#endif /* NAMED_BIND */

	errno = 0;
	from = NULL;

	/* initialize some macros, etc. */
	init_vendor_macros(&BlankEnvelope);

	/* version */
	macdefine(&BlankEnvelope.e_macro, A_PERM, 'v', Version);

	/* hostname */
	hp = myhostname(jbuf, sizeof(jbuf));
	if (jbuf[0] != '\0')
	{
		struct utsname utsname;

		if (tTd(0, 4))
			sm_dprintf("Canonical name: %s\n", jbuf);
		macdefine(&BlankEnvelope.e_macro, A_TEMP, 'w', jbuf);
		macdefine(&BlankEnvelope.e_macro, A_TEMP, 'j', jbuf);
		setclass('w', jbuf);

		p = strchr(jbuf, '.');
		if (p != NULL && p[1] != '\0')
			macdefine(&BlankEnvelope.e_macro, A_TEMP, 'm', &p[1]);

		if (uname(&utsname) >= 0)
			p = utsname.nodename;
		else
		{
			if (tTd(0, 22))
				sm_dprintf("uname failed (%s)\n",
					   sm_errstring(errno));
			makelower(jbuf);
			p = jbuf;
		}
		if (tTd(0, 4))
			sm_dprintf(" UUCP nodename: %s\n", p);
		macdefine(&BlankEnvelope.e_macro, A_TEMP, 'k', p);
		setclass('k', p);
		setclass('w', p);
	}
	if (hp != NULL)
	{
		for (av = hp->h_aliases; av != NULL && *av != NULL; av++)
		{
			if (tTd(0, 4))
				sm_dprintf("\ta.k.a.: %s\n", *av);
			setclass('w', *av);
		}
#if NETINET || NETINET6
		for (i = 0; i >= 0 && hp->h_addr_list[i] != NULL; i++)
		{
# if NETINET6
			char *addr;
			char buf6[INET6_ADDRSTRLEN];
			struct in6_addr ia6;
# endif /* NETINET6 */
# if NETINET
			struct in_addr ia;
# endif /* NETINET */
			char ipbuf[103];

			ipbuf[0] = '\0';
			switch (hp->h_addrtype)
			{
# if NETINET
			  case AF_INET:
				if (hp->h_length != INADDRSZ)
					break;

				memmove(&ia, hp->h_addr_list[i], INADDRSZ);
				(void) sm_snprintf(ipbuf, sizeof(ipbuf),
						   "[%.100s]", inet_ntoa(ia));
				break;
# endif /* NETINET */

# if NETINET6
			  case AF_INET6:
				if (hp->h_length != IN6ADDRSZ)
					break;

				memmove(&ia6, hp->h_addr_list[i], IN6ADDRSZ);
				addr = anynet_ntop(&ia6, buf6, sizeof(buf6));
				if (addr != NULL)
					(void) sm_snprintf(ipbuf, sizeof(ipbuf),
							   "[%.100s]", addr);
				break;
# endif /* NETINET6 */
			}
			if (ipbuf[0] == '\0')
				break;

			if (tTd(0, 4))
				sm_dprintf("\ta.k.a.: %s\n", ipbuf);
			setclass('w', ipbuf);
		}
#endif /* NETINET || NETINET6 */
#if NETINET6
		freehostent(hp);
		hp = NULL;
#endif /* NETINET6 */
	}

	/* current time */
	macdefine(&BlankEnvelope.e_macro, A_TEMP, 'b', arpadate((char *) NULL));

	/* current load average */
	sm_getla();

	QueueLimitRecipient = (QUEUE_CHAR *) NULL;
	QueueLimitSender = (QUEUE_CHAR *) NULL;
	QueueLimitId = (QUEUE_CHAR *) NULL;
	QueueLimitQuarantine = (QUEUE_CHAR *) NULL;

	/*
	**  Crack argv.
	*/

	optind = 1;
	while ((j = getopt(argc, argv, OPTIONS)) != -1)
	{
		switch (j)
		{
		  case 'b':	/* operations mode */
			/* already done */
			break;

		  case 'A':	/* use Alternate sendmail/submit.cf */
			cftype = optarg[0] == 'c' ? SM_GET_SUBMIT_CF
						  : SM_GET_SENDMAIL_CF;
			break;

		  case 'B':	/* body type */
			CHECK_AGAINST_OPMODE(j);
			BlankEnvelope.e_bodytype = newstr(optarg);
			break;

		  case 'C':	/* select configuration file (already done) */
			if (RealUid != 0)
				warn_C_flag = true;
			conffile = newstr(optarg);
			dp = drop_privileges(true);
			setstat(dp);
			safecf = false;
			break;

		  case 'D':
		  case 'd':	/* debugging */
			/* already done */
			break;

		  case 'f':	/* from address */
		  case 'r':	/* obsolete -f flag */
			CHECK_AGAINST_OPMODE(j);
			if (from != NULL)
			{
				usrerr("More than one \"from\" person");
				ExitStat = EX_USAGE;
				break;
			}
			if (optarg[0] == '\0')
				from = newstr("<>");
			else
				from = newstr(denlstring(optarg, true, true));
			if (strcmp(RealUserName, from) != 0)
				warn_f_flag = j;
			break;

		  case 'F':	/* set full name */
			CHECK_AGAINST_OPMODE(j);
			FullName = newstr(optarg);
			break;

		  case 'G':	/* relay (gateway) submission */
			/* already set */
			CHECK_AGAINST_OPMODE(j);
			break;

		  case 'h':	/* hop count */
			CHECK_AGAINST_OPMODE(j);
			BlankEnvelope.e_hopcount = (short) strtol(optarg, &ep,
								  10);
			(void) sm_snprintf(buf, sizeof(buf), "%d",
					   BlankEnvelope.e_hopcount);
			macdefine(&BlankEnvelope.e_macro, A_TEMP, 'c', buf);

			if (*ep)
			{
				usrerr("Bad hop count (%s)", optarg);
				ExitStat = EX_USAGE;
			}
			break;

		  case 'L':	/* program label */
			/* already set */
			break;

		  case 'n':	/* don't alias */
			CHECK_AGAINST_OPMODE(j);
			NoAlias = true;
			break;

		  case 'N':	/* delivery status notifications */
			CHECK_AGAINST_OPMODE(j);
			DefaultNotify |= QHASNOTIFY;
			macdefine(&BlankEnvelope.e_macro, A_TEMP,
				macid("{dsn_notify}"), optarg);
			if (sm_strcasecmp(optarg, "never") == 0)
				break;
			for (p = optarg; p != NULL; optarg = p)
			{
				p = strchr(p, ',');
				if (p != NULL)
					*p++ = '\0';
				if (sm_strcasecmp(optarg, "success") == 0)
					DefaultNotify |= QPINGONSUCCESS;
				else if (sm_strcasecmp(optarg, "failure") == 0)
					DefaultNotify |= QPINGONFAILURE;
				else if (sm_strcasecmp(optarg, "delay") == 0)
					DefaultNotify |= QPINGONDELAY;
				else
				{
					usrerr("Invalid -N argument");
					ExitStat = EX_USAGE;
				}
			}
			break;

		  case 'o':	/* set option */
			setoption(*optarg, optarg + 1, false, true,
				  &BlankEnvelope);
			break;

		  case 'O':	/* set option (long form) */
			setoption(' ', optarg, false, true, &BlankEnvelope);
			break;

		  case 'p':	/* set protocol */
			CHECK_AGAINST_OPMODE(j);
			p = strchr(optarg, ':');
			if (p != NULL)
			{
				*p++ = '\0';
				if (*p != '\0')
				{
					i = strlen(p) + 1;
					ep = sm_malloc_x(i);
					cleanstrcpy(ep, p, i);
					macdefine(&BlankEnvelope.e_macro,
						  A_HEAP, 's', ep);
				}
			}
			if (*optarg != '\0')
			{
				i = strlen(optarg) + 1;
				ep = sm_malloc_x(i);
				cleanstrcpy(ep, optarg, i);
				macdefine(&BlankEnvelope.e_macro, A_HEAP,
					  'r', ep);
			}
			break;

		  case 'Q':	/* change quarantining on queued items */
			/* sanity check */
			if (OpMode != MD_DELIVER &&
			    OpMode != MD_QUEUERUN)
			{
				usrerr("Can not use -Q with -b%c", OpMode);
				ExitStat = EX_USAGE;
				break;
			}

			if (OpMode == MD_DELIVER)
				set_op_mode(MD_QUEUERUN);

			FullName = NULL;

			quarantining = newstr(optarg);
			break;

		  case 'q':	/* run queue files at intervals */
			/* sanity check */
			if (OpMode != MD_DELIVER &&
			    OpMode != MD_DAEMON &&
			    OpMode != MD_FGDAEMON &&
			    OpMode != MD_PRINT &&
			    OpMode != MD_PRINTNQE &&
			    OpMode != MD_QUEUERUN)
			{
				usrerr("Can not use -q with -b%c", OpMode);
				ExitStat = EX_USAGE;
				break;
			}

			/* don't override -bd, -bD or -bp */
			if (OpMode == MD_DELIVER)
				set_op_mode(MD_QUEUERUN);

			FullName = NULL;
			negate = optarg[0] == '!';
			if (negate)
			{
				/* negate meaning of pattern match */
				optarg++; /* skip '!' for next switch */
			}

			switch (optarg[0])
			{
			  case 'G': /* Limit by queue group name */
				if (negate)
				{
					usrerr("Can not use -q!G");
					ExitStat = EX_USAGE;
					break;
				}
				if (queuegroup != NULL)
				{
					usrerr("Can not use multiple -qG options");
					ExitStat = EX_USAGE;
					break;
				}
				queuegroup = newstr(&optarg[1]);
				break;

			  case 'I': /* Limit by ID */
				new = (QUEUE_CHAR *) xalloc(sizeof(*new));
				new->queue_match = newstr(&optarg[1]);
				new->queue_negate = negate;
				new->queue_next = QueueLimitId;
				QueueLimitId = new;
				break;

			  case 'R': /* Limit by recipient */
				new = (QUEUE_CHAR *) xalloc(sizeof(*new));
				new->queue_match = newstr(&optarg[1]);
				new->queue_negate = negate;
				new->queue_next = QueueLimitRecipient;
				QueueLimitRecipient = new;
				break;

			  case 'S': /* Limit by sender */
				new = (QUEUE_CHAR *) xalloc(sizeof(*new));
				new->queue_match = newstr(&optarg[1]);
				new->queue_negate = negate;
				new->queue_next = QueueLimitSender;
				QueueLimitSender = new;
				break;

			  case 'f': /* foreground queue run */
				foregroundqueue  = true;
				break;

			  case 'Q': /* Limit by quarantine message */
				if (optarg[1] != '\0')
				{
					new = (QUEUE_CHAR *) xalloc(sizeof(*new));
					new->queue_match = newstr(&optarg[1]);
					new->queue_negate = negate;
					new->queue_next = QueueLimitQuarantine;
					QueueLimitQuarantine = new;
				}
				QueueMode = QM_QUARANTINE;
				break;

			  case 'L': /* act on lost items */
				QueueMode = QM_LOST;
				break;

			  case 'p': /* Persistent queue */
				queuepersistent = true;
				if (QueueIntvl == 0)
					QueueIntvl = 1;
				if (optarg[1] == '\0')
					break;
				++optarg;
				/* FALLTHROUGH */

			  default:
				i = Errors;
				QueueIntvl = convtime(optarg, 'm');
				if (QueueIntvl < 0)
				{
					usrerr("Invalid -q value");
					ExitStat = EX_USAGE;
				}

				/* check for bad conversion */
				if (i < Errors)
					ExitStat = EX_USAGE;
				break;
			}
			break;

		  case 'R':	/* DSN RET: what to return */
			CHECK_AGAINST_OPMODE(j);
			if (bitset(EF_RET_PARAM, BlankEnvelope.e_flags))
			{
				usrerr("Duplicate -R flag");
				ExitStat = EX_USAGE;
				break;
			}
			BlankEnvelope.e_flags |= EF_RET_PARAM;
			if (sm_strcasecmp(optarg, "hdrs") == 0)
				BlankEnvelope.e_flags |= EF_NO_BODY_RETN;
			else if (sm_strcasecmp(optarg, "full") != 0)
			{
				usrerr("Invalid -R value");
				ExitStat = EX_USAGE;
			}
			macdefine(&BlankEnvelope.e_macro, A_TEMP,
				  macid("{dsn_ret}"), optarg);
			break;

		  case 't':	/* read recipients from message */
			CHECK_AGAINST_OPMODE(j);
			GrabTo = true;
			break;

		  case 'V':	/* DSN ENVID: set "original" envelope id */
			CHECK_AGAINST_OPMODE(j);
			if (!xtextok(optarg))
			{
				usrerr("Invalid syntax in -V flag");
				ExitStat = EX_USAGE;
			}
			else
			{
				BlankEnvelope.e_envid = newstr(optarg);
				macdefine(&BlankEnvelope.e_macro, A_TEMP,
					  macid("{dsn_envid}"), optarg);
			}
			break;

		  case 'X':	/* traffic log file */
			dp = drop_privileges(true);
			setstat(dp);
			if (stat(optarg, &traf_st) == 0 &&
			    S_ISFIFO(traf_st.st_mode))
				TrafficLogFile = sm_io_open(SmFtStdio,
							    SM_TIME_DEFAULT,
							    optarg,
							    SM_IO_WRONLY, NULL);
			else
				TrafficLogFile = sm_io_open(SmFtStdio,
							    SM_TIME_DEFAULT,
							    optarg,
							    SM_IO_APPEND, NULL);
			if (TrafficLogFile == NULL)
			{
				syserr("cannot open %s", optarg);
				ExitStat = EX_CANTCREAT;
				break;
			}
			(void) sm_io_setvbuf(TrafficLogFile, SM_TIME_DEFAULT,
					     NULL, SM_IO_LBF, 0);
			break;

			/* compatibility flags */
		  case 'c':	/* connect to non-local mailers */
		  case 'i':	/* don't let dot stop me */
		  case 'm':	/* send to me too */
		  case 'T':	/* set timeout interval */
		  case 'v':	/* give blow-by-blow description */
			setoption(j, "T", false, true, &BlankEnvelope);
			break;

		  case 'e':	/* error message disposition */
		  case 'M':	/* define macro */
			setoption(j, optarg, false, true, &BlankEnvelope);
			break;

		  case 's':	/* save From lines in headers */
			setoption('f', "T", false, true, &BlankEnvelope);
			break;

#ifdef DBM
		  case 'I':	/* initialize alias DBM file */
			set_op_mode(MD_INITALIAS);
			break;
#endif /* DBM */

#if defined(__osf__) || defined(_AIX3)
		  case 'x':	/* random flag that OSF/1 & AIX mailx passes */
			break;
#endif /* defined(__osf__) || defined(_AIX3) */
#if defined(sony_news)
		  case 'E':
		  case 'J':	/* ignore flags for Japanese code conversion
				   implemented on Sony NEWS */
			break;
#endif /* defined(sony_news) */

		  default:
			finis(true, true, EX_USAGE);
			/* NOTREACHED */
			break;
		}
	}

	/* if we've had errors so far, exit now */
	if ((ExitStat != EX_OK && OpMode != MD_TEST && OpMode != MD_CHECKCONFIG) ||
	    ExitStat == EX_OSERR)
	{
		finis(false, true, ExitStat);
		/* NOTREACHED */
	}

	if (bitset(SUBMIT_MTA, SubmitMode))
	{
		/* If set daemon_flags on command line, don't reset it */
		if (macvalue(macid("{daemon_flags}"), &BlankEnvelope) == NULL)
			macdefine(&BlankEnvelope.e_macro, A_PERM,
				  macid("{daemon_flags}"), "CC f");
	}
	else if (OpMode == MD_DELIVER || OpMode == MD_SMTP)
	{
		SubmitMode = SUBMIT_MSA;

		/* If set daemon_flags on command line, don't reset it */
		if (macvalue(macid("{daemon_flags}"), &BlankEnvelope) == NULL)
			macdefine(&BlankEnvelope.e_macro, A_PERM,
				  macid("{daemon_flags}"), "c u");
	}

	/*
	**  Do basic initialization.
	**	Read system control file.
	**	Extract special fields for local use.
	*/

#if XDEBUG
	checkfd012("before readcf");
#endif /* XDEBUG */
	vendor_pre_defaults(&BlankEnvelope);

	readcf(getcfname(OpMode, SubmitMode, cftype, conffile),
			 safecf, &BlankEnvelope);
#if !defined(_USE_SUN_NSSWITCH_) && !defined(_USE_DEC_SVC_CONF_)
	ConfigFileRead = true;
#endif /* !defined(_USE_SUN_NSSWITCH_) && !defined(_USE_DEC_SVC_CONF_) */
	vendor_post_defaults(&BlankEnvelope);

	/* now we can complain about missing fds */
	if (MissingFds != 0 && LogLevel > 8)
	{
		char mbuf[MAXLINE];

		mbuf[0] = '\0';
		if (bitset(1 << STDIN_FILENO, MissingFds))
			(void) sm_strlcat(mbuf, ", stdin", sizeof(mbuf));
		if (bitset(1 << STDOUT_FILENO, MissingFds))
			(void) sm_strlcat(mbuf, ", stdout", sizeof(mbuf));
		if (bitset(1 << STDERR_FILENO, MissingFds))
			(void) sm_strlcat(mbuf, ", stderr", sizeof(mbuf));

		/* Notice: fill_errno is from high above: fill_fd() */
		sm_syslog(LOG_WARNING, NOQID,
			  "File descriptors missing on startup: %s; %s",
			  &mbuf[2], sm_errstring(fill_errno));
	}

	/* Remove the ability for a normal user to send signals */
	if (RealUid != 0 && RealUid != geteuid())
	{
		uid_t new_uid = geteuid();

#if HASSETREUID
		/*
		**  Since we can differentiate between uid and euid,
		**  make the uid a different user so the real user
		**  can't send signals.  However, it doesn't need to be
		**  root (euid has root).
		*/

		if (new_uid == 0)
			new_uid = DefUid;
		if (tTd(47, 5))
			sm_dprintf("Changing real uid to %d\n", (int) new_uid);
		if (setreuid(new_uid, geteuid()) < 0)
		{
			syserr("main: setreuid(%d, %d) failed",
			       (int) new_uid, (int) geteuid());
			finis(false, true, EX_OSERR);
			/* NOTREACHED */
		}
		if (tTd(47, 10))
			sm_dprintf("Now running as e/ruid %d:%d\n",
				   (int) geteuid(), (int) getuid());
#else /* HASSETREUID */
		/*
		**  Have to change both effective and real so need to
		**  change them both to effective to keep privs.
		*/

		if (tTd(47, 5))
			sm_dprintf("Changing uid to %d\n", (int) new_uid);
		if (setuid(new_uid) < 0)
		{
			syserr("main: setuid(%d) failed", (int) new_uid);
			finis(false, true, EX_OSERR);
			/* NOTREACHED */
		}
		if (tTd(47, 10))
			sm_dprintf("Now running as e/ruid %d:%d\n",
				   (int) geteuid(), (int) getuid());
#endif /* HASSETREUID */
	}

#if NAMED_BIND
	if (FallbackMX != NULL)
		(void) getfallbackmxrr(FallbackMX);
#endif /* NAMED_BIND */

	if (SuperSafe == SAFE_INTERACTIVE && CurEnv->e_sendmode != SM_DELIVER)
	{
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "WARNING: SuperSafe=interactive should only be used with\n         DeliveryMode=interactive\n");
	}

	if (UseMSP && (OpMode == MD_DAEMON || OpMode == MD_FGDAEMON))
	{
		usrerr("Mail submission program cannot be used as daemon");
		finis(false, true, EX_USAGE);
	}

	if (OpMode == MD_DELIVER || OpMode == MD_SMTP ||
	    OpMode == MD_QUEUERUN || OpMode == MD_ARPAFTP ||
	    OpMode == MD_DAEMON || OpMode == MD_FGDAEMON)
		makeworkgroups();

	/* set up the basic signal handlers */
	if (sm_signal(SIGINT, SIG_IGN) != SIG_IGN)
		(void) sm_signal(SIGINT, intsig);
	(void) sm_signal(SIGTERM, intsig);

	/* Enforce use of local time (null string overrides this) */
	if (TimeZoneSpec == NULL)
		unsetenv("TZ");
	else if (TimeZoneSpec[0] != '\0')
		sm_setuserenv("TZ", TimeZoneSpec);
	else
		sm_setuserenv("TZ", NULL);
	tzset();

	/* initialize mailbox database */
	i = sm_mbdb_initialize(Mbdb);
	if (i != EX_OK)
	{
		usrerr("Can't initialize mailbox database \"%s\": %s",
		       Mbdb, sm_strexit(i));
		ExitStat = i;
	}

	/* avoid denial-of-service attacks */
	resetlimits();

	if (OpMode == MD_TEST)
	{
		/* can't be done after readcf if RunAs* is used */
		dp = drop_privileges(true);
		if (dp != EX_OK)
		{
			finis(false, true, dp);
			/* NOTREACHED */
		}
	}
	else if (OpMode != MD_DAEMON && OpMode != MD_FGDAEMON)
	{
		/* drop privileges -- daemon mode done after socket/bind */
		dp = drop_privileges(false);
		setstat(dp);
		if (dp == EX_OK && UseMSP && (geteuid() == 0 || getuid() == 0))
		{
			usrerr("Mail submission program must have RunAsUser set to non root user");
			finis(false, true, EX_CONFIG);
			/* NOTREACHED */
		}
	}

#if NAMED_BIND
	_res.retry = TimeOuts.res_retry[RES_TO_DEFAULT];
	_res.retrans = TimeOuts.res_retrans[RES_TO_DEFAULT];
#endif /* NAMED_BIND */

	/*
	**  Find our real host name for future logging.
	*/

	authinfo = getauthinfo(STDIN_FILENO, &forged);
	macdefine(&BlankEnvelope.e_macro, A_TEMP, '_', authinfo);

	/* suppress error printing if errors mailed back or whatever */
	if (BlankEnvelope.e_errormode != EM_PRINT)
		HoldErrs = true;

	/* set up the $=m class now, after .cf has a chance to redefine $m */
	expand("\201m", jbuf, sizeof(jbuf), &BlankEnvelope);
	if (jbuf[0] != '\0')
		setclass('m', jbuf);

	/* probe interfaces and locate any additional names */
	if (DontProbeInterfaces != DPI_PROBENONE)
		load_if_names();

	if (tTd(0, 10))
	{
		char pidpath[MAXPATHLEN];

		/* Now we know which .cf file we use */
		sm_dprintf("     Conf file:\t%s (selected)\n",
			   getcfname(OpMode, SubmitMode, cftype, conffile));
		expand(PidFile, pidpath, sizeof(pidpath), &BlankEnvelope);
		sm_dprintf("      Pid file:\t%s (selected)\n", pidpath);
	}

	if (tTd(0, 1))
	{
		sm_dprintf("\n============ SYSTEM IDENTITY (after readcf) ============");
		sm_dprintf("\n      (short domain name) $w = ");
		xputs(sm_debug_file(), macvalue('w', &BlankEnvelope));
		sm_dprintf("\n  (canonical domain name) $j = ");
		xputs(sm_debug_file(), macvalue('j', &BlankEnvelope));
		sm_dprintf("\n         (subdomain name) $m = ");
		xputs(sm_debug_file(), macvalue('m', &BlankEnvelope));
		sm_dprintf("\n              (node name) $k = ");
		xputs(sm_debug_file(), macvalue('k', &BlankEnvelope));
		sm_dprintf("\n========================================================\n\n");
	}

	/*
	**  Do more command line checking -- these are things that
	**  have to modify the results of reading the config file.
	*/

	/* process authorization warnings from command line */
	if (warn_C_flag)
		auth_warning(&BlankEnvelope, "Processed by %s with -C %s",
			     RealUserName, conffile);
	if (Warn_Q_option && !wordinclass(RealUserName, 't'))
		auth_warning(&BlankEnvelope, "Processed from queue %s",
			     QueueDir);
	if (sysloglabel != NULL && !wordinclass(RealUserName, 't') &&
	    RealUid != 0 && RealUid != TrustedUid && LogLevel > 1)
		sm_syslog(LOG_WARNING, NOQID, "user %d changed syslog label",
			  (int) RealUid);

	/* check body type for legality */
	i = check_bodytype(BlankEnvelope.e_bodytype);
	if (i == BODYTYPE_ILLEGAL)
	{
		usrerr("Illegal body type %s", BlankEnvelope.e_bodytype);
		BlankEnvelope.e_bodytype = NULL;
	}
	else if (i != BODYTYPE_NONE)
		SevenBitInput = (i == BODYTYPE_7BIT);

	/* tweak default DSN notifications */
	if (DefaultNotify == 0)
		DefaultNotify = QPINGONFAILURE|QPINGONDELAY;

	/* check for sane configuration level */
	if (ConfigLevel > MAXCONFIGLEVEL)
	{
		syserr("Warning: .cf version level (%d) exceeds sendmail version %s functionality (%d)",
		       ConfigLevel, Version, MAXCONFIGLEVEL);
	}

	/* need MCI cache to have persistence */
	if (HostStatDir != NULL && MaxMciCache == 0)
	{
		HostStatDir = NULL;
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Warning: HostStatusDirectory disabled with ConnectionCacheSize = 0\n");
	}

	/* need HostStatusDir in order to have SingleThreadDelivery */
	if (SingleThreadDelivery && HostStatDir == NULL)
	{
		SingleThreadDelivery = false;
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Warning: HostStatusDirectory required for SingleThreadDelivery\n");
	}

#if _FFR_MEMSTAT
	j = sm_memstat_open();
	if (j < 0 && (RefuseLowMem > 0 || QueueLowMem > 0) && LogLevel > 4)
	{
		sm_syslog(LOG_WARNING, NOQID,
			  "cannot get memory statistics, settings ignored, error=%d"
			  , j);
	}
#endif /* _FFR_MEMSTAT */

	/* check for permissions */
	if (RealUid != 0 &&
	    RealUid != TrustedUid)
	{
		char *action = NULL;

		switch (OpMode)
		{
		  case MD_QUEUERUN:
			if (quarantining != NULL)
				action = "quarantine jobs";
			else
			{
				/* Normal users can do a single queue run */
				if (QueueIntvl == 0)
					break;
			}

			/* but not persistent queue runners */
			if (action == NULL)
				action = "start a queue runner daemon";
			/* FALLTHROUGH */

		  case MD_PURGESTAT:
			if (action == NULL)
				action = "purge host status";
			/* FALLTHROUGH */

		  case MD_DAEMON:
		  case MD_FGDAEMON:
			if (action == NULL)
				action = "run daemon";

			if (tTd(65, 1))
				sm_dprintf("Deny user %d attempt to %s\n",
					   (int) RealUid, action);

			if (LogLevel > 1)
				sm_syslog(LOG_ALERT, NOQID,
					  "user %d attempted to %s",
					  (int) RealUid, action);
			HoldErrs = false;
			usrerr("Permission denied (real uid not trusted)");
			finis(false, true, EX_USAGE);
			/* NOTREACHED */
			break;

		  case MD_VERIFY:
			if (bitset(PRIV_RESTRICTEXPAND, PrivacyFlags))
			{
				/*
				**  If -bv and RestrictExpand,
				**  drop privs to prevent normal
				**  users from reading private
				**  aliases/forwards/:include:s
				*/

				if (tTd(65, 1))
					sm_dprintf("Drop privs for user %d attempt to expand (RestrictExpand)\n",
						   (int) RealUid);

				dp = drop_privileges(true);

				/* Fake address safety */
				if (tTd(65, 1))
					sm_dprintf("Faking DontBlameSendmail=NonRootSafeAddr\n");
				setbitn(DBS_NONROOTSAFEADDR, DontBlameSendmail);

				if (dp != EX_OK)
				{
					if (tTd(65, 1))
						sm_dprintf("Failed to drop privs for user %d attempt to expand, exiting\n",
							   (int) RealUid);
					CurEnv->e_id = NULL;
					finis(true, true, dp);
					/* NOTREACHED */
				}
			}
			break;

		  case MD_TEST:
		  case MD_CHECKCONFIG:
		  case MD_PRINT:
		  case MD_PRINTNQE:
		  case MD_FREEZE:
		  case MD_HOSTSTAT:
			/* Nothing special to check */
			break;

		  case MD_INITALIAS:
			if (!wordinclass(RealUserName, 't'))
			{
				if (tTd(65, 1))
					sm_dprintf("Deny user %d attempt to rebuild the alias map\n",
						   (int) RealUid);
				if (LogLevel > 1)
					sm_syslog(LOG_ALERT, NOQID,
						  "user %d attempted to rebuild the alias map",
						  (int) RealUid);
				HoldErrs = false;
				usrerr("Permission denied (real uid not trusted)");
				finis(false, true, EX_USAGE);
				/* NOTREACHED */
			}
			if (UseMSP)
			{
				HoldErrs = false;
				usrerr("User %d cannot rebuild aliases in mail submission program",
				       (int) RealUid);
				finis(false, true, EX_USAGE);
				/* NOTREACHED */
			}
			/* FALLTHROUGH */

		  default:
			if (bitset(PRIV_RESTRICTEXPAND, PrivacyFlags) &&
			    Verbose != 0)
			{
				/*
				**  If -v and RestrictExpand, reset
				**  Verbose to prevent normal users
				**  from seeing the expansion of
				**  aliases/forwards/:include:s
				*/

				if (tTd(65, 1))
					sm_dprintf("Dropping verbosity for user %d (RestrictExpand)\n",
						   (int) RealUid);
				Verbose = 0;
			}
			break;
		}
	}

	if (MeToo)
		BlankEnvelope.e_flags |= EF_METOO;

	switch (OpMode)
	{
	  case MD_TEST:
		/* don't have persistent host status in test mode */
		HostStatDir = NULL;
		/* FALLTHROUGH */

	  case MD_CHECKCONFIG:
		if (Verbose == 0)
			Verbose = 2;
		BlankEnvelope.e_errormode = EM_PRINT;
		HoldErrs = false;
		break;

	  case MD_VERIFY:
		BlankEnvelope.e_errormode = EM_PRINT;
		HoldErrs = false;
		/* arrange to exit cleanly on hangup signal */
		if (sm_signal(SIGHUP, SIG_IGN) == (sigfunc_t) SIG_DFL)
			(void) sm_signal(SIGHUP, intsig);
		if (geteuid() != 0)
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Notice: -bv may give misleading output for non-privileged user\n");
		break;

	  case MD_FGDAEMON:
		run_in_foreground = true;
		set_op_mode(MD_DAEMON);
		/* FALLTHROUGH */

	  case MD_DAEMON:
		vendor_daemon_setup(&BlankEnvelope);

		/* remove things that don't make sense in daemon mode */
		FullName = NULL;
		GrabTo = false;

		/* arrange to restart on hangup signal */
		if (SaveArgv[0] == NULL || SaveArgv[0][0] != '/')
			sm_syslog(LOG_WARNING, NOQID,
				  "daemon invoked without full pathname; kill -1 won't work");
		break;

	  case MD_INITALIAS:
		Verbose = 2;
		BlankEnvelope.e_errormode = EM_PRINT;
		HoldErrs = false;
		/* FALLTHROUGH */

	  default:
		/* arrange to exit cleanly on hangup signal */
		if (sm_signal(SIGHUP, SIG_IGN) == (sigfunc_t) SIG_DFL)
			(void) sm_signal(SIGHUP, intsig);
		break;
	}

	/* special considerations for FullName */
	if (FullName != NULL)
	{
		char *full = NULL;

		/* full names can't have newlines */
		if (strchr(FullName, '\n') != NULL)
		{
			full = newstr(denlstring(FullName, true, true));
			FullName = full;
		}

		/* check for characters that may have to be quoted */
		if (!rfc822_string(FullName))
		{
			/*
			**  Quote a full name with special characters
			**  as a comment so crackaddr() doesn't destroy
			**  the name portion of the address.
			*/

			FullName = addquotes(FullName, NULL);
			if (full != NULL)
				sm_free(full);  /* XXX */
		}
	}

	/* do heuristic mode adjustment */
	if (Verbose)
	{
		/* turn off noconnect option */
		setoption('c', "F", true, false, &BlankEnvelope);

		/* turn on interactive delivery */
		setoption('d', "", true, false, &BlankEnvelope);
	}

#ifdef VENDOR_CODE
	/* check for vendor mismatch */
	if (VendorCode != VENDOR_CODE)
	{
		message("Warning: .cf file vendor code mismatch: sendmail expects vendor %s, .cf file vendor is %s",
			getvendor(VENDOR_CODE), getvendor(VendorCode));
	}
#endif /* VENDOR_CODE */

	/* check for out of date configuration level */
	if (ConfigLevel < MAXCONFIGLEVEL)
	{
		message("Warning: .cf file is out of date: sendmail %s supports version %d, .cf file is version %d",
			Version, MAXCONFIGLEVEL, ConfigLevel);
	}

	if (ConfigLevel < 3)
		UseErrorsTo = true;

	/* set options that were previous macros */
	if (SmtpGreeting == NULL)
	{
		if (ConfigLevel < 7 &&
		    (p = macvalue('e', &BlankEnvelope)) != NULL)
			SmtpGreeting = newstr(p);
		else
			SmtpGreeting = "\201j Sendmail \201v ready at \201b";
	}
	if (UnixFromLine == NULL)
	{
		if (ConfigLevel < 7 &&
		    (p = macvalue('l', &BlankEnvelope)) != NULL)
			UnixFromLine = newstr(p);
		else
			UnixFromLine = "From \201g  \201d";
	}
	SmtpError[0] = '\0';

	/* our name for SMTP codes */
	expand("\201j", jbuf, sizeof(jbuf), &BlankEnvelope);
	if (jbuf[0] == '\0')
		PSTRSET(MyHostName, "localhost");
	else
		PSTRSET(MyHostName, jbuf);
	if (strchr(MyHostName, '.') == NULL)
		message("WARNING: local host name (%s) is not qualified; see cf/README: WHO AM I?",
			MyHostName);

	/* make certain that this name is part of the $=w class */
	setclass('w', MyHostName);

	/* fill in the structure of the *default* queue */
	st = stab("mqueue", ST_QUEUE, ST_FIND);
	if (st == NULL)
		syserr("No default queue (mqueue) defined");
	else
		set_def_queueval(st->s_quegrp, true);

	/* the indices of built-in mailers */
	st = stab("local", ST_MAILER, ST_FIND);
	if (st != NULL)
		LocalMailer = st->s_mailer;
	else if (OpMode != MD_TEST || !warn_C_flag)
		syserr("No local mailer defined");

	st = stab("prog", ST_MAILER, ST_FIND);
	if (st == NULL)
		syserr("No prog mailer defined");
	else
	{
		ProgMailer = st->s_mailer;
		clrbitn(M_MUSER, ProgMailer->m_flags);
	}

	st = stab("*file*", ST_MAILER, ST_FIND);
	if (st == NULL)
		syserr("No *file* mailer defined");
	else
	{
		FileMailer = st->s_mailer;
		clrbitn(M_MUSER, FileMailer->m_flags);
	}

	st = stab("*include*", ST_MAILER, ST_FIND);
	if (st == NULL)
		syserr("No *include* mailer defined");
	else
		InclMailer = st->s_mailer;

	if (ConfigLevel < 6)
	{
		/* heuristic tweaking of local mailer for back compat */
		if (LocalMailer != NULL)
		{
			setbitn(M_ALIASABLE, LocalMailer->m_flags);
			setbitn(M_HASPWENT, LocalMailer->m_flags);
			setbitn(M_TRYRULESET5, LocalMailer->m_flags);
			setbitn(M_CHECKINCLUDE, LocalMailer->m_flags);
			setbitn(M_CHECKPROG, LocalMailer->m_flags);
			setbitn(M_CHECKFILE, LocalMailer->m_flags);
			setbitn(M_CHECKUDB, LocalMailer->m_flags);
		}
		if (ProgMailer != NULL)
			setbitn(M_RUNASRCPT, ProgMailer->m_flags);
		if (FileMailer != NULL)
			setbitn(M_RUNASRCPT, FileMailer->m_flags);
	}
	if (ConfigLevel < 7)
	{
		if (LocalMailer != NULL)
			setbitn(M_VRFY250, LocalMailer->m_flags);
		if (ProgMailer != NULL)
			setbitn(M_VRFY250, ProgMailer->m_flags);
		if (FileMailer != NULL)
			setbitn(M_VRFY250, FileMailer->m_flags);
	}

	/* MIME Content-Types that cannot be transfer encoded */
	setclass('n', "multipart/signed");

	/* MIME message/xxx subtypes that can be treated as messages */
	setclass('s', "rfc822");

	/* MIME Content-Transfer-Encodings that can be encoded */
	setclass('e', "7bit");
	setclass('e', "8bit");
	setclass('e', "binary");

#ifdef USE_B_CLASS
	/* MIME Content-Types that should be treated as binary */
	setclass('b', "image");
	setclass('b', "audio");
	setclass('b', "video");
	setclass('b', "application/octet-stream");
#endif /* USE_B_CLASS */

	/* MIME headers which have fields to check for overflow */
	setclass(macid("{checkMIMEFieldHeaders}"), "content-disposition");
	setclass(macid("{checkMIMEFieldHeaders}"), "content-type");

	/* MIME headers to check for length overflow */
	setclass(macid("{checkMIMETextHeaders}"), "content-description");

	/* MIME headers to check for overflow and rebalance */
	setclass(macid("{checkMIMEHeaders}"), "content-disposition");
	setclass(macid("{checkMIMEHeaders}"), "content-id");
	setclass(macid("{checkMIMEHeaders}"), "content-transfer-encoding");
	setclass(macid("{checkMIMEHeaders}"), "content-type");
	setclass(macid("{checkMIMEHeaders}"), "mime-version");

	/* Macros to save in the queue file -- don't remove any */
	setclass(macid("{persistentMacros}"), "r");
	setclass(macid("{persistentMacros}"), "s");
	setclass(macid("{persistentMacros}"), "_");
	setclass(macid("{persistentMacros}"), "{if_addr}");
	setclass(macid("{persistentMacros}"), "{daemon_flags}");

	/* operate in queue directory */
	if (QueueDir == NULL || *QueueDir == '\0')
	{
		if (OpMode != MD_TEST)
		{
			syserr("QueueDirectory (Q) option must be set");
			ExitStat = EX_CONFIG;
		}
	}
	else
	{
		if (OpMode != MD_TEST)
			setup_queues(OpMode == MD_DAEMON);
	}

	/* check host status directory for validity */
	if (HostStatDir != NULL && !path_is_dir(HostStatDir, false))
	{
		/* cannot use this value */
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Warning: Cannot use HostStatusDirectory = %s: %s\n",
				     HostStatDir, sm_errstring(errno));
		HostStatDir = NULL;
	}

	if (OpMode == MD_QUEUERUN &&
	    RealUid != 0 && bitset(PRIV_RESTRICTQRUN, PrivacyFlags))
	{
		struct stat stbuf;

		/* check to see if we own the queue directory */
		if (stat(".", &stbuf) < 0)
			syserr("main: cannot stat %s", QueueDir);
		if (stbuf.st_uid != RealUid)
		{
			/* nope, really a botch */
			HoldErrs = false;
			usrerr("You do not have permission to process the queue");
			finis(false, true, EX_NOPERM);
			/* NOTREACHED */
		}
	}

#if MILTER
	/* sanity checks on milter filters */
	if (OpMode == MD_DAEMON || OpMode == MD_SMTP)
	{
		milter_config(InputFilterList, InputFilters, MAXFILTERS);
		setup_daemon_milters();
	}
#endif /* MILTER */

	/* Convert queuegroup string to qgrp number */
	if (queuegroup != NULL)
	{
		qgrp = name2qid(queuegroup);
		if (qgrp == NOQGRP)
		{
			HoldErrs = false;
			usrerr("Queue group %s unknown", queuegroup);
			finis(false, true, ExitStat);
			/* NOTREACHED */
		}
	}

	/* if checking config or have had errors so far, exit now */
	if (OpMode == MD_CHECKCONFIG || (ExitStat != EX_OK && OpMode != MD_TEST))
	{
		finis(false, true, ExitStat);
		/* NOTREACHED */
	}

#if SASL
	/* sendmail specific SASL initialization */
	sm_sasl_init();
#endif /* SASL */

#if XDEBUG
	checkfd012("before main() initmaps");
#endif /* XDEBUG */

	/*
	**  Do operation-mode-dependent initialization.
	*/

	switch (OpMode)
	{
	  case MD_PRINT:
		/* print the queue */
		HoldErrs = false;
		(void) dropenvelope(&BlankEnvelope, true, false);
		(void) sm_signal(SIGPIPE, sigpipe);
		if (qgrp != NOQGRP)
		{
			int j;

			/* Selecting a particular queue group to run */
			for (j = 0; j < Queue[qgrp]->qg_numqueues; j++)
			{
				if (StopRequest)
					stop_sendmail();
				(void) print_single_queue(qgrp, j);
			}
			finis(false, true, EX_OK);
			/* NOTREACHED */
		}
		printqueue();
		finis(false, true, EX_OK);
		/* NOTREACHED */
		break;

	  case MD_PRINTNQE:
		/* print number of entries in queue */
		(void) dropenvelope(&BlankEnvelope, true, false);
		(void) sm_signal(SIGPIPE, sigpipe);
		printnqe(smioout, NULL);
		finis(false, true, EX_OK);
		/* NOTREACHED */
		break;

	  case MD_QUEUERUN:
		/* only handle quarantining here */
		if (quarantining == NULL)
			break;

		if (QueueMode != QM_QUARANTINE &&
		    QueueMode != QM_NORMAL)
		{
			HoldErrs = false;
			usrerr("Can not use -Q with -q%c", QueueMode);
			ExitStat = EX_USAGE;
			finis(false, true, ExitStat);
			/* NOTREACHED */
		}
		quarantine_queue(quarantining, qgrp);
		finis(false, true, EX_OK);
		break;

	  case MD_HOSTSTAT:
		(void) sm_signal(SIGPIPE, sigpipe);
		(void) mci_traverse_persistent(mci_print_persistent, NULL);
		finis(false, true, EX_OK);
		/* NOTREACHED */
		break;

	  case MD_PURGESTAT:
		(void) mci_traverse_persistent(mci_purge_persistent, NULL);
		finis(false, true, EX_OK);
		/* NOTREACHED */
		break;

	  case MD_INITALIAS:
		/* initialize maps */
		initmaps();
		finis(false, true, ExitStat);
		/* NOTREACHED */
		break;

	  case MD_SMTP:
	  case MD_DAEMON:
		/* reset DSN parameters */
		DefaultNotify = QPINGONFAILURE|QPINGONDELAY;
		macdefine(&BlankEnvelope.e_macro, A_PERM,
			  macid("{dsn_notify}"), NULL);
		BlankEnvelope.e_envid = NULL;
		macdefine(&BlankEnvelope.e_macro, A_PERM,
			  macid("{dsn_envid}"), NULL);
		BlankEnvelope.e_flags &= ~(EF_RET_PARAM|EF_NO_BODY_RETN);
		macdefine(&BlankEnvelope.e_macro, A_PERM,
			  macid("{dsn_ret}"), NULL);

		/* don't open maps for daemon -- done below in child */
		break;
	}

	if (tTd(0, 15))
	{
		/* print configuration table (or at least part of it) */
		if (tTd(0, 90))
			printrules();
		for (i = 0; i < MAXMAILERS; i++)
		{
			if (Mailer[i] != NULL)
				printmailer(sm_debug_file(), Mailer[i]);
		}
	}

	/*
	**  Switch to the main envelope.
	*/

	CurEnv = newenvelope(&MainEnvelope, &BlankEnvelope,
			     sm_rpool_new_x(NULL));
	MainEnvelope.e_flags = BlankEnvelope.e_flags;

	/*
	**  If test mode, read addresses from stdin and process.
	*/

	if (OpMode == MD_TEST)
	{
		if (isatty(sm_io_getinfo(smioin, SM_IO_WHAT_FD, NULL)))
			Verbose = 2;

		if (Verbose)
		{
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "ADDRESS TEST MODE (ruleset 3 NOT automatically invoked)\n");
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "Enter <ruleset> <address>\n");
		}
		macdefine(&(MainEnvelope.e_macro), A_PERM,
			  macid("{addr_type}"), "e r");
		for (;;)
		{
			SM_TRY
			{
				(void) sm_signal(SIGINT, intindebug);
				(void) sm_releasesignal(SIGINT);
				if (Verbose == 2)
					(void) sm_io_fprintf(smioout,
							     SM_TIME_DEFAULT,
							     "> ");
				(void) sm_io_flush(smioout, SM_TIME_DEFAULT);
				if (sm_io_fgets(smioin, SM_TIME_DEFAULT, buf,
						sizeof(buf)) == NULL)
					testmodeline("/quit", &MainEnvelope);
				p = strchr(buf, '\n');
				if (p != NULL)
					*p = '\0';
				if (Verbose < 2)
					(void) sm_io_fprintf(smioout,
							     SM_TIME_DEFAULT,
							     "> %s\n", buf);
				testmodeline(buf, &MainEnvelope);
			}
			SM_EXCEPT(exc, "[!F]*")
			{
				/*
				**  8.10 just prints \n on interrupt.
				**  I'm printing the exception here in case
				**  sendmail is extended to raise additional
				**  exceptions in this context.
				*/

				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "\n");
				sm_exc_print(exc, smioout);
			}
			SM_END_TRY
		}
	}

#if STARTTLS
	tls_ok = true;
	if (OpMode == MD_QUEUERUN || OpMode == MD_DELIVER ||
	    OpMode == MD_ARPAFTP)
	{
		/* check whether STARTTLS is turned off for the client */
		if (chkclientmodifiers(D_NOTLS))
			tls_ok = false;
	}
	else if (OpMode == MD_DAEMON || OpMode == MD_FGDAEMON ||
		 OpMode == MD_SMTP)
	{
		/* check whether STARTTLS is turned off */
		if (chkdaemonmodifiers(D_NOTLS) && chkclientmodifiers(D_NOTLS))
			tls_ok = false;
	}
	else	/* other modes don't need STARTTLS */
		tls_ok = false;

	if (tls_ok)
	{
		/* basic TLS initialization */
		tls_ok = init_tls_library();
	}

	if (!tls_ok && (OpMode == MD_QUEUERUN || OpMode == MD_DELIVER))
	{
		/* disable TLS for client */
		setclttls(false);
	}
#endif /* STARTTLS */

	/*
	**  If collecting stuff from the queue, go start doing that.
	*/

	if (OpMode == MD_QUEUERUN && QueueIntvl == 0)
	{
		pid_t pid = -1;

#if STARTTLS
		/* init TLS for client, ignore result for now */
		(void) initclttls(tls_ok);
#endif /* STARTTLS */

		/*
		**  The parent process of the caller of runqueue() needs
		**  to stay around for a possible SIGTERM. The SIGTERM will
		**  tell this process that all of the queue runners children
		**  need to be sent SIGTERM as well. At the same time, we
		**  want to return control to the command line. So we do an
		**  extra fork().
		*/

		if (Verbose || foregroundqueue || (pid = fork()) <= 0)
		{
			/*
			**  If the fork() failed we should still try to do
			**  the queue run. If it succeeded then the child
			**  is going to start the run and wait for all
			**  of the children to finish.
			*/

			if (pid == 0)
			{
				/* Reset global flags */
				RestartRequest = NULL;
				ShutdownRequest = NULL;
				PendingSignal = 0;

				/* disconnect from terminal */
				disconnect(2, CurEnv);
			}

			CurrentPid = getpid();
			if (qgrp != NOQGRP)
			{
				int rwgflags = RWG_NONE;

				/*
				**  To run a specific queue group mark it to
				**  be run, select the work group it's in and
				**  increment the work counter.
				*/

				for (i = 0; i < NumQueue && Queue[i] != NULL;
				     i++)
					Queue[i]->qg_nextrun = (time_t) -1;
				Queue[qgrp]->qg_nextrun = 0;
				if (Verbose)
					rwgflags |= RWG_VERBOSE;
				if (queuepersistent)
					rwgflags |= RWG_PERSISTENT;
				rwgflags |= RWG_FORCE;
				(void) run_work_group(Queue[qgrp]->qg_wgrp,
						      rwgflags);
			}
			else
				(void) runqueue(false, Verbose,
						queuepersistent, true);

			/* set the title to make it easier to find */
			sm_setproctitle(true, CurEnv, "Queue control");
			(void) sm_signal(SIGCHLD, SIG_DFL);
			while (CurChildren > 0)
			{
				int status;
				pid_t ret;

				errno = 0;
				while ((ret = sm_wait(&status)) <= 0)
				{
					if (errno == ECHILD)
					{
						/*
						**  Oops... something got messed
						**  up really bad. Waiting for
						**  non-existent children
						**  shouldn't happen. Let's get
						**  out of here.
						*/

						CurChildren = 0;
						break;
					}
					continue;
				}

				/* something is really really wrong */
				if (errno == ECHILD)
				{
					sm_syslog(LOG_ERR, NOQID,
						  "queue control process: lost all children: wait returned ECHILD");
					break;
				}

				/* Only drop when a child gives status */
				if (WIFSTOPPED(status))
					continue;

				proc_list_drop(ret, status, NULL);
			}
		}
		finis(true, true, ExitStat);
		/* NOTREACHED */
	}

# if SASL
	if (OpMode == MD_SMTP || OpMode == MD_DAEMON)
	{
		/* check whether AUTH is turned off for the server */
		if (!chkdaemonmodifiers(D_NOAUTH) &&
		    (i = sasl_server_init(srvcallbacks, "Sendmail")) != SASL_OK)
			syserr("!sasl_server_init failed! [%s]",
				sasl_errstring(i, NULL, NULL));
	}
# endif /* SASL */

	if (OpMode == MD_SMTP)
	{
		proc_list_add(CurrentPid, "Sendmail SMTP Agent",
			      PROC_DAEMON, 0, -1, NULL);

		/* clean up background delivery children */
		(void) sm_signal(SIGCHLD, reapchild);
	}

	/*
	**  If a daemon, wait for a request.
	**	getrequests will always return in a child.
	**	If we should also be processing the queue, start
	**		doing it in background.
	**	We check for any errors that might have happened
	**		during startup.
	*/

	if (OpMode == MD_DAEMON || QueueIntvl > 0)
	{
		char dtype[200];

		/* avoid cleanup in finis(), DaemonPid will be set below */
		DaemonPid = 0;
		if (!run_in_foreground && !tTd(99, 100))
		{
			/* put us in background */
			i = fork();
			if (i < 0)
				syserr("daemon: cannot fork");
			if (i != 0)
			{
				finis(false, true, EX_OK);
				/* NOTREACHED */
			}

			/*
			**  Initialize exception stack and default exception
			**  handler for child process.
			*/

			/* Reset global flags */
			RestartRequest = NULL;
			RestartWorkGroup = false;
			ShutdownRequest = NULL;
			PendingSignal = 0;
			CurrentPid = getpid();

			sm_exc_newthread(fatal_error);

			/* disconnect from our controlling tty */
			disconnect(2, &MainEnvelope);
		}

		dtype[0] = '\0';
		if (OpMode == MD_DAEMON)
		{
			(void) sm_strlcat(dtype, "+SMTP", sizeof(dtype));
			DaemonPid = CurrentPid;
		}
		if (QueueIntvl > 0)
		{
			(void) sm_strlcat2(dtype,
					   queuepersistent
					   ? "+persistent-queueing@"
					   : "+queueing@",
					   pintvl(QueueIntvl, true),
					   sizeof(dtype));
		}
		if (tTd(0, 1))
			(void) sm_strlcat(dtype, "+debugging", sizeof(dtype));

		sm_syslog(LOG_INFO, NOQID,
			  "starting daemon (%s): %s", Version, dtype + 1);
#if XLA
		xla_create_file();
#endif /* XLA */

		/* save daemon type in a macro for possible PidFile use */
		macdefine(&BlankEnvelope.e_macro, A_TEMP,
			macid("{daemon_info}"), dtype + 1);

		/* save queue interval in a macro for possible PidFile use */
		macdefine(&MainEnvelope.e_macro, A_TEMP,
			macid("{queue_interval}"), pintvl(QueueIntvl, true));

		/* workaround: can't seem to release the signal in the parent */
		(void) sm_signal(SIGHUP, sighup);
		(void) sm_releasesignal(SIGHUP);
		(void) sm_signal(SIGTERM, sigterm);

		if (QueueIntvl > 0)
		{
#if _FFR_RUNPQG
			if (qgrp != NOQGRP)
			{
				int rwgflags = RWG_NONE;

				/*
				**  To run a specific queue group mark it to
				**  be run, select the work group it's in and
				**  increment the work counter.
				*/

				for (i = 0; i < NumQueue && Queue[i] != NULL;
				     i++)
					Queue[i]->qg_nextrun = (time_t) -1;
				Queue[qgrp]->qg_nextrun = 0;
				if (Verbose)
					rwgflags |= RWG_VERBOSE;
				if (queuepersistent)
					rwgflags |= RWG_PERSISTENT;
				rwgflags |= RWG_FORCE;
				(void) run_work_group(Queue[qgrp]->qg_wgrp,
						      rwgflags);
			}
			else
#endif /* _FFR_RUNPQG */
				(void) runqueue(true, false, queuepersistent,
						true);

			/*
			**  If queuepersistent but not in daemon mode then
			**  we're going to do the queue runner monitoring here.
			**  If in daemon mode then the monitoring will happen
			**  elsewhere.
			*/

			if (OpMode != MD_DAEMON && queuepersistent)
			{
				/*
				**  Write the pid to file
				**  XXX Overwrites sendmail.pid
				*/

				log_sendmail_pid(&MainEnvelope);

				/* set the title to make it easier to find */
				sm_setproctitle(true, CurEnv, "Queue control");
				(void) sm_signal(SIGCHLD, SIG_DFL);
				while (CurChildren > 0)
				{
					int status;
					pid_t ret;
					int group;

					CHECK_RESTART;
					errno = 0;
					while ((ret = sm_wait(&status)) <= 0)
					{
						/*
						**  Waiting for non-existent
						**  children shouldn't happen.
						**  Let's get out of here if
						**  it occurs.
						*/

						if (errno == ECHILD)
						{
							CurChildren = 0;
							break;
						}
						continue;
					}

					/* something is really really wrong */
					if (errno == ECHILD)
					{
						sm_syslog(LOG_ERR, NOQID,
							  "persistent queue runner control process: lost all children: wait returned ECHILD");
						break;
					}

					if (WIFSTOPPED(status))
						continue;

					/* Probe only on a child status */
					proc_list_drop(ret, status, &group);

					if (WIFSIGNALED(status))
					{
						if (WCOREDUMP(status))
						{
							sm_syslog(LOG_ERR, NOQID,
								  "persistent queue runner=%d core dumped, signal=%d",
								  group, WTERMSIG(status));

							/* don't restart this */
							mark_work_group_restart(
								group, -1);
							continue;
						}

						sm_syslog(LOG_ERR, NOQID,
							  "persistent queue runner=%d died, pid=%ld, signal=%d",
							  group, (long) ret,
							  WTERMSIG(status));
					}

					/*
					**  When debugging active, don't
					**  restart the persistent queues.
					**  But do log this as info.
					*/

					if (sm_debug_active(&DebugNoPRestart,
							    1))
					{
						sm_syslog(LOG_DEBUG, NOQID,
							  "persistent queue runner=%d, exited",
							  group);
						mark_work_group_restart(group,
									-1);
					}
					CHECK_RESTART;
				}
				finis(true, true, ExitStat);
				/* NOTREACHED */
			}

			if (OpMode != MD_DAEMON)
			{
				char qtype[200];

				/*
				**  Write the pid to file
				**  XXX Overwrites sendmail.pid
				*/

				log_sendmail_pid(&MainEnvelope);

				/* set the title to make it easier to find */
				qtype[0] = '\0';
				(void) sm_strlcpyn(qtype, sizeof(qtype), 4,
						   "Queue runner@",
						   pintvl(QueueIntvl, true),
						   " for ",
						   QueueDir);
				sm_setproctitle(true, CurEnv, qtype);
				for (;;)
				{
					(void) pause();

					CHECK_RESTART;

					if (doqueuerun())
						(void) runqueue(true, false,
								false, false);
				}
			}
		}
		(void) dropenvelope(&MainEnvelope, true, false);

#if STARTTLS
		/* init TLS for server, ignore result for now */
		(void) initsrvtls(tls_ok);
#endif /* STARTTLS */

	nextreq:
		p_flags = getrequests(&MainEnvelope);

		/* drop privileges */
		(void) drop_privileges(false);

		/*
		**  Get authentication data
		**  Set _ macro in BlankEnvelope before calling newenvelope().
		*/

		authinfo = getauthinfo(sm_io_getinfo(InChannel, SM_IO_WHAT_FD,
						     NULL), &forged);
		macdefine(&BlankEnvelope.e_macro, A_TEMP, '_', authinfo);

		/* at this point we are in a child: reset state */
		sm_rpool_free(MainEnvelope.e_rpool);
		(void) newenvelope(&MainEnvelope, &MainEnvelope,
				   sm_rpool_new_x(NULL));
	}

	if (LogLevel > 9)
	{
		/* log connection information */
		sm_syslog(LOG_INFO, NULL, "connect from %s", authinfo);
	}

	/*
	**  If running SMTP protocol, start collecting and executing
	**  commands.  This will never return.
	*/

	if (OpMode == MD_SMTP || OpMode == MD_DAEMON)
	{
		char pbuf[20];

		/*
		**  Save some macros for check_* rulesets.
		*/

		if (forged)
		{
			char ipbuf[103];

			(void) sm_snprintf(ipbuf, sizeof(ipbuf), "[%.100s]",
					   anynet_ntoa(&RealHostAddr));
			macdefine(&BlankEnvelope.e_macro, A_TEMP,
				  macid("{client_name}"), ipbuf);
		}
		else
			macdefine(&BlankEnvelope.e_macro, A_PERM,
				  macid("{client_name}"), RealHostName);
		macdefine(&BlankEnvelope.e_macro, A_PERM,
			  macid("{client_ptr}"), RealHostName);
		macdefine(&BlankEnvelope.e_macro, A_TEMP,
			  macid("{client_addr}"), anynet_ntoa(&RealHostAddr));
		sm_getla();

		switch (RealHostAddr.sa.sa_family)
		{
#if NETINET
		  case AF_INET:
			(void) sm_snprintf(pbuf, sizeof(pbuf), "%d",
					   RealHostAddr.sin.sin_port);
			break;
#endif /* NETINET */
#if NETINET6
		  case AF_INET6:
			(void) sm_snprintf(pbuf, sizeof(pbuf), "%d",
					   RealHostAddr.sin6.sin6_port);
			break;
#endif /* NETINET6 */
		  default:
			(void) sm_snprintf(pbuf, sizeof(pbuf), "0");
			break;
		}
		macdefine(&BlankEnvelope.e_macro, A_TEMP,
			macid("{client_port}"), pbuf);

		if (OpMode == MD_DAEMON)
		{
			ENVELOPE *saved_env;

			/* validate the connection */
			HoldErrs = true;
			saved_env = CurEnv;
			CurEnv = &BlankEnvelope;
			nullserver = validate_connection(&RealHostAddr,
						macvalue(macid("{client_name}"),
							&BlankEnvelope),
						&BlankEnvelope);
			if (bitset(EF_DISCARD, BlankEnvelope.e_flags))
				MainEnvelope.e_flags |= EF_DISCARD;
			CurEnv = saved_env;
			HoldErrs = false;
		}
		else if (p_flags == NULL)
		{
			p_flags = (BITMAP256 *) xalloc(sizeof(*p_flags));
			clrbitmap(p_flags);
		}
#if STARTTLS
		if (OpMode == MD_SMTP)
			(void) initsrvtls(tls_ok);
#endif /* STARTTLS */

		/* turn off profiling */
		SM_PROF(1);
		smtp(nullserver, *p_flags, &MainEnvelope);

		if (tTd(93, 100))
		{
			/* turn off profiling */
			SM_PROF(0);
			if (OpMode == MD_DAEMON)
				goto nextreq;
		}
	}

	sm_rpool_free(MainEnvelope.e_rpool);
	clearenvelope(&MainEnvelope, false, sm_rpool_new_x(NULL));
	if (OpMode == MD_VERIFY)
	{
		set_delivery_mode(SM_VERIFY, &MainEnvelope);
		PostMasterCopy = NULL;
	}
	else
	{
		/* interactive -- all errors are global */
		MainEnvelope.e_flags |= EF_GLOBALERRS|EF_LOGSENDER;
	}

	/*
	**  Do basic system initialization and set the sender
	*/

	initsys(&MainEnvelope);
	macdefine(&MainEnvelope.e_macro, A_PERM, macid("{ntries}"), "0");
	macdefine(&MainEnvelope.e_macro, A_PERM, macid("{nrcpts}"), "0");
	setsender(from, &MainEnvelope, NULL, '\0', false);
	if (warn_f_flag != '\0' && !wordinclass(RealUserName, 't') &&
	    (!bitnset(M_LOCALMAILER, MainEnvelope.e_from.q_mailer->m_flags) ||
	     strcmp(MainEnvelope.e_from.q_user, RealUserName) != 0))
	{
		auth_warning(&MainEnvelope, "%s set sender to %s using -%c",
			     RealUserName, from, warn_f_flag);
#if SASL
		auth = false;
#endif /* SASL */
	}
	if (auth)
	{
		char *fv;

		/* set the initial sender for AUTH= to $f@$j */
		fv = macvalue('f', &MainEnvelope);
		if (fv == NULL || *fv == '\0')
			MainEnvelope.e_auth_param = NULL;
		else
		{
			if (strchr(fv, '@') == NULL)
			{
				i = strlen(fv) + strlen(macvalue('j',
							&MainEnvelope)) + 2;
				p = sm_malloc_x(i);
				(void) sm_strlcpyn(p, i, 3, fv, "@",
						   macvalue('j',
							    &MainEnvelope));
			}
			else
				p = sm_strdup_x(fv);
			MainEnvelope.e_auth_param = sm_rpool_strdup_x(MainEnvelope.e_rpool,
								      xtextify(p, "="));
			sm_free(p);  /* XXX */
		}
	}
	if (macvalue('s', &MainEnvelope) == NULL)
		macdefine(&MainEnvelope.e_macro, A_PERM, 's', RealHostName);

	av = argv + optind;
	if (*av == NULL && !GrabTo)
	{
		MainEnvelope.e_to = NULL;
		MainEnvelope.e_flags |= EF_GLOBALERRS;
		HoldErrs = false;
		SuperSafe = SAFE_NO;
		usrerr("Recipient names must be specified");

		/* collect body for UUCP return */
		if (OpMode != MD_VERIFY)
			collect(InChannel, false, NULL, &MainEnvelope, true);
		finis(true, true, EX_USAGE);
		/* NOTREACHED */
	}

	/*
	**  Scan argv and deliver the message to everyone.
	*/

	save_val = LogUsrErrs;
	LogUsrErrs = true;
	sendtoargv(av, &MainEnvelope);
	LogUsrErrs = save_val;

	/* if we have had errors sofar, arrange a meaningful exit stat */
	if (Errors > 0 && ExitStat == EX_OK)
		ExitStat = EX_USAGE;

#if _FFR_FIX_DASHT
	/*
	**  If using -t, force not sending to argv recipients, even
	**  if they are mentioned in the headers.
	*/

	if (GrabTo)
	{
		ADDRESS *q;

		for (q = MainEnvelope.e_sendqueue; q != NULL; q = q->q_next)
			q->q_state = QS_REMOVED;
	}
#endif /* _FFR_FIX_DASHT */

	/*
	**  Read the input mail.
	*/

	MainEnvelope.e_to = NULL;
	if (OpMode != MD_VERIFY || GrabTo)
	{
		int savederrors;
		unsigned long savedflags;

		/*
		**  workaround for compiler warning on Irix:
		**  do not initialize variable in the definition, but
		**  later on:
		**  warning(1548): transfer of control bypasses
		**  initialization of:
		**  variable "savederrors" (declared at line 2570)
		**  variable "savedflags" (declared at line 2571)
		**  goto giveup;
		*/

		savederrors = Errors;
		savedflags = MainEnvelope.e_flags & EF_FATALERRS;
		MainEnvelope.e_flags |= EF_GLOBALERRS;
		MainEnvelope.e_flags &= ~EF_FATALERRS;
		Errors = 0;
		buffer_errors();
		collect(InChannel, false, NULL, &MainEnvelope, true);

		/* header checks failed */
		if (Errors > 0)
		{
  giveup:
			if (!GrabTo)
			{
				/* Log who the mail would have gone to */
				logundelrcpts(&MainEnvelope,
					      MainEnvelope.e_message,
					      8, false);
			}
			flush_errors(true);
			finis(true, true, ExitStat);
			/* NOTREACHED */
			return -1;
		}

		/* bail out if message too large */
		if (bitset(EF_CLRQUEUE, MainEnvelope.e_flags))
		{
			finis(true, true, ExitStat != EX_OK ? ExitStat
							    : EX_DATAERR);
			/* NOTREACHED */
			return -1;
		}

		/* set message size */
		(void) sm_snprintf(buf, sizeof(buf), "%ld",
				   MainEnvelope.e_msgsize);
		macdefine(&MainEnvelope.e_macro, A_TEMP,
			  macid("{msg_size}"), buf);

		Errors = savederrors;
		MainEnvelope.e_flags |= savedflags;
	}
	errno = 0;

	if (tTd(1, 1))
		sm_dprintf("From person = \"%s\"\n",
			   MainEnvelope.e_from.q_paddr);

	/* Check if quarantining stats should be updated */
	if (MainEnvelope.e_quarmsg != NULL)
		markstats(&MainEnvelope, NULL, STATS_QUARANTINE);

	/*
	**  Actually send everything.
	**	If verifying, just ack.
	*/

	if (Errors == 0)
	{
		if (!split_by_recipient(&MainEnvelope) &&
		    bitset(EF_FATALERRS, MainEnvelope.e_flags))
			goto giveup;
	}

	/* make sure we deliver at least the first envelope */
	i = FastSplit > 0 ? 0 : -1;
	for (e = &MainEnvelope; e != NULL; e = e->e_sibling, i++)
	{
		ENVELOPE *next;

		e->e_from.q_state = QS_SENDER;
		if (tTd(1, 5))
		{
			sm_dprintf("main[%d]: QS_SENDER ", i);
			printaddr(sm_debug_file(), &e->e_from, false);
		}
		e->e_to = NULL;
		sm_getla();
		GrabTo = false;
#if NAMED_BIND
		_res.retry = TimeOuts.res_retry[RES_TO_FIRST];
		_res.retrans = TimeOuts.res_retrans[RES_TO_FIRST];
#endif /* NAMED_BIND */
		next = e->e_sibling;
		e->e_sibling = NULL;

		/* after FastSplit envelopes: queue up */
		sendall(e, i >= FastSplit ? SM_QUEUE : SM_DEFAULT);
		e->e_sibling = next;
	}

	/*
	**  All done.
	**	Don't send return error message if in VERIFY mode.
	*/

	finis(true, true, ExitStat);
	/* NOTREACHED */
	return ExitStat;
}
/*
**  STOP_SENDMAIL -- Stop the running program
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		exits.
*/

void
stop_sendmail()
{
	/* reset uid for process accounting */
	endpwent();
	(void) setuid(RealUid);
	exit(EX_OK);
}
/*
**  FINIS -- Clean up and exit.
**
**	Parameters:
**		drop -- whether or not to drop CurEnv envelope
**		cleanup -- call exit() or _exit()?
**		exitstat -- exit status to use for exit() call
**
**	Returns:
**		never
**
**	Side Effects:
**		exits sendmail
*/

void
finis(drop, cleanup, exitstat)
	bool drop;
	bool cleanup;
	volatile int exitstat;
{
	char pidpath[MAXPATHLEN];
	pid_t pid;

	/* Still want to process new timeouts added below */
	sm_clear_events();
	(void) sm_releasesignal(SIGALRM);

	if (tTd(2, 1))
	{
		sm_dprintf("\n====finis: stat %d e_id=%s e_flags=",
			   exitstat,
			   CurEnv->e_id == NULL ? "NOQUEUE" : CurEnv->e_id);
		printenvflags(CurEnv);
	}
	if (tTd(2, 9))
		printopenfds(false);

	SM_TRY
		/*
		**  Clean up.  This might raise E:mta.quickabort
		*/

		/* clean up temp files */
		CurEnv->e_to = NULL;
		if (drop)
		{
			if (CurEnv->e_id != NULL)
			{
				int r;

				r = dropenvelope(CurEnv, true, false);
				if (exitstat == EX_OK)
					exitstat = r;
				sm_rpool_free(CurEnv->e_rpool);
				CurEnv->e_rpool = NULL;

				/* these may have pointed to the rpool */
				CurEnv->e_to = NULL;
				CurEnv->e_message = NULL;
				CurEnv->e_statmsg = NULL;
				CurEnv->e_quarmsg = NULL;
				CurEnv->e_bodytype = NULL;
				CurEnv->e_id = NULL;
				CurEnv->e_envid = NULL;
				CurEnv->e_auth_param = NULL;
			}
			else
				poststats(StatFile);
		}

		/* flush any cached connections */
		mci_flush(true, NULL);

		/* close maps belonging to this pid */
		closemaps(false);

#if USERDB
		/* close UserDatabase */
		_udbx_close();
#endif /* USERDB */

#if SASL
		stop_sasl_client();
#endif /* SASL */

#if XLA
		/* clean up extended load average stuff */
		xla_all_end();
#endif /* XLA */

	SM_FINALLY
		/*
		**  And exit.
		*/

		if (LogLevel > 78)
			sm_syslog(LOG_DEBUG, CurEnv->e_id, "finis, pid=%d",
				  (int) CurrentPid);
		if (exitstat == EX_TEMPFAIL ||
		    CurEnv->e_errormode == EM_BERKNET)
			exitstat = EX_OK;

		/* XXX clean up queues and related data structures */
		cleanup_queues();
		pid = getpid();
#if SM_CONF_SHM
		cleanup_shm(DaemonPid == pid);
#endif /* SM_CONF_SHM */

		/* close locked pid file */
		close_sendmail_pid();

		if (DaemonPid == pid || PidFilePid == pid)
		{
			/* blow away the pid file */
			expand(PidFile, pidpath, sizeof(pidpath), CurEnv);
			(void) unlink(pidpath);
		}

		/* reset uid for process accounting */
		endpwent();
		sm_mbdb_terminate();
#if _FFR_MEMSTAT
		(void) sm_memstat_close();
#endif /* _FFR_MEMSTAT */
		(void) setuid(RealUid);
#if SM_HEAP_CHECK
		/* dump the heap, if we are checking for memory leaks */
		if (sm_debug_active(&SmHeapCheck, 2))
			sm_heap_report(smioout,
				       sm_debug_level(&SmHeapCheck) - 1);
#endif /* SM_HEAP_CHECK */
		if (sm_debug_active(&SmXtrapReport, 1))
			sm_dprintf("xtrap count = %d\n", SmXtrapCount);
		if (cleanup)
			exit(exitstat);
		else
			_exit(exitstat);
	SM_END_TRY
}
/*
**  INTINDEBUG -- signal handler for SIGINT in -bt mode
**
**	Parameters:
**		sig -- incoming signal.
**
**	Returns:
**		none.
**
**	Side Effects:
**		longjmps back to test mode loop.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
*/

/* Type of an exception generated on SIGINT during address test mode.  */
static const SM_EXC_TYPE_T EtypeInterrupt =
{
	SmExcTypeMagic,
	"S:mta.interrupt",
	"",
	sm_etype_printf,
	"interrupt",
};

/* ARGSUSED */
static SIGFUNC_DECL
intindebug(sig)
	int sig;
{
	int save_errno = errno;

	FIX_SYSV_SIGNAL(sig, intindebug);
	errno = save_errno;
	CHECK_CRITICAL(sig);
	errno = save_errno;
	sm_exc_raisenew_x(&EtypeInterrupt);
	errno = save_errno;
	return SIGFUNC_RETURN;
}
/*
**  SIGTERM -- SIGTERM handler for the daemon
**
**	Parameters:
**		sig -- signal number.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Sets ShutdownRequest which will hopefully trigger
**		the daemon to exit.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
*/

/* ARGSUSED */
static SIGFUNC_DECL
sigterm(sig)
	int sig;
{
	int save_errno = errno;

	FIX_SYSV_SIGNAL(sig, sigterm);
	ShutdownRequest = "signal";
	errno = save_errno;
	return SIGFUNC_RETURN;
}
/*
**  SIGHUP -- handle a SIGHUP signal
**
**	Parameters:
**		sig -- incoming signal.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Sets RestartRequest which should cause the daemon
**		to restart.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
*/

/* ARGSUSED */
static SIGFUNC_DECL
sighup(sig)
	int sig;
{
	int save_errno = errno;

	FIX_SYSV_SIGNAL(sig, sighup);
	RestartRequest = "signal";
	errno = save_errno;
	return SIGFUNC_RETURN;
}
/*
**  SIGPIPE -- signal handler for SIGPIPE
**
**	Parameters:
**		sig -- incoming signal.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Sets StopRequest which should cause the mailq/hoststatus
**		display to stop.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
*/

/* ARGSUSED */
static SIGFUNC_DECL
sigpipe(sig)
	int sig;
{
	int save_errno = errno;

	FIX_SYSV_SIGNAL(sig, sigpipe);
	StopRequest = true;
	errno = save_errno;
	return SIGFUNC_RETURN;
}
/*
**  INTSIG -- clean up on interrupt
**
**	This just arranges to exit.  It pessimizes in that it
**	may resend a message.
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Unlocks the current job.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
**
**		XXX: More work is needed for this signal handler.
*/

/* ARGSUSED */
SIGFUNC_DECL
intsig(sig)
	int sig;
{
	bool drop = false;
	int save_errno = errno;

	FIX_SYSV_SIGNAL(sig, intsig);
	errno = save_errno;
	CHECK_CRITICAL(sig);
	sm_allsignals(true);

	if (sig != 0 && LogLevel > 79)
		sm_syslog(LOG_DEBUG, CurEnv->e_id, "interrupt");
	FileName = NULL;

	/* Clean-up on aborted stdin message submission */
	if (CurEnv->e_id != NULL &&
	    (OpMode == MD_SMTP ||
	     OpMode == MD_DELIVER ||
	     OpMode == MD_ARPAFTP))
	{
		register ADDRESS *q;

		/* don't return an error indication */
		CurEnv->e_to = NULL;
		CurEnv->e_flags &= ~EF_FATALERRS;
		CurEnv->e_flags |= EF_CLRQUEUE;

		/*
		**  Spin through the addresses and
		**  mark them dead to prevent bounces
		*/

		for (q = CurEnv->e_sendqueue; q != NULL; q = q->q_next)
			q->q_state = QS_DONTSEND;

		drop = true;
	}
	else if (OpMode != MD_TEST)
	{
		unlockqueue(CurEnv);
	}

	finis(drop, false, EX_OK);
	/* NOTREACHED */
}
/*
**  DISCONNECT -- remove our connection with any foreground process
**
**	Parameters:
**		droplev -- how "deeply" we should drop the line.
**			0 -- ignore signals, mail back errors, make sure
**			     output goes to stdout.
**			1 -- also, make stdout go to /dev/null.
**			2 -- also, disconnect from controlling terminal
**			     (only for daemon mode).
**		e -- the current envelope.
**
**	Returns:
**		none
**
**	Side Effects:
**		Trys to insure that we are immune to vagaries of
**		the controlling tty.
*/

void
disconnect(droplev, e)
	int droplev;
	register ENVELOPE *e;
{
	int fd;

	if (tTd(52, 1))
		sm_dprintf("disconnect: In %d Out %d, e=%p\n",
			   sm_io_getinfo(InChannel, SM_IO_WHAT_FD, NULL),
			   sm_io_getinfo(OutChannel, SM_IO_WHAT_FD, NULL), e);
	if (tTd(52, 100))
	{
		sm_dprintf("don't\n");
		return;
	}
	if (LogLevel > 93)
		sm_syslog(LOG_DEBUG, e->e_id,
			  "disconnect level %d",
			  droplev);

	/* be sure we don't get nasty signals */
	(void) sm_signal(SIGINT, SIG_IGN);
	(void) sm_signal(SIGQUIT, SIG_IGN);

	/* we can't communicate with our caller, so.... */
	HoldErrs = true;
	CurEnv->e_errormode = EM_MAIL;
	Verbose = 0;
	DisConnected = true;

	/* all input from /dev/null */
	if (InChannel != smioin)
	{
		(void) sm_io_close(InChannel, SM_TIME_DEFAULT);
		InChannel = smioin;
	}
	if (sm_io_reopen(SmFtStdio, SM_TIME_DEFAULT, SM_PATH_DEVNULL,
			 SM_IO_RDONLY, NULL, smioin) == NULL)
		sm_syslog(LOG_ERR, e->e_id,
			  "disconnect: sm_io_reopen(\"%s\") failed: %s",
			  SM_PATH_DEVNULL, sm_errstring(errno));

	/*
	**  output to the transcript
	**	We also compare the fd numbers here since OutChannel
	**	might be a layer on top of smioout due to encryption
	**	(see sfsasl.c).
	*/

	if (OutChannel != smioout &&
	    sm_io_getinfo(OutChannel, SM_IO_WHAT_FD, NULL) !=
	    sm_io_getinfo(smioout, SM_IO_WHAT_FD, NULL))
	{
		(void) sm_io_close(OutChannel, SM_TIME_DEFAULT);
		OutChannel = smioout;

#if 0
		/*
		**  Has smioout been closed? Reopen it.
		**	This shouldn't happen anymore, the code is here
		**	just as a reminder.
		*/

		if (smioout->sm_magic == NULL &&
		    sm_io_reopen(SmFtStdio, SM_TIME_DEFAULT, SM_PATH_DEVNULL,
				 SM_IO_WRONLY, NULL, smioout) == NULL)
			sm_syslog(LOG_ERR, e->e_id,
				  "disconnect: sm_io_reopen(\"%s\") failed: %s",
				  SM_PATH_DEVNULL, sm_errstring(errno));
#endif /* 0 */
	}
	if (droplev > 0)
	{
		fd = open(SM_PATH_DEVNULL, O_WRONLY, 0666);
		if (fd == -1)
		{
			sm_syslog(LOG_ERR, e->e_id,
				  "disconnect: open(\"%s\") failed: %s",
				  SM_PATH_DEVNULL, sm_errstring(errno));
		}
		(void) sm_io_flush(smioout, SM_TIME_DEFAULT);
		if (fd >= 0)
		{
			(void) dup2(fd, STDOUT_FILENO);
			(void) dup2(fd, STDERR_FILENO);
			(void) close(fd);
		}
	}

	/* drop our controlling TTY completely if possible */
	if (droplev > 1)
	{
		(void) setsid();
		errno = 0;
	}

#if XDEBUG
	checkfd012("disconnect");
#endif /* XDEBUG */

	if (LogLevel > 71)
		sm_syslog(LOG_DEBUG, e->e_id, "in background, pid=%d",
			  (int) CurrentPid);

	errno = 0;
}

static void
obsolete(argv)
	char *argv[];
{
	register char *ap;
	register char *op;

	while ((ap = *++argv) != NULL)
	{
		/* Return if "--" or not an option of any form. */
		if (ap[0] != '-' || ap[1] == '-')
			return;

		/* Don't allow users to use "-Q." or "-Q ." */
		if ((ap[1] == 'Q' && ap[2] == '.') ||
		    (ap[1] == 'Q' && argv[1] != NULL &&
		     argv[1][0] == '.' && argv[1][1] == '\0'))
		{
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Can not use -Q.\n");
			exit(EX_USAGE);
		}

		/* skip over options that do have a value */
		op = strchr(OPTIONS, ap[1]);
		if (op != NULL && *++op == ':' && ap[2] == '\0' &&
		    ap[1] != 'd' &&
#if defined(sony_news)
		    ap[1] != 'E' && ap[1] != 'J' &&
#endif /* defined(sony_news) */
		    argv[1] != NULL && argv[1][0] != '-')
		{
			argv++;
			continue;
		}

		/* If -C doesn't have an argument, use sendmail.cf. */
#define __DEFPATH	"sendmail.cf"
		if (ap[1] == 'C' && ap[2] == '\0')
		{
			*argv = xalloc(sizeof(__DEFPATH) + 2);
			(void) sm_strlcpyn(argv[0], sizeof(__DEFPATH) + 2, 2,
					   "-C", __DEFPATH);
		}

		/* If -q doesn't have an argument, run it once. */
		if (ap[1] == 'q' && ap[2] == '\0')
			*argv = "-q0";

		/* If -Q doesn't have an argument, disable quarantining */
		if (ap[1] == 'Q' && ap[2] == '\0')
			*argv = "-Q.";

		/* if -d doesn't have an argument, use 0-99.1 */
		if (ap[1] == 'd' && ap[2] == '\0')
			*argv = "-d0-99.1";

#if defined(sony_news)
		/* if -E doesn't have an argument, use -EC */
		if (ap[1] == 'E' && ap[2] == '\0')
			*argv = "-EC";

		/* if -J doesn't have an argument, use -JJ */
		if (ap[1] == 'J' && ap[2] == '\0')
			*argv = "-JJ";
#endif /* defined(sony_news) */
	}
}
/*
**  AUTH_WARNING -- specify authorization warning
**
**	Parameters:
**		e -- the current envelope.
**		msg -- the text of the message.
**		args -- arguments to the message.
**
**	Returns:
**		none.
*/

void
#ifdef __STDC__
auth_warning(register ENVELOPE *e, const char *msg, ...)
#else /* __STDC__ */
auth_warning(e, msg, va_alist)
	register ENVELOPE *e;
	const char *msg;
	va_dcl
#endif /* __STDC__ */
{
	char buf[MAXLINE];
	SM_VA_LOCAL_DECL

	if (bitset(PRIV_AUTHWARNINGS, PrivacyFlags))
	{
		register char *p;
		static char hostbuf[48];

		if (hostbuf[0] == '\0')
		{
			struct hostent *hp;

			hp = myhostname(hostbuf, sizeof(hostbuf));
#if NETINET6
			if (hp != NULL)
			{
				freehostent(hp);
				hp = NULL;
			}
#endif /* NETINET6 */
		}

		(void) sm_strlcpyn(buf, sizeof(buf), 2, hostbuf, ": ");
		p = &buf[strlen(buf)];
		SM_VA_START(ap, msg);
		(void) sm_vsnprintf(p, SPACELEFT(buf, p), msg, ap);
		SM_VA_END(ap);
		addheader("X-Authentication-Warning", buf, 0, e, true);
		if (LogLevel > 3)
			sm_syslog(LOG_INFO, e->e_id,
				  "Authentication-Warning: %.400s",
				  buf);
	}
}
/*
**  GETEXTENV -- get from external environment
**
**	Parameters:
**		envar -- the name of the variable to retrieve
**
**	Returns:
**		The value, if any.
*/

static char *
getextenv(envar)
	const char *envar;
{
	char **envp;
	int l;

	l = strlen(envar);
	for (envp = ExternalEnviron; envp != NULL && *envp != NULL; envp++)
	{
		if (strncmp(*envp, envar, l) == 0 && (*envp)[l] == '=')
			return &(*envp)[l + 1];
	}
	return NULL;
}
/*
**  SM_SETUSERENV -- set an environment variable in the propagated environment
**
**	Parameters:
**		envar -- the name of the environment variable.
**		value -- the value to which it should be set.  If
**			null, this is extracted from the incoming
**			environment.  If that is not set, the call
**			to sm_setuserenv is ignored.
**
**	Returns:
**		none.
*/

void
sm_setuserenv(envar, value)
	const char *envar;
	const char *value;
{
	int i, l;
	char **evp = UserEnviron;
	char *p;

	if (value == NULL)
	{
		value = getextenv(envar);
		if (value == NULL)
			return;
	}

	/* XXX enforce reasonable size? */
	i = strlen(envar) + 1;
	l = strlen(value) + i + 1;
	p = (char *) xalloc(l);
	(void) sm_strlcpyn(p, l, 3, envar, "=", value);

	while (*evp != NULL && strncmp(*evp, p, i) != 0)
		evp++;
	if (*evp != NULL)
	{
		*evp++ = p;
	}
	else if (evp < &UserEnviron[MAXUSERENVIRON])
	{
		*evp++ = p;
		*evp = NULL;
	}

	/* make sure it is in our environment as well */
	if (putenv(p) < 0)
		syserr("sm_setuserenv: putenv(%s) failed", p);
}
/*
**  DUMPSTATE -- dump state
**
**	For debugging.
*/

void
dumpstate(when)
	char *when;
{
	register char *j = macvalue('j', CurEnv);
	int rs;
	extern int NextMacroId;

	sm_syslog(LOG_DEBUG, CurEnv->e_id,
		  "--- dumping state on %s: $j = %s ---",
		  when,
		  j == NULL ? "<NULL>" : j);
	if (j != NULL)
	{
		if (!wordinclass(j, 'w'))
			sm_syslog(LOG_DEBUG, CurEnv->e_id,
				  "*** $j not in $=w ***");
	}
	sm_syslog(LOG_DEBUG, CurEnv->e_id, "CurChildren = %d", CurChildren);
	sm_syslog(LOG_DEBUG, CurEnv->e_id, "NextMacroId = %d (Max %d)",
		  NextMacroId, MAXMACROID);
	sm_syslog(LOG_DEBUG, CurEnv->e_id, "--- open file descriptors: ---");
	printopenfds(true);
	sm_syslog(LOG_DEBUG, CurEnv->e_id, "--- connection cache: ---");
	mci_dump_all(smioout, true);
	rs = strtorwset("debug_dumpstate", NULL, ST_FIND);
	if (rs > 0)
	{
		int status;
		register char **pvp;
		char *pv[MAXATOM + 1];

		pv[0] = NULL;
		status = REWRITE(pv, rs, CurEnv);
		sm_syslog(LOG_DEBUG, CurEnv->e_id,
			  "--- ruleset debug_dumpstate returns stat %d, pv: ---",
			  status);
		for (pvp = pv; *pvp != NULL; pvp++)
			sm_syslog(LOG_DEBUG, CurEnv->e_id, "%s", *pvp);
	}
	sm_syslog(LOG_DEBUG, CurEnv->e_id, "--- end of state dump ---");
}

#ifdef SIGUSR1
/*
**  SIGUSR1 -- Signal a request to dump state.
**
**	Parameters:
**		sig -- calling signal.
**
**	Returns:
**		none.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
**
**		XXX: More work is needed for this signal handler.
*/

/* ARGSUSED */
static SIGFUNC_DECL
sigusr1(sig)
	int sig;
{
	int save_errno = errno;

	FIX_SYSV_SIGNAL(sig, sigusr1);
	errno = save_errno;
	CHECK_CRITICAL(sig);
	dumpstate("user signal");
# if SM_HEAP_CHECK
	dumpstab();
# endif /* SM_HEAP_CHECK */
	errno = save_errno;
	return SIGFUNC_RETURN;
}
#endif /* SIGUSR1 */

/*
**  DROP_PRIVILEGES -- reduce privileges to those of the RunAsUser option
**
**	Parameters:
**		to_real_uid -- if set, drop to the real uid instead
**			of the RunAsUser.
**
**	Returns:
**		EX_OSERR if the setuid failed.
**		EX_OK otherwise.
*/

int
drop_privileges(to_real_uid)
	bool to_real_uid;
{
	int rval = EX_OK;
	GIDSET_T emptygidset[1];

	if (tTd(47, 1))
		sm_dprintf("drop_privileges(%d): Real[UG]id=%d:%d, get[ug]id=%d:%d, gete[ug]id=%d:%d, RunAs[UG]id=%d:%d\n",
			   (int) to_real_uid,
			   (int) RealUid, (int) RealGid,
			   (int) getuid(), (int) getgid(),
			   (int) geteuid(), (int) getegid(),
			   (int) RunAsUid, (int) RunAsGid);

	if (to_real_uid)
	{
		RunAsUserName = RealUserName;
		RunAsUid = RealUid;
		RunAsGid = RealGid;
		EffGid = RunAsGid;
	}

	/* make sure no one can grab open descriptors for secret files */
	endpwent();
	sm_mbdb_terminate();

	/* reset group permissions; these can be set later */
	emptygidset[0] = (to_real_uid || RunAsGid != 0) ? RunAsGid : getegid();

	/*
	**  Notice:  on some OS (Linux...) the setgroups() call causes
	**	a logfile entry if sendmail is not run by root.
	**	However, it is unclear (no POSIX standard) whether
	**	setgroups() can only succeed if executed by root.
	**	So for now we keep it as it is; if you want to change it, use
	**  if (geteuid() == 0 && setgroups(1, emptygidset) == -1)
	*/

	if (setgroups(1, emptygidset) == -1 && geteuid() == 0)
	{
		syserr("drop_privileges: setgroups(1, %d) failed",
		       (int) emptygidset[0]);
		rval = EX_OSERR;
	}

	/* reset primary group id */
	if (to_real_uid)
	{
		/*
		**  Drop gid to real gid.
		**  On some OS we must reset the effective[/real[/saved]] gid,
		**  and then use setgid() to finally drop all group privileges.
		**  Later on we check whether we can get back the
		**  effective gid.
		*/

#if HASSETEGID
		if (setegid(RunAsGid) < 0)
		{
			syserr("drop_privileges: setegid(%d) failed",
			       (int) RunAsGid);
			rval = EX_OSERR;
		}
#else /* HASSETEGID */
# if HASSETREGID
		if (setregid(RunAsGid, RunAsGid) < 0)
		{
			syserr("drop_privileges: setregid(%d, %d) failed",
			       (int) RunAsGid, (int) RunAsGid);
			rval = EX_OSERR;
		}
# else /* HASSETREGID */
#  if HASSETRESGID
		if (setresgid(RunAsGid, RunAsGid, RunAsGid) < 0)
		{
			syserr("drop_privileges: setresgid(%d, %d, %d) failed",
			       (int) RunAsGid, (int) RunAsGid, (int) RunAsGid);
			rval = EX_OSERR;
		}
#  endif /* HASSETRESGID */
# endif /* HASSETREGID */
#endif /* HASSETEGID */
	}
	if (rval == EX_OK && (to_real_uid || RunAsGid != 0))
	{
		if (setgid(RunAsGid) < 0 && (!UseMSP || getegid() != RunAsGid))
		{
			syserr("drop_privileges: setgid(%d) failed",
			       (int) RunAsGid);
			rval = EX_OSERR;
		}
		errno = 0;
		if (rval == EX_OK && getegid() != RunAsGid)
		{
			syserr("drop_privileges: Unable to set effective gid=%d to RunAsGid=%d",
			       (int) getegid(), (int) RunAsGid);
			rval = EX_OSERR;
		}
	}

	/* fiddle with uid */
	if (to_real_uid || RunAsUid != 0)
	{
		uid_t euid;

		/*
		**  Try to setuid(RunAsUid).
		**  euid must be RunAsUid,
		**  ruid must be RunAsUid unless (e|r)uid wasn't 0
		**	and we didn't have to drop privileges to the real uid.
		*/

		if (setuid(RunAsUid) < 0 ||
		    geteuid() != RunAsUid ||
		    (getuid() != RunAsUid &&
		     (to_real_uid || geteuid() == 0 || getuid() == 0)))
		{
#if HASSETREUID
			/*
			**  if ruid != RunAsUid, euid == RunAsUid, then
			**  try resetting just the real uid, then using
			**  setuid() to drop the saved-uid as well.
			*/

			if (geteuid() == RunAsUid)
			{
				if (setreuid(RunAsUid, -1) < 0)
				{
					syserr("drop_privileges: setreuid(%d, -1) failed",
					       (int) RunAsUid);
					rval = EX_OSERR;
				}
				if (setuid(RunAsUid) < 0)
				{
					syserr("drop_privileges: second setuid(%d) attempt failed",
					       (int) RunAsUid);
					rval = EX_OSERR;
				}
			}
			else
#endif /* HASSETREUID */
			{
				syserr("drop_privileges: setuid(%d) failed",
				       (int) RunAsUid);
				rval = EX_OSERR;
			}
		}
		euid = geteuid();
		if (RunAsUid != 0 && setuid(0) == 0)
		{
			/*
			**  Believe it or not, the Linux capability model
			**  allows a non-root process to override setuid()
			**  on a process running as root and prevent that
			**  process from dropping privileges.
			*/

			syserr("drop_privileges: setuid(0) succeeded (when it should not)");
			rval = EX_OSERR;
		}
		else if (RunAsUid != euid && setuid(euid) == 0)
		{
			/*
			**  Some operating systems will keep the saved-uid
			**  if a non-root effective-uid calls setuid(real-uid)
			**  making it possible to set it back again later.
			*/

			syserr("drop_privileges: Unable to drop non-root set-user-ID privileges");
			rval = EX_OSERR;
		}
	}

	if ((to_real_uid || RunAsGid != 0) &&
	    rval == EX_OK && RunAsGid != EffGid &&
	    getuid() != 0 && geteuid() != 0)
	{
		errno = 0;
		if (setgid(EffGid) == 0)
		{
			syserr("drop_privileges: setgid(%d) succeeded (when it should not)",
			       (int) EffGid);
			rval = EX_OSERR;
		}
	}

	if (tTd(47, 5))
	{
		sm_dprintf("drop_privileges: e/ruid = %d/%d e/rgid = %d/%d\n",
			   (int) geteuid(), (int) getuid(),
			   (int) getegid(), (int) getgid());
		sm_dprintf("drop_privileges: RunAsUser = %d:%d\n",
			   (int) RunAsUid, (int) RunAsGid);
		if (tTd(47, 10))
			sm_dprintf("drop_privileges: rval = %d\n", rval);
	}
	return rval;
}
/*
**  FILL_FD -- make sure a file descriptor has been properly allocated
**
**	Used to make sure that stdin/out/err are allocated on startup
**
**	Parameters:
**		fd -- the file descriptor to be filled.
**		where -- a string used for logging.  If NULL, this is
**			being called on startup, and logging should
**			not be done.
**
**	Returns:
**		none
**
**	Side Effects:
**		possibly changes MissingFds
*/

void
fill_fd(fd, where)
	int fd;
	char *where;
{
	int i;
	struct stat stbuf;

	if (fstat(fd, &stbuf) >= 0 || errno != EBADF)
		return;

	if (where != NULL)
		syserr("fill_fd: %s: fd %d not open", where, fd);
	else
		MissingFds |= 1 << fd;
	i = open(SM_PATH_DEVNULL, fd == 0 ? O_RDONLY : O_WRONLY, 0666);
	if (i < 0)
	{
		syserr("!fill_fd: %s: cannot open %s",
		       where == NULL ? "startup" : where, SM_PATH_DEVNULL);
	}
	if (fd != i)
	{
		(void) dup2(i, fd);
		(void) close(i);
	}
}
/*
**  SM_PRINTOPTIONS -- print options
**
**	Parameters:
**		options -- array of options.
**
**	Returns:
**		none.
*/

static void
sm_printoptions(options)
	char **options;
{
	int ll;
	char **av;

	av = options;
	ll = 7;
	while (*av != NULL)
	{
		if (ll + strlen(*av) > 63)
		{
			sm_dprintf("\n");
			ll = 0;
		}
		if (ll == 0)
			sm_dprintf("\t\t");
		else
			sm_dprintf(" ");
		sm_dprintf("%s", *av);
		ll += strlen(*av++) + 1;
	}
	sm_dprintf("\n");
}

/*
**  TO8BIT -- convert \octal sequences in a test mode input line
**
**	Parameters:
**		str -- the input line.
**
**	Returns:
**		none.
**
**	Side Effects:
**		replaces \0octal in str with octal value.
*/

static bool to8bit __P((char *));

static bool
to8bit(str)
	char *str;
{
	int c, len;
	char *out, *in;
	bool changed;

	if (str == NULL)
		return false;
	in = out = str;
	changed = false;
	len = 0;
	while ((c = (*str++ & 0377)) != '\0')
	{
		int oct, nxtc;

		++len;
		if (c == '\\' &&
		    (nxtc = (*str & 0377)) == '0')
		{
			oct = 0;
			while ((nxtc = (*str & 0377)) != '\0' &&
				isascii(nxtc) && isdigit(nxtc))
			{
				oct <<= 3;
				oct += nxtc - '0';
				++str;
				++len;
			}
			changed = true;
			c = oct;
		}
		*out++ = c;
	}
	*out++ = c;
	if (changed)
	{
		char *q;

		q = quote_internal_chars(in, in, &len);
		if (q != in)
			sm_strlcpy(in, q, len);
	}
	return changed;
}

/*
**  TESTMODELINE -- process a test mode input line
**
**	Parameters:
**		line -- the input line.
**		e -- the current environment.
**	Syntax:
**		#  a comment
**		.X process X as a configuration line
**		=X dump a configuration item (such as mailers)
**		$X dump a macro or class
**		/X try an activity
**		X  normal process through rule set X
*/

static void
testmodeline(line, e)
	char *line;
	ENVELOPE *e;
{
	register char *p;
	char *q;
	auto char *delimptr;
	int mid;
	int i, rs;
	STAB *map;
	char **s;
	struct rewrite *rw;
	ADDRESS a;
	char *lbp;
	auto int lbs;
	static int tryflags = RF_COPYNONE;
	char exbuf[MAXLINE];
	char lbuf[MAXLINE];
	extern unsigned char TokTypeNoC[];
	bool eightbit;

	/* skip leading spaces */
	while (*line == ' ')
		line++;

	lbp = NULL;
	eightbit = false;
	switch (line[0])
	{
	  case '#':
	  case '\0':
		return;

	  case '?':
		help("-bt", e);
		return;

	  case '.':		/* config-style settings */
		switch (line[1])
		{
		  case 'D':
			mid = macid_parse(&line[2], &delimptr);
			if (mid == 0)
				return;
			lbs = sizeof(lbuf);
			lbp = translate_dollars(delimptr, lbuf, &lbs);
			macdefine(&e->e_macro, A_TEMP, mid, lbp);
			if (lbp != lbuf)
				SM_FREE(lbp);
			break;

		  case 'C':
			if (line[2] == '\0')	/* not to call syserr() */
				return;

			mid = macid_parse(&line[2], &delimptr);
			if (mid == 0)
				return;
			lbs = sizeof(lbuf);
			lbp = translate_dollars(delimptr, lbuf, &lbs);
			expand(lbp, exbuf, sizeof(exbuf), e);
			if (lbp != lbuf)
				SM_FREE(lbp);
			p = exbuf;
			while (*p != '\0')
			{
				register char *wd;
				char delim;

				while (*p != '\0' && isascii(*p) && isspace(*p))
					p++;
				wd = p;
				while (*p != '\0' && !(isascii(*p) && isspace(*p)))
					p++;
				delim = *p;
				*p = '\0';
				if (wd[0] != '\0')
					setclass(mid, wd);
				*p = delim;
			}
			break;

		  case '\0':
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Usage: .[DC]macro value(s)\n");
			break;

		  default:
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Unknown \".\" command %s\n", line);
			break;
		}
		return;

	  case '=':		/* config-style settings */
		switch (line[1])
		{
		  case 'S':		/* dump rule set */
			rs = strtorwset(&line[2], NULL, ST_FIND);
			if (rs < 0)
			{
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Undefined ruleset %s\n", &line[2]);
				return;
			}
			rw = RewriteRules[rs];
			if (rw == NULL)
				return;
			do
			{
				(void) sm_io_putc(smioout, SM_TIME_DEFAULT,
						  'R');
				s = rw->r_lhs;
				while (*s != NULL)
				{
					xputs(smioout, *s++);
					(void) sm_io_putc(smioout,
							  SM_TIME_DEFAULT, ' ');
				}
				(void) sm_io_putc(smioout, SM_TIME_DEFAULT,
						  '\t');
				(void) sm_io_putc(smioout, SM_TIME_DEFAULT,
						  '\t');
				s = rw->r_rhs;
				while (*s != NULL)
				{
					xputs(smioout, *s++);
					(void) sm_io_putc(smioout,
							  SM_TIME_DEFAULT, ' ');
				}
				(void) sm_io_putc(smioout, SM_TIME_DEFAULT,
						  '\n');
			} while ((rw = rw->r_next) != NULL);
			break;

		  case 'M':
			for (i = 0; i < MAXMAILERS; i++)
			{
				if (Mailer[i] != NULL)
					printmailer(smioout, Mailer[i]);
			}
			break;

		  case '\0':
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Usage: =Sruleset or =M\n");
			break;

		  default:
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Unknown \"=\" command %s\n", line);
			break;
		}
		return;

	  case '-':		/* set command-line-like opts */
		switch (line[1])
		{
		  case 'd':
			tTflag(&line[2]);
			break;

		  case '\0':
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Usage: -d{debug arguments}\n");
			break;

		  default:
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Unknown \"-\" command %s\n", line);
			break;
		}
		return;

	  case '$':
		if (line[1] == '=')
		{
			mid = macid(&line[2]);
			if (mid != 0)
				stabapply(dump_class, mid);
			return;
		}
		mid = macid(&line[1]);
		if (mid == 0)
			return;
		p = macvalue(mid, e);
		if (p == NULL)
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Undefined\n");
		else
		{
			xputs(smioout, p);
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "\n");
		}
		return;

	  case '/':		/* miscellaneous commands */
		p = &line[strlen(line)];
		while (--p >= line && isascii(*p) && isspace(*p))
			*p = '\0';
		p = strpbrk(line, " \t");
		if (p != NULL)
		{
			while (isascii(*p) && isspace(*p))
				*p++ = '\0';
		}
		else
			p = "";
		if (line[1] == '\0')
		{
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Usage: /[canon|map|mx|parse|try|tryflags]\n");
			return;
		}
		if (sm_strcasecmp(&line[1], "quit") == 0)
		{
			CurEnv->e_id = NULL;
			finis(true, true, ExitStat);
			/* NOTREACHED */
		}
		if (sm_strcasecmp(&line[1], "mx") == 0)
		{
#if NAMED_BIND
			/* look up MX records */
			int nmx;
			auto int rcode;
			char *mxhosts[MAXMXHOSTS + 1];

			if (*p == '\0')
			{
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Usage: /mx address\n");
				return;
			}
			nmx = getmxrr(p, mxhosts, NULL, false, &rcode, true,
				      NULL);
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "getmxrr(%s) returns %d value(s):\n",
				p, nmx);
			for (i = 0; i < nmx; i++)
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "\t%s\n", mxhosts[i]);
#else /* NAMED_BIND */
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "No MX code compiled in\n");
#endif /* NAMED_BIND */
		}
		else if (sm_strcasecmp(&line[1], "canon") == 0)
		{
			char host[MAXHOSTNAMELEN];

			if (*p == '\0')
			{
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Usage: /canon address\n");
				return;
			}
			else if (sm_strlcpy(host, p, sizeof(host)) >= sizeof(host))
			{
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Name too long\n");
				return;
			}
			(void) getcanonname(host, sizeof(host), !HasWildcardMX,
					    NULL);
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "getcanonname(%s) returns %s\n",
					     p, host);
		}
		else if (sm_strcasecmp(&line[1], "map") == 0)
		{
			auto int rcode = EX_OK;
			char *av[2];

			if (*p == '\0')
			{
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Usage: /map mapname key\n");
				return;
			}
			for (q = p; *q != '\0' && !(isascii(*q) && isspace(*q));			     q++)
				continue;
			if (*q == '\0')
			{
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "No key specified\n");
				return;
			}
			*q++ = '\0';
			map = stab(p, ST_MAP, ST_FIND);
			if (map == NULL)
			{
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Map named \"%s\" not found\n", p);
				return;
			}
			if (!bitset(MF_OPEN, map->s_map.map_mflags) &&
			    !openmap(&(map->s_map)))
			{
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Map named \"%s\" not open\n", p);
				return;
			}
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "map_lookup: %s (%s) ", p, q);
			av[0] = q;
			av[1] = NULL;
			p = (*map->s_map.map_class->map_lookup)
					(&map->s_map, q, av, &rcode);
			if (p == NULL)
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "no match (%d)\n",
						     rcode);
			else
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "returns %s (%d)\n", p,
						     rcode);
		}
		else if (sm_strcasecmp(&line[1], "try") == 0)
		{
			MAILER *m;
			STAB *st;
			auto int rcode = EX_OK;

			q = strpbrk(p, " \t");
			if (q != NULL)
			{
				while (isascii(*q) && isspace(*q))
					*q++ = '\0';
			}
			if (q == NULL || *q == '\0')
			{
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Usage: /try mailer address\n");
				return;
			}
			st = stab(p, ST_MAILER, ST_FIND);
			if (st == NULL)
			{
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Unknown mailer %s\n", p);
				return;
			}
			m = st->s_mailer;
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Trying %s %s address %s for mailer %s\n",
				     bitset(RF_HEADERADDR, tryflags) ? "header"
							: "envelope",
				     bitset(RF_SENDERADDR, tryflags) ? "sender"
							: "recipient", q, p);
			p = remotename(q, m, tryflags, &rcode, CurEnv);
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Rcode = %d, addr = %s\n",
					     rcode, p == NULL ? "<NULL>" : p);
			e->e_to = NULL;
		}
		else if (sm_strcasecmp(&line[1], "tryflags") == 0)
		{
			if (*p == '\0')
			{
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Usage: /tryflags [Hh|Ee][Ss|Rr]\n");
				return;
			}
			for (; *p != '\0'; p++)
			{
				switch (*p)
				{
				  case 'H':
				  case 'h':
					tryflags |= RF_HEADERADDR;
					break;

				  case 'E':
				  case 'e':
					tryflags &= ~RF_HEADERADDR;
					break;

				  case 'S':
				  case 's':
					tryflags |= RF_SENDERADDR;
					break;

				  case 'R':
				  case 'r':
					tryflags &= ~RF_SENDERADDR;
					break;
				}
			}
			exbuf[0] = bitset(RF_HEADERADDR, tryflags) ? 'h' : 'e';
			exbuf[1] = ' ';
			exbuf[2] = bitset(RF_SENDERADDR, tryflags) ? 's' : 'r';
			exbuf[3] = '\0';
			macdefine(&e->e_macro, A_TEMP,
				macid("{addr_type}"), exbuf);
		}
		else if (sm_strcasecmp(&line[1], "parse") == 0)
		{
			if (*p == '\0')
			{
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Usage: /parse address\n");
				return;
			}
			q = crackaddr(p, e);
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Cracked address = ");
			xputs(smioout, q);
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "\nParsing %s %s address\n",
					     bitset(RF_HEADERADDR, tryflags) ?
							"header" : "envelope",
					     bitset(RF_SENDERADDR, tryflags) ?
							"sender" : "recipient");
			if (parseaddr(p, &a, tryflags, '\0', NULL, e, true)
			    == NULL)
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Cannot parse\n");
			else if (a.q_host != NULL && a.q_host[0] != '\0')
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "mailer %s, host %s, user %s\n",
						     a.q_mailer->m_name,
						     a.q_host,
						     a.q_user);
			else
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "mailer %s, user %s\n",
						     a.q_mailer->m_name,
						     a.q_user);
			e->e_to = NULL;
		}
		else if (sm_strcasecmp(&line[1], "header") == 0)
		{
			unsigned long ul;

			ul = chompheader(p, CHHDR_CHECK|CHHDR_USER, NULL, e);
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "ul = %lu\n", ul);
		}
		else
		{
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
					     "Unknown \"/\" command %s\n",
					     line);
		}
		(void) sm_io_flush(smioout, SM_TIME_DEFAULT);
		return;
	}

	for (p = line; isascii(*p) && isspace(*p); p++)
		continue;
	q = p;
	while (*p != '\0' && !(isascii(*p) && isspace(*p)))
		p++;
	if (*p == '\0')
	{
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "No address!\n");
		return;
	}
	*p = '\0';
	if (tTd(23, 101))
		eightbit = to8bit(p + 1);
	if (invalidaddr(p + 1, NULL, true))
		return;
	do
	{
		register char **pvp;
		char pvpbuf[PSBUFSIZE];

		pvp = prescan(++p, ',', pvpbuf, sizeof(pvpbuf), &delimptr,
			      ConfigLevel >= 9 ? TokTypeNoC : ExtTokenTab, false);
		if (pvp == NULL)
			continue;
		p = q;
		while (*p != '\0')
		{
			int status;

			rs = strtorwset(p, NULL, ST_FIND);
			if (rs < 0)
			{
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "Undefined ruleset %s\n",
						     p);
				break;
			}
			status = REWRITE(pvp, rs, e);
			if (status != EX_OK)
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "== Ruleset %s (%d) status %d\n",
						     p, rs, status);
			else if (eightbit)
			{
				cataddr(pvp, NULL, exbuf, sizeof(exbuf), '\0',
					true);
				(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
						     "cataddr: %s\n",
						     str2prt(exbuf));
			}
			while (*p != '\0' && *p++ != ',')
				continue;
		}
	} while (*(p = delimptr) != '\0');
	(void) sm_io_flush(smioout, SM_TIME_DEFAULT);
}

static void
dump_class(s, id)
	register STAB *s;
	int id;
{
	if (s->s_symtype != ST_CLASS)
		return;
	if (bitnset(bitidx(id), s->s_class))
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,
				     "%s\n", s->s_name);
}

/*
**  An exception type used to create QuickAbort exceptions.
**  This is my first cut at converting QuickAbort from longjmp to exceptions.
**  These exceptions have a single integer argument, which is the argument
**  to longjmp in the original code (either 1 or 2).  I don't know the
**  significance of 1 vs 2: the calls to setjmp don't care.
*/

const SM_EXC_TYPE_T EtypeQuickAbort =
{
	SmExcTypeMagic,
	"E:mta.quickabort",
	"i",
	sm_etype_printf,
	"quick abort %0",
};



/* ============================================================================
 * SOURCE 77/98: minix4\exokernel\kernel_legacy\cmd\krb5\krb5kdc\main.c
 * Size: 22,940 bytes, Lines: 853
 * Hash: cf7d495de68f...
 * ============================================================================ */

/*
 * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */


/*
 * kdc/main.c
 *
 * Copyright 1990,2001 by the Massachusetts Institute of Technology.
 *
 * Export of this software from the United States of America may
 *   require a specific license from the United States Government.
 *   It is the responsibility of any person or organization contemplating
 *   export to obtain such a license before exporting.
 *
 * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and
 * distribute this software and its documentation for any purpose and
 * without fee is hereby granted, provided that the above copyright
 * notice appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation, and that
 * the name of M.I.T. not be used in advertising or publicity pertaining
 * to distribution of the software without specific, written prior
 * permission.  Furthermore if you modify this software you must label
 * your software as modified software and not distribute it in such a
 * fashion that it might be confused with the original M.I.T. software.
 * M.I.T. makes no representations about the suitability of
 * this software for any purpose.  It is provided "as is" without express
 * or implied warranty.
 *
 *
 * Main procedure body for the KDC server process.
 */

#include <stdio.h>
#include <syslog.h>
#include <signal.h>
#include <errno.h>
#include <netdb.h>

#include "k5-int.h"
#include "com_err.h"
#include "adm.h"
#include "adm_proto.h"
#include "kdc_util.h"
#include "extern.h"
#include "kdc5_err.h"
#include <libintl.h>
#include <locale.h>

#ifdef HAVE_NETINET_IN_H
#include <netinet/in.h>
#endif

#ifdef KRB5_KRB4_COMPAT
#include <des.h>
#endif

#if defined(NEED_DAEMON_PROTO)
extern int daemon(int, int);
#endif

void usage (char *);

krb5_sigtype request_exit (int);
krb5_sigtype request_hup  (int);

void setup_signal_handlers (void);

krb5_error_code setup_sam (void);

void initialize_realms (krb5_context, int, char **);

void finish_realms (char *);

static int nofork = 0;
static int rkey_init_done = 0;

/* Solaris Kerberos: global here that other functions access */
int max_tcp_data_connections;

#ifdef POSIX_SIGNALS
static struct sigaction s_action;
#endif /* POSIX_SIGNALS */

#define	KRB5_KDC_MAX_REALMS	32

/*
 * Find the realm entry for a given realm.
 */
kdc_realm_t *
find_realm_data(char *rname, krb5_ui_4 rsize)
{
    int i;
    for (i=0; i<kdc_numrealms; i++) {
	if ((rsize == strlen(kdc_realmlist[i]->realm_name)) &&
	    !strncmp(rname, kdc_realmlist[i]->realm_name, rsize))
	    return(kdc_realmlist[i]);
    }
    return((kdc_realm_t *) NULL);
}

krb5_error_code
setup_server_realm(krb5_principal sprinc)
{
    krb5_error_code	kret;
    kdc_realm_t		*newrealm;

    kret = 0;
    if (kdc_numrealms > 1) {
	if (!(newrealm = find_realm_data(sprinc->realm.data,
					 (krb5_ui_4) sprinc->realm.length)))
	    kret = ENOENT;
	else
	    kdc_active_realm = newrealm;
    }
    else
	kdc_active_realm = kdc_realmlist[0];
    return(kret);
}

static void
finish_realm(kdc_realm_t *rdp)
{
    if (rdp->realm_dbname)
	free(rdp->realm_dbname);
    if (rdp->realm_mpname)
	free(rdp->realm_mpname);
    if (rdp->realm_stash)
	free(rdp->realm_stash);
    if (rdp->realm_ports)
	free(rdp->realm_ports);
    if (rdp->realm_tcp_ports)
	free(rdp->realm_tcp_ports);
    if (rdp->realm_keytab)
	krb5_kt_close(rdp->realm_context, rdp->realm_keytab);
    if (rdp->realm_context) {
	if (rdp->realm_mprinc)
	    krb5_free_principal(rdp->realm_context, rdp->realm_mprinc);
	if (rdp->realm_mkey.length && rdp->realm_mkey.contents) {
	    memset(rdp->realm_mkey.contents, 0, rdp->realm_mkey.length);
	    free(rdp->realm_mkey.contents);
	}
	krb5_db_fini(rdp->realm_context);
	if (rdp->realm_tgsprinc)
	    krb5_free_principal(rdp->realm_context, rdp->realm_tgsprinc);
	krb5_free_context(rdp->realm_context);
    }
    memset((char *) rdp, 0, sizeof(*rdp));
    free(rdp);
}

/*
 * Initialize a realm control structure from the alternate profile or from
 * the specified defaults.
 *
 * After we're complete here, the essence of the realm is embodied in the
 * realm data and we should be all set to begin operation for that realm.
 */
static krb5_error_code
init_realm(krb5_context kcontext, char *progname, kdc_realm_t *rdp, char *realm,
	   char *def_mpname, krb5_enctype def_enctype, char *def_udp_ports,
	   char *def_tcp_ports, krb5_boolean def_manual, char **db_args)
{
    krb5_error_code	kret;
    krb5_boolean	manual;
    krb5_realm_params	*rparams;

    memset((char *) rdp, 0, sizeof(kdc_realm_t));
    if (!realm) {
	kret = EINVAL;
	goto whoops;
    }

    rdp->realm_name = realm;
    kret = krb5int_init_context_kdc(&rdp->realm_context);
    if (kret) {
	com_err(progname, kret, gettext("while getting context for realm %s"),
		realm);
	goto whoops;
    }

    /*
     * Solaris Kerberos:
     * Set the current context to that of the realm being init'ed
     */
    krb5_klog_set_context(rdp->realm_context);

    kret = krb5_read_realm_params(rdp->realm_context, rdp->realm_name,
				  &rparams);
    if (kret) {
	com_err(progname, kret, gettext("while reading realm parameters"));
	goto whoops;
    }

    /* Handle profile file name */
    if (rparams && rparams->realm_profile)
	rdp->realm_profile = strdup(rparams->realm_profile);

    /* Handle master key name */
    if (rparams && rparams->realm_mkey_name)
	rdp->realm_mpname = strdup(rparams->realm_mkey_name);
    else
	rdp->realm_mpname = (def_mpname) ? strdup(def_mpname) :
	    strdup(KRB5_KDB_M_NAME);

    /* Handle KDC ports */
    if (rparams && rparams->realm_kdc_ports)
	rdp->realm_ports = strdup(rparams->realm_kdc_ports);
    else
	rdp->realm_ports = strdup(def_udp_ports);
    if (rparams && rparams->realm_kdc_tcp_ports)
	rdp->realm_tcp_ports = strdup(rparams->realm_kdc_tcp_ports);
    else
	rdp->realm_tcp_ports = strdup(def_tcp_ports);

    /* Handle stash file */
    if (rparams && rparams->realm_stash_file) {
	rdp->realm_stash = strdup(rparams->realm_stash_file);
	manual = FALSE;
    } else
	manual = def_manual;

    /* Handle master key type */
    if (rparams && rparams->realm_enctype_valid)
	rdp->realm_mkey.enctype = (krb5_enctype) rparams->realm_enctype;
    else
	rdp->realm_mkey.enctype = manual ? def_enctype : ENCTYPE_UNKNOWN;

    /* Handle reject-bad-transit flag */
    if (rparams && rparams->realm_reject_bad_transit_valid)
	rdp->realm_reject_bad_transit = rparams->realm_reject_bad_transit;
    else
	rdp->realm_reject_bad_transit = 1;

    /* Handle ticket maximum life */
    rdp->realm_maxlife = (rparams && rparams->realm_max_life_valid) ?
	rparams->realm_max_life : KRB5_KDB_MAX_LIFE;

    /* Handle ticket renewable maximum life */
    rdp->realm_maxrlife = (rparams && rparams->realm_max_rlife_valid) ?
	rparams->realm_max_rlife : KRB5_KDB_MAX_RLIFE;

    if (rparams)
	krb5_free_realm_params(rdp->realm_context, rparams);

    /*
     * We've got our parameters, now go and setup our realm context.
     */

    /* Set the default realm of this context */
    if ((kret = krb5_set_default_realm(rdp->realm_context, realm))) {
	com_err(progname, kret, gettext("while setting default realm to %s"),
		realm);
	goto whoops;
    }

    /* first open the database  before doing anything */
#ifdef KRBCONF_KDC_MODIFIES_KDB
    if ((kret = krb5_db_open(rdp->realm_context, db_args,
			     KRB5_KDB_OPEN_RW | KRB5_KDB_SRV_TYPE_KDC))) {
#else
    if ((kret = krb5_db_open(rdp->realm_context, db_args,
			     KRB5_KDB_OPEN_RO | KRB5_KDB_SRV_TYPE_KDC))) {
#endif
	/*
	 * Solaris Kerberos:
	 * Make sure that error messages are printed using gettext
	 */
	com_err(progname, kret,
	    gettext("while initializing database for realm %s"), realm);
	goto whoops;
    }

    /* Assemble and parse the master key name */
    if ((kret = krb5_db_setup_mkey_name(rdp->realm_context, rdp->realm_mpname,
					rdp->realm_name, (char **) NULL,
					&rdp->realm_mprinc))) {
	com_err(progname, kret,
		gettext("while setting up master key name %s for realm %s"),
		rdp->realm_mpname, realm);
	goto whoops;
    }

    /*
     * Get the master key.
     */
    if ((kret = krb5_db_fetch_mkey(rdp->realm_context, rdp->realm_mprinc,
				   rdp->realm_mkey.enctype, manual,
				   FALSE, rdp->realm_stash,
				   0, &rdp->realm_mkey))) {
	com_err(progname, kret,
		gettext("while fetching master key %s for realm %s"),
		rdp->realm_mpname, realm);
	goto whoops;
    }

    /* Verify the master key */
    if ((kret = krb5_db_verify_master_key(rdp->realm_context,
					  rdp->realm_mprinc,
					  &rdp->realm_mkey))) {
	com_err(progname, kret,
		gettext("while verifying master key for realm %s"),
		realm);
	goto whoops;
    }

    if ((kret = krb5_db_set_mkey(rdp->realm_context, &rdp->realm_mkey))) {
	com_err(progname, kret,
		gettext("while processing master key for realm %s"),
		realm);
	goto whoops;
    }

    /* Set up the keytab */
    if ((kret = krb5_ktkdb_resolve(rdp->realm_context, NULL,
				   &rdp->realm_keytab))) {
	com_err(progname, kret,
		gettext("while resolving kdb keytab for realm %s"),
		realm);
	goto whoops;
    }

    /* Preformat the TGS name */
    if ((kret = krb5_build_principal(rdp->realm_context, &rdp->realm_tgsprinc,
				     strlen(realm), realm, KRB5_TGS_NAME,
				     realm, (char *) NULL))) {
	com_err(progname, kret,
		gettext("while building TGS name for realm %s"),
		realm);
	goto whoops;
    }

    if (!rkey_init_done) {
#ifdef KRB5_KRB4_COMPAT
	krb5_keyblock temp_key;
#endif
	/*
	 * If all that worked, then initialize the random key
	 * generators.
	 */
#ifdef KRB5_KRB4_COMPAT
	if ((kret = krb5_c_make_random_key(rdp->realm_context,
					   ENCTYPE_DES_CBC_CRC, &temp_key))) {
	    com_err(progname, kret,
		    "while initializing V4 random key generator");
	    goto whoops;
	}

	(void) des_init_random_number_generator(temp_key.contents);
	krb5_free_keyblock_contents(rdp->realm_context, &temp_key);
#endif
	rkey_init_done = 1;
    }
 whoops:
    /*
     * If we choked, then clean up any dirt we may have dropped on the floor.
     */
    if (kret) {

	finish_realm(rdp);
    }

    /*
     * Solaris Kerberos:
     * Set the current context back to the general context
     */
    krb5_klog_set_context(kcontext);

    return(kret);
}

krb5_sigtype
request_exit(int signo)
{
    signal_requests_exit = 1;

#ifdef POSIX_SIGTYPE
    return;
#else
    return(0);
#endif
}

krb5_sigtype
request_hup(int signo)
{
    signal_requests_hup = 1;

#ifdef POSIX_SIGTYPE
    return;
#else
    return(0);
#endif
}

void
setup_signal_handlers(void)
{
#ifdef POSIX_SIGNALS
    (void) sigemptyset(&s_action.sa_mask);
    s_action.sa_flags = 0;
    s_action.sa_handler = request_exit;
    (void) sigaction(SIGINT, &s_action, (struct sigaction *) NULL);
    (void) sigaction(SIGTERM, &s_action, (struct sigaction *) NULL);
    s_action.sa_handler = request_hup;
    (void) sigaction(SIGHUP, &s_action, (struct sigaction *) NULL);
    s_action.sa_handler = SIG_IGN;
    (void) sigaction(SIGPIPE, &s_action, (struct sigaction *) NULL);
#else  /* POSIX_SIGNALS */
    signal(SIGINT, request_exit);
    signal(SIGTERM, request_exit);
    signal(SIGHUP, request_hup);
    signal(SIGPIPE, SIG_IGN);
#endif /* POSIX_SIGNALS */

    return;
}

krb5_error_code
setup_sam(void)
{
    return krb5_c_make_random_key(kdc_context, ENCTYPE_DES_CBC_MD5, &psr_key);
}

void
usage(char *name)
{
    fprintf(stderr, gettext("usage: %s [-d dbpathname] [-r dbrealmname] [-R replaycachename ]\n\t[-m] [-k masterenctype] [-M masterkeyname] [-p port] [-n]\n"), name);
    fprintf(stderr, "usage: %s [-x db_args]* [-d dbpathname] [-r dbrealmname] [-R replaycachename ]\n\t[-m] [-k masterenctype] [-M masterkeyname] [-p port] [-X] [-n]\n"
	    "\nwhere,\n\t[-x db_args]* - any number of database specific arguments.\n"
	    "\t\t\tLook at each database documentation for supported arguments\n",
	    name);
    return;
}

void
initialize_realms(krb5_context kcontext, int argc, char **argv)
{
    int 		c;
    char		*db_name = (char *) NULL;
    char		*mkey_name = (char *) NULL;
    char		*rcname __unused;
    char		*lrealm = NULL;
    krb5_error_code	retval;
    krb5_enctype	menctype = ENCTYPE_UNKNOWN;
    kdc_realm_t		*rdatap;
    krb5_boolean	manual = FALSE;
    char		*default_udp_ports = 0;
    char		*default_tcp_ports = 0;
    krb5_pointer	aprof;
    const char		*hierarchy[3];
    char               **db_args      = NULL;
    int                  db_args_size = 0;

#ifdef KRB5_KRB4_COMPAT
    char                *v4mode = 0;
#endif
    extern char *optarg;

    rcname = KDCRCACHE;

    if (!krb5_aprof_init(DEFAULT_KDC_PROFILE, KDC_PROFILE_ENV, &aprof)) {
	hierarchy[0] = "kdcdefaults";
	hierarchy[1] = "kdc_ports";
	hierarchy[2] = (char *) NULL;
	if (krb5_aprof_get_string(aprof, hierarchy, TRUE, &default_udp_ports))
	    default_udp_ports = 0;
	hierarchy[1] = "kdc_tcp_ports";
	if (krb5_aprof_get_string(aprof, hierarchy, TRUE, &default_tcp_ports))
	    default_tcp_ports = 0;
	hierarchy[1] = "kdc_max_tcp_connections";
	if (krb5_aprof_get_int32(aprof, hierarchy, TRUE,
		&max_tcp_data_connections)) {
	    max_tcp_data_connections = DEFAULT_KDC_TCP_CONNECTIONS;
	} else if (max_tcp_data_connections < MIN_KDC_TCP_CONNECTIONS) {
	    max_tcp_data_connections = DEFAULT_KDC_TCP_CONNECTIONS;
	}
#ifdef KRB5_KRB4_COMPAT
	hierarchy[1] = "v4_mode";
	if (krb5_aprof_get_string(aprof, hierarchy, TRUE, &v4mode))
	    v4mode = 0;
#endif
	/* aprof_init can return 0 with aprof == NULL */
	if (aprof)
	     krb5_aprof_finish(aprof);
    }
    if (default_udp_ports == 0)
	default_udp_ports = strdup(DEFAULT_KDC_UDP_PORTLIST);
    if (default_tcp_ports == 0)
	default_tcp_ports = strdup(DEFAULT_KDC_TCP_PORTLIST);
    /*
     * Loop through the option list.  Each time we encounter a realm name,
     * use the previously scanned options to fill in for defaults.
     */
    while ((c = getopt(argc, argv, "x:r:d:mM:k:R:e:p:s:n4:X3")) != -1) {
	switch(c) {
	case 'x':
	    db_args_size++;
	    {
		char **temp = realloc( db_args, sizeof(char*) * (db_args_size+1)); /* one for NULL */
		if( temp == NULL )
		{
			/* Solaris Kerberos: Keep error messages consistent */
		    com_err(argv[0], errno, gettext("while initializing KDC"));
		    exit(1);
		}

		db_args = temp;
	    }
	    db_args[db_args_size-1] = optarg;
	    db_args[db_args_size]   = NULL;
	  break;

	case 'r':			/* realm name for db */
	    if (!find_realm_data(optarg, (krb5_ui_4) strlen(optarg))) {
		if ((rdatap = (kdc_realm_t *) malloc(sizeof(kdc_realm_t)))) {
		    if ((retval = init_realm(kcontext, argv[0], rdatap, optarg,
					     mkey_name, menctype,
					     default_udp_ports,
					     default_tcp_ports, manual, db_args))) {
			/* Solaris Kerberos: Keep error messages consistent */
			com_err(argv[0], retval, gettext("while initializing realm %s"), optarg);
			exit(1);
		    }
		    kdc_realmlist[kdc_numrealms] = rdatap;
		    kdc_numrealms++;
		    free(db_args), db_args=NULL, db_args_size = 0;
		}
		else
		{
			/* Solaris Kerberos: Keep error messages consistent */
			com_err(argv[0], errno, gettext("while initializing realm %s"), optarg);
			exit(1);
		}
	    }
	    break;
	case 'd':			/* pathname for db */
	    /* now db_name is not a seperate argument. It has to be passed as part of the db_args */
	    if( db_name == NULL )
	    {
		db_name = malloc(sizeof("dbname=") + strlen(optarg));
		if( db_name == NULL )
		{
			/* Solaris Kerberos: Keep error messages consistent */
			com_err(argv[0], errno, gettext("while initializing KDC"));
			exit(1);
		}

		sprintf( db_name, "dbname=%s", optarg);
	    }

	    db_args_size++;
	    {
		char **temp = realloc( db_args, sizeof(char*) * (db_args_size+1)); /* one for NULL */
		if( temp == NULL )
		{
			/* Solaris Kerberos: Keep error messages consistent */
		    com_err(argv[0], errno, gettext("while initializing KDC"));
		    exit(1);
		}

		db_args = temp;
	    }
	    db_args[db_args_size-1] = db_name;
	    db_args[db_args_size]   = NULL;
	    break;
	case 'm':			/* manual type-in of master key */
	    manual = TRUE;
	    if (menctype == ENCTYPE_UNKNOWN)
		menctype = ENCTYPE_DES_CBC_CRC;
	    break;
	case 'M':			/* master key name in DB */
	    mkey_name = optarg;
	    break;
	case 'n':
	    nofork++;			/* don't detach from terminal */
	    break;
	case 'k':			/* enctype for master key */
		/* Solaris Kerberos: Keep error messages consistent */
	    if (retval = krb5_string_to_enctype(optarg, &menctype))
		com_err(argv[0], retval,
		    gettext("while converting %s to an enctype"), optarg);
	    break;
	case 'R':
	    rcname = optarg;
	    break;
	case 'p':
	    if (default_udp_ports)
		free(default_udp_ports);
	    default_udp_ports = strdup(optarg);

	    if (default_tcp_ports)
		free(default_tcp_ports);
	    default_tcp_ports = strdup(optarg);

	    break;
	case '4':
#ifdef KRB5_KRB4_COMPAT
	    if (v4mode)
		free(v4mode);
	    v4mode = strdup(optarg);
#endif
	    break;
	case 'X':
#ifdef KRB5_KRB4_COMPAT
		enable_v4_crossrealm(argv[0]);
#endif
		break;
	case '?':
	default:
	    usage(argv[0]);
	    exit(1);
	}
    }

#ifdef KRB5_KRB4_COMPAT
    /*
     * Setup the v4 mode
     */
    process_v4_mode(argv[0], v4mode);
    free(v4mode);
#endif

    /*
     * Check to see if we processed any realms.
     */
    if (kdc_numrealms == 0) {
	/* no realm specified, use default realm */
	if ((retval = krb5_get_default_realm(kcontext, &lrealm))) {
	    com_err(argv[0], retval,
		gettext("while attempting to retrieve default realm"));
	/* Solaris Kerberos: avoid double logging */
#if 0
	    fprintf (stderr, "%s: %s, %s", argv[0], error_message (retval),
		gettext("attempting to retrieve default realm\n"));
#endif
	    exit(1);
	}
	if ((rdatap = (kdc_realm_t *) malloc(sizeof(kdc_realm_t)))) {
	    if ((retval = init_realm(kcontext, argv[0], rdatap, lrealm,
				     mkey_name, menctype, default_udp_ports,
				     default_tcp_ports, manual, db_args))) {
		/* Solaris Kerberos: Keep error messages consistent */
		com_err(argv[0], retval, gettext("while initializing realm %s"), lrealm);
		exit(1);
	    }
	    kdc_realmlist[0] = rdatap;
	    kdc_numrealms++;
	} else {
    	    if (lrealm)
		free(lrealm);
	}
    }

#ifdef USE_RCACHE
    /*
     * Now handle the replay cache.
     */
    if ((retval = kdc_initialize_rcache(kcontext, rcname))) {
	com_err(argv[0], retval, gettext("while initializing KDC replay cache '%s'"),
		rcname);
	exit(1);
    }
#endif

    /* Ensure that this is set for our first request. */
    kdc_active_realm = kdc_realmlist[0];

    if (default_udp_ports)
	free(default_udp_ports);
    if (default_tcp_ports)
	free(default_tcp_ports);
    if (db_args)
	free(db_args);
    if (db_name)
	free(db_name);

    return;
}

void
finish_realms(char *prog)
{
    int i;

    for (i = 0; i < kdc_numrealms; i++) {
	finish_realm(kdc_realmlist[i]);
	kdc_realmlist[i] = 0;
    }
}

/*
 outline:

 process args & setup

 initialize database access (fetch master key, open DB)

 initialize network

 loop:
 	listen for packet

	determine packet type, dispatch to handling routine
		(AS or TGS (or V4?))

	reflect response

	exit on signal

 clean up secrets, close db

 shut down network

 exit
 */

int main(int argc, char **argv)
{
    krb5_error_code	retval;
    krb5_context	kcontext;
    int errout = 0;

    krb5_boolean log_stderr_set;

    (void) setlocale(LC_ALL, "");

#if !defined(TEXT_DOMAIN)		/* Should be defined by cc -D */
#define	TEXT_DOMAIN	"KRB5KDC_TEST"	/* Use this only if it weren't */
#endif

    (void) textdomain(TEXT_DOMAIN);

    if (strrchr(argv[0], '/'))
	argv[0] = strrchr(argv[0], '/')+1;

    if (!(kdc_realmlist = (kdc_realm_t **) malloc(sizeof(kdc_realm_t *) *
						  KRB5_KDC_MAX_REALMS))) {
	fprintf(stderr, gettext("%s: cannot get memory for realm list\n"), argv[0]);
	exit(1);
    }
    memset((char *) kdc_realmlist, 0,
	   (size_t) (sizeof(kdc_realm_t *) * KRB5_KDC_MAX_REALMS));

    /*
     * A note about Kerberos contexts: This context, "kcontext", is used
     * for the KDC operations, i.e. setup, network connection and error
     * reporting.  The per-realm operations use the "realm_context"
     * associated with each realm.
     */
    retval = krb5int_init_context_kdc(&kcontext);
    if (retval) {
	    com_err(argv[0], retval, gettext("while initializing krb5"));
	    exit(1);
    }
    krb5_klog_init(kcontext, "kdc", argv[0], 1);

    /*
     * Solaris Kerberos:
     * In the early stages of krb5kdc it is desirable to log error messages
     * to stderr as well as any other logging locations specified in config
     * files.
     */
     log_stderr_set = krb5_klog_logging_to_stderr();
     if (log_stderr_set != TRUE) {
     	krb5_klog_add_stderr();
     }

    /* initialize_kdc5_error_table();  SUNWresync121 XXX */

    /*
     * Scan through the argument list
     */
    initialize_realms(kcontext, argc, argv);

    setup_signal_handlers();

    load_preauth_plugins(kcontext);

    retval = setup_sam();
    if (retval) {
	com_err(argv[0], retval, gettext("while initializing SAM"));
	finish_realms(argv[0]);
	return 1;
    }

    if ((retval = setup_network(argv[0]))) {
	com_err(argv[0], retval, gettext("while initializing network"));
	finish_realms(argv[0]);
	return 1;
    }

    /* Solaris Kerberos: Remove the extra stderr logging */
    if (log_stderr_set != TRUE)
	krb5_klog_remove_stderr();

    /*
     * Solaris Kerberos:
     * List the logs (FILE, STDERR, etc) which are currently being
     * logged to and print that to stderr. Useful when trying to
     * track down a failure via SMF.
     */
    if (retval = krb5_klog_list_logs(argv[0])) {
	com_err(argv[0], retval, gettext("while listing logs"));
	if (log_stderr_set != TRUE) {
		fprintf(stderr, gettext("%s: %s while listing logs\n"),
		    argv[0], error_message(retval));
	}
    }

    if (!nofork && daemon(0, 0)) {
	com_err(argv[0], errno, gettext("while detaching from tty"));
	if (log_stderr_set != TRUE) {
		fprintf(stderr, gettext("%s: %s while detaching from tty\n"),
		  argv[0], strerror(errno));
	}
	finish_realms(argv[0]);
	return 1;
    }
    if (retval = krb5_klog_syslog(LOG_INFO, "commencing operation")) {
	com_err(argv[0], retval, gettext("while logging message"));
	errout++;
	};

    if ((retval = listen_and_process(argv[0]))) {
	com_err(argv[0], retval, gettext("while processing network requests"));
	errout++;
    }
    if ((retval = closedown_network(argv[0]))) {
	com_err(argv[0], retval, gettext("while shutting down network"));
	errout++;
    }
    krb5_klog_syslog(LOG_INFO, "shutting down");
    unload_preauth_plugins(kcontext);
    krb5_klog_close(kdc_context);
    finish_realms(argv[0]);
    if (kdc_realmlist)
      free(kdc_realmlist);
#ifdef USE_RCACHE
    (void) krb5_rc_close(kcontext, kdc_rcache);
#endif
#ifndef NOCACHE
    kdc_free_lookaside(kcontext);
#endif
    krb5_free_context(kcontext);
    return errout;
}







/* ============================================================================
 * SOURCE 78/98: minix4\exokernel\kernel_legacy\cmd\isns\isnsd\main.c
 * Size: 11,095 bytes, Lines: 502
 * Hash: 63d57131b2fe...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <pthread.h>
#include <errno.h>
#include <libscf.h>
#ifdef DEBUG
#include <time.h>
#endif
#include <signal.h>
#include <semaphore.h>
#include <sys/wait.h>

#include "isns_server.h"
#include "isns_dseng.h"
#include "isns_msgq.h"
#include "isns_log.h"
#include "isns_cfg.h"
#include "isns_utils.h"
#include "isns_cache.h"
#include "isns_obj.h"
#include "isns_dd.h"
#include "isns_scn.h"
#include "isns_sched.h"
#include "isns_esi.h"
#include "isns_mgmt.h"

/*
 * iSNS Server administrative settings.
 */
uint8_t daemonlize = 0;
int dbg_level = 7;
uint64_t esi_threshold;
uint8_t mgmt_scn;
ctrl_node_t *control_nodes = NULL;
pthread_mutex_t ctrl_node_mtx = PTHREAD_MUTEX_INITIALIZER;
char data_store[MAXPATHLEN];


/* semaphore for handling exit */
static sem_t	isns_child_sem;
static int	isns_child_smf_exit_code;
static pid_t	isns_child_pid;

#if !defined(SMF_EXIT_ERR_OTHER)
#define	SMF_EXIT_ERR_OTHER	-1
#endif

/*
 * Globals for singal handling.  time_to_exit is set by sig_handle()
 * when set the main thread(daemon) and othere threads should exit.
 *
 * semaphone is used to make sure all threads that are created
 * by isns_port_watcher and esi.
 */
boolean_t time_to_exit = B_FALSE;
static uint32_t thr_ref_count;
static pthread_mutex_t thr_count_mtx = PTHREAD_MUTEX_INITIALIZER;
#define	MAX_RETRY_COUNT	10 /* for checking remaining threads before exit. */

/*
 * Door creation flag.
 */
boolean_t door_created = B_FALSE;

/*
 * global system message queue
 */
msg_queue_t *sys_q = NULL;
msg_queue_t *scn_q = NULL;

#ifdef DEBUG
extern void *cli_test(void *argv);
extern dump_db(void);
#endif

extern void sigalrm(int);

/*
 * sigusr2_handler -- SIGUSR2 Handler
 * sigusr2 is exepected only when child is running okay.
 */
/* ARGSUSED */
static void
sigusr2_handler(
	int	sig
)
{
	/* post okay status. */
	isnslog(LOG_DEBUG, "sigusr2_handler",
	    "SIGUSR@ is received.  Parent is existing...");
	isns_child_smf_exit_code = SMF_EXIT_OK;

	(void) sem_post(&isns_child_sem);
}

/*
 * sigchld_handler -- SIGCHLD Handler
 * sigchld is exepected only when there is an error.
 */
/* ARGSUSED */
static void
sigchld_handler(
	int	sig
)
{
	int	status;
	pid_t	ret_pid;

	/* This is the default code. */
	isns_child_smf_exit_code = SMF_EXIT_ERR_OTHER;

	ret_pid = waitpid(isns_child_pid, &status, WNOHANG);

	if (ret_pid == isns_child_pid) {
		if (WIFEXITED(status)) {
			isns_child_smf_exit_code = WEXITSTATUS(status);
		}
	}
	(void) sem_post(&isns_child_sem);
}

/* ARGSUSED */
static void
sighup_handler(
	int	sig
)
{

	isnslog(LOG_DEBUG, "sighup_handle",
	    "SIGHUP is received.  Reloading config...");
	(void) queue_msg_set(sys_q, CONFIG_RELOAD, NULL);
}

/* ARGSUSED */
static void
sigexit_handler(
	int	sig
)
{
	isnslog(LOG_DEBUG, "sigexit_handler",
	    "Signal: %d received and sending server exit.", sig);
	shutdown_server();
}

void
inc_thr_count(
)
{
	(void) pthread_mutex_lock(&thr_count_mtx);

	isnslog(LOG_DEBUG, "inc_thr_count",
	    "increase thread reference count(%d).", thr_ref_count);

	thr_ref_count++;

	(void) pthread_mutex_unlock(&thr_count_mtx);
}

void
dec_thr_count(
)
{
	(void) pthread_mutex_lock(&thr_count_mtx);

	isnslog(LOG_DEBUG, "dec_thr_count",
	    "decrease thread reference count(%d).", thr_ref_count);

	thr_ref_count--;

	(void) pthread_mutex_unlock(&thr_count_mtx);
}

uint32_t
get_thr_count(
)
{
	uint32_t ref;

	(void) pthread_mutex_lock(&thr_count_mtx);

	ref = thr_ref_count;

	(void) pthread_mutex_unlock(&thr_count_mtx);

	isnslog(LOG_DEBUG, "get_thr_count",
	    "checking thread reference count %d.", ref);

	return (ref);
}

void
shutdown_server(
)
{
	isnslog(LOG_DEBUG, "shutdown", "raise exit flag.");
	time_to_exit = B_TRUE;
	(void) queue_msg_set(sys_q, SERVER_EXIT, NULL);
}

int
main(
	/* LINTED E_FUNC_ARG_UNUSED */
	int	argc,
	/* LINTED E_FUNC_ARG_UNUSED */
	char	*argv[]
)
{
	int opt_i = 0;
	pthread_t port_tid, esi_tid, scn_tid;
	uint32_t thr_cnt;
	int i;

#ifdef DEBUG
	time_t t;
	clock_t c;
#endif

#ifdef DEBUG
	if (getopt(argc, argv, "i") == 'i') {
		opt_i = 1; /* interactive mode */
	}
#endif

	/* set locale */
	openlog(ISNS_DAEMON_SYSLOG_PP, LOG_PID | LOG_CONS, LOG_DAEMON);

	/* load administative settings. pick up data location. */
	if (load_config(B_TRUE) != 0) {
		isnslog(LOG_ERR, "main", "administrative settings load error.");
		exit(SMF_EXIT_ERR_OTHER);
	}

	/* A signal handler is set for SIGCHLD. */
	(void) signal(SIGCHLD, sigchld_handler);
	(void) signal(SIGUSR2, sigusr2_handler);
	(void) sigset(SIGALRM, sigalrm);

#ifdef DEBUG
	printf("start daemon\n");
#endif
	if (opt_i == 0 || daemonlize) {
		isnslog(LOG_DEBUG, "main", "now forking... pid %d", getpid());
		daemonlize = 1;
		/* daemonlize */
		isns_child_pid = fork();
		if (isns_child_pid < 0) {
			/*
			 * cannot fork(), terminate the server.
			 */
			exit(SMF_EXIT_ERR_CONFIG);
		}
		if (isns_child_pid > 0) {
			/*
			 * terminate parent.
			 */
			(void) sem_wait(&isns_child_sem);
			(void) sem_destroy(&isns_child_sem);
			isnslog(LOG_DEBUG, "main", "exiting with %d",
				isns_child_smf_exit_code);
			exit(isns_child_smf_exit_code);
		}

		/*
		 * redirect stdout, and stderr to /dev/null.
		 */
		i = open("/dev/null", O_RDWR);
		(void) dup2(i, 1);
		(void) dup2(i, 2);
	} /* end of daemonlize */

#ifdef DEBUG
	printf("calling cache init\n");
#endif
	/* initialize object hash table */
	if (cache_init() != 0) {
		isnslog(LOG_ERR, "main",
		    "object hash table initialization error.");
		exit(SMF_EXIT_ERR_OTHER);
	}

	/* initialize event list */
	if (el_init(10, 60, 6) != 0) {
		isnslog(LOG_ERR, "main",
		"ESI event list initialization error.");
		exit(SMF_EXIT_ERR_OTHER);
	}

	/* initialize iSNS database */
	if (init_data() != 0) {
		isnslog(LOG_ERR, "main",
		    "internal database initialization error");
		exit(SMF_EXIT_ERR_OTHER);
	}

#ifdef DEBUG
	printf("calling load_data\n");
	t = time(NULL);
	c = clock();
#endif

	if (load_data() != 0) {
		isnslog(LOG_ERR, "main", "loading data store failed");
		exit(SMF_EXIT_ERR_OTHER);
	}

#ifdef DEBUG
	t = time(NULL) - t;
	c = clock() - c;
	printf("time %d clock %.4lf -loading data\n",
	    t, c / (double)CLOCKS_PER_SEC);
#endif

#ifdef DEBUG
	printf("sys queue creating...\n");
#endif
	/* create a message queue for system control */
	sys_q = queue_calloc();
	if (!sys_q) {
		exit(SMF_EXIT_ERR_OTHER);
	}

	/* create a message queue for scn thread */
	scn_q = queue_calloc();
	if (!scn_q) {
		exit(SMF_EXIT_ERR_OTHER);
	}

	/* create scn thread */
	/* Check for Default DD/DD-set existence and */
	/* create them if they are not there. */
	if (verify_ddd() != 0) {
		exit(SMF_EXIT_ERR_OTHER);
	}

	/* setup and verify the portal(s) for scn(s) */
	/* after scn registry is loaded from data store. */
	if (verify_scn_portal() != 0) {
		exit(SMF_EXIT_ERR_OTHER);
	}

	/* setup and verify the portal(s) for esi(s) */
	/* after esi list is loaded from data store. */
	if (verify_esi_portal() != 0) {
		exit(SMF_EXIT_ERR_OTHER);
	}

#ifdef DEBUG
	printf("scn queue creating...\n");
#endif

	(void) sigset(SIGHUP, sighup_handler);
	(void) sigset(SIGINT, sigexit_handler);
	(void) sigset(SIGTERM, sigexit_handler);
	(void) sigset(SIGQUIT, sigexit_handler);

	/* create scn thread */
	if (pthread_create(&scn_tid, NULL, scn_proc, NULL) != 0) {
		isnslog(LOG_ERR, "main", "SCN thread creating error.");
		exit(SMF_EXIT_ERR_OTHER);
	}

	/* setup a door for management interface */
	if (setup_mgmt_door(sys_q) != 0) {
		exit(SMF_EXIT_ERR_OTHER);
	}

	/* create server port watcher */
	if (pthread_create(&port_tid, NULL,
	    isns_port_watcher, (void *)sys_q) != 0) {
		isnslog(LOG_ERR, "main", "iSNS port thread creating error.");
		exit(SMF_EXIT_ERR_OTHER);
	}

	/* create entity status inquiry thread */
	if (pthread_create(&esi_tid, NULL,
	    esi_proc, NULL) != 0) {
		isnslog(LOG_ERR, "main", "ESI thread creating error.");
		exit(SMF_EXIT_ERR_OTHER);
	}

#ifdef DEBUG
	if (!daemonlize) {
		(void) pthread_create(&tid,
		    NULL,
		    cli_test,
		    (void *)sys_q);
	}
#endif
	if (opt_i == 0 || daemonlize) {
		isnslog(LOG_DEBUG, "main", "issuing SIGUSR2.. parent pid %d",
		    getppid());
		(void) kill(getppid(), SIGUSR2);
	}

	/* pause */
	for (;;) {
		msg_text_t *msg = queue_msg_get(sys_q);
		switch (msg->id) {
			case DATA_ADD:
			case DATA_UPDATE:
			case DATA_DELETE:
			case DATA_DELETE_ASSOC:
			case DATA_COMMIT:
			case DATA_RETREAT:
				break;
			case REG_EXP:
				/* registration expiring */
				reg_expiring(msg->data);
				break;
			case DEAD_PORTAL:
				portal_dies((uint32_t)msg->data);
				break;
			case SERVER_EXIT:
				/* graceful exit. */
				(void) queue_msg_free(msg);
				isnslog(LOG_DEBUG, "main",
				    "wake up ESI and stop it.");
				(void) get_stopwatch(1);
				isnslog(LOG_DEBUG, "main",
				    "sending SCN stop msg.");
				(void) queue_msg_set(scn_q, SCN_STOP, NULL);
				if (door_created) {
					isnslog(LOG_DEBUG, "main",
					    "closing the door.");
					(void) fdetach(ISNS_DOOR_NAME);
				}
				(void) pthread_join(esi_tid, NULL);
				isnslog(LOG_DEBUG, "main",
				    "esi thread %d exited.", esi_tid);
				(void) pthread_join(port_tid, NULL);
				isnslog(LOG_DEBUG, "main",
				    "port watcher thread %d exited.", port_tid);
				(void) pthread_join(scn_tid, NULL);
				isnslog(LOG_DEBUG, "main",
				    "scn thread %d exited.", scn_tid);

				/* now check any remaining threads. */
				i = 0;
				do {
					thr_cnt = get_thr_count();
					if (thr_cnt == 0) {
						isnslog(LOG_DEBUG, "main",
						    "main thread %d is done.",
						    pthread_self());
						exit(1);
					} else {
						(void) sleep(1);
						i++;
					}
				} while (MAX_RETRY_COUNT > i);
				isnslog(LOG_DEBUG, "main",
				    "main thread %d existing ...",
				    pthread_self());
				exit(1);
				break;
			case CONFIG_RELOAD:
				/* load config again. don't pick data store. */
				(void) load_config(B_FALSE);
				break;
			case SYS_QUIT_OK:
				(void) queue_msg_free(msg);
				exit(0);
			default:
				break;
		}
		(void) queue_msg_free(msg);
	}

	/* LINTED E_STMT_NOT_REACHED */
	return (0);
}



/* ============================================================================
 * SOURCE 79/98: minix4\exokernel\kernel_legacy\cmd\hal\hald-runner\main.c
 * Size: 7,742 bytes, Lines: 271
 * Hash: ca09b94fff6e...
 * ============================================================================ */

/***************************************************************************
 * CVSID: $Id$
 *
 * main.c - Main dbus interface of the hald runner
 *
 * Copyright (C) 2006 Sjoerd Simons, <sjoerd@luon.net>
 * Copyright (C) 2007 Codethink Ltd. Author Rob Taylor <rob.taylor@codethink.co.uk>
 *
 * Licensed under the Academic Free License version 2.1
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *
 **************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#define DBUS_API_SUBJECT_TO_CHANGE
#include <dbus/dbus-glib-lowlevel.h>

#include <glib.h>
#include "utils.h"
#include "runner.h"

#ifndef __GNUC__
#define __attribute__(x)
#endif

static gboolean
parse_udi (run_request *r, DBusMessage *msg, DBusMessageIter *iter)
{
	char *tmpstr;

	/* Should be the device UDI */
	if (dbus_message_iter_get_arg_type(iter) != DBUS_TYPE_STRING)
		goto malformed;
	dbus_message_iter_get_basic(iter, &tmpstr);
	r->udi = g_strdup(tmpstr);

	if (!dbus_message_iter_next(iter))
		goto malformed;

	return TRUE;

malformed:
	return FALSE;
}

static gboolean
parse_environment(run_request *r, DBusMessage *msg, DBusMessageIter *iter)
{
	DBusMessageIter sub_iter;
	char *tmpstr;

	/* The environment array */
	if (dbus_message_iter_get_arg_type(iter) != DBUS_TYPE_ARRAY)
		goto malformed;
	dbus_message_iter_recurse(iter, &sub_iter);
	/* Add default path for the programs we start */
#if defined(__FreeBSD__)
	tmpstr = g_strdup_printf("PATH=/sbin:/usr/sbin:/bin:/usr/bin:/usr/local/sbin:/usr/X11R6/sbin:/bin:/usr/bin:/usr/local/bin:/usr/X11R6/bin:%s", getenv("PATH"));
#else
	tmpstr = g_strdup_printf("PATH=/sbin:/usr/sbin:/bin:/usr/bin:%s", getenv("PATH"));
#endif
	r->environment = get_string_array(&sub_iter, tmpstr);

	/* Then argv */
	if (!dbus_message_iter_next(iter) || dbus_message_iter_get_arg_type(iter) != DBUS_TYPE_ARRAY)
		goto malformed;
	dbus_message_iter_recurse(iter, &sub_iter);
	r->argv = get_string_array(&sub_iter, NULL);

	return TRUE;

malformed:
	return FALSE;
}

static void
handle_run(DBusConnection *con, DBusMessage *msg)
{
	DBusMessage *reply;
	DBusMessageIter iter;
	run_request *r;
	char *tmpstr;

	r = new_run_request();
	g_assert(dbus_message_iter_init(msg, &iter));

	if (!parse_udi(r, msg, &iter))
		goto malformed;

	if (!parse_environment(r, msg, &iter))
		goto malformed;

	/* Next a string of what should be written to stdin */
	if (!dbus_message_iter_next(&iter) || dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_STRING)
		goto malformed;
	dbus_message_iter_get_basic(&iter, &tmpstr);
	r->input = g_strdup(tmpstr);

	/* Then an bool to indicate if we should grab stderr */
	if (!dbus_message_iter_next(&iter) || dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_BOOLEAN)
		goto malformed;
	dbus_message_iter_get_basic(&iter, &(r->error_on_stderr));

	/* Then an uint32 timeout for it */
	if (!dbus_message_iter_next(&iter) || dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_UINT32)
		goto malformed;
	dbus_message_iter_get_basic(&iter, &(r->timeout));

	/* let run_request_run handle the reply */
	run_request_run(r, con, msg, NULL);
	return;

malformed:
	del_run_request(r);
	reply = dbus_message_new_error(msg, "org.freedesktop.HalRunner.Malformed",
				       "Malformed run request");
	dbus_connection_send(con, reply, NULL);
	dbus_message_unref(reply);
}

static void
handle_start(DBusConnection *con, DBusMessage *msg, gboolean is_singleton)
{
	DBusMessage *reply;
	DBusMessageIter iter;
	run_request *r;
	GPid pid;

	r = new_run_request();
	r->is_singleton = is_singleton;

	g_assert(dbus_message_iter_init(msg, &iter));

	if (!dbus_message_iter_init(msg, &iter))
		goto malformed;

	if (!is_singleton && !parse_udi(r, msg, &iter)) {
		fprintf(stderr, "error parsing udi");
		goto malformed;
	}

	if (!parse_environment(r, msg, &iter)) {
		fprintf(stderr, "error parsing environment");
		goto malformed;
	}

	if (run_request_run(r, con, NULL, &pid)) {
		gint64 ppid = pid;
		reply = dbus_message_new_method_return(msg);
		dbus_message_append_args (reply,
					  DBUS_TYPE_INT64, &ppid,
					  DBUS_TYPE_INVALID);

	} else {
		reply = dbus_message_new_error(msg, "org.freedesktop.HalRunner.Failed",
					       "Start request failed");
	}
	dbus_connection_send(con, reply, NULL);
	dbus_message_unref(reply);
	return ;
malformed:
	del_run_request(r);
	reply = dbus_message_new_error(msg, "org.freedesktop.HalRunner.Malformed",
				       "Malformed start request");
	dbus_connection_send(con, reply, NULL);
	dbus_message_unref(reply);
}

static void
handle_kill(DBusConnection *con, DBusMessage *msg)
{
	DBusError error;
	DBusMessage *reply = NULL;
	char *udi;

	dbus_error_init (&error);
	if (!dbus_message_get_args(msg, &error,
				   DBUS_TYPE_STRING, &udi,
				   DBUS_TYPE_INVALID)) {
		reply = dbus_message_new_error (msg, "org.freedesktop.HalRunner.Malformed",
						"Malformed kill message");
		g_assert(reply);
		dbus_connection_send (con, reply, NULL);
		dbus_message_unref(reply);
		return;
	}
	run_kill_udi(udi);

	/* always successfull */
	reply = dbus_message_new_method_return(msg);
	dbus_connection_send(con, reply, NULL);
	dbus_message_unref(reply);
}

static DBusHandlerResult
filter(DBusConnection *con, DBusMessage *msg, void *user_data)
{
	DBusMessage *reply;

	if (dbus_message_is_method_call(msg, "org.freedesktop.HalRunner", "Run")) {
		handle_run(con, msg);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else if (dbus_message_is_method_call(msg, "org.freedesktop.HalRunner", "Start")) {
		handle_start(con, msg, FALSE);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else if (dbus_message_is_method_call(msg, "org.freedesktop.HalRunner", "StartSingleton")) {
		handle_start(con, msg, TRUE);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else if (dbus_message_is_method_call(msg, "org.freedesktop.HalRunner", "Kill")) {
		handle_kill(con, msg);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else if (dbus_message_is_method_call(msg, "org.freedesktop.HalRunner", "Shutdown")) {
		run_kill_all ();
		exit (0);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else if (dbus_message_is_method_call(msg, "org.freedesktop.HalRunner", "KillAll")) {
		run_kill_all();
		/* alwasy successfull */
		reply = dbus_message_new_method_return(msg);
		dbus_connection_send(con, reply, NULL);
		dbus_message_unref(reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	}
	return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
}

int
main(int argc, char **argv)
{
	DBusConnection *c;
	DBusError error;
	GMainLoop *loop;
	char *dbus_address;

	run_init();
	dbus_error_init(&error);
	dbus_address = getenv("HALD_RUNNER_DBUS_ADDRESS");
	g_assert(dbus_address != NULL);

	fprintf(stderr, "Runner started - allowed paths are '%s'\n", getenv("PATH"));

	c = dbus_connection_open(dbus_address, &error);
	if (c == NULL)
		goto error;

	loop = g_main_loop_new(NULL, FALSE);

	dbus_connection_setup_with_g_main(c, NULL);
	dbus_connection_set_exit_on_disconnect(c, TRUE);
	dbus_connection_add_filter(c, filter, NULL, NULL);

	g_main_loop_run(loop);

error:
	fprintf(stderr,"An error has occured: %s\n", error.message);
	return -1;
}



/* ============================================================================
 * SOURCE 80/98: minix4\exokernel\kernel_legacy\cmd\fs.d\ufs\fsck\main.c
 * Size: 22,775 bytes, Lines: 866
 * Hash: 4eb95a7c399e...
 * ============================================================================ */

/*
 * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

/*	Copyright (c) 1983, 1984, 1985, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved	*/


/*
 * Copyright (c) 1980, 1986, 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that: (1) source distributions retain this entire copyright
 * notice and comment, and (2) distributions including binaries display
 * the following acknowledgement:  ``This product includes software
 * developed by the University of California, Berkeley and its contributors''
 * in the documentation or other materials provided with the distribution
 * and in all advertising materials mentioning features or use of this
 * software. Neither the name of the University nor the names of its
 * contributors may be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED '`AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

/*
 * In-core structures:
 * blockmap[]
 *	A bitmap of block usage very similar to what's on disk, but
 *	for the entire filesystem rather than just a cylinder group.
 *	Zero indicates free, one indicates allocated.  Note that this
 *	is opposite the interpretation of a cylinder group's free block
 *	bitmap.
 *
 * statemap[]
 *	Tracks what is known about each inode in the filesystem.
 *	The fundamental state value is one of USTATE, FSTATE, DSTATE,
 *	or SSTATE (unallocated, file, directory, shadow/acl).
 *
 *	There are optional modifying attributes as well: INZLINK,
 *	INFOUND, INCLEAR, INORPHAN, and INDELAYD.  The IN prefix
 *	stands for inode.  INZLINK declares that no links (di_nlink ==
 *	0) to the inode have been found.  It is used instead of
 *	examining di_nlink because we've always got the statemap[] in
 *	memory, and on average the odds are against having any given
 *	inode in the cache.  INFOUND flags that an inode was
 *	encountered during the descent of the filesystem.  In other
 *	words, it's reachable, either by name or by being an acl or
 *	attribute.  INCLEAR declares an intent to call clri() on an
 *	inode. The INCLEAR and INZLINK attributes are treated in a
 *	mutually exclusive manner with INCLEAR taking higher precedence
 *	as the intent is to clear the inode.
 *
 *	INORPHAN indicates that the inode has already been seen once
 *	in pass3 and determined to be an orphan, so any additional
 *	encounters don't need to waste cycles redetermining that status.
 *	It also means we don't ask the user about doing something to the
 *	inode N times.
 *
 *	INDELAYD marks inodes that pass1 determined needed to be truncated.
 *	They can't be truncated during that pass, because it depends on
 *	having a stable world for building the block and inode tables from.
 *
 *	The IN flags rarely used directly, but instead are
 *	pre-combined through the {D,F,S}ZLINK, DFOUND, and
 *	{D,F,S}CLEAR convenience macros.  This mainly matters when
 *	trying to use grep on the source.
 *
 *	Three state-test macros are provided: S_IS_DUNFOUND(),
 *	S_IS_DVALID(), and S_IS_ZLINK().  The first is true when an
 *	inode's state indicates that it is either a simple directory
 *	(DSTATE without the INFOUND or INCLEAR modifiers) or a
 *	directory with the INZLINK modifier set.  By definition, if a
 *	directory has zero links, then it can't be found.  As for
 *	S_IS_DVALID(), it decides if a directory inode is alive.
 *	Effectively, this translates to whether or not it's been
 *	flagged for clearing.  If not, then it's valid for current
 *	purposes.  This is true even if INZLINK is set, as we may find
 *	a reference to it later.  Finally, S_IS_ZLINK() just picks out
 *	the INZLINK flag from the state.
 *
 *	The S_*() macros all work on a state value.  To simplify a
 *	bit, the INO_IS_{DUNFOUND,DVALID}() macros take an inode
 *	number argument.  The inode is looked up in the statemap[] and
 *	the result handed off to the corresponding S_*() macro.  This
 *	is partly a holdover from working with different data
 *	structures (with the same net intent) in the BSD fsck.
 *
 * lncntp
 *	Each entry is initialized to the di_link from the on-disk
 *	inode.  Each time we find one of those links, we decrement it.
 *	Once all the traversing is done, we should have a zero.  If we
 *	have a positive value, then some reference disappeared
 *	(probably from a directory that got nuked); deal with it by
 *	fixing the count.  If we have a negative value, then we found
 *	an extra reference.  This is a can't-happen, except in the
 *	special case of when we reconnect a directory to its parent or
 *	to lost+found.  An exact match between lncntp[] and the on-disk
 *      inode means it's completely unreferenced.
 *
 * aclphead
 *	This is a hash table of the acl inodes in the filesystem.
 *
 * aclpsort
 *	The same acls as in aclphead, but as a simple linear array.
 *	It is used to hold the acl pointers for sorting and scanning
 *	in pass3b.
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/param.h>
#include <sys/int_types.h>
#include <sys/mntent.h>
#include <sys/fs/ufs_fs.h>
#include <sys/vnode.h>
#include <sys/fs/ufs_inode.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <sys/mnttab.h>
#include <signal.h>
#include <string.h>
#include <sys/vfstab.h>
#include <sys/statvfs.h>
#include <sys/filio.h>
#include <ustat.h>
#include <errno.h>
#include "fsck.h"

static void usage(void);
static long argtol(int, char *, char *, int);
static void checkfilesys(char *);
static void check_sanity(char *);
static void report_limbo(const void *, VISIT, int);

#define	QUICK_CHECK	'm'	/* are things ok according to superblock? */
#define	ALL_no		'n'	/* auto-answer interactive questions `no' */
#define	ALL_NO		'N'	/* auto-answer interactive questions `no' */
#define	UFS_OPTS	'o'	/* ufs-specific options, see subopts[] */
#define	ECHO_CMD	'V'	/* echo the command line */
#define	ALL_yes		'y'	/* auto-answer interactive questions `yes' */
#define	ALL_YES		'Y'	/* auto-answer interactive questions `yes' */
#define	VERBOSE		'v'	/* be chatty */

static char *subopts[] = {
#define	PREEN		0	/* non-interactive mode (parent is parallel) */
	"p",
#define	BLOCK		1	/* alternate superblock */
	"b",
#define	DEBUG		2	/* yammer */
	"d",
#define	ONLY_WRITES	3	/* check all writable filesystems */
	"w",
#define	FORCE		4	/* force checking, even if clean */
	"f",
	NULL
};

/*
 * Filesystems that are `magical' - if they exist in vfstab,
 * then they have to be mounted for the system to have gotten
 * far enough to be able to run fsck.  Thus, don't get all
 * bent out of shape if we're asked to check it and it is mounted.
 */
char *magic_fs[] = {
	"",			/* MAGIC_NONE, for normal filesystems */
	"/",			/* MAGIC_ROOT */
	"/usr",			/* MAGIC_USR */
	NULL			/* MAGIC_LIMIT */
};

daddr32_t bflag;
daddr32_t n_blks;
daddr32_t maxfsblock;
int debug;
int errorlocked;
int exitstat;
int fflag;
int fsmodified;
int fswritefd;
int iscorrupt;
int islog;
int islogok;
int interrupted;
int mflag;
int mountfd;
int overflowed_lf;
int rflag;
int reattached_dir;
int broke_dir_link;
int verbose;
char hotroot;
char mountedfs;
char nflag;
char preen;
char rerun;
char *blockmap;
char *devname;
char yflag;
short *lncntp;
ushort_t *statemap;
fsck_ino_t maxino;
fsck_ino_t countdirs;
fsck_ino_t n_files;
void *limbo_dirs;

int
main(int argc, char *argv[])
{
	int c;
	int wflag = 0;
	char *suboptions, *value;
	struct rlimit rlimit;
	extern int optind;
	extern char *optarg;

	while ((c = getopt(argc, argv, "mnNo:VvyY")) != EOF) {
		switch (c) {

		case QUICK_CHECK:
			mflag++;
			break;

		case ALL_no:
		case ALL_NO:
			nflag++;
			yflag = 0;
			break;

		case VERBOSE:
			verbose++;
			break;

		case UFS_OPTS:
			/*
			 * ufs specific options.
			 */
			if (optarg == NULL) {
				usage();
				/*
				 * lint does not believe this, nor does it
				 * believe #pragma does_not_return(usage)
				 */
				/* NOTREACHED */
			}
			suboptions = optarg;
			while (*suboptions != '\0') {
				switch (getsubopt(&suboptions, subopts,
				    &value)) {

				case PREEN:
					preen++;
					break;

				case BLOCK:
					bflag = argtol(BLOCK, "block",
					    value, 10);
					(void) printf("Alternate super block "
					    "location: %ld.\n",
					    (long)bflag);
					break;

				case DEBUG:
					debug++;
					verbose++;
					break;

				case ONLY_WRITES:
					/* check only writable filesystems */
					wflag++;
					break;

				case FORCE:
					fflag++;
					break;

				default:
					usage();
				}
			}
			break;

		case ECHO_CMD:
			{
				int	opt_count;
				char	*opt_text;

				(void) printf("fsck -F ufs ");
				for (opt_count = 1; opt_count < argc;
				    opt_count++) {
					opt_text = argv[opt_count];
					if (opt_text)
						(void) printf("%s ", opt_text);
				}
				(void) printf("\n");
			}
			break;

		case ALL_yes:
		case ALL_YES:
			yflag++;
			nflag = 0;
			break;

		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

	if (argc == 0)
		usage();

	rflag++; /* check raw devices where we can */
	if (signal(SIGINT, SIG_IGN) != SIG_IGN)
		(void) signal(SIGINT, catch);
	if (preen)
		(void) signal(SIGQUIT, catchquit);

	/*
	 * Push up our allowed memory limit so we can cope
	 * with huge file systems.
	 */
	if (getrlimit(RLIMIT_DATA, &rlimit) == 0) {
		rlimit.rlim_cur = rlimit.rlim_max;
		(void) setrlimit(RLIMIT_DATA, &rlimit);
	}

	/*
	 * There are a lot of places where we just exit if a problem is
	 * found.  This means that we won't necessarily check everything
	 * we were asked to.  It would be nice to do everything, and
	 * then provide a summary when we're done.  However, the
	 * interface doesn't really allow us to do that in any useful
	 * way.  So, we'll just bail on the first unrecoverable
	 * problem encountered.  If we've been run by the generic
	 * wrapper, we were only given one filesystem to check, so the
	 * multi-fs case implies being run manually; that means the
	 * user can rerun us on the remaining filesystems when it's
	 * convenient for them.
	 */
	while (argc-- > 0) {
		if (wflag && !writable(*argv)) {
			(void) fprintf(stderr, "not writeable '%s'\n", *argv);
			argv++;
			if (exitstat == 0)
				exitstat = EXBADPARM;
		} else {
			checkfilesys(*argv++);
		}
	}
	if (interrupted)
		exitstat = EXSIGNAL;
	exit(exitstat);
}

/*
 * A relatively intelligent strtol().  Note that if str is NULL, we'll
 * exit, so ret does not actually need to be pre-initialized.  Lint
 * doesn't believe this, and it's harmless enough to make lint happy here.
 */
static long
argtol(int flag, char *req, char *str, int base)
{
	char *cp = str;
	long ret = -1;

	errno = 0;
	if (str != NULL)
		ret = strtol(str, &cp, base);
	if (cp == str || *cp) {
		(void) fprintf(stderr, "-%c flag requires a %s\n", flag, req);
		exit(EXBADPARM);
	}
	if (errno != 0) {
		(void) fprintf(stderr, "-%c %s value out of range\n",
		    flag, req);
	}

	return (ret);
}

/*
 * Check the specified file system.
 */
static void
checkfilesys(char *filesys)
{
	daddr32_t n_ffree, n_bfree;
	char *devstr;
	fsck_ino_t files;
	daddr32_t blks;
	fsck_ino_t inumber;
	int zlinks_printed;
	fsck_ino_t limbo_victim;
	double dbl_nffree, dbl_dsize;
	int quiet_dups;

	mountfd = -1;
	hotroot = 0;
	mountedfs = M_NOMNT;
	reattached_dir = 0;
	broke_dir_link = 0;
	iscorrupt = 1;		/* assume failure in setup() */
	islog = 0;
	islogok = 0;
	overflowed_lf = 0;
	errorlocked = is_errorlocked(filesys);
	limbo_dirs = NULL;

	if ((devstr = setup(filesys)) == NULL) {
		if (!iscorrupt) {
			return;
		}

		if (preen)
			pfatal("CAN'T CHECK FILE SYSTEM.");
		if (exitstat == 0)
			exitstat = mflag ? EXUMNTCHK : EXERRFATAL;
		exit(exitstat);
	} else {
		devname = devstr;
	}

	if (mflag) {
		check_sanity(filesys);
		/* NOTREACHED */
	}

	if (debug)
		printclean();

	iscorrupt = 0;		/* setup() succeeded, assume good filesystem */

	/*
	 * 1: scan inodes tallying blocks used
	 */
	if (!preen) {
		/* hotroot is reported as such in setup() if debug is on */
		if (mountedfs != M_NOMNT)
			(void) printf("** Currently Mounted on %s\n",
			    sblock.fs_fsmnt);
		else
			(void) printf("** Last Mounted on %s\n",
			    sblock.fs_fsmnt);
		(void) printf("** Phase 1 - Check Blocks and Sizes\n");
	}
	pass1();

	/*
	 * 1b: locate first references to duplicates, if any
	 */
	if (have_dups()) {
		if (preen)
			pfatal("INTERNAL ERROR: dups with -o p");
		(void) printf("** Phase 1b - Rescan For More DUPS\n");
		pass1b();
	}

	/*
	 * 2: traverse directories from root to mark all connected directories
	 */
	if (!preen)
		(void) printf("** Phase 2 - Check Pathnames\n");
	pass2();

	/*
	 * 3a: scan inodes looking for disconnected directories.
	 */
	if (!preen)
		(void) printf("** Phase 3a - Check Connectivity\n");
	pass3a();

	/*
	 * 3b: check acls
	 */
	if (!preen)
		(void) printf("** Phase 3b - Verify Shadows/ACLs\n");
	pass3b();

	/*
	 * 4: scan inodes looking for disconnected files; check reference counts
	 */
	if (!preen)
		(void) printf("** Phase 4 - Check Reference Counts\n");
	pass4();

	/*
	 * 5: check and repair resource counts in cylinder groups
	 */
	if (!preen)
		(void) printf("** Phase 5 - Check Cylinder Groups\n");
recount:
	pass5();

	if (overflowed_lf) {
		iscorrupt = 1;
	}

	if (!nflag && mountedfs == M_RW) {
		(void) printf("FILESYSTEM MAY STILL BE INCONSISTENT.\n");
		rerun = 1;
	}

	if (have_dups()) {
		quiet_dups = (reply("LIST REMAINING DUPS") == 0);
		if (report_dups(quiet_dups) > 0)
			iscorrupt = 1;

		(void) printf("WARNING: DATA LOSS MAY HAVE OCCURRED DUE TO "
		    "DUP BLOCKS.\nVERIFY FILE CONTENTS BEFORE USING.\n");
	}

	if (limbo_dirs != NULL) {
		/*
		 * Don't force iscorrupt, as this is sufficiently
		 * harmless that the filesystem can be mounted and
		 * used.  We just leak some inodes and/or blocks.
		 */
		pwarn("Orphan directories not cleared or reconnected:\n");

		twalk(limbo_dirs, report_limbo);

		while (limbo_dirs != NULL) {
			limbo_victim = *(fsck_ino_t *)limbo_dirs;
			if (limbo_victim != 0) {
				(void) tdelete((void *)limbo_victim,
				    &limbo_dirs,
				    ino_t_cmp);
			}
		}

		rerun = 1;
	}

	if (iscorrupt) {
		if (mountedfs == M_RW)
			(void) printf("FS IS MOUNTED R/W AND"
			    " FSCK DID ITS BEST TO FIX"
			    " INCONSISTENCIES.\n");
		else
			(void) printf("FILESYSTEM MAY STILL BE"
			    " INCONSISTENT.\n");
		rerun = 1;
	}

	/*
	 * iscorrupt must be stable at this point.
	 * updateclean() returns true when it had to discard the log.
	 * This can only happen once, since sblock.fs_logbno gets
	 * cleared as part of that operation.
	 */
	if (updateclean()) {
		if (!preen)
			(void) printf(
			    "Log was discarded, updating cyl groups\n");
		goto recount;
	}

	if (debug)
		printclean();

	ckfini();

	/*
	 * print out summary statistics
	 */
	n_ffree = sblock.fs_cstotal.cs_nffree;
	n_bfree = sblock.fs_cstotal.cs_nbfree;
	files = maxino - UFSROOTINO - sblock.fs_cstotal.cs_nifree - n_files;
	blks = n_blks +
	    sblock.fs_ncg * (cgdmin(&sblock, 0) - cgsblock(&sblock, 0));
	blks += cgsblock(&sblock, 0) - cgbase(&sblock, 0);
	blks += howmany(sblock.fs_cssize, sblock.fs_fsize);
	blks = maxfsblock - (n_ffree + sblock.fs_frag * n_bfree) - blks;
	if (debug && (files > 0 || blks > 0)) {
		countdirs = sblock.fs_cstotal.cs_ndir - countdirs;
		pwarn("Reclaimed: %d directories, %d files, %lld fragments\n",
		    countdirs, files - countdirs,
		    (longlong_t)blks);
	}

	dbl_nffree = (double)n_ffree;
	dbl_dsize = (double)sblock.fs_dsize;

	if (!verbose) {
		/*
		 * Done as one big string to try for a single write,
		 * so the output doesn't get interleaved with other
		 * preening fscks.
		 */
		pwarn("%ld files, %lld used, %lld free "
		    "(%lld frags, %lld blocks, %.1f%% fragmentation)\n",
		    (long)n_files, (longlong_t)n_blks,
		    (longlong_t)n_ffree + sblock.fs_frag * n_bfree,
		    (longlong_t)n_ffree, (longlong_t)n_bfree,
		    (dbl_nffree * 100.0) / dbl_dsize);
	} else {
		pwarn("\nFilesystem summary:\n");
		pwarn("Inodes in use: %ld\n", (long)n_files);
		pwarn("Blocks in use: %lld\n", (longlong_t)n_blks);
		pwarn("Total free fragments: %lld\n",
		    (longlong_t)n_ffree + sblock.fs_frag * n_bfree);
		pwarn("Free fragments not in blocks: %lld\n",
		    (longlong_t)n_ffree);
		pwarn("Total free blocks: %lld\n", (longlong_t)n_bfree);
		pwarn("Fragment/block fragmentation: %.1f%%\n",
		    (dbl_nffree * 100.0) / dbl_dsize);
		pwarn("");

		if (files < 0)
			pwarn("%d inodes missing\n", -files);
		if (blks < 0)
			pwarn("%lld blocks missing\n", -(longlong_t)blks);

		zlinks_printed = 0;
		for (inumber = UFSROOTINO; inumber < maxino; inumber++) {
			if (S_IS_ZLINK(statemap[inumber])) {
				if (zlinks_printed == 0) {
					pwarn("The following zero "
					    "link count inodes remain:");
				}
				if (zlinks_printed) {
					if ((zlinks_printed % 9) == 0)
						(void) puts(",\n");
					else
						(void) puts(", ");
				}
				(void) printf("%u", inumber);
				zlinks_printed++;
			}
		}
		if ((zlinks_printed != 0) && ((zlinks_printed % 9) != 0))
			(void) putchar('\n');
	}

	/*
	 * Clean up after ourselves, so we can do the next filesystem.
	 */
	free_dup_state();
	inocleanup();
	free(blockmap);
	free(statemap);
	free((void *)lncntp);
	lncntp = NULL;
	blockmap = NULL;
	statemap = NULL;
	if (iscorrupt && exitstat == 0)
		exitstat = EXFNDERRS;
	if (fsmodified)
		(void) printf("\n***** FILE SYSTEM WAS MODIFIED *****\n");
	if (overflowed_lf)
		(void) printf("\n***** %s FULL, MUST REMOVE ENTRIES *****\n",
		    lfname);
	if (reattached_dir) {
		(void) printf("ORPHANED DIRECTORIES REATTACHED; DIR LINK "
		    "COUNTS MAY NOT BE CORRECT.\n");
		rerun = 1;
	}
	if (broke_dir_link) {
		(void) printf(
		    "DIRECTORY HARDLINK BROKEN; LOOPS MAY STILL EXIST.\n");
		rerun = 1;
	}
	if (iscorrupt)
		(void) printf("***** FILE SYSTEM IS BAD *****\n");

	if (rerun) {
		if (mountedfs == M_RW)
			(void) printf("\n***** PLEASE RERUN FSCK ON UNMOUNTED"
			    " FILE SYSTEM *****\n");
		else
			(void) printf("\n***** PLEASE RERUN FSCK *****\n");
	}

	if ((exitstat == 0) &&
	    (((mountedfs != M_NOMNT) && !errorlocked) || hotroot)) {
		exitstat = EXROOTOKAY;
	}

	if ((exitstat == 0) && rerun)
		exitstat = EXFNDERRS;

	if (mountedfs != M_NOMNT) {
		if (!fsmodified)
			return;
		/*
		 * _FIOFFS is much more effective than a simple sync().
		 * Note that the original fswritefd was discarded in
		 * ckfini().
		 */
		fswritefd = open(devstr, O_RDWR, 0);
		if (fswritefd != -1) {
			(void) ioctl(fswritefd, _FIOFFS, NULL);
			(void) close(fswritefd);
		}

		if (!preen)
			(void) printf("\n***** REBOOT NOW *****\n");

		exitstat = EXREBOOTNOW;
	}
}

/*
 * fsck -m: does the filesystem pass cursory examination
 *
 * XXX This is very redundant with setup().  The right thing would be
 *     for setup() to modify its behaviour when mflag is set (less
 *     chatty, exit instead of return, etc).
 */
void
check_sanity(char *filename)
{
	struct stat64 stbd, stbr;
	char *devname;
	struct ustat usb;
	char vfsfilename[MAXPATHLEN];
	struct vfstab vfsbuf;
	FILE *vfstab;
	struct statvfs vfs_stat;
	int found_magic[MAGIC_LIMIT];
	int magic_cnt;
	int is_magic = 0;
	int is_block = 0;
	int is_file = 0;

	(void) memset((void *)found_magic, 0, sizeof (found_magic));

	if (stat64(filename, &stbd) < 0) {
		(void) fprintf(stderr,
		"ufs fsck: sanity check failed : cannot stat %s\n", filename);
		exit(EXNOSTAT);
	}

	if (S_ISBLK(stbd.st_mode)) {
		is_block = 1;
	} else if (S_ISCHR(stbd.st_mode)) {
		is_block = 0;
	} else if (S_ISREG(stbd.st_mode)) {
		is_file = 1;
	}

	/*
	 * Determine if this is the root file system via vfstab. Give up
	 * silently on failures. The whole point of this is to be tolerant
	 * of the magic file systems being already mounted.
	 */
	if (!is_file && (vfstab = fopen(VFSTAB, "r")) != NULL) {
		for (magic_cnt = 0; magic_cnt < MAGIC_LIMIT; magic_cnt++) {
			if (magic_cnt == MAGIC_NONE)
				continue;
			if (getvfsfile(vfstab, &vfsbuf,
			    magic_fs[magic_cnt]) == 0) {
				if (is_block)
					devname = vfsbuf.vfs_special;
				else
					devname = vfsbuf.vfs_fsckdev;
				if (stat64(devname, &stbr) == 0) {
					if (stbr.st_rdev == stbd.st_rdev) {
						found_magic[magic_cnt] = 1;
						is_magic = magic_cnt;
						break;
					}
				}
			}
		}
	}

	/*
	 * Only works if filename is a block device or if
	 * character and block device has the same dev_t value.
	 * This is currently true, but nothing really forces it.
	 */
	if (!is_magic && (ustat(stbd.st_rdev, &usb) == 0)) {
		(void) fprintf(stderr,
		    "ufs fsck: sanity check: %s already mounted\n", filename);
		exit(EXMOUNTED);
	}

	if (is_magic) {
		(void) strcpy(vfsfilename, magic_fs[is_magic]);
		if (statvfs(vfsfilename, &vfs_stat) != 0) {
			(void) fprintf(stderr, "ufs fsck: Cannot stat %s\n",
			    vfsfilename);
			exit(EXNOSTAT);
		}

		if (!(vfs_stat.f_flag & ST_RDONLY)) {
			/*
			 * The file system is mounted read/write
			 * We need to exit saying this. If it's only
			 * mounted readonly, we can continue.
			 */

			(void) fprintf(stderr,
			    "ufs fsck: sanity check:"
			    "%s already mounted read/write\n", filename);
			exit(EXMOUNTED);
		}
	}

	/*
	 * We know that at boot, the ufs root file system is mounted
	 * read-only first.  After fsck runs, it is remounted as
	 * read-write.  Therefore, we do not need to check for different
	 * values for fs_state between the root file system and the
	 * rest of the file systems.
	 */
	if (islog && !islogok) {
		(void) fprintf(stderr,
		    "ufs fsck: sanity check: %s needs checking\n", filename);
		exit(EXUMNTCHK);
	}
	if ((sblock.fs_state + (long)sblock.fs_time == FSOKAY) &&
	    (sblock.fs_clean == FSCLEAN || sblock.fs_clean == FSSTABLE ||
	    (sblock.fs_clean == FSLOG && islog))) {
		(void) fprintf(stderr,
		    "ufs fsck: sanity check: %s okay\n", filename);
	} else {
		(void) fprintf(stderr,
		    "ufs fsck: sanity check: %s needs checking\n", filename);
		exit(EXUMNTCHK);
	}
	exit(EXOKAY);
}

caddr_t
hasvfsopt(struct vfstab *vfs, char *opt)
{
	struct mnttab mtab;

	if (vfs->vfs_mntopts == NULL)
		return (NULL);
	mtab.mnt_mntopts = vfs->vfs_mntopts;
	return (hasmntopt(&mtab, opt));
}

void
usage(void)
{
	(void) fprintf(stderr,
	    "ufs usage: fsck [-F ufs] [-m] [-n] [-V] [-v] [-y] "
	    "[-o p,b=#,w,f] [special ....]\n");

	exit(EXBADPARM);
}

/*ARGSUSED*/
static void
report_limbo(const void *node, VISIT order, int level)
{
	fsck_ino_t ino = *(fsck_ino_t *)node;

	if ((order == postorder) || (order == leaf)) {
		(void) printf("    Inode %d\n", ino);
	}
}



/* ============================================================================
 * SOURCE 81/98: minix4\exokernel\kernel_legacy\cmd\fs.d\udfs\fsck\main.c
 * Size: 9,042 bytes, Lines: 438
 * Hash: 12d6f8d9f22f...
 * ============================================================================ */

/*
 * Copyright 2005 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

/*	Copyright (c) 1983, 1984, 1985, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved	*/

/*
 * Copyright (c) 1980, 1986, 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that: (1) source distributions retain this entire copyright
 * notice and comment, and (2) distributions including binaries display
 * the following acknowledgement:  ``This product includes software
 * developed by the University of California, Berkeley and its contributors''
 * in the documentation or other materials provided with the distribution
 * and in all advertising materials mentioning features or use of this
 * software. Neither the name of the University nor the names of its
 * contributors may be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#include <stdio.h>
#include <string.h>
#include <ctype.h>	/* use isdigit macro rather than 4.1 libc routine */
#include <unistd.h>
#include <stdlib.h>
#include <signal.h>
#include <malloc.h>
#include <ustat.h>
#include <sys/param.h>
#include <sys/types.h>
#include <sys/sysmacros.h>
#include <sys/mntent.h>
#include <sys/vnode.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/mnttab.h>
#include <sys/signal.h>
#include <sys/vfstab.h>
#include <sys/fs/udf_volume.h>
#include "fsck.h"
#include <locale.h>

int	debug;
char	nflag;
char	yflag;
int	rflag;
static int	wflag;		/* check only writable filesystems */
int	fflag;
static int	sflag;		/* print status flag */
int	isdirty;
int	fsmodified;
int	iscorrupt;
int	exitstat;
uint32_t part_len;
daddr_t	n_blks;
daddr_t	n_files;
daddr_t	n_dirs;
char	preen;
char	mountpoint[100];
char	mountedfs;
char	*devname;
struct log_vol_int_desc *lvintp;

extern int32_t	writable(char *);
extern void	pfatal(char *, ...);
extern void	printfree();
extern void	pwarn(char *, ...);

extern void	pass1();
extern void	dofreemap();
extern void	dolvint();
extern char	*getfullblkname();
extern char	*getfullrawname();

static int	mflag = 0;		/* sanity check only */

char	*mntopt();
void	catch(), catchquit(), voidquit();
int	returntosingle;
static void	checkfilesys();
static void	check_sanity();
static void	usage();

static char *subopts [] = {
#define	PREEN		0
	"p",
#define	DEBUG		1
	"d",
#define	READ_ONLY	2
	"r",
#define	ONLY_WRITES	3
	"w",
#define	FORCE		4	/* force checking, even if clean */
	"f",
#define	STATS		5	/* print time and busy stats */
	"s",
	NULL
};

uint32_t ecma_version = 2;

int
main(int argc, char *argv[])
{
	int	c;
	char	*suboptions,	*value;
	int	suboption;

	(void) setlocale(LC_ALL, "");

	while ((c = getopt(argc, argv, "mnNo:VyYz")) != EOF) {
		switch (c) {

		case 'm':
			mflag++;
			break;

		case 'n':	/* default no answer flag */
		case 'N':
			nflag++;
			yflag = 0;
			break;

		case 'o':
			/*
			 * udfs specific options.
			 */
			suboptions = optarg;
			while (*suboptions != '\0') {
				suboption = getsubopt(&suboptions,
						subopts, &value);
				switch (suboption) {

				case PREEN:
					preen++;
					break;

				case DEBUG:
					debug++;
					break;

				case READ_ONLY:
					break;

				case ONLY_WRITES:
					/* check only writable filesystems */
					wflag++;
					break;

				case FORCE:
					fflag++;
					break;

				case STATS:
					sflag++;
					break;

				default:
					usage();
				}
			}
			break;

		case 'V':
			{
				int	opt_count;
				char	*opt_text;

				(void) fprintf(stdout, "fsck -F udfs ");
				for (opt_count = 1; opt_count < argc;
								opt_count++) {
					opt_text = argv[opt_count];
					if (opt_text)
						(void) fprintf(stdout, " %s ",
								opt_text);
				}
				(void) fprintf(stdout, "\n");
			}
			break;

		case 'y':	/* default yes answer flag */
		case 'Y':
			yflag++;
			nflag = 0;
			break;

		case '?':
			usage();
		}
	}
	argc -= optind;
	argv = &argv[optind];
	rflag++; /* check raw devices */
	if (signal(SIGINT, SIG_IGN) != SIG_IGN) {
		(void) signal(SIGINT, catch);
	}

	if (preen) {
		(void) signal(SIGQUIT, catchquit);
	}

	if (argc) {
		while (argc-- > 0) {
			if (wflag && !writable(*argv)) {
				(void) fprintf(stderr,
					gettext("not writeable '%s'\n"), *argv);
				argv++;
			} else
				checkfilesys(*argv++);
		}
		exit(exitstat);
	}
	return (0);
}


static void
checkfilesys(char *filesys)
{
	char *devstr;

	mountedfs = 0;
	iscorrupt = 1;

	if ((devstr = setup(filesys)) == 0) {
		if (iscorrupt == 0)
			return;
		if (preen)
			pfatal(gettext("CAN'T CHECK FILE SYSTEM."));
		if ((exitstat == 0) && (mflag))
			exitstat = 32;
		exit(exitstat);
	}
	else
		devname = devstr;
	if (mflag)
		check_sanity(filesys);	/* this never returns */
	iscorrupt = 0;
	/*
	 * 1: scan inodes tallying blocks used
	 */
	if (preen == 0) {
		if (mountedfs)
			(void) printf(gettext("** Currently Mounted on %s\n"),
				mountpoint);
		if (mflag) {
			(void) printf(
				gettext("** Phase 1 - Sanity Check only\n"));
			return;
		} else
			(void) printf(
				gettext("** Phase 1 - Check Directories "
				"and Blocks\n"));
	}
	pass1();
	if (sflag) {
		if (preen)
			(void) printf("%s: ", devname);
		else
			(void) printf("** ");
	}
	if (debug)
		(void) printf("pass1 isdirty %d\n", isdirty);
	if (debug)
		printfree();
	dofreemap();
	dolvint();

	/*
	 * print out summary statistics
	 */
	pwarn(gettext("%d files, %d dirs, %d used, %d free\n"), n_files, n_dirs,
		n_blks, part_len - n_blks);
	if (iscorrupt)
		exitstat = 36;
	if (!fsmodified)
		return;
	if (!preen)
		(void) printf(
			gettext("\n***** FILE SYSTEM WAS MODIFIED *****\n"));

	if (mountedfs) {
		exitstat = 40;
	}
}


/*
 * exit 0 - file system is unmounted and okay
 * exit 32 - file system is unmounted and needs checking
 * exit 33 - file system is mounted
 *	for root file system
 * exit 34 - cannot stat device
 */

static void
check_sanity(char *filename)
{
	struct stat stbd, stbr;
	struct ustat usb;
	char *devname;
	struct vfstab vfsbuf;
	FILE *vfstab;
	int is_root = 0;
	int is_usr = 0;
	int is_block = 0;

	if (stat(filename, &stbd) < 0) {
		(void) fprintf(stderr,
			gettext("udfs fsck: sanity check failed : cannot stat "
			"%s\n"), filename);
		exit(34);
	}

	if ((stbd.st_mode & S_IFMT) == S_IFBLK)
		is_block = 1;
	else if ((stbd.st_mode & S_IFMT) == S_IFCHR)
		is_block = 0;
	else {
		(void) fprintf(stderr,
			gettext("udfs fsck: sanity check failed: %s not "
			"block or character device\n"), filename);
		exit(34);
	}

	/*
	 * Determine if this is the root file system via vfstab. Give up
	 * silently on failures. The whole point of this is not to care
	 * if the root file system is already mounted.
	 *
	 * XXX - similar for /usr. This should be fixed to simply return
	 * a new code indicating, mounted and needs to be checked.
	 */
	if ((vfstab = fopen(VFSTAB, "r")) != 0) {
		if (getvfsfile(vfstab, &vfsbuf, "/") == 0) {
			if (is_block)
				devname = vfsbuf.vfs_special;
			else
				devname = vfsbuf.vfs_fsckdev;
			if (stat(devname, &stbr) == 0)
				if (stbr.st_rdev == stbd.st_rdev)
					is_root = 1;
		}
		if (getvfsfile(vfstab, &vfsbuf, "/usr") == 0) {
			if (is_block)
				devname = vfsbuf.vfs_special;
			else
				devname = vfsbuf.vfs_fsckdev;
			if (stat(devname, &stbr) == 0)
				if (stbr.st_rdev == stbd.st_rdev)
					is_usr = 1;
		}
	}


	/*
	 * XXX - only works if filename is a block device or if
	 * character and block device has the same dev_t value
	 */
	if (is_root == 0 && is_usr == 0 && ustat(stbd.st_rdev, &usb) == 0) {
		(void) fprintf(stderr,
			gettext("udfs fsck: sanity check: %s "
			"already mounted\n"), filename);
		exit(33);
	}

	if (lvintp->lvid_int_type == LVI_CLOSE) {
		(void) fprintf(stderr,
			gettext("udfs fsck: sanity check: %s okay\n"),
			filename);
	} else {
		(void) fprintf(stderr,
			gettext("udfs fsck: sanity check: %s needs checking\n"),
			filename);
		exit(32);
	}
	exit(0);
}

char *
unrawname(char *name)
{
	char *dp;


	if ((dp = getfullblkname(name)) == NULL)
		return ("");
	return (dp);
}

char *
rawname(char *name)
{
	char *dp;

	if ((dp = getfullrawname(name)) == NULL)
		return ("");
	return (dp);
}

char *
hasvfsopt(struct vfstab *vfs, char *opt)
{
	char *f, *opts;
	static char *tmpopts;

	if (vfs->vfs_mntopts == NULL)
		return (NULL);
	if (tmpopts == 0) {
		tmpopts = (char *)calloc(256, sizeof (char));
		if (tmpopts == 0)
			return (0);
	}
	(void) strncpy(tmpopts, vfs->vfs_mntopts, (sizeof (tmpopts) - 1));
	opts = tmpopts;
	f = mntopt(&opts);
	for (; *f; f = mntopt(&opts)) {
		if (strncmp(opt, f, strlen(opt)) == 0)
			return (f - tmpopts + vfs->vfs_mntopts);
	}
	return (NULL);
}

static void
usage()
{
	(void) fprintf(stderr, gettext("udfs usage: fsck [-F udfs] "
		"[generic options] [-o p,w,s] [special ....]\n"));
	exit(31+1);
}



/* ============================================================================
 * SOURCE 82/98: minix4\exokernel\kernel_legacy\cmd\cmd-inet\usr.sbin\in.routed\main.c
 * Size: 26,678 bytes, Lines: 1,068
 * Hash: 3952085bc7fc...
 * ============================================================================ */

/*
 * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 *
 * Copyright (c) 1983, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgment:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: src/sbin/routed/main.c,v 1.14 2000/08/11 08:24:38 sheldonh Exp $
 * char copyright[] = "@(#) Copyright (c) 1983, 1988, 1993\n"
 * " The Regents of the University of California.  All rights reserved.\n";
 */

#include "defs.h"
#include "pathnames.h"
#include <signal.h>
#include <fcntl.h>
#include <sys/file.h>
#include <userdefs.h>
#include <sys/stat.h>

#define	IN_ROUTED_VERSION	"2.22"

int		stopint;
boolean_t	supplier;	/* supply or broadcast updates */
boolean_t	supplier_set;
/* -S option. _B_TRUE=treat all RIP speakers as default routers. */
boolean_t	save_space = _B_FALSE;

static boolean_t default_gateway;	/* _B_TRUE=advertise default */
static boolean_t background = _B_TRUE;
boolean_t	ridhosts;	/* _B_TRUE=reduce host routes */
boolean_t	mhome;		/* _B_TRUE=want multi-homed host route */
boolean_t	advertise_mhome;  /* _B_TRUE=must continue advertising it */
boolean_t	auth_ok = _B_TRUE; /* _B_TRUE=ignore auth if we don't care */
boolean_t	no_install;	/* _B_TRUE=don't install in kernel */

struct timeval epoch;		/* when started */
struct timeval clk;
static struct timeval prev_clk;
static int usec_fudge;
struct timeval now;		/* current idea of time */
/* If a route's rts_time is <= to now_stale, the route is stale. */
time_t	now_stale;
/* If a route's rts_time is <= to now_expire, the route is expired */
time_t	now_expire;
/* If a route's rts_time is <= to now_garbage, the route needs to be deleted */
time_t	now_garbage;

static struct timeval next_bcast;	/* next general broadcast */
struct timeval no_flash = {		/* inhibit flash update */
	EPOCH+SUPPLY_INTERVAL, 0
};

/* When now reaches this time, it's time to call sync_kern() */
static struct timeval sync_kern_timer;

static fd_set	fdbits;
static int	sock_max;
int		rip_sock = -1;	/* RIP socket */
boolean_t	rip_enabled;
static boolean_t	openlog_done;

/*
 * The interface to which rip_sock is currently pointing for
 * output.
 */
struct interface *rip_sock_interface;

int	rt_sock;			/* routing socket */


static  int open_rip_sock();
static void timevalsub(struct timeval *, struct timeval *, struct timeval *);
static void	sigalrm(int);
static void	sigterm(int);

int
main(int argc, char *argv[])
{
	int n, off;
	char *p, *q;
	const char *cp;
	struct timeval select_timeout, result;
	fd_set ibits;
	in_addr_t p_net, p_mask;
	struct parm parm;
	char *tracename = NULL;
	boolean_t vflag = _B_FALSE;
	boolean_t version = _B_FALSE;
	int sigerr = 0;
	FILE *pidfp;
	mode_t pidmode = (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH); /* 0644 */

	(void) setlocale(LC_ALL, "");

#if	!defined(TEXT_DOMAIN)   /* Should be defined by cc -D */
#define	TEXT_DOMAIN	"SYS_TEXT"
#endif	/* ! TEXT_DOMAIN */

	(void) textdomain(TEXT_DOMAIN);

	/*
	 * Some shells are badly broken and send SIGHUP to backgrounded
	 * processes.
	 */
	if (signal(SIGHUP, SIG_IGN) == SIG_ERR)
		sigerr = errno;

	ftrace = stdout;

	if (gettimeofday(&clk, 0) == -1) {
		logbad(_B_FALSE, "gettimeofday: %s", rip_strerror(errno));
	}
	prev_clk = clk;
	epoch = clk;
	epoch.tv_sec -= EPOCH;
	now.tv_sec = EPOCH;
	now_stale = EPOCH - STALE_TIME;
	now_expire = EPOCH - EXPIRE_TIME;
	now_garbage = EPOCH - GARBAGE_TIME;
	select_timeout.tv_sec = 0;

	while ((n = getopt(argc, argv, "sSqdghmpAztVvnT:F:P:")) != -1) {
		switch (n) {
		case 'A':
			/*
			 * Ignore authentication if we do not care.
			 * Crazy as it is, that is what RFC 2453 requires.
			 */
			auth_ok = _B_FALSE;
			break;

		case 't':
			if (new_tracelevel < 2)
				new_tracelevel = 2;
			background = _B_FALSE;
			break;

		case 'd':	/* put in.routed in foreground */
			background = _B_FALSE;
			break;

		case 'F':		/* minimal routes for SLIP */
			n = FAKE_METRIC;
			p = strchr(optarg, ',');
			if (p != NULL) {
				n = (int)strtoul(p+1, &q, 0);
				if (*q == '\0' && p+1 != q &&
				    n <= HOPCNT_INFINITY-1 && n >= 1)
					*p = '\0';
			}
			if (!getnet(optarg, &p_net, &p_mask)) {
				if (p != NULL)
					*p = ',';
				msglog(gettext("bad network; \"-F %s\""),
				    optarg);
				break;
			}
			(void) memset(&parm, 0, sizeof (parm));
			parm.parm_net = p_net;
			parm.parm_mask = p_mask;
			parm.parm_d_metric = n;
			cp = insert_parm(&parm);
			if (cp != NULL)
				msglog(gettext("bad -F: %s"), cp);
			break;

		case 'g':
			(void) memset(&parm, 0, sizeof (parm));
			parm.parm_d_metric = 1;
			cp = insert_parm(&parm);
			if (cp != NULL)
				msglog(gettext("bad -g: %s"), cp);
			else
				default_gateway = _B_TRUE;
			break;

		case 'h':		/* suppress extra host routes */
			ridhosts = _B_TRUE;
			break;

		case 'm':		/* advertise host route */
			mhome = _B_TRUE;	/* on multi-homed hosts */
			break;

		case 'n':	/* No-install mode */
			no_install = _B_TRUE;
			break;

		case 'P':
			/* handle arbitrary parameters. */
			q = strdup(optarg);
			if (q == NULL)
				logbad(_B_FALSE, "strdup: %s",
				    rip_strerror(errno));
			cp = parse_parms(q, _B_FALSE);
			if (cp != NULL)
				msglog(gettext("%1$s in \"-P %2$s\""), cp,
				    optarg);
			free(q);
			break;

		case 'q':
			supplier = _B_FALSE;
			supplier_set = _B_TRUE;
			break;

		case 's':
			supplier = _B_TRUE;
			supplier_set = _B_TRUE;
			break;

		case 'S':	/* save-space option */
			save_space = _B_TRUE;
			break;

		case 'T':
			tracename = optarg;
			break;

		case 'V':
			/* display version */
			version = _B_TRUE;
			msglog(gettext("version " IN_ROUTED_VERSION));
			break;

		case 'v':
			/* display route changes to supplied logfile */
			new_tracelevel = 1;
			vflag = _B_TRUE;
			break;

		case 'z':	/* increase debug-level */
			new_tracelevel++;
			break;

		default:
			goto usage;
		}
	}
	argc -= optind;
	argv += optind;

	if (tracename == NULL && argc >= 1) {
		tracename = *argv++;
		argc--;
	}
	if (tracename != NULL && tracename[0] == '\0')
		goto usage;
	if (vflag && tracename == NULL)
		goto usage;
	if (argc != 0) {
usage:
		(void) fprintf(stderr, gettext(
		    "usage: in.routed [-AdghmnqsStVvz] "
		    "[-T <tracefile>]\n"));
		(void) fprintf(stderr,
		    gettext("\t[-F <net>[/<mask>][,<metric>]] [-P <parms>]\n"));
		logbad(_B_FALSE, gettext("excess arguments"));
	}
	if (geteuid() != 0) {
		/*
		 * Regular users are allowed to run in.routed for the
		 * sole purpose of obtaining the version number.  In
		 * that case, exit(EXIT_SUCCESS) without complaining.
		 */
		if (version)
			exit(EXIT_SUCCESS);
		logbad(_B_FALSE, gettext("requires UID 0"));
	}

	if (default_gateway) {
		if (supplier_set && !supplier) {
			msglog(gettext("-g and -q are incompatible"));
		} else {
			supplier = _B_TRUE;
			supplier_set = _B_TRUE;
		}
	}

	if (signal(SIGALRM, sigalrm) == SIG_ERR)
		sigerr = errno;
	/* SIGHUP fatal during debugging */
	if (!background)
		if (signal(SIGHUP, sigterm) == SIG_ERR)
			sigerr = errno;
	if (signal(SIGTERM, sigterm) == SIG_ERR)
		sigerr = errno;
	if (signal(SIGINT, sigterm) == SIG_ERR)
		sigerr = errno;
	if (signal(SIGUSR1, sigtrace_more) == SIG_ERR)
		sigerr = errno;
	if (signal(SIGUSR2, sigtrace_less) == SIG_ERR)
		sigerr = errno;
	if (signal(SIGHUP, sigtrace_dump) == SIG_ERR)
		sigerr = errno;

	if (sigerr)
		msglog("signal: %s", rip_strerror(sigerr));

	/* get into the background */
	if (background && daemon(0, 0) < 0)
		BADERR(_B_FALSE, "daemon()");

	/* Store our process id, blow away any existing file if it exists. */
	if ((pidfp = fopen(PATH_PID, "w")) == NULL) {
		(void) fprintf(stderr,
		    gettext("in.routed: unable to open " PATH_PID ": %s\n"),
		    strerror(errno));
	} else {
		(void) fprintf(pidfp, "%ld\n", getpid());
		(void) fclose(pidfp);
		(void) chmod(PATH_PID, pidmode);
	}

	srandom((int)(clk.tv_sec ^ clk.tv_usec ^ getpid()));

	/* allocate the interface tables */
	iftbl_alloc();

	/* prepare socket connected to the kernel. */
	rt_sock = socket(PF_ROUTE, SOCK_RAW, AF_INET);
	if (rt_sock < 0)
		BADERR(_B_TRUE, "rt_sock = socket()");
	if (fcntl(rt_sock, F_SETFL, O_NONBLOCK) == -1)
		logbad(_B_TRUE, "fcntl(rt_sock) O_NONBLOCK: %s",
		    rip_strerror(errno));
	off = 0;
	if (setsockopt(rt_sock, SOL_SOCKET, SO_USELOOPBACK,
	    &off, sizeof (off)) < 0)
		LOGERR("setsockopt(SO_USELOOPBACK,0)");

	fix_select();


	if (tracename != NULL) {
		(void) strlcpy(inittracename, tracename,
		    sizeof (inittracename));
		set_tracefile(inittracename, "%s", -1);
	} else {
		tracelevel_msg("%s", -1);   /* turn on tracing to stdio */
	}

	bufinit();

	/* initialize radix tree */
	rtinit();

	/*
	 * Pick a random part of the second for our output to minimize
	 * collisions.
	 *
	 * Start broadcasting after hearing from other routers, and
	 * at a random time so a bunch of systems do not get synchronized
	 * after a power failure.
	 *
	 * Since now is the number of seconds since epoch (this is initially
	 * EPOCH seconds), these times are really relative to now.
	 */
	intvl_random(&next_bcast, EPOCH+MIN_WAITTIME, EPOCH+SUPPLY_INTERVAL);
	age_timer.tv_usec = next_bcast.tv_usec;
	age_timer.tv_sec = EPOCH+MIN_WAITTIME;
	rdisc_timer = next_bcast;
	ifscan_timer.tv_usec = next_bcast.tv_usec;

	/*
	 * Open the global rip socket.  From now on, this socket can be
	 * assumed to be open.  It will remain open until in.routed
	 * exits.
	 */
	rip_sock = open_rip_sock();

	/*
	 * Collect an initial view of the world by checking the interface
	 * configuration and the kludge file.
	 *
	 * gwkludge() could call addroutefordefault(), resulting in a call to
	 * iflookup, and thus ifscan() to find the physical interfaces.
	 * ifscan() will attempt to use the rip_sock in order to join
	 * mcast groups, so gwkludge *must* be called after opening
	 * the rip_sock.
	 */
	gwkludge();

	ifscan();

	/* Ask for routes */
	rip_query();
	rdisc_sol();

	/* Now turn off stdio if not tracing */
	if (new_tracelevel == 0)
		trace_close(background);

	/* Loop until a fatal error occurs, listening and broadcasting. */
	for (;;) {
		prev_clk = clk;
		if (gettimeofday(&clk, 0) == -1) {
			logbad(_B_FALSE, "gettimeofday: %s",
			    rip_strerror(errno));
		}
		if (prev_clk.tv_sec == clk.tv_sec &&
		    prev_clk.tv_usec == clk.tv_usec+usec_fudge) {
			/*
			 * Much of `in.routed` depends on time always advancing.
			 * On systems that do not guarantee that gettimeofday()
			 * produces unique timestamps even if called within
			 * a single tick, use trickery like that in classic
			 * BSD kernels.
			 */
			clk.tv_usec += ++usec_fudge;

		} else {
			time_t dt;

			usec_fudge = 0;

			timevalsub(&result, &clk, &prev_clk);
			if (result.tv_sec < 0 || result.tv_sec >
			    select_timeout.tv_sec + 5) {
				/*
				 * Deal with time changes before other
				 * housekeeping to keep everything straight.
				 */
				dt = result.tv_sec;
				if (dt > 0)
					dt -= select_timeout.tv_sec;
				trace_act("time changed by %d sec", (int)dt);
				epoch.tv_sec += dt;
			}
		}
		timevalsub(&now, &clk, &epoch);
		now_stale = now.tv_sec - STALE_TIME;
		now_expire = now.tv_sec - EXPIRE_TIME;
		now_garbage = now.tv_sec - GARBAGE_TIME;

		/* deal with signals that should affect tracing */
		set_tracelevel();

		if (stopint != 0) {
			trace_off("exiting with signal %d", stopint);
			break;
		}

		/* look for new or dead interfaces */
		timevalsub(&select_timeout, &ifscan_timer, &now);
		if (select_timeout.tv_sec <= 0) {
			select_timeout.tv_sec = 0;
			ifscan();
			rip_query();
			continue;
		}

		/*
		 * Check the kernel table occassionally for mysteriously
		 * evaporated routes
		 */
		timevalsub(&result, &sync_kern_timer, &now);
		if (result.tv_sec <= 0) {
			sync_kern();
			sync_kern_timer.tv_sec = (now.tv_sec
			    + CHECK_QUIET_INTERVAL);
			continue;
		}
		if (timercmp(&result, &select_timeout, < /* */))
			select_timeout = result;

		/* If it is time, then broadcast our routes. */
		if (should_supply(NULL) || advertise_mhome) {
			timevalsub(&result, &next_bcast, &now);
			if (result.tv_sec <= 0) {
				/*
				 * Synchronize the aging and broadcast
				 * timers to minimize awakenings
				 */
				age(0);
				age_peer_info();

				rip_bcast(0);

				/*
				 * It is desirable to send routing updates
				 * regularly.  So schedule the next update
				 * 30 seconds after the previous one was
				 * scheduled, instead of 30 seconds after
				 * the previous update was finished.
				 * Even if we just started after discovering
				 * a 2nd interface or were otherwise delayed,
				 * pick a 30-second aniversary of the
				 * original broadcast time.
				 */
				n = 1 + (0-result.tv_sec)/SUPPLY_INTERVAL;
				next_bcast.tv_sec += n*SUPPLY_INTERVAL;

				continue;
			}

			if (timercmp(&result, &select_timeout, < /* */))
				select_timeout = result;
		}

		/*
		 * If we need a flash update, either do it now or
		 * set the delay to end when it is time.
		 *
		 * If we are within MIN_WAITTIME seconds of a full update,
		 * do not bother.
		 */
		if (need_flash && should_supply(NULL) &&
		    no_flash.tv_sec+MIN_WAITTIME < next_bcast.tv_sec) {
			/* accurate to the millisecond */
			if (!timercmp(&no_flash, &now, > /* */))
				rip_bcast(1);
			timevalsub(&result, &no_flash, &now);
			if (timercmp(&result, &select_timeout, < /* */))
				select_timeout = result;
		}

		/* trigger the main aging timer. */
		timevalsub(&result, &age_timer, &now);
		if (result.tv_sec <= 0) {
			age(0);
			continue;
		}
		if (timercmp(&result, &select_timeout, < /* */))
			select_timeout = result;

		/* update the kernel routing table */
		timevalsub(&result, &need_kern, &now);
		if (result.tv_sec <= 0) {
			age(0);
			continue;
		}
		if (timercmp(&result, &select_timeout, < /* */))
			select_timeout = result;

		/*
		 * take care of router discovery.  We compare timeval
		 * structures here to have millisecond granularity.
		 */
		if (!timercmp(&rdisc_timer, &now, > /* */)) {
			rdisc_age(0);
			continue;
		}
		timevalsub(&result, &rdisc_timer, &now);
		if (timercmp(&result, &select_timeout, < /* */))
			select_timeout = result;

		/*
		 * Well-known bit of select(3c) silliness inherited
		 * from BSD: anything over 100 million seconds is
		 * considered an "error."  Reset that to zero.
		 */
		if (select_timeout.tv_sec > 100000000)
			select_timeout.tv_sec = 0;

		/* wait for input or a timer to expire. */
		trace_flush();
		ibits = fdbits;
		n = select(sock_max, &ibits, 0, 0, &select_timeout);
		if (n <= 0) {
			if (n < 0 && errno != EINTR && errno != EAGAIN)
				BADERR(_B_TRUE, "select");
			continue;
		}

		if (FD_ISSET(rt_sock, &ibits)) {
			read_rt();
			n--;
		}
		if (rdisc_sock >= 0 && FD_ISSET(rdisc_sock, &ibits)) {
			read_d();
			n--;
		}
		if (rdisc_mib_sock >= 0 && FD_ISSET(rdisc_mib_sock, &ibits)) {
			process_d_mib_sock();
			n--;
		}
		if (rip_sock >= 0 && FD_ISSET(rip_sock, &ibits)) {
			if (read_rip() == -1) {
				rip_enabled = _B_FALSE;
				trace_off("main rip socket failed");
				(void) close(rip_sock);
				rip_sock = -1;
				fix_select();
				break;
			}
			n--;
		}
	}
	rip_bcast(0);
	rdisc_adv(_B_FALSE);
	(void) unlink(PATH_PID);
	return (stopint | 128);
}


static void
sigalrm(int sig)
{
	/*
	 * Historically, SIGALRM would cause the daemon to check for
	 * new and broken interfaces.
	 */
	ifscan_timer.tv_sec = now.tv_sec;
	trace_act("SIGALRM");
	if (signal(sig, sigalrm) == SIG_ERR)
		msglog("signal: %s", rip_strerror(errno));
}


/* watch for fatal signals */
static void
sigterm(int sig)
{
	stopint = sig;
	if (signal(sig, SIG_DFL) == SIG_ERR)	/* catch it only once */
		msglog("signal: %s", rip_strerror(errno));
}


void
fix_select(void)
{
	(void) FD_ZERO(&fdbits);
	sock_max = 0;

	FD_SET(rt_sock, &fdbits);
	if (sock_max <= rt_sock)
		sock_max = rt_sock+1;
	if (rip_sock >= 0) {
		FD_SET(rip_sock, &fdbits);
		if (sock_max <= rip_sock)
			sock_max = rip_sock+1;
	}
	if (rdisc_sock >= 0) {
		FD_SET(rdisc_sock, &fdbits);
		if (sock_max <= rdisc_sock)
			sock_max = rdisc_sock+1;
		FD_SET(rdisc_mib_sock, &fdbits);
		if (sock_max <= rdisc_mib_sock)
			sock_max = rdisc_mib_sock+1;
	}
}


void
fix_sock(int sock,
    const char *name)
{
	int on;
#define	MIN_SOCKBUF (4*1024)
	static int rbuf;

	if (fcntl(sock, F_SETFL, O_NONBLOCK) == -1)
		logbad(_B_TRUE, "fcntl(%s) O_NONBLOCK: %s", name,
		    rip_strerror(errno));
	on = 1;
	if (setsockopt(sock, SOL_SOCKET, SO_BROADCAST, &on, sizeof (on)) < 0)
		msglog("setsockopt(%s,SO_BROADCAST): %s",
		    name, rip_strerror(errno));

	if (rbuf >= MIN_SOCKBUF) {
		if (setsockopt(sock, SOL_SOCKET, SO_RCVBUF,
		    &rbuf, sizeof (rbuf)) < 0)
			msglog("setsockopt(%s,SO_RCVBUF=%d): %s",
			    name, rbuf, rip_strerror(errno));
	} else {
		for (rbuf = 60*1024; ; rbuf -= 4096) {
			if (setsockopt(sock, SOL_SOCKET, SO_RCVBUF,
			    &rbuf, sizeof (rbuf)) == 0) {
				trace_act("RCVBUF=%d", rbuf);
				break;
			}
			if (rbuf < MIN_SOCKBUF) {
				msglog("setsockopt(%s,SO_RCVBUF = %d): %s",
				    name, rbuf, rip_strerror(errno));
				break;
			}
		}
	}
}


/*
 * Open and return the global rip socket.  It is guaranteed to return
 * a good file descriptor.
 */
static int
open_rip_sock()
{
	struct sockaddr_in sin;
	unsigned char ttl;
	int s;
	int on = 1;


	if ((s = socket(PF_INET, SOCK_DGRAM, 0)) < 0)
		BADERR(_B_TRUE, "rip_sock = socket()");

	(void) memset(&sin, 0, sizeof (sin));
	sin.sin_family = AF_INET;
	sin.sin_port = htons(RIP_PORT);
	sin.sin_addr.s_addr = INADDR_ANY;
	if (bind(s, (struct sockaddr *)&sin, sizeof (sin)) < 0) {
		BADERR(_B_FALSE, "bind(rip_sock)");
	}
	fix_sock(s, "rip_sock");

	ttl = 1;
	if (setsockopt(s, IPPROTO_IP, IP_MULTICAST_TTL,
	    &ttl, sizeof (ttl)) < 0)
		DBGERR(_B_TRUE, "rip_sock setsockopt(IP_MULTICAST_TTL)");

	if (setsockopt(s, IPPROTO_IP, IP_RECVIF, &on, sizeof (on)))
		BADERR(_B_FALSE, "setsockopt(IP_RECVIF)");

	return (s);
}


/*
 * Disable RIP.  Note that we don't close the global rip socket since
 * it is used even when RIP is disabled to receive and answer certain
 * queries.
 */
void
rip_off(void)
{
	struct ip_mreq m;
	struct interface *ifp;
	char addrstr[INET_ADDRSTRLEN];

	if (rip_enabled && !mhome) {
		trace_act("turn off RIP");

		/*
		 * Unsubscribe from the 224.0.0.9  RIP multicast
		 * group address
		 */
		for (ifp = ifnet; ifp != NULL; ifp = ifp->int_next) {
			if ((ifp->int_if_flags & IFF_MULTICAST) &&
			    !IS_IFF_QUIET(ifp->int_if_flags) &&
			    !IS_RIP_IN_OFF(ifp->int_state) &&
			    !(ifp->int_state & IS_DUP)) {
				m.imr_multiaddr.s_addr =
				    htonl(INADDR_RIP_GROUP);
				m.imr_interface.s_addr =
				    (ifp->int_if_flags & IFF_POINTOPOINT) ?
				    ifp->int_dstaddr : ifp->int_addr;
				(void) strlcpy(addrstr,
				    inet_ntoa(m.imr_multiaddr),
				    sizeof (addrstr));
				if (setsockopt(rip_sock, IPPROTO_IP,
				    IP_DROP_MEMBERSHIP, &m,
				    sizeof (m)) < 0 &&
				    errno != EADDRNOTAVAIL && errno != ENOENT)
					writelog(LOG_WARNING,
					    "%s: setsockopt(IP_DROP_MEMBERSHIP "
					    "%s, %s): %s", ifp->int_name,
					    addrstr, inet_ntoa(m.imr_interface),
					    rip_strerror(errno));
			}
		}
		rip_enabled = _B_FALSE;

		age(0);
	}
}


/* turn on RIP multicast input via an interface */
void
rip_mcast_on(struct interface *ifp)
{
	struct ip_mreq m;

	if (!IS_RIP_IN_OFF(ifp->int_state) &&
	    (ifp->int_if_flags & IFF_MULTICAST) &&
	    !IS_IFF_QUIET(ifp->int_if_flags) &&
	    !(ifp->int_state & IS_DUP)) {
		m.imr_multiaddr.s_addr = htonl(INADDR_RIP_GROUP);
		m.imr_interface.s_addr = (ifp->int_if_flags & IFF_POINTOPOINT) ?
		    ifp->int_dstaddr : ifp->int_addr;
		if ((setsockopt(rip_sock, IPPROTO_IP, IP_ADD_MEMBERSHIP,
		    &m, sizeof (m)) < 0) && !(ifp->int_state & IS_BROKE))
			writelog(LOG_WARNING,
			    "Could not join 224.0.0.9 on interface %s: %s",
			    ifp->int_name, rip_strerror(errno));
	}
}

/* turn off RIP multicast input via an interface */
void
rip_mcast_off(struct interface *ifp)
{
	struct ip_mreq m;

	if ((ifp->int_if_flags & IFF_MULTICAST) &&
	    !IS_IFF_QUIET(ifp->int_if_flags) && rip_enabled) {
		m.imr_multiaddr.s_addr = htonl(INADDR_RIP_GROUP);
		m.imr_interface.s_addr = (ifp->int_if_flags & IFF_POINTOPOINT) ?
		    ifp->int_dstaddr : ifp->int_addr;
		if ((setsockopt(rip_sock, IPPROTO_IP, IP_DROP_MEMBERSHIP,
		    &m, sizeof (m)) < 0) && errno != EADDRNOTAVAIL &&
		    errno != ENOENT)
			writelog(LOG_WARNING,
			    "setsockopt(IP_DROP_MEMBERSHIP RIP) for %s: %s",
			    ifp->int_name, rip_strerror(errno));
	}
}

/* enable RIP */
void
rip_on(struct interface *ifp)
{
	/*
	 * If RIP is already enabled, only start receiving
	 * multicasts for this interface.
	 */
	if (rip_enabled) {
		if (ifp != NULL)
			rip_mcast_on(ifp);
		return;
	}

	/*
	 * If RIP is disabled and it makes sense to enable it, then enable
	 * it on all of the interfaces.  It makes sense if either router
	 * discovery is off, or if router discovery is on and at most one
	 * interface is doing RIP.
	 */
	if (rip_interfaces > 0 && (!rdisc_ok || rip_interfaces > 1)) {
		trace_act("turn on RIP");

		rip_enabled = _B_TRUE;
		rip_sock_interface = NULL;

		/* Do not advertise anything until we have heard something */
		if (next_bcast.tv_sec < now.tv_sec+MIN_WAITTIME)
			next_bcast.tv_sec = now.tv_sec+MIN_WAITTIME;

		for (ifp = ifnet; ifp != NULL; ifp = ifp->int_next) {
			ifp->int_query_time = NEVER;
			rip_mcast_on(ifp);
		}
		ifscan_timer.tv_sec = now.tv_sec;
	}

	fix_select();
}


/* die if malloc(3) fails */
void *
rtmalloc(size_t size,
    const char *msg)
{
	void *p = malloc(size);
	if (p == NULL)
		logbad(_B_TRUE, "malloc(%lu) failed in %s: %s", (ulong_t)size,
		    msg, rip_strerror(errno));
	return (p);
}


/* get a random instant in an interval */
void
intvl_random(struct timeval *tp,	/* put value here */
    ulong_t lo,			/* value is after this second */
    ulong_t hi)			/* and before this */
{
	tp->tv_sec = (time_t)(hi == lo ? lo : (lo + random() % ((hi - lo))));
	tp->tv_usec = random() % 1000000;
}


void
timevaladd(struct timeval *t1,
    struct timeval *t2)
{

	t1->tv_sec += t2->tv_sec;
	if ((t1->tv_usec += t2->tv_usec) >= 1000000) {
		t1->tv_sec++;
		t1->tv_usec -= 1000000;
	}
}


/* t1 = t2 - t3 */
static void
timevalsub(struct timeval *t1,
    struct timeval *t2,
    struct timeval *t3)
{
	t1->tv_sec = t2->tv_sec - t3->tv_sec;
	if ((t1->tv_usec = t2->tv_usec - t3->tv_usec) < 0) {
		t1->tv_sec--;
		t1->tv_usec += 1000000;
	}
}

static void
do_openlog(void)
{
	openlog_done = _B_TRUE;
	openlog("in.routed", LOG_PID | LOG_ODELAY, LOG_DAEMON);
}

/* put a LOG_ERR message into the system log */
void
msglog(const char *p, ...)
{
	va_list args;

	trace_flush();

	if (!openlog_done)
		do_openlog();
	va_start(args, p);
	vsyslog(LOG_ERR, p, args);

	if (ftrace != 0) {
		if (ftrace == stdout)
			(void) fputs("in.routed: ", ftrace);
		(void) vfprintf(ftrace, p, args);
		(void) fputc('\n', ftrace);
	}
}


/*
 * Put a message about a bad system into the system log if
 * we have not complained about it recently.
 *
 * It is desirable to complain about all bad systems, but not too often.
 * In the worst case, it is not practical to keep track of all bad systems.
 * For example, there can be many systems with the wrong password.
 */
void
msglim(struct msg_limit *lim, in_addr_t addr, const char *p, ...)
{
	va_list args;
	int i;
	struct msg_sub *ms1, *ms;
	const char *p1;

	va_start(args, p);

	/*
	 * look for the oldest slot in the table
	 * or the slot for the bad router.
	 */
	ms = ms1 = lim->subs;
	for (i = MSG_SUBJECT_N; ; i--, ms1++) {
		if (i == 0) {
			/* Reuse a slot at most once every 10 minutes. */
			if (lim->reuse > now.tv_sec) {
				ms = NULL;
			} else {
				lim->reuse = now.tv_sec + 10*60;
			}
			break;
		}
		if (ms->addr == addr) {
			/*
			 * Repeat a complaint about a given system at
			 * most once an hour.
			 */
			if (ms->until > now.tv_sec)
				ms = NULL;
			break;
		}
		if (ms->until < ms1->until)
			ms = ms1;
	}
	if (ms != NULL) {
		ms->addr = addr;
		ms->until = now.tv_sec + 60*60;	/* 60 minutes */

		if (!openlog_done)
			do_openlog();
		trace_flush();
		for (p1 = p; *p1 == ' '; p1++)
			continue;
		vsyslog(LOG_ERR, p1, args);
	}

	/* always display the message if tracing */
	if (ftrace != 0) {
		(void) vfprintf(ftrace, p, args);
		(void) fputc('\n', ftrace);
	}
}


void
logbad(boolean_t dump, const char *p, ...)
{
	va_list args;

	trace_flush();

	if (!openlog_done)
		do_openlog();
	va_start(args, p);
	vsyslog(LOG_ERR, p, args);

	(void) fputs(gettext("in.routed: "), stderr);
	(void) vfprintf(stderr, p, args);
	(void) fputs(gettext("; giving up\n"), stderr);
	(void) fflush(stderr);

	if (dump)
		abort();
	exit(EXIT_FAILURE);
}

/* put a message into the system log */
void
writelog(int level, const char *p, ...)
{
	va_list args;

	trace_flush();

	if (!openlog_done)
		do_openlog();
	va_start(args, p);
	vsyslog(level, p, args);

	if (ftrace != 0) {
		if (ftrace == stdout)
			(void) fputs("in.routed: ", ftrace);
		(void) vfprintf(ftrace, p, args);
		(void) fputc('\n', ftrace);
	}
}



/* ============================================================================
 * SOURCE 83/98: minix4\exokernel\kernel_legacy\cmd\cmd-inet\usr.lib\bridged\main.c
 * Size: 5,593 bytes, Lines: 252
 * Hash: f90cd70dcacb...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

/*
 * bridged - bridging control daemon.
 */

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#include <string.h>
#include <signal.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <syslog.h>
#include <locale.h>
#include <stropts.h>

#include "global.h"

boolean_t debugging;
uint32_t tablemax;
const char *instance_name = "default";

struct pollfd *fdarray;

dladm_handle_t dlhandle;

boolean_t shutting_down;

static pthread_t sighand;

/*
 * engine_lock is held while the main loop is busy calling librstp functions.
 * Door threads take the lock to protect the library from reentrancy.
 */
static pthread_mutex_t engine_lock = PTHREAD_MUTEX_INITIALIZER;

/*
 * These wrapper functions allow the other components in the daemon to remain
 * ignorant of pthreads details.
 */
int
lock_engine(void)
{
	return (pthread_mutex_lock(&engine_lock));
}

void
unlock_engine(void)
{
	(void) pthread_mutex_unlock(&engine_lock);
}

/*
 * Utility function for STREAMS ioctls.
 */
ssize_t
strioctl(int fd, int cmd, void *buf, size_t buflen)
{
	int retv;
	struct strioctl ic;

	ic.ic_cmd = cmd;
	ic.ic_timout = 0;
	ic.ic_dp = buf;
	ic.ic_len = buflen;
	if ((retv = ioctl(fd, I_STR, &ic)) != 0)
		return (retv);
	else
		return (ic.ic_len);
}

static void
daemonize(void)
{
	pid_t pid;

	/*
	 * A little bit of magic here.  By the first fork+setsid, we
	 * disconnect from our current controlling terminal and become
	 * a session group leader.  By forking again without calling
	 * setsid again, we make certain that we are not the session
	 * group leader and can never reacquire a controlling terminal.
	 */
	if ((pid = fork()) == (pid_t)-1) {
		syslog(LOG_ERR, "fork 1 failed");
		exit(EXIT_FAILURE);
	}
	if (pid != 0) {
		(void) wait(NULL);
		_exit(EXIT_SUCCESS);
	}
	if (setsid() == (pid_t)-1) {
		syslog(LOG_ERR, "setsid");
		exit(EXIT_FAILURE);
	}
	if ((pid = fork()) == (pid_t)-1) {
		syslog(LOG_ERR, "fork 2 failed");
		exit(EXIT_FAILURE);
	}
	if (pid != 0)
		_exit(EXIT_SUCCESS);
	(void) chdir("/");
	(void) umask(022);
}

static void *
sighandler(void *arg)
{
	sigset_t sigset;
	int sig;
	int sigfd = (int)(uintptr_t)arg;

	(void) sigfillset(&sigset);

	for (;;) {
		sig = sigwait(&sigset);
		switch (sig) {
		case SIGHUP:
			(void) write(sigfd, "", 1);
			break;

		default:
			if (debugging)
				syslog(LOG_NOTICE, "%s signal, shutting down",
				    strsignal(sig));
			shutting_down = B_TRUE;
			break;
		}

		/* if we're shutting down, exit this thread */
		if (shutting_down)
			return (NULL);
	}
}

static void
init_signalhandling(void)
{
	pthread_attr_t attr;
	int err;
	sigset_t new;
	int fildes[2];

	if ((fdarray = malloc(FDOFFSET * sizeof (struct pollfd))) == NULL) {
		syslog(LOG_ERR, "unable to allocate fdarray: %m");
		exit(EXIT_FAILURE);
	}
	if (pipe(fildes) != 0) {
		syslog(LOG_ERR, "unable to create signal pipe: %m");
		exit(EXIT_FAILURE);
	}
	fdarray[0].fd = fildes[0];
	fdarray[0].events = POLLIN;
	assert(control_fd != -1);
	fdarray[1].fd = control_fd;
	fdarray[1].events = POLLIN;

	(void) sigfillset(&new);
	(void) pthread_sigmask(SIG_BLOCK, &new, NULL);
	(void) pthread_attr_init(&attr);
	(void) pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	err = pthread_create(&sighand, &attr, sighandler,
	    (void *)(uintptr_t)fildes[1]);
	if (err != 0) {
		syslog(LOG_ERR, "cannot create signal handling thread: %s",
		    strerror(err));
		exit(EXIT_FAILURE);
	}
	(void) pthread_attr_destroy(&attr);
}

int
main(int argc, char **argv)
{
	dladm_status_t status;
	char buf[DLADM_STRSIZE];

	(void) setlocale(LC_ALL, "");
	(void) textdomain(TEXT_DOMAIN);

	shutting_down = B_FALSE;
	openlog("bridged", LOG_PID | LOG_NDELAY, LOG_DAEMON);

	if (argc != 2) {
		syslog(LOG_ERR, "instance name is required");
		exit(EXIT_FAILURE);
	}

	instance_name = argv[1];

	if ((status = dladm_open(&dlhandle)) != DLADM_STATUS_OK) {
		syslog(LOG_ERR, "%s: unable to open datalink control: %s",
		    instance_name, dladm_status2str(status, buf));
		exit(EXIT_FAILURE);
	}

	status = dladm_bridge_get_privprop(instance_name, &debugging,
	    &tablemax);
	if (status != DLADM_STATUS_OK) {
		syslog(LOG_ERR, "%s: unable to read properties: %s",
		    instance_name, dladm_status2str(status, buf));
		exit(EXIT_FAILURE);
	}

	/* Get the properties once so that we have the right initial values */
	rstp_init();

	open_bridge_control();

	daemonize();

	init_signalhandling();
	init_door();

	if (debugging)
		syslog(LOG_INFO, "bridged started: instance %s", instance_name);

	event_loop();
	(void) pthread_cancel(sighand);
	(void) pthread_join(sighand, NULL);

	return (0);
}



/* ============================================================================
 * SOURCE 84/98: minix4\exokernel\kernel_legacy\cmd\cmd-inet\usr.lib\in.ndpd\main.c
 * Size: 66,774 bytes, Lines: 2,599
 * Hash: b913569ea036...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright (c) 1999, 2010, Oracle and/or its affiliates. All rights reserved.
 * Copyright 2024 Oxide Computer Company
 */

#include "defs.h"
#include "tables.h"
#include <fcntl.h>
#include <sys/un.h>

static void	initlog(void);
static void	run_timeouts(void);

static void	advertise(struct sockaddr_in6 *sin6, struct phyint *pi,
		    boolean_t no_prefixes);
static void	solicit(struct sockaddr_in6 *sin6, struct phyint *pi);
static void	initifs(boolean_t first);
static void	check_if_removed(struct phyint *pi);
static void	loopback_ra_enqueue(struct phyint *pi,
		    struct nd_router_advert *ra, int len);
static void	loopback_ra_dequeue(void);
static void	check_daemonize(void);

struct in6_addr all_nodes_mcast = { { 0xff, 0x2, 0x0, 0x0,
				    0x0, 0x0, 0x0, 0x0,
				    0x0, 0x0, 0x0, 0x0,
				    0x0, 0x0, 0x0, 0x1 } };

struct in6_addr all_routers_mcast = { { 0xff, 0x2, 0x0, 0x0,
				    0x0, 0x0, 0x0, 0x0,
				    0x0, 0x0, 0x0, 0x0,
				    0x0, 0x0, 0x0, 0x2 } };

static struct sockaddr_in6 v6allnodes = { AF_INET6, 0, 0,
				    { 0xff, 0x2, 0x0, 0x0,
				    0x0, 0x0, 0x0, 0x0,
				    0x0, 0x0, 0x0, 0x0,
				    0x0, 0x0, 0x0, 0x1 } };

static struct sockaddr_in6 v6allrouters = { AF_INET6, 0, 0,
				    { 0xff, 0x2, 0x0, 0x0,
				    0x0, 0x0, 0x0, 0x0,
				    0x0, 0x0, 0x0, 0x0,
				    0x0, 0x0, 0x0, 0x2 } };

static char **argv0;		/* Saved for re-exec on SIGHUP */

static uint64_t packet[(IP_MAXPACKET + 1)/8];

static int	show_ifs = 0;
static boolean_t	already_daemonized = _B_FALSE;
int		debug = 0;
int		no_loopback = 0; /* Do not send RA packets to ourselves */

/*
 * Size of routing socket message used by in.ndpd which includes the header,
 * space for the RTA_DST, RTA_GATEWAY and RTA_NETMASK (each a sockaddr_in6)
 * plus space for the RTA_IFP (a sockaddr_dl).
 */
#define	NDP_RTM_MSGLEN	sizeof (struct rt_msghdr) +	\
			sizeof (struct sockaddr_in6) +	\
			sizeof (struct sockaddr_in6) +	\
			sizeof (struct sockaddr_in6) +	\
			sizeof (struct sockaddr_dl)

/*
 * These are referenced externally in tables.c in order to fill in the
 * dynamic portions of the routing socket message and then to send the message
 * itself.
 */
int	rtsock = -1;			/* Routing socket */
struct	rt_msghdr	*rt_msg;	/* Routing socket message */
struct	sockaddr_in6	*rta_gateway;	/* RTA_GATEWAY sockaddr */
struct	sockaddr_dl	*rta_ifp;	/* RTA_IFP sockaddr */

/*
 * These sockets are used internally in this file.
 */
static int	mibsock = -1;			/* mib request socket */
static int	cmdsock = -1;			/* command socket */

static	int	ndpd_setup_cmd_listener(void);
static	void	ndpd_cmd_handler(int);
static	int	ndpd_process_cmd(int, ipadm_ndpd_msg_t *);
static	int	ndpd_send_error(int, int);
static	int	ndpd_set_autoconf(const char *, boolean_t);
static	int	ndpd_create_addrs(const char *, struct sockaddr_in6, int,
    boolean_t, boolean_t, char *);
static	int	ndpd_delete_addrs(const char *);
static	int	phyint_check_ipadm_intfid(struct phyint *);

/*
 * Return the current time in milliseconds truncated to
 * fit in an integer.
 */
uint_t
getcurrenttime(void)
{
	struct timeval tp;

	if (gettimeofday(&tp, NULL) < 0) {
		logperror("getcurrenttime: gettimeofday failed");
		exit(1);
	}
	return (tp.tv_sec * 1000 + tp.tv_usec / 1000);
}

/*
 * Output a preformated packet from the packet[] buffer.
 */
static void
sendpacket(struct sockaddr_in6 *sin6, int sock, int size, int flags)
{
	int cc;
	char abuf[INET6_ADDRSTRLEN];

	cc = sendto(sock, (char *)packet, size, flags,
	    (struct sockaddr *)sin6, sizeof (*sin6));
	if (cc < 0 || cc != size) {
		if (cc < 0) {
			logperror("sendpacket: sendto");
		}
		logmsg(LOG_ERR, "sendpacket: wrote %s %d chars, ret=%d\n",
		    inet_ntop(sin6->sin6_family,
		    (void *)&sin6->sin6_addr,
		    abuf, sizeof (abuf)),
		    size, cc);
	}
}

/*
 * If possible, place an ND_OPT_SOURCE_LINKADDR option at `optp'.
 * Return the number of bytes placed in the option.
 */
static uint_t
add_opt_lla(struct phyint *pi, struct nd_opt_lla *optp)
{
	uint_t optlen;
	uint_t hwaddrlen;
	struct lifreq lifr;

	/* If this phyint doesn't have a link-layer address, bail */
	if (phyint_get_lla(pi, &lifr) == -1)
		return (0);

	hwaddrlen = lifr.lifr_nd.lnr_hdw_len;
	/* roundup to multiple of 8 and make padding zero */
	optlen = ((sizeof (struct nd_opt_hdr) + hwaddrlen + 7) / 8) * 8;
	bzero(optp, optlen);
	optp->nd_opt_lla_type = ND_OPT_SOURCE_LINKADDR;
	optp->nd_opt_lla_len = optlen / 8;
	bcopy(lifr.lifr_nd.lnr_hdw_addr, optp->nd_opt_lla_hdw_addr, hwaddrlen);

	return (optlen);
}

/* Send a Router Solicitation */
static void
solicit(struct sockaddr_in6 *sin6, struct phyint *pi)
{
	int packetlen = 0;
	struct	nd_router_solicit *rs = (struct nd_router_solicit *)packet;
	char *pptr = (char *)packet;

	rs->nd_rs_type = ND_ROUTER_SOLICIT;
	rs->nd_rs_code = 0;
	rs->nd_rs_cksum = htons(0);
	rs->nd_rs_reserved = htonl(0);

	packetlen += sizeof (*rs);
	pptr += sizeof (*rs);

	/* add options */
	packetlen += add_opt_lla(pi, (struct nd_opt_lla *)pptr);

	if (debug & D_PKTOUT) {
		print_route_sol("Sending solicitation to ", pi, rs, packetlen,
		    sin6);
	}
	sendpacket(sin6, pi->pi_sock, packetlen, 0);
}

/*
 * Send a (set of) Router Advertisements and feed them back to ourselves
 * for processing. Unless no_prefixes is set all prefixes are included.
 * If there are too many prefix options to fit in one packet multiple
 * packets will be sent - each containing a subset of the prefix options.
 */
static void
advertise(struct sockaddr_in6 *sin6, struct phyint *pi, boolean_t no_prefixes)
{
	struct	nd_opt_prefix_info *po;
	char *pptr = (char *)packet;
	struct nd_router_advert *ra;
	struct adv_prefix *adv_pr;
	int packetlen = 0;

	ra = (struct nd_router_advert *)pptr;
	ra->nd_ra_type = ND_ROUTER_ADVERT;
	ra->nd_ra_code = 0;
	ra->nd_ra_cksum = htons(0);
	ra->nd_ra_curhoplimit = pi->pi_AdvCurHopLimit;
	ra->nd_ra_flags_reserved = 0;
	if (pi->pi_AdvManagedFlag)
		ra->nd_ra_flags_reserved |= ND_RA_FLAG_MANAGED;
	if (pi->pi_AdvOtherConfigFlag)
		ra->nd_ra_flags_reserved |= ND_RA_FLAG_OTHER;

	if (pi->pi_adv_state == FINAL_ADV)
		ra->nd_ra_router_lifetime = htons(0);
	else
		ra->nd_ra_router_lifetime = htons(pi->pi_AdvDefaultLifetime);
	ra->nd_ra_reachable = htonl(pi->pi_AdvReachableTime);
	ra->nd_ra_retransmit = htonl(pi->pi_AdvRetransTimer);

	packetlen = sizeof (*ra);
	pptr += sizeof (*ra);

	if (pi->pi_adv_state == FINAL_ADV) {
		if (debug & D_PKTOUT) {
			print_route_adv("Sending advert (FINAL) to ", pi,
			    ra, packetlen, sin6);
		}
		sendpacket(sin6, pi->pi_sock, packetlen, 0);
		/* Feed packet back in for router operation */
		loopback_ra_enqueue(pi, ra, packetlen);
		return;
	}

	/* add options */
	packetlen += add_opt_lla(pi, (struct nd_opt_lla *)pptr);
	pptr = (char *)packet + packetlen;

	if (pi->pi_AdvLinkMTU != 0) {
		struct nd_opt_mtu *mo = (struct nd_opt_mtu *)pptr;

		mo->nd_opt_mtu_type = ND_OPT_MTU;
		mo->nd_opt_mtu_len = sizeof (struct nd_opt_mtu) / 8;
		mo->nd_opt_mtu_reserved = 0;
		mo->nd_opt_mtu_mtu = htonl(pi->pi_AdvLinkMTU);

		packetlen += sizeof (struct nd_opt_mtu);
		pptr += sizeof (struct nd_opt_mtu);
	}

	if (no_prefixes) {
		if (debug & D_PKTOUT) {
			print_route_adv("Sending advert to ", pi,
			    ra, packetlen, sin6);
		}
		sendpacket(sin6, pi->pi_sock, packetlen, 0);
		/* Feed packet back in for router operation */
		loopback_ra_enqueue(pi, ra, packetlen);
		return;
	}

	po = (struct nd_opt_prefix_info *)pptr;
	for (adv_pr = pi->pi_adv_prefix_list; adv_pr != NULL;
	    adv_pr = adv_pr->adv_pr_next) {
		if (!adv_pr->adv_pr_AdvOnLinkFlag &&
		    !adv_pr->adv_pr_AdvAutonomousFlag) {
			continue;
		}

		/*
		 * If the prefix doesn't fit in packet send
		 * what we have so far and start with new packet.
		 */
		if (packetlen + sizeof (*po) >
		    pi->pi_LinkMTU - sizeof (struct ip6_hdr)) {
			if (debug & D_PKTOUT) {
				print_route_adv("Sending advert "
				    "(FRAG) to ",
				    pi, ra, packetlen, sin6);
			}
			sendpacket(sin6, pi->pi_sock, packetlen, 0);
			/* Feed packet back in for router operation */
			loopback_ra_enqueue(pi, ra, packetlen);
			packetlen = sizeof (*ra);
			pptr = (char *)packet + sizeof (*ra);
			po = (struct nd_opt_prefix_info *)pptr;
		}
		po->nd_opt_pi_type = ND_OPT_PREFIX_INFORMATION;
		po->nd_opt_pi_len = sizeof (*po)/8;
		po->nd_opt_pi_flags_reserved = 0;
		if (adv_pr->adv_pr_AdvOnLinkFlag) {
			po->nd_opt_pi_flags_reserved |=
			    ND_OPT_PI_FLAG_ONLINK;
		}
		if (adv_pr->adv_pr_AdvAutonomousFlag) {
			po->nd_opt_pi_flags_reserved |=
			    ND_OPT_PI_FLAG_AUTO;
		}
		po->nd_opt_pi_prefix_len = adv_pr->adv_pr_prefix_len;
		/*
		 * If both Adv*Expiration and Adv*Lifetime are
		 * set we prefer the former and make the lifetime
		 * decrement in real time.
		 */
		if (adv_pr->adv_pr_AdvValidRealTime) {
			po->nd_opt_pi_valid_time =
			    htonl(adv_pr->adv_pr_AdvValidExpiration);
		} else {
			po->nd_opt_pi_valid_time =
			    htonl(adv_pr->adv_pr_AdvValidLifetime);
		}
		if (adv_pr->adv_pr_AdvPreferredRealTime) {
			po->nd_opt_pi_preferred_time =
			    htonl(adv_pr->adv_pr_AdvPreferredExpiration);
		} else {
			po->nd_opt_pi_preferred_time =
			    htonl(adv_pr->adv_pr_AdvPreferredLifetime);
		}
		po->nd_opt_pi_reserved2 = htonl(0);
		po->nd_opt_pi_prefix = adv_pr->adv_pr_prefix;

		po++;
		packetlen += sizeof (*po);
	}
	if (debug & D_PKTOUT) {
		print_route_adv("Sending advert to ", pi,
		    ra, packetlen, sin6);
	}
	sendpacket(sin6, pi->pi_sock, packetlen, 0);
	/* Feed packet back in for router operation */
	loopback_ra_enqueue(pi, ra, packetlen);
}

/* Poll support */
static int		pollfd_num = 0;	/* Allocated and initialized */
static struct pollfd	*pollfds = NULL;

/*
 * Add fd to the set being polled. Returns 0 if ok; -1 if failed.
 */
int
poll_add(int fd)
{
	int i;
	int new_num;
	struct pollfd *newfds;

	/* Check if already present */
	for (i = 0; i < pollfd_num; i++) {
		if (pollfds[i].fd == fd)
			return (0);
	}
	/* Check for empty spot already present */
	for (i = 0; i < pollfd_num; i++) {
		if (pollfds[i].fd == -1) {
			pollfds[i].fd = fd;
			return (0);
		}
	}

	/* Allocate space for 32 more fds and initialize to -1 */
	new_num = pollfd_num + 32;
	newfds = realloc(pollfds, new_num * sizeof (struct pollfd));
	if (newfds == NULL) {
		logperror("realloc");
		return (-1);
	}

	newfds[pollfd_num].fd = fd;
	newfds[pollfd_num++].events = POLLIN;

	for (i = pollfd_num; i < new_num; i++) {
		newfds[i].fd = -1;
		newfds[i].events = POLLIN;
	}
	pollfd_num = new_num;
	pollfds = newfds;
	return (0);
}

/*
 * Remove fd from the set being polled. Returns 0 if ok; -1 if failed.
 */
int
poll_remove(int fd)
{
	int i;

	/* Check if already present */
	for (i = 0; i < pollfd_num; i++) {
		if (pollfds[i].fd == fd) {
			pollfds[i].fd = -1;
			return (0);
		}
	}
	return (-1);
}

/*
 * Extract information about the ifname (either a physical interface and
 * the ":0" logical interface or just a logical interface).
 * If the interface (still) exists in kernel set pr_in_use
 * for caller to be able to detect interfaces that are removed.
 * Starts sending advertisements/solicitations when new physical interfaces
 * are detected.
 */
static void
if_process(int s, char *ifname, boolean_t first)
{
	struct lifreq lifr;
	struct phyint *pi;
	struct prefix *pr;
	char *cp;
	char phyintname[LIFNAMSIZ + 1];

	if (debug & D_IFSCAN)
		logmsg(LOG_DEBUG, "if_process(%s)\n", ifname);

	(void) strncpy(lifr.lifr_name, ifname, sizeof (lifr.lifr_name));
	lifr.lifr_name[sizeof (lifr.lifr_name) - 1] = '\0';
	if (ioctl(s, SIOCGLIFFLAGS, (char *)&lifr) < 0) {
		if (errno == ENXIO) {
			/*
			 * Interface has disappeared
			 */
			return;
		}
		logperror("if_process: ioctl (get interface flags)");
		return;
	}

	/*
	 * Ignore loopback, point-to-multipoint and VRRP interfaces.
	 * The IP addresses over VRRP interfaces cannot be auto-configured.
	 * Point-to-point interfaces always have IFF_MULTICAST set.
	 */
	if (!(lifr.lifr_flags & IFF_MULTICAST) ||
	    (lifr.lifr_flags & (IFF_LOOPBACK|IFF_VRRP))) {
		return;
	}

	if (!(lifr.lifr_flags & IFF_IPV6))
		return;

	(void) strncpy(phyintname, ifname, sizeof (phyintname));
	phyintname[sizeof (phyintname) - 1] = '\0';
	if ((cp = strchr(phyintname, IF_SEPARATOR)) != NULL) {
		*cp = '\0';
	}

	pi = phyint_lookup(phyintname);
	if (pi == NULL) {
		pi = phyint_create(phyintname);
		if (pi == NULL) {
			logmsg(LOG_ERR, "if_process: out of memory\n");
			return;
		}
	} else {
		/*
		 * if the phyint already exists, synchronize it with
		 * the kernel state. For a newly created phyint, phyint_create
		 * calls phyint_init_from_k().
		 */
		(void) phyint_init_from_k(pi);
	}
	/*
	 * Immediately after restart, check with ipmgmtd if there is
	 * any interface id to be configured for this interface.  If
	 * interface configuration is still in progress as we're
	 * starting, this will clear pi->pi_autoconf so we don't get
	 * ahead of ourselves; ipadm will poke us later to turn it
	 * back on to restart configuration.
	 */
	if (first) {
		if (phyint_check_ipadm_intfid(pi) == -1)
			logmsg(LOG_ERR, "Could not get ipadm info\n");
	}
	if (pi->pi_sock == -1 && !(pi->pi_kernel_state & PI_PRESENT)) {
		/* Interface is not yet present */
		if (debug & D_PHYINT) {
			logmsg(LOG_DEBUG, "if_process: interface not yet "
			    "present %s\n", pi->pi_name);
		}
		return;
	}

	if (pi->pi_sock != -1) {
		if (poll_add(pi->pi_sock) == -1) {
			/*
			 * reset state.
			 */
			phyint_cleanup(pi);
		}
	}

	/*
	 * Check if IFF_ROUTER has been turned off in kernel in which
	 * case we have to turn off AdvSendAdvertisements.
	 * The kernel will automatically turn off IFF_ROUTER if
	 * ip6_forwarding is turned off.
	 * Note that we do not switch back should IFF_ROUTER be turned on.
	 */
	if (!first &&
	    pi->pi_AdvSendAdvertisements && !(pi->pi_flags & IFF_ROUTER)) {
		logmsg(LOG_INFO, "No longer a router on %s\n", pi->pi_name);
		check_to_advertise(pi, START_FINAL_ADV);

		pi->pi_AdvSendAdvertisements = 0;
		pi->pi_sol_state = NO_SOLICIT;
	}

	/*
	 * Send advertisments and solicitation only if the interface is
	 * present in the kernel.
	 */
	if (pi->pi_kernel_state & PI_PRESENT) {

		if (pi->pi_AdvSendAdvertisements) {
			if (pi->pi_adv_state == NO_ADV)
				check_to_advertise(pi, START_INIT_ADV);
		} else {
			if (pi->pi_sol_state == NO_SOLICIT)
				check_to_solicit(pi, START_INIT_SOLICIT);
		}
	}

	/*
	 * Track static kernel prefixes to prevent in.ndpd from clobbering
	 * them by creating a struct prefix for each prefix detected in the
	 * kernel.
	 */
	pr = prefix_lookup_name(pi, ifname);
	if (pr == NULL) {
		pr = prefix_create_name(pi, ifname);
		if (pr == NULL) {
			logmsg(LOG_ERR, "if_process: out of memory\n");
			return;
		}
		if (prefix_init_from_k(pr) == -1) {
			prefix_delete(pr);
			return;
		}
	}
	/* Detect prefixes which are removed */
	if (pr->pr_kernel_state != 0)
		pr->pr_in_use = _B_TRUE;

	if ((lifr.lifr_flags & IFF_DUPLICATE) &&
	    !(lifr.lifr_flags & IFF_DHCPRUNNING) &&
	    (pr->pr_flags & IFF_TEMPORARY)) {
		in6_addr_t *token;
		int i;
		char abuf[INET6_ADDRSTRLEN];

		if (++pr->pr_attempts >= MAX_DAD_FAILURES) {
			logmsg(LOG_ERR, "%s: token %s is duplicate after %d "
			    "attempts; disabling temporary addresses on %s",
			    pr->pr_name, inet_ntop(AF_INET6,
			    (void *)&pi->pi_tmp_token, abuf, sizeof (abuf)),
			    pr->pr_attempts, pi->pi_name);
			pi->pi_TmpAddrsEnabled = 0;
			tmptoken_delete(pi);
			prefix_delete(pr);
			return;
		}
		logmsg(LOG_WARNING, "%s: token %s is duplicate; trying again",
		    pr->pr_name, inet_ntop(AF_INET6, (void *)&pi->pi_tmp_token,
		    abuf, sizeof (abuf)));
		if (!tmptoken_create(pi)) {
			prefix_delete(pr);
			return;
		}
		token = &pi->pi_tmp_token;
		for (i = 0; i < 16; i++) {
			/*
			 * prefix_create ensures that pr_prefix has all-zero
			 * bits after prefixlen.
			 */
			pr->pr_address.s6_addr[i] = pr->pr_prefix.s6_addr[i] |
			    token->s6_addr[i];
		}
		if (prefix_lookup_addr_match(pr) != NULL) {
			prefix_delete(pr);
			return;
		}
		pr->pr_CreateTime = getcurrenttime() / MILLISEC;
		/*
		 * We've got a new token.  Clearing PR_AUTO causes
		 * prefix_update_k to bring the interface up and set the
		 * address.
		 */
		pr->pr_kernel_state &= ~PR_AUTO;
		prefix_update_k(pr);
	}
}

static int ifsock = -1;

/*
 * Scan all interfaces to detect changes as well as new and deleted intefaces
 * 'first' is set for the initial call only. Do not effect anything.
 */
static void
initifs(boolean_t first)
{
	char *buf;
	int bufsize;
	int numifs;
	int n;
	struct lifnum lifn;
	struct lifconf lifc;
	struct lifreq *lifr;
	struct phyint *pi;
	struct phyint *next_pi;
	struct prefix *pr;

	if (debug & D_IFSCAN)
		logmsg(LOG_DEBUG, "Reading interface configuration\n");
	if (ifsock < 0) {
		ifsock = socket(AF_INET6, SOCK_DGRAM, 0);
		if (ifsock < 0) {
			logperror("initifs: socket");
			return;
		}
	}
	lifn.lifn_family = AF_INET6;
	lifn.lifn_flags = LIFC_NOXMIT | LIFC_TEMPORARY;
	if (ioctl(ifsock, SIOCGLIFNUM, (char *)&lifn) < 0) {
		logperror("initifs: ioctl (get interface numbers)");
		return;
	}
	numifs = lifn.lifn_count;
	bufsize = numifs * sizeof (struct lifreq);

	buf = (char *)malloc(bufsize);
	if (buf == NULL) {
		logmsg(LOG_ERR, "initifs: out of memory\n");
		return;
	}

	/*
	 * Mark the interfaces so that we can find phyints and prefixes
	 * which have disappeared from the kernel.
	 * if_process will set pr_in_use when it finds the interface
	 * in the kernel.
	 */
	for (pi = phyints; pi != NULL; pi = pi->pi_next) {
		/*
		 * Before re-examining the state of the interfaces,
		 * PI_PRESENT should be cleared from pi_kernel_state.
		 */
		pi->pi_kernel_state &= ~PI_PRESENT;
		for (pr = pi->pi_prefix_list; pr != NULL; pr = pr->pr_next) {
			pr->pr_in_use = _B_FALSE;
		}
	}

	lifc.lifc_family = AF_INET6;
	lifc.lifc_flags = LIFC_NOXMIT | LIFC_TEMPORARY;
	lifc.lifc_len = bufsize;
	lifc.lifc_buf = buf;

	if (ioctl(ifsock, SIOCGLIFCONF, (char *)&lifc) < 0) {
		logperror("initifs: ioctl (get interface configuration)");
		free(buf);
		return;
	}

	lifr = (struct lifreq *)lifc.lifc_req;
	for (n = lifc.lifc_len / sizeof (struct lifreq); n > 0; n--, lifr++)
		if_process(ifsock, lifr->lifr_name, first);
	free(buf);

	/*
	 * Detect phyints that have been removed from the kernel.
	 * Since we can't recreate it here (would require ifconfig plumb
	 * logic) we just terminate use of that phyint.
	 */
	for (pi = phyints; pi != NULL; pi = next_pi) {
		next_pi = pi->pi_next;
		/*
		 * If interface (still) exists in kernel, set
		 * pi_state to indicate that.
		 */
		if (pi->pi_kernel_state & PI_PRESENT) {
			pi->pi_state |= PI_PRESENT;
		}

		check_if_removed(pi);
	}
	if (show_ifs)
		phyint_print_all();
}


/*
 * Router advertisement state machine. Used for everything but timer
 * events which use advertise_event directly.
 */
void
check_to_advertise(struct phyint *pi, enum adv_events event)
{
	uint_t delay;
	enum adv_states old_state = pi->pi_adv_state;

	if (debug & D_STATE) {
		logmsg(LOG_DEBUG, "check_to_advertise(%s, %d) state %d\n",
		    pi->pi_name, (int)event, (int)old_state);
	}
	delay = advertise_event(pi, event, 0);
	if (delay != TIMER_INFINITY) {
		/* Make sure the global next event is updated */
		timer_schedule(delay);
	}

	if (debug & D_STATE) {
		logmsg(LOG_DEBUG, "check_to_advertise(%s, %d) state %d -> %d\n",
		    pi->pi_name, (int)event, (int)old_state,
		    (int)pi->pi_adv_state);
	}
}

/*
 * Router advertisement state machine.
 * Return the number of milliseconds until next timeout (TIMER_INFINITY
 * if never).
 * For the ADV_TIMER event the caller passes in the number of milliseconds
 * since the last timer event in the 'elapsed' parameter.
 */
uint_t
advertise_event(struct phyint *pi, enum adv_events event, uint_t elapsed)
{
	uint_t delay;

	if (debug & D_STATE) {
		logmsg(LOG_DEBUG, "advertise_event(%s, %d, %d) state %d\n",
		    pi->pi_name, (int)event, elapsed, (int)pi->pi_adv_state);
	}
	check_daemonize();
	if (!pi->pi_AdvSendAdvertisements)
		return (TIMER_INFINITY);
	if (pi->pi_flags & IFF_NORTEXCH) {
		if (debug & D_PKTOUT) {
			logmsg(LOG_DEBUG, "Suppress sending RA packet on %s "
			    "(no route exchange on interface)\n",
			    pi->pi_name);
		}
		return (TIMER_INFINITY);
	}

	switch (event) {
	case ADV_OFF:
		pi->pi_adv_state = NO_ADV;
		return (TIMER_INFINITY);

	case START_INIT_ADV:
		if (pi->pi_adv_state == INIT_ADV)
			return (pi->pi_adv_time_left);
		pi->pi_adv_count = ND_MAX_INITIAL_RTR_ADVERTISEMENTS;
		pi->pi_adv_time_left = 0;
		pi->pi_adv_state = INIT_ADV;
		break;	/* send advertisement */

	case START_FINAL_ADV:
		if (pi->pi_adv_state == NO_ADV)
			return (TIMER_INFINITY);
		if (pi->pi_adv_state == FINAL_ADV)
			return (pi->pi_adv_time_left);
		pi->pi_adv_count = ND_MAX_FINAL_RTR_ADVERTISEMENTS;
		pi->pi_adv_time_left = 0;
		pi->pi_adv_state = FINAL_ADV;
		break;	/* send advertisement */

	case RECEIVED_SOLICIT:
		if (pi->pi_adv_state == NO_ADV)
			return (TIMER_INFINITY);
		if (pi->pi_adv_state == SOLICIT_ADV) {
			if (pi->pi_adv_time_left != 0)
				return (pi->pi_adv_time_left);
			break;
		}
		delay = GET_RANDOM(0, ND_MAX_RA_DELAY_TIME);
		if (delay < pi->pi_adv_time_left)
			pi->pi_adv_time_left = delay;
		if (pi->pi_adv_time_since_sent < ND_MIN_DELAY_BETWEEN_RAS) {
			/*
			 * Send an advertisement (ND_MIN_DELAY_BETWEEN_RAS
			 * plus random delay) after the previous
			 * advertisement was sent.
			 */
			pi->pi_adv_time_left = delay +
			    ND_MIN_DELAY_BETWEEN_RAS -
			    pi->pi_adv_time_since_sent;
		}
		pi->pi_adv_state = SOLICIT_ADV;
		break;

	case ADV_TIMER:
		if (pi->pi_adv_state == NO_ADV)
			return (TIMER_INFINITY);
		/* Decrease time left */
		if (pi->pi_adv_time_left >= elapsed)
			pi->pi_adv_time_left -= elapsed;
		else
			pi->pi_adv_time_left = 0;

		/* Increase time since last advertisement was sent */
		pi->pi_adv_time_since_sent += elapsed;
		break;
	default:
		logmsg(LOG_ERR, "advertise_event: Unknown event %d\n",
		    (int)event);
		return (TIMER_INFINITY);
	}

	if (pi->pi_adv_time_left != 0)
		return (pi->pi_adv_time_left);

	/* Send advertisement and calculate next time to send */
	if (pi->pi_adv_state == FINAL_ADV) {
		/* Omit the prefixes */
		advertise(&v6allnodes, pi, _B_TRUE);
	} else {
		advertise(&v6allnodes, pi, _B_FALSE);
	}
	pi->pi_adv_time_since_sent = 0;

	switch (pi->pi_adv_state) {
	case SOLICIT_ADV:
		/*
		 * The solicited advertisement has been sent.
		 * Revert to periodic advertisements.
		 */
		pi->pi_adv_state = REG_ADV;
		/* FALLTHRU */
	case REG_ADV:
		pi->pi_adv_time_left =
		    GET_RANDOM(1000 * pi->pi_MinRtrAdvInterval,
		    1000 * pi->pi_MaxRtrAdvInterval);
		break;

	case INIT_ADV:
		if (--pi->pi_adv_count > 0) {
			delay = GET_RANDOM(1000 * pi->pi_MinRtrAdvInterval,
			    1000 * pi->pi_MaxRtrAdvInterval);
			if (delay > ND_MAX_INITIAL_RTR_ADVERT_INTERVAL)
				delay = ND_MAX_INITIAL_RTR_ADVERT_INTERVAL;
			pi->pi_adv_time_left = delay;
		} else {
			pi->pi_adv_time_left =
			    GET_RANDOM(1000 * pi->pi_MinRtrAdvInterval,
			    1000 * pi->pi_MaxRtrAdvInterval);
			pi->pi_adv_state = REG_ADV;
		}
		break;

	case FINAL_ADV:
		if (--pi->pi_adv_count > 0) {
			pi->pi_adv_time_left =
			    ND_MAX_INITIAL_RTR_ADVERT_INTERVAL;
		} else {
			pi->pi_adv_state = NO_ADV;
		}
		break;
	}
	if (pi->pi_adv_state != NO_ADV)
		return (pi->pi_adv_time_left);
	else
		return (TIMER_INFINITY);
}

/*
 * Router solicitation state machine. Used for everything but timer
 * events which use solicit_event directly.
 */
void
check_to_solicit(struct phyint *pi, enum solicit_events event)
{
	uint_t delay;
	enum solicit_states old_state = pi->pi_sol_state;

	if (debug & D_STATE) {
		logmsg(LOG_DEBUG, "check_to_solicit(%s, %d) state %d\n",
		    pi->pi_name, (int)event, (int)old_state);
	}
	delay = solicit_event(pi, event, 0);
	if (delay != TIMER_INFINITY) {
		/* Make sure the global next event is updated */
		timer_schedule(delay);
	}

	if (debug & D_STATE) {
		logmsg(LOG_DEBUG, "check_to_solicit(%s, %d) state %d -> %d\n",
		    pi->pi_name, (int)event, (int)old_state,
		    (int)pi->pi_sol_state);
	}
}

static void
daemonize_ndpd(void)
{
	struct itimerval it;
	boolean_t timerval = _B_TRUE;

	/*
	 * Need to get current timer settings so they can be restored
	 * after the fork(), as the it_value and it_interval values for
	 * the ITIMER_REAL timer are reset to 0 in the child process.
	 */
	if (getitimer(ITIMER_REAL, &it) < 0) {
		if (debug & D_TIMER)
			logmsg(LOG_DEBUG,
			    "daemonize_ndpd: failed to get itimerval\n");
		timerval = _B_FALSE;
	}

	/* Daemonize. */
	if (daemon(0, 0) == -1) {
		logperror("fork");
		exit(1);
	}

	already_daemonized = _B_TRUE;

	/*
	 * Restore timer values, if we were able to save them; if not,
	 * check and set the right value by calling run_timeouts().
	 */
	if (timerval) {
		if (setitimer(ITIMER_REAL, &it, NULL) < 0) {
			logperror("daemonize_ndpd: setitimer");
			exit(2);
		}
	} else {
		run_timeouts();
	}
}

/*
 * Check to see if the time is right to daemonize.  The right time is when:
 *
 * 1.  We haven't already daemonized.
 * 2.  We are not in debug mode.
 * 3.  All interfaces are marked IFF_NOXMIT.
 * 4.  All non-router interfaces have their prefixes set up and we're
 *     done sending router solicitations on those interfaces without
 *     prefixes.
 */
static void
check_daemonize(void)
{
	struct phyint		*pi;

	if (already_daemonized || debug != 0)
		return;

	for (pi = phyints; pi != NULL; pi = pi->pi_next) {
		if (!(pi->pi_flags & IFF_NOXMIT))
			break;
	}

	/*
	 * If we can't transmit on any of the interfaces there is no reason
	 * to hold up progress.
	 */
	if (pi == NULL) {
		daemonize_ndpd();
		return;
	}

	/* Check all interfaces.  If any are still soliciting, just return. */
	for (pi = phyints; pi != NULL; pi = pi->pi_next) {
		if (pi->pi_AdvSendAdvertisements ||
		    !(pi->pi_kernel_state & PI_PRESENT))
			continue;

		if (pi->pi_sol_state == INIT_SOLICIT)
			return;
	}

	daemonize_ndpd();
}

/*
 * Router solicitation state machine.
 * Return the number of milliseconds until next timeout (TIMER_INFINITY
 * if never).
 * For the SOL_TIMER event the caller passes in the number of milliseconds
 * since the last timer event in the 'elapsed' parameter.
 */
uint_t
solicit_event(struct phyint *pi, enum solicit_events event, uint_t elapsed)
{
	if (debug & D_STATE) {
		logmsg(LOG_DEBUG, "solicit_event(%s, %d, %d) state %d\n",
		    pi->pi_name, (int)event, elapsed, (int)pi->pi_sol_state);
	}

	if (pi->pi_AdvSendAdvertisements)
		return (TIMER_INFINITY);
	if (pi->pi_flags & IFF_NORTEXCH) {
		if (debug & D_PKTOUT) {
			logmsg(LOG_DEBUG, "Suppress sending RS packet on %s "
			    "(no route exchange on interface)\n",
			    pi->pi_name);
		}
		return (TIMER_INFINITY);
	}

	switch (event) {
	case SOLICIT_OFF:
		pi->pi_sol_state = NO_SOLICIT;
		check_daemonize();
		return (TIMER_INFINITY);

	case SOLICIT_DONE:
		pi->pi_sol_state = DONE_SOLICIT;
		check_daemonize();
		return (TIMER_INFINITY);

	case RESTART_INIT_SOLICIT:
		/*
		 * This event allows us to start solicitation over again
		 * without losing the RA flags.  We start solicitation over
		 * when we are missing an interface prefix for a newly-
		 * encountered DHCP interface.
		 */
		if (pi->pi_sol_state == INIT_SOLICIT)
			return (pi->pi_sol_time_left);
		pi->pi_sol_count = ND_MAX_RTR_SOLICITATIONS;
		pi->pi_sol_time_left =
		    GET_RANDOM(0, ND_MAX_RTR_SOLICITATION_DELAY);
		pi->pi_sol_state = INIT_SOLICIT;
		break;

	case START_INIT_SOLICIT:
		if (pi->pi_sol_state == INIT_SOLICIT)
			return (pi->pi_sol_time_left);
		pi->pi_ra_flags = 0;
		pi->pi_sol_count = ND_MAX_RTR_SOLICITATIONS;
		pi->pi_sol_time_left =
		    GET_RANDOM(0, ND_MAX_RTR_SOLICITATION_DELAY);
		pi->pi_sol_state = INIT_SOLICIT;
		break;

	case SOL_TIMER:
		if (pi->pi_sol_state == NO_SOLICIT)
			return (TIMER_INFINITY);
		/* Decrease time left */
		if (pi->pi_sol_time_left >= elapsed)
			pi->pi_sol_time_left -= elapsed;
		else
			pi->pi_sol_time_left = 0;
		break;
	default:
		logmsg(LOG_ERR, "solicit_event: Unknown event %d\n",
		    (int)event);
		return (TIMER_INFINITY);
	}

	if (pi->pi_sol_time_left != 0)
		return (pi->pi_sol_time_left);

	/* Send solicitation and calculate next time */
	switch (pi->pi_sol_state) {
	case INIT_SOLICIT:
		solicit(&v6allrouters, pi);
		if (--pi->pi_sol_count == 0) {
			if (debug & D_STATE) {
				logmsg(LOG_DEBUG, "solicit_event: no routers "
				    "found on %s; assuming default flags\n",
				    pi->pi_name);
			}
			if (pi->pi_autoconf && pi->pi_StatefulAddrConf) {
				pi->pi_ra_flags |= ND_RA_FLAG_MANAGED |
				    ND_RA_FLAG_OTHER;
				start_dhcp(pi);
			}
			pi->pi_sol_state = DONE_SOLICIT;
			check_daemonize();
			return (TIMER_INFINITY);
		}
		pi->pi_sol_time_left = ND_RTR_SOLICITATION_INTERVAL;
		return (pi->pi_sol_time_left);
	case NO_SOLICIT:
	case DONE_SOLICIT:
		return (TIMER_INFINITY);
	default:
		return (pi->pi_sol_time_left);
	}
}

/*
 * Timer mechanism using relative time (in milliseconds) from the
 * previous timer event. Timers exceeding TIMER_INFINITY milliseconds
 * will fire after TIMER_INFINITY milliseconds.
 */
static uint_t timer_previous;	/* When last SIGALRM occurred */
static uint_t timer_next;	/* Currently scheduled timeout */

static void
timer_init(void)
{
	timer_previous = getcurrenttime();
	timer_next = TIMER_INFINITY;
	run_timeouts();
}

/*
 * Make sure the next SIGALRM occurs delay milliseconds from the current
 * time if not earlier.
 * Handles getcurrenttime (32 bit integer holding milliseconds) wraparound
 * by treating differences greater than 0x80000000 as negative.
 */
void
timer_schedule(uint_t delay)
{
	uint_t now;
	struct itimerval itimerval;

	now = getcurrenttime();
	if (debug & D_TIMER) {
		logmsg(LOG_DEBUG, "timer_schedule(%u): now %u next %u\n",
		    delay, now, timer_next);
	}
	/* Will this timer occur before the currently scheduled SIGALRM? */
	if (delay >= timer_next - now) {
		if (debug & D_TIMER) {
			logmsg(LOG_DEBUG, "timer_schedule(%u): no action - "
			    "next in %u ms\n",
			    delay, timer_next - now);
		}
		return;
	}
	if (delay == 0) {
		/* Minimum allowed delay */
		delay = 1;
	}
	timer_next = now + delay;

	itimerval.it_value.tv_sec = delay / 1000;
	itimerval.it_value.tv_usec = (delay % 1000) * 1000;
	itimerval.it_interval.tv_sec = 0;
	itimerval.it_interval.tv_usec = 0;
	if (debug & D_TIMER) {
		logmsg(LOG_DEBUG, "timer_schedule(%u): sec %lu usec %lu\n",
		    delay,
		    itimerval.it_value.tv_sec, itimerval.it_value.tv_usec);
	}
	if (setitimer(ITIMER_REAL, &itimerval, NULL) < 0) {
		logperror("timer_schedule: setitimer");
		exit(2);
	}
}

/*
 * Conditional running of timer. If more than 'minimal_time' millseconds
 * since the timer routines were last run we run them.
 * Used when packets arrive.
 */
static void
conditional_run_timeouts(uint_t minimal_time)
{
	uint_t now;
	uint_t elapsed;

	now = getcurrenttime();
	elapsed = now - timer_previous;
	if (elapsed > minimal_time) {
		if (debug & D_TIMER) {
			logmsg(LOG_DEBUG, "conditional_run_timeouts: "
			    "elapsed %d\n", elapsed);
		}
		run_timeouts();
	}
}

/*
 * Timer has fired.
 * Determine when the next timer event will occur by asking all
 * the timer routines.
 * Should not be called from a timer routine but in some cases this is
 * done because the code doesn't know that e.g. it was called from
 * ifconfig_timer(). In this case the nested run_timeouts will just return but
 * the running run_timeouts will ensure to call all the timer functions by
 * looping once more.
 */
static void
run_timeouts(void)
{
	uint_t now;
	uint_t elapsed;
	uint_t next;
	uint_t nexti;
	struct phyint *pi;
	struct phyint *next_pi;
	struct prefix *pr;
	struct prefix *next_pr;
	struct adv_prefix *adv_pr;
	struct adv_prefix *next_adv_pr;
	struct router *dr;
	struct router *next_dr;
	static boolean_t timeout_running;
	static boolean_t do_retry;

	if (timeout_running) {
		if (debug & D_TIMER)
			logmsg(LOG_DEBUG, "run_timeouts: nested call\n");
		do_retry = _B_TRUE;
		return;
	}
	timeout_running = _B_TRUE;
retry:
	/* How much time since the last time we were called? */
	now = getcurrenttime();
	elapsed = now - timer_previous;
	timer_previous = now;

	if (debug & D_TIMER)
		logmsg(LOG_DEBUG, "run_timeouts: elapsed %d\n", elapsed);

	next = TIMER_INFINITY;
	for (pi = phyints; pi != NULL; pi = next_pi) {
		next_pi = pi->pi_next;
		nexti = phyint_timer(pi, elapsed);
		if (nexti != TIMER_INFINITY && nexti < next)
			next = nexti;
		if (debug & D_TIMER) {
			logmsg(LOG_DEBUG, "run_timeouts (pi %s): %d -> %u ms\n",
			    pi->pi_name, nexti, next);
		}
		for (pr = pi->pi_prefix_list; pr != NULL; pr = next_pr) {
			next_pr = pr->pr_next;
			nexti = prefix_timer(pr, elapsed);
			if (nexti != TIMER_INFINITY && nexti < next)
				next = nexti;
			if (debug & D_TIMER) {
				logmsg(LOG_DEBUG, "run_timeouts (pr %s): "
				    "%d -> %u ms\n", pr->pr_name, nexti, next);
			}
		}
		for (adv_pr = pi->pi_adv_prefix_list; adv_pr != NULL;
		    adv_pr = next_adv_pr) {
			next_adv_pr = adv_pr->adv_pr_next;
			nexti = adv_prefix_timer(adv_pr, elapsed);
			if (nexti != TIMER_INFINITY && nexti < next)
				next = nexti;
			if (debug & D_TIMER) {
				logmsg(LOG_DEBUG, "run_timeouts "
				    "(adv pr on %s): %d -> %u ms\n",
				    adv_pr->adv_pr_physical->pi_name,
				    nexti, next);
			}
		}
		for (dr = pi->pi_router_list; dr != NULL; dr = next_dr) {
			next_dr = dr->dr_next;
			nexti = router_timer(dr, elapsed);
			if (nexti != TIMER_INFINITY && nexti < next)
				next = nexti;
			if (debug & D_TIMER) {
				logmsg(LOG_DEBUG, "run_timeouts (dr): "
				    "%d -> %u ms\n", nexti, next);
			}
		}
		if (pi->pi_TmpAddrsEnabled) {
			nexti = tmptoken_timer(pi, elapsed);
			if (nexti != TIMER_INFINITY && nexti < next)
				next = nexti;
			if (debug & D_TIMER) {
				logmsg(LOG_DEBUG, "run_timeouts (tmp on %s): "
				    "%d -> %u ms\n", pi->pi_name, nexti, next);
			}
		}
	}
	/*
	 * Make sure the timer functions are run at least once
	 * an hour.
	 */
	if (next == TIMER_INFINITY)
		next = 3600 * 1000;	/* 1 hour */

	if (debug & D_TIMER)
		logmsg(LOG_DEBUG, "run_timeouts: %u ms\n", next);
	timer_schedule(next);
	if (do_retry) {
		if (debug & D_TIMER)
			logmsg(LOG_DEBUG, "run_timeouts: retry\n");
		do_retry = _B_FALSE;
		goto retry;
	}
	timeout_running = _B_FALSE;
}

static int eventpipe_read = -1;	/* Used for synchronous signal delivery */
static int eventpipe_write = -1;

/*
 * Ensure that signals are processed synchronously with the rest of
 * the code by just writing a one character signal number on the pipe.
 * The poll loop will pick this up and process the signal event.
 */
static void
sig_handler(int signo)
{
	uchar_t buf = (uchar_t)signo;

	if (eventpipe_write == -1) {
		logmsg(LOG_ERR, "sig_handler: no pipe\n");
		return;
	}
	if (write(eventpipe_write, &buf, sizeof (buf)) < 0)
		logperror("sig_handler: write");
}

/*
 * Pick up a signal "byte" from the pipe and process it.
 */
static void
in_signal(int fd)
{
	uchar_t buf;
	struct phyint *pi;
	struct phyint *next_pi;

	switch (read(fd, &buf, sizeof (buf))) {
	case -1:
		logperror("in_signal: read");
		exit(1);
		/* NOTREACHED */
	case 1:
		break;
	case 0:
		logmsg(LOG_ERR, "in_signal: read eof\n");
		exit(1);
		/* NOTREACHED */
	default:
		logmsg(LOG_ERR, "in_signal: read > 1\n");
		exit(1);
	}

	if (debug & D_TIMER)
		logmsg(LOG_DEBUG, "in_signal() got %d\n", buf);

	switch (buf) {
	case SIGALRM:
		if (debug & D_TIMER) {
			uint_t now = getcurrenttime();

			logmsg(LOG_DEBUG, "in_signal(SIGALRM) delta %u\n",
			    now - timer_next);
		}
		timer_next = TIMER_INFINITY;
		run_timeouts();
		break;
	case SIGHUP:
		/* Re-read config file by exec'ing ourselves */
		for (pi = phyints; pi != NULL; pi = next_pi) {
			next_pi = pi->pi_next;
			if (pi->pi_AdvSendAdvertisements)
				check_to_advertise(pi, START_FINAL_ADV);

			/*
			 * Remove all the configured addresses.
			 * Remove the addrobj names created with ipmgmtd.
			 * Release the dhcpv6 addresses if any.
			 * Cleanup the phyints.
			 */
			phyint_delete(pi);
		}

		/*
		 * Prevent fd leaks.  Everything gets re-opened at start-up
		 * time.  0, 1, and 2 are closed and re-opened as
		 * /dev/null, so we'll leave those open.
		 */
		closefrom(3);

		logmsg(LOG_ERR, "SIGHUP: restart and reread config file\n");
		(void) execv(argv0[0], argv0);
		_exit(0177);
		/* NOTREACHED */
	case SIGUSR1:
		logmsg(LOG_DEBUG, "Printing configuration:\n");
		phyint_print_all();
		break;
	case SIGINT:
	case SIGTERM:
	case SIGQUIT:
		for (pi = phyints; pi != NULL; pi = next_pi) {
			next_pi = pi->pi_next;
			if (pi->pi_AdvSendAdvertisements)
				check_to_advertise(pi, START_FINAL_ADV);

			phyint_delete(pi);
		}
		(void) unlink(NDPD_SNMP_SOCKET);
		exit(0);
		/* NOTREACHED */
	case 255:
		/*
		 * Special "signal" from loopback_ra_enqueue.
		 * Handle any queued loopback router advertisements.
		 */
		loopback_ra_dequeue();
		break;
	default:
		logmsg(LOG_ERR, "in_signal: unknown signal: %d\n", buf);
	}
}

/*
 * Create pipe for signal delivery and set up signal handlers.
 */
static void
setup_eventpipe(void)
{
	int fds[2];
	struct sigaction act;

	if ((pipe(fds)) < 0) {
		logperror("setup_eventpipe: pipe");
		exit(1);
	}
	eventpipe_read = fds[0];
	eventpipe_write = fds[1];
	if (poll_add(eventpipe_read) == -1) {
		exit(1);
	}
	act.sa_handler = sig_handler;
	act.sa_flags = SA_RESTART;
	(void) sigaction(SIGALRM, &act, NULL);

	(void) sigset(SIGHUP, sig_handler);
	(void) sigset(SIGUSR1, sig_handler);
	(void) sigset(SIGTERM, sig_handler);
	(void) sigset(SIGINT, sig_handler);
	(void) sigset(SIGQUIT, sig_handler);
}

/*
 * Create a routing socket for receiving RTM_IFINFO messages and initialize
 * the routing socket message header and as much of the sockaddrs as possible.
 */
static int
setup_rtsock(void)
{
	int s;
	int ret;
	char *cp;
	struct sockaddr_in6 *sin6;

	s = socket(PF_ROUTE, SOCK_RAW, AF_INET6);
	if (s == -1) {
		logperror("socket(PF_ROUTE)");
		exit(1);
	}
	ret = fcntl(s, F_SETFL, O_NDELAY|O_NONBLOCK);
	if (ret < 0) {
		logperror("fcntl(O_NDELAY)");
		exit(1);
	}
	if (poll_add(s) == -1) {
		exit(1);
	}

	/*
	 * Allocate storage for the routing socket message.
	 */
	rt_msg = (struct rt_msghdr *)malloc(NDP_RTM_MSGLEN);
	if (rt_msg == NULL) {
		logperror("malloc");
		exit(1);
	}

	/*
	 * Initialize the routing socket message by zero-filling it and then
	 * setting the fields where are constant through the lifetime of the
	 * process.
	 */
	bzero(rt_msg, NDP_RTM_MSGLEN);
	rt_msg->rtm_msglen = NDP_RTM_MSGLEN;
	rt_msg->rtm_version = RTM_VERSION;
	rt_msg->rtm_addrs = RTA_DST | RTA_GATEWAY | RTA_NETMASK | RTA_IFP;
	rt_msg->rtm_pid = getpid();
	if (rt_msg->rtm_pid < 0) {
		logperror("getpid");
		exit(1);
	}

	/*
	 * The RTA_DST sockaddr does not change during the lifetime of the
	 * process so it can be completely initialized at this time.
	 */
	cp = (char *)rt_msg + sizeof (struct rt_msghdr);
	sin6 = (struct sockaddr_in6 *)cp;
	sin6->sin6_family = AF_INET6;
	sin6->sin6_addr = in6addr_any;

	/*
	 * Initialize the constant portion of the RTA_GATEWAY sockaddr.
	 */
	cp += sizeof (struct sockaddr_in6);
	rta_gateway = (struct sockaddr_in6 *)cp;
	rta_gateway->sin6_family = AF_INET6;

	/*
	 * The RTA_NETMASK sockaddr does not change during the lifetime of the
	 * process so it can be completely initialized at this time.
	 */
	cp += sizeof (struct sockaddr_in6);
	sin6 = (struct sockaddr_in6 *)cp;
	sin6->sin6_family = AF_INET6;
	sin6->sin6_addr = in6addr_any;

	/*
	 * Initialize the constant portion of the RTA_IFP sockaddr.
	 */
	cp += sizeof (struct sockaddr_in6);
	rta_ifp = (struct sockaddr_dl *)cp;
	rta_ifp->sdl_family = AF_LINK;

	return (s);
}

static int
setup_mibsock(void)
{
	int sock;
	int ret;
	int len;
	struct sockaddr_un laddr;

	sock = socket(AF_UNIX, SOCK_DGRAM, 0);
	if (sock == -1) {
		logperror("setup_mibsock: socket(AF_UNIX)");
		exit(1);
	}

	bzero(&laddr, sizeof (laddr));
	laddr.sun_family = AF_UNIX;

	(void) strncpy(laddr.sun_path, NDPD_SNMP_SOCKET,
	    sizeof (laddr.sun_path));
	len = sizeof (struct sockaddr_un);

	(void) unlink(NDPD_SNMP_SOCKET);
	ret = bind(sock, (struct sockaddr *)&laddr, len);
	if (ret < 0) {
		logperror("setup_mibsock: bind\n");
		exit(1);
	}

	ret = fcntl(sock, F_SETFL, O_NONBLOCK);
	if (ret < 0) {
		logperror("fcntl(O_NONBLOCK)");
		exit(1);
	}
	if (poll_add(sock) == -1) {
		exit(1);
	}
	return (sock);
}

/*
 * Retrieve one routing socket message. If RTM_IFINFO indicates
 * new phyint do a full scan of the interfaces. If RTM_IFINFO
 * indicates an existing phyint, only scan that phyint and associated
 * prefixes.
 */
static void
process_rtsock(int rtsock)
{
	int n;
#define	MSG_SIZE	2048/8
	int64_t msg[MSG_SIZE];
	struct rt_msghdr *rtm;
	struct if_msghdr *ifm;
	struct phyint *pi;
	struct prefix *pr;
	boolean_t need_initifs = _B_FALSE;
	boolean_t need_ifscan = _B_FALSE;
	int64_t	ifscan_msg[10][MSG_SIZE];
	int ifscan_index = 0;
	int i;

	/* Empty the rtsock and coealesce all the work that we have */
	while (ifscan_index < 10) {
		n = read(rtsock, msg, sizeof (msg));
		if (n <= 0) {
			/* No more messages */
			break;
		}
		rtm = (struct rt_msghdr *)msg;
		if (rtm->rtm_version != RTM_VERSION) {
			logmsg(LOG_ERR,
			    "process_rtsock: version %d not understood\n",
			    rtm->rtm_version);
			return;
		}
		switch (rtm->rtm_type) {
		case RTM_NEWADDR:
		case RTM_DELADDR:
			/*
			 * Some logical interface has changed - have to scan
			 * everything to determine what actually changed.
			 */
			if (debug & D_IFSCAN) {
				logmsg(LOG_DEBUG, "process_rtsock: "
				    "message %d\n", rtm->rtm_type);
			}
			need_initifs = _B_TRUE;
			break;
		case RTM_IFINFO:
			need_ifscan = _B_TRUE;
			(void) memcpy(ifscan_msg[ifscan_index], rtm,
			    sizeof (msg));
			ifscan_index++;
			/* Handled below */
			break;
		default:
			/* Not interesting */
			break;
		}
	}
	/*
	 * If we do full scan i.e initifs, we don't need to
	 * scan a particular interface as we should have
	 * done that as part of initifs.
	 */
	if (need_initifs) {
		initifs(_B_FALSE);
		return;
	}

	if (!need_ifscan)
		return;

	for (i = 0; i < ifscan_index; i++) {
		ifm = (struct if_msghdr *)ifscan_msg[i];
		if (debug & D_IFSCAN)
			logmsg(LOG_DEBUG, "process_rtsock: index %d\n",
			    ifm->ifm_index);

		pi = phyint_lookup_on_index(ifm->ifm_index);
		if (pi == NULL) {
			/*
			 * A new physical interface. Do a full scan of the
			 * to catch any new logical interfaces.
			 */
			initifs(_B_FALSE);
			return;
		}

		if (ifm->ifm_flags != (uint_t)pi->pi_flags) {
			if (debug & D_IFSCAN) {
				logmsg(LOG_DEBUG, "process_rtsock: clr for "
				    "%s old flags 0x%llx new flags 0x%x\n",
				    pi->pi_name, pi->pi_flags, ifm->ifm_flags);
			}
		}


		/*
		 * Mark the interfaces so that we can find phyints and prefixes
		 * which have disappeared from the kernel.
		 * if_process will set pr_in_use when it finds the
		 * interface in the kernel.
		 * Before re-examining the state of the interfaces,
		 * PI_PRESENT should be cleared from pi_kernel_state.
		 */
		pi->pi_kernel_state &= ~PI_PRESENT;
		for (pr = pi->pi_prefix_list; pr != NULL; pr = pr->pr_next) {
			pr->pr_in_use = _B_FALSE;
		}

		if (ifsock < 0) {
			ifsock = socket(AF_INET6, SOCK_DGRAM, 0);
			if (ifsock < 0) {
				logperror("process_rtsock: socket");
				return;
			}
		}
		if_process(ifsock, pi->pi_name, _B_FALSE);
		for (pr = pi->pi_prefix_list; pr != NULL; pr = pr->pr_next) {
			if_process(ifsock, pr->pr_name, _B_FALSE);
		}
		/*
		 * If interface (still) exists in kernel, set
		 * pi_state to indicate that.
		 */
		if (pi->pi_kernel_state & PI_PRESENT) {
			pi->pi_state |= PI_PRESENT;
		}
		check_if_removed(pi);
		if (show_ifs)
			phyint_print_all();
	}
}

static void
process_mibsock(int mibsock)
{
	struct phyint *pi;
	socklen_t fromlen;
	struct sockaddr_un from;
	ndpd_info_t ndpd_info;
	ssize_t len;
	int command;

	fromlen = (socklen_t)sizeof (from);
	len = recvfrom(mibsock, &command, sizeof (int), 0,
	    (struct sockaddr *)&from, &fromlen);

	if (len < sizeof (int) || command != NDPD_SNMP_INFO_REQ) {
		logperror("process_mibsock: bad command \n");
		return;
	}

	ndpd_info.info_type = NDPD_SNMP_INFO_RESPONSE;
	ndpd_info.info_version = NDPD_SNMP_INFO_VER;
	ndpd_info.info_num_of_phyints = num_of_phyints;

	(void) sendto(mibsock, &ndpd_info, sizeof (ndpd_info_t), 0,
	    (struct sockaddr *)&from, fromlen);

	for (pi = phyints; pi != NULL; pi = pi->pi_next) {
		int prefixes;
		int routers;
		struct prefix   *prefix_list;
		struct router   *router_list;
		ndpd_phyint_info_t phyint;
		ndpd_prefix_info_t prefix;
		ndpd_router_info_t router;
		/*
		 * get number of prefixes
		 */
		routers = 0;
		prefixes = 0;
		prefix_list = pi->pi_prefix_list;
		while (prefix_list != NULL) {
			prefixes++;
			prefix_list = prefix_list->pr_next;
		}

		/*
		 * get number of routers
		 */
		router_list = pi->pi_router_list;
		while (router_list != NULL) {
			routers++;
			router_list = router_list->dr_next;
		}

		phyint.phyint_info_type = NDPD_PHYINT_INFO;
		phyint.phyint_info_version = NDPD_PHYINT_INFO_VER;
		phyint.phyint_index = pi->pi_index;
		bcopy(pi->pi_config,
		    phyint.phyint_config, I_IFSIZE);
		phyint.phyint_num_of_prefixes = prefixes;
		phyint.phyint_num_of_routers = routers;
		(void) sendto(mibsock, &phyint, sizeof (phyint), 0,
		    (struct sockaddr *)&from, fromlen);

		/*
		 * Copy prefix information
		 */

		prefix_list = pi->pi_prefix_list;
		while (prefix_list != NULL) {
			prefix.prefix_info_type = NDPD_PREFIX_INFO;
			prefix.prefix_info_version = NDPD_PREFIX_INFO_VER;
			prefix.prefix_prefix = prefix_list->pr_prefix;
			prefix.prefix_len = prefix_list->pr_prefix_len;
			prefix.prefix_flags = prefix_list->pr_flags;
			prefix.prefix_phyint_index = pi->pi_index;
			prefix.prefix_ValidLifetime =
			    prefix_list->pr_ValidLifetime;
			prefix.prefix_PreferredLifetime =
			    prefix_list->pr_PreferredLifetime;
			prefix.prefix_OnLinkLifetime =
			    prefix_list->pr_OnLinkLifetime;
			prefix.prefix_OnLinkFlag =
			    prefix_list->pr_OnLinkFlag;
			prefix.prefix_AutonomousFlag =
			    prefix_list->pr_AutonomousFlag;
			(void) sendto(mibsock, &prefix, sizeof (prefix), 0,
			    (struct sockaddr *)&from, fromlen);
			prefix_list = prefix_list->pr_next;
		}
		/*
		 * Copy router information
		 */
		router_list = pi->pi_router_list;
		while (router_list != NULL) {
			router.router_info_type = NDPD_ROUTER_INFO;
			router.router_info_version = NDPD_ROUTER_INFO_VER;
			router.router_address = router_list->dr_address;
			router.router_lifetime = router_list->dr_lifetime;
			router.router_phyint_index = pi->pi_index;
			(void) sendto(mibsock, &router, sizeof (router), 0,
			    (struct sockaddr *)&from, fromlen);
			router_list = router_list->dr_next;
		}
	}
}

/*
 * Look if the phyint or one of its prefixes have been removed from
 * the kernel and take appropriate action.
 * Uses pr_in_use and pi{,_kernel}_state.
 */
static void
check_if_removed(struct phyint *pi)
{
	struct prefix *pr, *next_pr;

	/*
	 * Detect prefixes which are removed.
	 * Static prefixes are just removed from our tables.
	 * Non-static prefixes are recreated i.e. in.ndpd takes precedence
	 * over manually removing prefixes via ifconfig.
	 */
	for (pr = pi->pi_prefix_list; pr != NULL; pr = next_pr) {
		next_pr = pr->pr_next;
		if (!pr->pr_in_use) {
			/* Clear everything except PR_STATIC */
			pr->pr_kernel_state &= PR_STATIC;
			if (pr->pr_state & PR_STATIC)
				prefix_update_ipadm_addrobj(pr, _B_FALSE);
			pr->pr_name[0] = '\0';
			if (pr->pr_state & PR_STATIC) {
				prefix_delete(pr);
			} else if (!(pi->pi_kernel_state & PI_PRESENT)) {
				/*
				 * Ensure that there are no future attempts to
				 * run prefix_update_k since the phyint is gone.
				 */
				pr->pr_state = pr->pr_kernel_state;
			} else if (pr->pr_state != pr->pr_kernel_state) {
				logmsg(LOG_INFO, "Prefix manually removed "
				    "on %s; recreating\n", pi->pi_name);
				prefix_update_k(pr);
			}
		}
	}

	/*
	 * Detect phyints that have been removed from the kernel, and tear
	 * down any prefixes we created that are associated with that phyint.
	 * (NOTE: IPMP depends on in.ndpd tearing down these prefixes so an
	 * administrator can easily place an IP interface with ADDRCONF'd
	 * addresses into an IPMP group.)
	 */
	if (!(pi->pi_kernel_state & PI_PRESENT) &&
	    (pi->pi_state & PI_PRESENT)) {
		logmsg(LOG_ERR, "Interface %s has been removed from kernel. "
		    "in.ndpd will no longer use it\n", pi->pi_name);

		for (pr = pi->pi_prefix_list; pr != NULL; pr = next_pr) {
			next_pr = pr->pr_next;
			if (pr->pr_state & PR_AUTO)
				prefix_update_ipadm_addrobj(pr, _B_FALSE);
			prefix_delete(pr);
		}

		/*
		 * Clear state so that should the phyint reappear we will
		 * start with initial advertisements or solicitations.
		 */
		phyint_cleanup(pi);
	}
}


/*
 * Queuing mechanism for router advertisements that are sent by in.ndpd
 * and that also need to be processed by in.ndpd.
 * Uses "signal number" 255 to indicate to the main poll loop
 * that there is something to dequeue and send to incomining_ra().
 */
struct raq {
	struct raq	*raq_next;
	struct phyint	*raq_pi;
	int		raq_packetlen;
	uchar_t		*raq_packet;
};
static struct raq *raq_head = NULL;

/*
 * Allocate a struct raq and memory for the packet.
 * Send signal 255 to have poll dequeue.
 */
static void
loopback_ra_enqueue(struct phyint *pi, struct nd_router_advert *ra, int len)
{
	struct raq *raq;
	struct raq **raqp;

	if (no_loopback)
		return;

	if (debug & D_PKTOUT)
		logmsg(LOG_DEBUG, "loopback_ra_enqueue for %s\n", pi->pi_name);

	raq = calloc(sizeof (struct raq), 1);
	if (raq == NULL) {
		logmsg(LOG_ERR, "loopback_ra_enqueue: out of memory\n");
		return;
	}
	raq->raq_packet = malloc(len);
	if (raq->raq_packet == NULL) {
		free(raq);
		logmsg(LOG_ERR, "loopback_ra_enqueue: out of memory\n");
		return;
	}
	bcopy(ra, raq->raq_packet, len);
	raq->raq_packetlen = len;
	raq->raq_pi = pi;

	/* Tail insert */
	raqp = &raq_head;
	while (*raqp != NULL)
		raqp = &((*raqp)->raq_next);
	*raqp = raq;

	/* Signal for poll loop */
	sig_handler(255);
}

/*
 * Dequeue and process all queued advertisements.
 */
static void
loopback_ra_dequeue(void)
{
	struct sockaddr_in6 from = IN6ADDR_LOOPBACK_INIT;
	struct raq *raq;

	if (debug & D_PKTIN)
		logmsg(LOG_DEBUG, "loopback_ra_dequeue()\n");

	while ((raq = raq_head) != NULL) {
		raq_head = raq->raq_next;
		raq->raq_next = NULL;

		if (debug & D_PKTIN) {
			logmsg(LOG_DEBUG, "loopback_ra_dequeue for %s\n",
			    raq->raq_pi->pi_name);
		}

		incoming_ra(raq->raq_pi,
		    (struct nd_router_advert *)raq->raq_packet,
		    raq->raq_packetlen, &from, _B_TRUE);
		free(raq->raq_packet);
		free(raq);
	}
}


static void
usage(char *cmd)
{
	(void) fprintf(stderr,
	    "usage: %s [ -adt ] [-f <config file>]\n", cmd);
}

int
main(int argc, char *argv[])
{
	int i;
	struct phyint *pi;
	int c;
	char *config_file = PATH_NDPD_CONF;
	boolean_t file_required = _B_FALSE;

	argv0 = argv;
	srandom(gethostid());
	(void) umask(0022);

	while ((c = getopt(argc, argv, "adD:ntIf:")) != EOF) {
		switch (c) {
		case 'a':
			/*
			 * The StatelessAddrConf variable in ndpd.conf, if
			 * present, will override this setting.
			 */
			ifdefaults[I_StatelessAddrConf].cf_value = 0;
			break;
		case 'd':
			debug = D_ALL;
			break;
		case 'D':
			i = strtol((char *)optarg, NULL, 0);
			if (i == 0) {
				(void) fprintf(stderr, "Bad debug flags: %s\n",
				    (char *)optarg);
				exit(1);
			}
			debug |= i;
			break;
		case 'n':
			no_loopback = 1;
			break;
		case 'I':
			show_ifs = 1;
			break;
		case 't':
			debug |= D_PKTIN | D_PKTOUT | D_PKTBAD;
			break;
		case 'f':
			config_file = (char *)optarg;
			file_required = _B_TRUE;
			break;
		case '?':
			usage(argv[0]);
			exit(1);
		}
	}

	if (parse_config(config_file, file_required) == -1)
		exit(2);

	if (show_ifs)
		phyint_print_all();

	if (debug == 0)
		initlog();

	cmdsock = ndpd_setup_cmd_listener();
	setup_eventpipe();
	rtsock = setup_rtsock();
	mibsock = setup_mibsock();
	timer_init();
	initifs(_B_TRUE);

	check_daemonize();

	for (;;) {
		if (poll(pollfds, pollfd_num, -1) < 0) {
			if (errno == EINTR)
				continue;
			logperror("main: poll");
			exit(1);
		}
		for (i = 0; i < pollfd_num; i++) {
			if (!(pollfds[i].revents & POLLIN))
				continue;
			if (pollfds[i].fd == eventpipe_read) {
				in_signal(eventpipe_read);
				break;
			}
			if (pollfds[i].fd == rtsock) {
				process_rtsock(rtsock);
				break;
			}
			if (pollfds[i].fd == mibsock) {
				process_mibsock(mibsock);
				break;
			}
			if (pollfds[i].fd == cmdsock) {
				ndpd_cmd_handler(cmdsock);
				break;
			}
			/*
			 * Run timer routine to advance clock if more than
			 * half a second since the clock was advanced.
			 * This limits CPU usage under severe packet
			 * arrival rates but it creates a slight inaccuracy
			 * in the timer mechanism.
			 */
			conditional_run_timeouts(500U);
			for (pi = phyints; pi != NULL; pi = pi->pi_next) {
				if (pollfds[i].fd == pi->pi_sock) {
					in_data(pi);
					break;
				}
			}
		}
	}
	/* NOTREACHED */
	return (0);
}

/*
 * LOGGER
 */

static boolean_t logging = _B_FALSE;

static void
initlog(void)
{
	logging = _B_TRUE;
	openlog("in.ndpd", LOG_PID | LOG_CONS, LOG_DAEMON);
}

/* Print the date/time without a trailing carridge return */
static void
fprintdate(FILE *file)
{
	char buf[BUFSIZ];
	struct tm tms;
	time_t now;

	now = time(NULL);
	(void) localtime_r(&now, &tms);
	(void) strftime(buf, sizeof (buf), "%h %d %X", &tms);
	(void) fprintf(file, "%s ", buf);
}

/* PRINTFLIKE2 */
void
logmsg(int level, const char *fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);

	if (logging) {
		vsyslog(level, fmt, ap);
	} else {
		fprintdate(stderr);
		(void) vfprintf(stderr, fmt, ap);
	}
	va_end(ap);
}

void
logperror(const char *str)
{
	if (logging) {
		syslog(LOG_ERR, "%s: %m\n", str);
	} else {
		fprintdate(stderr);
		(void) fprintf(stderr, "%s: %s\n", str, strerror(errno));
	}
}

void
logperror_pi(const struct phyint *pi, const char *str)
{
	if (logging) {
		syslog(LOG_ERR, "%s (interface %s): %m\n",
		    str, pi->pi_name);
	} else {
		fprintdate(stderr);
		(void) fprintf(stderr, "%s (interface %s): %s\n",
		    str, pi->pi_name, strerror(errno));
	}
}

void
logperror_pr(const struct prefix *pr, const char *str)
{
	if (logging) {
		syslog(LOG_ERR, "%s (prefix %s if %s): %m\n",
		    str, pr->pr_name, pr->pr_physical->pi_name);
	} else {
		fprintdate(stderr);
		(void) fprintf(stderr, "%s (prefix %s if %s): %s\n",
		    str, pr->pr_name, pr->pr_physical->pi_name,
		    strerror(errno));
	}
}

static int
ndpd_setup_cmd_listener(void)
{
	int sock;
	int ret;
	struct sockaddr_un servaddr;

	sock = socket(AF_UNIX, SOCK_STREAM, 0);
	if (sock < 0) {
		logperror("socket");
		exit(1);
	}

	bzero(&servaddr, sizeof (servaddr));
	servaddr.sun_family = AF_UNIX;
	(void) strlcpy(servaddr.sun_path, IPADM_UDS_PATH,
	    sizeof (servaddr.sun_path));
	(void) unlink(servaddr.sun_path);
	ret = bind(sock, (struct sockaddr *)&servaddr, sizeof (servaddr));
	if (ret < 0) {
		logperror("bind");
		exit(1);
	}
	if (listen(sock, 30) < 0) {
		logperror("listen");
		exit(1);
	}
	if (poll_add(sock) == -1) {
		logmsg(LOG_ERR, "command socket could not be added to the "
		    "polling set\n");
		exit(1);
	}

	return (sock);
}

/*
 * Commands received over the command socket come here
 */
static void
ndpd_cmd_handler(int sock)
{
	int			newfd;
	struct sockaddr_storage	peer;
	socklen_t		peerlen;
	ipadm_ndpd_msg_t	ndpd_msg;
	int			retval;

	peerlen = sizeof (peer);
	newfd = accept(sock, (struct sockaddr *)&peer, &peerlen);
	if (newfd < 0) {
		logperror("accept");
		return;
	}

	retval = ipadm_ndpd_read(newfd, &ndpd_msg, sizeof (ndpd_msg));
	if (retval != 0)
		logperror("Could not read ndpd command");

	retval = ndpd_process_cmd(newfd, &ndpd_msg);
	if (retval != 0) {
		logmsg(LOG_ERR, "ndpd command on interface %s failed with "
		    "error %s\n", ndpd_msg.inm_ifname, strerror(retval));
	}
	(void) close(newfd);
}

/*
 * Process the commands received from the cmd listener socket.
 */
static int
ndpd_process_cmd(int newfd, ipadm_ndpd_msg_t *msg)
{
	int err;

	if (!ipadm_check_auth()) {
		logmsg(LOG_ERR, "User not authorized to send the command\n");
		(void) ndpd_send_error(newfd, EPERM);
		return (EPERM);
	}
	switch (msg->inm_cmd) {
	case IPADM_DISABLE_AUTOCONF:
		err = ndpd_set_autoconf(msg->inm_ifname, _B_FALSE);
		break;

	case IPADM_ENABLE_AUTOCONF:
		err = ndpd_set_autoconf(msg->inm_ifname, _B_TRUE);
		break;

	case IPADM_CREATE_ADDRS:
		err = ndpd_create_addrs(msg->inm_ifname, msg->inm_intfid,
		    msg->inm_intfidlen, msg->inm_stateless,
		    msg->inm_stateful, msg->inm_aobjname);
		break;

	case IPADM_DELETE_ADDRS:
		err = ndpd_delete_addrs(msg->inm_ifname);
		break;

	default:
		err = EINVAL;
		break;
	}

	(void) ndpd_send_error(newfd, err);

	return (err);
}

static int
ndpd_send_error(int fd, int error)
{
	return (ipadm_ndpd_write(fd, &error, sizeof (error)));
}

/*
 * Disables/Enables autoconfiguration of addresses on the
 * given physical interface.
 * This is provided to support the legacy method of configuring IPv6
 * addresses. i.e. `ifconfig bge0 inet6 plumb` will plumb the interface
 * and start stateless and stateful autoconfiguration. If this function is
 * not called with enable=_B_FALSE, no autoconfiguration will be done until
 * ndpd_create_addrs() is called with an Interface ID.
 */
static int
ndpd_set_autoconf(const char *ifname, boolean_t enable)
{
	struct phyint *pi;

	pi = phyint_lookup((char *)ifname);
	if (pi == NULL) {
		/*
		 * If the physical interface was plumbed but no
		 * addresses were configured yet, phyint will not exist.
		 */
		pi = phyint_create((char *)ifname);
		if (pi == NULL) {
			logmsg(LOG_ERR, "could not create phyint for "
			    "interface %s", ifname);
			return (ENOMEM);
		}
	}
	pi->pi_autoconf = enable;

	if (debug & D_PHYINT) {
		logmsg(LOG_DEBUG, "ndpd_set_autoconf: %s autoconf for "
		    "interface %s\n", (enable ? "enabled" : "disabled"),
		    pi->pi_name);
	}
	return (0);
}

/*
 * Create auto-configured addresses on the given interface using
 * the given token as the interface id during the next Router Advertisement.
 * Currently, only one token per interface is supported.
 */
static int
ndpd_create_addrs(const char *ifname, struct sockaddr_in6 intfid, int intfidlen,
    boolean_t stateless, boolean_t stateful, char *addrobj)
{
	struct phyint *pi;
	struct lifreq lifr;
	struct sockaddr_in6 *sin6;
	int err;

	pi = phyint_lookup((char *)ifname);
	if (pi == NULL) {
		/*
		 * If the physical interface was plumbed but no
		 * addresses were configured yet, phyint will not exist.
		 */
		pi = phyint_create((char *)ifname);
		if (pi == NULL) {
			if (debug & D_PHYINT)
				logmsg(LOG_ERR, "could not create phyint "
				    "for interface %s", ifname);
			return (ENOMEM);
		}
	} else if (pi->pi_autoconf) {
		logmsg(LOG_ERR, "autoconfiguration already in progress\n");
		return (EEXIST);
	}
	check_autoconf_var_consistency(pi, stateless, stateful);

	if (intfidlen == 0) {
		pi->pi_default_token = _B_TRUE;
		if (ifsock < 0) {
			ifsock = socket(AF_INET6, SOCK_DGRAM, 0);
			if (ifsock < 0) {
				err = errno;
				logperror("ndpd_create_addrs: socket");
				return (err);
			}
		}
		(void) strncpy(lifr.lifr_name, ifname, sizeof (lifr.lifr_name));
		sin6 = (struct sockaddr_in6 *)&lifr.lifr_addr;
		if (ioctl(ifsock, SIOCGLIFTOKEN, (char *)&lifr) < 0) {
			err = errno;
			logperror("SIOCGLIFTOKEN");
			return (err);
		}
		pi->pi_token = sin6->sin6_addr;
		pi->pi_token_length = lifr.lifr_addrlen;
	} else {
		pi->pi_default_token = _B_FALSE;
		pi->pi_token = intfid.sin6_addr;
		pi->pi_token_length = intfidlen;
	}
	pi->pi_stateless = stateless;
	pi->pi_stateful = stateful;
	(void) strlcpy(pi->pi_ipadm_aobjname, addrobj,
	    sizeof (pi->pi_ipadm_aobjname));

	/* We can allow autoconfiguration now. */
	pi->pi_autoconf = _B_TRUE;

	/* Restart the solicitations. */
	if (pi->pi_sol_state == DONE_SOLICIT)
		pi->pi_sol_state = NO_SOLICIT;
	if (pi->pi_sol_state == NO_SOLICIT)
		check_to_solicit(pi, START_INIT_SOLICIT);
	if (debug & D_PHYINT)
		logmsg(LOG_DEBUG, "ndpd_create_addrs: "
		    "added token to interface %s\n", pi->pi_name);
	return (0);
}

/*
 * This function deletes all addresses on the given interface
 * with the given Interface ID.
 */
static int
ndpd_delete_addrs(const char *ifname)
{
	struct phyint *pi;
	struct prefix *pr, *next_pr;
	struct lifreq lifr;
	int err;

	pi = phyint_lookup((char *)ifname);
	if (pi == NULL) {
		logmsg(LOG_ERR, "no phyint found for %s", ifname);
		return (ENXIO);
	}
	if (IN6_IS_ADDR_UNSPECIFIED(&pi->pi_token)) {
		logmsg(LOG_ERR, "token does not exist for %s", ifname);
		return (ENOENT);
	}

	if (ifsock < 0) {
		ifsock = socket(AF_INET6, SOCK_DGRAM, 0);
		if (ifsock < 0) {
			err = errno;
			logperror("ndpd_delete_addrs: socket");
			return (err);
		}
	}
	/* Remove the prefixes for this phyint if they exist */
	for (pr = pi->pi_prefix_list; pr != NULL; pr = next_pr) {
		next_pr = pr->pr_next;
		if (pr->pr_name[0] == '\0') {
			prefix_delete(pr);
			continue;
		}
		/*
		 * Delete all the prefixes for the auto-configured
		 * addresses as well as the DHCPv6 addresses.
		 */
		(void) strncpy(lifr.lifr_name, pr->pr_name,
		    sizeof (lifr.lifr_name));
		if (ioctl(ifsock, SIOCGLIFFLAGS, (char *)&lifr) < 0) {
			err = errno;
			logperror("SIOCGLIFFLAGS");
			return (err);
		}
		if ((lifr.lifr_flags & IFF_ADDRCONF) ||
		    (lifr.lifr_flags & IFF_DHCPRUNNING)) {
			prefix_update_ipadm_addrobj(pr, _B_FALSE);
		}
		prefix_delete(pr);
	}

	/*
	 * If we had started dhcpagent, we need to release the leases
	 * if any are required.
	 */
	if (pi->pi_stateful) {
		(void) strncpy(lifr.lifr_name, pi->pi_name,
		    sizeof (lifr.lifr_name));
		if (ioctl(ifsock, SIOCGLIFFLAGS, (char *)&lifr) < 0) {
			err = errno;
			logperror("SIOCGLIFFLAGS");
			return (err);
		}
		if (lifr.lifr_flags & IFF_DHCPRUNNING)
			release_dhcp(pi);
	}

	/*
	 * Reset the Interface ID on this phyint and stop autoconfigurations
	 * until a new interface ID is provided.
	 */
	pi->pi_token = in6addr_any;
	pi->pi_ifaddr = in6addr_any;
	pi->pi_token_length = 0;
	pi->pi_autoconf = _B_FALSE;
	pi->pi_ipadm_aobjname[0] = '\0';

	/* Reset the stateless and stateful settings to default. */
	pi->pi_stateless = pi->pi_StatelessAddrConf;
	pi->pi_stateful = pi->pi_StatefulAddrConf;

	if (debug & D_PHYINT) {
		logmsg(LOG_DEBUG, "ndpd_delete_addrs: "
		    "removed token from interface %s\n", pi->pi_name);
	}
	return (0);
}

void
check_autoconf_var_consistency(struct phyint *pi, boolean_t stateless,
    boolean_t stateful)
{
	/*
	 * If StatelessAddrConf and StatelessAddrConf are set in
	 * /etc/inet/ndpd.conf, check if the new values override those
	 * settings. If so, log a warning.
	 */
	if ((pi->pi_StatelessAddrConf !=
	    ifdefaults[I_StatelessAddrConf].cf_value &&
	    stateless != pi->pi_StatelessAddrConf) ||
	    (pi->pi_StatefulAddrConf !=
	    ifdefaults[I_StatefulAddrConf].cf_value &&
	    stateful != pi->pi_StatefulAddrConf)) {
		logmsg(LOG_ERR, "check_autoconf_var_consistency: "
		    "Overriding the StatelessAddrConf or StatefulAddrConf "
		    "settings in ndpd.conf with the new values for "
		    "interface %s\n", pi->pi_name);
	}
}

/*
 * If ipadm was used to start autoconfiguration and in.ndpd was restarted
 * for some reason, in.ndpd has to resume autoconfiguration when it comes up.
 * In this function, it scans the ipadm_addr_info() output to find a link-local
 * on this interface with address type "addrconf" and extracts the interface id.
 * It also stores the addrobj name to be used later when new addresses are
 * created for the prefixes advertised by the router.
 * If autoconfiguration was never started on this interface before in.ndpd
 * was killed, then in.ndpd should refrain from configuring prefixes, even if
 * there is a valid link-local on this interface, created by ipadm (identified
 * if there is a valid addrobj name).
 */
static int
phyint_check_ipadm_intfid(struct phyint *pi)
{
	ipadm_status_t		status;
	ipadm_addr_info_t	*addrinfo;
	struct ifaddrs		*ifap;
	ipadm_addr_info_t	*ainfop;
	struct sockaddr_in6	*sin6;
	ipadm_handle_t		iph;

	if (ipadm_open(&iph, 0) != IPADM_SUCCESS) {
		logmsg(LOG_ERR, "could not open handle to libipadm\n");
		return (-1);
	}

	status = ipadm_addr_info(iph, pi->pi_name, &addrinfo,
	    IPADM_OPT_ZEROADDR, LIFC_NOXMIT|LIFC_TEMPORARY);
	if (status != IPADM_SUCCESS) {
		ipadm_close(iph);
		return (-1);
	}
	pi->pi_autoconf = _B_TRUE;
	for (ainfop = addrinfo; ainfop != NULL; ainfop = IA_NEXT(ainfop)) {
		ifap = &ainfop->ia_ifa;
		if (ifap->ifa_addr->sa_family != AF_INET6 ||
		    ainfop->ia_state == IFA_DISABLED)
			continue;
		sin6 = (struct sockaddr_in6 *)ifap->ifa_addr;
		if (IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr)) {
			if (ainfop->ia_atype == IPADM_ADDR_IPV6_ADDRCONF) {
				/*
				 * Clearing pi_default_token here
				 * prevents the configured interface
				 * token from being overwritten later.
				 */
				pi->pi_default_token = _B_FALSE;
				pi->pi_token = sin6->sin6_addr;
				pi->pi_token._S6_un._S6_u32[0] = 0;
				pi->pi_token._S6_un._S6_u32[1] = 0;
				pi->pi_autoconf = _B_TRUE;
				(void) strlcpy(pi->pi_ipadm_aobjname,
				    ainfop->ia_aobjname,
				    sizeof (pi->pi_ipadm_aobjname));
				break;
			}
			/*
			 * If IFF_NOLINKLOCAL is set, then the link-local
			 * was created using ipadm. Do not autoconfigure until
			 * ipadm is explicitly used for autoconfiguration.
			 */
			if (ifap->ifa_flags & IFF_NOLINKLOCAL)
				pi->pi_autoconf = _B_FALSE;
		} else if (IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr) &&
		    strrchr(ifap->ifa_name, ':') == NULL) {
			/* The interface was created using ipadm. */
			pi->pi_autoconf = _B_FALSE;
		}
	}
	ipadm_free_addr_info(addrinfo);
	if (!pi->pi_autoconf) {
		pi->pi_token = in6addr_any;
		pi->pi_token_length = 0;
	}
	ipadm_close(iph);
	return (0);
}



/* ============================================================================
 * SOURCE 85/98: minix4\exokernel\kernel_legacy\cmd\cmd-inet\usr.lib\in.ripngd\main.c
 * Size: 7,639 bytes, Lines: 314
 * Hash: e3be8b0b35d8...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2005 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

/*	Copyright (c) 1983, 1984, 1985, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved  	*/

/*
 * Portions of this source code were derived from Berkeley 4.3 BSD
 * under license from the Regents of the University of California.
 */

#include "defs.h"

struct		sockaddr_in6 allrouters;
char		*control;
boolean_t	dopoison = _B_TRUE;	/* Do poison reverse */
int		iocsoc;
struct		timeval lastfullupdate;	/* last time full table multicast */
struct		timeval lastmcast;	/* last time all/changes multicast */
int		max_poll_ifs = START_POLL_SIZE;
struct		rip6 *msg;
boolean_t	needupdate;		/* true if need update at nextmcast */
struct		timeval nextmcast;	/* time to wait before changes mcast */
struct		timeval now;		/* current idea of time */
char		*packet;
struct		pollfd *poll_ifs = NULL;
int		poll_ifs_num = 0;
int		rip6_port;
boolean_t	supplier = _B_TRUE;	/* process should supply updates */

struct		in6_addr allrouters_in6 = {
/* BEGIN CSTYLED */
    { 0xff, 0x2, 0x0, 0x0,
      0x0,  0x0, 0x0, 0x0,
      0x0,  0x0, 0x0, 0x0,
      0x0,  0x0, 0x0, 0x9 }
/* END CSTYLED */
};

static void	timevalsub(struct timeval *t1, struct timeval *t2);

static void
usage(char *fname)
{
	(void) fprintf(stderr,
	    "usage: "
	    "%s [ -P ] [ -p port ] [ -q ] [ -s ] [ -t ] [ -v ] [<logfile>]\n",
	    fname);
	exit(EXIT_FAILURE);
}

int
main(int argc, char *argv[])
{
	int i, n;
	struct interface *ifp;
	int c;
	struct timeval waittime;
	int timeout;
	boolean_t daemon = _B_TRUE;	/* Fork off a detached daemon */
	FILE *pidfp;
	mode_t pidmode = (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH); /* 0644 */

	rip6_port = htons(IPPORT_ROUTESERVER6);
	allrouters.sin6_family = AF_INET6;
	allrouters.sin6_port = rip6_port;
	allrouters.sin6_addr = allrouters_in6;

	while ((c = getopt(argc, argv, "nsqvTtdgPp:")) != EOF) {
		switch (c) {
		case 'n':
			install = _B_FALSE;
			break;
		case 's':
			supplier = _B_TRUE;
			break;
		case 'q':
			supplier = _B_FALSE;
			break;
		case 'v':
			tracing |= ACTION_BIT;
			break;
		case 'T':
			daemon = _B_FALSE;
			break;
		case 't':
			tracepackets = _B_TRUE;
			daemon = _B_FALSE;
			tracing |= (INPUT_BIT | OUTPUT_BIT);
			break;
		case 'd':
			break;
		case 'P':
			dopoison = _B_FALSE;
			break;
		case 'p':
			rip6_port = htons(atoi(optarg));
			allrouters.sin6_port = rip6_port;
			break;
		default:
			usage(argv[0]);
			/* NOTREACHED */
		}
	}

	/*
	 * Any extra argument is considered
	 * a tracing log file.
	 */
	if (optind < argc) {
		traceon(argv[optind]);
	} else if (tracing && !daemon) {
		traceonfp(stdout);
	} else if (tracing) {
		(void) fprintf(stderr, "Need logfile with -v\n");
		usage(argv[0]);
		/* NOTREACHED */
	}

	if (daemon) {
		int t;

		if (fork())
			exit(EXIT_SUCCESS);
		for (t = 0; t < 20; t++) {
			if (!tracing || (t != fileno(ftrace)))
				(void) close(t);
		}
		(void) open("/", 0);
		(void) dup2(0, 1);
		(void) dup2(0, 2);
		(void) setsid();
	}

	/* Store our process id, blow away any existing file if it exists. */
	if ((pidfp = fopen(PATH_PID, "w")) == NULL) {
		(void) fprintf(stderr, "%s: unable to open " PATH_PID ": %s\n",
		    argv[0], strerror(errno));
	} else {
		(void) fprintf(pidfp, "%ld\n", getpid());
		(void) fclose(pidfp);
		(void) chmod(PATH_PID, pidmode);
	}


	iocsoc = socket(AF_INET6, SOCK_DGRAM, 0);
	if (iocsoc < 0) {
		syslog(LOG_ERR, "main: socket: %m");
		exit(EXIT_FAILURE);
	}

	setup_rtsock();

	/*
	 * Allocate the buffer to hold the RIPng packet.  In reality, it will be
	 * smaller than IPV6_MAX_PACKET octets due to (at least) the IPv6 and
	 * UDP headers but IPV6_MAX_PACKET is a convenient size.
	 */
	packet = (char *)malloc(IPV6_MAX_PACKET);
	if (packet == NULL) {
		syslog(LOG_ERR, "main: malloc: %m");
		exit(EXIT_FAILURE);
	}
	msg = (struct rip6 *)packet;

	/*
	 * Allocate the buffer to hold the ancillary data.  This data is used to
	 * insure that the incoming hop count of a RIPCMD6_RESPONSE message is
	 * IPV6_MAX_HOPS which indicates that it came from a direct neighbor
	 * (namely, no intervening router decremented it).
	 */
	control = (char *)malloc(IPV6_MAX_PACKET);
	if (control == NULL) {
		syslog(LOG_ERR, "main: malloc: %m");
		exit(EXIT_FAILURE);
	}

	openlog("in.ripngd", LOG_PID | LOG_CONS, LOG_DAEMON);

	(void) gettimeofday(&now, (struct timezone *)NULL);

	initifs();
	solicitall(&allrouters);

	if (supplier)
		supplyall(&allrouters, 0, (struct interface *)NULL, _B_TRUE);

	(void) sigset(SIGALRM, (void (*)(int))timer);
	(void) sigset(SIGHUP, (void (*)(int))initifs);
	(void) sigset(SIGTERM, (void (*)(int))term);
	(void) sigset(SIGUSR1, (void (*)(int))if_dump);
	(void) sigset(SIGUSR2, (void (*)(int))rtdump);

	/*
	 * Seed the pseudo-random number generator for GET_RANDOM().
	 */
	srandom((uint_t)gethostid());

	timer();

	for (;;) {
		if (needupdate) {
			waittime = nextmcast;
			timevalsub(&waittime, &now);
			if (waittime.tv_sec < 0) {
				timeout = 0;
			} else {
				timeout = TIME_TO_MSECS(waittime);
			}
			if (tracing & ACTION_BIT) {
				(void) fprintf(ftrace,
				    "poll until dynamic update in %d msec\n",
				    timeout);
				(void) fflush(ftrace);
			}
		} else {
			timeout = INFTIM;
		}

		if ((n = poll(poll_ifs, poll_ifs_num, timeout)) < 0) {
			if (errno == EINTR)
				continue;
			syslog(LOG_ERR, "main: poll: %m");
			exit(EXIT_FAILURE);
		}
		(void) sighold(SIGALRM);
		(void) sighold(SIGHUP);
		/*
		 * Poll timed out.
		 */
		if (n == 0) {
			if (needupdate) {
				TRACE_ACTION("send delayed dynamic update",
				    (struct rt_entry *)NULL);
				(void) gettimeofday(&now,
				    (struct timezone *)NULL);
				supplyall(&allrouters, RTS_CHANGED,
				    (struct interface *)NULL, _B_TRUE);
				lastmcast = now;
				needupdate = _B_FALSE;
				nextmcast.tv_sec = 0;
			}
			(void) sigrelse(SIGHUP);
			(void) sigrelse(SIGALRM);
			continue;
		}
		(void) gettimeofday(&now, (struct timezone *)NULL);
		for (i = 0; i < poll_ifs_num; i++) {
			/*
			 * This case should never happen.
			 */
			if (poll_ifs[i].revents & POLLERR) {
				syslog(LOG_ERR,
				    "main: poll returned a POLLERR event");
				continue;
			}
			if (poll_ifs[i].revents & POLLIN) {
				for (ifp = ifnet; ifp != NULL;
				    ifp = ifp->int_next) {
					if (poll_ifs[i].fd == ifp->int_sock)
						in_data(ifp);
				}
			}
		}
		(void) sigrelse(SIGHUP);
		(void) sigrelse(SIGALRM);
	}

	return (0);
}

void
timevaladd(struct timeval *t1, struct timeval *t2)
{
	t1->tv_sec += t2->tv_sec;
	if ((t1->tv_usec += t2->tv_usec) > 1000000) {
		t1->tv_sec++;
		t1->tv_usec -= 1000000;
	}
}

void
timevalsub(struct timeval *t1, struct timeval *t2)
{
	t1->tv_sec -= t2->tv_sec;
	if ((t1->tv_usec -= t2->tv_usec) < 0) {
		t1->tv_sec--;
		t1->tv_usec += 1000000;
	}
}



/* ============================================================================
 * SOURCE 86/98: minix4\exokernel\kernel_legacy\cmd\cmd-inet\usr.bin\ftp\main.c
 * Size: 13,960 bytes, Lines: 767
 * Hash: 41d270803f6e...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 *	Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
 *	Use is subject to license terms.
 */

/*	Copyright (c) 1983, 1984, 1985, 1986, 1987, 1988, 1989 AT&T	*/
/*	All Rights Reserved	*/

/*
 *	University Copyright- Copyright (c) 1982, 1986, 1988
 *	The Regents of the University of California
 *	All Rights Reserved
 *
 *	University Acknowledgment- Portions of this document are derived from
 *	software developed by the University of California, Berkeley, and its
 *	contributors.
 */

/*
 * FTP User Program -- Command Interface.
 */
#include	"ftp_var.h"
#include	<deflt.h>	/* macros that make using libcmd easier */

int	trace;
int	hash;
int	sendport;
int	verbose;
int	connected;
int	fromatty;
int	interactive;
int	debug;
int	bell;
int	doglob;
int	autologin;
int	proxy;
int	proxflag;
int	sunique;
int	runique;
int	mcase;
int	ntflag;
int	mapflag;
int	code;
int	crflag;
char	pasv[64];
char	*altarg;
char	ntin[17];
char	ntout[17];
char	mapin[MAXPATHLEN];
char	mapout[MAXPATHLEN];
char	typename[32];
int	type;
char	structname[32];
int	stru;
char	formname[32];
int	form;
char	modename[32];
int	mode;
char	bytename[32];
int	bytesize;
int	passivemode;
off_t	restart_point;
int	tcpwindowsize;
boolean_t ls_invokes_NLST;
char	*hostname;
char	*home;
char	*globerr;
struct	sockaddr_in6 myctladdr;
struct	sockaddr_in6 remctladdr;
int	clevel;
int	dlevel;
int	autoauth;
int	auth_error;
int	autoencrypt;
int	fflag;
boolean_t goteof;
int	skipsyst;
char	mechstr[MECH_SZ];
char	*buf;
jmp_buf	toplevel;
char	line[BUFSIZE];
char	*stringbase;
char	argbuf[BUFSIZE];
char	*argbase;
int	margc;
char	**margv;
int	cpend;
int	mflag;
char	reply_buf[FTPBUFSIZ];
char	*reply_ptr;
int	options;
int	timeout;
int	timeoutms;
jmp_buf	timeralarm;
int	macnum;
struct macel macros[16];
char	macbuf[4096];

static void usage(void);
static void timeout_sig(int sig);
static void cmdscanner(int top);
static void intr(int sig);
static char *slurpstring(void);
extern	int use_eprt;

boolean_t ls_invokes_NLST = B_TRUE;

#include <gssapi/gssapi.h>
#include <gssapi/gssapi_ext.h>
#define	GETOPT_STR	"dginpstvET:axfm:"
#define	USAGE_STR	"[-adfginpstvx] [-m mech] [-T timeout] " \
			"[hostname [port]]"

int
main(int argc, char *argv[])
{
	char *cp;
	int c, top;
	struct passwd *pw = NULL;
	char homedir[MAXPATHLEN];
	char *temp_string = NULL;

	(void) setlocale(LC_ALL, "");

	buf = (char *)memalign(getpagesize(), FTPBUFSIZ);
	if (buf == NULL) {
		(void) fprintf(stderr, "ftp: memory allocation failed\n");
		return (1);
	}

	timeoutms = timeout = 0;
	doglob = 1;
	interactive = 1;
	autologin = 1;

	autoauth = 0;
	/* by default SYST command will be sent to determine system type */
	skipsyst = 0;
	fflag = 0;
	autoencrypt = 0;
	goteof = 0;
	mechstr[0] = '\0';

	sendport = -1;	/* tri-state variable. start out in "automatic" mode. */
	passivemode = 0;

	while ((c = getopt(argc, argv, GETOPT_STR)) != EOF) {
		switch (c) {
		case 'd':
			options |= SO_DEBUG;
			debug++;
			break;

		case 'g':
			doglob = 0;
			break;

		case 'i':
			interactive = 0;
			break;

		case 'n':
			autologin = 0;
			break;

		case 'p':
			passivemode = 1;
			break;

		case 't':
			trace++;
			break;

		case 'v':
			verbose++;
			break;

		/* undocumented option: allows testing of EPRT */
		case 'E':
			use_eprt = 1;
			break;

		case 'T':
			if (!isdigit(*optarg)) {
				(void) fprintf(stderr,
				    "ftp: bad timeout: \"%s\"\n", optarg);
				break;
			}
			timeout = atoi(optarg);
			timeoutms = timeout * MILLISEC;
			break;

		case 'a':
			autoauth = 1;
			break;

		case 'f':
			autoauth = 1;
			fflag = 1;
			break;

		case 'm':
			autoauth = 1;
			call(setmech, "ftp", optarg, 0);
			if (code != 0)
				exit(1);
			break;

		case 'x':
			autoauth = 1;
			autoencrypt = 1;
			break;

		case 's':
			skipsyst = 1;
			break;

		case '?':
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

	if (argc > 2)
		usage();

	fromatty = isatty(fileno(stdin));
	/*
	 * Scan env, then DEFAULTFTPFILE
	 * for FTP_LS_SENDS_NLST
	 */
	temp_string = getenv("FTP_LS_SENDS_NLST");
	if (temp_string == NULL) {	/* env var not set */
		if (defopen(DEFAULTFTPFILE) == 0) {
			/*
			 * turn off case sensitivity
			 */
			int flags = defcntl(DC_GETFLAGS, 0);

			TURNOFF(flags, DC_CASE);
			(void) defcntl(DC_SETFLAGS, flags);

			temp_string = defread("FTP_LS_SENDS_NLST=");
			(void) defopen(NULL);	/* close default file */
		}
	}
	if (temp_string != NULL &&
	    strncasecmp(temp_string, "n", 1) == 0)
		ls_invokes_NLST = B_FALSE;

	/*
	 * Set up defaults for FTP.
	 */
	(void) strcpy(typename, "ascii"), type = TYPE_A;
	(void) strcpy(formname, "non-print"), form = FORM_N;
	(void) strcpy(modename, "stream"), mode = MODE_S;
	(void) strcpy(structname, "file"), stru = STRU_F;
	(void) strcpy(bytename, "8"), bytesize = 8;
	if (fromatty)
		verbose++;
	cpend = 0;	/* no pending replies */
	proxy = 0;	/* proxy not active */
	crflag = 1;	/* strip c.r. on ascii gets */

	if (mechstr[0] == '\0') {
		strlcpy(mechstr, FTP_DEF_MECH, MECH_SZ);
	}

	/*
	 * Set up the home directory in case we're globbing.
	 */
	cp = getlogin();
	if (cp != NULL) {
		pw = getpwnam(cp);
	}
	if (pw == NULL)
		pw = getpwuid(getuid());
	if (pw != NULL) {
		home = homedir;
		(void) strcpy(home, pw->pw_dir);
	}
	if (setjmp(timeralarm)) {
		(void) fflush(stdout);
		(void) printf("Connection timeout\n");
		exit(1);
	}
	(void) signal(SIGALRM, timeout_sig);
	reset_timer();
	if (argc > 0) {
		int nargc = 0;
		char *nargv[4];

		if (setjmp(toplevel))
			return (0);
		(void) signal(SIGINT, intr);
		(void) signal(SIGPIPE, lostpeer);
		nargv[nargc++] = "ftp";
		nargv[nargc++] = argv[0];		/* hostname */
		if (argc > 1)
			nargv[nargc++] = argv[1];	/* port */
		nargv[nargc] = NULL;
		setpeer(nargc, nargv);
	}
	top = setjmp(toplevel) == 0;
	if (top) {
		(void) signal(SIGINT, intr);
		(void) signal(SIGPIPE, lostpeer);
	}

	for (;;) {
		cmdscanner(top);
		top = 1;
	}
}

static void
usage(void)
{
	(void) fprintf(stderr, "usage: ftp %s\n", USAGE_STR);
	exit(1);
}

void
reset_timer()
{
	/* The test is just to reduce syscalls if timeouts aren't used */
	if (timeout)
		alarm(timeout);
}

void
stop_timer()
{
	if (timeout)
		alarm(0);
}

/*ARGSUSED*/
static void
timeout_sig(int sig)
{
	longjmp(timeralarm, 1);
}

/*ARGSUSED*/
static void
intr(int sig)
{
	longjmp(toplevel, 1);
}

/*ARGSUSED*/
void
lostpeer(int sig)
{
	extern FILE *ctrl_out;
	extern int data;

	if (connected) {
		if (ctrl_out != NULL) {
			(void) shutdown(fileno(ctrl_out), 1+1);
			(void) fclose(ctrl_out);
			ctrl_out = NULL;
		}
		if (data >= 0) {
			(void) shutdown(data, 1+1);
			(void) close(data);
			data = -1;
		}
		connected = 0;

		auth_type = AUTHTYPE_NONE;
		clevel = dlevel = PROT_C;
		goteof = 0;
	}
	pswitch(1);
	if (connected) {
		if (ctrl_out != NULL) {
			(void) shutdown(fileno(ctrl_out), 1+1);
			(void) fclose(ctrl_out);
			ctrl_out = NULL;
		}
		connected = 0;

		auth_type = AUTHTYPE_NONE;
		clevel = dlevel = PROT_C;
		goteof = 0;
	}
	proxflag = 0;
	pswitch(0);
}

/*
 * Command parser.
 */
static void
cmdscanner(int top)
{
	struct cmd *c;

	if (!top)
		(void) putchar('\n');
	for (;;) {
		stop_timer();
		if (fromatty) {
			(void) printf("ftp> ");
			(void) fflush(stdout);
		}
		if (fgets(line, sizeof (line), stdin) == 0) {
			if (feof(stdin) || ferror(stdin))
				quit(0, NULL);
			break;
		}
		if (line[0] == 0)
			break;
		/* If not all, just discard rest of line */
		if (line[strlen(line)-1] != '\n') {
			while (fgetc(stdin) != '\n' && !feof(stdin) &&
			    !ferror(stdin))
				;
			(void) printf("Line too long\n");
			continue;
		} else
			line[strlen(line)-1] = 0;

		makeargv();
		if (margc == 0) {
			continue;
		}
		c = getcmd(margv[0]);
		if (c == (struct cmd *)-1) {
			(void) printf("?Ambiguous command\n");
			continue;
		}
		if (c == 0) {
			(void) printf("?Invalid command\n");
			continue;
		}
		if (c->c_conn && !connected) {
			(void) printf("Not connected.\n");
			continue;
		}
		reset_timer();
		(*c->c_handler)(margc, margv);
#ifndef CTRL
#define	CTRL(c) ((c)&037)
#endif
		stop_timer();
		if (bell && c->c_bell)
			(void) putchar(CTRL('g'));
		if (c->c_handler != help)
			break;
	}
	(void) signal(SIGINT, intr);
	(void) signal(SIGPIPE, lostpeer);
}

struct cmd *
getcmd(char *name)
{
	char *p, *q;
	struct cmd *c, *found;
	int nmatches, longest;
	extern struct cmd cmdtab[];

	if (name == NULL)
		return (0);

	longest = 0;
	nmatches = 0;
	found = 0;
	for (c = cmdtab; (p = c->c_name) != NULL; c++) {
		for (q = name; *q == *p++; q++)
			if (*q == 0)		/* exact match? */
				return (c);
		if (!*q) {			/* the name was a prefix */
			if (q - name > longest) {
				longest = q - name;
				nmatches = 1;
				found = c;
			} else if (q - name == longest)
				nmatches++;
		}
	}
	if (nmatches > 1)
		return ((struct cmd *)-1);
	return (found);
}

/*
 * Slice a string up into argc/argv.
 */

static int slrflag;
#define	MARGV_INC	20

void
makeargv(void)
{
	char **argp;
	static int margv_size;

	margc = 0;
	stringbase = line;		/* scan from first of buffer */
	argbase = argbuf;		/* store from first of buffer */
	slrflag = 0;

	if (!margv) {
		margv_size = MARGV_INC;
		if ((margv = malloc(margv_size * sizeof (char *))) == NULL)
			fatal("Out of memory");
	}
	argp = margv;
	while (*argp++ = slurpstring()) {
		margc++;
		if (margc == margv_size) {
			margv_size += MARGV_INC;
			if ((margv = realloc(margv,
			    margv_size * sizeof (char *))) == NULL)
				fatal("Out of memory");
			argp = margv + margc;
		}
	}
}

/*
 * Parse string into argbuf;
 * implemented with FSM to
 * handle quoting and strings
 */
static char *
slurpstring(void)
{
	int got_one = 0;
	char *sb = stringbase;
	char *ap = argbase;
	char *tmp = argbase;		/* will return this if token found */
	int	len;

	if (*sb == '!' || *sb == '$') {	/* recognize ! as a token for shell */
		switch (slrflag) {	/* and $ as token for macro invoke */
			case 0:
				slrflag++;
				stringbase++;
				return ((*sb == '!') ? "!" : "$");
			case 1:
				slrflag++;
				altarg = stringbase;
				break;
			default:
				break;
		}
	}

S0:
	switch (*sb) {

	case '\0':
		goto OUT;

	case ' ':
	case '\t':
		sb++; goto S0;

	default:
		switch (slrflag) {
			case 0:
				slrflag++;
				break;
			case 1:
				slrflag++;
				altarg = sb;
				break;
			default:
				break;
		}
		goto S1;
	}

S1:
	switch (*sb) {

	case ' ':
	case '\t':
	case '\0':
		goto OUT;	/* end of token */

	case '\\':
		sb++; goto S2;	/* slurp next character */

	case '"':
		sb++; goto S3;	/* slurp quoted string */

	default:
		if ((len = mblen(sb, MB_CUR_MAX)) <= 0)
			len = 1;
		memcpy(ap, sb, len);
		ap += len;
		sb += len;
		got_one = 1;
		goto S1;
	}

S2:
	switch (*sb) {

	case '\0':
		goto OUT;

	default:
		if ((len = mblen(sb, MB_CUR_MAX)) <= 0)
			len = 1;
		memcpy(ap, sb, len);
		ap += len;
		sb += len;
		got_one = 1;
		goto S1;
	}

S3:
	switch (*sb) {

	case '\0':
		goto OUT;

	case '"':
		sb++; goto S1;

	default:
		if ((len = mblen(sb, MB_CUR_MAX)) <= 0)
			len = 1;
		memcpy(ap, sb, len);
		ap += len;
		sb += len;
		got_one = 1;
		goto S3;
	}

OUT:
	if (got_one)
		*ap++ = '\0';
	argbase = ap;			/* update storage pointer */
	stringbase = sb;		/* update scan pointer */
	if (got_one) {
		return (tmp);
	}
	switch (slrflag) {
		case 0:
			slrflag++;
			break;
		case 1:
			slrflag++;
			altarg = (char *)0;
			break;
		default:
			break;
	}
	return ((char *)0);
}

#define	HELPINDENT (sizeof ("directory"))

/*
 * Help command.
 * Call each command handler with argc == 0 and argv[0] == name.
 */
void
help(int argc, char *argv[])
{
	struct cmd *c;
	extern struct cmd cmdtab[];

	if (argc == 1) {
		int i, j, w, k;
		int columns, width = 0, lines;
		extern int NCMDS;

		(void) printf(
		    "Commands may be abbreviated.  Commands are:\n\n");
		for (c = cmdtab; c < &cmdtab[NCMDS]; c++) {
			int len = strlen(c->c_name);

			if (len > width)
				width = len;
		}
		width = (width + 8) &~ 7;
		columns = 80 / width;
		if (columns == 0)
			columns = 1;
		lines = (NCMDS + columns - 1) / columns;
		for (i = 0; i < lines; i++) {
			for (j = 0; j < columns; j++) {
				c = cmdtab + j * lines + i;
				if (c->c_name && (!proxy || c->c_proxy)) {
					(void) printf("%s", c->c_name);
				} else if (c->c_name) {
					for (k = 0; k < strlen(c->c_name);
					    k++) {
						(void) putchar(' ');
					}
				}
				if (c + lines >= &cmdtab[NCMDS]) {
					(void) printf("\n");
					break;
				}
				w = strlen(c->c_name);
				while (w < width) {
					w = (w + 8) &~ 7;
					(void) putchar('\t');
				}
			}
		}
		return;
	}
	while (--argc > 0) {
		char *arg;
		arg = *++argv;
		c = getcmd(arg);
		if (c == (struct cmd *)-1)
			(void) printf("?Ambiguous help command %s\n", arg);
		else if (c == (struct cmd *)0)
			(void) printf("?Invalid help command %s\n", arg);
		else
			(void) printf("%-*s\t%s\n", HELPINDENT,
			    c->c_name, c->c_help);
	}
}

/*
 * Call routine with argc, argv set from args (terminated by 0).
 */
void
call(void (*routine)(int argc, char *argv[]), ...)
{
	va_list ap;
	char *argv[10];
	int argc = 0;

	va_start(ap, routine);
	while ((argv[argc] = va_arg(ap, char *)) != (char *)0)
		argc++;
	va_end(ap);
	(*routine)(argc, argv);
}



/* ============================================================================
 * SOURCE 87/98: minix4\exokernel\kernel_legacy\cmd\cmd-inet\usr.bin\pppd\main.c
 * Size: 74,675 bytes, Lines: 2,934
 * Hash: 3ee2c71c6c59...
 * ============================================================================ */

/*
 * main.c - Point-to-Point Protocol main module
 *
 * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation is hereby granted, provided that the above copyright
 * notice appears in all copies.
 *
 * SUN MAKES NO REPRESENTATION OR WARRANTIES ABOUT THE SUITABILITY OF
 * THE SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
 * TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE, OR NON-INFRINGEMENT.  SUN SHALL NOT BE LIABLE FOR
 * ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING OR
 * DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES
 *
 * Copyright (c) 1989 Carnegie Mellon University.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by Carnegie Mellon University.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */
/*
 * Copyright (c) 2016 by Delphix. All rights reserved.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>
#include <errno.h>
#include <fcntl.h>
#include <syslog.h>
#include <netdb.h>
#include <pwd.h>
#include <setjmp.h>
#include <sys/param.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include "pppd.h"
#include "magic.h"
#include "fsm.h"
#include "lcp.h"
#include "ipcp.h"
#ifdef INET6
#include "ipv6cp.h"
#endif
#include "upap.h"
#include "chap.h"
#include "ccp.h"
#include "pathnames.h"
#include "patchlevel.h"

#ifdef HAVE_MULTILINK
#include "tdb.h"
#endif

#ifdef CBCP_SUPPORT
#include "cbcp.h"
#endif

#ifdef IPX_CHANGE
#include "ipxcp.h"
#endif /* IPX_CHANGE */
#ifdef AT_CHANGE
#include "atcp.h"
#endif

/* interface vars */
char ifname[32];		/* Interface name */
int ifunit = -1;		/* Interface unit number */

char *progname;			/* Name of this program */
char hostname[MAXHOSTNAMELEN+1]; /* Our hostname */
static char pidfilename[MAXPATHLEN]; /* name of pid file */
static char linkpidfile[MAXPATHLEN]; /* name of linkname pid file */
char ppp_devnam[MAXPATHLEN];	/* name of PPP tty (maybe ttypx) */
static uid_t uid;		/* Our real user-id */
static int conn_running;	/* we have a [dis]connector running */

int ttyfd;			/* Serial port file descriptor */
mode_t tty_mode = (mode_t)-1;	/* Original access permissions to tty */
int baud_rate;			/* Actual bits/second for serial device */
bool hungup;			/* terminal has been hung up */
bool privileged;		/* we're running as real uid root */
bool need_holdoff;		/* need holdoff period before restarting */
bool detached;			/* have detached from terminal */
struct stat devstat;		/* result of stat() on devnam */
bool prepass = 0;		/* doing prepass to find device name */
int devnam_fixed;		/* set while in options.ttyxx file */
volatile int status;		/* exit status for pppd */
int unsuccess;			/* # unsuccessful connection attempts */
int do_callback;		/* != 0 if we should do callback next */
int doing_callback;		/* != 0 if we are doing callback */
char *callback_script;		/* script for doing callback */
#ifdef HAVE_MULTILINK
TDB_CONTEXT *pppdb;		/* database for storing status etc. */
char db_key[32];
#endif

/*
 * For plug-in usage:
 *
 *	holdoff_hook - Can be used to change the demand-dial hold-off
 *		time dynamically.  This is normally set by the
 *		"holdoff" option, and is 30 seconds by default.
 *
 *	new_phase_hook - This is called for each change in the PPP
 *		phase (per RFC 1661).  This can be used to log
 *		progress.
 *
 *	check_options_hook - This is called before doing sys_init()
 *		and allows the plugin to verify the selected options.
 *
 *	updown_script_hook - This is called with the proposed
 *		command-line arguments for any of the
 *		/etc/ppp/{ip,ipv6,ipx,auth}-{up,down} scripts before
 *		fork/exec.  It can be used to add or change arguments.
 *
 *	device_pipe_hook - If this is set, then an extra fd (3) is
 *		passed to the connect/disconnect script.  This extra
 *		fd is the write side of a pipe, and the read side is
 *		passed to this routine.  This can be used to pass
 *		arbitrary data from the script back to pppd.
 */
int (*holdoff_hook) __P((void)) = NULL;
int (*new_phase_hook) __P((int new, int old)) = NULL;
int (*check_options_hook) __P((uid_t uid)) = NULL;
int (*updown_script_hook) __P((const char ***argsp)) = NULL;
void (*device_pipe_hook) __P((int pipefd)) = NULL;

static int fd_ppp = -1;		/* fd for talking PPP */
static int fd_loop;		/* fd for getting demand-dial packets */
static int pty_master;		/* fd for master side of pty */
int pty_slave = -1;		/* fd for slave side of pty */
static int real_ttyfd;		/* fd for actual serial port (not pty) */

int phase;			/* where the link is at */
int kill_link;
int open_ccp_flag;

static int waiting;		/* for input from peer or timer expiration */
static sigjmp_buf sigjmp;

char **script_env;		/* Env. variable values for scripts */
int s_env_nalloc;		/* # words avail at script_env */

u_char outpacket_buf[PPP_MRU+PPP_HDRLEN]; /* buffer for outgoing packet */
u_char inpacket_buf[PPP_MRU+PPP_HDRLEN]; /* buffer for incoming packet */
u_char nak_buffer[PPP_MRU];	/* where we construct a nak packet */

static int n_children;		/* # child processes still running */
static bool got_sigchld;	/* set if we have received a SIGCHLD */
static sigset_t main_sigmask;	/* signals blocked while dispatching */

static bool locked;		/* lock() has succeeded */
static bool privopen;		/* don't lock, open device as root */

char *no_ppp_msg = "Sorry - this system lacks PPP kernel support\n";

GIDSET_TYPE groups[NGROUPS_MAX];/* groups the user is in */
int ngroups;			/* How many groups valid in groups */

static struct timeval start_time; /* Time when link was started. */

struct pppd_stats link_stats;
int link_connect_time;
bool link_stats_valid;

static pid_t charshunt_pid;	/* Process ID for charshunt */

extern option_t general_options[];
extern option_t auth_options[];

/*
 * We maintain a list of child process pids and
 * functions to call when they exit.
 */
struct subprocess {
    pid_t	pid;
    char	*prog;
    void	(*done) __P((void *, int));
    void	*arg;
    struct subprocess *next;
};

static struct subprocess *children;

/* Prototypes for procedures local to this file. */

static void setup_signals __P((void));
static void create_pidfile __P((void));
static void create_linkpidfile __P((void));
static void cleanup __P((void));
static void close_tty __P((void));
static void get_input __P((void));
static void calltimeout __P((void));
static struct timeval *timeleft __P((struct timeval *));
static void kill_my_pg __P((int));
static void hup __P((int));
static void term __P((int));
static void chld __P((int));
static void toggle_debug __P((int));
static void open_ccp __P((int));
static void bad_signal __P((int));
static void holdoff_end __P((void *));
static int device_script __P((char *, int, int, int, char *));
static int reap_kids __P((int waitfor));
static void record_child __P((pid_t, char *, void (*) (void *, int), void *));
static int open_socket __P((char *));
static int start_charshunt __P((int, int));
static void charshunt_done __P((void *, int));
static void charshunt __P((int, int, char *));
static int record_write __P((FILE *, int code, u_char *buf, int nb,
    struct timeval *));
static void final_reap __P((void));

#ifdef HAVE_MULTILINK
static void update_db_entry __P((void));
static void add_db_key __P((const char *));
static void delete_db_key __P((const char *));
static void cleanup_db __P((void));
#endif

int main __P((int, char *[]));

#ifdef ultrix
#undef	O_NONBLOCK
#define	O_NONBLOCK	O_NDELAY
#endif

#ifdef ULTRIX
#define setlogmask(x)	0
#endif

/* Backward compatibility for Linux */
#ifndef RECMARK_TIMESTART
#define	RECMARK_STARTSEND	1
#define	RECMARK_STARTRECV	2
#define	RECMARK_ENDSEND		3
#define	RECMARK_ENDRECV		4
#define	RECMARK_TIMEDELTA32	5
#define	RECMARK_TIMEDELTA8	6
#define	RECMARK_TIMESTART	7
#endif

/*
 * PPP Data Link Layer "protocol" table.
 * One entry per supported protocol.
 * The last entry must be NULL.
 */
struct protent *protocols[] = {
    &lcp_protent,
    &pap_protent,
    &chap_protent,
#ifdef CBCP_SUPPORT
    &cbcp_protent,
#endif
    &ipcp_protent,
#ifdef INET6
    &ipv6cp_protent,
#endif
    &ccp_protent,
#ifdef IPX_CHANGE
    &ipxcp_protent,
#endif
#ifdef AT_CHANGE
    &atcp_protent,
#endif
    NULL
};

int
main(argc, argv)
    int argc;
    char *argv[];
{
    int i, fdflags, t;
    char *p, *connector;
    struct passwd *pw;
    struct timeval timo;
    struct protent *protp;
    struct stat statbuf;
    char numbuf[16];

    ifname[0] = '\0';
    new_phase(PHASE_INITIALIZE);

    /*
     * Ensure that fds 0, 1, 2 are open, to /dev/null if nowhere else.
     * This way we can close 0, 1, 2 in detach() without clobbering
     * a fd that we are using.
     */
    if ((i = open(_PATH_DEVNULL, O_RDWR)) >= 0) {
	while (0 <= i && i <= 2)
	    i = dup(i);
	if (i >= 0)
	    (void) close(i);
    }

    script_env = NULL;

    /* Initialize syslog facilities */
    reopen_log();

    if (gethostname(hostname, MAXHOSTNAMELEN+1) < 0 ) {
	option_error("Couldn't get hostname: %m");
	exit(1);
    }
    hostname[MAXHOSTNAMELEN] = '\0';

    /* make sure we don't create world or group writable files. */
    (void) umask(umask(0777) | 022);

    uid = getuid();
    privileged = (uid == 0);
    (void) slprintf(numbuf, sizeof(numbuf), "%d", uid);
    script_setenv("ORIG_UID", numbuf, 0);

    ngroups = getgroups(NGROUPS_MAX, groups);

    /*
     * Initialize magic number generator now so that protocols may
     * use magic numbers in initialization.
     */
    magic_init();

    progname = *argv;
    prepass = 0;
    /*
     * Initialize to the standard option set, then parse, in order, the
     * system options file, the user's options file, the tty's options file,
     * and the command line arguments.  At last, install the options declared
     * by each protocol into the extra_option list.
     */
    for (i = 0; (protp = protocols[i]) != NULL; ++i) {
        (*protp->init)(0);
	if (protp->options != NULL) {
	    add_options(protp->options);
	}
    }

    /*
     * Install "generic" options into the extra_options list.
     */
    add_options(auth_options);
    add_options(general_options);

    /* Install any system-specific options (or remove unusable ones) */
    sys_options();

    if (!options_from_file(_PATH_SYSOPTIONS, !privileged, 0, 1)
	|| !options_from_user())
	exit(EXIT_OPTION_ERROR);

    /* scan command line and options files to find device name */
    prepass = 1;
    (void) parse_args(argc-1, argv+1);
    prepass = 0;

    /*
     * Work out the device name, if it hasn't already been specified.
     */
    using_pty = notty || ptycommand != NULL || pty_socket != NULL;
    if (!using_pty && default_device && !direct_tty) {
	char *p;

	if (!isatty(0) || (p = ttyname(0)) == NULL) {
	    option_error("no device specified and stdin is not a tty");
	    exit(EXIT_OPTION_ERROR);
	}
	(void) strlcpy(devnam, p, sizeof(devnam));
	if (stat(devnam, &devstat) < 0)
	    fatal("Couldn't stat default device %s: %m", devnam);
    }

    /*
     * Parse the tty options file and the command line.
     * The per-tty options file should not change
     * ptycommand, pty_socket, notty or devnam.
     */
    devnam_fixed = 1;
    if (!using_pty && !direct_tty) {
	if (!options_for_tty())
	    exit(EXIT_OPTION_ERROR);
    }

    devnam_fixed = 0;
    if (!parse_args(argc-1, argv+1))
	exit(EXIT_OPTION_ERROR);

    /*
     * Check that we are running as root.
     */
    if (geteuid() != 0) {
	option_error("must be root to run %s, since it is not setuid-root",
		     argv[0]);
	exit(EXIT_NOT_ROOT);
    }

    if (!ppp_available()) {
	option_error(no_ppp_msg);
	exit(EXIT_NO_KERNEL_SUPPORT);
    }

    /*
     * Check that the options given are valid and consistent.
     */
    if (!sys_check_options())
	exit(EXIT_OPTION_ERROR);
    auth_check_options();
#ifdef HAVE_MULTILINK
    mp_check_options();
#endif
    for (i = 0; (protp = protocols[i]) != NULL; ++i)
	if (protp->enabled_flag && protp->check_options != NULL)
	    (*protp->check_options)();
    if (demand && (connect_script == NULL)) {
	option_error("connect script is required for demand-dialling\n");
	exit(EXIT_OPTION_ERROR);
    }
    if (updetach && (nodetach || demand)) {
	option_error("updetach cannot be used with %s",
	    nodetach ? "nodetach" : "demand");
	exit(EXIT_OPTION_ERROR);
    }
    /* default holdoff to 0 if no connect script has been given */
    if ((connect_script == NULL) && !holdoff_specified)
	holdoff = 0;

    if (using_pty || direct_tty) {
	if (!default_device) {
	    option_error("%s option precludes specifying device name",
			 notty? "notty": "pty");
	    exit(EXIT_OPTION_ERROR);
	}
	if (ptycommand != NULL && (notty || direct_tty)) {
	    option_error("pty option is incompatible with notty option");
	    exit(EXIT_OPTION_ERROR);
	}
	if (pty_socket != NULL && (ptycommand != NULL || notty ||
	    direct_tty)) {
	    option_error("socket option is incompatible with pty and notty");
	    exit(EXIT_OPTION_ERROR);
	}
	default_device = notty || direct_tty;
	lockflag = 0;
	modem = 0;
	if (default_device && log_to_fd <= 1)
	    log_to_fd = -1;
    } else {
	/*
	 * If the user has specified a device which is the same as
	 * the one on stdin, pretend they didn't specify any.
	 * If the device is already open read/write on stdin,
	 * we assume we don't need to lock it, and we can open it as root.
	 */
	if (fstat(0, &statbuf) >= 0 && S_ISCHR(statbuf.st_mode)
	    && statbuf.st_rdev == devstat.st_rdev) {
	    default_device = 1;
	    fdflags = fcntl(0, F_GETFL);
	    if (fdflags != -1 && (fdflags & O_ACCMODE) == O_RDWR)
		privopen = 1;
	}
    }
    if (default_device)
	nodetach = 1;

    /*
     * Don't send log messages to the serial port, it tends to
     * confuse the peer. :-)
     */
    if (log_to_fd >= 0 && fstat(log_to_fd, &statbuf) >= 0
	&& S_ISCHR(statbuf.st_mode) && statbuf.st_rdev == devstat.st_rdev)
	log_to_fd = -1;
    early_log = 0;

    if (debug)
	(void) setlogmask(LOG_UPTO(LOG_DEBUG));

    /*
     * Initialize system-dependent stuff.
     */
    if (check_options_hook != NULL &&
	(*check_options_hook)(uid) == -1) {
	exit(EXIT_OPTION_ERROR);
    }
    sys_init(!devnam_info.priv && !privopen);

#ifdef HAVE_MULTILINK
    pppdb = tdb_open(_PATH_PPPDB, 0, 0, O_RDWR|O_CREAT, 0644);
    if (pppdb != NULL) {
	(void) slprintf(db_key, sizeof(db_key), "pppd%d", getpid());
	update_db_entry();
    } else {
	warn("Warning: couldn't open ppp database %s", _PATH_PPPDB);
	if (multilink) {
	    warn("Warning: disabling multilink");
	    multilink = 0;
	}
    }
#endif

    /*
     * Detach ourselves from the terminal, if required, and identify
     * who is running us.  Printing to stderr stops here unless
     * nodetach or updetach is set.
     */
    if (!nodetach && !updetach)
	detach();
    p = getlogin();
    if (p == NULL) {
	pw = getpwuid(uid);
	if (pw != NULL && pw->pw_name != NULL)
	    p = pw->pw_name;
	else
	    p = "(unknown)";
    }
    syslog(LOG_NOTICE, "pppd %s.%d%s started by %s, uid %d",
	   VERSION, PATCHLEVEL, IMPLEMENTATION, p, uid);
    script_setenv("PPPLOGNAME", p, 0);

    if (devnam[0] != '\0')
	script_setenv("DEVICE", devnam, 1);
    (void) slprintf(numbuf, sizeof(numbuf), "%d", getpid());
    script_setenv("PPPD_PID", numbuf, 1);

    setup_signals();

    waiting = 0;

    create_linkpidfile();

    /*
     * If we're doing dial-on-demand, set up the interface now.
     */
    if (demand) {
	/*
	 * Open the loopback channel and set it up to be the ppp interface.
	 */
#ifdef HAVE_MULTILINK
	(void) tdb_writelock(pppdb);
#endif
	set_ifunit(1);
	fd_loop = open_ppp_loopback();
#ifdef HAVE_MULTILINK
	(void) tdb_writeunlock(pppdb);
#endif

	/*
	 * Configure the interface and mark it up, etc.
	 */
	demand_conf();
    }

    new_phase(PHASE_INITIALIZED);
    do_callback = 0;
    for (;;) {

	need_holdoff = 1;
	ttyfd = -1;
	real_ttyfd = -1;
	status = EXIT_OK;
	++unsuccess;
	doing_callback = do_callback;
	do_callback = 0;

	if (demand && !doing_callback) {
	    /*
	     * Don't do anything until we see some activity.
	     */
	    kill_link = 0;
	    new_phase(PHASE_DORMANT);
	    demand_unblock();
	    add_fd(fd_loop);
	    for (;;) {
		if (sigsetjmp(sigjmp, 1) == 0) {
		    (void) sigprocmask(SIG_BLOCK, &main_sigmask, NULL);
		    if (kill_link || got_sigchld) {
			(void) sigprocmask(SIG_UNBLOCK, &main_sigmask, NULL);
		    } else {
			waiting = 1;
			(void) sigprocmask(SIG_UNBLOCK, &main_sigmask, NULL);
			wait_input(timeleft(&timo));
		    }
		}
		waiting = 0;
		calltimeout();
		if (kill_link) {
		    if (!persist)
			break;
		    kill_link = 0;
		}
		if (get_loop_output())
		    break;
		if (got_sigchld)
		    (void) reap_kids(0);
	    }
	    remove_fd(fd_loop);
	    if (kill_link && !persist)
		break;

	    /*
	     * Now we want to bring up the link.
	     */
	    demand_block();
	    info("Starting link");
	}

	new_phase(doing_callback ? PHASE_CALLINGBACK : PHASE_SERIALCONN);

	/*
	 * Get a pty master/slave pair if the pty, notty, socket,
	 * or record options were specified.
	 */
	(void) strlcpy(ppp_devnam, devnam, sizeof(ppp_devnam));
	pty_master = -1;
	pty_slave = -1;
	if (using_pty || record_file != NULL) {
	    if (!get_pty(&pty_master, &pty_slave, ppp_devnam, uid)) {
		error("Couldn't allocate pseudo-tty");
		status = EXIT_FATAL_ERROR;
		goto fail;
	    }
	    set_up_tty(pty_slave, 1);
	}

	/*
	 * Lock the device if we've been asked to.
	 */
	status = EXIT_LOCK_FAILED;
	if (lockflag && !privopen && !direct_tty) {
	    if (lock(devnam) < 0)
		goto fail;
	    locked = 1;
	}

	/*
	 * Open the serial device and set it up to be the ppp interface.
	 * First we open it in non-blocking mode so we can set the
	 * various termios flags appropriately.  If we aren't dialling
	 * out and we want to use the modem lines, we reopen it later
	 * in order to wait for the carrier detect signal from the modem.
	 */
	hungup = 0;
	kill_link = 0;
	connector = doing_callback? callback_script: connect_script;
	if (direct_tty) {
	    ttyfd = 0;
	} else if (devnam[0] != '\0') {
	    for (;;) {
		/* If the user specified the device name, become the
		   user before opening it. */
		int err;
		if (!devnam_info.priv && !privopen)
		    (void) seteuid(uid);
		if ((ttyfd = sys_extra_fd()) < 0)
		    ttyfd = open(devnam, O_NONBLOCK | O_RDWR);
		err = errno;
		if (!devnam_info.priv && !privopen)
		    (void) seteuid(0);
		if (ttyfd >= 0)
		    break;
		errno = err;
		if (err != EINTR) {
		    error("Failed to open %s: %m", devnam);
		    status = EXIT_OPEN_FAILED;
		}
		if (!persist || err != EINTR)
		    goto fail;
	    }
	    if ((fdflags = fcntl(ttyfd, F_GETFL)) == -1
		|| fcntl(ttyfd, F_SETFL, fdflags & ~O_NONBLOCK) < 0)
		warn("Couldn't reset non-blocking mode on device: %m");

	    /*
	     * Do the equivalent of `mesg n' to stop broadcast messages.
	     */
	    if (fstat(ttyfd, &statbuf) < 0
		|| fchmod(ttyfd, statbuf.st_mode & ~(S_IWGRP | S_IWOTH)) < 0) {
		warn("Couldn't restrict write permissions to %s: %m", devnam);
	    } else
		tty_mode = statbuf.st_mode;

	    /*
	     * Set line speed, flow control, etc.
	     * If we have a non-null connection or initializer script,
	     * on most systems we set CLOCAL for now so that we can talk
	     * to the modem before carrier comes up.  But this has the
	     * side effect that we might miss it if CD drops before we
	     * get to clear CLOCAL below.  On systems where we can talk
	     * successfully to the modem with CLOCAL clear and CD down,
	     * we could clear CLOCAL at this point.
	     */
	    set_up_tty(ttyfd, ((connector != NULL && connector[0] != '\0')
			       || initializer != NULL));
	    real_ttyfd = ttyfd;
	}

	/*
	 * If the pty, socket, notty and/or record option was specified,
	 * start up the character shunt now.
	 */
	status = EXIT_PTYCMD_FAILED;
	if (ptycommand != NULL) {
	    if (record_file != NULL) {
		int ipipe[2], opipe[2], ok;

		if (pipe(ipipe) < 0 || pipe(opipe) < 0)
		    fatal("Couldn't create pipes for record option: %m");
		dbglog("starting charshunt for pty option");
		ok = device_script(ptycommand, opipe[0], ipipe[1], 1,
		    "record") == 0 && start_charshunt(ipipe[0], opipe[1]);
		(void) close(ipipe[0]);
		(void) close(ipipe[1]);
		(void) close(opipe[0]);
		(void) close(opipe[1]);
		if (!ok)
		    goto fail;
	    } else {
		if (device_script(ptycommand, pty_master, pty_master, 1,
		    "pty") < 0)
		    goto fail;
		ttyfd = pty_slave;
		(void) close(pty_master);
		pty_master = -1;
	    }
	} else if (pty_socket != NULL) {
	    int fd = open_socket(pty_socket);
	    if (fd < 0)
		goto fail;
	    dbglog("starting charshunt for socket option");
	    if (!start_charshunt(fd, fd))
		goto fail;
	} else if (notty) {
	    dbglog("starting charshunt for notty option");
	    if (!start_charshunt(0, 1))
		goto fail;
	} else if (record_file != NULL) {
	    dbglog("starting charshunt for record option");
	    if (!start_charshunt(ttyfd, ttyfd))
		goto fail;
	}

	/* run connection script */
	if (((connector != NULL) && (connector[0] != '\0')) || initializer) {
	    if (real_ttyfd != -1) {
		/* XXX do this if doing_callback == CALLBACK_DIALIN? */
		if (!default_device && modem && !direct_tty) {
		    setdtr(real_ttyfd, 0);	/* in case modem is off hook */
		    (void) sleep(1);
		    setdtr(real_ttyfd, 1);
		}
	    }

	    if ((initializer != NULL) && (initializer[0] != '\0')) {
		if (device_script(initializer, ttyfd, ttyfd, 0, "init") < 0) {
		    error("Initializer script failed");
		    status = EXIT_INIT_FAILED;
		    goto fail;
		}
		if (kill_link)
		    goto disconnect;

		info("Serial port initialized.");
	    }

	    if ((connector != NULL) && (connector[0] != '\0')) {
		if (device_script(connector, ttyfd, ttyfd, 0, "connect") < 0) {
		    error("Connect script failed");
		    status = EXIT_CONNECT_FAILED;
		    goto fail;
		}
		if (kill_link)
		    goto disconnect;

		info("Serial connection established.");
	    }

	    /*
	     * Clear CLOCAL if modem option -- we now have carrier
	     * established, and we should respect loss of carrier.
	     */
	    if (real_ttyfd != -1)
		set_up_tty(real_ttyfd, 0);

	    if (doing_callback == CALLBACK_DIALIN)
		connector = NULL;
	}

	/* reopen tty if necessary to wait for carrier */
	if (connector == NULL && modem && devnam[0] != '\0' && !direct_tty) {
	    for (;;) {
		if ((i = open(devnam, O_RDWR)) >= 0)
		    break;
		if (errno != EINTR) {
		    error("Failed to reopen %s: %m", devnam);
		    status = EXIT_OPEN_FAILED;
		}
		if (!persist || errno != EINTR || hungup || kill_link)
		    goto fail;
	    }
	    (void) close(i);
	}

	(void) slprintf(numbuf, sizeof(numbuf), "%d", baud_rate);
	script_setenv("SPEED", numbuf, 0);

	/* run welcome script, if any */
	if ((welcomer != NULL) && (welcomer[0] != '\0')) {
	    if (device_script(welcomer, ttyfd, ttyfd, 0, "welcome") < 0)
		warn("Welcome script failed");
	}

	/* set up the serial device as a ppp interface */
#ifdef HAVE_MULTILINK
	(void) tdb_writelock(pppdb);
#endif
	fd_ppp = establish_ppp(ttyfd);
	if (fd_ppp < 0) {
#ifdef HAVE_MULTILINK
	    (void) tdb_writeunlock(pppdb);
#endif
	    status = EXIT_FATAL_ERROR;
	    goto disconnect;
	}

	if (!demand && ifunit >= 0)
	    set_ifunit(1);
#ifdef HAVE_MULTILINK
	(void) tdb_writeunlock(pppdb);
#endif

	/*
	 * Start opening the connection and wait for
	 * incoming events (reply, timeout, etc.).
	 */
	notice("Connect: %s <--> %s", ifname, ppp_devnam);
	(void) gettimeofday(&start_time, NULL);
	link_stats_valid = 0;
	script_unsetenv("CONNECT_TIME");
	script_unsetenv("BYTES_SENT");
	script_unsetenv("BYTES_RCVD");
	lcp_lowerup(0);

	/* Mostly for accounting purposes */
	new_phase(PHASE_CONNECTED);

	/*
	 * If we are initiating this connection, wait for a short
	 * time for something from the peer.  This can avoid bouncing
	 * our packets off its tty before it has set up the tty.
	 */
	add_fd(fd_ppp);
	if (connect_delay != 0 && (connector != NULL || ptycommand != NULL)) {
	    struct timeval t;
	    t.tv_sec = connect_delay / 1000;
	    t.tv_usec = connect_delay % 1000;
	    wait_input(&t);
	}

	lcp_open(0);		/* Start protocol */
	open_ccp_flag = 0;
	status = EXIT_NEGOTIATION_FAILED;
	new_phase(PHASE_ESTABLISH);
	while (phase != PHASE_DEAD) {
	    if (sigsetjmp(sigjmp, 1) == 0) {
		(void) sigprocmask(SIG_BLOCK, &main_sigmask, NULL);
		if (kill_link || open_ccp_flag || got_sigchld) {
		    (void) sigprocmask(SIG_UNBLOCK, &main_sigmask, NULL);
		} else {
		    waiting = 1;
		    (void) sigprocmask(SIG_UNBLOCK, &main_sigmask, NULL);
		    wait_input(timeleft(&timo));
		}
	    }
	    waiting = 0;
	    calltimeout();
	    get_input();
	    if (kill_link) {
		lcp_close(0, "User request");
		kill_link = 0;
	    }
	    if (open_ccp_flag) {
		if (phase == PHASE_NETWORK || phase == PHASE_RUNNING) {
		    /* Uncloak ourselves. */
		    ccp_fsm[0].flags &= ~OPT_SILENT;
		    (*ccp_protent.open)(0);
		}
		open_ccp_flag = 0;
	    }
	    if (got_sigchld)
		(void) reap_kids(0);	/* Don't leave dead kids lying around */
	}

	/*
	 * Print connect time and statistics.
	 */
	if (link_stats_valid) {
	    int t = (link_connect_time + 5) / 6;    /* 1/10ths of minutes */
	    info("Connect time %d.%d minutes.", t/10, t%10);
	    info("Sent %" PPP_COUNTER_F " bytes (%" PPP_COUNTER_F
		" packets), received %" PPP_COUNTER_F " bytes (%" PPP_COUNTER_F
		" packets).",
		 link_stats.bytes_out, link_stats.pkts_out,
		 link_stats.bytes_in, link_stats.pkts_in);
	}

	/*
	 * Delete pid file before disestablishing ppp.  Otherwise it
	 * can happen that another pppd gets the same unit and then
	 * we delete its pid file.
	 */
	if (!demand) {
	    if (pidfilename[0] != '\0'
		&& unlink(pidfilename) < 0 && errno != ENOENT)
		warn("unable to delete pid file %s: %m", pidfilename);
	    pidfilename[0] = '\0';
	}

	/*
	 * If we may want to bring the link up again, transfer
	 * the ppp unit back to the loopback.  Set the
	 * real serial device back to its normal mode of operation.
	 */
	remove_fd(fd_ppp);
	clean_check();
	if (demand)
	    restore_loop();
	disestablish_ppp(ttyfd);
	fd_ppp = -1;
	if (!hungup)
	    lcp_lowerdown(0);
	if (!demand)
	    script_unsetenv("IFNAME");

	/*
	 * Run disconnector script, if requested.
	 * XXX we may not be able to do this if the line has hung up!
	 */
    disconnect:
	if ((disconnect_script != NULL) && (disconnect_script[0] != '\0') &&
	    !hungup) {
	    new_phase(PHASE_DISCONNECT);
	    if (real_ttyfd >= 0)
		set_up_tty(real_ttyfd, 1);
	    if (device_script(disconnect_script, ttyfd, ttyfd, 0,
		"disconnect") < 0) {
		warn("disconnect script failed");
	    } else {
		info("Serial link disconnected.");
	    }
	}

    fail:
	if (pty_master >= 0)
	    (void) close(pty_master);
	if (pty_slave >= 0) {
	    (void) close(pty_slave);
	    pty_slave = -1;
	}
	if (real_ttyfd >= 0)
	    close_tty();
	if (locked) {
	    locked = 0;
	    unlock();
	}

	if (!demand) {
	    if (pidfilename[0] != '\0'
		&& unlink(pidfilename) < 0 && errno != ENOENT)
		warn("unable to delete pid file %s: %m", pidfilename);
	    pidfilename[0] = '\0';
	}

	if (!persist || (maxfail > 0 && unsuccess >= maxfail))
	    break;

	kill_link = 0;
	if (demand)
	    demand_discard();
	t = need_holdoff? holdoff: 0;
	if (holdoff_hook != NULL)
	    t = (*holdoff_hook)();
	if (t > 0) {
	    new_phase(PHASE_HOLDOFF);
	    TIMEOUT(holdoff_end, NULL, t);
	    do {
		if (sigsetjmp(sigjmp, 1) == 0) {
		    (void) sigprocmask(SIG_BLOCK, &main_sigmask, NULL);
		    if (kill_link || got_sigchld) {
			(void) sigprocmask(SIG_UNBLOCK, &main_sigmask, NULL);
		    } else {
			waiting = 1;
			(void) sigprocmask(SIG_UNBLOCK, &main_sigmask, NULL);
			wait_input(timeleft(&timo));
		    }
		}
		waiting = 0;
		calltimeout();
		if (kill_link) {
		    kill_link = 0;
		    new_phase(PHASE_DORMANT); /* allow signal to end holdoff */
		}
		if (got_sigchld)
		    (void) reap_kids(0);
	    } while (phase == PHASE_HOLDOFF);
	    if (!persist)
		break;
	}
    }

    /* Wait for scripts to finish */
    final_reap();

    die(status);
    return (0);
}

/*
 * setup_signals - initialize signal handling.
 */
static void
setup_signals()
{
    struct sigaction sa;

    /*
     * Compute mask of all interesting signals and install signal handlers
     * for each.  Only one signal handler may be active at a time.  Therefore,
     * all other signals should be masked when any handler is executing.
     */
    (void) sigemptyset(&main_sigmask);
    (void) sigaddset(&main_sigmask, SIGHUP);
    (void) sigaddset(&main_sigmask, SIGINT);
    (void) sigaddset(&main_sigmask, SIGTERM);
    (void) sigaddset(&main_sigmask, SIGCHLD);
    (void) sigaddset(&main_sigmask, SIGUSR2);

#define SIGNAL(s, handler)	if (1) { \
	sa.sa_handler = handler; \
	if (sigaction(s, &sa, NULL) < 0) \
	    fatal("Couldn't establish signal handler (%d): %m", s); \
    } else ((void)0)

    sa.sa_mask = main_sigmask;
    sa.sa_flags = 0;
/*CONSTANTCONDITION*/ SIGNAL(SIGHUP, hup);		/* Hangup */
/*CONSTANTCONDITION*/ SIGNAL(SIGINT, term);		/* Interrupt */
/*CONSTANTCONDITION*/ SIGNAL(SIGTERM, term);		/* Terminate */
/*CONSTANTCONDITION*/ SIGNAL(SIGCHLD, chld);

/*CONSTANTCONDITION*/ SIGNAL(SIGUSR1, toggle_debug);	/* Toggle debug flag */
/*CONSTANTCONDITION*/ SIGNAL(SIGUSR2, open_ccp);	/* Reopen CCP */

    /*
     * Install a handler for other signals which would otherwise
     * cause pppd to exit without cleaning up.
     */
/*CONSTANTCONDITION*/ SIGNAL(SIGALRM, bad_signal);
/*CONSTANTCONDITION*/ SIGNAL(SIGQUIT, bad_signal);

/* Do not hook any of these signals on Solaris; allow core dump instead */
#ifndef SOL2
/*CONSTANTCONDITION*/ SIGNAL(SIGABRT, bad_signal);
/*CONSTANTCONDITION*/ SIGNAL(SIGFPE, bad_signal);
/*CONSTANTCONDITION*/ SIGNAL(SIGILL, bad_signal);
#ifndef DEBUG
/*CONSTANTCONDITION*/ SIGNAL(SIGSEGV, bad_signal);
#endif
#ifdef SIGBUS
/*CONSTANTCONDITION*/ SIGNAL(SIGBUS, bad_signal);
#endif
#ifdef SIGEMT
/*CONSTANTCONDITION*/ SIGNAL(SIGEMT, bad_signal);
#endif
#ifdef SIGPOLL
/*CONSTANTCONDITION*/ SIGNAL(SIGPOLL, bad_signal);
#endif
#ifdef SIGPROF
/*CONSTANTCONDITION*/ SIGNAL(SIGPROF, bad_signal);
#endif
#ifdef SIGSYS
/*CONSTANTCONDITION*/ SIGNAL(SIGSYS, bad_signal);
#endif
#ifdef SIGTRAP
/*CONSTANTCONDITION*/ SIGNAL(SIGTRAP, bad_signal);
#endif
#ifdef SIGVTALRM
/*CONSTANTCONDITION*/ SIGNAL(SIGVTALRM, bad_signal);
#endif
#ifdef SIGXCPU
/*CONSTANTCONDITION*/ SIGNAL(SIGXCPU, bad_signal);
#endif
#ifdef SIGXFSZ
/*CONSTANTCONDITION*/ SIGNAL(SIGXFSZ, bad_signal);
#endif
#endif

    /*
     * Apparently we can get a SIGPIPE when we call syslog, if
     * syslogd has died and been restarted.  Ignoring it seems
     * be sufficient.
     */
    (void) signal(SIGPIPE, SIG_IGN);
}

/*
 * set_ifunit - do things we need to do once we know which ppp
 * unit we are using.
 */
void
set_ifunit(iskey)
    int iskey;
{
    sys_ifname();
    info("Using interface %s", ifname);
    script_setenv("IFNAME", ifname, iskey);
    if (iskey) {
	create_pidfile();	/* write pid to file */
	create_linkpidfile();
    }
}

/*
 * detach - detach us from the controlling terminal.
 */
void
detach()
{
    pid_t pid;
    char numbuf[16];

    if (detached)
	return;
    if ((pid = fork()) == (pid_t)-1) {
	error("Couldn't detach (fork failed: %m)");
	die(1);			/* or just return? */
    }
    if (pid != (pid_t)0) {
	/* parent */
	if (locked)
	    (void) relock(pid);
	exit(0);		/* parent dies */
    }
    (void) setsid();
	/*
	 * Fork again to relinquish session leadership. This is needed
	 * to prevent the daemon from acquiring controlling terminal.
	 */
    if ((pid = fork()) == (pid_t)-1) {
	error("Couldn't detach (second fork failed: %m)");
	die(1);			/* or just return? */
    }
    if (pid != (pid_t)0) {
	/* parent */
	if (locked)
	    (void) relock(pid);
	exit(0);		/* parent dies */
    }
    (void) chdir("/");
    (void) close(0);
    (void) close(1);
    (void) close(2);
    detached = 1;
    if (!log_to_file && !log_to_specific_fd)
	log_to_fd = -1;
    /* update pid files if they have been written already */
    if (pidfilename[0] != '\0')
	create_pidfile();
    if (linkpidfile[0] != '\0')
	create_linkpidfile();
    (void) slprintf(numbuf, sizeof(numbuf), "%d", getpid());
    script_setenv("PPPD_PID", numbuf, 1);
}

/*
 * reopen_log - (re)open our connection to syslog.
 */
void
reopen_log()
{
#ifdef ULTRIX
    openlog("pppd", LOG_PID);
#else
    openlog("pppd", LOG_PID | LOG_NDELAY, LOG_PPP);
    (void) setlogmask(LOG_UPTO(LOG_INFO));
#endif
}

/*
 * Create a file containing our process ID.
 */
static void
create_pidfile()
{
    FILE *pidfile;

    (void) slprintf(pidfilename, sizeof(pidfilename), "%s%s.pid",
	     _PATH_VARRUN, ifname);
    if ((pidfile = fopen(pidfilename, "w")) != NULL) {
	(void) fprintf(pidfile, "%u\n", (unsigned)getpid());
	(void) fclose(pidfile);
    } else {
	error("Failed to create pid file %s: %m", pidfilename);
	pidfilename[0] = '\0';
    }
}

static void
create_linkpidfile()
{
    FILE *pidfile;

    if (linkname[0] == '\0')
	return;
    script_setenv("LINKNAME", linkname, 1);
    (void) slprintf(linkpidfile, sizeof(linkpidfile), "%sppp-%s.pid",
	     _PATH_VARRUN, linkname);
    if ((pidfile = fopen(linkpidfile, "w")) != NULL) {
	(void) fprintf(pidfile, "%u\n", (unsigned)getpid());
	if (ifname[0] != '\0')
	    (void) fprintf(pidfile, "%s\n", ifname);
	(void) fclose(pidfile);
    } else {
	error("Failed to create pid file %s: %m", linkpidfile);
	linkpidfile[0] = '\0';
    }
}

/*
 * holdoff_end - called via a timeout when the holdoff period ends.
 */
/*ARGSUSED*/
static void
holdoff_end(arg)
    void *arg;
{
    new_phase(PHASE_DORMANT);
}

/* List of protocol names, to make our messages a little more informative. */
struct protocol_list {
    u_short	proto;
    const char	*name;
} protocol_list[] = {
    { 0x21,	"IP" },
    { 0x23,	"OSI Network Layer" },
    { 0x25,	"Xerox NS IDP" },
    { 0x27,	"DECnet Phase IV" },
    { 0x29,	"Appletalk" },
    { 0x2b,	"Novell IPX" },
    { 0x2d,	"VJ compressed TCP/IP" },
    { 0x2f,	"VJ uncompressed TCP/IP" },
    { 0x31,	"Bridging PDU" },
    { 0x33,	"Stream Protocol ST-II" },
    { 0x35,	"Banyan Vines" },
    { 0x37,	"Old VJ compressed TCP/IP" },
    { 0x39,	"AppleTalk EDDP" },
    { 0x3b,	"AppleTalk SmartBuffered" },
    { 0x3d,	"Multilink" },
    { 0x3f,	"NetBIOS Frame" },
    { 0x41,	"Cisco LAN Extension" },
    { 0x43,	"Ascom Timeplex" },
    { 0x45,	"Fujitsu Link Backup and Load Balancing (LBLB)" },
    { 0x47,	"DCA Remote Lan" },
    { 0x49,	"Serial Data Transport Protocol (PPP-SDTP)" },
    { 0x4b,	"SNA over 802.2" },
    { 0x4d,	"SNA" },
    { 0x4f,	"IP6 Header Compression" },
    { 0x51,	"KNX Bridging" },
    { 0x53,	"Encrypted" },
    { 0x55,	"per-link encrypted" },
    { 0x57,	"IPv6" },
    { 0x59,	"PPP Muxing" },
    { 0x6f,	"Stampede Bridging" },
    { 0x73,	"MP+" },
    { 0xc1,	"STMF" },
    { 0xfb,	"per-link compressed" },
    { 0xfd,	"compressed datagram" },
    { 0x0201,	"802.1d Hello Packets" },
    { 0x0203,	"IBM Source Routing BPDU" },
    { 0x0205,	"DEC LANBridge100 Spanning Tree" },
    { 0x0207,	"Cisco Discovery Protocol" },
    { 0x0231,	"Luxcom" },
    { 0x0233,	"Sigma Network Systems" },
    { 0x0235,	"Apple Client Server Protocol" },
    { 0x0281,	"MPLS Unicast" },
    { 0x0283,	"MPLS Multicast" },
    { 0x0285,	"IEEE p1284.4" },
    { 0x0287,	"ETSI TETRA TNP1" },
    { 0x4021,	"Stacker LZS" },
    { 0x8021,	"Internet Protocol Control Protocol" },
    { 0x8023,	"OSI Network Layer Control Protocol" },
    { 0x8025,	"Xerox NS IDP Control Protocol" },
    { 0x8027,	"DECnet Phase IV Control Protocol" },
    { 0x8029,	"Appletalk Control Protocol" },
    { 0x802b,	"Novell IPX Control Protocol" },
    { 0x8031,	"Bridging Control Protocol" },
    { 0x8033,	"Stream Protocol Control Protocol" },
    { 0x8035,	"Banyan Vines Control Protocol" },
    { 0x803f,	"NetBIOS Frames Control Protocol" },
    { 0x8041,	"Cisco LAN Extension Control Protocol" },
    { 0x8043,	"Ascom Timeplex Control Protocol" },
    { 0x8045,	"Fujitsu LBLB Control Protocol" },
    { 0x8047,	"DCA Remote Lan Network Control Protocol (RLNCP)" },
    { 0x8049,	"Serial Data Control Protocol (PPP-SDCP)" },
    { 0x804b,	"SNA over 802.2 Control Protocol" },
    { 0x804d,	"SNA Control Protocol" },
    { 0x8051,	"KNX Bridging Control Protocol" },
    { 0x8053,	"Encryption Control Protocol" },
    { 0x8055,	"Per-link Encryption Control Protocol" },
    { 0x8057,	"IPv6 Control Protocol" },
    { 0x806f,	"Stampede Bridging Control Protocol" },
    { 0x80c1,	"STMF Control Protocol" },
    { 0x80fb,	"Per-link Compression Control Protocol" },
    { 0x80fd,	"Compression Control Protocol" },
    { 0x8207,	"Cisco Discovery Control Protocol" },
    { 0x8235,	"Apple Client Server Control Protocol" },
    { 0x8281,	"MPLS Control Protocol" },
    { 0x8287,	"ETSI TETRA TNP1 Control Protocol" },
    { 0xc021,	"Link Control Protocol" },
    { 0xc023,	"Password Authentication Protocol" },
    { 0xc025,	"Link Quality Report" },
    { 0xc027,	"Shiva Password Authentication Protocol" },
    { 0xc029,	"CallBack Control Protocol (CBCP)" },
    { 0xc02b,	"Bandwidth Allocation Control Protocol" },
    { 0xc02d,	"BAP" },
    { 0xc081,	"Container Control Protocol" },
    { 0xc223,	"Challenge Handshake Authentication Protocol" },
    { 0xc227,	"Extensible Authentication Protocol" },
    { 0xc281,	"Funk Proprietary Authentication Protocol" },
    { 0,	NULL },
};

/*
 * protocol_name - find a name for a PPP protocol.
 */
const char *
protocol_name(proto)
    int proto;
{
    struct protocol_list *lp;

    for (lp = protocol_list; lp->proto != 0; ++lp)
	if (proto == lp->proto)
	    return (lp->name);
    return (NULL);
}

static const char *phase_names[] = { PHASE__NAMES };

const char *
phase_name(pval)
    int pval;
{
    static char buf[32];

    if (pval < 0 || pval >= Dim(phase_names)) {
	(void) slprintf(buf, sizeof (buf), "unknown %d", pval);
	return ((const char *)buf);
    }
    return (phase_names[pval]);
}

/*
 * get_input - called when incoming data is available.
 */
static void
get_input()
{
    int len, i;
    u_char *p;
    u_short protocol;
    struct protent *protp;
    const char *pname;

    p = inpacket_buf;	/* point to beginning of packet buffer */

    len = read_packet(inpacket_buf);
    if (len < 0)
	return;

    if (len == 0) {
	notice("Modem hangup");
	hungup = 1;
	status = EXIT_HANGUP;
	lcp_lowerdown(0);	/* serial link is no longer available */
	link_terminated(0);
	return;
    }

    if (debug /*&& (debugflags & DBG_INPACKET)*/)
	dbglog("rcvd %P", p, len);

    if (len < PPP_HDRLEN) {
	dbglog("Discarded short packet (%d < %d)", len, PPP_HDRLEN);
	return;
    }

    p += 2;				/* Skip address and control */
    GETSHORT(protocol, p);
    len -= PPP_HDRLEN;

    pname = debug ? NULL : protocol_name(protocol);

    /*
     * Toss all non-LCP packets unless LCP is in Opened state and
     * discard non-authentication protocols if we're not yet
     * authenticated.
     */
    if ((protocol != PPP_LCP &&
	(phase < PHASE_AUTHENTICATE || phase > PHASE_RUNNING)) ||
	(phase <= PHASE_AUTHENTICATE &&
	    !(protocol == PPP_LCP || protocol == PPP_LQR ||
		protocol == PPP_PAP || protocol == PPP_CHAP))) {
	    if (pname == NULL)
		    dbglog("Discarded proto 0x%x in %s phase",
			protocol, phase_name(phase));
	    else
		    dbglog("Discarded %s (0x%x) in %s phase",
			pname, protocol, phase_name(phase));
	return;
    }

    /*
     * Upcall the proper protocol input routine.
     */
    for (i = 0; (protp = protocols[i]) != NULL; ++i) {
	if (protp->protocol == protocol && protp->enabled_flag) {
	    (*protp->input)(0, p, len);
	    return;
	}
        if (protocol == (protp->protocol & ~0x8000) && protp->enabled_flag
	    && protp->datainput != NULL) {
	    (*protp->datainput)(0, p, len);
	    return;
	}
    }

    if (debug) {
	if (pname != NULL)
	    warn("Unsupported protocol '%s' (0x%x) received", pname, protocol);
	else
	    warn("Unsupported protocol 0x%x received", protocol);
    }
    lcp_sprotrej(0, p - PPP_HDRLEN, len + PPP_HDRLEN);
}

/*
 * new_phase - signal the start of a new phase of pppd's operation.
 */
void
new_phase(p)
    int p;
{
    if (new_phase_hook != NULL)
	(*new_phase_hook)(p, phase);
    phase = p;
}

/*
 * die - clean up state and exit with the specified status.
 */
void
die(status)
    int status;
{
    cleanup();
    if (phase != PHASE_EXIT) {
	syslog(LOG_INFO, "Exit.");
	new_phase(PHASE_EXIT);
    }
    exit(status);
}

/*
 * cleanup - restore anything which needs to be restored before we exit
 */
static void
cleanup()
{
    sys_cleanup();  /* XXX: Need to check if this is okay after close_tty */

    if (fd_ppp >= 0) {
	fd_ppp = -1;
	disestablish_ppp(ttyfd);
    }
    if (real_ttyfd >= 0)
	close_tty();

    if (pidfilename[0] != '\0' && unlink(pidfilename) < 0 && errno != ENOENT)
	warn("unable to delete pid file %s: %m", pidfilename);
    pidfilename[0] = '\0';
    if (linkpidfile[0] != '\0' && unlink(linkpidfile) < 0 && errno != ENOENT)
	warn("unable to delete pid file %s: %m", linkpidfile);
    linkpidfile[0] = '\0';

    if (locked) {
	locked = 0;
	unlock();
    }

#ifdef HAVE_MULTILINK
    if (pppdb != NULL) {
	cleanup_db();
	pppdb = NULL;
    }
#endif
}

/*
 * close_tty - restore the terminal device and close it.
 */
static void
close_tty()
{
    int fd = real_ttyfd;

    real_ttyfd = -1;

    /* drop dtr to hang up */
    if (!default_device && modem) {
	setdtr(fd, 0);
	/*
	 * This sleep is in case the serial port has CLOCAL set by default,
	 * and consequently will reassert DTR when we close the device.
	 */
	(void) sleep(1);
    }

    restore_tty(fd);

    if (tty_mode != (mode_t) -1) {
	if (fchmod(fd, tty_mode) != 0) {
	    /* XXX if devnam is a symlink, this will change the link */
	    if (chmod(devnam, tty_mode) != 0) {
		error("Unable to chmod file %s: %m", devnam);
	    }
	}
    }

    (void) close(fd);
}

/*
 * update_link_stats - get stats at link termination.
 */
void
update_link_stats(u)
    int u;
{
    struct timeval now;
    char numbuf[32];

    if (gettimeofday(&now, NULL) >= 0) {
	link_connect_time = now.tv_sec - start_time.tv_sec;
	(void) slprintf(numbuf, sizeof(numbuf), "%d", link_connect_time);
	script_setenv("CONNECT_TIME", numbuf, 0);
    } else {
	link_connect_time = 0;
    }

    if (get_ppp_stats(u, &link_stats)) {
	(void) slprintf(numbuf, sizeof(numbuf), "%" PPP_COUNTER_F,
	    link_stats.bytes_out);
	script_setenv("BYTES_SENT", numbuf, 0);
	(void) slprintf(numbuf, sizeof(numbuf), "%" PPP_COUNTER_F,
	    link_stats.bytes_in);
	script_setenv("BYTES_RCVD", numbuf, 0);
	(void) slprintf(numbuf, sizeof(numbuf), "%" PPP_COUNTER_F,
	    link_stats.pkts_in);
	script_setenv("PKTS_RCVD", numbuf, 0);
	(void) slprintf(numbuf, sizeof(numbuf), "%" PPP_COUNTER_F,
	    link_stats.pkts_out);
	script_setenv("PKTS_SENT", numbuf, 0);
	link_stats_valid = 1;
    }
}


struct	callout {
    struct timeval	c_time;		/* time at which to call routine */
    void		*c_arg;		/* argument to routine */
    void		(*c_func) __P((void *)); /* routine */
    struct		callout *c_next;
};

static struct callout *callout = NULL;	/* Callout list */
static struct timeval timenow;		/* Current time */

/*
 * timeout - Schedule a timeout.
 *
 * Note that this timeout takes the number of seconds, NOT hz (as in
 * the kernel).
 */
void
timeout(func, arg, time)
    void (*func) __P((void *));
    void *arg;
    int time;
{
    struct callout *newp, *p, **pp;

    MAINDEBUG(("Timeout %p:%p in %d seconds.", func, arg, time));

    /*
     * Allocate timeout.
     */
    if ((newp = (struct callout *) malloc(sizeof(struct callout))) == NULL)
	novm("callout structure for timeout.");
    newp->c_arg = arg;
    newp->c_func = func;
    (void) gettimeofday(&timenow, NULL);
    newp->c_time.tv_sec = timenow.tv_sec + time;
    newp->c_time.tv_usec = timenow.tv_usec;

    /*
     * Find correct place and link it in.
     */
    for (pp = &callout; (p = *pp) != NULL; pp = &p->c_next)
	if (newp->c_time.tv_sec < p->c_time.tv_sec
	    || (newp->c_time.tv_sec == p->c_time.tv_sec
		&& newp->c_time.tv_usec < p->c_time.tv_usec))
	    break;
    newp->c_next = p;
    *pp = newp;
}


/*
 * untimeout - Unschedule a timeout.
 */
void
untimeout(func, arg)
    void (*func) __P((void *));
    void *arg;
{
    struct callout **copp, *freep;

    MAINDEBUG(("Untimeout %p:%p.", func, arg));

    /*
     * Find first matching timeout and remove it from the list.
     */
    for (copp = &callout; (freep = *copp) != NULL; copp = &freep->c_next)
	if (freep->c_func == func && freep->c_arg == arg) {
	    *copp = freep->c_next;
	    free((char *) freep);
	    break;
	}
}


/*
 * calltimeout - Call any timeout routines which are now due.
 */
static void
calltimeout()
{
    struct callout *p;

    while (callout != NULL) {
	p = callout;

	if (gettimeofday(&timenow, NULL) < 0)
	    fatal("Failed to get time of day: %m");
	if (!(p->c_time.tv_sec < timenow.tv_sec
	      || (p->c_time.tv_sec == timenow.tv_sec
		  && p->c_time.tv_usec <= timenow.tv_usec)))
	    break;		/* no, it's not time yet */

	callout = p->c_next;
	(*p->c_func)(p->c_arg);

	free((char *) p);
    }
}


/*
 * timeleft - return the length of time until the next timeout is due.
 */
static struct timeval *
timeleft(tvp)
    struct timeval *tvp;
{
    if (callout == NULL)
	return (NULL);

    (void) gettimeofday(&timenow, NULL);
    tvp->tv_sec = callout->c_time.tv_sec - timenow.tv_sec;
    tvp->tv_usec = callout->c_time.tv_usec - timenow.tv_usec;
    if (tvp->tv_usec < 0) {
	tvp->tv_usec += 1000000;
	tvp->tv_sec -= 1;
    }
    if (tvp->tv_sec < 0)
	tvp->tv_sec = tvp->tv_usec = 0;

    return (tvp);
}


/*
 * kill_my_pg - send a signal to our process group, and ignore it ourselves.
 */
static void
kill_my_pg(sig)
    int sig;
{
    struct sigaction act, oldact;
    sigset_t mask;

    BZERO(&act, sizeof (act));
    act.sa_handler = SIG_IGN;
    (void) sigemptyset(&mask);
    (void) sigaddset(&mask, sig);
    /*
     * Ignore signal 'sig' temporarily, before finally re-activating the
     * original handler.  We need to do it in the following sequence, since
     * otherwise the signal handler for 'sig' will be called forever.
     */
    if (sigaction(sig, &act, &oldact) < 0) {
	fatal("kill_my_pg: couldn't establish signal handler (%d): %m", sig);
    }
    (void) sigprocmask(SIG_UNBLOCK, &mask, NULL);
    /*
     * Send signal 'sig' to all processes whose process group ID is equal
     * to the process group ID of the sender.
     */
    (void) kill(0, sig);
    if (sigaction(sig, &oldact, NULL) < 0) {
	fatal("kill_my_pg: couldn't establish signal handler (%d): %m", sig);
    }
}


/*
 * hup - Catch SIGHUP signal.
 *
 * Indicates that the physical layer has been disconnected.
 * We don't rely on this indication; if the user has sent this
 * signal, we just take the link down.
 */
static void
hup(sig)
    int sig;
{
    info("Hangup (SIGHUP)");
    kill_link = 1;
    if (status != EXIT_HANGUP)
	status = EXIT_USER_REQUEST;
    if (conn_running > 0)
	/* Send the signal to the [dis]connector process(es) also */
	kill_my_pg(sig);
    if (charshunt_pid)
	(void) kill(charshunt_pid, sig);
    if (waiting)
	siglongjmp(sigjmp, 1);
}


/*
 * term - Catch SIGTERM signal and SIGINT signal (^C/del).
 *
 * Indicates that we should initiate a graceful disconnect and exit.
 */
/*ARGSUSED*/
static void
term(sig)
    int sig;
{
    info("Terminating on signal %d.", sig);
    persist = 0;		/* don't try to restart */
    kill_link = 1;
    status = EXIT_USER_REQUEST;
    if (conn_running > 0)
	/* Send the signal to the [dis]connector process(es) also */
	kill_my_pg(sig);
    if (charshunt_pid)
	(void) kill(charshunt_pid, sig);
    if (waiting)
	siglongjmp(sigjmp, 1);
}


/*
 * chld - Catch SIGCHLD signal.
 * Sets a flag so we will call reap_kids in the mainline.
 */
/*ARGSUSED*/
static void
chld(sig)
    int sig;
{
    got_sigchld = 1;
    if (waiting)
	siglongjmp(sigjmp, 1);
}

/*
 * toggle_debug - Catch SIGUSR1 signal.
 *
 * Toggle debug flag.
 */
/*ARGSUSED*/
static void
toggle_debug(sig)
    int sig;
{
    if (debug) {
	print_ncpstate(0, NULL);
	dbglog("debug logging disabled");
	(void) setlogmask(LOG_UPTO(LOG_WARNING));
	debug = 0;
    } else {
	(void) setlogmask(LOG_UPTO(LOG_DEBUG));
	dbglog("debug logging enabled");
	print_ncpstate(0, NULL);
	debug = 1;
    }
}


/*
 * open_ccp - Catch SIGUSR2 signal.
 *
 * Try to (re)negotiate compression.
 */
/*ARGSUSED*/
static void
open_ccp(sig)
    int sig;
{
    open_ccp_flag = 1;
    if (waiting)
	siglongjmp(sigjmp, 1);
}


/*
 * bad_signal - We've caught a fatal signal.  Clean up state and exit.
 */
static void
bad_signal(sig)
    int sig;
{
    static int crashed = 0;

    if (crashed)
	_exit(127);
    crashed = 1;
    error("Fatal signal %d", sig);
    if (conn_running > 0)
	kill_my_pg(SIGTERM);
    if (charshunt_pid)
	(void) kill(charshunt_pid, SIGTERM);
    die(127);
}


/*
 * device_script - run a program to talk to the serial device
 * (e.g. to run the connector or disconnector script).
 */
static int
device_script(program, in, out, dont_wait, optname)
    char *program;
    int in, out;
    int dont_wait;
    char *optname;
{
    pid_t pid;
    int status = -1;
    int errfd;
    int envpipe[2];

    envpipe[0] = envpipe[1] = -1;
    if (!dont_wait && device_pipe_hook != NULL && pipe(envpipe) == -1) {
	error("Cannot create pipe for child: %m");
	return (-1);
    }

    ++conn_running;
    pid = fork();

    if (pid == (pid_t)-1) {
	--conn_running;
	error("Failed to create child process: %m");
	return (-1);
    }

    if (pid == (pid_t)0) {
	sys_close();
	closelog();
	if (envpipe[0] >= 0) {
	    if (envpipe[1] <= 2)
		envpipe[1] = dup(envpipe[1]);
	    (void) close(envpipe[0]);
	}
	if (in == 2) {
	    /* aargh!!! */
	    int newin = dup(in);
	    if (in == out)
		out = newin;
	    in = newin;
	} else if (out == 2) {
	    out = dup(out);
	}
	if (log_to_fd >= 0) {
	    if (log_to_fd != 2) {
		if (dup2(log_to_fd, 2) < 0)
		    error("dup2(log_to_fd, STDERR) failed: %m");
	    }
	} else {
	    (void) close(2);
	    errfd = open(_PATH_CONNERRS, O_WRONLY | O_APPEND | O_CREAT, 0600);
	    if (errfd >= 0 && errfd != 2) {
		if (dup2(errfd, 2) < 0)
		    error("dup2(errfd, STDERR) failed: %m");
		(void) close(errfd);
	    }
	}
	if (in != 0) {
	    if (out == 0)
		out = dup(out);
	    if (dup2(in, 0) < 0)
		error("dup2(in, STDIN) failed: %m");
	}
	if (out != 1) {
	    if (dup2(out, 1) < 0)
		error("dup2(out, STDOUT) failed: %m");
	}
	if (envpipe[0] >= 0 && dup2(envpipe[1], 3) < 0)
	    error("dup2(pipe, pipeout) failed: %m");
	if (real_ttyfd > 2)
	    (void) close(real_ttyfd);
	if (pty_master > 2)
	    (void) close(pty_master);
	if (pty_slave > 2) {
	    (void) close(pty_slave);
	    pty_slave = -1;
	}
	(void) setuid(uid);
	if (getuid() != uid) {
	    error("setuid failed");
	    exit(1);
	}
	(void) setgid(getgid());
	if (script_env != NULL) {
	    while (*script_env != NULL) {
		if (putenv(*script_env) == -1)
		    warn("unable to set %s for %s: %m", *script_env, program);
		script_env++;
	    }
	}
	(void) execl("/bin/sh", "sh", "-c", program, (char *)0);
	error("could not exec /bin/sh: %m");
	exit(99);
	/* NOTREACHED */
    }

    if (debug)
	dbglog("%s option: '%s' started (pid %d)", optname, program, pid);
    if (dont_wait) {
	record_child(pid, program, NULL, NULL);
	status = 0;
    } else {
	if (envpipe[0] >= 0) {
	    (void) close(envpipe[1]);
	    (*device_pipe_hook)(envpipe[0]);
	}
	while (waitpid(pid, &status, 0) < 0) {
	    if (errno == EINTR)
		continue;
	    fatal("error waiting for (dis)connection process: %m");
	}
	if (envpipe[0] >= 0)
	    (void) close(envpipe[0]);
	--conn_running;
    }

    return (status == 0 ? 0 : -1);
}


/*
 * run-program - execute a program with given arguments,
 * but don't wait for it.
 * If the program can't be executed, logs an error unless
 * must_exist is 0 and the program file doesn't exist.
 * Returns -1 if it couldn't fork, 0 if the file doesn't exist
 * or isn't an executable plain file, or the process ID of the child.
 * If done != NULL, (*done)(arg, int) will be called later (within
 * reap_kids) if this routine returns value > 0.
 */
pid_t
run_program(prog, args, must_exist, done, arg)
    char *prog;
    char **args;
    int must_exist;
    void (*done) __P((void *arg, int status));
    void *arg;
{
    pid_t pid;
    struct stat sbuf;
    int retv;

    /*
     * First check if the file exists and is executable.
     * We don't use access() because that would use the
     * real user-id, which might not be root, and the script
     * might be accessible only to root.
     */
    errno = EINVAL;
    if (stat(prog, &sbuf) < 0 || !S_ISREG(sbuf.st_mode)
	|| (sbuf.st_mode & (S_IXUSR|S_IXGRP|S_IXOTH)) == 0) {
	if (must_exist || errno != ENOENT)
	    warn("Can't execute %s: %m", prog);
	return (0);
    }

    if (updown_script_hook != NULL) {
	retv = (*updown_script_hook)((const char ***)&args);
	if (retv == -1) {
	    return (-1);
	}
    }

    pid = fork();
    if (pid == (pid_t)-1) {
	error("Failed to create child process for %s: %m", prog);
	return (-1);
    }
    if (pid == (pid_t)0) {
	int new_fd;

	/* Leave the current location */
	(void) setsid();	/* No controlling tty. */
	(void) umask (S_IRWXG|S_IRWXO);
	(void) chdir ("/");	/* no current directory. */
	(void) setuid(0);	/* set real UID = root */
	(void) setgid(getegid());

	/* Ensure that nothing of our device environment is inherited. */
	sys_close();
	closelog();
	(void) close(0);
	(void) close(1);
	(void) close(2);
	(void) close(ttyfd);  /* tty interface to the ppp device */
	if (real_ttyfd >= 0)
	    (void) close(real_ttyfd);

        /* Don't pass handles to the PPP device, even by accident. */
	new_fd = open (_PATH_DEVNULL, O_RDWR);
	if (new_fd >= 0) {
	    if (new_fd != 0) {
	        if (dup2(new_fd, 0) < 0) /* stdin <- /dev/null */
		    error("dup2(/dev/null, STDIN) failed: %m");
		(void) close(new_fd);
	    }
	    if (dup2(0, 1) < 0) /* stdout -> /dev/null */
		error("dup2(/dev/null, STDOUT) failed: %m");
	    if (dup2(0, 2) < 0) /* stderr -> /dev/null */
		error("dup2(/dev/null, STDERR) failed: %m");
	}

#ifdef BSD
	/* Force the priority back to zero if pppd is running higher. */
	if (setpriority (PRIO_PROCESS, 0, 0) < 0)
	    warn("can't reset priority to 0: %m");
#endif

	/* SysV recommends a second fork at this point. */

	/* run the program */
	(void) execve(prog, args, script_env);
	if (must_exist || errno != ENOENT) {
	    /* have to reopen the log, there's nowhere else
	       for the message to go. */
	    reopen_log();
	    syslog(LOG_ERR, "Can't execute %s: %m", prog);
	    closelog();
	}
	_exit(-1);
    }

    if (debug)
	dbglog("Script %s started (pid %d)", prog, pid);
    record_child(pid, prog, done, arg);

    return (pid);
}


/*
 * record_child - add a child process to the list for reap_kids
 * to use.
 */
static void
record_child(pid, prog, done, arg)
    pid_t pid;
    char *prog;
    void (*done) __P((void *, int));
    void *arg;
{
    struct subprocess *chp;

    ++n_children;

    chp = (struct subprocess *) malloc(sizeof(struct subprocess));
    if (chp == NULL) {
	warn("losing track of %s process", prog);
    } else {
	chp->pid = pid;
	chp->prog = prog;
	chp->done = done;
	chp->arg = arg;
	chp->next = children;
	children = chp;
    }
}


/*
 * reap_kids - get status from any dead child processes,
 * and log a message for abnormal terminations.
 */
static int
reap_kids(waitfor)
    int waitfor;
{
    pid_t pid;
    int status, i;
    struct subprocess *chp, **prevp;

    got_sigchld = 0;
    if (n_children == 0)
	return (0);

    /*CONSTANTCONDITION*/
    while (1) {
	pid = waitpid(-1, &status, (waitfor ? 0 : WNOHANG));
	if (pid == 0) {
	    break;	/* return 0 */
	} else if (pid == -1) {
	    if (errno == EINTR)
		continue;
	    if (errno != ECHILD)
		error("Error waiting for child process: %m");
	    return (-1);
	} else {
	    for (prevp = &children; (chp = *prevp) != NULL;
		prevp = &chp->next) {
		if (chp->pid == pid) {
		    --n_children;
		    *prevp = chp->next;
		    break;
		}
	    }
	    if (WIFSIGNALED(status) || WIFSTOPPED(status)) {
		i = WIFSIGNALED(status) ? WTERMSIG(status) : WSTOPSIG(status);
		warn("Child process %s (pid %d) %s with signal %d (%s)",
		    (chp != NULL ? chp->prog : "??"), pid,
		    (WIFSIGNALED(status) ? "terminated" : "stopped"),
		    i, signal_name(i));
	    } else if (debug) {
		dbglog("Child process %s finished (pid %d), status = %d",
		       (chp != NULL ? chp->prog: "??"), pid,
		    WEXITSTATUS(status));
	    }
	    if ((chp != NULL) && (chp->done != NULL))
		(*chp->done)(chp->arg, status);
	    if (chp != NULL)
		free(chp);
	}
    }
    return (0);
}

/*
 * infanticide - timeout while waiting for child process.
 */
/*ARGSUSED*/
static void
infanticide(sig)
    int sig;
{
    struct subprocess *chp;
    static int runcount = 0;

    if (runcount < 2) {
	for (chp = children; chp != NULL; chp = chp->next)
	    (void) kill(chp->pid, runcount == 0 ? SIGTERM : SIGKILL);
    } else {
	kill_my_pg(SIGTERM);
	/* Quit and hope for the best. */
	n_children = 0;
    }
    runcount++;
}

/*
 * Perform final wait before exiting.
 */
static void
final_reap()
{
    struct sigaction sa;
    struct subprocess *chp;

    if (n_children > 0 && debug) {
	dbglog("Waiting for %d child processes...", n_children);
	for (chp = children; chp != NULL; chp = chp->next)
	    dbglog("  pid %d: %s", chp->pid, chp->prog);
    }
    BZERO(&sa, sizeof (sa));
/*CONSTANTCONDITION*/ SIGNAL(SIGALRM, infanticide);
    while (n_children > 0) {
	(void) alarm(7);
	if (reap_kids(1) < 0)
	    break;
    }
    (void) alarm(0);
}

/*
 * novm - log an error message saying we ran out of memory, and die.
 */
void
novm(msg)
    char *msg;
{
    fatal("Virtual memory exhausted allocating %s\n", msg);
}

/*
 * script_setenv - set an environment variable value to be used
 * for scripts that we run (e.g. ip-up, auth-up, etc.)
 */
void
script_setenv(var, value, iskey)
    const char *var;
    const char *value;
    int iskey;
{
    size_t varl = strlen(var);
    size_t vl = varl + strlen(value) + 2;
    int i;
    char *p, *newstring;

    /*
     * XXX: Can we assert that a tdb write lock is held here ?  It appears that
     *	    Linux's use of tdb is not safe.
     */
    newstring = (char *) malloc(vl+1);
    if (newstring == NULL) {
	novm("script environment string");
	return;
    }
    *newstring++ = iskey;
    (void) slprintf(newstring, vl, "%s=%s", var, value);

    /* check if this variable is already set */
    if (script_env != NULL) {
	for (i = 0; (p = script_env[i]) != NULL; ++i) {
	    if (strncmp(p, var, varl) == 0 && p[varl] == '=') {
#ifdef HAVE_MULTILINK
		if (p[-1] != '\0' && pppdb != NULL)
		    delete_db_key(p);
#endif
		free(p-1);
		script_env[i] = newstring;
#ifdef HAVE_MULTILINK
		if (iskey && pppdb != NULL)
		    add_db_key(newstring);
		update_db_entry();
#endif
		return;
	    }
	}
    } else {
	/* no space allocated for script env. ptrs. yet */
	i = 0;
	script_env = (char **) malloc(16 * sizeof(char *));
	if (script_env == NULL) {
	    novm("script environment variable.");
	    return;
	}
	s_env_nalloc = 16;
    }

    /* reallocate script_env with more space if needed */
    if (i + 1 >= s_env_nalloc) {
	int new_n = i + 17;
	char **newenv = (char **) realloc((void *)script_env,
					  new_n * sizeof(char *));
	if (newenv == NULL) {
	    novm("expanded script environment variable.");
	    return;
	}
	script_env = newenv;
	s_env_nalloc = new_n;
    }

    script_env[i] = newstring;
    script_env[i+1] = NULL;

#ifdef HAVE_MULTILINK
    if (pppdb != NULL) {
	if (iskey)
	    add_db_key(newstring);
	update_db_entry();
    }
#endif
}

/*
 * script_unsetenv - remove a variable from the environment
 * for scripts.
 */
void
script_unsetenv(var)
    const char *var;
{
    int vl = strlen(var);
    int i;
    char *p;

    /*
     * XXX: Can we assert that a tdb write lock is held here ?  It appears that
     *	    Linux's use of tdb is not safe.
     */
    if (script_env == NULL)
	return;
    for (i = 0; (p = script_env[i]) != NULL; ++i) {
	if (strncmp(p, var, vl) == 0 && p[vl] == '=') {
#ifdef HAVE_MULTILINK
	    if (p[-1] != '\0' && pppdb != NULL)
		delete_db_key(p);
#endif
	    free(p-1);
	    while ((script_env[i] = script_env[i+1]) != NULL)
		++i;
	    break;
	}
    }
#ifdef HAVE_MULTILINK
    if ((pppdb != NULL) && (p != NULL))
	update_db_entry();
#endif
}

/*
 * script_getenv - find a variable in the script environment.
 */
const char *
script_getenv(var)
    const char *var;
{
    int vl = strlen(var);
    int i;
    char *p;

    if (script_env == NULL)
	return (NULL);
    for (i = 0; (p = script_env[i]) != NULL; ++i) {
	if (strncmp(p, var, vl) == 0 && p[vl] == '=')
	    return ((const char *)p+vl+1);
    }
    return (NULL);
}

#ifdef HAVE_MULTILINK
/*
 * update_db_entry - update our entry in the database.
 */
static void
update_db_entry()
{
    TDB_DATA key, dbuf;
    int vlen, i;
    char *p, *q, *vbuf;

    if (script_env == NULL)
	return;
    /*
     * vlen needs to be initialized as 1, or otherwise, the last string
     * is truncated by slprintf.
     */
    vlen = 1;
    for (i = 0; (p = script_env[i]) != NULL; ++i)
	vlen += strlen(p) + 1;
    vbuf = malloc(vlen);
    if (vbuf == NULL)
	novm("database entry");
    q = vbuf;
    for (i = 0; (p = script_env[i]) != NULL; ++i)
	q += slprintf(q, vbuf + vlen - q, "%s;", p);

    key.dptr = db_key;
    key.dsize = strlen(db_key);
    dbuf.dptr = vbuf;
    dbuf.dsize = vlen;
    if (tdb_store(pppdb, key, dbuf, TDB_REPLACE))
	error("tdb_store failed: %s", tdb_error(pppdb));
}

/*
 * add_db_key - add a key that we can use to look up our database entry.
 */
static void
add_db_key(str)
    const char *str;
{
    TDB_DATA key, dbuf;

    key.dptr = (char *) str;
    key.dsize = strlen(str);
    dbuf.dptr = db_key;
    dbuf.dsize = strlen(db_key);
    if (tdb_store(pppdb, key, dbuf, TDB_REPLACE))
	error("tdb_store key failed: %s", tdb_error(pppdb));
}

/*
 * delete_db_key - delete a key for looking up our database entry.
 */
static void
delete_db_key(str)
    const char *str;
{
    TDB_DATA key;

    key.dptr = (char *) str;
    key.dsize = strlen(str);
    (void) tdb_delete(pppdb, key);
}

/*
 * cleanup_db - delete all the entries we put in the database.
 */
static void
cleanup_db()
{
    TDB_DATA key;
    int i;
    char *p;

    key.dptr = db_key;
    key.dsize = strlen(db_key);
    (void) tdb_delete(pppdb, key);
    for (i = 0; (p = script_env[i]) != NULL; ++i)
	if (p[-1] != '\0')
	    delete_db_key(p);
}
#endif /* HAVE_MULTILINK */

/*
 * open_socket - establish a stream socket connection to the nominated
 * host and port.
 * XXX: Need IPv6 support for those systems that support it (use getaddrinfo),
 *	but requires portability changes.
 */
static int
open_socket(dest)
    char *dest;
{
    char *sep, *endp = NULL;
    int sock;
    int port = -1;
    u_int32_t host;
    struct hostent *hent = NULL;
    struct sockaddr_in sad;
    struct servent *se;

    /* parse host:port and resolve host to an IP address */
    sep = strchr(dest, ':');
    if (sep != NULL) {
	se = getservbyname((const char *)sep+1, "tcp");
	if (se != NULL) {
	    port = ntohs(se->s_port);
	} else {
	    port = strtol(sep+1, &endp, 10);
	    if (endp == sep+1 || *endp != '\0') {
		error("Can't parse host:port for socket destination");
		return (-1);
	    }
	}
    }
    if (port < 0 || port > 65535 || sep == dest) {
	error("Can't parse host:port for socket destination");
	return (-1);
    }
    *sep = '\0';
    host = inet_addr(dest);
    if (host == (u_int32_t) -1) {
	hent = gethostbyname(dest);
	if (hent == NULL) {
	    error("%s: unknown host in socket option", dest);
	    *sep = ':';
	    return (-1);
	}
	BCOPY(hent->h_addr_list[0], &host, sizeof(host));
	hent->h_addr_list++;
    }
    *sep = ':';

    for (;;) {
	/* get a socket and connect it to the other end */
	sock = socket(PF_INET, SOCK_STREAM, 0);
	if (sock < 0) {
	    error("Can't create socket: %m");
	    return (-1);
	}
	BZERO(&sad, sizeof(sad));
	sad.sin_family = AF_INET;
	sad.sin_port = htons(port);
	sad.sin_addr.s_addr = host;
	if (connect(sock, (struct sockaddr *)&sad, sizeof(sad)) >= 0) {
	    break;  /* return sock file descriptor */
	}
	if ((hent != NULL) && (hent->h_addr_list != NULL)) {
	    BCOPY(hent->h_addr_list[0], &host, sizeof(host));
	    hent->h_addr_list++;
	    (void) close(sock);
	    continue;
	}
	error("Can't connect to %s: %m", dest);
	(void) close(sock);
	return (-1);
    }
    return (sock);
}

/*
 * print_ncpstate - prints out current NCP state.
 *
 * We're normally called from SIGUSR1 here, but this is safe because
 * these signals are blocked unless we're idle waiting for events.
 * There's no need to otherwise lock the data structures referenced.
 */
void
print_ncpstate(unit, strptr)
    int unit;
    FILE *strptr;
{
    struct protent *protp;
    int i;

    (void) flprintf(strptr, "In %s phase\n", phase_name(phase));
    for (i = 0; (protp = protocols[i]) != NULL; ++i) {
	if (protp->print_stat != NULL)
	    (*protp->print_stat)(unit, strptr);
    }
    sys_print_state(strptr);
}

/*
 * start_charshunt - create a child process to run the character shunt.
 */
static int
start_charshunt(ifd, ofd)
    int ifd, ofd;
{
    pid_t cpid;

    cpid = fork();
    if (cpid == (pid_t)-1) {
	error("Can't fork process for character shunt: %m");
	return (0);
    }
    if (cpid == (pid_t)0) {
	/* child */
	(void) close(pty_slave);
	pty_slave = -1;
	(void) setgid(getgid());
	(void) setuid(uid);
	if (getuid() != uid)
	    fatal("setuid failed");
	if (!nodetach)
	    log_to_fd = -1;
	charshunt(ifd, ofd, record_file);
	exit(0);
    }
    charshunt_pid = cpid;
    (void) close(pty_master);
    pty_master = -1;
    ttyfd = pty_slave;
    record_child(cpid, "pppd (charshunt)", charshunt_done, NULL);
    return (1);
}

/*ARGSUSED*/
static void
charshunt_done(arg, status)
    void *arg;
    int status;
{
    charshunt_pid = (pid_t)0;
}

static void
reportme(int signo)
{
    dbglog("charshunt taking signal %d", signo);
    exit(1);
}

/*
 * charshunt - the character shunt, which passes characters between
 * the pty master side and the serial port (or stdin/stdout).
 * This runs as the user (not as root).
 * (We assume ofd >= ifd which is true the way this gets called. :-).
 */
static void
charshunt(ifd, ofd, record_file)
    int ifd, ofd;
    char *record_file;
{
    int n, nfds;
    fd_set ready, writey;
    u_char *ibufp, *obufp;
    int nibuf, nobuf;
    int flags;
    struct timeval lasttime;
    FILE *recordf = NULL;
    int ilevel, olevel, max_level;
    struct timeval levelt, tout, *top;

    /*
     * Reset signal handlers.
     */
    (void) signal(SIGHUP, SIG_IGN);		/* Hangup */
    (void) signal(SIGINT, reportme);		/* Interrupt */
    (void) signal(SIGTERM, reportme);		/* Terminate */
    (void) signal(SIGCHLD, reportme);
    (void) signal(SIGUSR1, reportme);
    (void) signal(SIGUSR2, reportme);
    (void) signal(SIGABRT, reportme);
    (void) signal(SIGALRM, reportme);
    (void) signal(SIGFPE, reportme);
    (void) signal(SIGILL, reportme);
    (void) signal(SIGPIPE, reportme);
    (void) signal(SIGQUIT, reportme);
#ifndef DEBUG
    (void) signal(SIGSEGV, reportme);
#endif
#ifdef SIGBUS
    (void) signal(SIGBUS, reportme);
#endif
#ifdef SIGEMT
    (void) signal(SIGEMT, reportme);
#endif
#ifdef SIGPOLL
    (void) signal(SIGPOLL, reportme);
#endif
#ifdef SIGPROF
    (void) signal(SIGPROF, reportme);
#endif
#ifdef SIGSYS
    (void) signal(SIGSYS, reportme);
#endif
#ifdef SIGTRAP
    (void) signal(SIGTRAP, reportme);
#endif
#ifdef SIGVTALRM
    (void) signal(SIGVTALRM, reportme);
#endif
#ifdef SIGXCPU
    (void) signal(SIGXCPU, reportme);
#endif
#ifdef SIGXFSZ
    (void) signal(SIGXFSZ, reportme);
#endif

    /*
     * Open the record file if required.
     */
    if (record_file != NULL) {
	recordf = fopen(record_file, "a");
	if (recordf == NULL)
	    error("Couldn't create record file %s: %m", record_file);
    }

    /* set all the fds to non-blocking mode */
    flags = fcntl(pty_master, F_GETFL);
    if (flags == -1
	|| fcntl(pty_master, F_SETFL, flags | O_NONBLOCK) == -1)
	warn("couldn't set pty master to nonblock: %m");
    flags = fcntl(ifd, F_GETFL);
    if (flags == -1
	|| fcntl(ifd, F_SETFL, flags | O_NONBLOCK) == -1)
	warn("couldn't set %s to nonblock: %m", (ifd==0? "stdin": "tty"));
    if (ofd != ifd) {
	flags = fcntl(ofd, F_GETFL);
	if (flags == -1
	    || fcntl(ofd, F_SETFL, flags | O_NONBLOCK) == -1)
	    warn("couldn't set stdout to nonblock: %m");
    }

    nibuf = nobuf = 0;
    ibufp = obufp = NULL;

    ilevel = olevel = 0;
    (void) gettimeofday(&levelt, NULL);
    if (max_data_rate) {
	max_level = max_data_rate / 10;
	if (max_level < MAXLEVELMINSIZE)
	    max_level = MAXLEVELMINSIZE;
    } else
	max_level = sizeof(inpacket_buf) + 1;

    nfds = (ofd > pty_master? ofd: pty_master) + 1;
    if (recordf != NULL) {
	(void) gettimeofday(&lasttime, NULL);
	(void) putc(RECMARK_TIMESTART, recordf);	/* put start marker */
	(void) putc(lasttime.tv_sec >> 24, recordf);
	(void) putc(lasttime.tv_sec >> 16, recordf);
	(void) putc(lasttime.tv_sec >> 8, recordf);
	(void) putc(lasttime.tv_sec, recordf);
	lasttime.tv_usec = 0;
    }

    while (nibuf != 0 || nobuf != 0 || ofd >= 0 || pty_master >= 0) {
	top = 0;
	tout.tv_sec = 0;
	tout.tv_usec = 10000;
	FD_ZERO(&ready);
	FD_ZERO(&writey);
	if (nibuf != 0) {
	    if (ilevel >= max_level)
		top = &tout;
	    else if (pty_master >= 0)
		FD_SET(pty_master, &writey);
	} else if (ifd >= 0)
	    FD_SET(ifd, &ready);
	if (nobuf != 0) {
	    if (olevel >= max_level)
		top = &tout;
	    else if (ofd >= 0)
		FD_SET(ofd, &writey);
	} else {
	    /* Don't read from pty if it's gone or it has closed. */
	    if (pty_master >= 0 && ofd >= 0)
		FD_SET(pty_master, &ready);
	}
	if (select(nfds, &ready, &writey, NULL, top) < 0) {
	    if (errno != EINTR)
		fatal("select");
	    continue;
	}
	if (max_data_rate) {
	    double dt;
	    int nbt;
	    struct timeval now;

	    (void) gettimeofday(&now, NULL);
	    dt = (now.tv_sec - levelt.tv_sec
		  + (now.tv_usec - levelt.tv_usec) / 1e6);
	    nbt = (int)(dt * max_data_rate);
	    ilevel = (nbt < 0 || nbt > ilevel)? 0: ilevel - nbt;
	    olevel = (nbt < 0 || nbt > olevel)? 0: olevel - nbt;
	    levelt = now;
	} else
	    ilevel = olevel = 0;
	if (FD_ISSET(ifd, &ready)) {
	    ibufp = inpacket_buf;
	    nibuf = read(ifd, ibufp, sizeof(inpacket_buf));
	    if (nibuf < 0 && errno == EIO)
		nibuf = 0;
	    if (nibuf < 0 || pty_master == -1) {
		if (errno != EINTR && errno != EAGAIN) {
		    error("Error reading standard input: %m");
		    break;
		}
		nibuf = 0;
	    } else if (nibuf == 0) {
		/* end of file from stdin */
		(void) close(pty_master);
		pty_master = -1;
		(void) close(ifd);
		ifd = -1;
		if (recordf)
		    if (!record_write(recordf, RECMARK_ENDRECV, NULL, 0,
			&lasttime))
			recordf = NULL;
	    } else {
		FD_SET(pty_master, &writey);
		if (recordf)
		    if (!record_write(recordf, RECMARK_STARTRECV, ibufp, nibuf,
			&lasttime))
			recordf = NULL;
	    }
	}
	if (ofd >= 0 && pty_master >= 0 && FD_ISSET(pty_master, &ready)) {
	    obufp = outpacket_buf;
	    nobuf = read(pty_master, obufp, sizeof(outpacket_buf));
	    if (nobuf < 0 && errno == EIO)
		nobuf = 0;
	    if (nobuf < 0 || ofd == -1) {
		if (!(errno == EINTR || errno == EAGAIN)) {
		    error("Error reading pseudo-tty master: %m");
		    break;
		}
		nobuf = 0;
	    } else if (nobuf == 0) {
		/* end of file from the pty - slave side has closed */
		nibuf = 0;
		(void) close(ofd);
		ofd = -1;
		if (recordf)
		    if (!record_write(recordf, RECMARK_ENDSEND, NULL, 0,
			&lasttime))
			recordf = NULL;
	    } else {
		FD_SET(ofd, &writey);
		if (recordf)
		    if (!record_write(recordf, RECMARK_STARTSEND, obufp, nobuf,
			&lasttime))
			recordf = NULL;
	    }
	}
	if (ofd == -1)
	    nobuf = 0;
	else if (FD_ISSET(ofd, &writey)) {
	    n = nobuf;
	    if (olevel + n > max_level)
		n = max_level - olevel;
	    n = write(ofd, obufp, n);
	    if (n < 0) {
		if (errno == EIO) {
		    (void) close(ofd);
		    ofd = -1;
		    nobuf = 0;
		} else if (errno != EAGAIN && errno != EINTR) {
		    error("Error writing standard output: %m");
		    break;
		}
	    } else {
		obufp += n;
		nobuf -= n;
		olevel += n;
	    }
	}
	if (pty_master == -1)
	    nibuf = 0;
	else if (FD_ISSET(pty_master, &writey)) {
	    n = nibuf;
	    if (ilevel + n > max_level)
		n = max_level - ilevel;
	    n = write(pty_master, ibufp, n);
	    if (n < 0) {
		if (errno == EAGAIN || errno == EINTR)
		    continue;
		if (errno != EIO) {
		    error("Error writing pseudo-tty master: %m");
		    break;
		}
		(void) close(pty_master);
		pty_master = -1;
		nibuf = 0;
	    } else {
		ibufp += n;
		nibuf -= n;
		ilevel += n;
	    }
	}
    }
    exit(0);
}

static int
record_write(f, code, buf, nb, tp)
    FILE *f;
    int code;
    u_char *buf;
    int nb;
    struct timeval *tp;
{
    struct timeval now;
    int diff;

    (void) gettimeofday(&now, NULL);
    now.tv_usec /= 100000;	/* actually 1/10 s, not usec now */
    diff = (now.tv_sec - tp->tv_sec) * 10 + (now.tv_usec - tp->tv_usec);
    if (diff > 0) {
	if (diff > 255) {
	    (void) putc(RECMARK_TIMEDELTA32, f);
	    (void) putc(diff >> 24, f);
	    (void) putc(diff >> 16, f);
	    (void) putc(diff >> 8, f);
	    (void) putc(diff, f);
	} else {
	    (void) putc(RECMARK_TIMEDELTA8, f);
	    (void) putc(diff, f);
	}
	*tp = now;
    }
    (void) putc(code, f);
    if (buf != NULL) {
	(void) putc(nb >> 8, f);
	(void) putc(nb, f);
	(void) fwrite(buf, nb, 1, f);
    }
    (void) fflush(f);
    if (ferror(f)) {
	error("Error writing record file: %m");
	return (0);
    }
    return (1);
}



/* ============================================================================
 * SOURCE 88/98: minix4\exokernel\kernel_legacy\cmd\cmd-inet\usr.bin\rdist\main.c
 * Size: 12,305 bytes, Lines: 595
 * Hash: b07f031b841f...
 * ============================================================================ */

/*
 * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

/*
 * Copyright (c) 1983 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 */

#include "defs.h"
#include <string.h>
#include <syslog.h>
#include <k5-int.h>
#include <krb5defs.h>
#include <priv_utils.h>

#define	NHOSTS 100

/*
 * Remote distribution program.
 */

char	*distfile = NULL;
char	Tmpfile[] = "/tmp/rdistXXXXXX";
char	*tmpname = &Tmpfile[5];

int	debug;		/* debugging flag */
int	nflag;		/* NOP flag, just print commands without executing */
int	qflag;		/* Quiet. Don't print messages */
int	options;	/* global options */
int	iamremote;	/* act as remote server for transfering files */

FILE	*fin = NULL;	/* input file pointer */
int	rem = -1;	/* file descriptor to remote source/sink process */
char	host[32];	/* host name */
int	nerrs;		/* number of errors while sending/receiving */
char	user[10];	/* user's name */
char	homedir[128];	/* user's home directory */
char	buf[RDIST_BUFSIZ];	/* general purpose buffer */

struct	passwd *pw;	/* pointer to static area used by getpwent */
struct	group *gr;	/* pointer to static area used by getgrent */

char des_inbuf[2 * RDIST_BUFSIZ];	/* needs to be > largest read size */
char des_outbuf[2 * RDIST_BUFSIZ];	/* needs to be > largest write size */
krb5_data desinbuf, desoutbuf;
krb5_encrypt_block eblock;		/* eblock for encrypt/decrypt */
krb5_context bsd_context = NULL;
krb5_auth_context auth_context;
krb5_creds *cred;
char *krb_cache = NULL;
krb5_flags authopts;
krb5_error_code status;
enum kcmd_proto kcmd_proto = KCMD_NEW_PROTOCOL;

int encrypt_flag = 0;	/* Flag set when encryption is used */
int krb5auth_flag = 0;	/* Flag set, when KERBEROS is enabled */
static profile_options_boolean autologin_option[] = {
	{ "autologin", &krb5auth_flag, 0 },
	{ NULL, NULL, 0 }
};
static int no_krb5auth_flag = 0;

int debug_port = 0;

int retval = 0;
char *krb_realm = NULL;

/* Flag set, if -PN / -PO is specified */
static boolean_t rcmdoption_done = B_FALSE;

static int encrypt_done = 0;	/* Flag set, if -x is specified */
profile_options_boolean option[] = {
	{ "encrypt", &encrypt_flag, 0 },
	{ NULL, NULL, 0 }
};

static char *rcmdproto = NULL;
profile_option_strings rcmdversion[] = {
	{ "rcmd_protocol", &rcmdproto, 0 },
	{ NULL, NULL, 0 }
};

char *realmdef[] = { "realms", NULL, "rdist", NULL };
char *appdef[] = { "appdefaults", "rdist", NULL };

static void usage(void);
static char *prtype(int t);
static void prsubcmd(struct subcmd *s);
static void docmdargs(int nargs, char *args[]);
void prnames();
void prcmd();

int
main(argc, argv)
	int argc;
	char *argv[];
{
	register char *arg;
	int cmdargs = 0;
	char *dhosts[NHOSTS], **hp = dhosts;

	(void) setlocale(LC_ALL, "");

	pw = getpwuid(getuid());
	if (pw == NULL) {
		(void) fprintf(stderr, gettext("%s: Who are you?\n"), argv[0]);
		exit(1);
	}
	strncpy(user, pw->pw_name, sizeof (user));
	user[sizeof (user) - 1] = '\0';
	strncpy(homedir, pw->pw_dir, sizeof (homedir));
	homedir[sizeof (homedir) - 1] = '\0';
	gethostname(host, sizeof (host));

	while (--argc > 0) {
		if ((arg = *++argv)[0] != '-')
			break;
		if ((strcmp(arg, "-Server") == 0))
			iamremote++;
		else while (*++arg) {
			if (strncmp(*argv, "-PO", 3) == 0) {
				if (rcmdoption_done == B_TRUE) {
					(void) fprintf(stderr, gettext("rdist: "
						"Only one of -PN "
						"and -PO allowed.\n"));
					usage();
				}
				kcmd_proto = KCMD_OLD_PROTOCOL;
				krb5auth_flag++;
				rcmdoption_done = B_TRUE;
				break;
			}
			if (strncmp(*argv, "-PN", 3) == 0) {
				if (rcmdoption_done == B_TRUE) {
					(void) fprintf(stderr, gettext("rdist: "
						"Only one of -PN "
						"and -PO allowed.\n"));
					usage();
				}
				kcmd_proto = KCMD_NEW_PROTOCOL;
				krb5auth_flag++;
				rcmdoption_done = B_TRUE;
				break;
			}

			switch (*arg) {
#ifdef DEBUG
			case 'p':
				if (--argc <= 0)
					usage();
				debug_port = htons(atoi(*++argv));
				break;
#endif /* DEBUG */
			case 'k':
				if (--argc <= 0) {
					(void) fprintf(stderr, gettext("rdist: "
						"-k flag must be followed with "
						" a realm name.\n"));
					exit(1);
				}
				if ((krb_realm = strdup(*++argv)) == NULL) {
					(void) fprintf(stderr, gettext("rdist: "
						"Cannot malloc.\n"));
					exit(1);
				}
				krb5auth_flag++;
				break;

			case 'K':
				no_krb5auth_flag++;
				break;

			case 'a':
				krb5auth_flag++;
				break;

			case 'x':
				encrypt_flag++;
				encrypt_done++;
				krb5auth_flag++;
				break;

			case 'f':
				if (--argc <= 0)
					usage();
				distfile = *++argv;
				if (distfile[0] == '-' && distfile[1] == '\0')
					fin = stdin;
				break;

			case 'm':
				if (--argc <= 0)
					usage();
				if (hp >= &dhosts[NHOSTS-2]) {
					(void) fprintf(stderr, gettext("rdist:"
						" too many destination"
						" hosts\n"));
					exit(1);
				}
				*hp++ = *++argv;
				break;

			case 'd':
				if (--argc <= 0)
					usage();
				define(*++argv);
				break;

			case 'D':
				debug++;
				break;

			case 'c':
				cmdargs++;
				break;

			case 'n':
				if (options & VERIFY) {
					printf("rdist: -n overrides -v\n");
					options &= ~VERIFY;
				}
				nflag++;
				break;

			case 'q':
				qflag++;
				break;

			case 'b':
				options |= COMPARE;
				break;

			case 'R':
				options |= REMOVE;
				break;

			case 'v':
				if (nflag) {
					printf("rdist: -n overrides -v\n");
					break;
				}
				options |= VERIFY;
				break;

			case 'w':
				options |= WHOLE;
				break;

			case 'y':
				options |= YOUNGER;
				break;

			case 'h':
				options |= FOLLOW;
				break;

			case 'i':
				options |= IGNLNKS;
				break;

			default:
				usage();
			}
		}
	}
	*hp = NULL;

	mktemp(Tmpfile);

	/*
	 * if the user disables krb5 on the cmdline (-K), then skip
	 * all krb5 setup.
	 *
	 * if the user does not disable krb5 or enable krb5 on the
	 * cmdline, check krb5.conf to see if it should be enabled.
	 */

	if (no_krb5auth_flag) {
		krb5auth_flag = 0;
		encrypt_flag = 0;
	} else if (!krb5auth_flag) {
		/* is autologin set in krb5.conf? */
		status = krb5_init_context(&bsd_context);
		/* don't sweat failure here */
		if (!status) {
			/*
			 * note that the call to profile_get_options_boolean
			 * with autologin_option can affect value of
			 * krb5auth_flag
			 */
			(void) profile_get_options_boolean(bsd_context->profile,
							appdef,
							autologin_option);
		}
	}

	if (krb5auth_flag > 0) {
		if (!bsd_context) {
			status = krb5_init_context(&bsd_context);
			if (status) {
				com_err("rdist", status,
				    gettext("while initializing krb5"));
				exit(1);
			}
		}

		/* Set up des buffers */
		desinbuf.data = des_inbuf;
		desoutbuf.data = des_outbuf;
		desinbuf.length = sizeof (des_inbuf);
		desoutbuf.length = sizeof (des_outbuf);

		/*
		 * Get our local realm to look up local realm options.
		 */
		status = krb5_get_default_realm(bsd_context, &realmdef[1]);
		if (status) {
			com_err("rdist", status,
				gettext("while getting default realm"));
			exit(1);
		}
		/*
		 * See if encryption should be done for this realm
		 */
		profile_get_options_boolean(bsd_context->profile, realmdef,
						option);
		/*
		 * Check the appdefaults section
		 */
		profile_get_options_boolean(bsd_context->profile, appdef,
						option);
		profile_get_options_string(bsd_context->profile, appdef,
						rcmdversion);

		if ((encrypt_done > 0) || (encrypt_flag > 0)) {
			if (krb5_privacy_allowed() == TRUE) {
				encrypt_flag++;
			} else {
				(void) fprintf(stderr, gettext("rdist: "
						"Encryption not supported.\n"));
				exit(1);
			}
		}

		if ((rcmdoption_done == B_FALSE) && (rcmdproto != NULL)) {
			if (strncmp(rcmdproto, "rcmdv2", 6) == 0) {
				kcmd_proto = KCMD_NEW_PROTOCOL;
			} else if (strncmp(rcmdproto, "rcmdv1", 6) == 0) {
				kcmd_proto = KCMD_OLD_PROTOCOL;
			} else {
				(void) fprintf(stderr, gettext("Unrecognized "
					"KCMD protocol (%s)"), rcmdproto);
				exit(1);
			}
		}
	}

	if (iamremote) {
		setreuid(getuid(), getuid());
		server();
		exit(nerrs != 0);
	}
	if (__init_suid_priv(0, PRIV_NET_PRIVADDR, NULL) == -1) {
		(void) fprintf(stderr,
			"rdist needs to run with sufficient privilege\n");
		exit(1);
	}

	if (cmdargs)
		docmdargs(argc, argv);
	else {
		if (fin == NULL) {
			if (distfile == NULL) {
				if ((fin = fopen("distfile", "r")) == NULL)
					fin = fopen("Distfile", "r");
			} else
				fin = fopen(distfile, "r");
			if (fin == NULL) {
				perror(distfile ? distfile : "distfile");
				exit(1);
			}
		}
		yyparse();
		if (nerrs == 0)
			docmds(dhosts, argc, argv);
	}

	return (nerrs != 0);
}

static void
usage()
{
	printf(gettext("Usage: rdist [-nqbhirvwyDax] [-PN / -PO] "
#ifdef DEBUG
	"[-p port] "
#endif /* DEBUG */
	"[-k realm] [-f distfile] [-d var=value] [-m host] [file ...]\n"));
	printf(gettext("or: rdist [-nqbhirvwyDax] [-PN / -PO] [-p port] "
	"[-k realm] -c source [...] machine[:dest]\n"));
	exit(1);
}

/*
 * rcp like interface for distributing files.
 */
static void
docmdargs(nargs, args)
	int nargs;
	char *args[];
{
	register struct namelist *nl, *prev;
	register char *cp;
	struct namelist *files, *hosts;
	struct subcmd *cmds;
	char *dest;
	static struct namelist tnl = { NULL, NULL };
	int i;

	if (nargs < 2)
		usage();

	prev = NULL;
	for (i = 0; i < nargs - 1; i++) {
		nl = makenl(args[i]);
		if (prev == NULL)
			files = prev = nl;
		else {
			prev->n_next = nl;
			prev = nl;
		}
	}

	cp = args[i];
	if ((dest = index(cp, ':')) != NULL)
		*dest++ = '\0';
	tnl.n_name = cp;
	hosts = expand(&tnl, E_ALL);
	if (nerrs)
		exit(1);

	if (dest == NULL || *dest == '\0')
		cmds = NULL;
	else {
		cmds = makesubcmd(INSTALL);
		cmds->sc_options = options;
		cmds->sc_name = dest;
	}

	if (debug) {
		printf("docmdargs()\nfiles = ");
		prnames(files);
		printf("hosts = ");
		prnames(hosts);
	}
	insert(NULL, files, hosts, cmds);
	docmds(NULL, 0, NULL);
}

/*
 * Print a list of NAME blocks (mostly for debugging).
 */
void
prnames(nl)
	register struct namelist *nl;
{
	printf("( ");
	while (nl != NULL) {
		printf("%s ", nl->n_name);
		nl = nl->n_next;
	}
	printf(")\n");
}

void
prcmd(c)
	struct cmd *c;
{
	extern char *prtype();

	while (c) {
		printf("c_type %s, c_name %s, c_label %s, c_files ",
			prtype(c->c_type), c->c_name,
			c->c_label?  c->c_label : "NULL");
		prnames(c->c_files);
		prsubcmd(c->c_cmds);
		c = c->c_next;
	}
}

static void
prsubcmd(s)
	struct subcmd *s;
{
	extern char *prtype();
	extern char *proptions();

	while (s) {
		printf("sc_type %s, sc_options %d%s, sc_name %s, sc_args ",
			prtype(s->sc_type),
			s->sc_options, proptions(s->sc_options),
			s->sc_name ? s->sc_name : "NULL");
		prnames(s->sc_args);
		s = s->sc_next;
	}
}

char *
prtype(t)
	int t;
{
	switch (t) {
		case EQUAL:
			return ("EQUAL");
		case LP:
			return ("LP");
		case RP:
			return ("RP");
		case SM:
			return ("SM");
		case ARROW:
			return ("ARROW");
		case COLON:
			return ("COLON");
		case DCOLON:
			return ("DCOLON");
		case NAME:
			return ("NAME");
		case STRING:
			return ("STRING");
		case INSTALL:
			return ("INSTALL");
		case NOTIFY:
			return ("NOTIFY");
		case EXCEPT:
			return ("EXCEPT");
		case PATTERN:
			return ("PATTERN");
		case SPECIAL:
			return ("SPECIAL");
		case OPTION:
			return ("OPTION");
	}
	return (NULL);
}

char *
proptions(o)
	int o;
{
	return (printb((unsigned short) o, OBITS));
}

char *
printb(v, bits)
	register char *bits;
	register unsigned short v;
{
	register int i, any = 0;
	register char c;
	char *p = buf;

	bits++;
	if (bits) {

		*p++ = '<';
		while ((i = *bits++) != 0) {
			if (v & (1 << (i-1))) {
				if (any)
					*p++ = ',';
				any = 1;
				for (; (c = *bits) > 32; bits++)
					*p++ = c;
			} else
				for (; *bits > 32; bits++)
					;
		}
		*p++ = '>';
	}

	*p = '\0';
	return (buf);
}



/* ============================================================================
 * SOURCE 89/98: minix4\exokernel\kernel_legacy\cmd\cmd-inet\usr.bin\telnet\main.c
 * Size: 6,591 bytes, Lines: 282
 * Hash: 2039e15fc52b...
 * ============================================================================ */

/*
 * Copyright 2002 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

/*
 * Copyright (c) 1988, 1990 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef lint
char copyright[] =
"@(#) Copyright (c) 1988, 1990 Regents of the University of California.\n"
" All rights reserved.\n";
#endif /* not lint */

#ifndef lint
static char sccsid[] = "@(#)main.c	5.5 (Berkeley) 12/18/92";
#endif /* not lint */

#include <string.h>
#include <sys/types.h>

#include "ring.h"
#include "externs.h"
#include "defines.h"

/* These values need to be the same as defined in libtelnet/kerberos5.c */
/* Either define them in both places, or put in some common header file. */
#define	OPTS_FORWARD_CREDS		0x00000002
#define	OPTS_FORWARDABLE_CREDS		0x00000001

/*
 * This flag is incremented, if any of the
 * Kerberos command line options are used.
 */
int krb5auth_flag = 0;

/*
 * Initialize variables.
 */
int
tninit()
{
	init_terminal();

	init_network();

	if (init_telnet() == 0)
		return (0);

	init_sys();

	return (1);
}

#if	defined(USE_TOS)
#define	TELNET_OPTIONS	"8EKLS:X:acde:fFk:l:n:rt:x"
#else
#define	TELNET_OPTIONS	"8EKLX:acde:fFk:l:n:rt:x"
#endif	/* USE_TOS */

static void
usage()
{
	(void) fprintf(stderr, "Usage: %s %s\n",
		prompt,
		" [-8] [-E] [-K] [-L] [-a] [-c] [-d] [-f/-F] [-r] [-x]"
		"\n\t[-e char] [-k realm] [-l user] [-n tracefile] [-X atype]"
		"\n\t[host-name [port]]");
	exit(1);
}

/*
 * main.  Parse arguments, invoke the protocol or command parser.
 */


int
main(int argc, char *argv[])
{
	int ch;
	char *user;
	extern boolean_t auth_enable_encrypt;
	extern int forward_flags;

	/* Clear out things */
	if (tninit() == 0)
		return (EXIT_FAILURE);

	if (!isatty(fileno(stdin))) {
		setbuf(stdin, NULL);
	}
	if (!isatty(fileno(stdout))) {
		setbuf(stdout, NULL);
	}

	TerminalSaveState();

	if (prompt = strrchr(argv[0], '/'))
		++prompt;
	else
		prompt = argv[0];

	user = NULL;

	rlogin = (strncmp(prompt, "rlog", 4) == 0) ? '~' : _POSIX_VDISABLE;
	autologin = -1;

	while ((ch = getopt(argc, argv, TELNET_OPTIONS)) != EOF) {
		switch (ch) {
		case 'K':
			autologin_set = 1;
			autologin = 0;
			krb5auth_flag++;
			break;
		case 'X':
			auth_disable_name(optarg);
			krb5auth_flag++;
			break;
		case 'a':
			autologin_set = 1;
			autologin = 1;
			krb5auth_flag++;
			break;
		case 'f':
			if (forward_flags & OPTS_FORWARD_CREDS) {
			    (void) fprintf(stderr, gettext(
				"%s: Only one of -f "
				"and -F allowed.\n"), prompt);
			    usage();
			}
			forward_flags |= OPTS_FORWARD_CREDS;
			forward_flag_set = 1;
			krb5auth_flag++;
			break;
		case 'F':
			if (forward_flags & OPTS_FORWARD_CREDS) {
			    (void) fprintf(stderr, gettext(
				"%s: Only one of -f "
				"and -F allowed.\n"), prompt);
			    usage();
			}
			forward_flags |= OPTS_FORWARD_CREDS;
			forward_flags |= OPTS_FORWARDABLE_CREDS;
			forwardable_flag_set = 1;
			forward_flag = 1;
			krb5auth_flag++;
			break;
		case 'k':
			set_krb5_realm(optarg);
			krb5auth_flag++;
			break;
		case 'x':
			if (krb5_privacy_allowed()) {
				encrypt_auto(1);
				decrypt_auto(1);
				wantencryption = B_TRUE;
				autologin = 1;
				autologin_set = 1;
				auth_enable_encrypt = B_TRUE;
				encrypt_flag_set = 1;
				krb5auth_flag++;
			} else {
				(void) fprintf(stderr, gettext(
					"%s: Encryption not supported.\n"),
					prompt);
				exit(1);
			}
			break;

		/* begin common options */
		case '8':
			eight = 3;	/* binary output and input */
			break;
		case 'E':
			escape_valid = B_FALSE;
			rlogin = escape = _POSIX_VDISABLE;
			break;
		case 'L':
			eight |= 2;	/* binary output only */
			break;
#if USE_TOS
		case 'S':
			(void) fprintf(stderr,
			    "%s: Warning: -S ignored, no parsetos() support.\n",
			    prompt);
			break;
#endif /* USE_TOS */
		case 'c':
			skiprc = 1;
			break;
		case 'd':
			debug = 1;
			break;
		case 'e':
			escape_valid = B_TRUE;
			set_escape_char(optarg);
			break;
		case 'l':
			autologin_set = 1;
			autologin = 1;
			user = optarg;
			break;
		case 'n':
			SetNetTrace(optarg);
			break;
		case 'r':
			rlogin = '~';
			break;
		case 't':
			(void) fprintf(stderr,
			    "%s: Warning: -t ignored, no TN3270 support.\n",
			    prompt);
			break;
		default:
			usage();
			/* NOTREACHED */
		}
	}
	if (autologin == -1)
		autologin = (rlogin == _POSIX_VDISABLE) ? 0 : 1;

	argc -= optind;
	argv += optind;

	if (argc) {
		char *args[7], **argp = args;

		if (argc > 2)
			usage();
		*argp++ = prompt;
		if (user) {
			*argp++ = "-l";
			*argp++ = user;
		}
		*argp++ = argv[0];		/* host */
		if (argc > 1)
			*argp++ = argv[1];	/* port */
		*argp = 0;

		if (setjmp(toplevel) != 0)
			Exit(EXIT_SUCCESS);
		if (tn(argp - args, args) == 1)
			return (EXIT_SUCCESS);
		else
			return (EXIT_FAILURE);
	}
	(void) setjmp(toplevel);
	for (;;) {
		command(1, 0, 0);
	}
}



/* ============================================================================
 * SOURCE 90/98: minix4\exokernel\kernel_legacy\cmd\cmd-inet\usr.bin\tftp\main.c
 * Size: 23,253 bytes, Lines: 1,019
 * Hash: 3983988fa78e...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2002 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

/*	Copyright (c) 1983, 1984, 1985, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved	*/

/*
 * University Copyright- Copyright (c) 1982, 1986, 1988
 * The Regents of the University of California
 * All Rights Reserved
 *
 * University Acknowledgment- Portions of this document are derived from
 * software developed by the University of California, Berkeley, and its
 * contributors.
 */

/*
 * TFTP User Program -- Command Interface.
 */
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/sysmacros.h>

#include <arpa/inet.h>

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <errno.h>
#include <ctype.h>
#include <netdb.h>
#include <fcntl.h>
#include <string.h>
#include <limits.h>
#include <libtecla.h>

#include "tftpcommon.h"
#include "tftpprivate.h"

#define	TIMEOUT		5		/* secs between rexmt's */

struct sockaddr_in6	sin6;
int			f;
int			maxtimeout = 5 * TIMEOUT;
int			verbose;
int			trace;
int			srexmtval;
int			blksize;
int			rexmtval = TIMEOUT;
int			tsize_opt;
jmp_buf			toplevel;

static int			default_port, port;
static int			connected;
static char			mode[32];
static char			line[200];
static char			*prompt = "tftp> ";
static char			hostname[MAXHOSTNAMELEN];
static GetLine			*gl;

static void		intr(int);
static void		quit(int, char **);
static void		help(int, char **);
static void		setverbose(int, char **);
static void		settrace(int, char **);
static void		status(int, char **);
static void		get(int, char **);
static void		put(int, char **);
static void		setpeer(int, char **);
static void		modecmd(int, char **);
static void		setrexmt(int, char **);
static void		settimeout(int, char **);
static void		setbinary(int, char **);
static void		setascii(int, char **);
static void		setblksize(int, char **);
static void		setsrexmt(int, char **);
static void		settsize(int, char **);
static void		setmode(char *);
static void		putusage(char *);
static void		getusage(char *);
static char		*finddelimiter(char *);
static char		*removebrackets(char *);
static int		prompt_for_arg(char *, int, char *);
static struct cmd	*getcmd(char *);
static char		*tail(char *);
static void		command(int);
static void		makeargv(char *, int *, char ***);

#define	HELPINDENT (sizeof ("connect"))

struct cmd {
	char	*name;
	char	*help;
	void	(*handler)(int, char **);
};

static char	vhelp[] =	"toggle verbose mode";
static char	thelp[] =	"toggle packet tracing";
static char	chelp[] =	"connect to remote tftp";
static char	qhelp[] =	"exit tftp";
static char	hhelp[] =	"print help information";
static char	shelp[] =	"send file";
static char	rhelp[] =	"receive file";
static char	mhelp[] =	"set file transfer mode";
static char	sthelp[] =	"show current status";
static char	xhelp[] =	"set per-packet retransmission timeout";
static char	ihelp[] =	"set total retransmission timeout";
static char	ashelp[] =	"set mode to netascii";
static char	bnhelp[] =	"set mode to octet";
static char	bshelp[] =	"set transfer blocksize to negotiate with the "
				"server";
static char	srhelp[] =	"set preferred per-packet retransmission "
				"timeout for server";
static char	tshelp[] =	"toggle sending the transfer size option to "
				"the server";

static struct cmd	cmdtab[] = {
	{ "connect",	chelp,		setpeer },
	{ "mode",	mhelp,		modecmd },
	{ "put",	shelp,		put },
	{ "get",	rhelp,		get },
	{ "quit",	qhelp,		quit },
	{ "verbose",	vhelp,		setverbose },
	{ "trace",	thelp,		settrace },
	{ "status",	sthelp,		status },
	{ "binary",	bnhelp,		setbinary },
	{ "ascii",	ashelp,		setascii },
	{ "rexmt",	xhelp,		setrexmt },
	{ "timeout",	ihelp,		settimeout },
	{ "blksize",	bshelp,		setblksize },
	{ "srexmt",	srhelp,		setsrexmt },
	{ "tsize",	tshelp,		settsize },
	{ "help",	hhelp,		help },
	{ "?",		hhelp,		help },
	{ NULL }
};

#define	AMBIGCMD	(&cmdtab[ARRAY_SIZE(cmdtab)])

static struct modes {
	char *m_name;
	char *m_mode;
} modes[] = {
	{ "ascii",	"netascii" },
	{ "netascii",	"netascii" },
	{ "binary",	"octet" },
	{ "image",	"octet" },
	{ "octet",	"octet" },
/*      { "mail",       "mail" },       */
	{ NULL,		NULL }
};

static int
cmdmatch(WordCompletion *cpl, void *data, const char *line, int word_end)
{
	struct cmd *cmds = data;
	const char *word;
	int i, rc = 0;

	for (word = line + word_end; word > line && *(word - 1) != ' '; word--)
		;

	/* This word is command */
	if (word == line) {
		for (i = 0; cmds[i].name != NULL; i++) {
			const char *cmd = strstr(cmds[i].name, word);

			if (cmd == cmds[i].name) {
				rc = cpl_add_completion(cpl, line, 0,
				    word_end, cmds[i].name + strlen(word),
				    NULL, NULL);
			}
		}
	} else {
		/* We only complete arguments for mode command */
		if (strncmp(line, "mode", 4) == 0) {
			for (i = 0; modes[i].m_name != NULL; i++) {
				const char *mode;

				mode = strstr(modes[i].m_name, word);
				if (mode == modes[i].m_name) {
					rc = cpl_add_completion(cpl, line, 0,
					    word_end,
					    modes[i].m_name + strlen(word),
					    NULL, NULL);
				}
			}
		}
	}

	return (rc);
}

#define	LINELEN		1024
#define	HISTORY		2048

int
main(int argc, char **argv)
{
	struct servent *sp;
	struct sockaddr_in6 sin6;
	int top;

	sp = getservbyname("tftp", "udp");
	default_port = (sp != NULL) ? sp->s_port : htons(IPPORT_TFTP);
	port = default_port;

	f = socket(AF_INET6, SOCK_DGRAM, 0);
	if (f < 0) {
		perror("tftp: socket");
		exit(3);
	}

	(void) memset(&sin6, 0, sizeof (sin6));
	sin6.sin6_family = AF_INET6;
	if (bind(f, (struct sockaddr *)&sin6, sizeof (sin6)) < 0) {
		perror("tftp: bind");
		exit(1);
	}

	(void) strlcpy(mode, "netascii", sizeof (mode));

	gl = new_GetLine(LINELEN, HISTORY);
	if (gl == NULL) {
		perror("tftp: cli setup");
		exit(1);
	}

	/* SIGALRM is used by tftp */
	if (gl_ignore_signal(gl, SIGALRM) == 0) {
		if (gl_customize_completion(gl, cmdtab, cmdmatch) != 0)
			perror("gl_customize_completion");
	} else {
		perror("gl_ignore_signal");
	}

	(void) signal(SIGINT, intr);
	if (argc > 1) {
		if (setjmp(toplevel) != 0)
			exit(0);
		setpeer(argc, argv);
	}

	top = (setjmp(toplevel) == 0);
	for (;;)
		command(top);

	/*NOTREACHED*/
	return (0);
}

/* Prompt for command argument, add to buffer with space separator */
static int
prompt_for_arg(char *buffer, int buffer_size, char *prompt)
{
	char *buf;
	char *p;

	if (strlcat(buffer, " ", buffer_size) >= buffer_size) {
		(void) fputs("?Line too long\n", stderr);
		return (-1);
	}

	if (asprintf(&p, "(%s) ", prompt) < 0)
		perror("prompt_for_arg");
	buf = gl_get_line(gl, p, NULL, -1);
	free(p);
	if (buf == NULL)
		return (-1);

	if (strlcat(buffer, buf, buffer_size) >= buffer_size) {
		(void) fputs("?Line too long\n", stderr);
		return (-1);
	}
	return (0);
}

static void
unknown_host(int error, char *hostname)
{
	if (error == TRY_AGAIN)
		(void) fprintf(stderr, "%s: Unknown host (try again later).\n",
		    hostname);
	else
		(void) fprintf(stderr, "%s: Unknown host.\n", hostname);
}

static void
setpeer(int argc, char **argv)
{
	struct hostent *host;
	int error_num;
	struct in6_addr ipv6addr;
	struct in_addr ipv4addr;
	char *hostnameinput;
	const char *errstr;

	if (argc < 2) {
		if (strlcat(line, argv[0], sizeof (line)) >= sizeof (line)) {
			(void) fprintf(stderr, "%s is too big\n", argv[0]);
			return;
		}
		if (prompt_for_arg(line, sizeof (line), "to") == -1)
			return;
		makeargv(line, &argc, &argv);
	}
	if (argc > 3 || argc < 2) {
		(void) fprintf(stderr, "usage: %s host-name [port]\n",
		    argv[0]);
		return;
	}
	hostnameinput = removebrackets(argv[1]);

	(void) memset(&sin6, 0, sizeof (sin6));
	sin6.sin6_family = AF_INET6;
	host = getipnodebyname(hostnameinput, AF_INET6,
	    AI_ALL | AI_ADDRCONFIG | AI_V4MAPPED, &error_num);
	if (host != NULL) {
		(void) memcpy(&sin6.sin6_addr, host->h_addr_list[0],
		    host->h_length);
		/*
		 * If host->h_name is a IPv4-mapped IPv6 literal, we'll convert
		 * it to IPv4 literal address.
		 */
		if ((inet_pton(AF_INET6, host->h_name, &ipv6addr) > 0) &&
		    IN6_IS_ADDR_V4MAPPED(&ipv6addr)) {
			IN6_V4MAPPED_TO_INADDR(&ipv6addr, &ipv4addr);
			(void) inet_ntop(AF_INET, &ipv4addr, hostname,
			    sizeof (hostname));
		} else {
			(void) strlcpy(hostname, host->h_name,
			    sizeof (hostname));
		}
		freehostent(host);
	} else {
		/* Keeping with previous semantics */
		connected = 0;
		unknown_host(error_num, hostnameinput);
		return;
	}

	port = default_port;
	if (argc == 3) {
		port = strtonum(argv[2], 1, 65535, &errstr);
		if (errstr != NULL) {
			(void) fprintf(stderr, "%s: bad port number: %s\n",
			    argv[2], errstr);
			connected = 0;
			return;
		}
		port = htons(port);
	}
	connected = 1;
}

static void
modecmd(int argc, char **argv)
{
	struct modes *p;

	if (argc < 2) {
		(void) fprintf(stderr, "Using %s mode to transfer files.\n",
		    mode);
		return;
	}
	if (argc == 2) {
		for (p = modes; p->m_name != NULL; p++)
			if (strcmp(argv[1], p->m_name) == 0) {
				setmode(p->m_mode);
				return;
			}
		(void) fprintf(stderr, "%s: unknown mode\n", argv[1]);
		/* drop through and print usage message */
	}

	p = modes;
	(void) fprintf(stderr, "usage: %s [ %s", argv[0], p->m_name);
	for (p++; p->m_name != NULL; p++)
		(void) fprintf(stderr, " | %s", p->m_name);
	(void) puts(" ]");
}

/*ARGSUSED*/
static void
setbinary(int argc, char **argv)
{
	setmode("octet");
}

/*ARGSUSED*/
static void
setascii(int argc, char **argv)
{
	setmode("netascii");
}

static void
setmode(char *newmode)
{
	(void) strlcpy(mode, newmode, sizeof (mode));
	if (verbose)
		(void) printf("mode set to %s\n", mode);
}

/*
 * Send file(s).
 */
static void
put(int argc, char **argv)
{
	int fd;
	int n;
	char *cp, *targ;
	struct in6_addr	ipv6addr;
	struct in_addr ipv4addr;
	char buf[PATH_MAX + 1], *argtail;

	if (argc < 2) {
		if (strlcat(line, argv[0], sizeof (line)) >= sizeof (line)) {
			(void) fprintf(stderr, "%s is too big\n", argv[0]);
			return;
		}
		if (prompt_for_arg(line, sizeof (line), "file") == -1)
			return;
		makeargv(line, &argc, &argv);
	}
	if (argc < 2) {
		putusage(argv[0]);
		return;
	}
	targ = argv[argc - 1];
	if (finddelimiter(argv[argc - 1])) {
		char *cp;
		struct hostent *hp;
		int error_num;

		for (n = 1; n < argc - 1; n++)
			if (finddelimiter(argv[n])) {
				putusage(argv[0]);
				return;
			}
		cp = argv[argc - 1];
		targ = finddelimiter(cp);
		*targ++ = 0;
		cp = removebrackets(cp);

		if ((hp = getipnodebyname(cp,
		    AF_INET6, AI_ALL | AI_ADDRCONFIG | AI_V4MAPPED,
		    &error_num)) == NULL) {
			unknown_host(error_num, cp);
			return;
		}
		(void) memcpy(&sin6.sin6_addr, hp->h_addr_list[0],
		    hp->h_length);

		sin6.sin6_family = AF_INET6;
		connected = 1;
		/*
		 * If hp->h_name is a IPv4-mapped IPv6 literal, we'll convert
		 * it to IPv4 literal address.
		 */
		if ((inet_pton(AF_INET6, hp->h_name, &ipv6addr) > 0) &&
		    IN6_IS_ADDR_V4MAPPED(&ipv6addr)) {
			IN6_V4MAPPED_TO_INADDR(&ipv6addr, &ipv4addr);
			(void) inet_ntop(AF_INET, &ipv4addr, hostname,
			    sizeof (hostname));
		} else {
			(void) strlcpy(hostname, hp->h_name,
			    sizeof (hostname));
		}
	}
	if (!connected) {
		(void) fputs("No target machine specified.\n", stderr);
		return;
	}
	if (argc < 4) {
		cp = argc == 2 ? tail(targ) : argv[1];
		fd = open(cp, O_RDONLY);
		if (fd < 0) {
			(void) fprintf(stderr, "tftp: %s: %s\n", cp,
			    strerror(errno));
			return;
		}
		if (verbose)
			(void) printf("putting %s to %s:%s [%s]\n",
			    cp, hostname, targ, mode);
		sin6.sin6_port = port;
		tftp_sendfile(fd, targ, mode);
		return;
	}
	/* this assumes the target is a directory */
	/* on a remote unix system.  hmmmm.  */
	if (strlen(targ) + 1 >= sizeof (buf)) {
		(void) fprintf(stderr, "tftp: filename too long: %s\n", targ);
		return;
	}
	for (n = 1; n < argc - 1; n++) {
		argtail = tail(argv[n]);
		if (snprintf(buf, sizeof (buf), "%s/%s", targ, argtail) >=
		    sizeof (buf)) {
			(void) fprintf(stderr,
			    "tftp: filename too long: %s/%s\n", targ, argtail);
			continue;
		}
		fd = open(argv[n], O_RDONLY);
		if (fd < 0) {
			(void) fprintf(stderr, "tftp: %s: %s\n", argv[n],
			    strerror(errno));
			continue;
		}
		if (verbose)
			(void) printf("putting %s to %s:%s [%s]\n",
			    argv[n], hostname, buf, mode);
		sin6.sin6_port = port;
		tftp_sendfile(fd, buf, mode);
	}
}

static void
putusage(char *s)
{
	(void) fprintf(stderr, "usage: %s file ... host:target, or\n"
	    "       %s file ... target (when already connected)\n", s, s);
}

/*
 * Receive file(s).
 */
static void
get(int argc, char **argv)
{
	int fd;
	int n;
	char *cp;
	char *src;
	struct in6_addr ipv6addr;
	struct in_addr ipv4addr;
	int error_num;

	if (argc < 2) {
		if (strlcat(line, argv[0], sizeof (line)) >= sizeof (line)) {
			(void) fprintf(stderr, "%s is too big\n", argv[0]);
			return;
		}
		if (prompt_for_arg(line, sizeof (line), "files") == -1)
			return;
		makeargv(line, &argc, &argv);
	}
	if (argc < 2) {
		getusage(argv[0]);
		return;
	}
	if (!connected) {
		for (n = 1; n < argc; n++)
			if (finddelimiter(argv[n]) == 0) {
				getusage(argv[0]);
				return;
			}
	}
	for (n = 1; n < argc; n++) {
		src = finddelimiter(argv[n]);
		if (src == NULL)
			src = argv[n];
		else {
			struct hostent *hp;
			char *hostnameinput;

			*src++ = 0;
			hostnameinput = removebrackets(argv[n]);

			if ((hp = getipnodebyname(hostnameinput, AF_INET6,
			    AI_ALL | AI_ADDRCONFIG | AI_V4MAPPED,
			    &error_num)) == NULL) {
				unknown_host(error_num, hostnameinput);
				continue;
			}
			(void) memcpy((caddr_t)&sin6.sin6_addr,
			    hp->h_addr_list[0], hp->h_length);

			sin6.sin6_family = AF_INET6;
			connected = 1;
			/*
			 * If hp->h_name is a IPv4-mapped IPv6 literal, we'll
			 * convert it to IPv4 literal address.
			 */
			if ((inet_pton(AF_INET6, hp->h_name, &ipv6addr) > 0) &&
			    IN6_IS_ADDR_V4MAPPED(&ipv6addr)) {
				IN6_V4MAPPED_TO_INADDR(&ipv6addr, &ipv4addr);
				(void) inet_ntop(AF_INET, &ipv4addr, hostname,
				    sizeof (hostname));
			} else {
				(void) strlcpy(hostname, hp->h_name,
				    sizeof (hostname));
			}
		}
		if (argc < 4) {
			cp = argc == 3 ? argv[2] : tail(src);
			fd = creat(cp, 0644);
			if (fd < 0) {
				(void) fprintf(stderr, "tftp: %s: %s\n", cp,
				    strerror(errno));
				return;
			}
			if (verbose)
				(void) printf("getting from %s:%s to %s [%s]\n",
				    hostname, src, cp, mode);
			sin6.sin6_port = port;
			tftp_recvfile(fd, src, mode);
			break;
		}
		cp = tail(src);	/* new .. jdg */
		fd = creat(cp, 0644);
		if (fd < 0) {
			(void) fprintf(stderr, "tftp: %s: %s\n", cp,
			    strerror(errno));
			continue;
		}
		if (verbose)
			(void) printf("getting from %s:%s to %s [%s]\n",
			    hostname, src, cp, mode);
		sin6.sin6_port = port;
		tftp_recvfile(fd, src, mode);
	}
}

static void
getusage(char *s)
{
	(void) fprintf(stderr, "usage: %s host:file host:file ... file, or\n"
	    "       %s file file ... file if connected\n", s, s);
}

static void
setrexmt(int argc, char **argv)
{
	int t;
	const char *errstr;

	if (argc < 2) {
		if (strlcat(line, argv[0], sizeof (line)) >= sizeof (line)) {
			(void) fprintf(stderr, "%s is too big\n", argv[0]);
			return;
		}
		if (prompt_for_arg(line, sizeof (line), "value") == -1)
			return;
		makeargv(line, &argc, &argv);
	}
	if (argc != 2) {
		(void) fprintf(stderr, "usage: %s value\n", argv[0]);
		return;
	}

	t = strtonum(argv[1], 0, INT_MAX, &errstr);
	if (errstr != NULL)
		(void) fprintf(stderr, "%s: bad value: %s\n", argv[1], errstr);
	else
		rexmtval = t;
}

static void
settimeout(int argc, char **argv)
{
	int t;
	const char *errstr;

	if (argc < 2) {
		if (strlcat(line, argv[0], sizeof (line)) >= sizeof (line)) {
			(void) fprintf(stderr, "%s is too big\n", argv[0]);
			return;
		}
		if (prompt_for_arg(line, sizeof (line), "value") == -1)
			return;
		makeargv(line, &argc, &argv);
	}
	if (argc != 2) {
		(void) fprintf(stderr, "usage: %s value\n", argv[0]);
		return;
	}
	t = strtonum(argv[1], 0, INT_MAX, &errstr);
	if (errstr != NULL)
		(void) fprintf(stderr, "%s: bad value: %s\n", argv[1], errstr);
	else
		maxtimeout = t;
}

/*ARGSUSED*/
static void
status(int argc, char **argv)
{
	if (connected)
		(void) printf("Connected to %s.\n", hostname);
	else
		(void) puts("Not connected.");
	(void) printf("Mode: %s Verbose: %s Tracing: %s\n", mode,
	    verbose ? "on" : "off", trace ? "on" : "off");
	(void) printf("Rexmt-interval: %d seconds, Max-timeout: %d seconds\n",
	    rexmtval, maxtimeout);
	(void) printf("Transfer blocksize option: ");
	if (blksize == 0)
		(void) puts("off");
	else
		(void) printf("%d bytes\n", blksize);
	(void) printf("Server rexmt-interval option: ");
	if (srexmtval == 0)
		(void) puts("off");
	else
		(void) printf("%d seconds\n", srexmtval);
	(void) printf("Transfer size option: %s\n", tsize_opt ? "on" : "off");
}

/*ARGSUSED*/
static void
intr(int signum)
{
	(void) cancel_alarm();
	longjmp(toplevel, -1);
}

static char *
tail(char *filename)
{
	char *s;

	while (*filename != '\0') {
		s = strrchr(filename, '/');
		if (s == NULL)
			break;
		if (s[1] != '\0')
			return (&s[1]);
		*s = '\0';
	}
	return (filename);
}

/*
 * Command parser.
 */
static void
command(int top)
{
	struct cmd *c;
	char *buf, **argv;
	int argc;

	if (!top)
		(void) putchar('\n');
	for (;;) {
		buf = gl_get_line(gl, prompt, NULL, -1);
		if (buf == NULL) {
			quit(0, NULL);
		}

		makeargv(buf, &argc, &argv);
		c = getcmd(argv[0]);
		if (c == AMBIGCMD)
			(void) fputs("?Ambiguous command\n", stderr);
		else if (c == NULL)
			(void) fputs("?Invalid command\n", stderr);
		else
			(*c->handler)(argc, argv);
	}
}

static struct cmd *
getcmd(char *name)
{
	char *p, *q;
	struct cmd *c, *found;

	if (name == NULL)
		return (NULL);

	found = NULL;
	for (c = cmdtab; (p = c->name) != NULL; c++) {
		for (q = name; *q == *p++; q++)
			if (*q == '\0')		/* exact match? */
				return (c);
		if (*q == '\0')		/* the name was a prefix */
			found = (found == NULL) ? c : AMBIGCMD;
	}
	return (found);
}

/*
 * Given a string, this function returns the pointer to the delimiting ':'.
 * The string can contain an IPv6 literal address, which should be inside a
 * pair of brackets, e.g. [1::2]. Any colons inside a pair of brackets are not
 * accepted as delimiters. Returns NULL if delimiting ':' is not found.
 */
static char *
finddelimiter(char *str)
{
	bool is_bracket_open = false;
	char *cp;

	for (cp = str; *cp != '\0'; cp++) {
		if (*cp == '[')
			is_bracket_open = true;
		else if (*cp == ']')
			is_bracket_open = false;
		else if (*cp == ':' && !is_bracket_open)
			return (cp);
	}
	return (NULL);
}

/*
 * Given a string which is possibly surrounded by brackets, e.g. [1::2], this
 * function returns a string after removing those brackets. If the brackets
 * don't match, it does nothing.
 */
static char *
removebrackets(char *str)
{
	char *newstr = str;

	if ((str[0] == '[') && (str[strlen(str) - 1] == ']')) {
		newstr = str + 1;
		str[strlen(str) - 1] = '\0';
	}
	return (newstr);
}

#define	MARGV_INC	20

/*
 * Slice a string up into argc/argv.
 */
static void
makeargv(char *buf, int *argcp, char ***argvp)
{
	char *cp;
	char **argp;
	int argc;
	static char **argv;
	static int argv_size;

	if (argv == NULL) {
		argv_size = MARGV_INC;
		if ((argv = malloc(argv_size * sizeof (char *))) == NULL) {
			perror("tftp: malloc");
			exit(1);
		}
	}
	argc = 0;
	argp = argv;
	for (cp = buf; *cp != '\0'; ) {
		while (isspace(*cp))
			cp++;
		if (*cp == '\0')
			break;
		*argp++ = cp;
		argc++;
		if (argc == argv_size) {
			argv_size += MARGV_INC;
			if ((argv = realloc(argv,
			    argv_size * sizeof (char *))) == NULL) {
				perror("tftp: realloc");
				exit(1);
			}
			argp = argv + argc;
		}
		while (*cp != '\0' && !isspace(*cp))
			cp++;
		if (*cp == '\0')
			break;
		*cp++ = '\0';
	}
	*argp = NULL;

	*argcp = argc;
	*argvp = argv;
}

/*ARGSUSED*/
static void
quit(int argc, char **argv)
{
	exit(0);
}

/*
 * Help command.
 */
static void
help(int argc, char **argv)
{
	struct cmd *c;

	if (argc == 1) {
		(void) puts("Commands may be abbreviated.  Commands are:\n");
		for (c = cmdtab; c->name != NULL; c++)
			(void) printf("%-*s\t%s\n", HELPINDENT, c->name,
			    c->help);
		return;
	}
	while (--argc > 0) {
		char *arg;
		arg = *++argv;
		c = getcmd(arg);
		if (c == AMBIGCMD)
			(void) fprintf(stderr, "?Ambiguous help command %s\n",
			    arg);
		else if (c == NULL)
			(void) fprintf(stderr, "?Invalid help command %s\n",
			    arg);
		else
			(void) fprintf(stderr, "%s\n", c->help);
	}
}

/*ARGSUSED*/
static void
settrace(int argc, char **argv)
{
	trace = !trace;
	(void) printf("Packet tracing %s.\n", trace ? "on" : "off");
}

/*ARGSUSED*/
static void
setverbose(int argc, char **argv)
{
	verbose = !verbose;
	(void) printf("Verbose mode %s.\n", verbose ? "on" : "off");
}

static void
setblksize(int argc, char **argv)
{
	int b;
	const char *errstr;

	if (argc < 2) {
		if (strlcat(line, argv[0], sizeof (line)) >= sizeof (line)) {
			(void) fprintf(stderr, "%s is too big\n", argv[0]);
			return;
		}
		if (prompt_for_arg(line, sizeof (line), "value") == -1)
			return;
		makeargv(line, &argc, &argv);
	}
	if (argc != 2) {
		(void) fprintf(stderr, "usage: %s value\n", argv[0]);
		return;
	}

	/* RFC 2348 specifies valid blksize range, allow 0 to turn option off */
	errno = 0;
	b = strtonum(argv[1], 0, MAX_BLKSIZE, &errstr);
	if (errstr != NULL || (b > 0 && b < MIN_BLKSIZE))
		(void) fprintf(stderr, "%s: bad value: %s\n", argv[1], errstr);
	else
		blksize = b;
}

static void
setsrexmt(int argc, char **argv)
{
	int t;
	const char *errstr;

	if (argc < 2) {
		if (strlcat(line, argv[0], sizeof (line)) >= sizeof (line)) {
			(void) fprintf(stderr, "%s is too big\n", argv[0]);
			return;
		}
		if (prompt_for_arg(line, sizeof (line), "value") == -1)
			return;
		makeargv(line, &argc, &argv);
	}
	if (argc != 2) {
		(void) fprintf(stderr, "usage: %s value\n", argv[0]);
		return;
	}

	/* RFC 2349 specifies valid timeout range, allow 0 to turn option off */
	t = strtonum(argv[1], 0, MAX_TIMEOUT, &errstr);
	if (errstr != NULL || (t > 0 && t < MIN_TIMEOUT))
		(void) fprintf(stderr, "%s: bad value: %s\n", argv[1], errstr);
	else
		srexmtval = t;
}

static void
settsize(int argc, char **argv)
{
	if (argc != 1) {
		(void) fprintf(stderr, "usage: %s\n", argv[0]);
		return;
	}
	tsize_opt = !tsize_opt;
	(void) printf("Transfer size option %s.\n", tsize_opt ? "on" : "off");
}



/* ============================================================================
 * SOURCE 91/98: minix4\exokernel\kernel_legacy\cmd\cmd-inet\lib\nwamd\main.c
 * Size: 13,108 bytes, Lines: 475
 * Hash: 6c8002ddd59e...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.
 */

#include <errno.h>
#include <fcntl.h>
#include <libdllink.h>
#include <libintl.h>
#include <libnwam.h>
#include <locale.h>
#include <priv.h>
#include <pthread.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#include <libnwam.h>
#include "conditions.h"
#include "events.h"
#include "llp.h"
#include "ncp.h"
#include "objects.h"
#include "util.h"

/*
 * nwamd - NetWork Auto-Magic Daemon
 */

boolean_t fg = B_FALSE;
dladm_handle_t dld_handle = NULL;
ipadm_handle_t ipadm_handle = NULL;
boolean_t shutting_down = B_FALSE;

sigset_t original_sigmask;
static sigset_t sigwaitset;

static void nwamd_refresh(void);
static void graceful_shutdown(void);

/*
 * nwamd
 *
 * This is the Network Auto-Magic daemon.  For further high level information
 * see the Network Auto-Magic project and the Approachability communities
 * on opensolaris.org, nwamd(8), and the README in the source directory.
 *
 * The general structure of the code is as a set of event source threads
 * which feed events into the event handling thread. Some of these events
 * are internal-only (e.g UPGRADE), but some also involve propogation
 * to external listeners (who register via a door call into the daemon).
 *
 * signal management
 * Due to being threaded, a simple set of signal handlers would not work
 * very well for nwamd.  Instead nwamd blocks signals in all but the
 * signal handling thread at startup.
 *
 */

/*
 * In this file there are several utility functions which might otherwise
 * belong in util.c, but since they are only called from main(), they can
 * live here as static functions:
 * - nlog set-up
 * - daemonizing
 * - looking up smf(7) properties
 * - signal handling
 * - managing privileges(7)
 */

static void
start_logging(void)
{
	openlog("nwamd", LOG_PID | LOG_NDELAY, LOG_DAEMON);
}

static void
daemonize(void)
{
	pid_t pid;

	/*
	 * A little bit of magic here.  By the first fork+setsid, we
	 * disconnect from our current controlling terminal and become
	 * a session group leader.  By forking again without calling
	 * setsid again, we make certain that we are not the session
	 * group leader and can never reacquire a controlling terminal.
	 */
	if ((pid = fork()) == (pid_t)-1)
		pfail("fork 1 failed");
	if (pid != 0) {
		(void) wait(NULL);
		nlog(LOG_DEBUG, "child %ld exited, daemonizing", pid);
		_exit(0);
	}
	if (setsid() == (pid_t)-1)
		pfail("setsid");
	if ((pid = fork()) == (pid_t)-1)
		pfail("fork 2 failed");
	if (pid != 0) {
		_exit(0);
	}
	(void) chdir("/");
	(void) umask(022);
}

/* ARGSUSED */
static void *
sighandler(void *arg)
{
	int sig;

	while (!shutting_down) {
		sig = sigwait(&sigwaitset);
		nlog(LOG_DEBUG, "signal %s caught", strsignal(sig));

		switch (sig) {
		case SIGTHAW:
		case SIGHUP:
			/*
			 * Resumed from suspend or refresh.  Clear up all
			 * objects so their states start from scratch;
			 * then refresh().
			 */
			nwamd_fini_enms();
			nwamd_fini_ncus();
			nwamd_fini_locs();
			nwamd_refresh();
			break;
		case SIGUSR1:
			/*
			 * Undocumented "log ncu list" signal.
			 */
			nwamd_log_ncus();
			break;
		case SIGTERM:
			nlog(LOG_DEBUG, "%s received, shutting down",
			    strsignal(sig));
			graceful_shutdown();
			break;
		default:
			nlog(LOG_DEBUG, "unexpected signal %s received, "
			    "ignoring", strsignal(sig));
			break;
		}
	}
	return (NULL);
}

static void
init_signalhandling(void)
{
	pthread_attr_t attr;
	pthread_t sighand;
	int err;

	(void) pthread_attr_init(&attr);
	(void) pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	if (err = pthread_create(&sighand, &attr, sighandler, NULL)) {
		nlog(LOG_ERR, "pthread_create system: %s", strerror(err));
		exit(EXIT_FAILURE);
	} else {
		nlog(LOG_DEBUG, "signal handler thread: %d", sighand);
	}
	(void) pthread_attr_destroy(&attr);
}

/*
 * Construct the set of signals that we explicitly want to deal with.
 * We block these while we're still single-threaded; this block will
 * be inherited by all the threads we create.  When we are ready to
 * start handling signals, we will start the signal handling thread,
 * which will sigwait() this same set of signals, and will thus receive
 * and handle any that are sent to the process.
 */
static void
block_signals(void)
{
	(void) sigemptyset(&sigwaitset);
	(void) sigaddset(&sigwaitset, SIGHUP);
	(void) sigaddset(&sigwaitset, SIGUSR1);
	(void) sigaddset(&sigwaitset, SIGUSR2);
	(void) sigaddset(&sigwaitset, SIGTERM);
	(void) sigaddset(&sigwaitset, SIGTHAW);
	(void) pthread_sigmask(SIG_BLOCK, &sigwaitset, &original_sigmask);
}

/*
 * Look up nwamd property values and set daemon variables appropriately.
 * This function will be called on startup and via the signal handling
 * thread on receiving a HUP (which occurs when the nwam service is
 * refreshed).
 */
static void
lookup_daemon_properties(void)
{
	char *active_ncp_tmp;
	char *scan_level_tmp;

	(void) nwamd_lookup_boolean_property(OUR_FMRI, OUR_PG,
	    OUR_DEBUG_PROP_NAME, &debug);
	(void) nwamd_lookup_boolean_property(OUR_FMRI, OUR_PG,
	    OUR_AUTOCONF_PROP_NAME, &wireless_autoconf);
	(void) nwamd_lookup_boolean_property(OUR_FMRI, OUR_PG,
	    OUR_STRICT_BSSID_PROP_NAME, &wireless_strict_bssid);

	(void) pthread_mutex_lock(&active_ncp_mutex);
	if ((active_ncp_tmp = malloc(NWAM_MAX_NAME_LEN)) == NULL ||
	    nwamd_lookup_string_property(OUR_FMRI, OUR_PG,
	    OUR_ACTIVE_NCP_PROP_NAME, active_ncp_tmp, NWAM_MAX_NAME_LEN) != 0) {
		(void) strlcpy(active_ncp, NWAM_NCP_NAME_AUTOMATIC,
		    NWAM_MAX_NAME_LEN);
	} else {
		(void) strlcpy(active_ncp, active_ncp_tmp, NWAM_MAX_NAME_LEN);
	}
	(void) pthread_mutex_unlock(&active_ncp_mutex);
	free(active_ncp_tmp);

	if (nwamd_lookup_count_property(OUR_FMRI, OUR_PG,
	    OUR_CONDITION_CHECK_INTERVAL_PROP_NAME,
	    &condition_check_interval) != 0)
		condition_check_interval = CONDITION_CHECK_INTERVAL_DEFAULT;

	if ((scan_level_tmp = malloc(NWAM_MAX_NAME_LEN)) == NULL ||
	    nwamd_lookup_string_property(OUR_FMRI, OUR_PG,
	    OUR_WIRELESS_SCAN_LEVEL_PROP_NAME, scan_level_tmp,
	    NWAM_MAX_NAME_LEN) != 0) {
		wireless_scan_level = WIRELESS_SCAN_LEVEL_DEFAULT;
	} else {
		if (dladm_wlan_str2strength(scan_level_tmp,
		    &wireless_scan_level) != DLADM_STATUS_OK)
			wireless_scan_level = DLADM_WLAN_STRENGTH_VERY_WEAK;
	}
	free(scan_level_tmp);

	if (nwamd_lookup_count_property(OUR_FMRI, OUR_PG,
	    OUR_WIRELESS_SCAN_INTERVAL_PROP_NAME, &wireless_scan_interval) != 0)
		wireless_scan_interval = WIRELESS_SCAN_INTERVAL_DEFAULT;

	if (nwamd_lookup_count_property(OUR_FMRI, OUR_PG,
	    OUR_NCU_WAIT_TIME_PROP_NAME, &ncu_wait_time) != 0)
		ncu_wait_time = NCU_WAIT_TIME_DEFAULT;

	nlog(LOG_DEBUG, "Read daemon configuration properties.");
}

/*
 * Re-read the SMF properties.
 * Reset ncu priority group (since the NCUs will have to walk
 *   through their state machines again) and schedule a check
 * Re-read objects from libnwam.
 * Also, run condition checking for locations and ENMs.
 */
static void
nwamd_refresh(void)
{
	lookup_daemon_properties();

	(void) pthread_mutex_lock(&active_ncp_mutex);
	current_ncu_priority_group = INVALID_PRIORITY_GROUP;
	(void) pthread_mutex_unlock(&active_ncp_mutex);

	nwamd_init_ncus();
	nwamd_init_enms();
	nwamd_init_locs();

	nwamd_create_ncu_check_event(0);
	nwamd_create_triggered_condition_check_event(0);
}

static void
graceful_shutdown(void)
{
	nwamd_event_t event;

	shutting_down = B_TRUE;
	nwamd_event_sources_fini();
	nwamd_door_fini();
	nwamd_fini_enms();
	nwamd_fini_ncus();
	nwamd_fini_locs();

	event = nwamd_event_init_shutdown();
	if (event == NULL)
		pfail("nwamd could not create shutdown event, exiting");
	nwamd_event_enqueue(event);
}

int
main(int argc, char *argv[])
{
	int c;
	uint64_t version;
	nwamd_event_t event;
	dladm_status_t drc;
	ipadm_status_t irc;
	uid_t uid = getuid();

	/*
	 * Block the signals we care about (and which might cause us to
	 * exit based on default disposition) until we're ready to start
	 * handling them properly...see init_signalhandling() below.
	 */
	block_signals();

	if (uid != UID_NETADM && uid != 0) {
		/*
		 * This shouldn't happen normally.  On upgrade the service might
		 * need reloading.
		 */
		pfail("nwamd should run as uid %d, not uid %d\n", UID_NETADM,
		    uid);
	}

	(void) setlocale(LC_ALL, "");
	(void) textdomain(TEXT_DOMAIN);

	start_logging();
	nlog(LOG_INFO, "nwamd pid %d started", getpid());

	while ((c = getopt(argc, argv, "fs:")) != -1) {
		switch (c) {
			case 'f':
				fg = B_TRUE;
				break;
			default:
				nlog(LOG_ERR, "unrecognized option %c",
				    optopt);
				break;
		}
	}

	lookup_daemon_properties();

	if (!fg)
		daemonize();

	/*
	 * The dladm handle *must* be opened before privileges are dropped.
	 * The device privilege requirements, which are stored in
	 * /etc/security/device_policy, may not be loaded yet, as that's
	 * done by svc:/system/filesystem/root.  If they are not loaded,
	 * then one must have *all* privs in order to open /dev/dld, which
	 * is one of the steps performed in dladm_open().
	 */
	drc = dladm_open(&dld_handle);
	if (drc != DLADM_STATUS_OK) {
		char status_str[DLADM_STRSIZE];
		pfail("failed to open dladm handle: %s",
		    dladm_status2str(drc, status_str));
	}

	irc = ipadm_open(&ipadm_handle, 0);
	if (irc != IPADM_SUCCESS)
		pfail("failed to open ipadm handle: %s", ipadm_status2str(irc));

	/*
	 * Create the event queue before starting event sources, including
	 * signal handling, so we are ready to handle incoming events.  Also
	 * start before attempting to upgrade, in case there's a problem
	 * upgrading and we need to retry (in which case we schedule an event
	 * to do so).
	 */
	nwamd_event_queue_init();

	/*
	 * Handle upgrade of legacy config.  Absence of version property
	 * (which did not exist in phase 0 or 0.5) is the indication that
	 * we need to upgrade to phase 1 (version 1).
	 */
	if (nwamd_lookup_count_property(OUR_FMRI, OUR_PG, OUR_VERSION_PROP_NAME,
	    &version) != 0)
		nwamd_handle_upgrade(NULL);

	/*
	 * Initialize lists handling internal representations of objects.
	 */
	nwamd_object_lists_init();

	init_signalhandling();

	/* Enqueue init event */
	event = nwamd_event_init_init();
	if (event == NULL)
		pfail("nwamd could not create init event, exiting");
	nwamd_event_enqueue(event);

	/*
	 * Collect initial user configuration.
	 */

	/*
	 * Walk the physical interfaces and update the Automatic NCP to
	 * contain the IP and link NCUs for the interfaces that exist in
	 * the system.
	 */
	nwamd_walk_physical_configuration();

	/*
	 * We should initialize the door at the point that we can respond to
	 * user requests about the system but before we start actually process
	 * state changes or effecting the system.
	 */
	nwamd_door_init();

	/*
	 * Initialize data objects.
	 *
	 * Enabling an NCP involves refreshing nwam, which initializes the
	 * objects (ncu, enm, loc, known wlan).  Thus, no need to
	 * explicitly initialize these objects here.  The refresh also
	 * enqueues and NCU activation checking event.  Location and ENM
	 * condition checking are triggered by changes in NCU states.
	 */
	(void) pthread_mutex_lock(&active_ncp_mutex);
	if (nwamd_ncp_action(active_ncp, NWAM_ACTION_ENABLE) != 0)
		pfail("Initial enable failed for active NCP %s", active_ncp);
	(void) pthread_mutex_unlock(&active_ncp_mutex);

	/*
	 * Enqueue an event to start periodic checking of activation conditions.
	 */
	nwamd_create_timed_condition_check_event();

	/*
	 * These two routines safely minimize our privilege set.  They
	 * use reference counting to be safe in a threaded program.  It is
	 * gross that we escalate/deescalate to initialize this functionality
	 * but a real fix is to add functionality to do fine grained privs
	 * (and if necessary set uid to 0) in this threaded daemon.
	 */
	nwamd_escalate();
	nwamd_deescalate();

	/*
	 * Start the various agents (hooks on fds, threads) which collect events
	 */
	nwamd_event_sources_init();

	/*
	 * nwamd_event_handler() only returns on shutdown.
	 */
	nwamd_event_handler();

	ipadm_close(ipadm_handle);
	dladm_close(dld_handle);

	return (EXIT_SUCCESS);
}



/* ============================================================================
 * SOURCE 92/98: minix4\exokernel\kernel_legacy\cmd\cmd-crypto\tpmadm\main.c
 * Size: 5,858 bytes, Lines: 263
 * Hash: c8612c966423...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 * Copyright 2018 OmniOS Community Edition (OmniOSce) Association.
 */


#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <strings.h>
#include <libintl.h>
#include <locale.h>

#include <tss/tspi.h>
#include <trousers/trousers.h>
#include "tpmadm.h"

extern cmdtable_t commands[];

static void
print_usage(char *progname, cmdtable_t cmds[])
{
	cmdtable_t *p;

	(void) fprintf(stderr,
	    gettext("usage: %s command args ...\n"), progname);
	(void) fprintf(stderr,
	    gettext("where 'command' is one of the following:\n"));
	for (p = &cmds[0]; p->name != NULL; p++) {
		(void) fprintf(stderr, "\t%s %s\n", p->name, p->args);
	}
}

int
main(int argc, char *argv[])
{
	char *progname;
	cmdtable_t *p;
	cmdfunc_t fptr = NULL;
	int ret;
	TSS_HCONTEXT hContext;
	TSS_HOBJECT hTPM;

	/* Set up for i18n/l10n. */
#if !defined(TEXT_DOMAIN)		/* Should be defined by cc -D. */
#define	TEXT_DOMAIN	"SYS_TEST"	/* Use this only if it isn't. */
#endif
	(void) setlocale(LC_ALL, "");
	(void) textdomain(TEXT_DOMAIN);

	progname = argv[0];
	argc--;
	argv++;

	if (argc <= 0) {
		print_usage(progname, commands);
		return (ERR_USAGE);
	}

	for (p = &commands[0]; p->name != NULL; p++) {
		if (0 == strcmp(p->name, argv[0])) {
			fptr = p->func;
			break;
		}
	}
	if (fptr == NULL) {
		print_usage(progname, commands);
		return (ERR_USAGE);
	}

	if (tpm_preamble(&hContext, &hTPM))
		return (ERR_FAIL);
	ret = fptr(hContext, hTPM, argc, argv);
	(void) tpm_postamble(hContext);

	return (ret);
}


/*
 * Utility functions
 */

void
print_bytes(BYTE *bytes, size_t len, int formatted)
{
	int i;
	for (i = 0; i < len; i++) {
		(void) printf("%02X ", bytes[i]);
		if (formatted && i % 16 == 7)
			(void) printf("  ");
		if (formatted && i % 16 == 15)
			(void) printf("\n");
	}
	(void) printf("\n");
}


/*
 * TSS convenience functions
 */

void
print_error(TSS_RESULT ret, char *msg)
{
	char *err_string;

	/* Print the standard error string and error code. */
	err_string = Trspi_Error_String(ret);
	(void) fprintf(stderr, "%s: %s (0x%0x)\n", msg, err_string, ret);

	/* For a few special cases, add a more verbose error message. */
	switch (ret) {
	case TPM_E_DEACTIVATED:
	case TPM_E_DISABLED:
		(void) fprintf(stderr,
		    gettext("Enable the TPM and reboot.\n"));
		break;
	case TSP_ERROR(TSS_E_COMM_FAILURE):
		(void) fprintf(stderr,
		    gettext("Make sure the tcsd service "
		    "(svc:/application/security/tcsd) is running.\n"));
		break;
	}
}

int
get_tpm_capability(TSS_HCONTEXT hContext, TSS_HOBJECT hTPM, UINT32 cap,
    UINT32 subcap, void *buf, size_t bufsize)
{
	TSS_RESULT ret;
	UINT32 datalen;
	BYTE *data;

	ret = Tspi_TPM_GetCapability(hTPM, cap, sizeof (subcap),
	    (BYTE *)&subcap, &datalen, &data);
	if (ret) {
		print_error(ret, gettext("Get TPM capability"));
		return (ERR_FAIL);
	}

	if (datalen > bufsize) {
		(void) fprintf(stderr,
		    gettext("Capability 0x%x returned %u bytes "
		    "(expected %u)\n"), cap, datalen, bufsize);
		return (ERR_FAIL);
	}
	bcopy(data, buf, datalen);

	ret = Tspi_Context_FreeMemory(hContext, data);
	if (ret) {
		print_error(ret, gettext("Free capability buffer"));
		return (ERR_FAIL);
	}

	return (0);
}

int
set_policy_options(TSS_HPOLICY hPolicy, TSS_FLAG mode, char *prompt,
    UINT32 secret_len, BYTE *secret)
{
	TSS_RESULT ret;
	BYTE *unicode_prompt;
	UINT32 len;

	ret = Tspi_Policy_SetSecret(hPolicy, mode, secret_len, secret);
	if (ret) {
		print_error(ret, gettext("Set policy secret"));
		return (ERR_FAIL);
	}
	if (prompt != NULL) {
		unicode_prompt = Trspi_Native_To_UNICODE((BYTE *)prompt, &len);
		ret = Tspi_SetAttribData(hPolicy,
		    TSS_TSPATTRIB_POLICY_POPUPSTRING,
		    0, len, unicode_prompt);
		if (ret) {
			print_error(ret, gettext("Set policy prompt"));
			return (ERR_FAIL);
		}
	}

	return (0);
}

int
set_object_policy(TSS_HOBJECT handle, TSS_FLAG mode, char *prompt,
    UINT32 secret_len, BYTE *secret)
{
	TSS_HPOLICY hPolicy;
	TSS_RESULT ret;

	ret = Tspi_GetPolicyObject(handle, TSS_POLICY_USAGE, &hPolicy);
	if (ret) {
		print_error(ret, gettext("Get object policy"));
		return (ERR_FAIL);
	}

	return (set_policy_options(hPolicy, mode, prompt, secret_len, secret));
}

int
tpm_preamble(TSS_HCONTEXT *hContext, TSS_HOBJECT *hTPM)
{
	TSS_RESULT ret;

	ret = Tspi_Context_Create(hContext);
	if (ret) {
		print_error(ret, gettext("Create context"));
		return (ERR_FAIL);
	}

	ret = Tspi_Context_Connect(*hContext, NULL);
	if (ret) {
		print_error(ret, gettext("Connect context"));
		(void) Tspi_Context_Close(*hContext);
		return (ERR_FAIL);
	}

	ret = Tspi_Context_GetTpmObject(*hContext, hTPM);
	if (ret) {
		print_error(ret, gettext("Get TPM object"));
		(void) Tspi_Context_Close(*hContext);
		return (ERR_FAIL);
	}
	return (0);
}

int
tpm_postamble(TSS_HCONTEXT hContext)
{
	TSS_RESULT ret;

	ret = Tspi_Context_Close(hContext);
	if (ret) {
		print_error(ret, gettext("Close context"));
		return (ERR_FAIL);
	}
	return (0);
}



/* ============================================================================
 * SOURCE 93/98: minix4\exokernel\kernel_legacy\cmd\backup\restore\main.c
 * Size: 13,901 bytes, Lines: 579
 * Hash: 13a19f855077...
 * ============================================================================ */

/*
 * Copyright 2005 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

/*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved	*/

/*
 * Copyright (c) 1983 Regents of the University of California.
 * All rights reserved.  The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
 */

/*
 *	Modified to recursively extract all files within a subtree
 *	(supressed by the h option) and recreate the heirarchical
 *	structure of that subtree and move extracted files to their
 *	proper homes (supressed by the m option).
 *	Includes the s (skip files) option for use with multiple
 *	dumps on a single tape.
 *	8/29/80		by Mike Litzkow
 *
 *	Modified to work on the new file system and to recover from
 *	tape read errors.
 *	1/19/82		by Kirk McKusick
 *
 *	Full incremental restore running entirely in user code and
 *	interactive tape browser.
 *	1/19/83		by Kirk McKusick
 */

#include "restore.h"
#include <signal.h>
#include <byteorder.h>
#include <priv_utils.h>

#include <euc.h>
#include <getwidth.h>
#include <sys/mtio.h>
eucwidth_t wp;

int	bflag = 0, dflag = 0, vflag = 0, yflag = 0;
int	hflag = 1, mflag = 1, paginating = 0, offline = 0, autoload = 0;
int	autoload_tries;
int	autoload_period;
int	cvtflag = 0;		/* Converting from old dump format */
char	command = '\0';
long	dumpnum = 1;
int	volno = 0;
uint_t	ntrec;			/* blocking factor, in KB */
uint_t	saved_ntrec;		/* saved blocking factor, in KB */
ssize_t	tape_rec_size = 0;	/* tape record size (ntrec * tp_bsize) */
size_t	newtapebuf_size = 0;	/* save size of last call to newtapebuf */
char	*progname;
char	*dumpmap;
char	*clrimap;
char	*c_label;		/* if non-NULL, we must see this tape label */
ino_t	maxino;
time_t	dumptime;
time_t	dumpdate;
FILE 	*terminal;
char	*tmpdir;
char	*pager_catenated;
char	**pager_vector;
int	pager_len;
int	inattrspace = 0;
int	savepwd;
int32_t	tp_bsize = TP_BSIZE_MIN;
struct byteorder_ctx *byteorder;

static void set_tmpdir(void);

int
main(int argc, char *argv[])
{
	static struct arglist alist = { 0, 0, 0, 0, 0 };
	int  count;
	char *cp;
	char *fname;
	ino_t ino;
	char *inputdev;
	char *archivefile = 0;
	char *symtbl = RESTORESYMTABLE;
	char name[MAXPATHLEN];
	int  fflag = 0;
	struct sigaction sa, osa;
	int multiplier;
	char units;

	if ((progname = strrchr(argv[0], '/')) != NULL)
		progname++;
	else
		progname = argv[0];

	if (strcmp("hsmrestore", progname) == 0) {
		(void) fprintf(stderr,
		    gettext("hsmrestore emulation is no longer supported.\n"));
		done(1);
	}

	/*
	 * Convert the effective uid of 0 to the single privilege
	 * we really want.  When running with all privileges, this
	 * is a no-op.  When the set-uid bit is stripped restore
	 * still works for local tapes.  Fail when trying to access
	 * a remote tape in that case and not immediately.
	 */
	(void) __init_suid_priv(0, PRIV_NET_PRIVADDR, (char *)NULL);

	inputdev = DEFTAPE;

	/*
	 * This doesn't work because ufsrestore is statically linked:
	 * (void) setlocale(LC_ALL, "");
	 * The problem seems to be with LC_COLLATE, so set all the
	 * others explicitly.  Bug 1157128 was created against the I18N
	 * library.  When that bug is fixed this should go back to the way
	 * it was.
	 * XXX 1157128 was closed as a dup of 1099747.  That bug was fixed by
	 * disallowing setlocale() to anything other than "C".  "" is
	 * allowed, but only if none of the envars LC_ALL, LC_COLLATE, or LANG
	 * select anything other than "C".
	 */
	(void) setlocale(LC_CTYPE, "");
	(void) setlocale(LC_NUMERIC, "");
	(void) setlocale(LC_TIME, "");
	(void) setlocale(LC_MONETARY, "");
	(void) setlocale(LC_MESSAGES, "");
#if !defined(TEXT_DOMAIN)
#define	TEXT_DOMAIN "SYS_TEST"
#endif
	(void) textdomain(TEXT_DOMAIN);
	getwidth(&wp);
	if ((byteorder = byteorder_create()) == NULL) {
		(void) fprintf(stderr,
		    gettext("Cannot create byteorder context\n"));
		done(1);
	}

	if ((savepwd = open(".", O_RDONLY)) < 0) {
		(void) fprintf(stderr,
		    gettext("Cannot save current directory context\n"));
		done(1);
	}

	set_tmpdir();

	autoload_period = 12;
	autoload_tries = 12;	/* traditional default of ~2.5 minutes */

	sa.sa_handler = onintr;
	sa.sa_flags = SA_RESTART;
	(void) sigemptyset(&sa.sa_mask);

	(void) sigaction(SIGINT, &sa, &osa);
	if (osa.sa_handler == SIG_IGN)
		(void) sigaction(SIGINT, &osa, (struct sigaction *)0);

	(void) sigaction(SIGTERM, &sa, &osa);
	if (osa.sa_handler == SIG_IGN)
		(void) sigaction(SIGTERM, &osa, (struct sigaction *)0);
	if (argc < 2) {
usage:
		(void) fprintf(stderr, gettext("Usage:\n\
\t%s tabcdfhsvyLloT [file file ...]\n\
\t%s xabcdfhmsvyLloT [file file ...]\n\
\t%s iabcdfhmsvyLloT\n\
\t%s rabcdfsvyLloT\n\
\t%s RabcdfsvyLloT\n\n\
a requires an archive file name\n\
b requires a blocking factor\n\
f requires a dump file\n\
s requires a file number\n\
L requires a tape label\n\
If set, the envar TMPDIR selects where temporary files are kept\n"),
		    progname, progname, progname, progname, progname);
		done(1);
	}

	argv++;			/* the bag-of-options */
	argc -= 2;		/* count of parameters to the options  */
	command = '\0';
	c_label = (char *)NULL;	/* any tape's acceptable */
	for (cp = *argv++; *cp; cp++) {
		switch (*cp) {		/* BE CAUTIOUS OF FALLTHROUGHS */
		case 'T':
			if (argc < 1) {
				(void) fprintf(stderr, gettext(
				    "Missing autoload timeout period\n"));
				done(1);
			}

			count = atoi(*argv);
			if (count < 1) {
				(void) fprintf(stderr, gettext(
			    "Unreasonable autoload timeout period `%s'\n"),
					*argv);
				done(1);
			}
			units = *(*argv + strlen(*argv) - 1);
			switch (units) {
			case 's':
				multiplier = 1;
				break;
			case 'h':
				multiplier = 3600;
				break;
			case '0': case '1': case '2': case '3': case '4':
			case '5': case '6': case '7': case '8': case '9':
			case 'm':
				multiplier = 60;
				break;
			default:
				(void) fprintf(stderr, gettext(
				    "Unknown timeout units indicator `%c'\n"),
				    units);
				done(1);
			}
			autoload_tries = 1 +
			    ((count * multiplier) / autoload_period);
			argv++;
			argc--;
			break;
		case 'l':
			autoload++;
			break;
		case 'o':
			offline++;
			break;
		case '-':
			break;
		case 'a':
			if (argc < 1) {
				(void) fprintf(stderr,
					gettext("missing archive file name\n"));
				done(1);
			}
			archivefile = *argv++;
			if (*archivefile == '\0') {
				(void) fprintf(stderr,
				    gettext("empty archive file name\n"));
				done(1);
			}
			argc--;
			break;
		case 'c':
			cvtflag++;
			break;
		case 'd':
			dflag++;
			break;
		case 'D':
			/*
			 * This used to be the Dflag, but it doesn't
			 * hurt to always check, so was removed.  This
			 * case is here for backward compatability.
			 */
			break;
		case 'h':
			hflag = 0;
			break;
		case 'm':
			mflag = 0;
			break;
		case 'v':
			vflag++;
			break;
		case 'y':
			yflag++;
			break;
		case 'f':
			if (argc < 1) {
				(void) fprintf(stderr,
				    gettext("missing device specifier\n"));
				done(1);
			}
			inputdev = *argv++;
			if (*inputdev == '\0') {
				(void) fprintf(stderr,
				    gettext("empty device specifier\n"));
				done(1);
			}
			fflag++;
			argc--;
			break;
		case 'b':
			/*
			 * change default tape blocksize
			 */
			bflag++;
			if (argc < 1) {
				(void) fprintf(stderr,
					gettext("missing block size\n"));
				done(1);
			}
			saved_ntrec = ntrec = atoi(*argv++);
			if (ntrec == 0 || (ntrec&1)) {
				(void) fprintf(stderr, gettext(
			    "Block size must be a positive, even integer\n"));
				done(1);
			}
			ntrec /= (tp_bsize/DEV_BSIZE);
			argc--;
			break;
		case 's':
			/*
			 * dumpnum (skip to) for multifile dump tapes
			 */
			if (argc < 1) {
				(void) fprintf(stderr,
					gettext("missing dump number\n"));
				done(1);
			}
			dumpnum = atoi(*argv++);
			if (dumpnum <= 0) {
				(void) fprintf(stderr, gettext(
			    "Dump number must be a positive integer\n"));
				done(1);
			}
			argc--;
			break;
		case 't':
		case 'R':
		case 'r':
		case 'x':
		case 'i':
			if (command != '\0') {
				(void) fprintf(stderr, gettext(
				    "%c and %c are mutually exclusive\n"),
				    (uchar_t)*cp, (uchar_t)command);
				goto usage;
			}
			command = *cp;
			break;
		case 'L':
			if (argc < 1 || **argv == '\0') {
				(void) fprintf(stderr,
				    gettext("Missing tape label name\n"));
				done(1);
			}
			c_label = *argv++; /* must get tape with this label */
			if (strlen(c_label) > (sizeof (spcl.c_label) - 1)) {
				c_label[sizeof (spcl.c_label) - 1] = '\0';
				(void) fprintf(stderr, gettext(
		    "Truncating label to maximum supported length: `%s'\n"),
				    c_label);
			}
			argc--;
			break;

		default:
			(void) fprintf(stderr,
			    gettext("Bad key character %c\n"), (uchar_t)*cp);
			goto usage;
		}
	}
	if (command == '\0') {
		(void) fprintf(stderr,
		    gettext("must specify i, t, r, R, or x\n"));
		goto usage;
	}
	setinput(inputdev, archivefile);
	if (argc == 0) {	/* re-use last argv slot for default */
		argc = 1;
		*--argv = mflag ? "." : "2";
	}
	switch (command) {

	/*
	 * Interactive mode.
	 */
	case 'i':
		setup();
		extractdirs(1);
		initsymtable((char *)0);
		initpagercmd();
		runcmdshell();
		done(0);
		/* NOTREACHED */
	/*
	 * Incremental restoration of a file system.
	 */
	case 'r':
		setup();
		if (dumptime > 0) {
			/*
			 * This is an incremental dump tape.
			 */
			vprintf(stdout, gettext("Begin incremental restore\n"));
			initsymtable(symtbl);
			extractdirs(1);
			removeoldleaves();
			vprintf(stdout, gettext("Calculate node updates.\n"));
			strcpy(name, ".");
			name[2] = '\0';
			treescan(name, ROOTINO, nodeupdates);
			attrscan(1, nodeupdates);
			findunreflinks();
			removeoldnodes();
		} else {
			/*
			 * This is a level zero dump tape.
			 */
			vprintf(stdout, gettext("Begin level 0 restore\n"));
			initsymtable((char *)0);
			extractdirs(1);
			vprintf(stdout,
			    gettext("Calculate extraction list.\n"));
			strcpy(name, ".");
			name[2] = '\0';
			treescan(name, ROOTINO, nodeupdates);
			attrscan(1, nodeupdates);
		}
		createleaves(symtbl);
		createlinks();
		setdirmodes();
		checkrestore();
		if (dflag) {
			vprintf(stdout,
			    gettext("Verify the directory structure\n"));
			strcpy(name, ".");
			name[2] = '\0';
			treescan(name, ROOTINO, verifyfile);
		}
		dumpsymtable(symtbl, (long)1);
		done(0);
		/* NOTREACHED */
	/*
	 * Resume an incremental file system restoration.
	 */
	case 'R':
		setupR();
		initsymtable(symtbl);
		skipmaps();
		skipdirs();
		createleaves(symtbl);
		createlinks();
		setdirmodes();
		checkrestore();
		dumpsymtable(symtbl, (long)1);
		done(0);
		/* NOTREACHED */
	/*
	 * List contents of tape.
	 */
	case 't':
		setup();
		extractdirs(0);
		initsymtable((char *)0);
		if (vflag)
			printdumpinfo();
		while (argc--) {
			canon(*argv++, name, sizeof (name));
			name[strlen(name)+1] = '\0';
			ino = dirlookup(name);
			if (ino == 0)
				continue;
			treescan(name, ino, listfile);
		}
		done(0);
		/* NOTREACHED */
	/*
	 * Batch extraction of tape contents.
	 */
	case 'x':
		setup();
		extractdirs(1);
		initsymtable((char *)0);
		while (argc--) {
			if (mflag) {
				canon(*argv++, name, sizeof (name));
				if (expand(name, 0, &alist) == 0) {
					/* no meta-characters to expand */
					ino = dirlookup(name);
					if (ino == 0)
						continue;
					pathcheck(name);
				} else {
					/* add each of the expansions */
					while ((alist.last - alist.head) > 0) {
						fname = alist.head->fname;
						ino = dirlookup(fname);
						if (ino != 0) {
							pathcheck(fname);
							treescan(fname, ino,
							    addfile);
						}
						freename(fname);
						alist.head++;
					}
					alist.head = (struct afile *)NULL;
					continue; /* argc loop */
				}
			} else {
				ino = (ino_t)atol(*argv);
				if ((*(*argv++) == '-') || ino < ROOTINO) {
					(void) fprintf(stderr, gettext(
					    "bad inode number: %ld\n"),
					    ino);
					done(1);
				}
				name[0] = '\0';
			}
			treescan(name, ino, addfile);
			attrscan(0, addfile);
		}
		createfiles();
		createlinks();
		setdirmodes();
		if (dflag)
			checkrestore();
		done(0);
		/* NOTREACHED */
	}
	return (0);
}

/*
 * Determine where the user wants us to put our temporary files,
 * and make sure we can actually do so.  Bail out if there's a problem.
 */
void
set_tmpdir(void)
{
	int fd;
	char name[MAXPATHLEN];

	tmpdir = getenv("TMPDIR");
	if ((tmpdir == (char *)NULL) || (*tmpdir == '\0'))
		tmpdir = "/tmp";

	if (*tmpdir != '/') {
		(void) fprintf(stderr,
		    gettext("TMPDIR is not an absolute path (`%s').\n"),
		    tmpdir);
		done(1);
	}

	/*
	 * The actual use of tmpdir is in dirs.c, and is of the form
	 * tmpdir + "/rst" + type (three characters) + "%ld.XXXXXX" +
	 * a trailing NUL, where %ld is an arbitrary time_t.
	 *
	 * Thus, the magic 31 is strlen(itoa(MAX_TIME_T)) + "/rst" +
	 * ".XXXXXX" + '\0'.  A time_t is 64 bits, so MAX_TIME_T is
	 * LONG_MAX - nineteen digits.  In theory, so many things in
	 * ufsrestore will break once time_t's value goes beyond 32
	 * bits that it's not worth worrying about this particular
	 * instance at this time, but we've got to start somewhere.
	 *
	 * Note that the use of a pid below is just for testing the
	 * validity of the named directory.
	 */
	if (strlen(tmpdir) > (MAXPATHLEN - 31)) {
		(void) fprintf(stderr, gettext("TMPDIR too long\n"));
		done(1);
	}

	/* Guaranteed to fit by above test (sizeof(time_t) >= sizeof(pid_t)) */
	(void) snprintf(name, sizeof (name), "%s/rstdir.%ld", tmpdir, getpid());

	/*
	 * This is effectively a stripped-down version of safe_open(),
	 * because if the file exists, we want to fail.
	 */
	fd = open(name, O_CREAT|O_EXCL|O_RDWR, 0600);
	if (fd < 0) {
		perror(gettext("Can not create temporary file"));
		done(1);
	}

	(void) close(fd);
	if (unlink(name) < 0) {
		perror(gettext("Can not delete temporary file"));
		done(1);
	}
}



/* ============================================================================
 * SOURCE 94/98: minix4\exokernel\kernel_legacy\cmd\abi\spectrans\parser\main.c
 * Size: 5,772 bytes, Lines: 230
 * Hash: d92f629eed60...
 * ============================================================================ */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <libgen.h>
#include <ctype.h>
#include <limits.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <dirent.h>
#include <errno.h>
#include "parser.h"
#include "errlog.h"

#define	SPEC_PARSER_VERSION "2.1"

char **filelist;

static char *prog;

static void usage(void);

int
main(int argc, char **argv)
{
	int c, retval, size = 0;
	int lflag = 0,
	    iflag = 0,
	    aflag = 0,
	    vflag = 0;
	char *tmpptr;

	Translator_info T_info;

	prog = basename(argv[0]);

	T_info.ti_verbosity = 0;
	T_info.ti_flags = 0;
	T_info.ti_dash_I = NULL;
	T_info.ti_output_file = NULL;
	T_info.ti_libtype = NORMALLIB;
	T_info.ti_versfile = "version";

	while ((c = getopt(argc, argv, "FVpd:v:l:o:I:a:")) != EOF) {
		switch (c) {
		case 'F':
			/* Library is a filter */
			T_info.ti_libtype = FILTERLIB;
			break;
		case 'a':
			/* set the target architecture */
			if ((T_info.ti_archtoken = arch_strtoi(optarg)) == 0) {
				errlog(ERROR,
				    "Error: architecture specified must "
				    "be one of: i386, sparc, sparcv9, "
				    "ia64 or amd64\n");
				usage();
			}
			T_info.ti_arch = optarg;
			++aflag;
			break;
		case 'V':
			/* print the version info */
			(void) fprintf(stderr,
			    "%s Version %s\n", prog, SPEC_PARSER_VERSION);
			return (0);
			break;
		case 'd':
			/* set debugging level */
			if (!isdigit(*optarg) ||
			    (T_info.ti_verbosity = atoi(optarg)) < 0) {
				errlog(ERROR,
				    "Error: -d option must be given a "
				    "positive integer argument\n");
				usage();
			}
			break;
		case 'l':
			/* set library name */
			++lflag;
			if (!isalnum(optarg[0])) {
				errlog(ERROR,
				    "Error: -l must be given the name of "
				    "a library as an argument\n");
				usage();
			}
			T_info.ti_liblist = optarg;
			break;
		case 'I':
			/* set path to spec files */
			++iflag;
			if (iflag == 1) {
				size = 1;
			} else {
				(void) strcat(T_info.ti_dash_I, ":");
				size = strlen(T_info.ti_dash_I);
			}
			tmpptr = realloc(T_info.ti_dash_I,
			    sizeof (char) * (size + strlen(optarg) + 3));
			if (tmpptr == NULL) {
				errlog(ERROR | FATAL,
				    "Error: Unable to allocate memory "
				    "for command line arguments\n");
			}
			T_info.ti_dash_I = tmpptr;
			if (iflag == 1) {
				(void) strcpy(T_info.ti_dash_I, optarg);
			} else {
				(void) strcat(T_info.ti_dash_I, optarg);
			}
			break;
		case 'v':
			/* set version filename */
			if (vflag != 0) {
				errlog(ERROR, "Error: Multiple -v options "
				    "in command line\n");
				usage();
			}
			T_info.ti_versfile = optarg;
			++vflag;
			break;
		case 'o':
			/* set name of output file */
			T_info.ti_output_file = optarg;
			break;
		case 'p':
			/* set picky flag */
			T_info.ti_flags = T_info.ti_flags | XLATOR_PICKY_FLAG;
			break;
		case '?':
		default:
			usage();
		}
	}

	if (lflag == 0) {
		errlog(ERROR,
		    "Error: -l library argument must be specified\n");
		usage();
	}
	if (aflag == 0) {
		errlog(ERROR, "Error: -a i386|sparc|sparcv9|ia64|amd64 "
			"argument must be specified\n");
		usage();
	}

	if (optind < argc) {
		filelist = &argv[optind];
	} else {
		filelist = NULL;
		errlog(ERROR, "Error: Must specify at least one spec "
			"file to process\n");
		usage();
	}

	T_info.ti_nfiles = argc-optind;
	seterrseverity(T_info.ti_verbosity);

	if (T_info.ti_dash_I == NULL) {
		T_info.ti_dash_I = ".";
	} else {
		(void) strcat(T_info.ti_dash_I, ":.");
	}

	errlog(STATUS, "using %s for spec path\n", T_info.ti_dash_I);

	if ((retval = frontend(&T_info)) != 0) {
		errlog(ERROR, "%d Error(s) occurred\n", retval);
		return (1);
	}
	return (0);
}

/*
 * usage()
 * prints the usage string and exits
 */
static void
usage(void)
{
	(void) fprintf(stderr, "Usage:\n\t%s [-d n] [-V] [ -v version_file] "
	    "-a i386|sparc|sparcv9|ia64|amd64 -l lib [-I path_to_spec ] "
	    "[-o outfile ] [-p] [-F] file.spec [ ... ]\n"
	    "Command line arguments:\n"
	    "  -d n             n is an integer specifying "
	    "the level of verbosity\n"
	    "  -V               Print the Version info\n"
	    "  -a arch          Target cpu architecture. "
	    "Must be one of\n"
	    "                   i386, sparc, sparcv9, ia64 or amd64\n"
	    "  -v version_file  Name of version file\n"
	    "  -o file          Name of output file\n"
	    "                   this option can only be used when "
	    "processing single\n                   spec files.  "
	    "Using this with multiple source .spec\n"
	    "                   filenames will cause "
	    "unpredictable results\n"
	    "  -l lib           library to process\n"
	    "  -I path_to_spec  path to spec files\n"
	    "  -p               be picky with interface versioning\n"
	    "  -F               library is a filter library\n", prog);
	exit(1);
}



/* ============================================================================
 * SOURCE 95/98: minix4\exokernel\kernel_legacy\boot\i386\loader\main.c
 * Size: 10,485 bytes, Lines: 382
 * Hash: 8c677cd44dc5...
 * ============================================================================ */

/*
 * Copyright (c) 1998 Michael Smith <msmith@freebsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/cdefs.h>

/*
 * MD bootstrap main() and assorted miscellaneous
 * commands.
 */

#include <stand.h>
#include <stddef.h>
#include <string.h>
#include <machine/bootinfo.h>
#include <machine/cpufunc.h>
#include <machine/psl.h>
#include <sys/disk.h>
#include <sys/param.h>
#include <sys/reboot.h>
#include <sys/zfs_bootenv.h>
#include <rbx.h>

#include "bootstrap.h"
#include "common/bootargs.h"
#include "libi386/libi386.h"
#include "smbios.h"
#include "btxv86.h"
#include "libzfs.h"

CTASSERT(sizeof (struct bootargs) == BOOTARGS_SIZE);
CTASSERT(offsetof(struct bootargs, bootinfo) == BA_BOOTINFO);
CTASSERT(offsetof(struct bootargs, bootflags) == BA_BOOTFLAGS);
CTASSERT(offsetof(struct bootinfo, bi_size) == BI_SIZE);

/* Arguments passed in from the boot1/boot2 loader */
struct bootargs *kargs;

uint32_t	opts;
static uint32_t	initial_bootdev;
static struct bootinfo	*initial_bootinfo;

struct arch_switch	archsw;		/* MI/MD interface boundary */

static void		extract_currdev(void);
static int		isa_inb(int port);
static void		isa_outb(int port, int value);
void			exit(int code);
static void		i386_zfs_probe(void);

/* XXX debugging */
extern char _end[];

static void *heap_top;
static void *heap_bottom;

caddr_t
ptov(uintptr_t x)
{
	return (PTOV(x));
}

int
main(void)
{
	int	i;

	/* Pick up arguments */
	kargs = (void *)__args;
	opts = kargs->howto;
	initial_bootdev = kargs->bootdev;
	initial_bootinfo = kargs->bootinfo ?
	    (struct bootinfo *)PTOV(kargs->bootinfo) : NULL;

	/* Initialize the v86 register set to a known-good state. */
	bzero(&v86, sizeof (v86));
	v86.efl = PSL_RESERVED_DEFAULT | PSL_I;

	/*
	 * Initialise the heap as early as possible.
	 * Once this is done, malloc() is usable.
	 */
	bios_getmem();

	if (high_heap_size > 0) {
		heap_top = PTOV(high_heap_base + high_heap_size);
		heap_bottom = PTOV(high_heap_base);
		if (high_heap_base < memtop_copyin)
			memtop_copyin = high_heap_base;
	} else {
		heap_top = (void *)PTOV(bios_basemem);
		heap_bottom = (void *)_end;
	}
	setheap(heap_bottom, heap_top);

	/* detect ACPI for future reference */
	biosacpi_detect();

	/*
	 * XXX Chicken-and-egg problem; we want to have console output early,
	 * but some console attributes may depend on reading from eg. the boot
	 * device, which we can't do yet.
	 *
	 * We can use printf() etc. once this is done.
	 * If the previous boot stage has requested a serial console,
	 * prefer that.
	 */
	bi_setboothowto(opts);
	if (OPT_CHECK(RBX_DUAL)) {
		if (OPT_CHECK(RBX_SERIAL))
			setenv("console", "ttya text", 1);
		else
			setenv("console", "text ttya", 1);
	} else if (OPT_CHECK(RBX_SERIAL)) {
		setenv("console", "ttya", 1);
	} else if (OPT_CHECK(RBX_MUTE)) {
		setenv("console", "null", 1);
	}
	cons_probe();

	/*
	 * Initialise the block cache. Set the upper limit.
	 */
	bcache_init(32768, 512);

	/*
	 * Special handling for PXE and CD booting.
	 */
	if (kargs->bootinfo == 0) {
		/*
		 * We only want the PXE disk to try to init itself in the below
		 * walk through devsw if we actually booted off of PXE.
		 */
		if (kargs->bootflags & KARGS_FLAGS_PXE)
			pxe_enable(kargs->pxeinfo ?
			    PTOV(kargs->pxeinfo) : NULL);
		else if (kargs->bootflags & KARGS_FLAGS_CD)
			bc_add(initial_bootdev);
	}

	archsw.arch_autoload = i386_autoload;
	archsw.arch_getdev = i386_getdev;
	archsw.arch_copyin = i386_copyin;
	archsw.arch_copyout = i386_copyout;
	archsw.arch_readin = i386_readin;
	archsw.arch_isainb = isa_inb;
	archsw.arch_isaoutb = isa_outb;
	archsw.arch_loadaddr = i386_loadaddr;
	archsw.arch_hypervisor = x86_hypervisor;
	archsw.arch_zfs_probe = i386_zfs_probe;

	/*
	 * March through the device switch probing for things.
	 */
	for (i = 0; devsw[i] != NULL; i++)
		if (devsw[i]->dv_init != NULL)
			(devsw[i]->dv_init)();

	printf("BIOS %dkB/%dkB available memory\n", bios_basemem / 1024,
	    bios_extmem / 1024);
	if (initial_bootinfo != NULL) {
		initial_bootinfo->bi_basemem = bios_basemem / 1024;
		initial_bootinfo->bi_extmem = bios_extmem / 1024;
	}

	/* detect SMBIOS for future reference */
	smbios_detect(NULL);

	/* detect PCI BIOS for future reference */
	biospci_detect();

	printf("\n%s", bootprog_info);

	extract_currdev();		/* set $currdev and $loaddev */
	autoload_font(OPT_CHECK(RBX_TEXT_MODE) != 0);

	bi_isadir();
	bios_getsmap();

	interact(NULL);

	/* if we ever get here, it is an error */
	return (1);
}

/*
 * Set the 'current device' by (if possible) recovering the boot device as
 * supplied by the initial bootstrap.
 *
 * XXX should be extended for netbooting.
 */
static void
extract_currdev(void)
{
	struct i386_devdesc	new_currdev;
	struct zfs_boot_args	*zargs;
	char			*bootonce;
	int			biosdev = -1;

	/* Assume we are booting from a BIOS disk by default */
	new_currdev.dd.d_dev = &bioshd;

	/* new-style boot loaders such as pxeldr and cdldr */
	if (kargs->bootinfo == 0) {
		if ((kargs->bootflags & KARGS_FLAGS_CD) != 0) {
			/* we are booting from a CD with cdboot */
			new_currdev.dd.d_dev = &bioscd;
			new_currdev.dd.d_unit = bd_bios2unit(initial_bootdev);
		} else if ((kargs->bootflags & KARGS_FLAGS_PXE) != 0) {
			/* we are booting from pxeldr */
			new_currdev.dd.d_dev = &pxedisk;
			new_currdev.dd.d_unit = 0;
		} else {
			/* we don't know what our boot device is */
			new_currdev.d_kind.biosdisk.slice = -1;
			new_currdev.d_kind.biosdisk.partition = 0;
			biosdev = -1;
		}
	} else if ((kargs->bootflags & KARGS_FLAGS_ZFS) != 0) {
		zargs = NULL;
		/* check for new style extended argument */
		if ((kargs->bootflags & KARGS_FLAGS_EXTARG) != 0)
			zargs = (struct zfs_boot_args *)(kargs + 1);

		if (zargs != NULL &&
		    zargs->size >=
		    offsetof(struct zfs_boot_args, primary_pool)) {
			/* sufficient data is provided */
			new_currdev.d_kind.zfs.pool_guid = zargs->pool;
			new_currdev.d_kind.zfs.root_guid = zargs->root;
		} else {
			/* old style zfsboot block */
			new_currdev.d_kind.zfs.pool_guid = kargs->zfspool;
			new_currdev.d_kind.zfs.root_guid = 0;
		}
		new_currdev.dd.d_dev = &zfs_dev;
		if ((bootonce = malloc(VDEV_PAD_SIZE)) != NULL) {
			if (zfs_get_bootonce(&new_currdev, OS_BOOTONCE_USED,
			    bootonce, VDEV_PAD_SIZE) == 0) {
				setenv("zfs-bootonce", bootonce, 1);
			}
			free(bootonce);
			(void) zfs_attach_nvstore(&new_currdev);
		} else {
			printf("Failed to process bootonce data: %s\n",
			    strerror(errno));
		}
	} else if ((initial_bootdev & B_MAGICMASK) != B_DEVMAGIC) {
		/* The passed-in boot device is bad */
		new_currdev.d_kind.biosdisk.slice = -1;
		new_currdev.d_kind.biosdisk.partition = 0;
		biosdev = -1;
	} else {
		new_currdev.d_kind.biosdisk.slice =
		    B_SLICE(initial_bootdev) - 1;
		new_currdev.d_kind.biosdisk.partition =
		    B_PARTITION(initial_bootdev);
		biosdev = initial_bootinfo->bi_bios_dev;

		/*
		 * If we are booted by an old bootstrap, we have to guess at
		 * the BIOS unit number. We will lose if there is more than
		 * one disk type and we are not booting from the
		 * lowest-numbered disk type (ie. SCSI when IDE also exists).
		 */
		if ((biosdev == 0) && (B_TYPE(initial_bootdev) != 2)) {
			/*
			 * biosdev doesn't match major, assume harddisk
			 */
			biosdev = 0x80 + B_UNIT(initial_bootdev);
		}
	}

	/*
	 * If we are booting off of a BIOS disk and we didn't succeed
	 * in determining which one we booted off of, just use disk0:
	 * as a reasonable default.
	 */
	if ((new_currdev.dd.d_dev->dv_type == bioshd.dv_type) &&
	    ((new_currdev.dd.d_unit = bd_bios2unit(biosdev)) == -1)) {
		printf("Can't work out which disk we are booting "
		    "from.\nGuessed BIOS device 0x%x not found by "
		    "probes, defaulting to disk0:\n", biosdev);
		new_currdev.dd.d_unit = 0;
	}

	env_setenv("currdev", EV_VOLATILE, i386_fmtdev(&new_currdev),
	    i386_setcurrdev, env_nounset);
	env_setenv("loaddev", EV_VOLATILE, i386_fmtdev(&new_currdev),
	    env_noset, env_nounset);
}

COMMAND_SET(reboot, "reboot", "reboot the system", command_reboot);

static int
command_reboot(int argc __unused, char *argv[] __unused)
{
	int i;

	for (i = 0; devsw[i] != NULL; ++i)
		if (devsw[i]->dv_cleanup != NULL)
			(devsw[i]->dv_cleanup)();

	printf("Rebooting...\n");
	delay(1000000);
	__exit(0);
}

/* provide this for panic, as it's not in the startup code */
void
exit(int code)
{
	__exit(code);
}

COMMAND_SET(heap, "heap", "show heap usage", command_heap);

static int
command_heap(int argc __unused, char *argv[] __unused)
{

	mallocstats();
	printf("heap base at %p, top at %p, upper limit at %p\n", heap_bottom,
	    sbrk(0), heap_top);
	return (CMD_OK);
}

/* ISA bus access functions for PnP. */
static int
isa_inb(int port)
{

	return (inb(port));
}

static void
isa_outb(int port, int value)
{

	outb(port, value);
}

static void
i386_zfs_probe(void)
{
	char devname[32];
	struct i386_devdesc dev;

	/*
	 * Open all the disks we can find and see if we can reconstruct
	 * ZFS pools from them.
	 */
	dev.dd.d_dev = &bioshd;
	for (dev.dd.d_unit = 0; bd_unit2bios(&dev) >= 0; dev.dd.d_unit++) {
		snprintf(devname, sizeof (devname), "%s%d:", bioshd.dv_name,
		    dev.dd.d_unit);
		zfs_probe_dev(devname, NULL);
	}
}



/* ============================================================================
 * SOURCE 96/98: minix4\exokernel\kernel_legacy\boot\efi\loader\main.c
 * Size: 35,707 bytes, Lines: 1,433
 * Hash: a0f34d33d2fc...
 * ============================================================================ */

/*
 * Copyright (c) 2008-2010 Rui Paulo
 * Copyright (c) 2006 Marcel Moolenaar
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/cdefs.h>

#include <sys/disk.h>
#include <sys/param.h>
#include <sys/reboot.h>
#include <sys/boot.h>
#include <sys/consplat.h>
#include <sys/zfs_bootenv.h>
#include <stand.h>
#include <inttypes.h>
#include <string.h>
#include <setjmp.h>
#include <disk.h>

#include <efi.h>
#include <efilib.h>
#include <efichar.h>
#include <eficonsctl.h>
#include <efidevp.h>
#include <Guid/SmBios.h>
#include <Protocol/DevicePath.h>
#include <Protocol/LoadedImage.h>
#include <Protocol/SerialIo.h>
#include <Protocol/SimpleTextIn.h>
#include <Uefi/UefiGpt.h>

#include <uuid.h>

#include <bootstrap.h>
#include <gfx_fb.h>
#include <smbios.h>

#include <libzfs.h>
#include <efizfs.h>

#include "loader_efi.h"

struct arch_switch archsw;	/* MI/MD interface boundary */

EFI_GUID gEfiLoadedImageProtocolGuid = EFI_LOADED_IMAGE_PROTOCOL_GUID;
EFI_GUID gEfiSmbiosTableGuid = SMBIOS_TABLE_GUID;
EFI_GUID gEfiSmbios3TableGuid = SMBIOS3_TABLE_GUID;

extern void acpi_detect(void);
extern void efi_getsmap(void);

static EFI_LOADED_IMAGE_PROTOCOL *img;

/*
 * Number of seconds to wait for a keystroke before exiting with failure
 * in the event no currdev is found. -2 means always break, -1 means
 * never break, 0 means poll once and then reboot, > 0 means wait for
 * that many seconds. "fail_timeout" can be set in the environment as
 * well.
 */
static int fail_timeout = 5;

bool
efi_zfs_is_preferred(EFI_HANDLE *h)
{
	EFI_DEVICE_PATH *devpath, *dp, *node;
	HARDDRIVE_DEVICE_PATH *hd;
	bool ret;
	extern UINT64 start_sector;	/* from mb_header.S */

	/* This check is true for chainloader case. */
	if (h == img->DeviceHandle)
		return (true);

	/*
	 * Make sure the image was loaded from the hard disk.
	 */
	devpath = efi_lookup_devpath(img->DeviceHandle);
	if (devpath == NULL)
		return (false);
	node = efi_devpath_last_node(devpath);
	if (node == NULL)
		return (false);
	if (DevicePathType(node) != MEDIA_DEVICE_PATH ||
	    (DevicePathSubType(node) != MEDIA_FILEPATH_DP &&
	    DevicePathSubType(node) != MEDIA_HARDDRIVE_DP)) {
		return (false);
	}

	/*
	 * XXX We ignore the MEDIA_FILEPATH_DP here for now as it is
	 * used on arm and we do not support arm.
	 */
	ret = false;
	dp = efi_devpath_trim(devpath);
	devpath = NULL;
	if (dp == NULL)
		goto done;

	devpath = efi_lookup_devpath(h);
	if (devpath == NULL)
		goto done;
	hd = (HARDDRIVE_DEVICE_PATH *)efi_devpath_last_node(devpath);
	if (hd == NULL) {
		devpath = NULL;
		goto done;
	}
	devpath = efi_devpath_trim(devpath);
	if (devpath == NULL)
		goto done;

	if (!efi_devpath_match(dp, devpath))
		goto done;

	/* It is the same disk, do we have partition start? */
	if (start_sector == 0)
		ret = true;
	else if (start_sector == hd->PartitionStart)
		ret = true;

done:
	free(dp);
	free(devpath);
	return (ret);
}

static bool
has_keyboard(void)
{
	EFI_STATUS status;
	EFI_DEVICE_PATH *path;
	EFI_HANDLE *hin;
	uint_t i, nhandles;
	bool retval = false;

	/*
	 * Find all the handles that support the SIMPLE_TEXT_INPUT_PROTOCOL and
	 * do the typical dance to get the right sized buffer.
	 */
	status = efi_get_protocol_handles(&gEfiSimpleTextInProtocolGuid,
	    &nhandles, &hin);
	if (EFI_ERROR(status))
		return (retval);

	/*
	 * Look at each of the handles. If it supports the device path protocol,
	 * use it to get the device path for this handle. Then see if that
	 * device path matches either the USB device path for keyboards or the
	 * legacy device path for keyboards.
	 */
	for (i = 0; i < nhandles; i++) {
		status = OpenProtocolByHandle(hin[i],
		    &gEfiDevicePathProtocolGuid, (void **)&path);
		if (EFI_ERROR(status))
			continue;

		while (!IsDevicePathEnd(path)) {
			/*
			 * Check for the ACPI keyboard node. All PNP3xx nodes
			 * are keyboards of different flavors. Note: It is
			 * unclear of there's always a keyboard node when
			 * there's a keyboard controller, or if there's only one
			 * when a keyboard is detected at boot.
			 */
			if (DevicePathType(path) == ACPI_DEVICE_PATH &&
			    (DevicePathSubType(path) == ACPI_DP ||
			    DevicePathSubType(path) == ACPI_EXTENDED_DP)) {
				ACPI_HID_DEVICE_PATH  *acpi;

				acpi = (ACPI_HID_DEVICE_PATH *)(void *)path;
				if ((EISA_ID_TO_NUM(acpi->HID) & 0xff00) ==
				    0x300 &&
				    (acpi->HID & 0xffff) == PNP_EISA_ID_CONST) {
					retval = true;
					goto out;
				}
			/*
			 * Check for USB keyboard node, if present. Unlike a
			 * PS/2 keyboard, these definitely only appear when
			 * connected to the system.
			 */
			} else if (DevicePathType(path) ==
			    MESSAGING_DEVICE_PATH &&
			    DevicePathSubType(path) == MSG_USB_CLASS_DP) {
				USB_CLASS_DEVICE_PATH *usb;

				/*
				 * Check for:
				 * DeviceClass: HID
				 * DeviceSubClass: Boot devices
				 * DeviceProtocol: Boot keyboards
				 */
				usb = (USB_CLASS_DEVICE_PATH *)(void *)path;
				if (usb->DeviceClass == 3 &&
				    usb->DeviceSubClass == 1 &&
				    usb->DeviceProtocol == 1) {
					retval = true;
					goto out;
				}
			}
			path = NextDevicePathNode(path);
		}
	}
out:
	free(hin);
	return (retval);
}

static void
set_currdev(const char *devname)
{

	/*
	 * Don't execute hooks here; we may need to try setting these more than
	 * once here if we're probing for the ZFS pool we're supposed to boot.
	 * The currdev hook is intended to just validate user input anyways,
	 * while the loaddev hook makes it immutable once we've determined what
	 * the proper currdev is.
	 */
	env_setenv("currdev", EV_VOLATILE | EV_NOHOOK, devname, efi_setcurrdev,
	    env_nounset);
	env_setenv("loaddev", EV_VOLATILE | EV_NOHOOK, devname, env_noset,
	    env_nounset);
}

static void
set_currdev_devdesc(struct devdesc *currdev)
{
	char *devname;

	devname = efi_fmtdev(currdev);

	printf("Setting currdev to %s\n", devname);
	set_currdev(devname);
}

static void
set_currdev_devsw(struct devsw *dev, int unit)
{
	struct devdesc currdev;

	currdev.d_dev = dev;
	currdev.d_unit = unit;

	set_currdev_devdesc(&currdev);
}

static void
set_currdev_pdinfo(pdinfo_t *dp)
{

	/*
	 * Disks are special: they have partitions. if the parent
	 * pointer is non-null, we're a partition not a full disk
	 * and we need to adjust currdev appropriately.
	 */
	if (dp->pd_devsw->dv_type == DEVT_DISK) {
		struct disk_devdesc currdev;

		currdev.dd.d_dev = dp->pd_devsw;
		if (dp->pd_parent == NULL) {
			currdev.dd.d_unit = dp->pd_unit;
			currdev.d_slice = D_SLICENONE;
			currdev.d_partition = D_PARTNONE;
		} else {
			currdev.dd.d_unit = dp->pd_parent->pd_unit;
			currdev.d_slice = dp->pd_unit;
			currdev.d_partition = D_PARTISGPT; /* Assumes GPT */
		}
		set_currdev_devdesc((struct devdesc *)&currdev);
	} else {
		set_currdev_devsw(dp->pd_devsw, dp->pd_unit);
	}
}

static bool
sanity_check_currdev(void)
{
	struct stat st;

	return (stat("/boot/defaults/loader.conf", &st) == 0);
}

static bool
probe_zfs_currdev(uint64_t guid)
{
	struct zfs_devdesc currdev;
	char *bootonce;
	bool rv;

	currdev.dd.d_dev = &zfs_dev;
	currdev.dd.d_unit = 0;
	currdev.pool_guid = guid;
	currdev.root_guid = 0;
	set_currdev_devdesc((struct devdesc *)&currdev);

	rv = sanity_check_currdev();
	if (rv) {
		bootonce = malloc(VDEV_PAD_SIZE);
		if (bootonce != NULL) {
			if (zfs_get_bootonce(&currdev, OS_BOOTONCE, bootonce,
			    VDEV_PAD_SIZE) == 0) {
				printf("zfs bootonce: %s\n", bootonce);
				set_currdev(bootonce);
				setenv("zfs-bootonce", bootonce, 1);
			}
			free(bootonce);
			(void) zfs_attach_nvstore(&currdev);
		} else {
			printf("Failed to process bootonce data: %s\n",
			    strerror(errno));
		}
	}
	return (rv);
}

static bool
try_as_currdev(pdinfo_t *pp)
{
	uint64_t guid;

	/*
	 * If there's a zpool on this device, try it as a ZFS
	 * filesystem, which has somewhat different setup than all
	 * other types of fs due to imperfect loader integration.
	 * This all stems from ZFS being both a device (zpool) and
	 * a filesystem, plus the boot env feature.
	 */
	if (efizfs_get_guid_by_handle(pp->pd_handle, &guid))
		return (probe_zfs_currdev(guid));

	/*
	 * All other filesystems just need the pdinfo
	 * initialized in the standard way.
	 */
	set_currdev_pdinfo(pp);
	return (sanity_check_currdev());
}

static bool
find_currdev(EFI_LOADED_IMAGE_PROTOCOL *img)
{
	pdinfo_t *dp, *pp;
	EFI_DEVICE_PATH *devpath, *copy;
	EFI_HANDLE h;
	CHAR16 *text;
	struct devsw *dev;
	int unit;
	uint64_t extra;

	/*
	 * Did efi_zfs_probe() detect the boot pool? If so, use the zpool
	 * it found, if it's sane. ZFS is the only thing that looks for
	 * disks and pools to boot.
	 */
	if (pool_guid != 0) {
		printf("Trying ZFS pool\n");
		if (probe_zfs_currdev(pool_guid))
			return (true);
	}

	/*
	 * Try to find the block device by its handle based on the
	 * image we're booting. If we can't find a sane partition,
	 * search all the other partitions of the disk. We do not
	 * search other disks because it's a violation of the UEFI
	 * boot protocol to do so. We fail and let UEFI go on to
	 * the next candidate.
	 */
	dp = efiblk_get_pdinfo_by_handle(img->DeviceHandle);
	if (dp != NULL) {
		text = efi_devpath_name(dp->pd_devpath);
		if (text != NULL) {
			printf("Trying ESP: %S\n", text);
			efi_free_devpath_name(text);
		}
		set_currdev_pdinfo(dp);
		if (sanity_check_currdev())
			return (true);
		if (dp->pd_parent != NULL) {
			dp = dp->pd_parent;
			STAILQ_FOREACH(pp, &dp->pd_part, pd_link) {
				text = efi_devpath_name(pp->pd_devpath);
				if (text != NULL) {
					printf("And now the part: %S\n", text);
					efi_free_devpath_name(text);
				}
				/*
				 * Roll up the ZFS special case
				 * for those partitions that have
				 * zpools on them
				 */
				if (try_as_currdev(pp))
					return (true);
			}
		}
	} else {
		printf("Can't find device by handle\n");
	}

	/*
	 * Try the device handle from our loaded image first.  If that
	 * fails, use the device path from the loaded image and see if
	 * any of the nodes in that path match one of the enumerated
	 * handles. Currently, this handle list is only for netboot.
	 */
	if (efi_handle_lookup(img->DeviceHandle, &dev, &unit, &extra) == 0) {
		set_currdev_devsw(dev, unit);
		if (sanity_check_currdev())
			return (true);
	}

	copy = NULL;
	devpath = efi_lookup_image_devpath(IH);
	while (devpath != NULL) {
		h = efi_devpath_handle(devpath);
		if (h == NULL)
			break;

		free(copy);
		copy = NULL;

		if (efi_handle_lookup(h, &dev, &unit, &extra) == 0) {
			set_currdev_devsw(dev, unit);
			if (sanity_check_currdev())
				return (true);
		}

		devpath = efi_lookup_devpath(h);
		if (devpath != NULL) {
			copy = efi_devpath_trim(devpath);
			devpath = copy;
		}
	}
	free(copy);

	return (false);
}

static bool
interactive_interrupt(const char *msg)
{
	time_t now, then, last;

	last = 0;
	now = then = getsecs();
	printf("%s\n", msg);
	if (fail_timeout == -2)			/* Always break to OK */
		return (true);
	if (fail_timeout == -1)			/* Never break to OK */
		return (false);
	do {
		if (last != now) {
			printf("press any key to interrupt reboot "
			    "in %d seconds\r",
			    fail_timeout - (int)(now - then));
			last = now;
		}

		/* XXX no pause or timeout wait for char */
		if (ischar())
			return (true);
		now = getsecs();
	} while (now - then < fail_timeout);
	return (false);
}

static void
setenv_int(const char *key, int val)
{
	char buf[20];

	(void) snprintf(buf, sizeof (buf), "%d", val);
	(void) setenv(key, buf, 1);
}

/*
 * Parse ConOut (the list of consoles active) and see if we can find a
 * serial port and/or a video port. It would be nice to also walk the
 * ACPI name space to map the UID for the serial port to a port. The
 * latter is especially hard.
 */
static int
parse_uefi_con_out(void)
{
	int how, rv;
	int vid_seen = 0, com_seen = 0, seen = 0;
	size_t sz;
	char buf[4096], *ep;
	EFI_DEVICE_PATH *node;
	ACPI_HID_DEVICE_PATH *acpi;
	UART_DEVICE_PATH *uart;
	bool pci_pending = false;

	how = 0;
	sz = sizeof (buf);
	rv = efi_global_getenv("ConOut", buf, &sz);
	if (rv != EFI_SUCCESS)
		rv = efi_global_getenv("ConOutDev", buf, &sz);
	if (rv != EFI_SUCCESS) {
		/*
		 * If we don't have any ConOut default to video.
		 * non-server systems may not have serial.
		 */
		goto out;
	}
	ep = buf + sz;
	node = (EFI_DEVICE_PATH *)buf;
	while ((char *)node < ep) {
		if (IsDevicePathEndType(node)) {
			if (pci_pending && vid_seen == 0)
				vid_seen = ++seen;
		}
		pci_pending = false;
		if (DevicePathType(node) == ACPI_DEVICE_PATH &&
		    (DevicePathSubType(node) == ACPI_DP ||
		    DevicePathSubType(node) == ACPI_EXTENDED_DP)) {
			/* Check for Serial node */
			acpi = (void *)node;
			if (EISA_ID_TO_NUM(acpi->HID) == 0x501) {
				setenv_int("efi_8250_uid", acpi->UID);
				com_seen = ++seen;
			}
		} else if (DevicePathType(node) == MESSAGING_DEVICE_PATH &&
		    DevicePathSubType(node) == MSG_UART_DP) {
			com_seen = ++seen;
			uart = (void *)node;
			setenv_int("efi_com_speed", uart->BaudRate);
		} else if (DevicePathType(node) == ACPI_DEVICE_PATH &&
		    DevicePathSubType(node) == ACPI_ADR_DP) {
			/* Check for AcpiAdr() Node for video */
			vid_seen = ++seen;
		} else if (DevicePathType(node) == HARDWARE_DEVICE_PATH &&
		    DevicePathSubType(node) == HW_PCI_DP) {
			/*
			 * Note, vmware fusion has a funky console device
			 *	PciRoot(0x0)/Pci(0xf,0x0)
			 * which we can only detect at the end since we also
			 * have to cope with:
			 *	PciRoot(0x0)/Pci(0x1f,0x0)/Serial(0x1)
			 * so only match it if it's last.
			 */
			pci_pending = true;
		}
		node = NextDevicePathNode(node); /* Skip the end node */
	}

	/*
	 * Truth table for RB_MULTIPLE | RB_SERIAL
	 * Value		Result
	 * 0			Use only video console
	 * RB_SERIAL		Use only serial console
	 * RB_MULTIPLE		Use both video and serial console
	 *			(but video is primary so gets rc messages)
	 * both			Use both video and serial console
	 *			(but serial is primary so gets rc messages)
	 *
	 * Try to honor this as best we can. If only one of serial / video
	 * found, then use that. Otherwise, use the first one we found.
	 * This also implies if we found nothing, default to video.
	 */
	how = 0;
	if (vid_seen && com_seen) {
		how |= RB_MULTIPLE;
		if (com_seen < vid_seen)
			how |= RB_SERIAL;
	} else if (com_seen)
		how |= RB_SERIAL;
out:
	return (how);
}

caddr_t
ptov(uintptr_t x)
{
	return ((caddr_t)x);
}

static int
efi_serial_get_uid(EFI_DEVICE_PATH *devpath)
{
	ACPI_HID_DEVICE_PATH  *acpi;

	while (!IsDevicePathEnd(devpath)) {
		if (DevicePathType(devpath) == ACPI_DEVICE_PATH &&
		    (DevicePathSubType(devpath) == ACPI_DP ||
		    DevicePathSubType(devpath) == ACPI_EXTENDED_DP)) {
			acpi = (ACPI_HID_DEVICE_PATH *)devpath;
			if (EISA_ID_TO_NUM(acpi->HID) == 0x501) {
				return (acpi->UID);
			}
		}

		devpath = NextDevicePathNode(devpath);
	}
	return (-1);
}

/*
 * Walk serialio protocol handle array and find index for serial console
 * device. The problem is, we check for acpi UID value, but we can not be sure,
 * if it will start from 0 or 1.
 */
static const char *
uefi_serial_console(void)
{
	EFI_STATUS status;
	EFI_HANDLE *handles;
	uint_t i, nhandles;
	unsigned long uid, lowest;
	char *env, *ep;

	env = getenv("efi_8250_uid");
	if (env == NULL)
		return (NULL);
	(void) unsetenv("efi_8250_uid");
	errno = 0;
	uid = strtoul(env, &ep, 10);
	if (errno != 0 || *ep != '\0')
		return (NULL);

	/* if uid is 0, this is first serial port */
	if (uid == 0)
		return ("ttya");

	status = efi_get_protocol_handles(&gEfiSerialIoProtocolGuid,
	    &nhandles, &handles);
	if (EFI_ERROR(status)) {
		return (NULL);
	}

	lowest = 255;	/* high enough value */
	for (i = 0; i < nhandles; i++) {
		EFI_DEVICE_PATH *devpath;
		unsigned long _uid;

		devpath = efi_lookup_devpath(handles[i]);
		_uid = efi_serial_get_uid(devpath);
		if (_uid < lowest)
			lowest = _uid;
	}
	free(handles);
	switch (uid - lowest) {
	case 0:
		return ("ttya");
	case 1:
		return ("ttyb");
	case 2:
		return ("ttyc");
	case 3:
		return ("ttyd");
	}
	return (NULL);
}

EFI_STATUS
main(int argc, CHAR16 *argv[])
{
	char var[128];
	int i, j, howto;
	bool vargood;
	void *ptr;
	bool has_kbd;
	char *s;
	const char *serial;
	EFI_DEVICE_PATH *imgpath;
	CHAR16 *text;
	EFI_STATUS status;
	UINT16 boot_current;
	size_t sz;
	UINT16 boot_order[100];

	archsw.arch_autoload = efi_autoload;
	archsw.arch_getdev = efi_getdev;
	archsw.arch_copyin = efi_copyin;
	archsw.arch_copyout = efi_copyout;
	archsw.arch_readin = efi_readin;
	archsw.arch_loadaddr = efi_loadaddr;
	archsw.arch_free_loadaddr = efi_free_loadaddr;
#if defined(__amd64) || defined(__i386)
	archsw.arch_hypervisor = x86_hypervisor;
#endif
	/* Note this needs to be set before ZFS init. */
	archsw.arch_zfs_probe = efi_zfs_probe;

	/* Get our loaded image protocol interface structure. */
	(void) OpenProtocolByHandle(IH, &gEfiLoadedImageProtocolGuid,
	    (void **)&img);

	/*
	 * XXX Chicken-and-egg problem; we want to have console output
	 * early, but some console attributes may depend on reading from
	 * eg. the boot device, which we can't do yet.  We can use
	 * printf() etc. once this is done.
	 */
	setenv("console", "text", 1);
	howto = parse_uefi_con_out();
	serial = uefi_serial_console();
	cons_probe();
	efi_getsmap();

	if ((s = getenv("efi_com_speed")) != NULL) {
		char *name;

		(void) snprintf(var, sizeof (var), "%s,8,n,1,-", s);
		if (asprintf(&name, "%s-mode", serial) > 0) {
			(void) setenv(name, var, 1);
			free(name);
		}
		if (asprintf(&name, "%s-spcr-mode", serial) > 0) {
			(void) setenv(name, var, 1);
			free(name);
		}
		(void) unsetenv("efi_com_speed");
	}

	/* Init the time source */
	efi_time_init();

	/*
	 * Initialise the block cache. Set the upper limit.
	 */
	bcache_init(32768, 512);

	has_kbd = has_keyboard();

	/*
	 * Parse the args to set the console settings, etc
	 * iPXE may be setup to pass these in. Or the optional argument in the
	 * boot environment was used to pass these arguments in (in which case
	 * neither /boot.config nor /boot/config are consulted).
	 *
	 * Loop through the args, and for each one that contains an '=' that is
	 * not the first character, add it to the environment.  This allows
	 * loader and kernel env vars to be passed on the command line.  Convert
	 * args from UCS-2 to ASCII (16 to 8 bit) as they are copied (though
	 * this method is flawed for non-ASCII characters).
	 */
	for (i = 1; i < argc; i++) {
		if (argv[i][0] == '-') {
			for (j = 1; argv[i][j] != 0; j++) {
				int ch;

				ch = argv[i][j];
				switch (ch) {
				case 'a':
					howto |= RB_ASKNAME;
					break;
				case 'd':
					howto |= RB_KDB;
					break;
				case 'D':
					howto |= RB_MULTIPLE;
					break;
				case 'h':
					howto |= RB_SERIAL;
					break;
				case 'm':
					howto |= RB_MUTE;
					break;
				case 'p':
					howto |= RB_PAUSE;
					break;
				case 'P':
					if (!has_kbd) {
						howto |= RB_SERIAL;
						howto |= RB_MULTIPLE;
					}
					break;
				case 'r':
					howto |= RB_DFLTROOT;
					break;
				case 's':
					howto |= RB_SINGLE;
					break;
				case 'S':
					if (argv[i][j + 1] == 0) {
						if (i + 1 == argc) {
							strncpy(var, "115200",
							    sizeof (var));
						} else {
							CHAR16 *ptr;
							ptr = &argv[i + 1][0];
							cpy16to8(ptr, var,
							    sizeof (var));
						}
						i++;
					} else {
						cpy16to8(&argv[i][j + 1], var,
						    sizeof (var));
					}
					strncat(var, ",8,n,1,-", sizeof (var));
					setenv("ttya-mode", var, 1);
					break;
				case 'v':
					howto |= RB_VERBOSE;
					break;
				}
			}
		} else {
			vargood = false;
			for (j = 0; argv[i][j] != 0; j++) {
				if (j == sizeof (var)) {
					vargood = false;
					break;
				}
				if (j > 0 && argv[i][j] == '=')
					vargood = true;
				var[j] = (char)argv[i][j];
			}
			if (vargood) {
				var[j] = 0;
				putenv(var);
			}
		}
	}
	for (i = 0; howto_names[i].ev != NULL; i++)
		if (howto & howto_names[i].mask)
			setenv(howto_names[i].ev, "YES", 1);

	/*
	 * XXX we need fallback to this stuff after looking at the ConIn,
	 * ConOut and ConErr variables.
	 */
	if (howto & RB_MULTIPLE) {
		if (howto & RB_SERIAL)
			(void) snprintf(var, sizeof (var), "%s text", serial);
		else
			(void) snprintf(var, sizeof (var), "text %s", serial);
	} else if (howto & RB_SERIAL) {
		(void) snprintf(var, sizeof (var), "%s", serial);
	} else {
		(void) snprintf(var, sizeof (var), "text");
	}
	(void) setenv("console", var, 1);

	if ((s = getenv("fail_timeout")) != NULL)
		fail_timeout = strtol(s, NULL, 10);

	/*
	 * Scan the BLOCK IO MEDIA handles then
	 * march through the device switch probing for things.
	 */
	if ((i = efipart_inithandles()) == 0) {
		for (i = 0; devsw[i] != NULL; i++)
			if (devsw[i]->dv_init != NULL)
				(devsw[i]->dv_init)();
	} else
		printf("efipart_inithandles failed %d, expect failures", i);

	printf("Command line arguments:");
	for (i = 0; i < argc; i++) {
		printf(" %S", argv[i]);
	}
	printf("\n");

	printf("Image base: 0x%lx\n", (unsigned long)img->ImageBase);
	printf("EFI version: %d.%02d\n", ST->Hdr.Revision >> 16,
	    ST->Hdr.Revision & 0xffff);
	printf("EFI Firmware: %S (rev %d.%02d)\n", ST->FirmwareVendor,
	    ST->FirmwareRevision >> 16, ST->FirmwareRevision & 0xffff);

	printf("\n%s", bootprog_info);

	/* Determine the devpath of our image so we can prefer it. */
	text = efi_devpath_name(img->FilePath);
	if (text != NULL) {
		printf("   Load Path: %S\n", text);
		efi_setenv_illumos_wcs("LoaderPath", text);
		efi_free_devpath_name(text);
	}

	status = OpenProtocolByHandle(img->DeviceHandle,
	    &gEfiDevicePathProtocolGuid, (void **)&imgpath);
	if (status == EFI_SUCCESS) {
		text = efi_devpath_name(imgpath);
		if (text != NULL) {
			printf("   Load Device: %S\n", text);
			efi_setenv_illumos_wcs("LoaderDev", text);
			efi_free_devpath_name(text);
		}
	}

	boot_current = 0;
	sz = sizeof (boot_current);
	efi_global_getenv("BootCurrent", &boot_current, &sz);
	printf("   BootCurrent: %04x\n", boot_current);

	sz = sizeof (boot_order);
	efi_global_getenv("BootOrder", &boot_order, &sz);
	printf("   BootOrder:");
	for (i = 0; i < sz / sizeof (boot_order[0]); i++)
		printf(" %04x%s", boot_order[i],
		    boot_order[i] == boot_current ? "[*]" : "");
	printf("\n");

	/*
	 * Disable the watchdog timer. By default the boot manager sets
	 * the timer to 5 minutes before invoking a boot option. If we
	 * want to return to the boot manager, we have to disable the
	 * watchdog timer and since we're an interactive program, we don't
	 * want to wait until the user types "quit". The timer may have
	 * fired by then. We don't care if this fails. It does not prevent
	 * normal functioning in any way...
	 */
	BS->SetWatchdogTimer(0, 0, 0, NULL);

	/*
	 * Try and find a good currdev based on the image that was booted.
	 * It might be desirable here to have a short pause to allow falling
	 * through to the boot loader instead of returning instantly to follow
	 * the boot protocol and also allow an escape hatch for users wishing
	 * to try something different.
	 */
	if (!find_currdev(img))
		if (!interactive_interrupt("Failed to find bootable partition"))
			return (EFI_NOT_FOUND);

	autoload_font(false);		/* Set up the font list for console. */
	efi_init_environment();
	bi_isadir();			/* set ISADIR */
	acpi_detect();

	if ((ptr = efi_get_table(&gEfiSmbios3TableGuid)) == NULL)
		ptr = efi_get_table(&gEfiSmbiosTableGuid);
	smbios_detect(ptr);

	interact(NULL);			/* doesn't return */

	return (EFI_SUCCESS);		/* keep compiler happy */
}

COMMAND_SET(reboot, "reboot", "reboot the system", command_reboot);

static void
fw_setup(void)
{
	uint64_t os_indications;
	size_t size;
	EFI_STATUS status;

	size = sizeof (os_indications);
	status = efi_global_getenv("OsIndicationsSupported",
	    &os_indications, &size);
	if (EFI_ERROR(status) || size != sizeof (os_indications) ||
	    (os_indications & EFI_OS_INDICATIONS_BOOT_TO_FW_UI) == 0) {
		printf("Booting to Firmware UI is not supported in "
		    "this system.");
		for (int i = 0; i < 3; i++) {
			delay(1000 * 1000); /* 1 second */
			if (ischar())
				break;
		}
		return;
	}

	os_indications = EFI_OS_INDICATIONS_BOOT_TO_FW_UI;

	status = efi_global_setenv("OsIndications", &os_indications,
	    sizeof (os_indications));
}

static int
command_reboot(int argc, char *argv[])
{
	int i, ch;
	bool fw = false;

	optind = 1;
	optreset = 1;

	while ((ch = getopt(argc, argv, "fh")) != -1) {
		switch (ch) {
		case 'f':
			fw = true;
			break;
		case 'h':
			printf("Usage: reboot [-f]\n");
			return (CMD_OK);
		case '?':
		default:
			return (CMD_OK);
		}
	}

	if (fw || getenv("BOOT_TO_FW_UI") != NULL)
		fw_setup();

	for (i = 0; devsw[i] != NULL; ++i)
		if (devsw[i]->dv_cleanup != NULL)
			(devsw[i]->dv_cleanup)();

	RS->ResetSystem(EfiResetCold, EFI_SUCCESS, 0, NULL);

	/* NOTREACHED */
	return (CMD_ERROR);
}

COMMAND_SET(poweroff, "poweroff", "power off the system", command_poweroff);

static int
command_poweroff(int argc __unused, char *argv[] __unused)
{
	int i;

	for (i = 0; devsw[i] != NULL; ++i)
		if (devsw[i]->dv_cleanup != NULL)
			(devsw[i]->dv_cleanup)();

	RS->ResetSystem(EfiResetShutdown, EFI_SUCCESS, 0, NULL);

	/* NOTREACHED */
	return (CMD_ERROR);
}

COMMAND_SET(memmap, "memmap", "print memory map", command_memmap);

static int
command_memmap(int argc __unused, char *argv[] __unused)
{
	UINTN sz;
	EFI_MEMORY_DESCRIPTOR *map, *p;
	UINTN key, dsz;
	UINT32 dver;
	EFI_STATUS status;
	int i, ndesc;
	int rv = 0;
	char line[80];

	sz = 0;
	status = BS->GetMemoryMap(&sz, 0, &key, &dsz, &dver);
	if (status != EFI_BUFFER_TOO_SMALL) {
		printf("Can't determine memory map size\n");
		return (CMD_ERROR);
	}
	map = malloc(sz);
	status = BS->GetMemoryMap(&sz, map, &key, &dsz, &dver);
	if (EFI_ERROR(status)) {
		printf("Can't read memory map\n");
		return (CMD_ERROR);
	}

	ndesc = sz / dsz;
	snprintf(line, 80, "%23s %12s %12s %8s %4s\n",
	    "Type", "Physical", "Virtual", "#Pages", "Attr");
	pager_open();
	rv = pager_output(line);
	if (rv) {
		pager_close();
		return (CMD_OK);
	}

	for (i = 0, p = map; i < ndesc;
	    i++, p = NextMemoryDescriptor(p, dsz)) {
		snprintf(line, 80, "%23s %012jx %012jx %08jx ",
		    efi_memory_type(p->Type), p->PhysicalStart,
		    p->VirtualStart, p->NumberOfPages);
		rv = pager_output(line);
		if (rv)
			break;

		if (p->Attribute & EFI_MEMORY_UC)
			printf("UC ");
		if (p->Attribute & EFI_MEMORY_WC)
			printf("WC ");
		if (p->Attribute & EFI_MEMORY_WT)
			printf("WT ");
		if (p->Attribute & EFI_MEMORY_WB)
			printf("WB ");
		if (p->Attribute & EFI_MEMORY_UCE)
			printf("UCE ");
		if (p->Attribute & EFI_MEMORY_WP)
			printf("WP ");
		if (p->Attribute & EFI_MEMORY_RP)
			printf("RP ");
		if (p->Attribute & EFI_MEMORY_XP)
			printf("XP ");
		if (p->Attribute & EFI_MEMORY_NV)
			printf("NV ");
		if (p->Attribute & EFI_MEMORY_MORE_RELIABLE)
			printf("MR ");
		if (p->Attribute & EFI_MEMORY_RO)
			printf("RO ");
		rv = pager_output("\n");
		if (rv)
			break;
	}

	pager_close();
	return (CMD_OK);
}

COMMAND_SET(configuration, "configuration", "print configuration tables",
    command_configuration);

static int
command_configuration(int argc __unused, char *argv[] __unused)
{
	UINTN i;
	char *name;

	printf("NumberOfTableEntries=%lu\n",
	    (unsigned long)ST->NumberOfTableEntries);
	for (i = 0; i < ST->NumberOfTableEntries; i++) {
		EFI_GUID *guid;

		printf("  ");
		guid = &ST->ConfigurationTable[i].VendorGuid;

		if (efi_guid_to_name(guid, &name) == true) {
			printf(name);
			free(name);
		} else {
			printf("Error while translating UUID to name");
		}
		printf(" at %p\n", ST->ConfigurationTable[i].VendorTable);
	}

	return (CMD_OK);
}


COMMAND_SET(mode, "mode", "change or display EFI text modes", command_mode);

static int
command_mode(int argc, char *argv[])
{
	UINTN cols, rows;
	unsigned int mode;
	int i;
	char *cp;
	EFI_STATUS status;
	SIMPLE_TEXT_OUTPUT_INTERFACE *conout;
	EFI_CONSOLE_CONTROL_SCREEN_MODE sm;

	if (plat_stdout_is_framebuffer())
		sm = EfiConsoleControlScreenGraphics;
	else
		sm = EfiConsoleControlScreenText;

	conout = ST->ConOut;

	if (argc > 1) {
		mode = strtol(argv[1], &cp, 0);
		if (cp[0] != '\0') {
			printf("Invalid mode\n");
			return (CMD_ERROR);
		}
		status = conout->QueryMode(conout, mode, &cols, &rows);
		if (EFI_ERROR(status)) {
			printf("invalid mode %d\n", mode);
			return (CMD_ERROR);
		}
		status = conout->SetMode(conout, mode);
		if (EFI_ERROR(status)) {
			printf("couldn't set mode %d\n", mode);
			return (CMD_ERROR);
		}
		plat_cons_update_mode(sm);
		return (CMD_OK);
	}

	printf("Current mode: %d\n", conout->Mode->Mode);
	for (i = 0; i <= conout->Mode->MaxMode; i++) {
		status = conout->QueryMode(conout, i, &cols, &rows);
		if (EFI_ERROR(status))
			continue;
		printf("Mode %d: %u columns, %u rows\n", i, (unsigned)cols,
		    (unsigned)rows);
	}

	if (i != 0)
		printf("Select a mode with the command \"mode <number>\"\n");

	return (CMD_OK);
}

COMMAND_SET(lsefi, "lsefi", "list EFI handles", command_lsefi);

static int
command_lsefi(int argc __unused, char *argv[] __unused)
{
	char *name;
	EFI_HANDLE *buffer = NULL;
	EFI_HANDLE handle;
	UINTN bufsz = 0, i, j;
	EFI_STATUS status;
	int ret = 0;

	status = BS->LocateHandle(AllHandles, NULL, NULL, &bufsz, buffer);
	if (status != EFI_BUFFER_TOO_SMALL) {
		snprintf(command_errbuf, sizeof (command_errbuf),
		    "unexpected error: %lld", (long long)status);
		return (CMD_ERROR);
	}
	if ((buffer = malloc(bufsz)) == NULL) {
		sprintf(command_errbuf, "out of memory");
		return (CMD_ERROR);
	}

	status = BS->LocateHandle(AllHandles, NULL, NULL, &bufsz, buffer);
	if (EFI_ERROR(status)) {
		free(buffer);
		snprintf(command_errbuf, sizeof (command_errbuf),
		    "LocateHandle() error: %lld", (long long)status);
		return (CMD_ERROR);
	}

	pager_open();
	for (i = 0; i < (bufsz / sizeof (EFI_HANDLE)); i++) {
		UINTN nproto = 0;
		EFI_GUID **protocols = NULL;
		EFI_DEVICE_PATH *dp;
		CHAR16 *text;

		handle = buffer[i];
		printf("Handle %p", handle);
		if (pager_output("\n"))
			break;

		ret = 0;
		dp = efi_lookup_devpath(handle);
		if (dp != NULL) {
			text = efi_devpath_name(dp);
			if (text != NULL) {
				printf("  %S", text);
				efi_free_devpath_name(text);
				ret = pager_output("\n");
			}
			efi_close_devpath(handle);
		}
		if (ret != 0)
			break;

		status = BS->ProtocolsPerHandle(handle, &protocols, &nproto);
		if (EFI_ERROR(status)) {
			snprintf(command_errbuf, sizeof (command_errbuf),
			    "ProtocolsPerHandle() error: %lld",
			    (long long)status);
			continue;
		}

		for (j = 0; j < nproto; j++) {
			if (efi_guid_to_name(protocols[j], &name) == true) {
				printf("  %s", name);
				free(name);
			} else {
				printf("Error while translating UUID to name");
			}
			if ((ret = pager_output("\n")) != 0)
				break;
		}
		BS->FreePool(protocols);
		if (ret != 0)
			break;
	}
	pager_close();
	free(buffer);
	return (CMD_OK);
}

#ifdef LOADER_FDT_SUPPORT
extern int command_fdt_internal(int argc, char *argv[]);

/*
 * Since proper fdt command handling function is defined in fdt_loader_cmd.c,
 * and declaring it as extern is in contradiction with COMMAND_SET() macro
 * (which uses static pointer), we're defining wrapper function, which
 * calls the proper fdt handling routine.
 */
static int
command_fdt(int argc, char *argv[])
{
	return (command_fdt_internal(argc, argv));
}

COMMAND_SET(fdt, "fdt", "flattened device tree handling", command_fdt);
#endif

/*
 * Chain load another efi loader.
 */
static int
command_chain(int argc, char *argv[])
{
	EFI_HANDLE loaderhandle;
	EFI_LOADED_IMAGE_PROTOCOL *loaded_image;
	EFI_STATUS status;
	struct stat st;
	struct devdesc *dev;
	char *name, *path;
	void *buf;
	int fd;

	if (argc < 2) {
		command_errmsg = "wrong number of arguments";
		return (CMD_ERROR);
	}

	name = argv[1];

	if ((fd = open(name, O_RDONLY)) < 0) {
		command_errmsg = "no such file";
		return (CMD_ERROR);
	}

	if (fstat(fd, &st) < -1) {
		command_errmsg = "stat failed";
		close(fd);
		return (CMD_ERROR);
	}

	status = BS->AllocatePool(EfiLoaderCode, (UINTN)st.st_size, &buf);
	if (status != EFI_SUCCESS) {
		command_errmsg = "failed to allocate buffer";
		close(fd);
		return (CMD_ERROR);
	}
	if (read(fd, buf, st.st_size) != st.st_size) {
		command_errmsg = "error while reading the file";
		(void) BS->FreePool(buf);
		close(fd);
		return (CMD_ERROR);
	}
	close(fd);
	status = BS->LoadImage(FALSE, IH, NULL, buf, st.st_size, &loaderhandle);
	(void) BS->FreePool(buf);
	if (status != EFI_SUCCESS) {
		printf("LoadImage failed: status code: %lu\n",
		    DECODE_ERROR(status));
		return (CMD_ERROR);
	}
	status = OpenProtocolByHandle(loaderhandle,
	    &gEfiLoadedImageProtocolGuid, (void **)&loaded_image);

	if (argc > 2) {
		int i, len = 0;
		CHAR16 *argp;

		for (i = 2; i < argc; i++)
			len += strlen(argv[i]) + 1;

		len *= sizeof (*argp);
		loaded_image->LoadOptions = argp = malloc(len);
		if (loaded_image->LoadOptions == NULL) {
			command_errmsg = "Adding LoadOptions: out of memory";
			(void) BS->UnloadImage(loaded_image);
			return (CMD_ERROR);
		}
		loaded_image->LoadOptionsSize = len;
		for (i = 2; i < argc; i++) {
			char *ptr = argv[i];
			while (*ptr)
				*(argp++) = *(ptr++);
			*(argp++) = ' ';
		}
		*(--argv) = 0;
	}

	if (efi_getdev((void **)&dev, name, (const char **)&path) == 0) {
		struct zfs_devdesc *z_dev;
		struct disk_devdesc *d_dev;
		pdinfo_t *hd, *pd;

		switch (dev->d_dev->dv_type) {
		case DEVT_ZFS:
			z_dev = (struct zfs_devdesc *)dev;
			loaded_image->DeviceHandle =
			    efizfs_get_handle_by_guid(z_dev->pool_guid);
			break;
		case DEVT_NET:
			loaded_image->DeviceHandle =
			    efi_find_handle(dev->d_dev, dev->d_unit);
			break;
		default:
			hd = efiblk_get_pdinfo(dev);
			if (STAILQ_EMPTY(&hd->pd_part)) {
				loaded_image->DeviceHandle = hd->pd_handle;
				break;
			}
			d_dev = (struct disk_devdesc *)dev;
			STAILQ_FOREACH(pd, &hd->pd_part, pd_link) {
				/*
				 * d_partition should be 255
				 */
				if (pd->pd_unit == d_dev->d_slice) {
					loaded_image->DeviceHandle =
					    pd->pd_handle;
					break;
				}
			}
			break;
		}
	}

	dev_cleanup();
	status = BS->StartImage(loaderhandle, NULL, NULL);
	if (status != EFI_SUCCESS) {
		printf("StartImage failed: status code: %lu\n",
		    DECODE_ERROR(status));
		free(loaded_image->LoadOptions);
		loaded_image->LoadOptions = NULL;
		status = BS->UnloadImage(loaded_image);
		return (CMD_ERROR);
	}

	return (CMD_ERROR);
}

COMMAND_SET(chain, "chain", "chain load file", command_chain);



/* ============================================================================
 * SOURCE 97/98: minix\core\main.c
 * Size: 12,594 bytes, Lines: 466
 * Hash: dceaedb4e092...
 * ============================================================================ */

/**
 * @file main.c
 * @brief MINIX4 Kernel Entry Point - C23 Implementation
 * @version 4.0.0
 * @date 2025-06-12
 * 
 * Modern C23 MINIX4 microkernel entry point with modular architecture,
 * capability-based security, and exokernel principles.
 * 
 * Copyright (c) 2025 MINIX4 Project
 * Licensed under BSD-3-Clause
 */

#include <stdint.h>
#include <stddef.h>
#include <stdnoreturn.h>
#include <stdalign.h>
#include <stdatomic.h>
#include <stdbool.h>
#include <string.h>
#include <stdio.h>

// MINIX4 Core Headers
#include "types.h"

// Forward declarations for now
struct proc;
struct buf;
struct inode;

// Constants for MINIX4
#define MINIX4_BOOT_MAGIC    0x4D494E5834UL  // "MINX4"
#define MAXMEM               (512 * 1024)    // 512MB default max
#define USIZE                2               // User structure size in pages
#define ROOTINO              1               // Root inode number

/**
 * @brief MINIX4 kernel boot information structure
 */
struct minix4_boot_info {
    uint64_t magic;                    /**< Boot magic number */
    uint64_t total_memory;             /**< Total system memory */
    uint64_t available_memory;         /**< Available memory for allocation */
    uint32_t cpu_count;                /**< Number of CPU cores */
    uint32_t boot_cpu;                 /**< Boot CPU ID */
    uint64_t kernel_start;             /**< Kernel start address */
    uint64_t kernel_end;               /**< Kernel end address */
    uint64_t initrd_start;             /**< Initial ramdisk start */
    uint64_t initrd_size;              /**< Initial ramdisk size */
    uint32_t arch_flags;               /**< Architecture-specific flags */
    char cmdline[256];                 /**< Kernel command line */
} __attribute__((packed));

// Global state
static struct minix4_boot_info *boot_info = NULL;
static atomic_bool memory_initialized = false;
static atomic_bool scheduler_initialized = false;
static atomic_bool ipc_initialized = false;
static atomic_bool capabilities_initialized = false;

// Simple console output for early boot
static void cprintf(const char *fmt, ...)
{
    // For now, just a placeholder
    // In real implementation, this would use early console
    (void)fmt;
}

// Panic function
noreturn void panic(const char *message)
{
    cprintf("KERNEL PANIC: %s\n", message);
    for (;;) {
        // Halt CPU
        __asm__ volatile ("hlt");
    }
}

/**
 * @brief Early kernel initialization
 */
static void early_init(void)
{
    cprintf("MINIX4 Kernel v4.0.0 (C23) - Early Init\n");
    cprintf("Boot CPU: %u, Total CPUs: %u\n", 
            boot_info->boot_cpu, boot_info->cpu_count);
    cprintf("Early initialization complete\n");
}

/**
 * @brief Initialize memory management subsystem
 */
static int init_memory_management(void)
{
    cprintf("Initializing memory management...\n");
    
    // Basic memory setup
    atomic_store(&memory_initialized, true);
    cprintf("Memory management initialized: %lu MB available\n",
            boot_info->available_memory / (1024 * 1024));
    
    return 0;
}

/**
 * @brief Initialize capability system
 */
static int init_capability_system(void)
{
    cprintf("Initializing capability system...\n");
    
    atomic_store(&capabilities_initialized, true);
    cprintf("Capability system initialized\n");
    
    return 0;
}

/**
 * @brief Initialize IPC subsystem
 */
static int init_ipc_subsystem(void)
{
    cprintf("Initializing IPC subsystem...\n");
    
    atomic_store(&ipc_initialized, true);
    cprintf("IPC subsystem initialized\n");
    
    return 0;
}

/**
 * @brief Initialize process management and scheduler
 */
static int init_process_management(void)
{
    cprintf("Initializing process management...\n");
    
    atomic_store(&scheduler_initialized, true);
    cprintf("Process management initialized\n");
    
    return 0;
}

/**
 * @brief Initialize device drivers and I/O subsystem
 */
static int init_device_subsystem(void)
{
    cprintf("Initializing device subsystem...\n");
    cprintf("Device subsystem initialized\n");
    
    return 0;
}

/**
 * @brief Start the first user process (init)
 */
static noreturn void start_init_process(void)
{
    cprintf("Starting init process...\n");
    cprintf("Switching to user mode - MINIX4 kernel initialization complete\n");
    
    // For now, just halt - in real implementation this would start init
    for (;;) {
        __asm__ volatile ("hlt");
    }
}

/**
 * @brief Main kernel entry point
 * 
 * This is the primary entry point for the MINIX4 kernel.
 * Called from architecture-specific boot code.
 */
noreturn void kernel_main(struct minix4_boot_info *boot_info_ptr)
{
    // Store boot information
    boot_info = boot_info_ptr;
    
    // Validate boot information
    if (boot_info == NULL || boot_info->magic != MINIX4_BOOT_MAGIC) {
        panic("Invalid boot magic");
    }
    
    // Early initialization
    early_init();
    
    // Initialize major subsystems in dependency order
    init_memory_management();
    init_capability_system();
    init_ipc_subsystem();
    init_process_management();
    init_device_subsystem();
    
    cprintf("MINIX4 kernel initialization complete\n");
    cprintf("Memory: %lu MB, CPUs: %u, Capabilities: enabled\n",
            boot_info->total_memory / (1024 * 1024),
            boot_info->cpu_count);
    
    // Start the init process (this doesn't return)
    start_init_process();
}

/**
 * @brief Legacy main function for backwards compatibility
 * 
 * This maintains compatibility with the old MINIX system while
 * providing a modernized implementation.
 */
int main(void)
{
    // Create a default boot info structure for legacy mode
    struct minix4_boot_info default_boot_info = {
        .magic = MINIX4_BOOT_MAGIC,
        .total_memory = 64 * 1024 * 1024,  // 64MB default
        .available_memory = 48 * 1024 * 1024,  // 48MB available
        .cpu_count = 1,
        .boot_cpu = 0,
        .kernel_start = 0x100000,
        .kernel_end = 0x200000,
        .initrd_start = 0,
        .initrd_size = 0,
        .arch_flags = 0,
        .cmdline = "minix4"
    };
    
    cprintf("MINIX4 starting in legacy compatibility mode\n");
    
    // Call the modern kernel main
    kernel_main(&default_boot_info);
    
    // Should never reach here
    return 0;
}/**
 * @file main.c
 * @brief MINIX4 Kernel Entry Point - C23 Implementation
 * @version 4.0.0
 * @date 2025-06-12
 * 
 * Modern C23 MINIX4 microkernel entry point with modular architecture,
 * capability-based security, and exokernel principles.
 * 
 * Copyright (c) 2025 MINIX4 Project
 * Licensed under BSD-3-Clause
 */

#include <stdint.h>
#include <stddef.h>
#include <stdnoreturn.h>
#include <stdalign.h>
#include <stdatomic.h>
#include <stdbool.h>

// MINIX4 Core Headers
#include "types.h"

// Forward declarations for now
struct proc;
struct buf;
struct inode;

// Constants for MINIX4
#define MINIX4_BOOT_MAGIC    0x4D494E5834UL  // "MINX4"
#define MAXMEM               (512 * 1024)    // 512MB default max
#define USIZE                2               // User structure size in pages
#define ROOTINO              1               // Root inode number

/**
 * @brief MINIX4 kernel boot information structure
 */
struct minix4_boot_info {
    uint64_t magic;                    /**< Boot magic number */
    uint64_t total_memory;             /**< Total system memory */
    uint64_t available_memory;         /**< Available memory for allocation */
    uint32_t cpu_count;                /**< Number of CPU cores */
    uint32_t boot_cpu;                 /**< Boot CPU ID */
    uint64_t kernel_start;             /**< Kernel start address */
    uint64_t kernel_end;               /**< Kernel end address */
    uint64_t initrd_start;             /**< Initial ramdisk start */
    uint64_t initrd_size;              /**< Initial ramdisk size */
    uint32_t arch_flags;               /**< Architecture-specific flags */
    char cmdline[256];                 /**< Kernel command line */
} __attribute__((packed));

// Global state
static struct minix4_boot_info *boot_info = NULL;
static atomic_bool memory_initialized = false;
static atomic_bool scheduler_initialized = false;
static atomic_bool ipc_initialized = false;
static atomic_bool capabilities_initialized = false;

// Simple console output for early boot
static void cprintf(const char *fmt, ...)
{
    // For now, just a placeholder
    // In real implementation, this would use early console
    (void)fmt;
}

// Panic function
noreturn void panic(const char *message)
{
    cprintf("KERNEL PANIC: %s\n", message);
    for (;;) {
        // Halt CPU
        __asm__ volatile ("hlt");
    }
}

/**
 * @brief Early kernel initialization
 */
static void early_init(void)
{
    cprintf("MINIX4 Kernel v4.0.0 (C23) - Early Init\n");
    cprintf("Boot CPU: %u, Total CPUs: %u\n", 
            boot_info->boot_cpu, boot_info->cpu_count);
    cprintf("Early initialization complete\n");
}

/**
 * @brief Initialize memory management subsystem
 */
static int init_memory_management(void)
{
    cprintf("Initializing memory management...\n");
    
    // Basic memory setup
    atomic_store(&memory_initialized, true);
    cprintf("Memory management initialized: %lu MB available\n",
            boot_info->available_memory / (1024 * 1024));
    
    return 0;
}

/**
 * @brief Initialize capability system
 */
static int init_capability_system(void)
{
    cprintf("Initializing capability system...\n");
    
    atomic_store(&capabilities_initialized, true);
    cprintf("Capability system initialized\n");
    
    return 0;
}

/**
 * @brief Initialize IPC subsystem
 */
static int init_ipc_subsystem(void)
{
    cprintf("Initializing IPC subsystem...\n");
    
    atomic_store(&ipc_initialized, true);
    cprintf("IPC subsystem initialized\n");
    
    return 0;
}

/**
 * @brief Initialize process management and scheduler
 */
static int init_process_management(void)
{
    cprintf("Initializing process management...\n");
    
    atomic_store(&scheduler_initialized, true);
    cprintf("Process management initialized\n");
    
    return 0;
}

/**
 * @brief Initialize device drivers and I/O subsystem
 */
static int init_device_subsystem(void)
{
    cprintf("Initializing device subsystem...\n");
    cprintf("Device subsystem initialized\n");
    
    return 0;
}

/**
 * @brief Start the first user process (init)
 */
static noreturn void start_init_process(void)
{
    cprintf("Starting init process...\n");
    cprintf("Switching to user mode - MINIX4 kernel initialization complete\n");
    
    // For now, just halt - in real implementation this would start init
    for (;;) {
        __asm__ volatile ("hlt");
    }
}

/**
 * @brief Main kernel entry point
 * 
 * This is the primary entry point for the MINIX4 kernel.
 * Called from architecture-specific boot code.
 */
noreturn void kernel_main(struct minix4_boot_info *boot_info_ptr)
{
    // Store boot information
    boot_info = boot_info_ptr;
    
    // Validate boot information
    if (boot_info == NULL || boot_info->magic != MINIX4_BOOT_MAGIC) {
        panic("Invalid boot magic");
    }
    
    // Early initialization
    early_init();
    
    // Initialize major subsystems in dependency order
    init_memory_management();
    init_capability_system();
    init_ipc_subsystem();
    init_process_management();
    init_device_subsystem();
    
    cprintf("MINIX4 kernel initialization complete\n");
    cprintf("Memory: %lu MB, CPUs: %u, Capabilities: enabled\n",
            boot_info->total_memory / (1024 * 1024),
            boot_info->cpu_count);
    
    // Start the init process (this doesn't return)
    start_init_process();
}

/**
 * @brief Legacy main function for backwards compatibility
 * 
 * This maintains compatibility with the old MINIX system while
 * providing a modernized implementation.
 */
int main(void)
{
    // Create a default boot info structure for legacy mode
    struct minix4_boot_info default_boot_info = {
        .magic = MINIX4_BOOT_MAGIC,
        .total_memory = 64 * 1024 * 1024,  // 64MB default
        .available_memory = 48 * 1024 * 1024,  // 48MB available
        .cpu_count = 1,
        .boot_cpu = 0,
        .kernel_start = 0x100000,
        .kernel_end = 0x200000,
        .initrd_start = 0,
        .initrd_size = 0,
        .arch_flags = 0,
        .cmdline = "minix4"
    };
    
    cprintf("MINIX4 starting in legacy compatibility mode\n");
    
    // Call the modern kernel main
    kernel_main(&default_boot_info);
    
    // Should never reach here
    return 0;
}



/* ============================================================================
 * SOURCE 98/98: archive\minix_legacy\main.c
 * Size: 1,868 bytes, Lines: 112
 * Hash: 704d57d4c798...
 * ============================================================================ */

/* Copyright (c) 1979 Regents of the University of California */
#

#include "rcv.h"
#include <sys/stat.h>

/*
 * Mail -- a mail program
 *
 * Startup -- interface with user.
 */

/*
 * Find out who the user is, copy his mail file (if exists) into
 * /tmp/Rxxxxx and set up the message pointers.  Then, print out the
 * message headers and read user commands.
 */

main(argc, argv)
	char **argv;
{
	register char *ef;
	register int i;
	FILE *ibuf;
	extern char tempMesg[], _sobuf[];

	argv[argc] = (char *) -1;
	mypid = getpid();
	intty = isatty(0);
	outtty = isatty(1);
	setbuf(stdout, _sobuf);
	tinit();
	ef = NOSTR;
	for (i = 1; i < argc; i++) {
		if (equal(argv[i], "-f")) {
			ef = argv[i+1];
			break;
		}
		if (equal(argv[i], "-n")) {
			demail();
			exit(0);
		}
	}
	if (ef == NOSTR && argc > 1) {
		commands();
		i = 1;
		if (equal(argv[1], "-i")) {
			assign("ignore", "");
			i++;
		}
		mail(&argv[i]);

		/*
		 * why wait?
		 */

		exit(0);
	}
	rcvmode++;
	if (ef != NOSTR) {
		edit++;
		if (ef == (char *) -1)
			ef = mbox;
		editfile = mailname = ef;
		if ((ibuf = fopen(mailname, "r")) == NULL) {
			perror(mailname);
			exit(1);
		}
		if ((i = open(mailname, 1)) < 0)
			printf("Warning: \"%s\" not writable.\n", mailname);
		else
			close(i);
	}
	else {
		if ((ibuf = fopen(mailname, "r")) == NULL) {
			printf("No mail.\n");
			exit(0);
		}
	}

	/*
	 * Copy the mudder into /tmp
	 * and set pointers.
	 * Announce the presence of this funny file.
	 */

	mailsize = fsize(ibuf);
	if ((otf = fopen(tempMesg, "w")) == NULL) {
		perror(tempMesg);
		exit(1);
	}
	if ((itf = fopen(tempMesg, "r")) == NULL) {
		perror(tempMesg);
		exit(1);
	}
	unlink(tempMesg);
	setptr(ibuf);
	fclose(ibuf);

	/*
	 * print headings and accept user commands. */

	if (msgCount == 0) {
		printf("No messages.\n");
		exit(1);
	}
	commands();
	if (!edit)
		quit();
	exit(0);
}

