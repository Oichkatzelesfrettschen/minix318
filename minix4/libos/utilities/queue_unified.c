/**
 * @file queue_unified.c
 * @brief Unified queue implementation
 * @details This file is a synthesized/unified implementation combining multiple
 *          source files from the legacy MINIX codebase into a single, modern,
 *          C23-compliant implementation for MINIX4.
 * 
 * @version 4.0.0
 * @date 2025-06-13
 * @author MINIX4 Synthesis System
 * 
 * @copyright Copyright (c) 2024 MINIX4 Project
 * @license MIT License
 * 
 * SYNTHESIS INFORMATION:
 * ======================
 * This file synthesizes the following source files:
 *    1. userspace\usr_bin_legacy\grep\queue.c
 *    2. minix4\libos\lib_legacy\libmthread\queue.c
 *    3. minix4\exokernel\kernel_legacy\cmd\auditd\queue.c
 *    4. minix4\exokernel\kernel_legacy\cmd\syslogd\queue.c
 *    5. minix4\exokernel\kernel_legacy\cmd\vntsd\queue.c
 *    6. minix4\exokernel\kernel_legacy\cmd\sendmail\src\queue.c
 * 
 * Total source files: 6
 * Synthesis date: 2025-06-13 19:51:15
 * Synthesis strategy: Modern C23 unification with legacy compatibility
 * 
 * MODERNIZATION FEATURES:
 * =======================
 * - C23 standard compliance
 * - Modern error handling patterns
 * - Consistent coding style
 * - Improved memory safety
 * - Enhanced documentation
 * - POSIX compliance where applicable
 */

#ifndef QUEUE_UNIFIED_C_H
#define QUEUE_UNIFIED_C_H

// C23 Standard Headers
#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdatomic.h>
#include <threads.h>

// POSIX Headers
#include <unistd.h>
#include <errno.h>
#include <string.h>

// MINIX4 Headers
#include "minix4_types.h"
#include "minix4_config.h"

#ifdef __cplusplus
extern "C" {
#endif


/* ===== INCLUDES ===== */
#include "dataq.h"
#include "global.h"
#include "grep.h"
#include "plugin.h"
#include "proto.h"
#include "queue.h"
#include "vntsd.h"
#include <assert.h>
#include <dirent.h>
#include <malloc.h>
#include <memory.h>
#include <minix/mthread.h>
#include <netinet/in.h>
#include <pthread.h>
#include <sendmail.h>
#include <signal.h>
#include <sm/sem.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ipc.h>
#include <sys/param.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <thread.h>
#include <time.h>
#include <unistd.h>
#include <wait.h>

/* ===== DEFINES ===== */
#define	DEBUG	0
#define	DPRINT(x) { (void) fprintf x; }
#define	DPRINT(x)
#define QF_VERSION	8	/* version number of this queue format */
#define GET_NEW_LA_TIME	30
#define SM_GET_LA(now)	\
#define FILE_SYS_NAME(i)	FSPath[i]
#define FILE_SYS_AVAIL(i)	FILE_SYS(i).fs_avail
#define FILE_SYS_BLKSIZE(i)	FILE_SYS(i).fs_blksize
#define FILE_SYS_DEV(i)	FILE_SYS(i).fs_dev
#define OPEN_TF	do							\
#define MAX_PERSIST_RESTART	10	/* max allowed number of restarts */
#define INCR_MOD(v, m)	if (++v >= m)	\
#define QP_NOSUB	0x0000	/* No subdirectories */
#define QP_SUBDF	0x0001	/* "df" subdirectory */
#define QP_SUBQF	0x0002	/* "qf" subdirectory */
#define QP_SUBXF	0x0004	/* "xf" subdirectory */
#define MIN_SLEEP_TIME	5
#define NEED_P		0001	/* 'P': priority */
#define NEED_T		0002	/* 'T': time */
#define NEED_R		0004	/* 'R': recipient */
#define NEED_S		0010	/* 'S': sender */
#define NEED_H		0020	/* host */
#define HAS_QUARANTINE	0040	/* has an unexpected 'q' line */
#define NEED_QUARANTINE	0100	/* 'q': reason */
#define QIC_LEN_SQR	(QIC_LEN * QIC_LEN)
#define INITIAL_SLOTS	20
#define ADD_SLOTS	10
#define CHKRSUBDIR(name, flag)	\
#define CHKSUBDIR(name, flag)	\
#define FSF_NOT_FOUND	(-1)
#define FSF_STAT_FAIL	(-2)
#define FSF_TOO_MANY	(-3)
#define SEL_SHM_KEY	((key_t) -1)
#define FIRST_SHM_KEY	25
#define SM_SPLIT_FAIL	(0)
#define SM_SPLIT_NONE	(1)
#define SM_SPLIT_NEW(n)	(1 + (n))
#define SPLIT_LOG_LEVEL	8

/* ===== TYPES ===== */
typedef struct queue {
	struct queue   *next;
struct work
	struct work	*w_next;	/* next in queue */
typedef struct work	WORK;
struct workgrp
typedef struct workgrp WORKGRP;
typedef struct filesys_shared	FILESYS;
struct filesys_shared
typedef struct queue_shared	QUEUE_SHM_T;
struct queue_shared
		struct stat stbuf;
		struct stat sbuf;
	struct stat st, stf;
		struct stat dst;
		struct stat st;
		struct stat st;
	struct tm *tm;
	struct passwd *pw;
	struct stat statb;
	struct stat st;
	struct stat st;
struct sortqgrp
typedef struct sortqgrp	SORTQGRP_T;

/* ===== GLOBAL VARIABLES ===== */
	str_t		data;
} queue_t;
static queue_t	*q_head, *q_tail;
static int	 count;
static queue_t	*dequeue(void);
	q_head = q_tail = NULL;
	free(item);
	queue_t	*item;
	item = grep_malloc(sizeof *item + x->len);
	item->data.len = x->len;
	item->data.line_no = x->line_no;
	item->data.off = x->off;
	item->data.dat = (char *)item + sizeof *item;
	memcpy(item->data.dat, x->dat, x->len);
	item->data.file = x->file;
	item->next = NULL;
		q_head = q_tail = item;
		q_tail->next = item;
		q_tail = item;
		free_item(dequeue());
	queue_t	*item;
	--count;
	item = q_head;
	q_head = item->next;
		q_tail = NULL;
	queue_t *item;
		printline(&item->data, '-', NULL);
		free_item(item);
	queue_t	*item;
		free_item(item);
mthread_thread_t thread;
  mthread_tcb_t *last;
  	mthread_panic("Can't append invalid thread ID to a queue");
  last = mthread_find_tcb(thread);
  	queue->mq_head = queue->mq_tail = last;
	queue->mq_tail->m_next = last;
  queue->mq_head = queue->mq_tail = NULL;
mthread_queue_t *queue;
mthread_queue_t *queue;
  int threshold, count = 0;
  mthread_tcb_t *t;
  mthread_thread_t tid;
  threshold = no_threads;
  printf("Dumping queue: ");
  	t = queue->mq_head;
	else tid = t->m_tid;
	printf("%d ", tid);
	count++;
	t = t->m_next; 
		else tid = t->m_tid;
		printf("%d ", tid);
		t = t->m_next; 
		count++;
  	printf("[empty]");
  printf("\n");
  mthread_thread_t thread;
  mthread_tcb_t *tcb, *random_tcb, *prev;
  int count = 0, offset_id = 0, picked_random = 0;
  tcb = queue->mq_head;
	random_tcb = queue->mq_head;
			count++;
			random_tcb = random_tcb->m_next;
		picked_random = 1;
		offset_id = random() % count;
		random_tcb = queue->mq_head;
		prev = random_tcb;
			prev = random_tcb;
			random_tcb = random_tcb->m_next;
		prev->m_next = random_tcb->m_next;
			queue->mq_head = random_tcb->m_next;
			queue->mq_tail = prev;
		tcb = random_tcb;
  else thread = (tcb->m_tid);
  	tcb = queue->mq_head;
		queue->mq_head = queue->mq_head->m_next;
extern FILE *dbfp;
extern FILE *__auditd_debug_file_open();
	q->auq_head = NULL;
	q->auq_tail = NULL;
	(void) pthread_mutex_init(&q->auq_lock, NULL);
	q->auq_count = 0;
		dbfp = __auditd_debug_file_open();
	(void) pthread_mutex_lock(&q->auq_lock);
	    q->auq_count));
		q->auq_head = p;
		    (void *)&(((audit_link_t *)(q->auq_tail))->aln_next)));
		((audit_link_t *)(q->auq_tail))->aln_next = p;
	q->auq_tail = p;
	((audit_link_t *)p)->aln_next = NULL;
	q->auq_count++;
	    (void *)((audit_link_t *)p)->aln_next));
	(void) pthread_mutex_unlock(&q->auq_lock);
	(void) pthread_mutex_lock(&q->auq_lock);
		    (void *)q->auq_head, (void *)q->auq_tail, q->auq_count));
		(void) pthread_mutex_unlock(&q->auq_lock);
	q->auq_count--;
	q->auq_head = ((audit_link_t *)*p)->aln_next;
	    (void *)((audit_link_t *)*p)->aln_next));
	(void) pthread_mutex_unlock(&q->auq_lock);
	(void) pthread_mutex_lock(l);
	p->abq_ref_count++;
	    (void *)p, p->abq_ref_count));
	(void) pthread_mutex_unlock(l);
	assert(p != NULL);
	(void) pthread_mutex_lock(l);
	    (void *)p, p->abq_ref_count));
		(void) pthread_mutex_unlock(l);
	(void) pthread_mutex_unlock(l);
	int	size;
	(void) pthread_mutex_lock(&q->auq_lock);
	size = q->auq_count;
	(void) pthread_mutex_unlock(&q->auq_lock);
	(void) pthread_mutex_destroy(&q->auq_lock);
	assert(ptr->num_data == ll_check(&ptr->data));
	assert(ptr->num_waiters == ll_check(&ptr->waiters));
	ptr->num_data = 0;
	ptr->num_waiters = 0;
	ll_init(&ptr->data);
	ll_init(&ptr->waiters);
	(void) pthread_mutex_init(&ptr->lock, NULL);
		(pthread_mutex_unlock(&ptr->lock) == 0));
	dataq_data_t *ptr = (dataq_data_t *)malloc(sizeof (*ptr));
	dataq_waiter_t *sleeper;
	ptr->data = in;
	(void) pthread_mutex_lock(&dataq->lock);
	assert(dataq_check(dataq));
	ll_enqueue(&dataq->data, &ptr->list);
	dataq->num_data++;
		sleeper = (dataq_waiter_t *)ll_peek(&dataq->waiters);
		sleeper->wakeup = 1;
		(void) pthread_cond_signal(&sleeper->cv);
	assert(dataq_check(dataq));
	(void) pthread_mutex_unlock(&dataq->lock);
	dataq_data_t *dptr;
	dataq_waiter_t *sleeper;
	(void) pthread_mutex_lock(&dataq->lock);
	dataq->num_data--;
		sleeper = (dataq_waiter_t *)ll_peek(&dataq->waiters);
		sleeper->wakeup = 1;
		(void) pthread_cond_signal(&sleeper->cv);
	(void) pthread_mutex_unlock(&dataq->lock);
	*outptr = dptr->data;
	free(dptr);
	dataq_data_t *d = (dataq_data_t *)p;
	free(d->data);
	free(d);
	dataq_waiter_t *d = (dataq_waiter_t *)p;
	(void) pthread_cond_destroy(&d->cv);
	free(d);
	(void) pthread_mutex_destroy(&dataq->lock);
	ll_mapf(&dataq->data, dataq_data_destroy);
	ll_mapf(&dataq->waiters, dataq_waiters_destroy);
	vntsd_que_t *el;
	el = (vntsd_que_t *)malloc(sizeof (vntsd_que_t));
	el->nextp = NULL;
	el->prevp = NULL;
	el->handle = handle;
	vntsd_que_t *p;
	vntsd_que_t *el;
	assert(que_hd);
	assert(handle);
	el = alloc_que_el(handle);
	p = *que_hd;
		*que_hd  = el;
			p = p->nextp;
		p->nextp = el;
	el->prevp = p;
	vntsd_que_t *q, *el;
	assert(que);
	q = que;
			break;
		q = q->nextp;
	el = alloc_que_el(next);
	el->nextp = q->nextp;
	q->nextp = el;
	el->prevp = q;
	vntsd_que_t	*p = *que_hd;
	vntsd_que_t	*prevp = NULL;
			break;
		prevp = p;
		p = p->nextp;
		*que_hd = p->nextp;
		prevp->nextp = p->nextp;
		p->nextp->prevp = prevp;
	handle = p->handle;
	free(p);
	vntsd_que_t *p = que_hd;
		p = p->nextp;
	vntsd_que_t *p = que_hd;
	assert(compare_func != NULL);
		p = p->nextp;
	vntsd_que_t *p;
		p = *q;
		*q  = p->nextp;
			(*clean_func)(p->handle);
			free(p->handle);
		free(p);
	vntsd_que_t *p = que_hd;
	assert((pos == 1) || (pos == -1));
					p = p->nextp;
				assert(p != NULL);
				assert(p->handle != NULL);
		p = p->nextp;
	    thr_self());
static char	queue_letter __P((ENVELOPE *, int));
static bool	quarantine_queue_item __P((int, int, ENVELOPE *, char *));
};
static time_t	Current_LA_time = 0;
};
	"@(#)$Debug: leak_q - trace memory leaks during queue processing $");
static const char EmptyString[] = "";
static void	grow_wlist __P((int, int));
static int	multiqueue_cache __P((char *, int, QUEUEGRP *, int, unsigned int *));
static int	gatherq __P((int, int, bool, bool *, bool *, int *));
static int	sortq __P((int));
static void	printctladdr __P((ADDRESS *, SM_FILE_T *));
static bool	readqf __P((ENVELOPE *, bool));
static void	restart_work_group __P((int));
static void	runner_work __P((ENVELOPE *, int, bool, int, int));
static void	schedule_queue_runs __P((bool, int, bool));
static char	*strrev __P((char *));
static ADDRESS	*setctluser __P((char *, int, ENVELOPE *));
static int	sm_strshufflecmp __P((char *, char *));
static void	init_shuffle_alphabet __P(());
static int	workcmpf0();
static int	workcmpf1();
static int	workcmpf2();
static int	workcmpf3();
static int	workcmpf4();
static int	workcmpf5();
static int	workcmpf6();
static int	workcmpf7();
};
};
static size_t shms;
int	*PRSATmpCnt;
static unsigned int	hash_q __P((char *, unsigned int));
	char *p;
	unsigned int h;
	int c, d;
		d = *p++;
		c = d;
		c ^= c<<6;
		h += (c<<11) ^ (c>>1);
		h ^= (d<<14) + (d<<7) + (d<<4) + d;
	register ENVELOPE *e;
	bool announce;
	bool msync;
	register SM_FILE_T *tfp;
	register HDR *h;
	register ADDRESS *q;
	int tfd = -1;
	int i;
	bool newid;
	register char *p;
	MAILER nullmailer;
	MCI mcibuf;
	char qf[MAXPATHLEN];
	char tf[MAXPATHLEN];
	char df[MAXPATHLEN];
	char buf[MAXLINE];
	newid = (e->e_id == NULL) || !bitset(EF_INQUEUE, e->e_flags);
	(void) sm_strlcpy(tf, queuename(e, NEWQFL_LETTER), sizeof(tf));
	tfp = e->e_lockfp;
		(void) sm_strlcpy(tf, queuename(e, ANYQFL_LETTER), sizeof(tf));
		OPEN_TF;
			int save_errno = errno;
			printopenfds(true);
			errno = save_errno;
				tf, (int) geteuid(), tfd, tfp);
		e->e_lockfp = tfp;
		upd_qs(e, 1, 0, "queueup");
				OPEN_TF;
						break;
							  sm_errstring(errno));
					break;
				break;
					break;
						  tf, sm_errstring(errno));
					(void) close(tfd);
					tfd = -1;
				(void) rename(tf, queuename(e, TEMPQF_LETTER));
				(void) sleep(i % 32);
			int save_errno = errno;
			printopenfds(true);
			errno = save_errno;
				tf, (int) geteuid());
			   newid ? " (new id)" : "");
		sm_dprintf("  e_flags=");
		printenvflags(e);
		sm_dprintf("  sendq=");
		printaddr(sm_debug_file(), e->e_sendqueue, true);
		sm_dprintf("  tfp=");
		dumpfd(sm_io_getinfo(tfp, SM_IO_WHAT_FD, NULL), true, false);
		sm_dprintf("  lockfp=");
			sm_dprintf("NULL\n");
			       true, false);
	(void) sm_strlcpy(df, queuename(e, DATAFL_LETTER), sizeof(df));
			       queuename(e, DATAFL_LETTER), (int) geteuid());
					  "queueup: fsync(e->e_dfp)");
					       df);
					       df);
		int dfd;
		MODE_T oldumask = 0;
		register SM_FILE_T *dfp = NULL;
			syserr("committing over bf file");
			oldumask = umask(002);
			   QueueFileMode);
			(void) umask(oldumask);
				df, (int) geteuid());
			e->e_dfino = -1;
			e->e_dfdev = stbuf.st_dev;
			e->e_dfino = ST_INODE(stbuf);
		e->e_flags |= EF_HAS_DF;
		memset(&mcibuf, '\0', sizeof(mcibuf));
		mcibuf.mci_out = dfp;
		mcibuf.mci_mailer = FileMailer;
		(*e->e_putbody)(&mcibuf, e, NULL);
					  "queueup: fsync(dfp)");
					       df);
					       df);
				df, (int) geteuid());
		e->e_putbody = putbody;
	(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "V%d\n", QF_VERSION);
	(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "T%ld\n", (long) e->e_ctime);
	(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "K%ld\n", (long) e->e_dtime);
	(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "N%d\n", e->e_ntries);
	(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "P%ld\n", e->e_msgpriority);
			Queue[e->e_dfqgrp]->qg_qpaths[e->e_dfqdir].qp_name);
				     (ULONGLONG_T) e->e_dfino);
				     denlstring(e->e_bodytype, true, false));
				     denlstring(e->e_quarmsg, true, false));
				     denlstring(e->e_message, true, false));
	p = buf;
		*p++ = 'w';
		*p++ = 'r';
		*p++ = '8';
		*p++ = 'b';
		*p++ = 'd';
		*p++ = 'n';
		*p++ = 's';
	*p++ = '\0';
		(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "F%s\n", buf);
		p = e->e_sender;
		p = e->e_from.q_paddr;
			     denlstring(p, true, false));
				     denlstring(e->e_envid, true, false));
				     denlstring(e->e_auth_param, true, false));
				     (char) e->e_dlvr_flag, e->e_deliver_by);
	printctladdr(NULL, NULL);
			continue;
							false));
		printctladdr(q, tfp);
							false));
							false));
		(void) sm_io_putc(tfp, SM_TIME_DEFAULT, 'R');
			(void) sm_io_putc(tfp, SM_TIME_DEFAULT, 'P');
			(void) sm_io_putc(tfp, SM_TIME_DEFAULT, 'N');
			(void) sm_io_putc(tfp, SM_TIME_DEFAULT, 'S');
			(void) sm_io_putc(tfp, SM_TIME_DEFAULT, 'F');
			(void) sm_io_putc(tfp, SM_TIME_DEFAULT, 'D');
			(void) sm_io_putc(tfp, SM_TIME_DEFAULT, 'A');
		(void) sm_io_putc(tfp, SM_TIME_DEFAULT, ':');
				     denlstring(q->q_paddr, true, false));
			char *tag = "queued";
				tag = "quarantined";
			e->e_to = q->q_paddr;
			message(tag);
					    tag, NULL, (time_t) 0, e);
			e->e_to = NULL;
			sm_dprintf("queueing ");
			printaddr(sm_debug_file(), q, false);
	memset((char *) &nullmailer, '\0', sizeof(nullmailer));
			nullmailer.m_se_rwset = nullmailer.m_sh_rwset = -1;
	nullmailer.m_eol = "\n";
	memset(&mcibuf, '\0', sizeof(mcibuf));
	mcibuf.mci_mailer = &nullmailer;
	mcibuf.mci_out = tfp;
	macdefine(&e->e_macro, A_PERM, 'g', "\201f");
			continue;
			continue;
			(void) expand(h->h_value, buf, sizeof(buf), e);
				continue;
				continue;
		(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "H?");
						      macname(bitidx(h->h_macro)));
						     "$%c", h->h_macro);
			int j;
							  j);
		(void) sm_io_putc(tfp, SM_TIME_DEFAULT, '?');
					     denlstring(buf, false, true));
			bool oldstyle = bitset(EF_OLDSTYLE, e->e_flags);
			SM_FILE_T *savetrace = TrafficLogFile;
			TrafficLogFile = NULL;
				oldstyle = false;
				 PXLF_HEADER);
			TrafficLogFile = savetrace;
							true));
	(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, ".\n");
			syserr("!552 Error writing control file %s", tf);
			syserr("!452 Error writing control file %s", tf);
		char new = queue_letter(e, ANYQFL_LETTER);
				  sizeof(qf));
				tf, qf, (int) geteuid());
						   e->e_qfletter, new);
							  sm_errstring(errno));
		e->e_qfletter = new;
				       tf);
			SYNC_DIR(qf, true);
			(void) sm_io_close(e->e_lockfp, SM_TIME_DEFAULT);
		e->e_lockfp = tfp;
			sm_syslog(LOG_DEBUG, e->e_id, "queueup %s", qf);
			sm_syslog(LOG_DEBUG, e->e_id, "queueup %s", tf);
		e->e_qfletter = queue_letter(e, ANYQFL_LETTER);
	errno = 0;
	e->e_flags |= EF_INQUEUE;
		sm_dprintf("<<<<< done queueing %s <<<<<\n\n", e->e_id);
	register ADDRESS *a;
	SM_FILE_T *tfp;
	char *user;
	register ADDRESS *q;
	uid_t uid;
	gid_t gid;
	static ADDRESS *lastctladdr = NULL;
	static uid_t lastuid;
			(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "C\n");
		lastctladdr = NULL;
		lastuid = 0;
	q = getctladdr(a);
		user = NULL;
		uid = 0;
		gid = 0;
		user = q->q_ruser != NULL ? q->q_ruser : q->q_user;
		uid = q->q_uid;
		gid = q->q_gid;
	a = a->q_alias;
	lastuid = uid;
	lastctladdr = a;
		(void) sm_io_fprintf(tfp, SM_TIME_DEFAULT, "C");
				     (long) gid);
			     denlstring(a->q_paddr, true, false));
static bool		volatile NoMoreRunners = false;
static sigfunc_t	Oldsh_term = SIG_DFL;
static sigfunc_t	Oldsh_hup = SIG_DFL;
static sigfunc_t	volatile Oldsh = SIG_DFL;
static bool		BlockOldsh = false;
static int		volatile Oldsig = 0;
static SIGFUNC_DECL	runners_sigterm __P((int));
static SIGFUNC_DECL	runners_sighup __P((int));
	int sig;
	int save_errno = errno;
	FIX_SYSV_SIGNAL(sig, runners_sigterm);
	errno = save_errno;
	CHECK_CRITICAL(sig);
	NoMoreRunners = true;
	Oldsh = Oldsh_term;
	Oldsig = sig;
	proc_list_signal(PROC_QUEUE, sig);
			(*Oldsh_term)(sig);
	errno = save_errno;
	int sig;
	int save_errno = errno;
	FIX_SYSV_SIGNAL(sig, runners_sighup);
	errno = save_errno;
	CHECK_CRITICAL(sig);
	NoMoreRunners = true;
	Oldsh = Oldsh_hup;
	Oldsig = sig;
	proc_list_signal(PROC_QUEUE, sig);
			(*Oldsh_hup)(sig);
	errno = save_errno;
	int wgrp;
	int reason;
	WorkGrp[wgrp].wg_restart = reason;
		RestartWorkGroup = true;
	int i;
	int wasblocked;
	wasblocked = sm_blocksignal(SIGCHLD);
					  i, WorkGrp[i].wg_restart);
			restart_work_group(i);
	RestartWorkGroup = false;
		(void) sm_releasesignal(SIGCHLD);
	int wgrp;
	WorkGrp[wgrp].wg_restart = -1;
		WorkGrp[wgrp].wg_restartcnt++;
		(void) run_work_group(wgrp, RWG_FORK|RWG_PERSISTENT|RWG_RUNALL);
			  wgrp);
	bool runall;
	int wgrp;
	bool didit;
	int qgrp, cgrp, endgrp;
	time_t lastsched;
	bool sched;
	time_t now;
	time_t minqintvl;
	now = curtime();
	minqintvl = 0;
	cgrp = endgrp = WorkGrp[wgrp].wg_curqgrp;
		time_t qintvl;
		lastsched = 0;
		sched = false;
		qgrp = WorkGrp[wgrp].wg_qgs[cgrp]->qg_index;
			qintvl = Queue[qgrp]->qg_queueintvl;
			qintvl = QueueIntvl;
			qintvl = (time_t) 0;
		lastsched = Queue[qgrp]->qg_nextrun;
			sched = true;
				minqintvl = qintvl;
				Queue[qgrp]->qg_nextrun += qintvl;
				Queue[qgrp]->qg_nextrun, sched);
		INCR_MOD(cgrp, WorkGrp[wgrp].wg_numqgrp);
		(void) sm_setevent(minqintvl, runqueueevent, 0);
	int qgrp;
	time_t now, minqintvl;
	now = curtime();
	minqintvl = 0;
		time_t qintvl;
			qintvl = Queue[qgrp]->qg_queueintvl;
			qintvl = QueueIntvl;
			qintvl = (time_t) 0;
				minqintvl = qintvl;
					qintvl);
		(void) sm_setevent(minqintvl, runqueueevent, 0);
	bool verbose;
	bool persistent;
	bool runall;
	int i;
	bool ret = true;
	static int curnum = 0;
	sigfunc_t cursh;
	SM_NONVOLATILE int oldgroup = 0;
		oldgroup = sm_heap_group();
		sm_heap_newgroup();
		sm_dprintf("runqueue() heap group #%d\n", sm_heap_group());
	DoQueueRun = false;
	cursh = sm_signal(SIGTERM, runners_sigterm);
		Oldsh_term = cursh;
	cursh = sm_signal(SIGHUP, runners_sighup);
		Oldsh_hup = cursh;
		int rwgflags = RWG_NONE;
				WorkGrp[curnum].wg_maxact);
			break;
		CurRunners += WorkGrp[curnum].wg_maxact;
			rwgflags |= RWG_FORK;
			rwgflags |= RWG_VERBOSE;
			rwgflags |= RWG_PERSISTENT;
			rwgflags |= RWG_RUNALL;
		ret = run_work_group(curnum, rwgflags);
			CurRunners -= WorkGrp[curnum].wg_maxact;
			break;
			schedule_queue_runs(runall, curnum, true);
		INCR_MOD(curnum, NumWorkGroups);
		int h;
			schedule_queue_runs(runall, h, false);
			INCR_MOD(h, NumWorkGroups);
		sm_heap_setgroup(oldgroup);
	int skip;
	int n, seqjump;
					n++;
					     n++;
		WorkQ = WorkQ->w_next;
	register ENVELOPE *e;
	int sequenceno;
	int skip;
	int njobs;
	int n, seqjump;
	WORK *w;
	time_t now;
	SM_GET_LA(now);
	BlockOldsh = true;
	seqjump = skip;
		SM_NONVOLATILE int oldgroup = 0;
			oldgroup = sm_heap_group();
			sm_heap_newgroup();
				sm_heap_group());
				(*Oldsh)(Oldsig);
			break;
			seqjump = 1;
						seqjump = skip_domains(skip);
						WorkQ = WorkQ->w_next;
						seqjump = skip_domains(skip);
						WorkQ = WorkQ->w_next;
				WorkQ = WorkQ->w_next;
				WorkQ = WorkQ->w_next;
		e->e_to = NULL;
		SM_GET_LA(now);
			char *msg = "Aborting queue run: load average too high";
				message("%s", msg);
				sm_syslog(LOG_INFO, NOQID, "runqueue: %s", msg);
			break;
				message(EmptyString);
						njobs);
						  njobs);
				break;
					w->w_name + 2, sequenceno, njobs);
				message(EmptyString);
					w->w_name + 2, sequenceno, njobs);
				sm_blocksignal(SIGCHLD);
				(void) sm_signal(SIGCHLD, reapchild);
					  w->w_name + 2);
				      ForkQueueRuns, false, e);
			errno = 0;
			sm_heap_setgroup(oldgroup);
	BlockOldsh = false;
			(*Oldsh)(Oldsig);
	int wgrp;
	int flags;
	register ENVELOPE *e;
	int njobs, qdir;
	int sequenceno = 1;
	int qgrp, endgrp, h, i;
	time_t now;
	bool full, more;
	SM_RPOOL_T *rpool;
	extern ENVELOPE BlankEnvelope;
	extern SIGFUNC_DECL reapchild __P((int));
	SM_GET_LA(now);
		char *msg = "Skipping queue run -- load average too high";
			message("458 %s\n", msg);
			sm_syslog(LOG_INFO, NOQID, "runqueue: %s", msg);
		char *msg = "Skipping queue run -- too many children";
			message("458 %s (%d)\n", msg, CurChildren);
				  msg, CurChildren);
		pid_t pid;
		(void) sm_blocksignal(SIGCHLD);
		(void) sm_signal(SIGCHLD, reapchild);
			const char *err = sm_errstring(errno);
				message("458 %s: %s\n", msg, err);
					  msg, err);
			(void) sm_releasesignal(SIGCHLD);
			(void) sm_blocksignal(SIGALRM);
				      NULL);
			(void) sm_releasesignal(SIGALRM);
			(void) sm_releasesignal(SIGCHLD);
		RestartRequest = NULL;
		RestartWorkGroup = false;
		ShutdownRequest = NULL;
		PendingSignal = 0;
		CurrentPid = getpid();
		close_sendmail_pid();
		sm_exc_newthread(fatal_error);
		clrcontrol();
		proc_list_clear();
			      PROC_QUEUE_CHILD, 0, -1, NULL);
		(void) sm_releasesignal(SIGCHLD);
		(void) sm_signal(SIGCHLD, SIG_DFL);
		(void) sm_signal(SIGHUP, SIG_DFL);
		(void) sm_signal(SIGTERM, intsig);
	clrdaemon();
	NoConnect = false;
		(void) drop_privileges(false);
	CurEnv = &QueueEnvelope;
	rpool = sm_rpool_new_x(NULL);
	e = newenvelope(&QueueEnvelope, CurEnv, rpool);
	e->e_flags = BlankEnvelope.e_flags;
	e->e_parent = NULL;
		disconnect(1, e);
		QuickAbort = false;
		IgnoreHostStatus = true;
		MinQueueAge = 0;
	now = curtime();
		qgrp = WorkGrp[wgrp].wg_qgs[WorkGrp[wgrp].wg_curqgrp]->qg_index;
			break;
			e->e_id = NULL;
				finis(true, true, ExitStat);
			WorkGrp[wgrp].wg_curqgrp, WorkGrp[wgrp].wg_numqgrp);
		(void) nice(Queue[qgrp]->qg_nice);
			qid_printqueue(qgrp, qdir));
			  bitset(RWG_FORK, flags));
		(void) gatherq(qgrp, qdir, false, &full, &more, &h);
			QSHM_ENTRIES(Queue[qgrp]->qg_qpaths[qdir].qp_idx) = h;
			qdir++;
			qdir %= Queue[qgrp]->qg_numqueues;
	njobs = sortq(Queue[qgrp]->qg_maxlist);
		int loop, maxrunners;
		pid_t pid;
		maxrunners = Queue[qgrp]->qg_maxqrun;
			maxrunners = 1;
			maxrunners = njobs;
			closemaps(false);
				mci_flush(false, NULL);
					sequenceno += skip_domains(1);
					WorkQ = WorkQ->w_next;
					sequenceno++;
					      PROC_QUEUE_CHILD, 0, -1, NULL);
					break;
				RestartRequest = NULL;
				RestartWorkGroup = false;
				ShutdownRequest = NULL;
				PendingSignal = 0;
				CurrentPid = getpid();
				close_sendmail_pid();
				sm_exc_newthread(fatal_error);
					proc_list_clear();
					sm_releasesignal(SIGCHLD);
					(void) sm_signal(SIGCHLD, SIG_DFL);
				QuickAbort = OnlyOneError = false;
					    maxrunners, njobs);
				finis(true, true, ExitStat);
		sm_releasesignal(SIGCHLD);
			int status;
			pid_t ret;
				continue;
			proc_list_drop(ret, status, NULL);
		runner_work(e, sequenceno, false, 1, njobs);
	sm_rpool_free(rpool);
	QueueEnvelope.e_rpool = NULL;
		rpool = sm_rpool_new_x(NULL);
		e = newenvelope(&QueueEnvelope, CurEnv, rpool);
		e->e_flags = BlankEnvelope.e_flags;
		goto domorework;
		sequenceno = 1;
				qid_printqueue(qgrp, qdir));
		closemaps(true);
		mci_flush(true, NULL);
		rmexpstab();
			(void) getfallbackmxrr(FallbackMX);
		_udbx_close();
			SM_FILE_T *out;
			remove("memdump");
					 "memdump.out", SM_IO_APPEND, NULL);
				(void) sm_io_fprintf(out, SM_TIME_DEFAULT, "----------------------\n");
					sm_debug_level(&SmHeapCheck) - 1);
				(void) sm_io_close(out, SM_TIME_DEFAULT);
			sleep(MIN_SLEEP_TIME);
			sleep(QueueIntvl > 0 ? QueueIntvl : MIN_SLEEP_TIME);
			sleep(WorkGrp[wgrp].wg_lowqintvl);
			SM_GET_LA(now);
		rpool = sm_rpool_new_x(NULL);
		e = newenvelope(&QueueEnvelope, CurEnv, rpool);
		e->e_flags = BlankEnvelope.e_flags;
		goto domorework;
	e->e_id = NULL;
		finis(true, true, ExitStat);
	int ignore;
	int save_errno = errno;
	DoQueueRun = true;
		sm_syslog(LOG_INFO, NOQID, "rqe: done");
	errno = save_errno;
		errno = ETIMEDOUT;
	int qgrp;
	int qdir;
	bool doall;
	bool *full;
	bool *more;
	int *pnentries;
	register struct dirent *d;
	register WORK *w;
	register char *p;
	DIR *f;
	int i, num_ent, wn, nentries;
	QUEUE_CHAR *check;
	char qd[MAXPATHLEN];
	char qf[MAXPATHLEN];
	wn = WorkListCount - 1;
	num_ent = 0;
	nentries = 0;
		(void) sm_strlcpy(qd, ".", sizeof(qd));
					? "/qf" : ""));
		sm_dprintf("gatherq:\n");
		check = QueueLimitId;
				check->queue_match);
			check = check->queue_next;
		check = QueueLimitSender;
				check->queue_match);
			check = check->queue_next;
		check = QueueLimitRecipient;
				check->queue_match);
			check = check->queue_next;
			check = QueueLimitQuarantine;
					   check->queue_match);
				check = check->queue_next;
	f = opendir(qd);
			qid_printqueue(qgrp, qdir));
			*full = WorkListCount >= MaxQueueRun && MaxQueueRun > 0;
			*more = false;
		SM_FILE_T *cf;
		int qfver = 0;
		char lbuf[MAXNAME + 1];
			sm_dprintf("gatherq: checking %s..", d->d_name);
				sm_dprintf("  skipping\n");
			continue;
			sm_dprintf("\n");
						     d->d_name, MAXQFNAME);
					  d->d_name, MAXQFNAME);
			continue;
		++nentries;
		check = QueueLimitId;
				break;
				check = check->queue_next;
			continue;
					  MaxQueueRun);
			break;
			grow_wlist(qgrp, qdir);
				continue;
		SM_ASSERT(wn >= 0);
		w = &WorkList[wn];
		(void) sm_strlcpyn(qf, sizeof(qf), 3, qd, "/", d->d_name);
					  d->d_name);
			wn--;
			continue;
				       qid_printqueue(qgrp, qdir), d->d_name);
			wn--;
			continue;
			w->w_qgrp = qgrp;
			w->w_qdir = qdir;
			w->w_name = newstr(d->d_name);
			w->w_host = NULL;
			w->w_lock = w->w_tooyoung = false;
			w->w_pri = 0;
			w->w_ctime = 0;
			w->w_mtime = sbuf.st_mtime;
			++num_ent;
			continue;
				NULL);
					d->d_name, sm_errstring(errno));
			errno = 0;
			wn--;
			continue;
		w->w_qgrp = qgrp;
		w->w_qdir = qdir;
		w->w_name = newstr(d->d_name);
		w->w_host = NULL;
					      LOCK_SH|LOCK_NB);
		w->w_tooyoung = false;
		w->w_pri = 0x7fffffff;
		w->w_ctime = 0;
		w->w_mtime = sbuf.st_mtime;
		i = NEED_P|NEED_T;
			i |= NEED_H;
			i |= NEED_S;
			i |= NEED_R;
			i |= NEED_QUARANTINE;
			int c;
			time_t age;
			p = strchr(lbuf, '\n');
				*p = '\0';
					continue;
				qfver = atoi(&lbuf[1]);
				break;
				w->w_pri = atol(&lbuf[1]);
				i &= ~NEED_P;
				break;
				w->w_ctime = atol(&lbuf[1]);
				i &= ~NEED_T;
				break;
							   w->w_name);
					i |= HAS_QUARANTINE;
						i &= ~NEED_QUARANTINE;
						break;
					p = &lbuf[1];
					check = QueueLimitQuarantine;
							break;
							check = check->queue_next;
						i &= ~NEED_QUARANTINE;
				break;
						w->w_host = newstr(&p[1]);
						w->w_host = strrev(&p[1]);
					makelower(w->w_host);
					i &= ~NEED_H;
					i &= ~NEED_R;
					break;
					p = strchr(&lbuf[1], ':');
						p = &lbuf[1];
					p = &lbuf[1];
				check = QueueLimitRecipient;
						break;
						check = check->queue_next;
					i &= ~NEED_R;
				break;
				check = QueueLimitSender;
						break;
						check = check->queue_next;
					i &= ~NEED_S;
				break;
					time_t lasttry, delay;
					lasttry = (time_t) atol(&lbuf[1]);
						    MaxQueueAge);
					age = curtime() - lasttry;
						w->w_tooyoung = true;
					break;
				age = curtime() - (time_t) atol(&lbuf[1]);
					w->w_tooyoung = true;
				break;
					w->w_tooyoung = false;
				break;
			(void) sm_io_close(cf, SM_TIME_DEFAULT);
				sm_dprintf("skipping %s (%x)\n", w->w_name, i);
			wn--;
			++num_ent;
	(void) closedir(f);
	wn++;
	i = wn - WorkListCount;
	WorkListCount += SM_MIN(num_ent, WorkListSize);
		*more = WorkListCount < wn;
			(WorkList == NULL && wn > 0);
		*pnentries = nentries;
	int max;
		WORK *nw;
			nw = w->w_next;
		WorkQ = NULL;
		qsort((char *) WorkList, wc, sizeof(*WorkList), workcmpf1);
		i = 0;
				i++;
				continue;
			w = &WorkList[i];
					WorkList[i].w_lock = true;
					WorkList[i].w_lock = true;
					break;
		qsort((char *) WorkList, wc, sizeof(*WorkList), workcmpf2);
		qsort((char *) WorkList, wc, sizeof(*WorkList), workcmpf3);
		qsort((char *) WorkList, wc, sizeof(*WorkList), workcmpf4);
		randi = get_rand_mod(MAXQFNAME);
			randi = 3;
		qsort((char *) WorkList, wc, sizeof(*WorkList), workcmpf5);
		qsort((char *) WorkList, wc, sizeof(*WorkList), workcmpf6);
		init_shuffle_alphabet();
		qsort((char *) WorkList, wc, sizeof(*WorkList), workcmpf7);
		qsort((char *) WorkList, wc, sizeof(*WorkList), workcmpf0);
		wc = max;
		w = (WORK *) xalloc(sizeof(*w));
		w->w_qgrp = WorkList[i].w_qgrp;
		w->w_qdir = WorkList[i].w_qdir;
		w->w_name = WorkList[i].w_name;
		w->w_host = WorkList[i].w_host;
		w->w_lock = WorkList[i].w_lock;
		w->w_tooyoung = WorkList[i].w_tooyoung;
		w->w_pri = WorkList[i].w_pri;
		w->w_ctime = WorkList[i].w_ctime;
		w->w_mtime = WorkList[i].w_mtime;
		w->w_next = WorkQ;
		WorkQ = w;
		sm_free(WorkList[i].w_name);
			sm_free(WorkList[i].w_host);
	WorkList = NULL;
	WorkListSize = 0;
	WorkListCount = 0;
					w->w_name, w->w_pri, w->w_host);
					w->w_name, w->w_pri);
	int qgrp;
	int qdir;
		sm_dprintf("grow_wlist: WorkListSize=%d\n", WorkListSize);
					   (QUEUESEGSIZE + 1));
		WorkListSize = QUEUESEGSIZE;
		int newsize = WorkListSize + QUEUESEGSIZE;
					  (unsigned) sizeof(WORK) * (newsize + 1));
			WorkListSize = newsize;
			WorkList = newlist;
					  WorkListSize);
				  qid_printqueue(qgrp, qdir), newsize);
		sm_dprintf("grow_wlist: WorkListSize now %d\n", WorkListSize);
	register WORK *a;
	register WORK *b;
	long pa = a->w_pri;
	long pb = b->w_pri;
	register WORK *a;
	register WORK *b;
	int i;
	register WORK *a;
	register WORK *b;
	int i;
	register WORK *a;
	register WORK *b;
	register WORK *a;
	register WORK *b;
	register WORK *a;
	register WORK *b;
	register WORK *a;
	register WORK *b;
	register WORK *a;
	register WORK *b;
	int i;
	char *fwd;
	char *rev = NULL;
	int len, cnt;
	len = strlen(fwd);
	rev = xalloc(len + 1);
		rev[cnt] = fwd[len - cnt - 1];
	rev[len] = '\0';
static unsigned char ShuffledAlphabet[NCHAR];
	static bool init = false;
	int i;
		ShuffledAlphabet[i] = i;
		register int j = get_random() % NASCII;
		register int tmp;
		tmp = ShuffledAlphabet[j];
		ShuffledAlphabet[j] = ShuffledAlphabet[i];
		ShuffledAlphabet[i] = tmp;
		ShuffledAlphabet[i] = ShuffledAlphabet[i + 'a' - 'A'];
		ShuffledAlphabet[i + NASCII] = ShuffledAlphabet[i];
	init = true;
	char *a;
	char *b;
	const unsigned char *us1 = (const unsigned char *) a;
	const unsigned char *us2 = (const unsigned char *) b;
	int qgrp;
	int qdir;
	char *id;
	bool requeueflag;
	register ENVELOPE *e;
	register pid_t pid;
	SM_RPOOL_T *rpool;
		sm_dprintf("dowork(%s/%s)\n", qid_printqueue(qgrp, qdir), id);
		closemaps(false);
			mci_flush(false, NULL);
			RestartRequest = NULL;
			RestartWorkGroup = false;
			ShutdownRequest = NULL;
			PendingSignal = 0;
			CurrentPid = getpid();
			sm_exc_newthread(fatal_error);
				proc_list_clear();
				sm_releasesignal(SIGCHLD);
				(void) sm_signal(SIGCHLD, SIG_DFL);
			QuickAbort = OnlyOneError = false;
		pid = 0;
			RestartRequest = NULL;
			RestartWorkGroup = false;
			ShutdownRequest = NULL;
			PendingSignal = 0;
		sm_clear_events();
		clearstats();
		rpool = sm_rpool_new_x(NULL);
		clearenvelope(e, false, rpool);
		e->e_flags |= EF_QUEUERUN|EF_GLOBALERRS;
		set_delivery_mode(SM_DELIVER, e);
		e->e_errormode = EM_MAIL;
		e->e_id = id;
		e->e_qgrp = qgrp;
		e->e_qdir = qdir;
		GrabTo = UseErrorsTo = false;
		ExitStat = EX_OK;
			disconnect(1, e);
			set_op_mode(MD_QUEUERUN);
		sm_setproctitle(true, e, "%s from queue", qid_printname(e));
				  (int) CurrentPid);
		e->e_header = NULL;
					qid_printname(e));
			e->e_id = NULL;
				finis(false, true, EX_OK);
				clearenvelope(e, false, rpool);
				sm_rpool_free(rpool);
				e->e_rpool = NULL;
		e->e_flags |= EF_INQUEUE;
		eatheader(e, requeueflag, true);
			queueup(e, false, false);
		sendall(e, SM_DELIVER);
			finis(true, true, ExitStat);
			(void) dropenvelope(e, true, false);
			sm_rpool_free(rpool);
			e->e_rpool = NULL;
	e->e_id = NULL;
	ENVELOPE *el;
	bool requeueflag;
	register pid_t pid;
	ENVELOPE *ei;
		sm_dprintf("doworklist()\n");
		closemaps(false);
			mci_flush(false, NULL);
			RestartRequest = NULL;
			RestartWorkGroup = false;
			ShutdownRequest = NULL;
			PendingSignal = 0;
			CurrentPid = getpid();
			sm_exc_newthread(fatal_error);
				proc_list_clear();
				sm_releasesignal(SIGCHLD);
				(void) sm_signal(SIGCHLD, SIG_DFL);
			QuickAbort = OnlyOneError = false;
		pid = 0;
		RestartRequest = NULL;
		RestartWorkGroup = false;
		ShutdownRequest = NULL;
		PendingSignal = 0;
	sm_clear_events();
	clearstats();
	GrabTo = UseErrorsTo = false;
	ExitStat = EX_OK;
		disconnect(1, el);
		set_op_mode(MD_QUEUERUN);
			  (int) CurrentPid);
		ENVELOPE e;
		SM_RPOOL_T *rpool;
			continue;
			continue;
		rpool = sm_rpool_new_x(NULL);
		clearenvelope(&e, true, rpool);
		e.e_flags |= EF_QUEUERUN|EF_GLOBALERRS;
		set_delivery_mode(SM_DELIVER, &e);
		e.e_errormode = EM_MAIL;
		e.e_id = ei->e_id;
		e.e_qgrp = ei->e_qgrp;
		e.e_qdir = ei->e_qdir;
		openxscript(&e);
		sm_setproctitle(true, &e, "%s from queue", qid_printname(&e));
		e.e_header = NULL;
		CurEnv = &e;
			e.e_flags |= EF_INQUEUE;
			eatheader(&e, requeueflag, true);
				queueup(&e, false, false);
			sendall(&e, SM_DELIVER);
			(void) dropenvelope(&e, true, false);
					qid_printname(&e));
		sm_rpool_free(rpool);
		ei->e_id = NULL;
	CurEnv = el;
		finis(true, true, ExitStat);
	register ENVELOPE *e;
	bool openonly;
	register SM_FILE_T *qfp;
	ADDRESS *ctladdr;
	char *bp;
	int qfver = 0;
	long hdrsize = 0;
	register char *p;
	char *frcpt = NULL;
	char *orcpt = NULL;
	bool nomore = false;
	bool bogus = false;
	MODE_T qsafe;
	char *err;
	char qf[MAXPATHLEN];
	char buf[MAXLINE];
	int bufsize;
	SM_REQUIRE(e != NULL);
	bp = NULL;
	(void) sm_strlcpy(qf, queuename(e, ANYQFL_LETTER), sizeof(qf));
	qfp = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, qf, SM_IO_RDWR_B, NULL);
		int save_errno = errno;
				qf, sm_errstring(errno));
		errno = save_errno;
			syserr("readqf: no control file %s", qf);
		RELEASE_QUEUE;
					     "%s: locked\n", e->e_id);
			sm_dprintf("%s: locked\n", e->e_id);
			sm_syslog(LOG_DEBUG, e->e_id, "locked");
		(void) sm_io_close(qfp, SM_TIME_DEFAULT);
		RELEASE_QUEUE;
	RELEASE_QUEUE;
	**  Process A: lockfile(qf);
				qf, sm_errstring(errno));
		(void) sm_io_close(qfp, SM_TIME_DEFAULT);
					     "%s: changed\n", e->e_id);
			sm_dprintf("%s: changed\n", e->e_id);
			sm_syslog(LOG_DEBUG, e->e_id, "changed");
		(void) sm_io_close(qfp, SM_TIME_DEFAULT);
	qsafe = S_IWOTH|S_IWGRP;
		qsafe &= ~S_IWGRP;
		geteuid() != RealUid;
		char delim;
		bp = SM_LAST_DIR_DELIM(qf);
			delim = '\0';
			delim = *bp;
			*bp = '\0';
				delim == '\0' ? "." : qf);
				  dst.st_gid == st.st_gid);
			*bp = delim;
		bp = NULL;
		bogus = bitset(qsafe, st.st_mode);
				  st.st_uid, st.st_gid, st.st_mode);
			sm_dprintf("readqf(%s): bogus file\n", qf);
		e->e_flags |= EF_INQUEUE;
			loseqfile(e, "bogus file uid/gid in mqueue");
		(void) sm_io_close(qfp, SM_TIME_DEFAULT);
			(void) xunlink(queuename(e, DATAFL_LETTER));
			(void) xunlink(queuename(e, ANYQFL_LETTER));
		(void) sm_io_close(qfp, SM_TIME_DEFAULT);
		(void) sm_io_close(qfp, SM_TIME_DEFAULT);
		e->e_flags |= EF_UNSAFE;
		e->e_flags |= EF_UNSAFE;
	e->e_lockfp = qfp;
	initsys(e);
	macdefine(&e->e_macro, A_PERM, 'i', e->e_id);
	LineNumber = 0;
	e->e_flags |= EF_GLOBALERRS;
	set_op_mode(MD_QUEUERUN);
	ctladdr = NULL;
	e->e_qfletter = queue_letter(e, ANYQFL_LETTER);
	e->e_dfqgrp = e->e_qgrp;
	e->e_dfqdir = e->e_qdir;
	e->e_dfino = -1;
	e->e_msgsize = -1;
		unsigned long qflags;
		ADDRESS *q;
		int r;
		time_t now;
		auto char *ep;
			sm_dprintf("+++++ %s\n", bp);
			       bp);
			err = "bogus queue line";
			goto fail;
				goto hackattack;
			e->e_auth_param = sm_rpool_strdup_x(e->e_rpool, &bp[1]);
			break;
			r = check_bodytype(&bp[1]);
				goto hackattack;
			e->e_bodytype = sm_rpool_strdup_x(e->e_rpool, &bp[1]);
			break;
			ctladdr = setctluser(&bp[1], qfver, e);
			break;
			break;
				int qgrp, qdir;
					goto hackattack;
				     qgrp < NumQueue && Queue[qgrp] != NULL;
					     qdir < Queue[qgrp]->qg_numqueues;
							e->e_dfqgrp = qgrp;
							e->e_dfqdir = qdir;
							goto done;
				err = "bogus queue file directory";
				goto fail;
				break;
			break;
				syserr("SECURITY ALERT: bogus qf line %s", bp);
				err = "bogus queue line";
				goto fail;
					e->e_flags |= EF_HAS8BIT;
					break;
					e->e_flags |= EF_DELETE_BCC;
					break;
					e->e_flags |= EF_RET_PARAM;
					break;
					e->e_flags |= EF_NO_BODY_RETN;
					break;
					e->e_flags |= EF_RESPONSE;
					break;
					e->e_flags |= EF_SPLIT;
					break;
					e->e_flags |= EF_WARNING;
					break;
			break;
			e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool, &bp[1]);
			hdrsize += strlen(bp) - 3;
			(void) chompheader(&bp[1], CHHDR_QUEUE, NULL, e);
			break;
			break;
			e->e_dtime = atol(&buf[1]);
			break;
			break;
			e->e_ntries = atoi(&buf[1]);
			now = curtime();
				char *howlong;
				howlong = pintvl(now - e->e_dtime, true);
							     e->e_id, howlong);
						e->e_id, howlong);
						  howlong);
				e->e_id = NULL;
				unlockqueue(e);
					sm_free(bp);
				_res.retry = TimeOuts.res_retry[RES_TO_FIRST];
				_res.retrans = TimeOuts.res_retrans[RES_TO_FIRST];
				_res.retry = TimeOuts.res_retry[RES_TO_NORMAL];
				_res.retrans = TimeOuts.res_retrans[RES_TO_NORMAL];
			break;
			e->e_msgpriority = atol(&bp[1]) + WkTimeFact;
			break;
			orcpt = sm_rpool_strdup_x(e->e_rpool, &bp[1]);
			break;
			frcpt = sm_rpool_strdup_x(e->e_rpool, &bp[1]);
			break;
			p = bp;
			qflags = 0;
						qflags |= QHASNOTIFY;
						break;
						qflags |= QPINGONSUCCESS;
						break;
						qflags |= QPINGONFAILURE;
						break;
						qflags |= QPINGONDELAY;
						break;
						qflags |= QPRIMARY;
						break;
							ctladdr->q_flags |= QALIAS;
						break;
						break;
				qflags |= QPRIMARY;
						NULL, e, true);
				q = NULL;
					q->q_qgrp = e->e_qgrp;
				q->q_alias = ctladdr;
					q->q_flags &= ~Q_PINGFLAGS;
				q->q_flags |= qflags;
				q->q_finalrcpt = frcpt;
				q->q_orcpt = orcpt;
				(void) recipient(q, &e->e_sendqueue, 0, e);
			frcpt = NULL;
			orcpt = NULL;
			break;
				  e, NULL, '\0', true);
			break;
			e->e_ctime = atol(&bp[1]);
			break;
			qfver = atoi(&bp[1]);
				break;
				qfver, QF_VERSION);
			err = "unsupported queue file version";
			goto fail;
			break;
			e->e_envid = sm_rpool_strdup_x(e->e_rpool, &bp[1]);
			e->e_dlvr_flag = buf[1];
			e->e_deliver_by = strtol(&buf[3], NULL, 10);
				char *p;
				r = macid_parse(&bp[1], &ep);
					break;
				p = sm_rpool_strdup_x(e->e_rpool, ep);
				macdefine(&e->e_macro, A_PERM, r, p);
			break;
			nomore = true;
			break;
				break;
				qf, LineNumber, shortenstring(bp, MAXSHORTSTR));
			err = "unrecognized line";
			goto fail;
			SM_FREE(bp);
		errno = 0;
		e->e_flags |= EF_CLRQUEUE|EF_FATALERRS|EF_RESPONSE;
		syserr("readqf: %s: incomplete queue file read", qf);
		(void) sm_io_close(qfp, SM_TIME_DEFAULT);
		(void) sm_io_close(qfp, SM_TIME_DEFAULT);
	p = queuename(e, DATAFL_LETTER);
			      NULL);
		syserr("readqf: cannot open %s", p);
		e->e_flags |= EF_HAS_DF;
			e->e_msgsize = st.st_size + hdrsize;
			e->e_dfdev = st.st_dev;
			e->e_dfino = ST_INODE(st);
					   e->e_msgsize);
	**	hence it is invalid (as file) after qfp is closed;
		SM_FREE(bp);
		(void) sm_io_close(qfp, SM_TIME_DEFAULT);
	e->e_lockfp = NULL;
	e->e_flags |= EF_INQUEUE;
	loseqfile(e, err);
static void prtstr __P((char *, int));
	char *s;
	int ml;
	int c;
				(void) sm_io_putc(smioout, SM_TIME_DEFAULT, c);
				(void) sm_io_putc(smioout, SM_TIME_DEFAULT, c);
			(void) sm_io_putc(smioout, SM_TIME_DEFAULT, c);
						     "\\%03o", c & 0xFF);
	SM_FILE_T *out;
	char *prefix;
	int i, k = 0, nrequests = 0;
	bool unknown = false;
					"Data unavailable: shared memory not updated\n");
					"%sNOTCONFIGURED:-1\r\n", prefix);
		int j;
		k++;
			int n;
				stop_sendmail();
			n = QSHM_ENTRIES(Queue[i]->qg_qpaths[j].qp_idx);
					prefix, qid_printqueue(i, j), n);
					qid_printqueue(i, j));
				unknown = true;
					qid_printqueue(i, j));
					qid_printqueue(i, j), n);
				nrequests += n;
				k++;
				     nrequests, unknown ? " (about)" : "");
			     "Data unavailable without shared memory support\n");
			     "%sNOTAVAILABLE:-1\r\n", prefix);
	int i, k = 0, nrequests = 0;
		int j;
		k++;
				stop_sendmail();
			nrequests += print_single_queue(i, j);
			k++;
				     nrequests);
	int qgrp;
	int qdir;
	register WORK *w;
	SM_FILE_T *f;
	int nrequests;
	char qd[MAXPATHLEN];
	char qddf[MAXPATHLEN];
	char buf[MAXLINE];
		(void) sm_strlcpy(qd, ".", sizeof(qd));
		(void) sm_strlcpy(qddf, ".", sizeof(qddf));
					? "/qf" : ""));
					? "/df" : ""));
		int n;
		extern GIDSET_T InitialGidSet[NGROUPS_MAX];
				qid_printqueue(qgrp, qdir));
		n = NGROUPS_MAX;
				break;
			usrerr("510 You are not permitted to see the queue");
			setstat(EX_NOPERM);
	nrequests = gatherq(qgrp, qdir, true, NULL, NULL, NULL);
	(void) sortq(Queue[qgrp]->qg_maxlist);
				     qid_printqueue(qgrp, qdir));
			     nrequests, nrequests == 1 ? "" : "s");
				     ", only %d printed", MaxQueueRun);
			")\n-----Q-ID----- --Size-- -Priority- ---Q-Time--- --------Sender/Recipient--------\n");
			")\n-----Q-ID----- --Size-- -----Q-Time----- ------------Sender/Recipient-----------\n");
		auto time_t submittime = 0;
		long dfsize;
		int flags = 0;
		int qfver;
		char quarmsg[MAXLINE];
		char statmsg[MAXLINE];
		char bodytype[MAXNAME + 1];
		char qf[MAXPATHLEN];
			stop_sendmail();
				     w->w_name + 2);
		(void) sm_strlcpyn(qf, sizeof(qf), 3, qd, "/", w->w_name);
			       NULL);
						     " (permission denied)\n");
						     " (job completed)\n");
						     sm_errstring(errno));
			errno = 0;
			continue;
		w->w_name[0] = DATAFL_LETTER;
		(void) sm_strlcpyn(qf, sizeof(qf), 3, qddf, "/", w->w_name);
			dfsize = st.st_size;
			ENVELOPE e;
			newenvelope(&e, &BlankEnvelope, sm_rpool_new_x(NULL));
			e.e_id = w->w_name + 2;
			e.e_qgrp = qgrp;
			e.e_qdir = qdir;
			dfsize = -1;
				char *df = queuename(&e, DATAFL_LETTER);
					dfsize = st.st_size;
				(void) sm_io_close(e.e_lockfp, SM_TIME_DEFAULT);
				e.e_lockfp = NULL;
			clearenvelope(&e, false, e.e_rpool);
			sm_rpool_free(e.e_rpool);
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "*");
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "?");
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "-");
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "X");
			(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, " ");
		errno = 0;
		quarmsg[0] = '\0';
		statmsg[0] = bodytype[0] = '\0';
		qfver = 0;
			register int i;
			register char *p;
				stop_sendmail();
			fixcrlf(buf, true);
				qfver = atoi(&buf[1]);
				break;
					i = sizeof(statmsg) - 1;
				memmove(statmsg, &buf[1], i);
				statmsg[i] = '\0';
				break;
					i = sizeof(quarmsg) - 1;
				memmove(quarmsg, &buf[1], i);
				quarmsg[i] = '\0';
				break;
					i = sizeof(bodytype) - 1;
				memmove(bodytype, &buf[1], i);
				bodytype[i] = '\0';
				break;
						ctime(&submittime) + 4);
					prtstr(&buf[1], 78);
						ctime(&submittime));
					prtstr(&buf[1], 39);
							     quarmsg);
					quarmsg[0] = '\0';
						bodytype);
							statmsg);
					statmsg[0] = '\0';
				break;
						&buf[1]);
				break;
				p = &buf[1];
					p = strchr(p, ':');
						break;
					p++;
							"\n\t\t\t\t\t\t");
					prtstr(p, 71);
							"\n\t\t\t\t\t ");
					prtstr(p, 38);
							statmsg);
					statmsg[0] = '\0';
				break;
				submittime = atol(&buf[1]);
				break;
						flags |= EF_WARNING;
						break;
					     " (no control file)");
		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT, "\n");
		(void) sm_io_close(f, SM_TIME_DEFAULT);
	ENVELOPE *e;
	int type;
			type = QUARQF_LETTER;
				type = NORMQF_LETTER;
				break;
				type = QUARQF_LETTER;
				break;
				type = LOSEQF_LETTER;
				break;
				abort();
	register ENVELOPE *e;
	int type;
	int qd, qg;
	char *sub = "/";
	char pref[3];
	static char buf[MAXPATHLEN];
		assign_queueid(e);
	type = queue_letter(e, type);
	pref[0] = (char) type;
	pref[1] = 'f';
	pref[2] = '\0';
				e->e_xfqgrp = e->e_qgrp;
				e->e_xfqdir = e->e_qdir;
				e->e_xfqgrp = 0;
					e->e_xfqdir = 0;
					      Queue[e->e_xfqgrp]->qg_numqueues);
		qd = e->e_xfqdir;
		qg = e->e_xfqgrp;
			(void) setnewqueue(e);
			qd = e->e_dfqdir;
			qg = e->e_dfqgrp;
			qd = e->e_qdir;
			qg = e->e_qgrp;
		(void) sm_strlcpyn(buf, sizeof(buf), 2, pref, e->e_id);
				sub = "/df/";
			break;
				sub = "/qf/";
			break;
				sub = "/xf/";
			break;
			sm_abort("queuename: bad queue file type %d", type);
				sub, pref, e->e_id);
		sm_dprintf("queuename: %s\n", buf);
	LastQueueTime = 0;
	LastQueuePid = -1;
static const char QueueIdChars[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
	register ENVELOPE *e;
	pid_t pid = queuenextid();
	static unsigned int cX = 0;
	static unsigned int random_offset;
	char idbuf[MAXQFNAME - 2];
	unsigned int seq;
		time_t then = LastQueueTime;
					% QIC_LEN_SQR;
			(void) sleep(1);
		LastQueuePid = queuenextid();
		cX = 0;
	seq = (cX + random_offset) % QIC_LEN_SQR;
	++cX;
			random_offset, seq);
	tm = gmtime(&LastQueueTime);
	idbuf[0] = QueueIdChars[tm->tm_year % QIC_LEN];
	idbuf[1] = QueueIdChars[tm->tm_mon];
	idbuf[2] = QueueIdChars[tm->tm_mday];
	idbuf[3] = QueueIdChars[tm->tm_hour];
	idbuf[4] = QueueIdChars[tm->tm_min % QIC_LEN_R];
	idbuf[5] = QueueIdChars[tm->tm_sec % QIC_LEN_R];
	idbuf[6] = QueueIdChars[seq / QIC_LEN];
	idbuf[7] = QueueIdChars[seq % QIC_LEN];
			   (int) LastQueuePid);
	e->e_id = sm_rpool_strdup_x(e->e_rpool, idbuf);
	macdefine(&e->e_macro, A_PERM, 'i', e->e_id);
	e->e_qdir = NOQDIR;
	e->e_xfqgrp = NOQGRP;
	e->e_qfletter = '\0';
			e->e_id, e);
		sm_syslog(LOG_DEBUG, e->e_id, "assigned id");
		(void) sleep(1);
	ENVELOPE *e;
			e->e_id == NULL ? "NOQUEUE" : e->e_id);
		(void) sm_io_close(e->e_lockfp, SM_TIME_DEFAULT);
	e->e_lockfp = NULL;
		sm_syslog(LOG_DEBUG, e->e_id, "unlock");
		(void) xunlink(queuename(e, XSCRPT_LETTER));
	char *user;
	int qfver;
	ENVELOPE *e;
	register ADDRESS *a;
	char *p;
	a = (ADDRESS *) sm_rpool_malloc_x(e->e_rpool, sizeof(*a));
	memset((char *) a, '\0', sizeof(*a));
		p = &user[1];
		a->q_user = sm_rpool_strdup_x(e->e_rpool, p);
		p = strtok(user, ":");
		a->q_user = sm_rpool_strdup_x(e->e_rpool, user);
				a->q_uid = atoi(p);
				a->q_gid = atoi(p);
				char *o;
				a->q_flags |= QGOODUID;
					o[-1] = ':';
				a->q_home = NULL;
				a->q_home = "";
				a->q_home = sm_rpool_strdup_x(e->e_rpool, pw->pw_dir);
			a->q_uid = pw->pw_uid;
			a->q_gid = pw->pw_gid;
			a->q_flags |= QGOODUID;
	a->q_mailer = LocalMailer;
		a->q_paddr = sm_rpool_strdup_x(e->e_rpool, a->q_user);
		a->q_paddr = sm_rpool_strdup_x(e->e_rpool, p);
	register ENVELOPE *e;
	char *why;
	bool loseit = true;
	char *p;
	char buf[MAXPATHLEN];
	p = queuename(e, ANYQFL_LETTER);
		queueup(e, false, true);
		loseit = false;
		p = queuename(e, LOSEQF_LETTER);
			       buf, p, (int) geteuid());
				  "Losing %s: %s", buf, why);
		(void) sm_io_close(e->e_dfp, SM_TIME_DEFAULT);
		e->e_dfp = NULL;
	e->e_flags &= ~EF_HAS_DF;
	char *queuename;
	register STAB *s;
	s = stab(queuename, ST_QUEUE, ST_FIND);
	ENVELOPE *e;
	char *id;
	static char idbuf[MAXQFNAME + 34];
		id = "";
		id = e->e_id;
			   id);
	int qgrp;
	int qdir;
	char *subdir;
	static char dir[MAXPATHLEN];
		subdir = NULL;
		subdir = Queue[qgrp]->qg_qpaths[qdir].qp_name;
					? "/df" : ""));
	QUEUEGRP *qg;
	long fsize;
	ENVELOPE *e;
	int qdir;
	int i;
	long avail = 0;
		qdir = 0;
		qdir = get_rand_mod(qg->qg_numqueues);
	i = qdir;
		QPATHS *qp = &qg->qg_qpaths[i];
		long needed = 0;
		long fsavail = 0;
				      > 0) ? 1 : 0);
			needed += MinBlocksFree;
		fsavail = FILE_SYS_AVAIL(qp->qp_fsysidx);
			long blksize;
						&blksize);
				fsavail = 0;
			avail = fsavail;
			i = (i + 1) % qg->qg_numqueues;
			qg->qg_qdir, avail);
	ENVELOPE *e;
		sm_dprintf("setnewqueue: called\n");
		ADDRESS *q;
		q = e->e_sendqueue;
			q = q->q_next;
			e->e_qgrp = 0;
			e->e_qgrp = q->q_qgrp;
			e->e_qgrp = q->q_mailer->m_qgrp;
			e->e_qgrp = 0;
		e->e_dfqgrp = e->e_qgrp;
				qid_printqueue(e->e_qgrp, e->e_qdir));
	filesys_update();
	e->e_qdir = pickqdir(Queue[e->e_qgrp], e->e_msgsize, e);
		e->e_qgrp = NOQGRP;
			usrerr("452 4.4.5 Insufficient disk space; try again later");
		e->e_flags |= EF_FATALERRS;
			qid_printqueue(e->e_qgrp, e->e_qdir));
		e->e_xfqgrp = e->e_qgrp;
		e->e_xfqdir = e->e_qdir;
	e->e_dfqdir = e->e_qdir;
static bool chkqdir __P((char *, long));
	char *name;
	long sff;
	int i;
				   name, sm_errstring(errno));
					   name, sm_errstring(errno));
				name);
	i = safedirpath(name, RunAsUid, RunAsGid, NULL, sff, 0, 0);
				   name, sm_errstring(i));
				  name, sm_errstring(i));
	char *basedir;
	int blen;
	QUEUEGRP *qg;
	int qn;
	unsigned int *phash;
	char *cp;
	int i, len;
	int slotsleft = 0;
	long sff = SFF_ANYFILE;
	char qpath[MAXPATHLEN];
	char subdir[MAXPATHLEN];
		sm_dprintf("multiqueue_cache: called\n");
	prefix[0] = '.';
	prefix[1] = '\0';
		qg->qg_qpaths = NULL;
		qg->qg_numqueues = 0;
		sff |= SFF_ROOTOK;
	sff |= SFF_SAFEDIRPATH|SFF_NOWWFILES;
		sff |= SFF_NOGWFILES;
		syserr("QueuePath %s not absolute", qg->qg_qdir);
		ExitStat = EX_CONFIG;
	len = sm_strlcpy(qpath, qg->qg_qdir, sizeof(qpath));
		       qg->qg_qdir, (int) sizeof(qpath));
		ExitStat = EX_CONFIG;
			qpath, basedir);
		ExitStat = EX_CONFIG;
				qg->qg_qdir, (int) sizeof(qpath));
			ExitStat = EX_CONFIG;
		cp = SM_LAST_DIR_DELIM(prefix);
		SM_ASSERT(cp != NULL);
	SM_ASSERT(len >= blen - 1);
	cp = &qpath[len - 1];
		register DIR *dp;
		register struct dirent *d;
		int off;
		char *delim;
		char relpath[MAXPATHLEN];
			syserr("QueueDirectory: can not wildcard relative path");
					qpath);
			ExitStat = EX_CONFIG;
			(void) sm_strlcpy(qpath + 1, qpath, sizeof(qpath) - 1);
			++cp;
		delim = cp;
		off = sm_strlcpyn(relpath, sizeof(relpath), 2, prefix, "/");
		SM_ASSERT(off < sizeof(relpath));
				   relpath, cp);
		qg->qg_qdir = newstr(basedir);
					sff, 0, 0);
					   basedir, sm_errstring(i));
			syserr("can not opendir(%s/%s)", qg->qg_qdir, prefix);
					   sm_errstring(errno));
			ExitStat = EX_CONFIG;
				continue;
			i = strlen(d->d_name);
						d->d_name);
				continue;
			i = sizeof(relpath) - off;
				continue;
				slotsleft = INITIAL_SLOTS;
								slotsleft);
				qg->qg_numqueues = 0;
							   ADD_SLOTS));
					(void) closedir(dp);
				slotsleft += ADD_SLOTS;
			qg->qg_qpaths[qg->qg_numqueues].qp_subdirs = QP_NOSUB;
			CHKRSUBDIR("qf", QP_SUBQF);
			CHKRSUBDIR("df", QP_SUBDF);
			CHKRSUBDIR("xf", QP_SUBXF);
					newstr(relpath);
					newstr(d->d_name);
					qg->qg_qpaths[qg->qg_numqueues].qp_subdirs);
			qg->qg_qpaths[qg->qg_numqueues].qp_idx = qn;
			*phash = hash_q(relpath, *phash);
			qg->qg_numqueues++;
			++qn;
			slotsleft--;
		(void) closedir(dp);
		*delim = '/';
		qg->qg_qpaths = (QPATHS *) xalloc(sizeof(*qg->qg_qpaths));
		i = safedirpath(qpath, RunAsUid, RunAsGid, NULL, sff, 0, 0);
			syserr("can not opendir(%s)", qpath);
					   qpath, sm_errstring(i));
			ExitStat = EX_CONFIG;
		qg->qg_qpaths[0].qp_subdirs = QP_NOSUB;
		qg->qg_numqueues = 1;
		CHKSUBDIR("qf", QP_SUBQF);
		CHKSUBDIR("df", QP_SUBDF);
		CHKSUBDIR("xf", QP_SUBXF);
			qg->qg_qpaths[0].qp_name = newstr(qg->qg_qdir + blen);
			qg->qg_qdir[blen - 1] = '\0';
			qg->qg_qpaths[0].qp_name = newstr(".");
		qg->qg_qpaths[0].qp_idx = qn;
		*phash = hash_q(qg->qg_qpaths[0].qp_name, *phash);
		++qn;
static short filesys_find __P((const char *, const char *, bool));
	const char *name;
	const char *path;
	bool add;
	short i;
		syserr("cannot stat queue directory %s", path);
				FILE_SYS_NAME(i) = name;
		syserr("too many queue file systems (%d max)", MAXFILESYS);
	++NumFileSys;
	FILE_SYS_NAME(i) = name;
	FILE_SYS_DEV(i) = st.st_dev;
	FILE_SYS_AVAIL(i) = 0;
static int filesys_setup __P((bool));
	bool add;
	int i, j;
	short fs;
	int ret;
	ret = 0;
			QPATHS *qp = &Queue[i]->qg_qpaths[j];
			char qddf[MAXPATHLEN];
						? "/df" : ""));
			fs = filesys_find(qp->qp_name, qddf, add);
				qp->qp_fsysidx = fs;
				qp->qp_fsysidx = 0;
				ret = fs;
	int i;
	long avail, blksize;
	time_t now;
	static time_t nextupdate = 0;
	now = curtime();
	nextupdate = now + FILESYS_UPDATE_INTERVAL;
		FILESYS *fs = &FILE_SYS(i);
		avail = freediskspace(FILE_SYS_NAME(i), &blksize);
					FILE_SYS_NAME(i), avail, blksize);
			fs->fs_avail = 0;
			fs->fs_avail = avail;
			fs->fs_blksize = blksize;
	long fsize;
	int i;
		long needed = 0;
			continue;
			  + MinBlocksFree;
	SM_FILE_T *out;
	char *prefix;
	int i;
	long avail, blksize;
	long free;
		avail = freediskspace(FILE_SYS_NAME(i), &blksize);
				((double) blksize / 1024));
			free = -1;
					free);
int SemKey = SM_SEM_KEY;
static void init_sem __P((bool));
	bool owner;
	SemId = sm_sem_start(SemKey, 1, 0, owner);
			(long) SemKey, SemId, sm_errstring(-SemId));
		int r;
		r = sm_semsetowner(SemId, RunAsUid, RunAsGid, 0660);
				(long) SemKey, r, RunAsUid, RunAsGid);
static void stop_sem __P((bool));
	bool owner;
		sm_sem_stop(SemId);
	ENVELOPE *e;
	int count;
	int space;
	char *where;
	short fidx;
	int idx;
	int r;
	long s;
	idx = Queue[e->e_qgrp]->qg_qpaths[e->e_qdir].qp_idx;
			count, space, where, idx, QSHM_ENTRIES(idx));
		r = sm_sem_acq(SemId, 0, 1);
		QSHM_ENTRIES(idx) += count;
			r = sm_sem_rel(SemId, 0, 1);
	fidx = Queue[e->e_qgrp]->qg_qpaths[e->e_qdir].qp_fsysidx;
	s = e->e_msgsize / FILE_SYS_BLKSIZE(fidx);
		FILE_SYS_AVAIL(fidx) += s;
		FILE_SYS_AVAIL(fidx) -= s;
static bool write_key_file __P((char *, long));
static long read_key_file __P((char *, long));
	char *keypath;
	long key;
	bool ok;
	long sff;
	SM_FILE_T *keyf;
	ok = false;
	sff = SFF_NOLINK|SFF_ROOTOK|SFF_REGONLY|SFF_CREAT;
		sff |= SFF_OPENASROOT;
	keyf = safefopen(keypath, O_WRONLY|O_TRUNC, FileMode, sff);
			  keypath, sm_errstring(errno));
			int fd;
			fd = keyf->f_file;
				int err = errno;
					  keypath, RunAsUid, sm_errstring(err));
		     SM_IO_EOF;
		ok = (sm_io_close(keyf, SM_TIME_DEFAULT) != SM_IO_EOF) && ok;
	char *keypath;
	long key;
	int r;
	long sff, n;
	SM_FILE_T *keyf;
	sff = SFF_NOLINK|SFF_ROOTOK|SFF_REGONLY;
		sff |= SFF_OPENASROOT;
	keyf = safefopen(keypath, O_RDONLY, FileMode, sff);
			  keypath, sm_errstring(errno));
		r = sm_io_fscanf(keyf, SM_TIME_DEFAULT, "%ld", &n);
			key = n;
		(void) sm_io_close(keyf, SM_TIME_DEFAULT);
static void init_shm __P((int, bool, unsigned int));
	int qn;
	bool owner;
	unsigned int hash;
	int i;
	int count;
	int save_errno;
	bool keyselect;
	PtrFileSys = &FileSys[0];
	PNumFileSys = &Numfilesys;
	count = 0;
	shms = SM_T_SIZE + qn * sizeof(QUEUE_SHM_T);
	keyselect = ShmKey == SEL_SHM_KEY;
			ShmKey = FIRST_SHM_KEY;
			errno = 0;
			ShmKey = read_key_file(ShmKeyFile, ShmKey);
			keyselect = false;
				save_errno = (errno != 0) ? errno : EINVAL;
				goto error;
				&ShmId, owner);
		save_errno = errno;
			break;
				++ShmKey;
					break;
				continue;
			break;
			sleep(count);
		int *p;
			(void) write_key_file(ShmKeyFile, (long) ShmKey);
			i = sm_shmsetowner(ShmId, RunAsUid, RunAsGid, 0660);
					(long) ShmKey, i, RunAsUid, RunAsGid);
		p = (int *) Pshm;
			*p = (int) shms;
			*((pid_t *) SHM_OFF_PID(Pshm)) = CurrentPid;
			p = (int *) SHM_OFF_TAG(Pshm);
			*p = hash;
				save_errno = EINVAL;
				cleanup_shm(false);
				goto error;
			p = (int *) SHM_OFF_TAG(Pshm);
				save_errno = EINVAL;
				cleanup_shm(false);
				goto error;
		PtrFileSys = (FILESYS *) OFF_FILE_SYS(Pshm);
		PNumFileSys = (int *) OFF_NUM_FILE_SYS(Pshm);
		QShm = (QUEUE_SHM_T *) OFF_QUEUE_SHM(Pshm);
		PRSATmpCnt = (int *) OFF_RSA_TMP_CNT(Pshm);
		*PRSATmpCnt = 0;
			NumFileSys = 0;
				QShm[i].qs_entries = -1;
		init_sem(owner);
			  (long) ShmKey, sm_errstring(save_errno));
	bool owner;
	int i, qn, len;
	unsigned int hashval;
	time_t now;
	char basedir[MAXPATHLEN];
	hashval = 0;
	errno = 0;
	len = sm_strlcpy(basedir, QueueDir, sizeof(basedir));
			len, (int) sizeof(basedir) - 1);
		ExitStat = EX_CONFIG;
	SM_ASSERT(len > 0);
		char *cp;
		cp = SM_LAST_DIR_DELIM(basedir);
				QueueDir);
					QueueDir);
			ExitStat = EX_CONFIG;
		*++cp = '\0';
		len = cp - basedir;
		basedir[len] = '/';
		basedir[++len] = '\0';
	SM_ASSERT(basedir[len - 1] == '/');
		int save_errno = errno;
		syserr("can not chdir(%s)", basedir);
				"Program mode requires special privileges, e.g., root or TrustedUser.\n");
				   basedir, sm_errstring(errno));
		ExitStat = EX_CONFIG;
	hashval = hash_q(basedir, hashval);
	DoQueueRun = false;
	now = curtime();
		Queue[i]->qg_nextrun = now;
		long sff = SFF_CREAT;
			syserr("can not stat(%s)", basedir);
					   basedir, sm_errstring(errno));
			ExitStat = EX_CONFIG;
			sff |= SFF_ROOTOK;
				basedir, (int) RunAsGid, (int) st.st_gid);
				(int) st.st_mode, basedir);
					  (int) st.st_mode, basedir);
	qn = 0;
		qn = multiqueue_cache(basedir, len, Queue[i], qn, &hashval);
	init_shm(qn, owner, hashval);
	i = filesys_setup(owner || ShmId == SM_SHM_NO_ID);
		SM_ASSERT(!owner);
		i = filesys_setup(false);
			syserr("filesys_setup failed twice, result=%d", i);
				  "shared memory does not contain expected data, ignored");
	i = filesys_setup(true);
		ExitStat = EX_CONFIG;
	bool owner;
				  sm_errstring(errno));
		Pshm = NULL;
		ShmId = SM_SHM_NO_ID;
	stop_sem(owner);
	sync_queue_time();
	QUEUEGRP *qg;
	bool all;
		qg->qg_qdir = QueueDir;
	qg->qg_sortorder = QueueSortOrder;
	qg->qg_maxqrun = all ? MaxRunnersPerQueue : -1;
	qg->qg_nice = NiceQueueRun;
	char *line;
	bool qdef;
	register char *p;
	register QUEUEGRP *qg;
	register STAB *s;
	int i;
	char fcode;
	qg = (QUEUEGRP *) xalloc(sizeof(*qg));
	memset((char *) qg, '\0', sizeof(*qg));
	     *p != '\0' && *p != ',' && !(isascii(*p) && isspace(*p));
		continue;
		*p++ = '\0';
	qg->qg_name = newstr(line);
	set_def_queueval(qg, false);
		auto char *delimptr;
			p++;
		fcode = *p;
			p++;
			syserr("queue %s: `=' expected", qg->qg_name);
			p++;
		p = munchstring(p, &delimptr, ',');
					qg->qg_name);
				qg->qg_qdir = newstr(p);
			break;
					setbitn(*p, qg->qg_flags);
			break;
			qg->qg_queueintvl = convtime(p, 'm');
			break;
			qg->qg_nice = atoi(p);
			break;
			i = atoi(p);
				qg->qg_maxqrun = MaxQueueChildren;
						     MaxQueueChildren);
				qg->qg_maxqrun = i;
			break;
			qg->qg_maxlist = atoi(p);
			break;
			qg->qg_maxrcpt = atoi(p);
			break;
				qg->qg_sortorder = QSO_BYHOST;
				break;
				qg->qg_sortorder = QSO_BYPRIORITY;
				break;
				qg->qg_sortorder = QSO_BYTIME;
				break;
				qg->qg_sortorder = QSO_BYFILENAME;
				break;
				qg->qg_sortorder = QSO_BYMODTIME;
				break;
				qg->qg_sortorder = QSO_RANDOM;
				break;
				qg->qg_sortorder = QSO_BYSHUFFLE;
				break;
				qg->qg_sortorder = QSO_NONE;
				break;
				syserr("Invalid queue sort order \"%s\"", p);
			break;
			       qg->qg_name, fcode);
			break;
		p = delimptr;
				     qg->qg_name);
			MAXQUEUEGROUPS);
		qg->qg_qdir = newstr(QueueDir);
				     qg->qg_name, qg->qg_maxqrun, QD_FORK);
			  qg->qg_qdir);
	s = stab(qg->qg_name, ST_QUEUE, ST_ENTER);
		i = s->s_quegrp->qg_index;
		i = NumQueue++;
	Queue[i] = s->s_quegrp = qg;
	qg->qg_index = i;
			qg->qg_maxqrun = MaxRunnersPerQueue;
			qg->qg_maxqrun = 1;
		setbitn(QD_DEFINED, qg->qg_flags);
	register char *fqn;
	int buckets;
	register char *p;
	register int h = 0, hash, cnt;
	p = fqn;
	h = 0x238F13AF * strlen(p);
		h = (h + (*p << (cnt * 5 % 24))) & 0x7FFFFFFF;
	h = (1103515243 * h + 12345) & 0x7FFFFFFF;
		hash = 0;
		hash = (h % buckets);
};
static int cmpidx __P((const void *, const void *));
	const void *a;
	const void *b;
	int i, j, total_runners, dir, h;
	SORTQGRP_T si[MAXQUEUEGROUPS + 1];
	total_runners = 0;
		NumWorkGroups = 1;
		WorkGrp[0].wg_numqgrp = 1;
		WorkGrp[0].wg_qgs = (QUEUEGRP **) xalloc(sizeof(QUEUEGRP *));
		WorkGrp[0].wg_qgs[0] = Queue[0];
			WorkGrp[0].wg_runners = MaxQueueChildren;
			WorkGrp[0].wg_runners = Queue[0]->qg_numqueues;
		Queue[0]->qg_wgrp = 0;
			Queue[0]->qg_maxqrun = MaxQueueChildren;
		WorkGrp[0].wg_maxact = Queue[0]->qg_maxqrun;
		WorkGrp[0].wg_lowqintvl = Queue[0]->qg_queueintvl;
		si[i].sg_maxqrun = Queue[i]->qg_maxqrun;
		si[i].sg_idx = i;
	qsort(si, NumQueue, sizeof(si[0]), cmpidx);
	NumWorkGroups = 0;
		total_runners += si[i].sg_maxqrun;
			NumWorkGroups++;
			break;
	j = 0;
	dir = 1;
			dir = -1;
			j = NumWorkGroups - 1;
			j = 0;
			dir = 1;
							(WorkGrp[j].wg_numqgrp + 1));
							(WorkGrp[j].wg_numqgrp + 1));
				      (WorkGrp[j].wg_numqgrp + 1)));
		h = si[i].sg_idx;
		WorkGrp[j].wg_qgs[WorkGrp[j].wg_numqgrp] = Queue[h];
		WorkGrp[j].wg_numqgrp++;
		WorkGrp[j].wg_runners += Queue[h]->qg_maxqrun;
		Queue[h]->qg_wgrp = j;
				Queue[h]->qg_maxqrun = MaxQueueChildren;
			WorkGrp[j].wg_maxact = Queue[h]->qg_maxqrun;
			WorkGrp[j].wg_lowqintvl = Queue[h]->qg_queueintvl;
		j += dir;
			sm_dprintf("Workgroup[%d]=", i);
					WorkGrp[i].wg_qgs[j]->qg_name);
			sm_dprintf("\n");
static bool	dup_df __P((ENVELOPE *, ENVELOPE *));
	ENVELOPE *old;
	ENVELOPE *new;
	int ofs, nfs, r;
	char opath[MAXPATHLEN];
	char npath[MAXPATHLEN];
		queueup(old, false, true);
	SM_REQUIRE(ISVALIDQGRP(old->e_qgrp) && ISVALIDQDIR(old->e_qdir));
	SM_REQUIRE(ISVALIDQGRP(new->e_qgrp) && ISVALIDQDIR(new->e_qdir));
	(void) sm_strlcpy(opath, queuename(old, DATAFL_LETTER), sizeof(opath));
	(void) sm_strlcpy(npath, queuename(new, DATAFL_LETTER), sizeof(npath));
		r = sm_io_setinfo(old->e_dfp, SM_BF_COMMIT, NULL);
			syserr("@can't commit %s", opath);
			old->e_flags |= EF_FATALERRS;
	SM_REQUIRE(ISVALIDQGRP(old->e_dfqgrp) && ISVALIDQDIR(old->e_dfqdir));
	SM_REQUIRE(ISVALIDQGRP(new->e_dfqgrp) && ISVALIDQDIR(new->e_dfqdir));
	ofs = Queue[old->e_dfqgrp]->qg_qpaths[old->e_dfqdir].qp_fsysidx;
	nfs = Queue[new->e_dfqgrp]->qg_qpaths[new->e_dfqdir].qp_fsysidx;
			new->e_flags |= EF_HAS_DF;
			SYNC_DIR(npath, true);
		goto error;
	new->e_dfqgrp = old->e_dfqgrp;
	new->e_dfqdir = old->e_dfqdir;
	(void) sm_strlcpy(npath, queuename(new, DATAFL_LETTER), sizeof(npath));
		new->e_flags |= EF_HAS_DF;
		SYNC_DIR(npath, true);
			  opath, npath, sm_errstring(errno));
static ENVELOPE	*split_env __P((ENVELOPE *, ADDRESS *, int, int));
	ENVELOPE *e;
	ADDRESS *sendqueue;
	int qgrp;
	int qdir;
	ENVELOPE *ee;
	ee = (ENVELOPE *) sm_rpool_malloc_x(e->e_rpool, sizeof(*ee));
	STRUCTCOPY(*e, *ee);
	ee->e_id = NULL;
	assign_queueid(ee);
	ee->e_sendqueue = sendqueue;
			 |EF_SENDRECEIPT|EF_RET_PARAM|EF_HAS_DF);
	ee->e_from.q_state = QS_SENDER;
	ee->e_dfp = NULL;
	ee->e_lockfp = NULL;
		ee->e_xfp = sm_io_dup(e->e_xfp);
		openxscript(ee);
	ee->e_qgrp = ee->e_dfqgrp = qgrp;
	ee->e_qdir = ee->e_dfqdir = qdir;
	ee->e_errormode = EM_MAIL;
	ee->e_statmsg = NULL;
						  e->e_quarmsg);
	ee->e_header = copyheader(e->e_header, ee->e_rpool);
	ee->e_errorqueue = copyqueue(e->e_errorqueue, ee->e_rpool);
static int	q_qgrp_compare __P((const void *, const void *));
static int	e_filesys_compare __P((const void *, const void *));
	const void *p1;
	const void *p2;
	ADDRESS **pq1 = (ADDRESS **) p1;
	ADDRESS **pq2 = (ADDRESS **) p2;
	const void *p1;
	const void *p2;
	ENVELOPE **pe1 = (ENVELOPE **) p1;
	ENVELOPE **pe2 = (ENVELOPE **) p2;
	int fs1, fs2;
	fs1 = Queue[(*pe1)->e_qgrp]->qg_qpaths[(*pe1)->e_qdir].qp_fsysidx;
	fs2 = Queue[(*pe2)->e_qgrp]->qg_qpaths[(*pe2)->e_qdir].qp_fsysidx;
static int split_across_queue_groups __P((ENVELOPE *));
	ENVELOPE *e;
	int naddrs, nsplits, i;
	bool changed;
	char **pvp;
	ADDRESS *q, **addrs;
	ENVELOPE *ee, *es;
	ENVELOPE *splits[MAXQUEUEGROUPS];
	char pvpbuf[PSBUFSIZE];
	SM_REQUIRE(ISVALIDQGRP(e->e_qgrp));
	naddrs = 0;
	changed = false;
			continue;
		++naddrs;
			q->q_qgrp = e->e_qgrp;
				  pvpbuf, sizeof(pvpbuf));
				i = name2qid(pvp[1]);
					q->q_qgrp = i;
					changed = true;
							pvp[1], i);
					continue;
						pvp[1]);
				changed = true;
				q->q_qgrp = q->q_mailer->m_qgrp;
				q->q_qgrp = e->e_qgrp;
				q->q_qgrp = 0;
	addrs = sm_rpool_malloc_x(e->e_rpool, naddrs * sizeof(ADDRESS *));
			continue;
		addrs[i++] = q;
	qsort(addrs, naddrs, sizeof(ADDRESS *), q_qgrp_compare);
	nsplits = 0;
	es = NULL;
	e->e_sendqueue = NULL;
			addrs[i]->q_next = NULL;
			addrs[i]->q_next = addrs[i + 1];
				e->e_sendqueue = addrs[i];
			continue;
			ee = split_env(e, addrs[i], addrs[i]->q_qgrp, NOQDIR);
			es = ee;
			splits[nsplits++] = ee;
		es = splits[i];
		es->e_qdir = pickqdir(Queue[es->e_qgrp], es->e_msgsize, es);
			goto failure;
	qsort(splits, nsplits, sizeof(ENVELOPE *), e_filesys_compare);
		i = 0;
		goto failure;
			goto failure;
		es = splits[i];
		es->e_sibling = e->e_sibling;
		e->e_sibling = es;
		int j;
			(void) unlink(queuename(splits[j], DATAFL_LETTER));
	e->e_sendqueue = addrs[0];
		addrs[i]->q_next = addrs[i + 1];
	addrs[naddrs - 1]->q_next = NULL;
static int	split_within_queue __P((ENVELOPE *));
	ENVELOPE *e;
	int maxrcpt, nrcpt, ndead, nsplit, i;
	int j, l;
	char *lsplits;
	ADDRESS *q, **addrs;
	ENVELOPE *ee, *firstsibling;
	maxrcpt = Queue[e->e_qgrp]->qg_maxrcpt;
	nrcpt = 0;
			continue;
		++nrcpt;
	addrs = sm_rpool_malloc_x(e->e_rpool, nrcpt * sizeof(ADDRESS *));
			continue;
		addrs[i++] = q;
	ndead = 0;
				ADDRESS *tmp = addrs[i];
				addrs[i] = addrs[ndead];
				addrs[ndead] = tmp;
			++ndead;
		addrs[i]->q_next = addrs[i + 1];
	addrs[nrcpt - 1]->q_next = NULL;
	e->e_sendqueue = addrs[0];
		l = MAXLINE;
		lsplits = sm_malloc(l);
			*lsplits = '\0';
		j = 0;
		lsplits = NULL;
		j = l = 0;
	firstsibling = e->e_sibling;
	i = maxrcpt + ndead;
	nsplit = 0;
		addrs[i - 1]->q_next = NULL;
		ee = split_env(e, addrs[i], e->e_qgrp, e->e_qdir);
			ee = firstsibling;
				(void) unlink(queuename(ee, DATAFL_LETTER));
				ee = ee->e_sibling;
			e->e_sibling = firstsibling;
				addrs[i]->q_next = addrs[i + 1];
				sm_free(lsplits);
		ee->e_sibling = e->e_sibling;
		e->e_sibling = ee;
		++nsplit;
				char *p;
				l += MAXLINE;
				p = sm_realloc(lsplits, l);
					sm_free(lsplits);
					lsplits = NULL;
					lsplits = p;
							l - j);
							 l - j);
				SM_ASSERT(j < l);
			break;
		i += maxrcpt;
				  nsplit > 1 ? "s" : "", lsplits);
		sm_free(lsplits);
	ENVELOPE *e;
	int split, n, i, j, l;
	char *lsplits;
	ENVELOPE *ee, *next, *firstsibling;
	n = split_across_queue_groups(e);
	firstsibling = ee = e->e_sibling;
		l = MAXLINE;
		lsplits = sm_malloc(l);
			*lsplits = '\0';
		j = 0;
		lsplits = NULL;
		j = l = 0;
		next = ee->e_sibling;
			e->e_sibling = firstsibling;
		ee->e_flags |= EF_SPLIT;
				char *p;
				l += MAXLINE;
				p = sm_realloc(lsplits, l);
					sm_free(lsplits);
					lsplits = NULL;
					lsplits = p;
							ee->e_id, l - j);
							 ee->e_id, l - j);
				SM_ASSERT(j < l);
		ee = next;
			  n - 1, n > 2 ? "s" : "", lsplits);
		sm_free(lsplits);
	split = split_within_queue(e) != SM_SPLIT_FAIL;
		e->e_flags |= EF_SPLIT;
	int qgrp;
	int qdir;
	ENVELOPE *e;
	char *reason;
	bool dirty = false;
	bool failing = false;
	bool foundq = false;
	bool finished = false;
	int fd;
	int flags;
	int oldtype;
	int newtype;
	int save_errno;
	MODE_T oldumask = 0;
	SM_FILE_T *oldqfp, *tempqfp;
	char *bp;
	int bufsize;
	char oldqf[MAXPATHLEN];
	char tempqf[MAXPATHLEN];
	char newqf[MAXPATHLEN];
	char buf[MAXLINE];
	oldtype = queue_letter(e, ANYQFL_LETTER);
	(void) sm_strlcpy(oldqf, queuename(e, ANYQFL_LETTER), sizeof(oldqf));
	(void) sm_strlcpy(tempqf, queuename(e, NEWQFL_LETTER), sizeof(tempqf));
				     "Skipping %s\n", qid_printname(e));
	oldqfp = e->e_lockfp;
	flags = O_CREAT|O_WRONLY|O_EXCL;
		oldumask = umask(002);
	fd = open(tempqf, flags, QueueFileMode);
		(void) umask(oldumask);
	RELEASE_QUEUE;
		save_errno = errno;
				     sm_errstring(save_errno));
		(void) sm_io_close(oldqfp, SM_TIME_DEFAULT);
				     qid_printname(e), tempqf);
		(void) close(fd);
		(void) sm_io_close(oldqfp, SM_TIME_DEFAULT);
			     SM_IO_WRONLY_B, NULL);
				     qid_printname(e), tempqf);
		(void) close(fd);
		(void) sm_io_close(oldqfp, SM_TIME_DEFAULT);
			sm_dprintf("+++++ %s\n", bp);
			foundq = true;
							     e->e_id, &bp[1]);
				sm_syslog(LOG_INFO, e->e_id, "unquarantine");
				dirty = true;
							     e->e_id, reason);
						     "q%s\n", reason);
							     reason);
						     "q%s\n", reason);
					  reason);
				dirty = true;
			break;
							     e->e_id, reason);
						     "q%s\n", reason);
					  reason);
				foundq = true;
				dirty = true;
					     "%s\n", bp);
			break;
			finished = true;
					     "%s\n", bp);
			break;
			sm_free(bp);
	errno = sm_io_error(tempqfp);
		save_errno = errno;
				     sm_errstring(save_errno));
		failing = true;
				     qid_printname(e), oldqf);
		failing = true;
		failing = true;
		save_errno = errno;
				     sm_errstring(save_errno));
		failing = true;
	newtype = (reason == NULL ? NORMQF_LETTER : QUARQF_LETTER);
		(void) sm_strlcpy(newqf, oldqf, sizeof(newqf));
		(void) sm_strlcpy(newqf, queuename(e, newtype), sizeof(newqf));
	save_errno = 0;
		save_errno = (errno == 0) ? EINVAL : errno;
			  tempqf, newqf, sm_errstring(save_errno));
				     sm_errstring(save_errno));
			RELEASE_QUEUE;
			errno = save_errno;
			syserr("!452 Error renaming control file %s", tempqf);
				save_errno = errno;
						     sm_errstring(save_errno));
			failing = true;
			save_errno = errno;
					     oldqf, sm_errstring(save_errno));
		(void) xunlink(tempqf);
					   SM_IO_WHAT_FD, NULL));
						   SM_IO_WHAT_FD, NULL));
		SYNC_DIR(tempqf, false);
	RELEASE_QUEUE;
		(void) sm_io_close(tempqfp, SM_TIME_DEFAULT);
		(void) sm_io_close(oldqfp, SM_TIME_DEFAULT);
	char *reason;
	int qgrplimit;
	int changed = 0;
	int qgrp;
		reason = NULL;
		reason = newstr(denlstring(reason, true, true));
		int qdir;
			continue;
			int i;
			int nrequests;
				stop_sendmail();
			nrequests = gatherq(qgrp, qdir, true, NULL, NULL, NULL);
							     qid_printqueue(qgrp, qdir));
				continue;
						     qid_printqueue(qgrp, qdir));
				ENVELOPE e;
					stop_sendmail();
				clearenvelope(&e, true, sm_rpool_new_x(NULL));
				e.e_id = WorkList[i].w_name + 2;
				e.e_qgrp = qgrp;
				e.e_qdir = qdir;
						      "Would do %s\n", e.e_id);
					changed++;
					changed++;
				sm_rpool_free(e.e_rpool);
				e.e_rpool = NULL;
			WorkList = NULL;
			WorkListSize = 0;
			WorkListCount = 0;
					     "No changes\n");
					     changed == 1 ? "" : "s");

/* ===== FUNCTIONS ===== */

/* Function 1 */
	    ((dptr = (dataq_data_t *)ll_dequeue(&dataq->data)) == NULL)) {
		dataq_waiter_t wait;
		if (try) {
			(void) pthread_mutex_unlock(&dataq->lock);
			return (1);
		}
		wait.wakeup = 0;
		(void) pthread_cond_init(&wait.cv, NULL);
		dataq->num_waiters++;
		ll_enqueue(&dataq->waiters, &wait.list);
		while (wait.wakeup == 0)
			(void) pthread_cond_wait(&wait.cv, &dataq->lock);
		(void) ll_dequeue(&dataq->waiters);
		dataq->num_waiters--;
		(void) pthread_cond_destroy(&wait.cv);
		dptr = (dataq_data_t *)ll_dequeue(&dataq->data);
	}

/* Function 2 */
	queueup_macros(macid("{persistentMacros}"), tfp, e);


/* Function 3 */
	**  else (like being a daemon). And we still want on a SIG{TERM,HUP} to
	**  clean up the child queue runners. Only install 'runners_sig*' once

/* Function 4 */
	macdefine(&e->e_macro, A_TEMP, macid("{queue}"),
		  qid_printqueue(e->e_qgrp, e->e_qdir));

/* Function 5 */
				  macid("{quarantine}"), e->e_quarmsg);
			break;

/* Function 6 */
				macid("{ntries}"), &buf[1]);


/* Function 7 */
			macdefine(&e->e_macro, A_PERM, macid("{addr_type}"),
				"e r");

/* Function 8 */
			macdefine(&e->e_macro, A_PERM, macid("{addr_type}"),
				NULL);

/* Function 9 */
				macid("{dsn_envid}"), e->e_envid);
			break;

/* Function 10 */
				macid("{dsn_ret}"), "hdrs");
		else

/* Function 11 */
				macid("{dsn_ret}"), "full");
	}

/* Function 12 */
			macdefine(&e->e_macro, A_TEMP, macid("{msg_size}"),
				  buf);


#ifdef __cplusplus
}
#endif

#endif /* QUEUE_UNIFIED_C_H */

/* End of queue_unified.c - Synthesized by MINIX4 Synthesis System */
