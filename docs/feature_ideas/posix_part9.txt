The iswpunct_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0335 [302], XSH/TC1-2008/0336 [283], and XSH/TC1-2008/0337 [283] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0190 [685] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getpwuid_r.html =====
getpwuid
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getpwuid, getpwuid_r — search user database for a user ID
SYNOPSIS
#include
struct passwd *getpwuid(uid_t uid);
int getpwuid_r(uid_t uid, struct passwd *pwd, char *buffer,
size_t bufsize, struct passwd **result);
DESCRIPTION
The getpwuid() function shall search the user database for an entry with a matching uid.
The getpwuid() function need not be thread-safe.
Applications wishing to check for error situations should set errno to 0 before calling getpwuid(). If
getpwuid() returns a null pointer and errno is set to non-zero, an error occurred.
The getpwuid_r() function shall update the passwd structure pointed to by pwd and store a pointer to that
structure at the location pointed to by result. The structure shall contain an entry from the user database with a matching
uid. Storage referenced by the structure is allocated from the memory provided with the buffer parameter, which is
bufsize bytes in size. A call to sysconf(_SC_GETPW_R_SIZE_MAX) returns either -1 without changing errno or an
initial value suggested for the size of this buffer. A null pointer shall be returned at the location pointed to by result
on error or if the requested entry is not found.
RETURN VALUE
The getpwuid() function shall return a pointer to a struct passwd with the structure as defined in  with a matching entry if found. A null pointer shall be returned if the requested
entry is not found, or an error occurs. If the requested entry was not found, errno shall not be changed. On error,
errno shall be set to indicate the error.
The application shall not modify the structure to which the return value points, nor any storage areas pointed to by pointers
within the structure. The returned pointer, and pointers within the structure, might be invalidated or the structure or the storage
areas might be overwritten by a subsequent call to getpwent(), getpwnam(), or getpwuid(). The returned pointer, and pointers within the structure,
might also be invalidated if the calling thread is terminated.
If successful, the getpwuid_r() function shall return zero; otherwise, an error number shall be returned to indicate the
error.
ERRORS
These functions may fail if:
[EIO]
An I/O error has occurred.
[EINTR]
A signal was caught during getpwuid().
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum allowable number of files is currently open in the system.
The getpwuid_r() function shall fail if:
[ERANGE]
Insufficient storage was supplied via buffer and bufsize to contain the data to be referenced by the resulting
passwd structure.
The following sections are informative.
EXAMPLES
Note that sysconf(_SC_GETPW_R_SIZE_MAX) may return -1 if there is no hard limit on the size of the buffer needed to store
all the groups returned. This example shows how an application can allocate a buffer of sufficient size to work with
getpwuid_r().
long int initlen = sysconf(_SC_GETPW_R_SIZE_MAX);
size_t len;
if (initlen == -1)
/* Default initial length. */
len = 1024;
else
len = (size_t) initlen;
struct passwd result;
struct passwd *resultp;
char *buffer = malloc(len);
if (buffer == NULL)
...handle error...
int e;
while ((e = getpwuid_r(42, &result, buffer, len, &resultp)) == ERANGE)
{
size_t newlen = 2 * len;
if (newlen
#include
...
uid_t id = 0;
struct passwd *pwd;
pwd = getpwuid(id);
Finding the Name for the Effective User ID
The following example defines pws as a pointer to a structure of type passwd, which is used to store the structure
pointer returned by the call to the getpwuid() function. The geteuid()
function shall return the effective user ID of the calling process; this is used as the search criteria for the getpwuid()
function. The call to getpwuid() shall return a pointer to the structure containing that user ID value.
#include
#include
#include
...
struct passwd *pws;
pws = getpwuid(geteuid());
Finding an Entry in the User Database
The following example uses getpwuid() to search the user database for a user ID that was previously stored in a
stat structure, then prints out the user name if it is found. If the user is not found, the program prints the numeric value
of the user ID for the entry.
#include
#include
#include
...
struct stat statbuf;
struct passwd *pwd;
...
if ((pwd = getpwuid(statbuf.st_uid)) != NULL)
printf(" %-8.8s", pwd->pw_name);
else
printf(" %-8d", statbuf.st_uid);
APPLICATION USAGE
Three names associated with the current process can be determined: getpwuid(geteuid()) returns the name associated with the effective user ID of the process; getlogin() returns the name associated with the current login activity; and
getpwuid(getuid()) returns the name associated with the real user ID of the
process.
The getpwuid_r() function is thread-safe and returns values in a user-supplied buffer instead of possibly using a static
data area that may be overwritten by each call.
Portable applications should take into account that it is usual for an implementation to return -1 from sysconf() indicating that there is no maximum for _SC_GETPW_R_SIZE_MAX.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
getpwnam(), geteuid(),
getuid(), getlogin(), sysconf()
XBD ,
CHANGE HISTORY
First released in Issue 1. Derived from System V Release 2.0.
Issue 5
Normative text previously in the APPLICATION USAGE section is moved to the RETURN VALUE section.
The getpwuid_r() function is included for alignment with the POSIX Threads Extension.
A note indicating that the getpwuid() function need not be reentrant is added to the DESCRIPTION.
Issue 6
The getpwuid_r() function is marked as part of the Thread-Safe Functions option.
The Open Group Corrigendum U028/3 is applied, correcting text in the DESCRIPTION describing matching the uid.
In the SYNOPSIS, the optional include of the  header is
removed.
In the DESCRIPTION, the note about reentrancy is expanded to cover thread-safety.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
In the RETURN VALUE section, the requirement to set errno on error is added.
The [EIO], [EINTR], [EMFILE], and [ENFILE] optional error conditions are added.
The APPLICATION USAGE section is updated to include a note on the thread-safe function and its avoidance of possibly using a
static data area.
IEEE PASC Interpretation 1003.1 #116 is applied, changing the description of the size of the buffer from bufsize
characters to bytes.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
SD5-XBD-ERN-4 is applied, changing the definition of the [EMFILE] error.
SD5-XSH-ERN-166 is applied.
The getpwuid_r() function is moved from the Thread-Safe Functions option to the Base.
A minor addition is made to the EXAMPLES section, reminding the application developer to free memory allocated as if by malloc().
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0256 [75] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0172 [808] and XSH/TC2-2008/0173 [656] are applied.
Issue 8
Austin Group Defect 398 is applied, changing the [ERANGE] error from "may fail" to "shall fail".
Austin Group Defect 1570 is applied, removing extra spacing in "==".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/islower.html =====
islower
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
islower, islower_l — test for a lowercase letter
SYNOPSIS
#include
int islower(int c);
[CX]  int islower_l(int c, locale_t locale);
DESCRIPTION
For islower(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The islower() [CX]   and islower_l()
functions shall test whether c is a character of class lower in the current locale, [CX]   or in the
locale represented by locale,  respectively; see XBD 7. Locale.
The c argument is an int, the value of which the application shall ensure is a character representable as an
unsigned char or equal to the value of the macro EOF. If the argument has any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to islower_l() is the special locale object LC_GLOBAL_LOCALE or is not a
valid locale object handle.
RETURN VALUE
The islower() [CX]   and islower_l()
functions shall return non-zero if c is a lowercase letter; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
Testing for a Lowercase Letter
Two examples follow, the first using islower(), the second using multiple concurrent locales and islower_l().
The examples test whether the value is a lowercase letter, based on the current locale, then use it as part of a key value.
/* Example 1 -- using islower() */
#include
#include
#include
...
char *keystr;
int elementlen, len;
unsigned char c;
...
setlocale(LC_ALL, "");
...
len = 0;
while (len
#include
#include
...
char *keystr;
int elementlen, len;
unsigned char c;
...
locale_t loc = newlocale (LC_ALL_MASK, "", (locale_t) 0);
...
len = 0;
while (len ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements and an example is added.
Issue 7
The islower_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0292 [302], XSH/TC1-2008/0293 [283], XSH/TC1-2008/0294 [283],
XSH/TC1-2008/0295 [302], and XSH/TC1-2008/0296 [304] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/acosh.html =====
acosh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
acosh, acoshf, acoshl — inverse hyperbolic cosine functions
SYNOPSIS
#include
double acosh(double x);
float acoshf(float x);
long double acoshl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the inverse hyperbolic cosine of their argument x.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the inverse hyperbolic cosine of their argument.
For finite values of x
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The acosh() function is no longer marked as an extension.
The acoshf() and acoshl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0025 [320] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fchmod.html =====
fchmod
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fchmod — change mode of a file
SYNOPSIS
#include
int fchmod(int fildes, mode_t mode);
DESCRIPTION
The fchmod() function shall be equivalent to chmod() except that the file
whose permissions are changed is specified by the file descriptor fildes.
[SHM]
If fildes references a shared memory object, the fchmod() function need only affect the S_IRUSR, S_IWUSR, S_IRGRP,
S_IWGRP, S_IROTH, and S_IWOTH file permission bits.
[TYM]
If fildes references a typed memory object, the behavior of fchmod() is unspecified.
If fildes refers to a socket, the behavior of fchmod() is unspecified.
RETURN VALUE
Upon successful completion, fchmod() shall return 0. Otherwise, it shall return -1 and set errno to indicate the
error.
ERRORS
The fchmod() function shall fail if:
[EBADF]
The fildes argument is not an open file descriptor.
[EPERM]
The effective user ID does not match the owner of the file and the process does not have appropriate privileges.
[EROFS]
The file referred to by fildes resides on a read-only file system.
The fchmod() function may fail if:
[EINTR]
[XSI]
The fchmod() function was interrupted by a signal.
[EINVAL]
[XSI]
The value of the mode argument is invalid.
[EINVAL]
The fildes argument refers to a pipe and the implementation disallows execution of fchmod() on a pipe.
The following sections are informative.
EXAMPLES
Changing the Current Permissions for a File
The following example shows how to change the permissions for a file named /home/cnd/mod1 so that the owner and group
have read/write/execute permissions, but the world only has read/write permissions.
#include
#include
mode_t mode;
int    fildes;
...
fildes = open("/home/cnd/mod1", O_RDWR);
fchmod(fildes, S_IRWXU | S_IRWXG | S_IROTH | S_IWOTH);
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
chmod(), chown()
, creat(), fcntl(), fstatat(), fstatvfs(), mknod(), open(), read(), write()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE and aligned with fchmod() in the POSIX Realtime Extension. Specifically, the
second paragraph of the DESCRIPTION is added and a second instance of [EINVAL] is defined in the list of optional errors.
Issue 6
The DESCRIPTION is updated for alignment with IEEE Std 1003.1j-2000 by stating that fchmod() behavior is
unspecified for typed memory objects.
Issue 8
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/seekdir.html =====
seekdir
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
seekdir — set the position of a directory stream
SYNOPSIS
[XSI]  #include
void seekdir(DIR *dirp, long loc);
DESCRIPTION
The seekdir() function shall set the position of the next readdir()
operation on the directory stream specified by dirp to the position specified by loc. The value of loc should
have been returned from an earlier call to telldir() using the same directory
stream. The new position reverts to the one associated with the directory stream when telldir() was performed.
If the value of loc was not obtained from an earlier call to telldir(), or
if a call to rewinddir() occurred between the call to telldir() and the call to seekdir(), the results of subsequent calls to readdir() are unspecified.
RETURN VALUE
The seekdir() function shall not return a value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The original standard developers perceived that there were restrictions on the use of the seekdir() and telldir() functions related to implementation details, and for that reason these functions
need not be supported on all POSIX-conforming systems. They are required on implementations supporting the XSI option.
One of the perceived problems of implementation is that returning to a given point in a directory is quite difficult to describe
formally, in spite of its intuitive appeal, when systems that use B-trees, hashing functions, or other similar mechanisms to order
their directories are considered. The definition of seekdir() and telldir()
does not specify whether, when using these interfaces, a given directory entry will be seen at all, or more than once.
On systems not supporting these functions, their capability can sometimes be accomplished by saving a filename found by readdir() and later using rewinddir() and a
loop on readdir() to relocate the position from which the filename was saved.
FUTURE DIRECTIONS
None.
SEE ALSO
fdopendir(), readdir(),
telldir()
XBD ,
CHANGE HISTORY
First released in Issue 2.
Issue 6
In the SYNOPSIS, the inclusion of  is no longer
required.
Issue 7
SD5-XSH-ERN-200 is applied, updating the DESCRIPTION to note that the value of loc should have been returned from an
earlier call to telldir() using the same directory stream.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/cacoshf.html =====
cacosh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cacosh, cacoshf, cacoshl — complex arc hyperbolic cosine functions
SYNOPSIS
#include
double complex cacosh(double complex z);
float complex cacoshf(float complex z);
long double complex cacoshl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex arc hyperbolic cosine of z, with a branch cut at values less than 1 along the
real axis.
RETURN VALUE
These functions shall return the complex arc hyperbolic cosine value, in the range of a half-strip of non-negative values along
the real axis and in the interval [-iℼ, +iℼ] along the imaginary axis.
[MXC]
cacosh(conj(z)), cacoshf(conjf(z)), and cacoshl(conjl(z)) shall
return exactly the same value as conj(cacosh(z)), conjf(cacoshf(z)), and
conjl(cacoshl(z)), respectively, including for the special values of z below.
If z is ±0 + i0, +0 + iℼ/2 shall be returned.
If z is x + iInf where x is finite, +Inf + iℼ/2 shall be returned.
If z is 0 + iNaN, NaN ± iℼ/2 shall be returned; the sign of the imaginary part of the result is
unspecified.
If z is x + iNaN where x is non-zero and finite, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is -Inf + iy where y is positive-signed and finite, +Inf + iℼ shall be returned.
If z is +Inf + iy where y is positive-signed and finite, +Inf + i0 shall be returned.
If z is -Inf + iInf, +Inf + i3ℼ/4 shall be returned.
If z is +Inf + iInf, +Inf + iℼ/4 shall be returned.
If z is ±Inf + iNaN, +Inf + iNaN shall be returned.
If z is NaN + iy where y is finite, NaN + iNaN shall be returned and the invalid floating-point
exception may be raised.
If z is NaN + iInf, +Inf + iNaN shall be returned.
If z is NaN + iNaN, NaN + iNaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
ccosh()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ngettext_l.html =====
gettext
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
dgettext, dgettext_l, dcgettext, dcgettext_l, gettext, gettext_l, ngettext, ngettext_l, dngettext, dngettext_l,
dcngettext, dcngettext_l — message handling functions
SYNOPSIS
#include
char *dgettext(const char *domainname, const char *msgid);
char *dgettext_l(const char *domainname, const char *msgid,
locale_t locale);
char *dcgettext(const char *domainname, const char *msgid,
int category);
char *dcgettext_l(const char *domainname, const char *msgid,
int category, locale_t locale);
char *dngettext(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n);
char *dngettext_l(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n,
locale_t locale);
char *dcngettext(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n,
int category);
char *dcngettext_l(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n,
int category, locale_t locale);
char *gettext(const char *msgid);
char *gettext_l(const char *msgid, locale_t locale);
char *ngettext(const char *msgid, const char *msgid_plural,
unsigned long int n);
char *ngettext_l(const char *msgid, const char *msgid_plural,
unsigned long int n, locale_t locale);
DESCRIPTION
The gettext() function shall:
attempt to locate a suitable messages object (described in detail below) for the LC_MESSAGES category in the current
locale, and for the current text domain (see bindtextdomain()), containing
the string identified by msgid,
retrieve the string identified by msgid from the messages object,
convert the string to the output codeset if necessary (described in detail below), and
return the result.
If the locale name in effect is "POSIX" or "C" (i.e. the name associated with the LC_MESSAGES locale
category in the current locale), or if no suitable messages object exists, or if no string identified by msgid exists in the
messages object, or if an error occurs, msgid shall be returned.
The dgettext() function shall be equivalent to gettext(), except domainname shall be used instead of the
current text domain to locate the messages object.
The dcgettext() function shall be equivalent to dgettext(), except the locale category identified by
category shall be used instead of LC_MESSAGES .
The ngettext() function shall be equivalent to gettext(), except:
The string to retrieve shall be identified by a combination of msgid and n (see msgfmt).
If the locale name in effect is "POSIX" or "C", or if no suitable messages object exists, or if no string
identified by the combination of msgid and n exists in the messages object, or if an error occurs, the return value
shall be msgid if n is 1, otherwise msgid_plural.
The dngettext() function shall be equivalent to ngettext(), except domainname shall be used instead of the
current text domain to locate the messages object.
The dcngettext() function shall be equivalent to dngettext(), except the locale category identified by
category shall be used instead of LC_MESSAGES .
The *_l() functions shall be equivalent to their counterparts without the _l suffix, except locale shall be
used instead of the current locale. If locale is the special locale object LC_GLOBAL_LOCALE or is not a valid locale object
handle, the behavior is undefined.
The application shall ensure that the msgid and msgid_plural arguments are strings. If either msgid or
msgid_plural is an empty string, or contains characters not in the portable character set, the results are unspecified. If
the category argument is LC_ALL , the results are unspecified.
The location of the messages object shall be determined according to the following criteria, stopping when the first messages
object is found:
[XSI]
If the NLSPATH environment variable is set to a non-empty string, an NLSPATH search shall be performed as described
in XBD 8.2 Internationalization Variables. If NLSPATH identifies
more than one template to use, each template in turn shall be used until a valid messages object is found.
If the LANGUAGE environment variable is set to a non-empty string, a LANGUAGE search shall be performed as
described below. If LANGUAGE identifies more than one directory to search, each directory shall be searched until a valid
messages object is found.
A single-locale search shall be performed as described below.
For [XSI]   the NLSPATH search and   the single-locale search,
the single locale name used to locate the messages object shall be the locale name associated with the selected locale category
from the current locale, or the provided locale object if calling one of the *_l() functions; additional searches of locale
names without .codeset (if present), without _territory (if present), and without @modifier (if present) may
be performed.
For the LANGUAGE search, the value of the LANGUAGE environment variable shall be a list of one or more locale
names separated by a  (':') character. Each locale name shall be tried in the specified order. If a messages
object for the locale does not exist, or cannot be opened, or is unsuitable for implementation-defined reasons (such as security),
the next locale name (if any) shall be tried. If:
a messages object for the locale can be opened but cannot be processed without error, or
the messages object does not contain a string identified by msgid, or msgid and n for the ngettext
functions,
it is unspecified whether the next locale name (if any) is tried. In all other cases, the messages object for the locale shall
be used.
For each locale name in LANGUAGE , or if LANGUAGE is not set or is empty, or no suitable messages object is found
in processing LANGUAGE , the pathname used to locate the messages object shall be
dirname/localename/categoryname/textdomainname.mo, where:
The dirname part is the dirname argument of the most recent successful call to bindtextdomain() that had textdomainname as the domainname argument;
any trailing  characters in dirname shall be discarded. If a successful call to bindtextdomain() has not been made for textdomainname, an
implementation-defined default directory shall be used.
For the LANGUAGE search, the localename part is each locale name from LANGUAGE in turn; if a locale name
has the format language[_territory][.codeset][@modifier], additional
searches of locale names without .codeset (if present), without _territory (if present), and without @modifier
(if present) may be performed; if .codeset is not present, additional searches of locale names with an added .codeset
may be performed. For the single-locale search, the localename part is the name of the current locale, or the locale
specified in an *_l() function call, for the category named by categoryname. Spellings of codeset names are not
standardized, and implementations may attempt to use different commonly known spellings, for example "utf8" and
"UTF-8".
The categoryname part is the string "LC_MESSAGES" if gettext(), dgettext(), ngettext(), or
dngettext() is called, or the locale category name corresponding to the category argument to dcgettext() or
dcngettext(). Likewise for the *_l() variants of all these functions.
For gettext(), gettext_l(), ngettext(), and ngettext_l(), the textdomainname part is the text
domain set by the last successful call to textdomain(). For dgettext(),
dcgettext(), dngettext(), dcngettext(), and the *_l() variants of these functions,
textdomainname is the text domain specified by the domainname argument. The domainname argument shall be
equivalent in syntax and meaning to the domainname argument to textdomain(), except that the selection of the text domain shall affect only the
dgettext(), dcgettext(), dngettext(), and dcngettext() function calls and their *_l() variants.
If the domainname argument is a null pointer, the text domain set by the last successful call to textdomain() shall be used. For all of these functions, if a successful call to textdomain() has not been made the default text domain "messages" shall be
used.
Resolution of the messages object pathname shall be performed the first time one of the gettext family of functions is
called for a given combination of dirname, localename, categoryname, and textdomainname. It is
unspecified whether the pathname is re-resolved if the combination has been used before in a call to one of the gettext
family of functions. If bindtextdomain() performs pathname resolution of its
dirname argument, only the part of the messages object pathname after dirname shall be resolved by the gettext
family of functions.
When one of the gettext family of functions returns a message string that was found in a messages object, it shall
convert the codeset of the message string to the output codeset if a codeset is specified in the messages object (see msgfmt) and the output codeset is not the same as that codeset. If a successful call to
bind_textdomain_codeset() has been made with the text domain of the
messages object as the domainname argument and a non-null codeset argument, the output codeset shall be the
codeset argument from the most recent such call. Otherwise, the output codeset shall be the codeset of characters in the
current locale, or the provided locale object if calling one of the *_l() functions, as specified by the LC_CTYPE
category of the locale. The conversion shall be performed as if by a call to iconv()
using a conversion descriptor returned by iconv_open(, ),
except that if the return value of iconv() would be greater than zero, the
non-identical conversions performed by the gettext family of functions need not be the same as those that such an iconv() call would perform. If an error prevents the codeset conversion from being performed,
the gettext family of functions shall behave as if no message string was found in the messages object. If at least one
non-identical conversion is performed that results in a fallback character (one that does not provide any information about the
character it was converted from, for example, a  or "replacement-character"), the gettext family of
functions may behave as if no message string was found in the messages object.
RETURN VALUE
The gettext(), gettext_l(), dgettext(), dgettext_l(), dcgettext(), and dcgettext_l()
functions shall return the message string described in DESCRIPTION if successful. Otherwise, they shall return msgid.
The ngettext(), ngettext_l(), dngettext(), dngettext_l(), dcngettext(), and
dcngettext_l() functions shall return the message string described in DESCRIPTION if successful. Otherwise, msgid
shall be returned if n is equal to 1, or msgid_plural if n is not equal to 1.
The application shall ensure that it does not modify the returned string. A subsequent call to a gettext family function
shall not overwrite or invalidate the returned string. The returned string may be invalidated by a subsequent call to bind_textdomain_codeset(), bindtextdomain(), setlocale(), or
textdomain() in the same process, except for calls that only query values. The
returned string shall not be invalidated by a subsequent call to uselocale().
ERRORS
The gettext family of functions shall not modify errno. If an error occurs these functions shall return a string
as described in RETURN VALUE.
The following sections are informative.
EXAMPLES
The example code below assumes the following:
The implementation-defined default directory is /system/gettextlib.
The following locales are available on the target system: en_US, en_GB, de_DE. The codeset used for all of these locales is
UTF-8.
The en_AU locale is not available on the target system.
The target system supports conversion from ISO/IEC 8859-1 to UTF-8.
The codeset used for the POSIX locale is ASCII.
The target system does not support conversion from ISO/IEC 8859-1 to ASCII.
Furthermore, the following .mo files (and only the following .mo files) are installed:
/system/gettextlib/en_US/LC_MESSAGES/mail.mo
/messagecatalogs/example/en_US/LC_MESSAGES/mail.mo
These are compiled from a portable messages object source file (dot-po file) with the following ISO/IEC 8859-1 encoded contents
(see the EXTENDED DESCRIPTION of the msgfmt utility for a description of the dot-po
file format):
msgid ""
msgstr ""
"Content-Type: text/plain; charset=ISO_8859-1\n"
"Plural-Forms: nplurals=4; plural= n==1?0: (n>1&&n1&&n1&&n,
XCU gettext, msgfmt,
xgettext
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fdopendir.html =====
fdopendir
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fdopendir, opendir — open directory associated with file descriptor
SYNOPSIS
#include
DIR *fdopendir(int fd);
DIR *opendir(const char *dirname);
DESCRIPTION
The fdopendir() function shall be equivalent to the opendir() function except that the directory is specified by a
file descriptor rather than by a name. The file offset associated with the file descriptor at the time of the call determines which
entries are returned.
Upon successful return from fdopendir(), the file descriptor is under the control of the system, and if any attempt is
made to close the file descriptor, or to modify the state of the associated description, other than by means of closedir(), readdir(), readdir_r(), rewinddir(), or
[XSI]
seekdir(),  the
behavior is undefined. Upon calling closedir() the file descriptor shall be
closed.
It is unspecified whether the FD_CLOEXEC flag will be set on the file descriptor by a successful call to fdopendir() if
it was not previously set. However, the flag shall not be cleared if it was previously set.
The opendir() function shall open a directory stream corresponding to the directory named by the dirname argument.
The directory stream shall be positioned at the first entry. If opendir() opens a file descriptor for dirname to
associate with the returned stream:
The descriptor shall be allocated as if the O_DIRECTORY and O_CLOEXEC flags were passed to open().
The descriptor shall be subject to the limit of {OPEN_MAX} file descriptors available to the process.
RETURN VALUE
Upon successful completion, these functions shall return a pointer to an object of type DIR. Otherwise, these functions
shall return a null pointer and set errno to indicate the error.
ERRORS
The fdopendir() function shall fail if:
[EBADF]
The fd argument is not a valid file descriptor open for reading.
[ENOTDIR]
The descriptor fd is not associated with a directory.
The opendir() function shall fail if:
[EACCES]
Search permission is denied for the component of the path prefix of dirname or read permission is denied for
dirname.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the dirname argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of dirname does not name an existing directory or dirname is an empty string.
[ENOTDIR]
A component of dirname names an existing file that is neither a directory nor a symbolic link to a directory.
The opendir() function may fail if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the dirname argument.
[EMFILE]
All file descriptors available to the process are currently open.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
[ENFILE]
Too many files are currently open in the system.
The following sections are informative.
EXAMPLES
Open a Directory Stream
The following program fragment demonstrates how the opendir() function is used.
#include
...
DIR *dir;
struct dirent *dp;
...
if ((dir = opendir (".")) == NULL) {
perror ("Cannot open .");
exit (1);
}
while ((dp = readdir (dir)) != NULL) {
...
Find And Open a File
The following program searches through a given directory looking for files whose name does not begin with a dot and whose size
is larger than 1 MiB.
#include
#include
#include
#include
#include
#include
#include
int
main(int argc, char *argv[])
{
struct stat statbuf;
DIR *d;
struct dirent *dp;
int dfd, ffd;
if ((d = fdopendir((dfd = open("./tmp", O_RDONLY)))) == NULL) {
fprintf(stderr, "Cannot open ./tmp directory\n");
exit(1);
}
while ((dp = readdir(d)) != NULL) {
if (dp->d_name[0] == '.')
continue;
/* there is a possible race condition here as the file
* could be renamed between the readdir and the open */
if ((ffd = openat(dfd, dp->d_name, O_RDONLY)) == -1) {
perror(dp->d_name);
continue;
}
if (fstat(ffd, &statbuf) == 0 && statbuf.st_size > (1024*1024)) {
/* found it ... */
printf("%s: %jdK\n", dp->d_name,
(intmax_t)(statbuf.st_size / 1024));
}
close(ffd);
}
closedir(d); // note this implicitly closes dfd
return 0;
}
APPLICATION USAGE
The opendir() function should be used in conjunction with readdir(),
closedir(), and rewinddir() to
examine the contents of the directory (see the EXAMPLES section in readdir()).
This method is recommended for portability.
RATIONALE
The purpose of the fdopendir() function is to enable opening files in directories other than the current working
directory without exposure to race conditions. Any part of the path of a file could be changed in parallel to a call to
opendir(), resulting in unspecified behavior.
Based on historical implementations, the rules about file descriptors apply to directory streams as well. However, this volume
of POSIX.1-2024 does not mandate that opendir() opens a file descriptor to associate with the stream; this may instead be
done by the first call to dirfd(), thus avoiding the need to allocate a file
descriptor if dirfd() is never called. Once a file descriptor has been associated with
the stream, it is mandatory that closedir() deallocate the file descriptor. If
opendir() opens a file descriptor to associate with the stream, it behaves as if the O_CLOEXEC flag for open() had been used, so that the FD_CLOEXEC flag is set for the file descriptor. If
fdopendir() is used to create a directory stream, it is unspecified whether the FD_CLOEXEC flag on the file descriptor
specified by the fd argument is set or left unchanged.
The directory entries for dot and dot-dot are optional. This volume of POSIX.1-2024 does not provide a way to test a
priori for their existence because an application that is portable must be written to look for (and usually ignore) those
entries. Writing code that presumes that they are the first two entries does not always work, as many implementations permit them
to be other than the first two entries, with a "normal" entry preceding them. There is negligible value in providing a way to
determine what the implementation does because the code to deal with dot and dot-dot must be written in any case and because such a
flag would add to the list of those flags (which has proven in itself to be objectionable) and might be abused.
Since the structure and buffer allocation, if any, for directory operations are defined by the implementation, this volume of
POSIX.1-2024 imposes no portability requirements for erroneous program constructs, erroneous data, or the use of unspecified values
such as the use or referencing of a dirp value or a dirent structure value after a directory stream has been closed
or after a fork() or one of the exec
function calls.
FUTURE DIRECTIONS
None.
SEE ALSO
closedir(), dirfd(), fstatat(), open(), posix_getdents(), readdir(),
rewinddir(), symlink()
XBD , ,
CHANGE HISTORY
First released in Issue 2.
Issue 6
In the SYNOPSIS, the optional include of the  header is
removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
The [ELOOP] mandatory error condition is added.
A second [ENAMETOOLONG] is added as an optional error condition.
The following changes were made to align with the IEEE P1003.1a draft standard:
The [ELOOP] optional error condition is added.
Issue 7
Austin Group Interpretation 1003.1-2001 #143 is applied.
SD5-XBD-ERN-4 is applied, changing the definition of the [EMFILE] error.
The fdopendir() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 2.
An additional example is added.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0122 [422] and XSH/TC1-2008/0123 [324] are applied.
Issue 8
Austin Group Defect 368 is applied, adding a requirement for FD_CLOEXEC to be set by opendir() if it associates a file
descriptor with the returned stream.
Austin Group Defect 411 is applied, clarifying that FD_CLOEXEC is not cleared by fdopendir() if it was previously
set.
Austin Group Defect 697 is applied, adding posix_getdents() to the SEE
ALSO section.
Austin Group Defect 1360 is applied, clarifying that type DIR always has the ability to store a file descriptor; what is
optional is whether one is opened by opendir().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/tcflush.html =====
tcflush
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
tcflush — flush non-transmitted output data, non-read input data, or both
SYNOPSIS
#include
int tcflush(int fildes, int queue_selector);
DESCRIPTION
Upon successful completion, tcflush() shall discard data written to the object referred to by fildes (an open file
descriptor associated with a terminal) but not transmitted, or data received but not read, depending on the value of
queue_selector:
If queue_selector is TCIFLUSH, it shall flush data received but not read.
If queue_selector is TCOFLUSH, it shall flush data written but not transmitted.
If queue_selector is TCIOFLUSH, it shall flush both data received but not read and data written but not transmitted.
Attempts to use tcflush() from a process which is a member of a background process group on a fildes associated
with its controlling terminal shall cause the process group to be sent a SIGTTOU signal. If the calling thread is blocking SIGTTOU
signals or the process is ignoring SIGTTOU signals, the process shall be allowed to perform the operation, and no signal is
sent.
RETURN VALUE
Upon successful completion, 0 shall be returned. Otherwise, -1 shall be returned and errno set to indicate the error.
ERRORS
The tcflush() function shall fail if:
[EBADF]
The fildes argument is not a valid file descriptor.
[EINVAL]
The queue_selector argument is not a supported value.
[EIO]
The process group of the writing process is orphaned, the calling thread is not blocking SIGTTOU, and the process is not
ignoring SIGTTOU.
[ENOTTY]
The file associated with fildes is not a terminal.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
tcdrain()
XBD 11. General Terminal Interface,
CHANGE HISTORY
First released in Issue 3. Included for alignment with the POSIX.1-1988 standard.
Issue 6
The Open Group Corrigendum U035/1 is applied. In the ERRORS and APPLICATION USAGE sections, references to tcflow() are replaced with tcflush().
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the DESCRIPTION, the final paragraph is no longer conditional on _POSIX_JOB_CONTROL. This is a FIPS requirement.
The [EIO] error is added.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0645 [79], XSH/TC1-2008/0646 [79], and XSH/TC1-2008/0647 [79] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ctanhl.html =====
ctanh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ctanh, ctanhf, ctanhl — complex hyperbolic tangent functions
SYNOPSIS
#include
double complex ctanh(double complex z);
float complex ctanhf(float complex z);
long double complex ctanhl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex hyperbolic tangent of z.
RETURN VALUE
These functions shall return the complex hyperbolic tangent value.
[MXC]
ctanh(conj(z)), ctanhf(conjf(z)), and ctanhl(conjl(z)) shall return
exactly the same value as conj(ctanh(z)), conjf(ctanhf(z)), and
conjl(ctanhl(z)), respectively, and ctanh(-z), ctanhf(-z), and
ctanhl(-z) shall return exactly the same value as -ctanh(z), -ctanhf(z), and
-ctanhl(z), respectively, including for the special values of z below.
If z is +0 + i0, +0 + i0 shall be returned.
If z is 0 + iInf, 0 + iNaN shall be returned and the invalid floating-point exception shall be raised.
If z is x + iInf where x is non-zero and finite, NaN + iNaN shall be returned and the invalid
floating-point exception shall be raised.
If z is 0 + iNaN, 0 + iNaN shall be returned.
If z is x + iNaN where x is non-zero and finite, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is +Inf + iy where y is positive-signed and finite, 1 + i0 sin(2y) shall be
returned.
If z is +Inf + iInf, 1 ± i0 shall be returned; the sign of the imaginary part of the result is
unspecified.
If z is +Inf + iNaN, 1 ± i0 shall be returned; the sign of the imaginary part of the result is
unspecified.
If z is NaN + i0, NaN + i0 shall be returned.
If z is NaN + iy where y is any non-zero number, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is NaN + iNaN, NaN + iNaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
catanh()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/utimensat.html =====
futimens
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
futimens, utimensat, utimes — set file access and modification times
SYNOPSIS
#include
int futimens(int fd, const struct timespec times[2]);
[OH] #include
int utimensat(int fd, const char *path, const struct timespec times[2],
int flag);
[XSI]
#include
int utimes(const char *path, const struct timeval times[2]);
DESCRIPTION
The futimens() and utimensat() functions shall set the access and modification times of a file to the values of
the times argument. The futimens() function changes the times of the file associated with the file descriptor
fd. The utimensat() function changes the times of the file pointed to by the path argument, relative to the
directory associated with the file descriptor fd. Both functions allow time specifications accurate to the nanosecond.
For futimens() and utimensat(), the times argument is an array of two timespec structures. The first
array member represents the date and time of last access, and the second member represents the date and time of last modification.
The times in the timespec structure are measured in seconds and nanoseconds since the Epoch. The file's relevant timestamp
shall be set to the greatest value supported by the file system that is not greater than the specified time.
If the tv_nsec field of a timespec structure has the special value UTIME_NOW, the file's relevant timestamp shall
be set to the greatest value supported by the file system that is not greater than the current time. If the tv_nsec field
has the special value UTIME_OMIT, the file's relevant timestamp shall not be changed. In either case, the tv_sec field shall
be ignored.
If the times argument is a null pointer, both the access and modification timestamps shall be set to the greatest value
supported by the file system that is not greater than the current time. If utimensat() is passed a relative path in the
path argument, the file to be used shall be relative to the directory associated with the file descriptor fd instead
of the current working directory. If the access mode of the open file description associated with the file descriptor is not
O_SEARCH, the function shall check whether directory searches are permitted using the current permissions of the directory
underlying the file descriptor. If the access mode is O_SEARCH, the function shall not perform the check.
If utimensat() is passed the special value AT_FDCWD in the fd parameter, the current working directory shall be
used.
Only a process with the effective user ID equal to the user ID of the file, or with write access to the file, or with
appropriate privileges may use futimens() or utimensat() with a null pointer as the times argument or with
both tv_nsec fields set to the special value UTIME_NOW. Only a process with the effective user ID equal to the user ID of
the file or with appropriate privileges may use futimens() or utimensat() with a non-null times argument that
does not have both tv_nsec fields set to UTIME_NOW and does not have both tv_nsec fields set to UTIME_OMIT. If both
tv_nsec fields are set to UTIME_OMIT, no ownership or permissions check shall be performed for the file, but other error
conditions may still be detected (including [EACCES] errors related to the path prefix).
Values for the flag argument of utimensat() are constructed by a bitwise-inclusive OR of flags from the following
list, defined in :
AT_SYMLINK_NOFOLLOW
If path names a symbolic link, then the access and modification times of the symbolic link are changed.
Upon successful completion, futimens() and utimensat() shall mark the last file status change timestamp for
update, with the exception that if both tv_nsec fields are set to UTIME_OMIT, the file status change timestamp need not be
marked for update.
The utimes() function shall be equivalent to the utimensat() function with the special value AT_FDCWD as the
fd argument and the flag argument set to zero, except that the times argument is a timeval structure
rather than a timespec structure, and accuracy is only to the microsecond, not nanosecond, and rounding towards the nearest
second may occur.
RETURN VALUE
Upon successful completion, these functions shall return 0. Otherwise, these functions shall return -1 and set errno to
indicate the error. If -1 is returned, the file times shall not be affected.
ERRORS
The utimes() function shall fail, the futimens() and utimensat() functions shall fail in the case that the
times argument does not have both tv_nsec fields set to UTIME_OMIT, and the futimens() and utimensat()
functions may fail in the case that the times argument has both tv_nsec fields set to UTIME_OMIT, if:
[EACCES]
The times argument is a null pointer, or both tv_nsec values are UTIME_NOW, and the effective user ID of the
process does not match the owner of the file and write access is denied.
[EINVAL]
Either of the times argument structures specified a tv_nsec value that was neither UTIME_NOW nor UTIME_OMIT, and
was a value less than zero or greater than or equal to 1000 million.
[EINVAL]
A new file timestamp would be a value whose tv_sec component is not a value supported by the file system.
[EPERM]
The times argument is not a null pointer, does not have both tv_nsec fields set to UTIME_NOW, does not have both
tv_nsec fields set to UTIME_OMIT, the calling process' effective user ID does not match the owner of the file, and the
calling process does not have appropriate privileges.
[EROFS]
The file system containing the file is read-only.
The futimens() function shall fail in the case that the times argument does not have both tv_nsec fields
set to UTIME_OMIT, and may fail in the case that the times argument has both tv_nsec fields set to UTIME_OMIT,
if:
[EBADF]
The fd argument is not a valid file descriptor.
The utimensat() function shall fail in the case that the times argument does not have both tv_nsec fields
set to UTIME_OMIT, and may fail in the case that the times argument has both tv_nsec fields set to UTIME_OMIT,
if:
[EACCES]
The access mode of the open file description associated with fd is not O_SEARCH and the permissions of the directory
underlying fd do not permit directory searches.
[EBADF]
The path argument does not specify an absolute path and the fd argument is neither AT_FDCWD nor a valid file
descriptor open for reading or searching.
[ENOTDIR]
The path argument is not an absolute path and fd is a file descriptor associated with a non-directory file.
The utimes() function shall fail, the utimensat() function shall fail in the case that the times argument
does not have both tv_nsec fields set to UTIME_OMIT, and the utimensat() function may fail in the case that the
times argument has both tv_nsec fields set to UTIME_OMIT, if:
[EACCES]
Search permission is denied by a component of the path prefix.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of path does not name an existing file or path is an empty string.
[ENOTDIR]
A component of the path prefix names an existing file that is neither a directory nor a symbolic link to a directory, or the
path argument contains at least one non- character and ends with one or more trailing  characters
and the last pathname component names an existing file that is neither a directory nor a symbolic link to a directory.
The utimensat() and utimes() functions may fail if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
The utimensat() function may fail if:
[EINVAL]
The value of the flag argument is not valid.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The purpose of the utimensat() function is to set the access and modification time of files in directories other than the
current working directory without exposure to race conditions. Any part of the path of a file could be changed in parallel to a
call to utimes(), resulting in unspecified behavior. By opening a file descriptor for the target directory and using the
utimensat() function it can be guaranteed that the changed file is located relative to the desired directory.
The standard developers considered including a special case for the permissions required by utimensat() when one
tv_nsec field is UTIME_NOW and the other is UTIME_OMIT. One possibility would be to include this case in with the cases
where times is a null pointer or both fields are UTIME_NOW, where the call is allowed if the process has write permission
for the file. However, associating write permission with an update to just the last data access timestamp (which is normally
updated by read()) did not seem appropriate. The other possibility would be to specify
that this one case is allowed if the process has read permission, but this was felt to be too great a departure from the
utime() and utimes() functions on which utimensat() is based. If an application needs to set the last data
access timestamp to the current time for a file on which it has read permission but is not the owner, it can do so by opening the
file, reading one or more bytes (or reading a directory entry, if the file is a directory), and then closing it.
FUTURE DIRECTIONS
None.
SEE ALSO
read()
XBD , ,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
This function is marked LEGACY.
The normative text is updated to avoid use of the term "must" for application requirements.
The wording of the mandatory [ELOOP] error condition is updated, and a second optional [ELOOP] error condition is added.
Issue 7
Austin Group Interpretation 1003.1-2001 #143 is applied.
The LEGACY marking is removed.
The utimensat() function (renamed from futimesat()) is added from The Open Group Technical Standard, 2006,
Extended API Set Part 2, and changed to allow modifying a symbolic link by adding a flag argument.
The futimens() function is added.
Changes are made related to support for finegrained timestamps.
Changes are made to allow a directory to be opened for searching.
The [ENOTDIR] error condition is clarified to cover the condition where the last component of a pathname exists but is not a
directory or a symbolic link to a directory.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0220 [63,428], XSH/TC1-2008/0221 [278], XSH/TC1-2008/0222 [324],
XSH/TC1-2008/0223 [306], and XSH/TC1-2008/0224 [278] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0140 [591], XSH/TC2-2008/0141 [817], XSH/TC2-2008/0142 [485], and
XSH/TC2-2008/0143 [817] are applied.
Issue 8
Austin Group Defect 1280 is applied, changing the ERRORS section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fchown.html =====
fchown
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fchown — change owner and group of a file
SYNOPSIS
#include
int fchown(int fildes, uid_t owner, gid_t group);
DESCRIPTION
The fchown() function shall be equivalent to chown() except that the file
whose owner and group are changed is specified by the file descriptor fildes.
RETURN VALUE
Upon successful completion, fchown() shall return 0. Otherwise, it shall return -1 and set errno to indicate the
error.
ERRORS
The fchown() function shall fail if:
[EBADF]
The fildes argument is not an open file descriptor.
[EPERM]
The effective user ID does not match the owner of the file or the process does not have appropriate privileges and
_POSIX_CHOWN_RESTRICTED indicates that such privilege is required.
[EROFS]
The file referred to by fildes resides on a read-only file system.
The fchown() function may fail if:
[EINVAL]
The owner or group ID is not a value supported by the implementation. The fildes argument refers to a pipe or socket and
the implementation disallows execution of fchown() on a pipe.
[EIO]
A physical I/O error has occurred.
[EINTR]
The fchown() function was interrupted by a signal which was caught.
The following sections are informative.
EXAMPLES
Changing the Current Owner of a File
The following example shows how to change the owner of a file named /home/cnd/mod1 to "jones" and the group to
"cnd".
The numeric value for the user ID is obtained by extracting the user ID from the user database entry associated with "jones".
Similarly, the numeric value for the group ID is obtained by extracting the group ID from the group database entry associated with
"cnd". This example assumes the calling program has appropriate privileges.
#include
#include
#include
#include
#include
struct passwd *pwd;
struct group  *grp;
int            fildes;
...
fildes = open("/home/cnd/mod1", O_RDWR);
pwd = getpwnam("jones");
grp = getgrnam("cnd");
fchown(fildes, pwd->pw_uid, grp->gr_gid);
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
chown()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The following changes were made to align with the IEEE P1003.1a draft standard:
Clarification is added that a call to fchown() may not be allowed on a pipe.
The fchown() function is defined as mandatory.
Issue 7
Functionality relating to XSI STREAMS is marked obsolescent.
Issue 8
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getsockname.html =====
getsockname
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getsockname — get the socket name
SYNOPSIS
#include
int getsockname(int socket, struct sockaddr *restrict address,
socklen_t *restrict address_len);
DESCRIPTION
The getsockname() function shall retrieve the locally-bound name of the specified socket, store this address in the
sockaddr structure pointed to by the address argument, and store the length of this address in the object pointed to
by the address_len argument.
The address_len argument points to a socklen_t object which on input specifies the length of the supplied
sockaddr structure, and on output specifies the length of the socket address. If the actual length of the address is greater
than the length of the supplied sockaddr structure, the stored address shall be truncated.
If the socket has not been bound to a local name, the value stored in the object pointed to by address is
unspecified.
RETURN VALUE
Upon successful completion, 0 shall be returned, the address argument shall point to the address of the socket, and the
address_len argument shall point to the length of the address. Otherwise, -1 shall be returned and errno set to
indicate the error.
ERRORS
The getsockname() function shall fail if:
[EBADF]
The socket argument is not a valid file descriptor.
[ENOTSOCK]
The socket argument does not refer to a socket.
[EOPNOTSUPP]
The operation is not supported for this socket's protocol.
The getsockname() function may fail if:
[EINVAL]
The socket has been shut down.
[ENOBUFS]
Insufficient resources were available in the system to complete the function.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
For AF_UNIX sockets, it is recommended that address points to a buffer of length greater than sizeof(struct
sockaddr_un) which has been initialized with null bytes. That way, even if the implementation supports the use of all bytes of
sun_path without a terminating null byte, the larger buffer guarantees that the sun_path member can then be passed to
other interfaces that expect a null-terminated string. If no truncation occurred based on the input value of address_len, it
is unspecified whether the returned address_len will be sizeof(struct sockaddr_un), or merely a value at least as
large as offsetof(struct sockaddr_un, sun_path) plus the number of non-null bytes stored in sun_path.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
accept(), bind(), getpeername(), socket()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
The restrict keyword is added to the getsockname() prototype for alignment with the ISO/IEC 9899:1999
standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0259 [464] is applied.
Issue 8
Austin Group Defect 561 is applied, adding a paragraph about sun_path to APPLICATION USAGE.
Austin Group Defect 1565 is applied, changing the description of address_len.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/llround.html =====
llround
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
llround, llroundf, llroundl — round to nearest integer value
SYNOPSIS
#include
long long llround(double x);
long long llroundf(float x);
long long llroundl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall round their argument to the nearest integer value, rounding halfway cases away from zero, regardless of
the current rounding direction.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the rounded integer value.
[MX]  If
x is NaN, a domain error shall occur, and an unspecified value is returned.
If x is +Inf, a domain error shall occur and an unspecified value is returned.
If x is -Inf, a domain error shall occur and an unspecified value is returned.
If the correct value is positive and too large to represent as a long long, an unspecified value shall be returned.
[MX]
On systems that support the IEC 60559 Floating-Point option, a domain error shall occur;   otherwise, a [CX]   domain  error may occur.
If the correct value is negative and too large to represent as a long long, an unspecified value shall be returned.
[MX]
On systems that support the IEC 60559 Floating-Point option, a domain error shall occur;   otherwise, a [CX]   domain  error may occur.
ERRORS
These functions shall fail if:
Domain Error
[MX]
The x argument is NaN or ±Inf, or the correct value is not representable as an integer.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
These functions may fail if:
Domain Error
The correct value is not representable as an integer.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
These functions differ from the llrint() functions in that the default rounding
direction for the llround() functions round halfway cases away from zero and need not raise the inexact floating-point
exception for non-integer arguments that round to within the range of the return type.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), lround()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #54 (SD5-XSH-ERN-75) is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/isblank.html =====
isblank
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
isblank, isblank_l — test for a blank character
SYNOPSIS
#include
int isblank(int c);
[CX]  int isblank_l(int c, locale_t locale);
DESCRIPTION
For isblank(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The isblank() [CX]   and isblank_l()
functions shall test whether c is a character of class blank in the current locale, [CX]   or in the
locale represented by locale,  respectively; see XBD 7. Locale.
The c argument is a type int, the value of which the application shall ensure is a character representable as an
unsigned char or equal to the value of the macro EOF. If the argument has any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to isblank_l() is the special locale object LC_GLOBAL_LOCALE or is not a
valid locale object handle.
RETURN VALUE
The isblank() [CX]   and isblank_l()
functions shall return non-zero if c is a ; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
isalnum(), isalpha(), iscntrl(), isdigit(), isgraph(), islower(), isprint(), ispunct(), isspace(), isupper(), isxdigit(), setlocale(), uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
The isblank_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0280 [302], XSH/TC1-2008/0281 [283], and XSH/TC1-2008/0282 [283] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/catclose.html =====
catclose
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
catclose — close a message catalog descriptor
SYNOPSIS
#include
int catclose(nl_catd catd);
DESCRIPTION
The catclose() function shall close the message catalog identified by catd. If a file descriptor is used to
implement the type nl_catd, that file descriptor shall be closed.
RETURN VALUE
Upon successful completion, catclose() shall return 0; otherwise, -1 shall be returned, and errno set to indicate
the error.
ERRORS
The catclose() function may fail if:
[EBADF]
The catalog descriptor is not valid.
[EINTR]
The catclose() function was interrupted by a signal.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
catgets(), catopen()
XBD
CHANGE HISTORY
First released in Issue 2.
Issue 7
The catclose() function is moved from the XSI option to the Base.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getresuid.html =====
getresuid
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getresuid — get real user ID, effective user ID, and saved set-user-ID
SYNOPSIS
[XSI]  #include
int getresuid(uid_t *restrict ruid, uid_t *restrict euid,
uid_t *restrict suid);
DESCRIPTION
The getresuid() function shall store the real user ID, effective user ID, and saved set-user-ID of the calling process in
the locations pointed to by the arguments ruid, euid, and suid, respectively.
RETURN VALUE
Upon successful completion, 0 shall be returned. Otherwise, -1 shall be returned and errno set to indicate the error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
exec, getegid(), geteuid(), getgid(), getresgid(), getuid(), setegid(), seteuid(), setgid(), setregid(), setresgid(), setresuid(), setreuid(), setuid()
XBD
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/clock_getres.html =====
clock_getres
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
clock_getres, clock_gettime, clock_settime — clock and timer functions
SYNOPSIS
[CX]  #include
int clock_getres(clockid_t clock_id, struct timespec *res);
int clock_gettime(clockid_t clock_id, struct timespec *tp);
int clock_settime(clockid_t clock_id, const struct timespec *tp);
DESCRIPTION
The clock_getres() function shall return the resolution of any clock. Clock resolutions are implementation-defined and
cannot be set by a process. If the argument res is not NULL, the resolution of the specified clock shall be stored in the
location pointed to by res. If res is NULL, the clock resolution is not returned. If the time argument of
clock_settime() is not a multiple of res, then the value is truncated to a multiple of res.
The clock_gettime() function shall return the current value tp for the specified clock, clock_id.
The clock_settime() function shall set the specified clock, clock_id, to the value specified by tp. Time
values that are between two consecutive non-negative integer multiples of the resolution of the specified clock shall be truncated
down to the smaller multiple of the resolution.
A clock may be system-wide (that is, visible to all processes) or per-process (measuring time that is meaningful only within a
process). All implementations shall support a clock_id of CLOCK_REALTIME as defined in . This clock represents the clock measuring real time for the system. For this
clock, the values returned by clock_gettime() and specified by clock_settime() represent the amount of time (in
seconds and nanoseconds) since the Epoch. An implementation may also support additional clocks. The interpretation of time values
for these clocks is unspecified.
If the value of the CLOCK_REALTIME clock is set via clock_settime(), the new value of the clock shall be used to
determine the time of expiration for absolute time services based upon the CLOCK_REALTIME clock. This applies to the time at which
armed absolute timers expire. If the absolute time requested at the invocation of such a time service is before the new value of
the clock, the time service shall expire immediately as if the clock had reached the requested time normally.
Setting the value of the CLOCK_REALTIME clock via clock_settime() shall have no effect on threads that are blocked
waiting for a relative time service based upon this clock, including the nanosleep() and thrd_sleep() functions;
nor on the expiration of relative timers based upon this clock. Consequently, these time services shall expire when the requested
relative interval elapses, independently of the new or old value of the clock.
All implementations shall support a clock_id of CLOCK_MONOTONIC defined in . This clock represents the monotonic clock for the system. For this clock, the
value returned by clock_gettime() represents the amount of time (in seconds and nanoseconds) since an unspecified point in
the past (for example, system start-up time, or the Epoch). This point does not change after system start-up time. The value of the
CLOCK_MONOTONIC clock cannot be set via clock_settime(). This function shall fail if it is invoked with a clock_id
argument of CLOCK_MONOTONIC.
The effect of setting a clock via clock_settime() on armed per-process timers associated with a clock other than
CLOCK_REALTIME is implementation-defined.
If the value of the CLOCK_REALTIME clock is set via clock_settime(), the new value of the clock shall be used to
determine the time at which the system shall awaken a thread blocked on an absolute clock_nanosleep() call based upon the CLOCK_REALTIME clock. If the absolute time
requested at the invocation of such a time service is before the new value of the clock, the call shall return immediately as if
the clock had reached the requested time normally.
Setting the value of the CLOCK_REALTIME clock via clock_settime() shall have no effect on any thread that is blocked on a
relative clock_nanosleep() call. Consequently, the call shall return when
the requested relative interval elapses, independently of the new or old value of the clock.
Appropriate privileges to set a particular clock are implementation-defined.
[CPT]
If _POSIX_CPUTIME is defined, implementations shall support clock ID values obtained by invoking clock_getcpuclockid(), which represent the CPU-time clock of a given process.
Implementations shall also support the special clockid_t value CLOCK_PROCESS_CPUTIME_ID, which represents the CPU-time clock
of the calling process when invoking one of the clock_*() or timer_*() functions. For these clock IDs, the values
returned by clock_gettime() and specified by clock_settime() represent the amount of execution time of the process
associated with the clock. Changing the value of a CPU-time clock via clock_settime() shall have no effect on the behavior
of the sporadic server scheduling policy (see Scheduling Policies
).
[TCT]
If _POSIX_THREAD_CPUTIME is defined, implementations shall support clock ID values obtained by invoking pthread_getcpuclockid(), which represent the CPU-time clock of a given thread.
Implementations shall also support the special clockid_t value CLOCK_THREAD_CPUTIME_ID, which represents the CPU-time clock
of the calling thread when invoking one of the clock_*() or timer_*() functions. For these clock IDs, the values
returned by clock_gettime() and specified by clock_settime() shall represent the amount of execution time of the
thread associated with the clock. Changing the value of a CPU-time clock via clock_settime() shall have no effect on the
behavior of the sporadic server scheduling policy (see Scheduling
Policies).
RETURN VALUE
A return value of 0 shall indicate that the call succeeded. A return value of -1 shall indicate that an error occurred, and
errno shall be set to indicate the error.
ERRORS
The clock_getres(), clock_gettime(), and clock_settime() functions shall fail if:
[EINVAL]
The clock_id argument does not specify a known clock.
The clock_gettime() function shall fail if:
[EOVERFLOW]
The number of seconds will not fit in an object of type time_t.
The clock_settime() function shall fail if:
[EINVAL]
The tp argument to clock_settime() is outside the range for the given clock ID.
[EINVAL]
The tp argument specified a nanosecond value less than zero or greater than or equal to 1000 million.
[EINVAL]
The value of the clock_id argument is CLOCK_MONOTONIC.
The clock_settime() function may fail if:
[EPERM]
The requesting process does not have appropriate privileges to set the specified clock.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Note that the absolute value of the monotonic clock is meaningless (because its origin is arbitrary), and thus there is no need
to set it. Furthermore, realtime applications can rely on the fact that the value of this clock is never set and, therefore, that
time intervals measured with this clock will not be affected by calls to clock_settime().
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
Scheduling Policies, clock_getcpuclockid(), clock_nanosleep(), ctime(),
mq_receive(), mq_send(),
nanosleep(), pthread_mutex_clocklock(), sem_clockwait(), thrd_sleep(),
time(), timer_create()
, timer_getoverrun()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Timers
option.
The APPLICATION USAGE section is added.
The following changes were made to align with the IEEE P1003.1a draft standard:
Clarification is added of the effect of resetting the clock resolution.
CPU-time clocks and the clock_getcpuclockid() function are added for
alignment with IEEE Std 1003.1d-1999.
The following changes are added for alignment with IEEE Std 1003.1j-2000:
The DESCRIPTION is updated as follows:
The value returned by clock_gettime() for CLOCK_MONOTONIC is specified.
The clock_settime() function failing for CLOCK_MONOTONIC is specified.
The effects of clock_settime() on the clock_nanosleep() function
with respect to CLOCK_REALTIME are specified.
An [EINVAL] error is added to the ERRORS section, indicating that clock_settime() fails for CLOCK_MONOTONIC.
The APPLICATION USAGE section notes that the CLOCK_MONOTONIC clock need not and shall not be set by clock_settime() since
the absolute value of the CLOCK_MONOTONIC clock is meaningless.
The clock_nanosleep(), mq_timedreceive(), mq_timedsend(), pthread_mutex_timedlock(), sem_timedwait(), timer_create(),
and timer_settime() functions are added to the SEE ALSO section.
Issue 7
Functionality relating to the Clock Selection option is moved to the Base.
The clock_getres(), clock_gettime(), and clock_settime() functions are moved from the Timers option to the
Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0058 [106] is applied.
Issue 8
Austin Group Defect 1302 is applied, changing "the nanosleep() function" to
"the nanosleep() and thrd_sleep() functions".
Austin Group Defect 1346 is applied, requiring support for Monotonic Clock.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/optarg.html =====
getopt
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getopt, optarg, opterr, optind, optopt — command option parsing
SYNOPSIS
#include
int getopt(int argc, char * const argv[], const char *optstring);
extern char *optarg;
extern int opterr, optind, optopt;
DESCRIPTION
The getopt() function is a command-line parser that shall follow Utility Syntax Guidelines 3, 4, 5, 6, 7, 9, and 10 in
XBD 12.2 Utility Syntax Guidelines.
The parameters argc and argv are the argument count and argument array as passed to main() (see exec()). The argument optstring is a string of recognized option characters; if a
character is followed by a , the option takes an argument. All option characters allowed by Utility Syntax Guideline 3
are allowed in optstring. The optstring argument can optionally start with a  ('+'), which
shall have no effect on behavior in a conforming environment. If a  occurs anywhere besides the first character of
optstring, the behavior is unspecified. The implementation may accept other characters as an extension.
The variable optind is the index of the next element of the argv[] vector to be processed. It shall be initialized
to 1 by the system, and getopt() shall update it when it finishes with each element of argv[]. If the application
sets optind to zero before calling getopt(), the behavior is unspecified. When an element of argv[] contains
multiple option characters, it is unspecified how getopt() determines which options have already been processed.
The getopt() function shall return the next option character (if one is found) from argv that matches a character
in optstring (excluding an optional leading ), if there is one that matches. If the option takes an
argument, getopt() shall set the variable optarg to point to the option-argument as follows:
If the option was the last character in the string pointed to by an element of argv, then optarg shall contain the
next element of argv, and optind shall be incremented by 2. If the resulting value of optind is greater than
argc, this indicates a missing option-argument, and getopt() shall return an error indication.
Otherwise, optarg shall point to the string following the option character in that element of argv, and
optind shall be incremented by 1.
If, when getopt() is called, any of the following is true:
argv[optind]  is a null pointer
*argv[optind]  is not the character '-'
argv[optind]  points to the string "-"
getopt() shall return -1 without changing optind. If:
argv[optind]   points to the string "--"
getopt() shall return -1 after incrementing optind.
If getopt() encounters a  as an option character, or an option character that is not contained in
optstring after an optional leading , it shall return the  ('?') character.
If it detects a missing option-argument, it shall return the  character (':') if the first character of
optstring after an optional  was a , or a  character ('?')
otherwise. In either case, getopt() shall set the variable optopt to the option character that caused the error. If
the application has not set the variable opterr to 0, and the first character of optstring after an optional
is not a , getopt() shall also print a diagnostic message to stderr in the format
specified for the getopts utility, unless the stderr stream has wide
orientation, in which case the behavior is undefined.
The getopt() function need not be thread-safe.
RETURN VALUE
The getopt() function shall return the next option character specified on the command line.
A  (':') shall be returned if getopt() detects a missing argument and the first character of
optstring after an optional  was a  (':').
A  ('?') shall be returned if getopt() encounters a  as an option character,
encounters an option character not in optstring, or detects a missing argument and the first character of optstring
after an optional  was not a  (':').
Otherwise, getopt() shall return -1 when all command line options are parsed.
ERRORS
If the application has not set the variable opterr to 0, the first character of optstring is not a ,
and a write error occurs while getopt() is printing a diagnostic message to stderr, then the error indicator for
stderr shall be set; but getopt() shall still succeed and the value of errno after getopt() is
unspecified.
The following sections are informative.
EXAMPLES
Parsing Command Line Options
The following code fragment shows how you might process the arguments for a utility that can take the mutually-exclusive options
a and b and the options f and o, both of which require arguments:
#include
#include
#include
int
main(int argc, char *argv[ ])
{
int c;
int bflg = 0, aflg = 0, errflg = 0;
char *ifile;
char *ofile;
. . .
while ((c = getopt(argc, argv, ":abf:o:")) != -1) {
switch(c) {
case 'a':
if (bflg)
errflg++;
else
aflg++;
break;
case 'b':
if (aflg)
errflg++;
else
bflg++;
break;
case 'f':
ifile = optarg;
break;
case 'o':
ofile = optarg;
break;
case ':':       /* -f or -o without operand */
fprintf(stderr,
"Option -%c requires an operand\n", optopt);
errflg++;
break;
case '?':
fprintf(stderr,
"Unrecognized option: '-%c'\n", optopt);
errflg++;
}
}
if (errflg) {
fprintf(stderr, "usage: . . . ");
exit(2);
}
for ( ; optind
#include
...
const char *Options = "hdbtl";
...
int dbtype, c;
char *st;
...
dbtype = 0;
while ((c = getopt(argc, argv, Options)) != -1) {
if ((st = strchr(Options, c)) != NULL) {
dbtype = st - Options;
break;
}
}
APPLICATION USAGE
The getopt() function is only required to support option characters included in Utility Syntax Guideline 3. Many
historical implementations of getopt() support other characters as options. This is an allowed extension, but applications
that use extensions are not maximally portable. Note that support for multi-byte option characters is only possible when such
characters can be represented as type int.
Applications which use wide-character output functions with stderr should ensure that any calls to getopt() do not
write to stderr, either by setting opterr to 0 or by ensuring the first character of optstring is always a
.
While ferror(stderr) may be used to detect failures to write a diagnostic to stderr when getopt()
returns '?', the value of errno is unspecified in such a condition. Applications desiring more control over
handling write failures should set opterr to 0 and independently perform output to stderr, rather than relying on
getopt() to do the output.
RATIONALE
The optopt variable represents historical practice and allows the application to obtain the identity of the invalid
option.
The description has been written to make it clear that getopt(), like the getopts utility, deals with option-arguments whether separated from the option by
characters or not. Note that the requirements on getopt() and getopts are more stringent than the Utility Syntax Guidelines.
The getopt() function shall return -1, rather than EOF, so that  is not required.
The special significance of a  as the first character of optstring makes getopt() consistent with the
getopts utility. It allows an application to make a distinction between a missing
argument and an incorrect option letter without having to examine the option letter. It is true that a missing argument can only be
detected in one case, but that is a case that has to be considered.
In some non-conforming environments, the use of a leading  in optstring forces getopt() to behave
in a conforming way, when it would otherwise have non-conforming behavior. Its use has been standardized to allow applications to
be written that can guarantee behavior consistent with this specification even in an otherwise non-conforming environment. If both
and  are used at the beginning of optstring, the  must be first.
Note that the use of a leading  in optstring is only standardized for getopt(). Use of a
is intentionally left unspecified for the getopts utility, where
historical implementations did not require a leading  for conforming behavior, and because some historical
getopts implementations used a leading  for a different
extension.
FUTURE DIRECTIONS
None.
SEE ALSO
exec
XBD 12.2 Utility Syntax Guidelines,
XCU getopts
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
A note indicating that the getopt() function need not be reentrant is added to the DESCRIPTION.
Issue 6
IEEE PASC Interpretation 1003.2 #150 is applied.
Austin Group Interpretation 1003.1-2001 #156 is applied.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0248 [318], XSH/TC1-2008/0249 [460], XSH/TC1-2008/0250 [189],
XSH/TC1-2008/0251 [189], XSH/TC1-2008/0252 [189], and XSH/TC1-2008/0253 [460] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0169 [608] is applied.
Issue 8
Austin Group Defect 191 is applied, allowing a leading  in optstring.
Austin Group Defect 1179 is applied, adding some missing '}' characters at the end of the example code.
Austin Group Defect 1523 is applied, clarifying the conditions under which getopt() returns -1 without changing
optind.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/scalbnl.html =====
scalbln
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
scalbln, scalblnf, scalblnl, scalbn, scalbnf, scalbnl — compute exponent using FLT_RADIX
SYNOPSIS
#include
double scalbln(double x, long n);
float scalblnf(float x, long n);
long double scalblnl(long double x, long n);
double scalbn(double x, int n);
float scalbnf(float x, int n);
long double scalbnl(long double x, int n);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute x * FLT_RADIXn efficiently, not normally by
computing FLT_RADIXn explicitly.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return x * FLT_RADIXn.
[MX]  If
the calculation does not overflow or underflow, the returned value shall be exact and shall be independent of the current rounding
direction mode.
If the result would cause overflow, a range error shall occur and these functions shall return ±HUGE_VAL, ±HUGE_VALF, and
±HUGE_VALL (according to the sign of x) as appropriate for the return type of the function.
If the correct value would cause underflow, [MXX]   and is not representable,   a range error may occur, and scalbln(), scalblnf(), scalblnl(),
scalbn(), scalbnf(), and scalbnl() shall return [MXX]
0.0, or   (if IEC 60559 Floating-Point is not supported) an implementation-defined value no greater in
magnitude than DBL_MIN, FLT_MIN, LDBL_MIN, DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0 or ±Inf, x shall be returned.
If n is 0, x shall be returned.
[MXX]
If the correct value would cause underflow, and is representable, a range error may occur and the correct value shall be returned.
ERRORS
These functions shall fail if:
Range Error
The result overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
These functions may fail if:
Range Error
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
These functions are named so as to avoid conflicting with the historical definition of the scalb() function from the
Single UNIX Specification. The difference is that the scalb() function has a second argument of double instead of
int. The scalb() function is not part of the ISO C standard. The three functions whose second type is
long are provided because the factor required to scale from the smallest positive floating-point value to the largest finite
one, on many implementations, is too large to represent in the minimum-width int format.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0521 [68] and XSH/TC1-2008/0522 [68] are applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getpwnam_r.html =====
getpwnam
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getpwnam, getpwnam_r — search user database for a name
SYNOPSIS
#include
struct passwd *getpwnam(const char *name);
int getpwnam_r(const char *name, struct passwd *pwd, char *buffer,
size_t bufsize, struct passwd **result);
DESCRIPTION
The getpwnam() function shall search the user database for an entry with a matching name.
The getpwnam() function need not be thread-safe.
Applications wishing to check for error situations should set errno to 0 before calling getpwnam(). If
getpwnam() returns a null pointer and errno is non-zero, an error occurred.
The getpwnam_r() function shall update the passwd structure pointed to by pwd and store a pointer to that
structure at the location pointed to by result. The structure shall contain an entry from the user database with a matching
name. Storage referenced by the structure is allocated from the memory provided with the buffer parameter, which is
bufsize bytes in size. A call to sysconf(_SC_GETPW_R_SIZE_MAX) returns either -1 without changing errno or an
initial value suggested for the size of this buffer. A null pointer shall be returned at the location pointed to by result
on error or if the requested entry is not found.
RETURN VALUE
The getpwnam() function shall return a pointer to a struct passwd with the structure as defined in  with a matching entry if found. A null pointer shall be returned if the requested
entry is not found, or an error occurs. If the requested entry was not found, errno shall not be changed. On error,
errno shall be set to indicate the error.
The application shall not modify the structure to which the return value points, nor any storage areas pointed to by pointers
within the structure. The returned pointer, and pointers within the structure, might be invalidated or the structure or the storage
areas might be overwritten by a subsequent call to getpwent(), getpwnam(),
or getpwuid(). The returned pointer, and pointers within the structure, might also
be invalidated if the calling thread is terminated.
The getpwnam_r() function shall return zero on success or if the requested entry was not found and no error has occurred.
If an error has occurred, an error number shall be returned to indicate the error.
ERRORS
These functions may fail if:
[EIO]
An I/O error has occurred.
[EINTR]
A signal was caught during getpwnam().
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum allowable number of files is currently open in the system.
The getpwnam_r() function shall fail if:
[ERANGE]
Insufficient storage was supplied via buffer and bufsize to contain the data to be referenced by the resulting
passwd structure.
The following sections are informative.
EXAMPLES
Note that sysconf(_SC_GETPW_R_SIZE_MAX) may return -1 if there is no hard limit on the size of the buffer needed to store
all the groups returned. This example shows how an application can allocate a buffer of sufficient size to work with
getpwnam_r().
long int initlen = sysconf(_SC_GETPW_R_SIZE_MAX);
size_t len;
if (initlen == -1)
/* Default initial length. */
len = 1024;
else
len = (size_t) initlen;
struct passwd result;
struct passwd *resultp;
char *buffer = malloc(len);
if (buffer == NULL)
...handle error...
int e;
while ((e = getpwnam_r("someuser", &result, buffer, len, &resultp))
== ERANGE)
{
size_t newlen = 2 * len;
if (newlen
#include
#include
#include
#include
...
char *lgn;
struct passwd *pw;
...
if ((lgn = getlogin()) == NULL || (pw = getpwnam(lgn)) == NULL) {
fprintf(stderr, "Get of user information failed.\n"); exit(1);
}
...
APPLICATION USAGE
Three names associated with the current process can be determined: getpwuid(geteuid()) returns the name associated with the effective user ID of the process; getlogin() returns the name associated with the current login activity; and
getpwuid(getuid()) returns the name associated with the real user ID of the
process.
The getpwnam_r() function is thread-safe and returns values in a user-supplied buffer instead of possibly using a static
data area that may be overwritten by each call.
Portable applications should take into account that it is usual for an implementation to return -1 from sysconf() indicating that there is no maximum for _SC_GETPW_R_SIZE_MAX.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
getpwuid(), sysconf()
XBD ,
CHANGE HISTORY
First released in Issue 1. Derived from System V Release 2.0.
Issue 5
Normative text previously in the APPLICATION USAGE section is moved to the RETURN VALUE section.
The getpwnam_r() function is included for alignment with the POSIX Threads Extension.
A note indicating that the getpwnam() function need not be reentrant is added to the DESCRIPTION.
Issue 6
The getpwnam_r() function is marked as part of the Thread-Safe Functions option.
The Open Group Corrigendum U028/3 is applied, correcting text in the DESCRIPTION describing matching the name.
In the SYNOPSIS, the optional include of the  header is
removed.
In the DESCRIPTION, the note about reentrancy is expanded to cover thread-safety.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
In the RETURN VALUE section, the requirement to set errno on error is added.
The [EMFILE], [ENFILE], and [ENXIO] optional error conditions are added.
The APPLICATION USAGE section is updated to include a note on the thread-safe function and its avoidance of possibly using a
static data area.
IEEE PASC Interpretation 1003.1 #116 is applied, changing the description of the size of the buffer from bufsize
characters to bytes.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
SD5-XBD-ERN-4 is applied, changing the definition of the [EMFILE] error.
SD5-XSH-ERN-166 is applied.
The getpwnam_r() function is moved from the Thread-Safe Functions option to the Base.
A minor addition is made to the EXAMPLES section, reminding the application developer to free memory allocated as if by malloc().
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0255 [75,428] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0170 [808] and XSH/TC2-2008/0171 [656] are applied.
Issue 8
Austin Group Defect 398 is applied, changing the [ERANGE] error from "may fail" to "shall fail".
Austin Group Defect 1570 is applied, removing extra spacing in "==".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atomic_fetch_or_explicit.html =====
atomic_fetch_add
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atomic_fetch_add, atomic_fetch_add_explicit, atomic_fetch_and, atomic_fetch_and_explicit, atomic_fetch_or,
atomic_fetch_or_explicit, atomic_fetch_sub, atomic_fetch_sub_explicit, atomic_fetch_xor, atomic_fetch_xor_explicit — atomically
replace the value of an object with the result of a computation
SYNOPSIS
#include
C atomic_fetch_add(volatile A *object, M operand); C
atomic_fetch_add_explicit(volatile A *object, M operand,
memory_order order); C atomic_fetch_and(volatile A
*object, M operand); C atomic_fetch_and_explicit(volatile A
*object, M operand,
memory_order order); C atomic_fetch_or(volatile A
*object, M operand); C atomic_fetch_or_explicit(volatile A
*object, M operand,
memory_order order); C atomic_fetch_sub(volatile A
*object, M operand); C atomic_fetch_sub_explicit(volatile A
*object, M operand,
memory_order order); C atomic_fetch_xor(volatile A
*object, M operand); C atomic_fetch_xor_explicit(volatile A
*object, M operand,
memory_order order);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
Implementations that define the macro __STDC_NO_ATOMICS__ need not provide the  header nor support these generic functions.
The atomic_fetch_add_explicit() generic function shall atomically replace the value pointed to by object with the
result of adding operand to this value. This operation shall be an atomic read-modify-write operation (see XBD 4.15.1 Memory Ordering). Memory shall be affected according to the value of
order.
The atomic_fetch_add() generic function shall be equivalent to atomic_fetch_add_explicit() called with
order set to memory_order_seq_cst.
The other atomic_fetch_*() generic functions shall be equivalent to atomic_fetch_add_explicit() if their name ends
with explicit, or to atomic_fetch_add() if it does not, respectively, except that they perform the computation
indicated in their name, instead of addition:
sub
subtraction
or
bitwise inclusive OR
xor
bitwise exclusive OR
and
bitwise AND
For addition and subtraction, the application shall ensure that A is an atomic integer type or an atomic pointer type and is not
atomic_bool. For the other operations, the application shall ensure that A is an atomic integer type and is not
atomic_bool.
For signed integer types, the computation shall silently wrap around on overflow; there are no undefined results. For pointer
types, the result can be an undefined address, but the computations otherwise have no undefined behavior.
RETURN VALUE
These generic functions shall return the value pointed to by object immediately before the effects.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The operation of these generic functions is nearly equivalent to the operation of the corresponding compound assignment
operators +=, -=, etc. The only differences are that the compound assignment operators are not guaranteed to
operate atomically, and the value yielded by a compound assignment operator is the updated value of the object, whereas the value
returned by these generic functions is the previous value of the atomic object.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD 4.15.1 Memory Ordering,
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcstol.html =====
wcstol
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcstol, wcstoll — convert a wide-character string to a long integer
SYNOPSIS
#include
long wcstol(const wchar_t *restrict nptr, wchar_t **restrict endptr,
int base);
long long wcstoll(const wchar_t *restrict nptr,
wchar_t **restrict endptr, int base);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall convert the initial portion of the wide-character string pointed to by nptr to long and
long long, respectively. First, they shall decompose the input string into three parts:
An initial, possibly empty, sequence of white-space wide characters
A subject sequence interpreted as an integer represented in some radix determined by the value of base
A final wide-character string of one or more unrecognized wide-character codes, including the terminating null wide-character
code of the input wide-character string
Then they shall attempt to convert the subject sequence to an integer, and return the result.
If base is 0, the expected form of the subject sequence is that of a decimal constant, octal constant, or hexadecimal
constant, any of which may be preceded by a '+' or '-' sign. A decimal constant begins with a non-zero digit, and
consists of a sequence of decimal digits. An octal constant consists of the prefix '0' optionally followed by a sequence
of the digits '0' to '7' only. A hexadecimal constant consists of the prefix 0x or 0X followed by a sequence of
the decimal digits and letters 'a' (or 'A') to 'f' (or 'F') with values 10 to 15
respectively.
If the value of base is between 2 and 36, the expected form of the subject sequence is a sequence of letters and digits
representing an integer with the radix specified by base, optionally preceded by a '+' or '-' sign, but
not including an integer suffix. The letters from 'a' (or 'A') to 'z' (or 'Z') inclusive are
ascribed the values 10 to 35; only letters whose ascribed values are less than that of base shall be permitted. If the value
of base is 16, the wide-character code representations of 0x or 0X may optionally precede the sequence of letters and
digits, following the sign if present.
The subject sequence is defined as the longest initial subsequence of the input wide-character string, starting with the first
non-white-space wide character, that is of the expected form. The subject sequence contains no wide-character codes if the input
wide-character string is empty or consists entirely of white-space wide characters, or if the first non-white-space wide character
is other than a sign or a permissible letter or digit.
If the subject sequence has the expected form and base is 0, the sequence of wide-character codes starting with the first
digit shall be interpreted as an integer constant. If the subject sequence has the expected form and the value of base is
between 2 and 36, it shall be used as the base for conversion, ascribing to each letter its value as given above. If the subject
sequence begins with a , the resulting value shall be the negative of the converted value. A pointer to the
final wide-character string shall be stored in the object pointed to by endptr, provided that endptr is not a null
pointer.
In other than the C [CX]   or POSIX  locale, additional
locale-specific subject sequence forms may be accepted.
If the subject sequence is empty or does not have the expected form, no conversion shall be performed; the value of nptr
shall be stored in the object pointed to by endptr, provided that endptr is not a null pointer.
These functions shall not change the setting of errno if successful.
Since 0, {LONG_MIN} or {LLONG_MIN} and {LONG_MAX} or {LLONG_MAX} are returned on error and are also valid returns on success, an
application wishing to check for error situations should set errno to 0, then call wcstol() or wcstoll(), then
check errno.
RETURN VALUE
Upon successful completion, these functions shall return the converted value, if any. If no conversion could be performed, 0
shall be returned [CX]   and errno may be set to indicate the error.  If the correct value is outside the range of representable values, {LONG_MIN}, {LONG_MAX}, {LLONG_MIN}, or {LLONG_MAX} shall
be returned (according to the sign of the value), and errno set to [ERANGE].
ERRORS
These functions shall fail if:
[EINVAL]
[CX]
The value of base is not supported.
[ERANGE]
The value to be returned is not representable.
These functions may fail if:
[EINVAL]
[CX]  No
conversion could be performed.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
fscanf(), iswalpha(), wcstod()
XBD
CHANGE HISTORY
First released in Issue 4. Derived from the MSE working draft.
Issue 5
The DESCRIPTION is updated to indicate that errno is not changed if the function is successful.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the RETURN VALUE and ERRORS sections, the [EINVAL] optional error condition is added if no conversion could be performed.
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The wcstol() prototype is updated.
The wcstoll() function is added.
Issue 7
SD5-XSH-ERN-56 is applied, removing the reference to unsigned long and unsigned long long from the
DESCRIPTION.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0725 [105] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0393 [584] and XSH/TC2-2008/0394 [796] are applied.
Issue 8
Austin Group Defect 700 is applied, clarifying how a subject sequence beginning with  is converted.
Austin Group Defect 1163 is applied, clarifying the handling of white space in the input string.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mbtowc.html =====
mbtowc
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mbtowc — convert a character to a wide-character code
SYNOPSIS
#include
int mbtowc(wchar_t *restrict pwc, const char *restrict s, size_t n);
DESCRIPTION
[CX]  Except for requirements relating to data races, the functionality described on this reference page is aligned with the
ISO C standard. Any other conflict between the requirements described here and the ISO C standard is unintentional. This
volume of POSIX.1-2024 defers to the ISO C standard for all mbtowc() functionality except in relation to data races.
If s is not a null pointer, mbtowc() shall determine the number of bytes that constitute the character pointed to
by s. It shall then determine the wide-character code for the value of type wchar_t that corresponds to that
character. (The value of the wide-character code corresponding to the null byte is 0.) If the character is valid and pwc is
not a null pointer, mbtowc() shall store the wide-character code in the object pointed to by pwc.
The behavior of this function is affected by the LC_CTYPE category of the current locale. For a state-dependent encoding,
this function shall be placed into its initial state at program startup and can be returned to that state by a call for which its
character pointer argument, s, is a null pointer. Subsequent calls with s as other than a null pointer shall cause
the internal state of the function to be altered as necessary. A call with s as a null pointer shall cause this function to
return a non-zero value if encodings have state dependency, and 0 otherwise. If the implementation employs special bytes to change
the shift state, these bytes shall not produce separate wide-character codes, but shall be grouped with an adjacent character.
Changing the LC_CTYPE category causes the shift state of this function to be unspecified. At most n bytes of the
array pointed to by s shall be examined.
The implementation shall behave as if no function defined in this volume of POSIX.1-2024 calls mbtowc().
The mbtowc() function [CX]   need not be thread-safe; however, it   shall avoid data races with all other functions.
RETURN VALUE
If s is a null pointer, mbtowc() shall return a non-zero or 0 value, if character encodings, respectively, do or
do not have state-dependent encodings. If s is not a null pointer, mbtowc() shall either return 0 (if s points
to the null byte), or return the number of bytes that constitute the converted character (if the next n or fewer bytes form
a valid character), or return -1 [CX]   and shall set errno to indicate the error  (if they do not form a valid character).
In no case shall the value returned be greater than n or the value of the {MB_CUR_MAX} macro.
ERRORS
The mbtowc() function shall fail if:
[EILSEQ]
[CX]  An
invalid character sequence is detected. In the POSIX locale an [EILSEQ] error cannot occur since all byte values are valid
characters.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
When the ISO C standard introduced threads in C11, it required mbtowc() to avoid data races (with itself as well as
with other functions), whereas POSIX.1-2008 did not require it to be thread-safe, and in many implementations it did not avoid data
races with itself and still does not. The ISO C committee intend to change the requirements in a future version of the ISO C
standard, but since POSIX.1 currently refers to C17 it is necessary for it not to defer to the ISO C standard regarding data
races in order to continue to allow this function not to avoid data races with itself.
FUTURE DIRECTIONS
It is expected that a change in a future version of the ISO C standard will allow a future version of this standard to
remove the data race exception from the statement that it defers to the ISO C standard.
SEE ALSO
mblen(), mbstowcs(), wctomb(), wcstombs()
XBD
CHANGE HISTORY
First released in Issue 4. Aligned with the ISO C standard.
Issue 6
The mbtowc() prototype is updated for alignment with the ISO/IEC 9899:1999 standard.
Extensions beyond the ISO C standard are marked.
Issue 7
Austin Group Interpretation 1003.1-2001 #170 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0372 [109] and XSH/TC1-2008/0373 [195] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0209 [663,674] is applied.
Issue 8
Austin Group Defects 708 and 1302 are applied, aligning this function with the ISO/IEC 9899:2018 standard, except in
relation to data races.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/isupper_l.html =====
isupper
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
isupper, isupper_l — test for an uppercase letter
SYNOPSIS
#include
int isupper(int c);
[CX]  int isupper_l(int c, locale_t locale);
DESCRIPTION
For isupper(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The isupper() [CX]   and isupper_l()
functions shall test whether c is a character of class upper in the current locale, [CX]   or in the
locale represented by locale,  respectively; see XBD 7. Locale.
The c argument is an int, the value of which the application shall ensure is a character representable as an
unsigned char or equal to the value of the macro EOF. If the argument has any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to isupper_l() is the special locale object LC_GLOBAL_LOCALE or is not a
valid locale object handle.
RETURN VALUE
The isupper() [CX]   and isupper_l()
functions shall return non-zero if c is an uppercase letter; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
isalnum(), isalpha(), isblank(), iscntrl(), isdigit(), isgraph(), islower(), isprint(), ispunct(), isspace(), isxdigit(), setlocale(), uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The isupper_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0306 [302], XSH/TC1-2008/0307 [283], and XSH/TC1-2008/0308 [283] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/signgam.html =====
lgamma
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
lgamma, lgammaf, lgammal, signgam — log gamma function
SYNOPSIS
#include
double lgamma(double x);
float lgammaf(float x);
long double lgammal(long double x);
[XSI]  extern int signgam;
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute
\(
\log _e \mid \Gamma(x) \mid \text { where } \Gamma(x) \text { is defined as } \int_0^{\infty} e^{-t} t^{x-1} d t \text {. }
\)
The argument \(x\) need not be a non-positive integer \( (\Gamma(x) \) is defined over the reals,
except the non-positive integers).
[XSI]
The sign of
\( \Gamma(x) \)
shall be returned in the external integer signgam. If \(x\) is NaN,
-Inf, or a negative integer, the value of signgam is unspecified.
If concurrent calls are made to these functions, the value of signgam is indeterminate.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the logarithmic gamma of \(x\).
If \(x\) is a non-positive integer, a pole error shall occur and lgamma(), lgammaf(), and lgammal()
shall return +HUGE_VAL, +HUGE_VALF, and +HUGE_VALL, respectively.
If the correct value would cause overflow, a range error shall occur and lgamma(), lgammaf(), and lgammal()
shall return ±HUGE_VAL, ±HUGE_VALF, and ±HUGE_VALL (having the same sign as the correct value), respectively.
[MX]  If
\(x\) is NaN, a NaN shall be returned.
If \(x\) is 1 or 2, +0 shall be returned.
If \(x\) is ±Inf, +Inf shall be returned.
ERRORS
These functions shall fail if:
Pole Error
The \(x\) argument is a negative integer or zero.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If
the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the divide-by-zero floating-point exception
shall be raised.
Range Error
The result overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If
the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall
be raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are
independent of each other, but at least one of them must be non-zero.
If the value of signgam will be obtained after a call to lgamma(), lgammaf(), or lgammal(), in order
to ensure that the value will not be altered by another call in a different thread, applications should either restrict calls to
these functions to be from a single thread or use a lock such as a mutex or spin lock to protect a critical section starting before
the function call and ending after the value of signgam has been obtained.
RATIONALE
Earlier versions of this standard did not require lgamma(), lgammaf(), and lgammal() to be thread-safe
because signgam was a global variable. They are now required to be thread-safe to align with the ISO C standard (which,
since the introduction of threads in 2011, requires that they avoid data races), with the exception that they need not avoid data
races when storing a value in the signgam variable. Since signgam is not specified by the ISO C standard, this
exception is not a conflict with that standard.
FUTURE DIRECTIONS
None.
SEE ALSO
exp, feclearexcept, fetestexcept, isnan
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 3.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
A note indicating that this function need not be reentrant is added to the DESCRIPTION.
Issue 6
The lgamma() function is no longer marked as an extension.
The lgammaf() and lgammal() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Functionality relating to the XSI option is marked.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
The DESCRIPTION is clarified regarding the value of signgam when \(x\) is Nan, -Inf, or a negative integer.
Issue 8
Austin Group Defect 1002 is applied, reinstating the requirement for the sign of \( \Gamma(x) \) to be
returned in signgam, which had been accidentally removed in Issue 7.
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getprotobynumber.html =====
endprotoent
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
endprotoent, getprotobyname, getprotobynumber, getprotoent, setprotoent — network protocol database
functions
SYNOPSIS
#include
void endprotoent(void);
struct protoent *getprotobyname(const char *name);
struct protoent *getprotobynumber(int proto);
struct protoent *getprotoent(void);
void setprotoent(int stayopen);
DESCRIPTION
These functions shall retrieve information about protocols. This information is considered to be stored in a database that can
be accessed sequentially or randomly. The implementation of this database is unspecified.
The setprotoent() function shall open a connection to the database, and set the next entry to the first entry. If the
stayopen argument is non-zero, the connection to the network protocol database shall not be closed after each call to
getprotoent() (either directly, or indirectly through one of the other getproto*() functions), and the implementation
may maintain an open file descriptor for the database. If a file descriptor is used, the FD_CLOEXEC flag shall be set; see .
The getprotobyname() function shall search the database from the beginning and find the first entry for which the
protocol name specified by name matches the p_name member, opening and closing a connection to the database as
necessary.
The getprotobynumber() function shall search the database from the beginning and find the first entry for which the
protocol number specified by proto matches the p_proto member, opening and closing a connection to the database as
necessary.
The getprotoent() function shall read the next entry of the database, opening and closing a connection to the database as
necessary.
The getprotobyname(), getprotobynumber(), and getprotoent() functions shall each return a pointer to a
protoent structure, the members of which shall contain the fields of an entry in the network protocol database.
The endprotoent() function shall close the connection to the database, releasing any open file descriptor.
These functions need not be thread-safe.
RETURN VALUE
Upon successful completion, getprotobyname(), getprotobynumber(), and getprotoent() return a pointer to a
protoent structure if the requested entry was found, and a null pointer if the end of the database was reached or the
requested entry was not found. Otherwise, a null pointer is returned.
The application shall not modify the structure to which the return value points, nor any storage areas pointed to by pointers
within the structure. The returned pointer, and pointers within the structure, might be invalidated or the structure or the storage
areas might be overwritten by a subsequent call to getprotobyname(), getprotobynumber(), or getprotoent(). The
returned pointer, and pointers within the structure, might also be invalidated if the calling thread is terminated.
ERRORS
The getprotobyname(), getprotobynumber(), getprotoent(), and setprotoent() functions may fail
if:
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum allowable number of files is currently open in the system.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0085 [75] and XSH/TC1-2008/0086 [75] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0091 [656] is applied.
Issue 8
Austin Group Defect 368 is applied, adding a requirement for FD_CLOEXEC to be set if a file descriptor is used, and adding the
[EMFILE] and [ENFILE] errors.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/rintf.html =====
rint
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
rint, rintf, rintl — round-to-nearest integral value
SYNOPSIS
#include
double rint(double x);
float rintf(float x);
long double rintl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall return the integral value (represented as a double) nearest x in the direction of the
current rounding mode. The current rounding mode is implementation-defined.
If the current rounding mode rounds toward negative infinity, then rint() shall be equivalent to floor(). If the current rounding mode rounds toward positive infinity, then rint()
shall be equivalent to ceil(). If the current rounding mode rounds towards zero, then
rint() shall be equivalent to trunc(). [MX]   If the current
rounding mode rounds towards nearest, then rint() differs from round() in that
halfway cases are rounded to even rather than away from zero.
These functions differ from the nearbyint(), nearbyintf(), and nearbyintl()
functions only in that they may raise the inexact floating-point exception if the result differs in value from the argument.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the integer (represented as a double precision number) nearest x
in the direction of the current rounding mode. [MX]   The result shall have the same sign as x.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0 or ±Inf, x shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The integral value returned by these functions need not be expressible as an intmax_t. The return value should be tested
before assigning it to an integer type to avoid the undefined results of an integer overflow.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
abs(), ceil(), feclearexcept(), fetestexcept()
, floor(), isnan(), nearbyint()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The rintf() and rintl() functions are added.
The rint() function is no longer marked as an extension.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0514 [346], XSH/TC1-2008/0515 [346], XSH/TC1-2008/0516 [346],
XSH/TC1-2008/0517 [346], and XSH/TC1-2008/0518 [346] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/thrd_exit.html =====
thrd_exit
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
thrd_exit — thread termination
SYNOPSIS
#include
_Noreturn void thrd_exit(int res);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
For every thread-specific storage key [CX]  (regardless of whether it has type tss_t or pthread_key_t)
which was created with a non-null destructor and for which the
value is non-null, thrd_exit() shall set the value associated with the key to a null pointer value and then invoke the
destructor with its previous value. The order in which destructors are invoked is unspecified.
If after this process there remain keys with both non-null destructors and values, the implementation shall repeat this process
up to [CX]
{PTHREAD_DESTRUCTOR_ITERATIONS}  times.
Following this, the thrd_exit() function shall terminate execution of the calling thread and shall set its exit status to
res. [CX]   Thread termination shall not release any application visible process resources, including, but not limited to,
mutexes and file descriptors, nor shall it perform any process-level cleanup actions, including, but not limited to, calling any
atexit() routines that might exist.
An implicit call to thrd_exit() is made when a thread that was created using thrd_create() returns from the start routine that was used to create it (see thrd_create()).
[CX]  The
behavior of thrd_exit() is undefined if called from a destructor function that was invoked as a result of either an implicit
or explicit call to thrd_exit().
The process shall exit with an exit status of zero after the last thread has been terminated. The behavior shall be as if the
implementation called exit() with a zero argument at thread termination time.
RETURN VALUE
This function shall not return a value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Calls to thrd_exit() should not be made from threads created using pthread_create() or via a SIGEV_THREAD notification, as their exit status has a
different type (void * instead of int). If thrd_exit() is called from the initial thread and it is not the
last thread to terminate, other threads should not try to obtain its exit status using pthread_join().
RATIONALE
The normal mechanism by which a thread that was started using thrd_create()
terminates is to return from the function that was specified in the thrd_create() call that started it. The thrd_exit() function provides the
capability for such a thread to terminate without requiring a return from the start routine of that thread, thereby providing a
function analogous to exit().
Regardless of the method of thread termination, the destructors for any existing thread-specific data are executed.
FUTURE DIRECTIONS
None.
SEE ALSO
exit(), pthread_create(), thrd_join()
XBD
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcscmp.html =====
wcscmp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcscmp — compare two wide-character strings
SYNOPSIS
#include
int wcscmp(const wchar_t *ws1, const wchar_t *ws2);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The wcscmp() function shall compare the wide-character string pointed to by ws1 to the wide-character string
pointed to by ws2.
The sign of a non-zero return value shall be determined by the sign of the difference between the values of the first pair of
wide-character codes that differ in the objects being compared.
[CX]  The
wcscmp() function shall not change the setting of errno on valid input.
RETURN VALUE
Upon completion, wcscmp() shall return an integer greater than, equal to, or less than 0, if the wide-character string
pointed to by ws1 is greater than, equal to, or less than the wide-character string pointed to by ws2,
respectively.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
wcscasecmp(), wcsncmp()
XBD
CHANGE HISTORY
First released in Issue 4. Derived from the MSE working draft.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that wcscmp() does not change the setting of errno on
valid input.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/csinhf.html =====
csinh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
csinh, csinhf, csinhl — complex hyperbolic sine functions
SYNOPSIS
#include
double complex csinh(double complex z);
float complex csinhf(float complex z);
long double complex csinhl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex hyperbolic sine of z.
RETURN VALUE
These functions shall return the complex hyperbolic sine value.
[MXC]
csinh(conj(z)), csinhf(conjf(z)), and csinhl(conjl(z)) shall return
exactly the same value as conj(csinh(z)), conjf(csinhf(z)), and
conjl(csinhl(z)), respectively, and csinh(-z), csinhf(-z), and
csinhl(-z) shall return exactly the same value as -csinh(z), -csinhf(z), and
-csinhl(z), respectively, including for the special values of z below.
If z is +0 + i0, +0 + i0 shall be returned.
If z is +0 + iInf, ±0 + iNaN shall be returned and the invalid floating-point exception shall be raised;
the sign of the real part of the result is unspecified.
If z is +0 + iNaN, ±0 + iNaN shall be returned; the sign of the real part of the result is unspecified.
If z is x + iInf where x is positive and finite, NaN + iNaN shall be returned and the invalid
floating-point exception shall be raised.
If z is x + iNaN where x is non-zero and finite, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is +Inf + i0, +Inf + i0 shall be returned.
If z is +Inf + iy where y is positive and finite, +Inf (cos(y) + isin(y)) shall
be returned.
If z is +Inf + iInf, ±Inf + iNaN shall be returned and the invalid floating-point exception shall be
raised; the sign of the real part of the result is unspecified.
If z is +Inf + iNaN, ±Inf + iNaN shall be returned; the sign of the real part of the result is
unspecified.
If z is NaN + i0, NaN + i0 shall be returned.
If z is NaN + iy where y is any non-zero number, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is NaN + iNaN, NaN + iNaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
casinh()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/memmove.html =====
memmove
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
memmove — copy bytes in memory with overlapping areas
SYNOPSIS
#include
void *memmove(void *s1, const void *s2, size_t n);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The memmove() function shall copy n bytes from the object pointed to by s2 into the object pointed to by
s1. Copying takes place as if the n bytes from the object pointed to by s2 are first copied into a temporary
array of n bytes that does not overlap the objects pointed to by s1 and s2, and then the n bytes from
the temporary array are copied into the object pointed to by s1.
[CX]  The
memmove() function shall not change the setting of errno on valid input.
RETURN VALUE
The memmove() function shall return s1; no return value is reserved to indicate an error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 4. Derived from the ANSI C standard.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that memmove() does not change the setting of errno on
valid input.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mlockall.html =====
mlockall
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mlockall, munlockall — lock/unlock the address space of a process (REALTIME)
SYNOPSIS
[ML]  #include
int mlockall(int flags);
int munlockall(void);
DESCRIPTION
The mlockall() function shall cause all of the pages mapped by the address space of a process to be memory-resident until
unlocked or until the process exits or execs another process image. The flags
argument determines whether the pages to be locked are those currently mapped by the address space of the process, those that are
mapped in the future, or both. The flags argument is constructed from the bitwise-inclusive OR of one or more of the
following symbolic constants, defined in :
MCL_CURRENT
Lock all of the pages currently mapped into the address space of the process.
MCL_FUTURE
Lock all of the pages that become mapped into the address space of the process in the future, when those mappings are
established.
If MCL_FUTURE is specified, and the automatic locking of future mappings eventually causes the amount of locked memory to exceed
the amount of available physical memory or any other implementation-defined limit, the behavior is implementation-defined. The
manner in which the implementation informs the application of these situations is also implementation-defined.
The munlockall() function shall unlock all currently mapped pages of the address space of the process. Any pages that
become mapped into the address space of the process after a call to munlockall() shall not be locked, unless there is an
intervening call to mlockall() specifying MCL_FUTURE or a subsequent call to mlockall() specifying MCL_CURRENT. If
pages mapped into the address space of the process are also mapped into the address spaces of other processes and are locked by
those processes, the locks established by the other processes shall be unaffected by a call by this process to
munlockall().
Upon successful return from the mlockall() function that specifies MCL_CURRENT, all currently mapped pages of the address
space of the process shall be memory-resident and locked. Upon return from the munlockall() function, all currently mapped
pages of the address space of the process shall be unlocked with respect to the address space of the process. The memory residency
of unlocked pages is unspecified.
Appropriate privileges are required to lock process memory with mlockall().
RETURN VALUE
Upon successful completion, the mlockall() function shall return a value of zero. Otherwise, no additional memory shall
be locked, and the function shall return a value of -1 and set errno to indicate the error. The effect of failure of
mlockall() on previously existing locks in the address space is unspecified.
If it is supported by the implementation, the munlockall() function shall always return a value of zero. Otherwise, the
function shall return a value of -1 and set errno to indicate the error.
ERRORS
The mlockall() function shall fail if:
[EAGAIN]
Some or all of the memory identified by the operation could not be locked when the call was made.
[EINVAL]
The flags argument is zero, or includes unimplemented flags.
The mlockall() function may fail if:
[ENOMEM]
Locking all of the pages currently mapped into the address space of the process would exceed an implementation-defined limit on
the amount of memory that the process may lock.
[EPERM]
The calling process does not have appropriate privileges to perform the requested operation.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
exec, exit(), fork(), mlock(), munmap()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The mlockall() and munlockall() functions are marked as part of the Process Memory Locking option.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Process
Memory Locking option.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/regerror.html =====
regcomp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
regcomp, regerror, regexec, regfree — regular expression matching
SYNOPSIS
#include
int regcomp(regex_t *restrict preg, const char *restrict pattern,
int cflags);
size_t regerror(int errcode, const regex_t *restrict preg,
char *restrict errbuf, size_t errbuf_size);
int regexec(const regex_t *restrict preg, const char *restrict string,
size_t nmatch, regmatch_t pmatch[restrict], int
eflags);
void regfree(regex_t *preg);
DESCRIPTION
These functions interpret basic and extended regular expressions as described in XBD 9. Regular Expressions.
The regex_t structure is defined in  and contains at least
the following member:
Member Type
Member Name
Description
size_t
re_nsub
Number of parenthesized subexpressions.
The regmatch_t structure is defined in  and
contains at least the following members:
Member Type
Member Name
Description
regoff_t
rm_so
Byte offset from start of string to start of substring.
regoff_t
rm_eo
Byte offset from start of string of the first character after the end of substring.
The regcomp() function shall compile the regular expression contained in the string pointed to by the
pattern argument and place the results in the structure pointed to by preg. The cflags argument is the
bitwise-inclusive OR of zero or more of the following flags, which are defined in the  header:
REG_EXTENDED
Use Extended Regular Expressions.
REG_ICASE
Perform matching in a case-insensitive manner (see XBD 9.2 Regular Expression
General Requirements).
REG_MINIMAL
Change the matching behavior for duplication symbols to the leftmost shortest possible match, and invert the behavior of the
repetition modifier '?' () to match the longest possible match instead of the shortest. Only
applicable to REG_EXTENDED regular expressions.
REG_NOSUB
Report only success/fail in regexec().
REG_NEWLINE
Change the handling of  characters, as described in the text.
The default regular expression type for pattern is a Basic Regular Expression. The application can specify
Extended Regular Expressions using the REG_EXTENDED cflags flag.
If the REG_NOSUB flag was not set in cflags, then regcomp() shall set re_nsub to the number of
parenthesized subexpressions (delimited by "\(\)" in basic regular expressions or "()" in extended regular
expressions) found in pattern.
The regexec() function compares the null-terminated string specified by string with the compiled
regular expression preg initialized by a previous call to regcomp(). If it finds a match, regexec() shall
return 0; otherwise, it shall return non-zero indicating either no match or an error. The eflags argument is the
bitwise-inclusive OR of zero or more of the following flags, which are defined in the  header:
REG_NOTBOL
The first character of the string pointed to by string is not the beginning of the line. Therefore, the
character ('^'), when taken as a special character, shall not match the beginning of
string.
REG_NOTEOL
The last character of the string pointed to by string is not the end of the line. Therefore, the
('$'), when taken as a special character, shall not match the end of string.
If nmatch is 0 or REG_NOSUB was set in the cflags argument to regcomp(), then regexec()
shall ignore the pmatch argument. Otherwise, the application shall ensure that the pmatch argument points to an array
with at least nmatch elements, and regexec() shall fill in the elements of that array with offsets of the substrings
of string that correspond to the parenthesized subexpressions of pattern: pmatch[i].rm_so shall
be the byte offset of the beginning and pmatch[i].rm_eo shall be one greater than the byte offset of the end
of substring i. (Subexpression i begins at the ith matched open parenthesis, counting from 1.) Offsets in
pmatch[0] identify the substring that corresponds to the entire regular expression. Unused elements of pmatch up to
pmatch[nmatch-1] shall be filled with -1. If there are more than nmatch subexpressions in pattern
(pattern itself counts as a subexpression), then regexec() shall still do the match, but shall record only the first
nmatch substrings.
When matching a basic or extended regular expression, any given parenthesized subexpression of pattern might
participate in the match of several different substrings of string, or it might not match any substring even though the
pattern as a whole did match. The following rules shall be used to determine which substrings to report in pmatch when
matching regular expressions:
If subexpression i in a regular expression is not contained within another subexpression, and it
participated in the match several times, then the byte offsets in pmatch[i] shall delimit the last such match.
If subexpression i is not contained within another subexpression, and it did not participate in an
otherwise successful match, the byte offsets in pmatch[i] shall be -1. A subexpression does not participate in the
match when:
'*' or "\{\}" appears immediately after the subexpression in a basic regular expression, or
'*', '?', or "{}" appears immediately after the subexpression in an extended regular expression, and the
subexpression did not match (matched 0 times)
or:
'|' is used in an extended regular expression to select this subexpression or another, and the other
subexpression matched.
If subexpression i is contained within another subexpression j, and i is not contained within
any other subexpression that is contained within j, and a match of subexpression j is reported in
pmatch[j], then the match or non-match of subexpression i reported in pmatch[i] shall be as
described in 1. and 2. above, but within the substring reported in pmatch[j] rather than the whole string. The
offsets in pmatch[i] are still relative to the start of string.
If subexpression i is contained in subexpression j, and the byte offsets in pmatch[j]
are -1, then the pointers in pmatch[i] shall also be -1.
If subexpression i matched a zero-length string, then both byte offsets in pmatch[i] shall be
the byte offset of the character or null terminator immediately following the zero-length string.
If, when regexec() is called, the locale is different from when the regular expression was compiled, the
result is undefined.
If REG_NEWLINE is not set in cflags, then a  in pattern or string shall be
treated as an ordinary character. If REG_NEWLINE is set, then  shall be treated as an ordinary character except as
follows:
A  in string shall not be matched by a  outside a bracket expression or by any
form of a non-matching list (see XBD 9. Regular Expressions).
A  ('^') in pattern, when used to specify expression anchoring (see XBD 9.3.8 BRE Expression Anchoring), shall match the zero-length string
immediately after a  in string, regardless of the setting of REG_NOTBOL.
A  ('$') in pattern, when used to specify expression anchoring, shall match the
zero-length string immediately before a  in string, regardless of the setting of REG_NOTEOL.
The regfree() function shall free any memory allocated by regcomp() associated with preg. The
regfree() function shall not modify errno if preg was previously returned by regcomp() and not yet
freed.
The following constants are defined as the minimum set of error return values, although other errors listed as
implementation extensions in  are possible:
REG_BADBR
Content of "\{\}" invalid: not a number, number too large, more than two numbers, first larger than second.
REG_BADPAT
Invalid regular expression.
REG_BADRPT
'?', '*', or '+' not preceded by valid regular expression.
REG_EBRACE
"\{\}" imbalance.
REG_EBRACK
"[]" imbalance.
REG_ECOLLATE
Invalid collating element referenced.
REG_ECTYPE
Invalid character class type referenced.
REG_EESCAPE
Trailing  character in pattern.
REG_EPAREN
"\(\)" or "()" imbalance.
REG_ERANGE
Invalid endpoint in range expression.
REG_ESPACE
Out of memory.
REG_ESUBREG
Number in "\digit" invalid or in error.
REG_NOMATCH
regexec() failed to match.
If more than one error occurs in processing a function call, any one of the possible constants may be returned, as
the order of detection is unspecified.
The regerror() function provides a mapping from error codes returned by regcomp() and
regexec() to unspecified printable strings. It generates a string corresponding to the value of the errcode argument,
which the application shall ensure is the last non-zero value returned by regcomp() or regexec() with the given value
of preg. If errcode is not such a value, the content of the generated string is unspecified.
If preg is a null pointer, but errcode is a value returned by a previous call to regexec() or
regcomp(), the regerror() still generates an error string corresponding to the value of errcode, but it might
not be as detailed under some implementations.
If the errbuf_size argument is not 0, regerror() shall place the generated string into the buffer of
size errbuf_size bytes pointed to by errbuf. If the string (including the terminating null) cannot fit in the buffer,
regerror() shall truncate the string and null-terminate the result.
If errbuf_size is 0, regerror() shall ignore the errbuf argument, and return the size of the
buffer needed to hold the generated string.
If the preg argument to regexec() or regfree() is not a compiled regular expression returned
by regcomp(), the result is undefined. A preg is no longer treated as a compiled regular expression after it is given
to regfree().
RETURN VALUE
Upon successful completion, the regcomp() function shall return 0. Otherwise, it shall return an integer value indicating
an error as described in , and the content of preg is
undefined. If a code is returned, the interpretation shall be as given in .
If regcomp() detects an invalid RE, it may return REG_BADPAT, or it may return one of the error codes that
more precisely describes the error.
Upon successful completion, the regexec() function shall return 0. Otherwise, it shall return REG_NOMATCH to
indicate no match.
Upon successful completion, the regerror() function shall return the number of bytes needed to hold the
entire generated string, including the null termination. If the return value is greater than errbuf_size, the string
returned in the buffer pointed to by errbuf has been truncated.
The regfree() function shall not return a value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
#include
/*
* Match string against the extended regular expression in
* pattern, treating errors as no match.
*
* Return 1 for match, 0 for no match.
*/
int
match(const char *string, char *pattern)
{
int    status;
regex_t    re;
if (regcomp(&re, pattern, REG_EXTENDED|REG_NOSUB) != 0) {
return(0);      /* Report error. */
}
status = regexec(&re, string, (size_t) 0, NULL, 0);
regfree(&re);
if (status != 0) {
return(0);      /* Report error. */
}
return(1);
}
The following demonstrates how the REG_NOTBOL flag could be used with regexec() to find all substrings in a
line that match a pattern supplied by a user. (For simplicity of the example, very little error checking is done.)
(void) regcomp (&re, pattern, 0);
/* This call to regexec() finds the first match on the line. */
error = regexec (&re, &buffer[0], 1, &pm, 0);
while (error == 0) {  /* While matches found. */
/* Substring found between pm.rm_so and pm.rm_eo. */
/* This call to regexec() finds the next match. */
error = regexec (&re, buffer + pm.rm_eo, 1, &pm, REG_NOTBOL);
}
APPLICATION USAGE
An application could use:
regerror(code,preg,(char *)NULL,(size_t)0)
to find out how big a buffer is needed for the generated string, malloc() a buffer to hold the string, and then call regerror() again to get the
string. Alternatively, it could allocate a fixed, static buffer that is big enough to hold most strings, and then use malloc() to allocate a larger buffer if it finds that this is too small.
To match a pattern as described in XCU 2.14 Pattern Matching
Notation, use the fnmatch() function.
RATIONALE
The regexec() function must fill in all nmatch elements of pmatch, where nmatch and pmatch
are supplied by the application, even if some elements of pmatch do not correspond to subexpressions in pattern. The
application developer should note that there is probably no reason for using a value of nmatch that is larger than
preg->re_nsub+1.
The REG_NEWLINE flag supports a use of RE matching that is needed in some applications like text editors. In such
applications, the user supplies an RE asking the application to find a line that matches the given expression. An anchor in such an
RE anchors at the beginning or end of any line. Such an application can pass a sequence of -separated lines to
regexec() as a single long string and specify REG_NEWLINE to regcomp() to get the desired behavior. The application
must ensure that there are no explicit  characters in pattern if it wants to ensure that any match occurs
entirely within a single line.
The REG_NEWLINE flag affects the behavior of regexec(), but it is in the cflags parameter to
regcomp() to allow flexibility of implementation. Some implementations will want to generate the same compiled RE in
regcomp() regardless of the setting of REG_NEWLINE and have regexec() handle anchors differently based on the setting
of the flag. Other implementations will generate different compiled REs based on the REG_NEWLINE.
The REG_ICASE flag supports the operations taken by the grep -i
option and the historical implementations of ex and vi. Including this flag will make it easier for application code to be written that does the same
thing as these utilities.
The substrings reported in pmatch[] are defined using offsets from the start of the string rather than
pointers. This allows type-safe access to both constant and non-constant strings.
The type regoff_t is used for the elements of pmatch[] to ensure that the application can represent
large arrays in memory (important for an application conforming to the Shell and Utilities volume of POSIX.1-2024).
The 1992 edition of this standard required regoff_t to be at least as wide as off_t, to facilitate
future extensions in which the string to be searched is taken from a file. However, these future extensions have not appeared. The
requirement rules out popular implementations with 32-bit regoff_t and 64-bit off_t, so it has been removed.
The standard developers rejected the inclusion of a regsub() function that would be used to do substitutions
for a matched RE. While such a routine would be useful to some applications, its utility would be much more limited than the
matching function described here. Both RE parsing and substitution are possible to implement without support other than that
required by the ISO C standard, but matching is much more complex than substituting. The only difficult part of substitution,
given the information supplied by regexec(), is finding the next character in a string when there can be multi-byte
characters. That is a much larger issue, and one that needs a more general solution.
The errno variable has not been used for error returns to avoid filling the errno name space for this
feature.
The interface is defined so that the matched substrings rm_sp and rm_ep are in a separate
regmatch_t structure instead of in regex_t. This allows a single compiled RE to be used simultaneously in several
contexts; in main() and a signal handler, perhaps, or in multiple threads of lightweight processes. (The preg
argument to regexec() is declared with type const, so the implementation is not permitted to use the structure to
store intermediate results.) It also allows an application to request an arbitrary number of substrings from an RE. The number of
subexpressions in the RE is reported in re_nsub in preg. With this change to regexec(), consideration was
given to dropping the REG_NOSUB flag since the user can now specify this with a zero nmatch argument to regexec().
However, keeping REG_NOSUB allows an implementation to use a different (perhaps more efficient) algorithm if it knows in
regcomp() that no subexpressions need be reported. The implementation is only required to fill in pmatch if
nmatch is not zero and if REG_NOSUB is not specified. Note that the size_t type, as defined in the ISO C
standard, is unsigned, so the description of regexec() does not need to address negative values of nmatch.
REG_NOTBOL was added to allow an application to do repeated searches for the same pattern in a line. If the pattern
contains a  character that should match the beginning of a line, then the pattern should only match when matched
against the beginning of the line. Without the REG_NOTBOL flag, the application could rewrite the expression for subsequent
matches, but in the general case this would require parsing the expression. The need for REG_NOTEOL is not as clear; it was added
for symmetry.
The addition of the regerror() function addresses the historical need for conforming application programs to
have access to error information more than "Function failed to compile/match your RE for unknown reasons".
This interface provides for two different methods of dealing with error conditions. The specific error codes
(REG_EBRACE, for example), defined in , allow an application to
recover from an error if it is so able. Many applications, especially those that use patterns supplied by a user, will not try to
deal with specific error cases, but will just use regerror() to obtain a human-readable error message to present to the
user.
The regerror() function uses a scheme similar to confstr() to
deal with the problem of allocating memory to hold the generated string. The scheme used by strerror() in the ISO C standard was considered unacceptable since it creates
difficulties for multi-threaded applications.
The preg argument is provided to regerror() to allow an implementation to generate a more descriptive
message than would be possible with errcode alone. An implementation might, for example, save the character offset of the
offending character of the pattern in a field of preg, and then include that in the generated message string. The
implementation may also ignore preg.
A REG_FILENAME flag was considered, but omitted. This flag caused regexec() to match patterns as described
in XCU 2.14 Pattern Matching Notation instead of REs. This service is
now provided by the fnmatch() function.
Notice that there is a difference in philosophy between the ISO POSIX-2:1993 standard and POSIX.1-2024 in how
to handle a "bad" regular expression. The ISO POSIX-2:1993 standard says that many bad constructs "produce undefined
results", or that "the interpretation is undefined". POSIX.1-2024, however, says that the interpretation of such REs is
unspecified. The term "undefined" means that the action by the application is an error, of similar severity to passing a bad
pointer to a function.
The regcomp() and regexec() functions are required to accept any null-terminated string as the
pattern argument. If the meaning of the string is "undefined", the behavior of the function is "unspecified".
POSIX.1-2024 does not specify how the functions will interpret the pattern; they might return error codes, or they might do pattern
matching in some completely unexpected way, but they should not do something like abort the process.
FUTURE DIRECTIONS
None.
SEE ALSO
fnmatch(), glob()
XBD 9. Regular Expressions, ,
XCU 2.14 Pattern Matching Notation
CHANGE HISTORY
First released in Issue 4. Derived from the ISO POSIX-2 standard.
Issue 5
Moved from POSIX2 C-language Binding to BASE.
Issue 6
In the SYNOPSIS, the optional include of the  header is
removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX
Specification:
The requirement to include  has been removed.
Although  was required for conforming implementations of
previous POSIX specifications, it was not required for UNIX applications.
The normative text is updated to avoid use of the term "must" for application requirements.
The REG_ENOSYS constant is removed.
The restrict keyword is added to the regcomp(), regerror(), and regexec() prototypes
for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
Austin Group Interpretation 1003.1-2001 #134 is applied, clarifying that if more than one error occurs in processing a function
call, any one of the possible constants may be returned.
SD5-XBD-ERN-60 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0505 [305] is applied.
Issue 8
Austin Group Defect 385 is applied, adding a requirement that regfree() does not modify errno when passed a
pointer to a regex_t that can be freed.
Austin Group Defects 793 and 1329 are applied, adding REG_MINIMAL.
Austin Group Defect 1031 is applied, changing the description of REG_ICASE.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/shm_open.html =====
shm_open
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
shm_open — open a shared memory object (REALTIME)
SYNOPSIS
[SHM]  #include
int shm_open(const char *name, int oflag, mode_t mode);
DESCRIPTION
The shm_open() function shall establish a connection between a shared memory object and a file descriptor. It shall
create an open file description that refers to the shared memory object and a file descriptor that refers to that open file
description. The file descriptor shall be allocated as described in 2.6 File
Descriptor Allocation, and can be used by other functions to refer to that shared memory object. The name argument
points to a string naming a shared memory object. It is unspecified whether the name appears in the file system and is visible to
other functions that take pathnames as arguments. The name argument conforms to the construction rules for a pathname,
except that the interpretation of  characters other than the leading  character in name is
implementation-defined, and that the length limits for the name argument are implementation-defined and need not be the same
as the pathname limits {PATH_MAX} and {NAME_MAX}. If name begins with the  character, then processes calling
shm_open() with the same value of name refer to the same shared memory object, as long as that name has not been
removed. If name does not begin with the  character, the effect is implementation-defined.
If successful, shm_open() shall return a file descriptor for the shared memory object. The open file description is new,
and therefore the file descriptor does not share it with any other processes. It is unspecified whether the file offset is set. The
FD_CLOEXEC file descriptor flag associated with the new file descriptor shall be set.
The file status flags and file access modes of the open file description shall be set according to the value of oflag.
The oflag argument is the bitwise-inclusive OR of the following flags. Applications specify exactly one of the first two
values (access modes) below in the value of oflag:
O_RDONLY
Open for read access only.
O_RDWR
Open for read or write access.
Any combination of the remaining flags can be specified in the value of oflag:
O_CREAT
If the shared memory object exists, this flag has no effect, except as noted under O_EXCL below. Otherwise, the shared memory
object is created. The user ID of the shared memory object shall be set to the effective user ID of the process. The group ID of
the shared memory object shall be set to the effective group ID of the process; however, if the name argument is visible in
the file system, the group ID may be set to the group ID of the containing directory. The permission bits of the shared memory
object shall be set to the value of the mode argument except those set in the file mode creation mask of the process. When
bits in mode other than the file permission bits are set, the effect is unspecified. The mode argument does not
affect whether the shared memory object is opened for reading, for writing, or for both. The shared memory object has a size of
zero.
O_EXCL
If O_EXCL and O_CREAT are set, shm_open() fails if the shared memory object exists. The check for the existence of the
shared memory object and the creation of the object if it does not exist is atomic with respect to other processes executing
shm_open() naming the same shared memory object with O_EXCL and O_CREAT set. If O_EXCL is set and O_CREAT is not set, the
result is undefined.
O_TRUNC
If the shared memory object exists, and it is successfully opened O_RDWR, the object shall be truncated to zero length and the
mode and owner shall be unchanged by this function call. The result of using O_TRUNC with O_RDONLY is undefined.
The following functions shall be atomic with respect to each other in the effects specified in POSIX.1-2024 when they operate on
shared memory objects:
close(), ftruncate(), mmap(), shm_open(), shm_unlink()
If two threads each call one of these functions, each call shall either see all of the specified effects of the other call, or
none of them. The requirement on the close() function shall also apply whenever a file
descriptor is successfully closed, however caused (for example, as a consequence of calling close(), calling dup2(), or of process
termination).
When a shared memory object is created, the state of the shared memory object, including all data associated with the shared
memory object, persists until the shared memory object is unlinked and all other references are gone. It is unspecified whether the
name and shared memory object state remain valid after a system reboot.
RETURN VALUE
Upon successful completion, the shm_open() function shall return a non-negative integer representing the file descriptor.
Otherwise, it shall return -1 and set errno to indicate the error.
ERRORS
The shm_open() function shall fail if:
[EACCES]
The shared memory object exists and the permissions specified by oflag are denied, or the shared memory object does not
exist and permission to create the shared memory object is denied, or O_TRUNC is specified and write permission is denied.
[EEXIST]
O_CREAT and O_EXCL are set and the named shared memory object already exists.
[EINTR]
The shm_open() operation was interrupted by a signal.
[EINVAL]
The shm_open() operation is not supported for the given name.
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
Too many shared memory objects are currently open in the system.
[ENOENT]
O_CREAT is not set and the named shared memory object does not exist.
[ENOSPC]
There is insufficient space for the creation of the new shared memory object.
The shm_open() function may fail if:
[ENAMETOOLONG]
The length of the name argument exceeds {_POSIX_PATH_MAX} on systems that do not support the XSI option [XSI]   or exceeds
{_XOPEN_PATH_MAX} on XSI systems,   or has a pathname component
that is longer than {_POSIX_NAME_MAX} on systems that do not support the XSI option [XSI]   or longer
than {_XOPEN_NAME_MAX} on XSI systems.
The following sections are informative.
EXAMPLES
Creating and Mapping a Shared Memory Object
The following code segment demonstrates the use of shm_open() to create a shared memory object which is then sized using
ftruncate() before being mapped into the process address space using mmap():
#include
#include
...
#define MAX_LEN 10000
struct region {        /* Defines "structure" of shared memory */
int len;
char buf[MAX_LEN];
};
struct region *rptr;
int fd;
/* Create shared memory object and set its size */
fd = shm_open("/myregion", O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);
if (fd == -1)
/* Handle error */;
if (ftruncate(fd, sizeof(struct region)) == -1)
/* Handle error */;
/* Map shared memory object */
rptr = mmap(NULL, sizeof(struct region),
PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
if (rptr == MAP_FAILED)
/* Handle error */;
/* Now we can refer to mapped region using fields of rptr;
for example, rptr->len */
...
APPLICATION USAGE
None.
RATIONALE
When the Memory Mapped Files option is supported, the normal open() call is used to
obtain a descriptor to a file to be mapped according to existing practice with mmap().
When the Shared Memory Objects option is supported, the shm_open() function shall obtain a descriptor to the shared memory
object to be mapped.
There is ample precedent for having a file descriptor represent several types of objects. In the POSIX.1-1990 standard, a file
descriptor can represent a file, a pipe, a FIFO, a tty, or a directory. Many implementations simply have an operations vector,
which is indexed by the file descriptor type and does very different operations. Note that in some cases the file descriptor passed
to generic operations on file descriptors is returned by open() or creat() and in some cases returned by alternate functions, such as pipe(). The latter technique is used by shm_open().
Note that such shared memory objects can actually be implemented as mapped files. In both cases, the size can be set after the
open using ftruncate(). The shm_open() function itself does not create a
shared object of a specified size because this would duplicate an extant function that set the size of an object referenced by a
file descriptor.
On implementations where memory objects are implemented using the existing file system, the shm_open() function may be
implemented using a macro that invokes open(), and the shm_unlink() function may be implemented using a macro that invokes unlink().
For implementations without a permanent file system, the definition of the name of the memory objects is allowed not to survive
a system reboot. Note that this allows systems with a permanent file system to implement memory objects as data structures internal
to the implementation as well.
On implementations that choose to implement memory objects using memory directly, a shm_open() followed by an ftruncate() and close() can be used to
preallocate a shared memory area and to set the size of that preallocation. This may be necessary for systems without virtual
memory hardware support in order to ensure that the memory is contiguous.
The set of valid open flags to shm_open() was restricted to O_RDONLY, O_RDWR, O_CREAT, and O_TRUNC because these could be
easily implemented on most memory mapping systems. This volume of POSIX.1-2024 is silent on the results if the implementation
cannot supply the requested file access because of implementation-defined reasons, including hardware ones. The O_CLOEXEC open flag
is not listed, because all shared memory objects are created with the FD_CLOEXEC flag already set; an application can later use
fcntl() to clear that flag to allow the shared memory file descriptor to be preserved
across the exec family of functions.
The error conditions [EACCES] and [ENOTSUP] are provided to inform the application that the implementation cannot complete a
request.
[EACCES] indicates for implementation-defined reasons, probably hardware-related, that the implementation cannot comply with a
requested mode because it conflicts with another requested mode. An example might be that an application desires to open a memory
object two times, mapping different areas with different access modes. If the implementation cannot map a single area into a
process space in two places, which would be required if different access modes were required for the two areas, then the
implementation may inform the application at the time of the second open.
[ENOTSUP] indicates for implementation-defined reasons, probably hardware-related, that the implementation cannot comply with a
requested mode at all. An example would be that the hardware of the implementation cannot support write-only shared memory
areas.
On all implementations, it may be desirable to restrict the location of the memory objects to specific file systems for
performance (such as a RAM disk) or implementation-defined reasons (shared memory supported directly only on certain file systems).
The shm_open() function may be used to enforce these restrictions. There are a number of methods available to the
application to determine an appropriate name of the file or the location of an appropriate directory. One way is from the
environment via getenv(). Another would be from a configuration file.
This volume of POSIX.1-2024 specifies that memory objects have initial contents of zero when created. This is consistent with
current behavior for both files and newly allocated memory. For those implementations that use physical memory, it would be
possible that such implementations could simply use available memory and give it to the process uninitialized. This, however, is
not consistent with standard behavior for the uninitialized data area, the stack, and of course, files. Finally, it is highly
desirable to set the allocated memory to zero for security reasons. Thus, initializing memory objects to zero is required.
FUTURE DIRECTIONS
A future version might require the shm_open() and shm_unlink()
functions to have semantics similar to normal file system operations.
SEE ALSO
2.6 File Descriptor Allocation, close(), dup(), exec, fcntl(), mmap(), shmat(), shmctl(), shmdt(), shm_unlink(), umask()
XBD ,
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The shm_open() function is marked as part of the Shared Memory Objects option.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Shared
Memory Objects option.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/126 is applied, adding the example to the EXAMPLES section.
Issue 7
Austin Group Interpretation 1003.1-2001 #077 is applied, clarifying the name argument and changing [ENAMETOOLONG] from a
"shall fail" to a "may fail" error.
Austin Group Interpretation 1003.1-2001 #141 is applied, adding FUTURE DIRECTIONS.
SD5-XSH-ERN-170 is applied, updating the DESCRIPTION to clarify the wording for setting the user ID and group ID of the shared
memory object.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0324 [835], XSH/TC2-2008/0325 [835], and XSH/TC2-2008/0326 [835] are
applied.
Issue 8
Austin Group Defect 411 is applied, adding a sentence about O_CLOEXEC to the RATIONALE section.
Austin Group Defect 593 is applied, removing a reference to  from
the DESCRIPTION section.
Austin Group Defect 695 is applied, adding atomicity requirements to operations on shared memory objects.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/htole32.html =====
be16toh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
be16toh, be32toh, be64toh, htobe16, htobe32, htobe64, htole16, htole32, htole64, le16toh, le32toh, le64toh — convert
values between host and specified byte order
SYNOPSIS
#include
uint16_t be16toh(uint16_t big_endian_16bits);
uint32_t be32toh(uint32_t big_endian_32bits);
uint64_t be64toh(uint64_t big_endian_64bits);
uint16_t htobe16(uint16_t host_16bits);
uint32_t htobe32(uint32_t host_32bits);
uint64_t htobe64(uint64_t host_64bits);
uint16_t htole16(uint16_t host_16bits);
uint32_t htole32(uint32_t host_32bits);
uint64_t htole64(uint64_t host_64bits);
uint16_t le16toh(uint16_t little_endian_16bits);
uint32_t le32toh(uint32_t little_endian_32bits);
uint64_t le64toh(uint64_t little_endian_64bits);
DESCRIPTION
These functions shall convert integer values of various sizes between host representations and representations in a specified
order.
On some implementations, these functions are defined as macros.
A little-endian representation of an integer has the least significant byte stored as the first byte, with the significance of
the bytes increasing as the byte address increases. A big-endian representation has the most significant byte as the first byte,
with the significance of the bytes reducing as the byte address increases.
Note:
Network byte order is big-endian.
For example, the uint32_t value 0x01020304 is represented as the four bytes 0x04, 0x03, 0x02, 0x01 on a little-endian
host, and as 0x01, 0x02, 0x03, 0x04 on a big-endian host.
For each of the sizes 16, 32 and 64, the htobeSIZE() function shall convert from whatever order the host uses to
big-endian representation, htoleSIZE() shall convert to little-endian representation, beSIZEtoh() shall convert from
big-endian to host order, and leSIZEtoh() shall convert from little-endian to host order.
RETURN VALUE
These functions shall return an unsigned integer of the appropriate size and representation.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
#include
#include
#include
int main(int argc, char *argv[])
{
uint32_t val;
if (argc > 1) {
val = (uint32_t)strtoul(argv[1], NULL, 0);
printf("Value: %08x\n", val);
printf("As bytes:\n");
union {
uint32_t asint;
unsigned char asbytes[sizeof(uint32_t)];
} u;
printf("Little endian: ");
u.asint = htole32(val);
for (int i = 0; i  is included:
htobe32
htonl
htobe16
htons
be32toh
ntohl
be16toh
ntohs
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
htonl()
XBD ,
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ntohl.html =====
htonl
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
htonl, htons, ntohl, ntohs — convert values between host and network byte order
SYNOPSIS
#include
uint32_t htonl(uint32_t hostlong);
uint16_t htons(uint16_t hostshort);
uint32_t ntohl(uint32_t netlong);
uint16_t ntohs(uint16_t netshort);
DESCRIPTION
These functions shall convert 16-bit and 32-bit quantities between network byte order and host byte order.
On some implementations, these functions are defined as macros.
The uint32_t and uint16_t types are defined in .
RETURN VALUE
The htonl() and htons() functions shall return the argument value converted from host to network byte order.
The ntohl() and ntohs() functions shall return the argument value converted from network to host byte order.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
These functions are most often used in conjunction with IPv4 addresses and ports as returned by gethostent() and getservent().
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
be16toh(), endhostent(),
endservent()
XBD , ,
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
Issue 8
Austin Group Defect 162 is applied, adding be16toh() and  to the SEE ALSO section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/dngettext_l.html =====
gettext
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
dgettext, dgettext_l, dcgettext, dcgettext_l, gettext, gettext_l, ngettext, ngettext_l, dngettext, dngettext_l,
dcngettext, dcngettext_l — message handling functions
SYNOPSIS
#include
char *dgettext(const char *domainname, const char *msgid);
char *dgettext_l(const char *domainname, const char *msgid,
locale_t locale);
char *dcgettext(const char *domainname, const char *msgid,
int category);
char *dcgettext_l(const char *domainname, const char *msgid,
int category, locale_t locale);
char *dngettext(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n);
char *dngettext_l(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n,
locale_t locale);
char *dcngettext(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n,
int category);
char *dcngettext_l(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n,
int category, locale_t locale);
char *gettext(const char *msgid);
char *gettext_l(const char *msgid, locale_t locale);
char *ngettext(const char *msgid, const char *msgid_plural,
unsigned long int n);
char *ngettext_l(const char *msgid, const char *msgid_plural,
unsigned long int n, locale_t locale);
DESCRIPTION
The gettext() function shall:
attempt to locate a suitable messages object (described in detail below) for the LC_MESSAGES category in the current
locale, and for the current text domain (see bindtextdomain()), containing
the string identified by msgid,
retrieve the string identified by msgid from the messages object,
convert the string to the output codeset if necessary (described in detail below), and
return the result.
If the locale name in effect is "POSIX" or "C" (i.e. the name associated with the LC_MESSAGES locale
category in the current locale), or if no suitable messages object exists, or if no string identified by msgid exists in the
messages object, or if an error occurs, msgid shall be returned.
The dgettext() function shall be equivalent to gettext(), except domainname shall be used instead of the
current text domain to locate the messages object.
The dcgettext() function shall be equivalent to dgettext(), except the locale category identified by
category shall be used instead of LC_MESSAGES .
The ngettext() function shall be equivalent to gettext(), except:
The string to retrieve shall be identified by a combination of msgid and n (see msgfmt).
If the locale name in effect is "POSIX" or "C", or if no suitable messages object exists, or if no string
identified by the combination of msgid and n exists in the messages object, or if an error occurs, the return value
shall be msgid if n is 1, otherwise msgid_plural.
The dngettext() function shall be equivalent to ngettext(), except domainname shall be used instead of the
current text domain to locate the messages object.
The dcngettext() function shall be equivalent to dngettext(), except the locale category identified by
category shall be used instead of LC_MESSAGES .
The *_l() functions shall be equivalent to their counterparts without the _l suffix, except locale shall be
used instead of the current locale. If locale is the special locale object LC_GLOBAL_LOCALE or is not a valid locale object
handle, the behavior is undefined.
The application shall ensure that the msgid and msgid_plural arguments are strings. If either msgid or
msgid_plural is an empty string, or contains characters not in the portable character set, the results are unspecified. If
the category argument is LC_ALL , the results are unspecified.
The location of the messages object shall be determined according to the following criteria, stopping when the first messages
object is found:
[XSI]
If the NLSPATH environment variable is set to a non-empty string, an NLSPATH search shall be performed as described
in XBD 8.2 Internationalization Variables. If NLSPATH identifies
more than one template to use, each template in turn shall be used until a valid messages object is found.
If the LANGUAGE environment variable is set to a non-empty string, a LANGUAGE search shall be performed as
described below. If LANGUAGE identifies more than one directory to search, each directory shall be searched until a valid
messages object is found.
A single-locale search shall be performed as described below.
For [XSI]   the NLSPATH search and   the single-locale search,
the single locale name used to locate the messages object shall be the locale name associated with the selected locale category
from the current locale, or the provided locale object if calling one of the *_l() functions; additional searches of locale
names without .codeset (if present), without _territory (if present), and without @modifier (if present) may
be performed.
For the LANGUAGE search, the value of the LANGUAGE environment variable shall be a list of one or more locale
names separated by a  (':') character. Each locale name shall be tried in the specified order. If a messages
object for the locale does not exist, or cannot be opened, or is unsuitable for implementation-defined reasons (such as security),
the next locale name (if any) shall be tried. If:
a messages object for the locale can be opened but cannot be processed without error, or
the messages object does not contain a string identified by msgid, or msgid and n for the ngettext
functions,
it is unspecified whether the next locale name (if any) is tried. In all other cases, the messages object for the locale shall
be used.
For each locale name in LANGUAGE , or if LANGUAGE is not set or is empty, or no suitable messages object is found
in processing LANGUAGE , the pathname used to locate the messages object shall be
dirname/localename/categoryname/textdomainname.mo, where:
The dirname part is the dirname argument of the most recent successful call to bindtextdomain() that had textdomainname as the domainname argument;
any trailing  characters in dirname shall be discarded. If a successful call to bindtextdomain() has not been made for textdomainname, an
implementation-defined default directory shall be used.
For the LANGUAGE search, the localename part is each locale name from LANGUAGE in turn; if a locale name
has the format language[_territory][.codeset][@modifier], additional
searches of locale names without .codeset (if present), without _territory (if present), and without @modifier
(if present) may be performed; if .codeset is not present, additional searches of locale names with an added .codeset
may be performed. For the single-locale search, the localename part is the name of the current locale, or the locale
specified in an *_l() function call, for the category named by categoryname. Spellings of codeset names are not
standardized, and implementations may attempt to use different commonly known spellings, for example "utf8" and
"UTF-8".
The categoryname part is the string "LC_MESSAGES" if gettext(), dgettext(), ngettext(), or
dngettext() is called, or the locale category name corresponding to the category argument to dcgettext() or
dcngettext(). Likewise for the *_l() variants of all these functions.
For gettext(), gettext_l(), ngettext(), and ngettext_l(), the textdomainname part is the text
domain set by the last successful call to textdomain(). For dgettext(),
dcgettext(), dngettext(), dcngettext(), and the *_l() variants of these functions,
textdomainname is the text domain specified by the domainname argument. The domainname argument shall be
equivalent in syntax and meaning to the domainname argument to textdomain(), except that the selection of the text domain shall affect only the
dgettext(), dcgettext(), dngettext(), and dcngettext() function calls and their *_l() variants.
If the domainname argument is a null pointer, the text domain set by the last successful call to textdomain() shall be used. For all of these functions, if a successful call to textdomain() has not been made the default text domain "messages" shall be
used.
Resolution of the messages object pathname shall be performed the first time one of the gettext family of functions is
called for a given combination of dirname, localename, categoryname, and textdomainname. It is
unspecified whether the pathname is re-resolved if the combination has been used before in a call to one of the gettext
family of functions. If bindtextdomain() performs pathname resolution of its
dirname argument, only the part of the messages object pathname after dirname shall be resolved by the gettext
family of functions.
When one of the gettext family of functions returns a message string that was found in a messages object, it shall
convert the codeset of the message string to the output codeset if a codeset is specified in the messages object (see msgfmt) and the output codeset is not the same as that codeset. If a successful call to
bind_textdomain_codeset() has been made with the text domain of the
messages object as the domainname argument and a non-null codeset argument, the output codeset shall be the
codeset argument from the most recent such call. Otherwise, the output codeset shall be the codeset of characters in the
current locale, or the provided locale object if calling one of the *_l() functions, as specified by the LC_CTYPE
category of the locale. The conversion shall be performed as if by a call to iconv()
using a conversion descriptor returned by iconv_open(, ),
except that if the return value of iconv() would be greater than zero, the
non-identical conversions performed by the gettext family of functions need not be the same as those that such an iconv() call would perform. If an error prevents the codeset conversion from being performed,
the gettext family of functions shall behave as if no message string was found in the messages object. If at least one
non-identical conversion is performed that results in a fallback character (one that does not provide any information about the
character it was converted from, for example, a  or "replacement-character"), the gettext family of
functions may behave as if no message string was found in the messages object.
RETURN VALUE
The gettext(), gettext_l(), dgettext(), dgettext_l(), dcgettext(), and dcgettext_l()
functions shall return the message string described in DESCRIPTION if successful. Otherwise, they shall return msgid.
The ngettext(), ngettext_l(), dngettext(), dngettext_l(), dcngettext(), and
dcngettext_l() functions shall return the message string described in DESCRIPTION if successful. Otherwise, msgid
shall be returned if n is equal to 1, or msgid_plural if n is not equal to 1.
The application shall ensure that it does not modify the returned string. A subsequent call to a gettext family function
shall not overwrite or invalidate the returned string. The returned string may be invalidated by a subsequent call to bind_textdomain_codeset(), bindtextdomain(), setlocale(), or
textdomain() in the same process, except for calls that only query values. The
returned string shall not be invalidated by a subsequent call to uselocale().
ERRORS
The gettext family of functions shall not modify errno. If an error occurs these functions shall return a string
as described in RETURN VALUE.
The following sections are informative.
EXAMPLES
The example code below assumes the following:
The implementation-defined default directory is /system/gettextlib.
The following locales are available on the target system: en_US, en_GB, de_DE. The codeset used for all of these locales is
UTF-8.
The en_AU locale is not available on the target system.
The target system supports conversion from ISO/IEC 8859-1 to UTF-8.
The codeset used for the POSIX locale is ASCII.
The target system does not support conversion from ISO/IEC 8859-1 to ASCII.
Furthermore, the following .mo files (and only the following .mo files) are installed:
/system/gettextlib/en_US/LC_MESSAGES/mail.mo
/messagecatalogs/example/en_US/LC_MESSAGES/mail.mo
These are compiled from a portable messages object source file (dot-po file) with the following ISO/IEC 8859-1 encoded contents
(see the EXTENDED DESCRIPTION of the msgfmt utility for a description of the dot-po
file format):
msgid ""
msgstr ""
"Content-Type: text/plain; charset=ISO_8859-1\n"
"Plural-Forms: nplurals=4; plural= n==1?0: (n>1&&n1&&n1&&n,
XCU gettext, msgfmt,
xgettext
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_rwlock_rdlock.html =====
pthread_rwlock_rdlock
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_rwlock_rdlock, pthread_rwlock_tryrdlock — lock a read-write lock object for reading
SYNOPSIS
#include
int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);
DESCRIPTION
The pthread_rwlock_rdlock() function shall apply a read lock to the read-write lock referenced by rwlock. The
calling thread acquires the read lock if a writer does not hold the lock and there are no writers blocked on the lock.
[TPS]
If the Thread Execution Scheduling option is supported, and the threads that hold or are blocked on the lock are executing with the
scheduling policies SCHED_FIFO or SCHED_RR, the calling thread shall not acquire the lock if a writer holds the lock or if the
calling thread does not already hold a read lock and writers of higher or equal priority are blocked on the lock; otherwise, the
calling thread shall acquire the lock.
[TPS TSP]  If the Thread Execution Scheduling option is supported, and the threads that hold or are blocked on the lock are
executing with the SCHED_SPORADIC scheduling policy, the calling thread shall not acquire the lock if a writer holds the lock or if
the calling thread does not already hold a read lock and writers of higher or equal priority are blocked on the lock; otherwise,
the calling thread shall acquire the lock.
If the Thread Execution Scheduling option is not supported, it is implementation-defined whether the calling thread acquires the
lock when a writer does not hold the lock and there are writers blocked on the lock. If a writer holds the lock, the calling thread
shall not acquire the read lock.
Whether the Thread Execution Scheduling option is supported or not, if the read lock is not acquired, the calling thread shall
block until it can acquire the lock. The calling thread may deadlock if at the time the call is made it holds a write lock.
A thread may hold multiple concurrent read locks on rwlock (that is, successfully call the pthread_rwlock_rdlock()
function n times). If so, the application shall ensure that the thread performs matching unlocks (that is, it calls the
pthread_rwlock_unlock() function n times).
The maximum number of simultaneous read locks that an implementation guarantees can be applied to a read-write lock shall be
implementation-defined. The pthread_rwlock_rdlock() function may fail if this maximum would be exceeded.
The pthread_rwlock_tryrdlock() function shall apply a read lock as in the pthread_rwlock_rdlock() function, with
the exception that the function shall fail if the equivalent pthread_rwlock_rdlock() call would have blocked the calling
thread. In no case shall the pthread_rwlock_tryrdlock() function ever block; it always either acquires the lock or fails and
returns immediately.
Results are undefined if any of these functions are called with an uninitialized read-write lock.
If a signal is delivered to a thread waiting for a read-write lock for reading, upon return from the signal handler the thread
resumes waiting for the read-write lock for reading as if it was not interrupted.
RETURN VALUE
If successful, the pthread_rwlock_rdlock() function shall return zero; otherwise, an error number shall be returned to
indicate the error.
The pthread_rwlock_tryrdlock() function shall return zero if the lock for reading on the read-write lock object
referenced by rwlock is acquired. Otherwise, an error number shall be returned to indicate the error.
ERRORS
The pthread_rwlock_tryrdlock() function shall fail if:
[EBUSY]
The read-write lock could not be acquired for reading because a writer holds the lock or a writer with the appropriate priority
was blocked on it.
The pthread_rwlock_rdlock() and pthread_rwlock_tryrdlock() functions may fail if:
[EAGAIN]
The read lock could not be acquired because the maximum number of read locks for rwlock has been exceeded.
The pthread_rwlock_rdlock() function may fail if:
[EDEADLK]
A deadlock condition was detected or the current thread already owns the read-write lock for writing.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications using these functions may be subject to priority inversion, as discussed in XBD 3.275 Priority Inversion.
RATIONALE
If an implementation detects that the value specified by the rwlock argument to pthread_rwlock_rdlock() or
pthread_rwlock_tryrdlock() does not refer to an initialized read-write lock object, it is recommended that the function
should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_rwlock_clockrdlock(), pthread_rwlock_clockwrlock(), pthread_rwlock_destroy(), pthread_rwlock_trywrlock(), pthread_rwlock_unlock()
XBD 3.275 Priority Inversion, 4.15.2 Memory Synchronization,
CHANGE HISTORY
First released in Issue 5.
Issue 6
The following changes are made for alignment with IEEE Std 1003.1j-2000:
The margin code in the SYNOPSIS is changed to THR to indicate that the functionality is now part of the Threads option
(previously it was part of the Read-Write Locks option in IEEE Std 1003.1j-2000 and also part of the XSI extension).
The DESCRIPTION is updated as follows:
Conditions under which writers have precedence over readers are specified.
Failure of pthread_rwlock_tryrdlock() is clarified.
A paragraph on the maximum number of read locks is added.
In the ERRORS sections, [EBUSY] is modified to take into account write priority, and [EDEADLK] is deleted as a
pthread_rwlock_tryrdlock() error.
The SEE ALSO section is updated.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/101 is applied, updating the ERRORS section so that the
[EDEADLK] error includes detection of a deadlock condition.
Issue 7
The pthread_rwlock_rdlock() and pthread_rwlock_tryrdlock() functions are moved from the Threads option to the
Base.
The [EINVAL] error for an uninitialized read-write lock object is removed; this condition results in undefined behavior.
Issue 8
Austin Group Defect 1111 is applied, changing "threads involved in the lock" to "threads that hold or are blocked on the
lock" and clarifying that a requirement when the read lock is not acquired applies regardless of whether or not the Thread
Execution Scheduling option is supported.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/asctime.html =====
asctime
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
asctime — convert date and time to a string
SYNOPSIS
[OB]  #include
char *asctime(const struct tm *timeptr);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The asctime() function shall convert the broken-down time in the structure pointed to by timeptr into a string in
the form:
Sun Sep 16 01:03:52 1973\n\0
using the equivalent of the following algorithm:
char *asctime(const struct tm *timeptr)
{
static char wday_name[7][3] = {
"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
};
static char mon_name[12][3] = {
"Jan", "Feb", "Mar", "Apr", "May", "Jun",
"Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
};
static char result[26];
sprintf(result, "%.3s %.3s%3d %.2d:%.2d:%.2d %d\n",
wday_name[timeptr->tm_wday],
mon_name[timeptr->tm_mon],
timeptr->tm_mday, timeptr->tm_hour,
timeptr->tm_min, timeptr->tm_sec,
1900 + timeptr->tm_year);
return result;
}
If any of the members of the broken-down time contain values that are outside their normal ranges (see XBD ), the behavior of the asctime() function is undefined. Likewise, if the
calculated year exceeds four digits or is less than the year 1000, the behavior is undefined.
The tm structure is defined in the  header.
The asctime(), ctime(), gmtime(), and localtime() functions shall
return values in one of two static objects: a broken-down time structure and an array of type char. Execution of any of the
functions that return a pointer to one of these object types may overwrite the information in any object of the same type pointed
to by the value returned from any previous call to any of them.
The asctime() function need not be thread-safe; however, asctime() shall avoid data races with all functions other
than itself, ctime(), gmtime(), and
localtime().
RETURN VALUE
Upon successful completion, asctime() shall return a pointer to the string. [CX]   If the
function is unsuccessful, it shall return NULL.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
This function is included only for compatibility with older implementations. It has undefined behavior if the resulting string
would be too long, so the use of this function should be discouraged. On implementations that do not detect output string length
overflow, it is possible to overflow the output buffer in such a way as to cause applications to fail, or possible system security
violations. Also, this function does not support localized date and time formats. To avoid these problems, applications should use
strftime() to generate strings from broken-down times.
Values for the broken-down time structure can be obtained by calling gmtime() or
localtime().
RATIONALE
The standard developers decided to mark the asctime() function obsolescent even though it is in the ISO C standard
due to the possibility of buffer overflow. The ISO C standard also provides the strftime() function which can be used to avoid these problems.
FUTURE DIRECTIONS
This function may be removed in a future version, but not until after it has been removed from the ISO C standard.
SEE ALSO
clock(), ctime(), difftime(), futimens(), gmtime(), localtime(), mktime(), strftime(), strptime(), time()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
Normative text previously in the APPLICATION USAGE section is moved to the DESCRIPTION.
The asctime_r() function is included for alignment with the POSIX Threads Extension.
A note indicating that the asctime() function need not be reentrant is added to the DESCRIPTION.
Issue 6
The asctime_r() function is marked as part of the Thread-Safe Functions option.
Extensions beyond the ISO C standard are marked.
The APPLICATION USAGE section is updated to include a note on the thread-safe function and its avoidance of possibly using a
static data area.
The DESCRIPTION of asctime_r() is updated to describe the format of the string returned.
The restrict keyword is added to the asctime_r() prototype for alignment with the ISO/IEC 9899:1999
standard
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/17 is applied, adding the CX extension in the RETURN VALUE
section requiring that if the asctime() function is unsuccessful it returns NULL.
Issue 7
Austin Group Interpretation 1003.1-2001 #053 is applied, marking these functions obsolescent.
Austin Group Interpretation 1003.1-2001 #156 is applied.
The asctime_r() function is moved from the Thread-Safe Functions option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0033 [86,429] is applied.
Issue 8
Austin Group Defect 469 is applied, clarifying the conditions under which the behavior of asctime() is undefined.
Austin Group Defect 1302 is applied, aligning this function with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1330 is applied, changing the FUTURE DIRECTIONS section.
Austin Group Defect 1376 is applied, removing CX shading from some text derived from the ISO C standard and updating it to
match the ISO C standard.
Austin Group Defect 1410 is applied, removing the asctime_r() function.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/munlockall.html =====
mlockall
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mlockall, munlockall — lock/unlock the address space of a process (REALTIME)
SYNOPSIS
[ML]  #include
int mlockall(int flags);
int munlockall(void);
DESCRIPTION
The mlockall() function shall cause all of the pages mapped by the address space of a process to be memory-resident until
unlocked or until the process exits or execs another process image. The flags
argument determines whether the pages to be locked are those currently mapped by the address space of the process, those that are
mapped in the future, or both. The flags argument is constructed from the bitwise-inclusive OR of one or more of the
following symbolic constants, defined in :
MCL_CURRENT
Lock all of the pages currently mapped into the address space of the process.
MCL_FUTURE
Lock all of the pages that become mapped into the address space of the process in the future, when those mappings are
established.
If MCL_FUTURE is specified, and the automatic locking of future mappings eventually causes the amount of locked memory to exceed
the amount of available physical memory or any other implementation-defined limit, the behavior is implementation-defined. The
manner in which the implementation informs the application of these situations is also implementation-defined.
The munlockall() function shall unlock all currently mapped pages of the address space of the process. Any pages that
become mapped into the address space of the process after a call to munlockall() shall not be locked, unless there is an
intervening call to mlockall() specifying MCL_FUTURE or a subsequent call to mlockall() specifying MCL_CURRENT. If
pages mapped into the address space of the process are also mapped into the address spaces of other processes and are locked by
those processes, the locks established by the other processes shall be unaffected by a call by this process to
munlockall().
Upon successful return from the mlockall() function that specifies MCL_CURRENT, all currently mapped pages of the address
space of the process shall be memory-resident and locked. Upon return from the munlockall() function, all currently mapped
pages of the address space of the process shall be unlocked with respect to the address space of the process. The memory residency
of unlocked pages is unspecified.
Appropriate privileges are required to lock process memory with mlockall().
RETURN VALUE
Upon successful completion, the mlockall() function shall return a value of zero. Otherwise, no additional memory shall
be locked, and the function shall return a value of -1 and set errno to indicate the error. The effect of failure of
mlockall() on previously existing locks in the address space is unspecified.
If it is supported by the implementation, the munlockall() function shall always return a value of zero. Otherwise, the
function shall return a value of -1 and set errno to indicate the error.
ERRORS
The mlockall() function shall fail if:
[EAGAIN]
Some or all of the memory identified by the operation could not be locked when the call was made.
[EINVAL]
The flags argument is zero, or includes unimplemented flags.
The mlockall() function may fail if:
[ENOMEM]
Locking all of the pages currently mapped into the address space of the process would exceed an implementation-defined limit on
the amount of memory that the process may lock.
[EPERM]
The calling process does not have appropriate privileges to perform the requested operation.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
exec, exit(), fork(), mlock(), munmap()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The mlockall() and munlockall() functions are marked as part of the Process Memory Locking option.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Process
Memory Locking option.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atomic_compare_exchange_weak.html =====
atomic_compare_exchange_strong
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atomic_compare_exchange_strong, atomic_compare_exchange_strong_explicit, atomic_compare_exchange_weak,
atomic_compare_exchange_weak_explicit — atomically compare and exchange the values of two objects
SYNOPSIS
#include
_Bool atomic_compare_exchange_strong(volatile A *object,
C *expected, C desired);
_Bool atomic_compare_exchange_strong_explicit(volatile A *object,
C *expected, C desired, memory_order
success, memory_order failure);
_Bool atomic_compare_exchange_weak(volatile A *object,
C *expected, C desired);
_Bool atomic_compare_exchange_weak_explicit(volatile A *object,
C *expected, C desired, memory_order
success, memory_order failure);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
Implementations that define the macro __STDC_NO_ATOMICS__ need not provide the  header nor support these generic functions.
The atomic_compare_exchange_strong_explicit() generic function shall atomically compare the contents of the memory
pointed to by object for equality with that pointed to by expected, and if true, shall replace the contents of the
memory pointed to by object with desired, and if false, shall update the contents of the memory pointed to by
expected with that pointed to by object. This operation shall be an atomic read-modify-write operation (see XBD
4.15.1 Memory Ordering). If the comparison is true, memory
shall be affected according to the value of success, and if the comparison is false, memory shall be affected
according to the value of failure. The application shall ensure that failure is not memory_order_release nor
memory_order_acq_rel, and shall ensure that failure is no stronger than success.
The atomic_compare_exchange_strong() generic function shall be equivalent to
atomic_compare_exchange_strong_explicit() called with success and failure both set to
memory_order_seq_cst.
The atomic_compare_exchange_weak_explicit() generic function shall be equivalent to
atomic_compare_exchange_strong_explicit(), except that the compare-and-exchange operation may fail spuriously. That is, even
when the contents of memory referred to by expected and object are equal, it may return zero and store back to
expected the same memory contents that were originally there.
The atomic_compare_exchange_weak() generic function shall be equivalent to atomic_compare_exchange_weak_explicit()
called with success and failure both set to memory_order_seq_cst.
RETURN VALUE
These generic functions shall return the result of the comparison.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
A consequence of spurious failure is that nearly all uses of weak compare-and-exchange will be in a loop. For example:
exp = atomic_load(&cur);
do {
des = function(exp);
} while (!atomic_compare_exchange_weak(&cur, &exp, des));
When a compare-and-exchange is in a loop, the weak version will yield better performance on some platforms. When a weak
compare-and-exchange would require a loop and a strong one would not, the strong one is preferable.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD 4.15.1 Memory Ordering,
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcstold.html =====
wcstod
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcstod, wcstof, wcstold — convert a wide-character string to a double-precision number
SYNOPSIS
#include
double wcstod(const wchar_t *restrict nptr, wchar_t **restrict endptr);
float wcstof(const wchar_t *restrict nptr, wchar_t **restrict endptr);
long double wcstold(const wchar_t *restrict nptr,
wchar_t **restrict endptr);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall convert the initial portion of the wide-character string pointed to by nptr to double,
float, and long double representation, respectively. First, they shall decompose the input wide-character string into
three parts:
An initial, possibly empty, sequence of white-space wide characters
A subject sequence interpreted as a floating-point constant or representing infinity or NaN
A final wide-character string of one or more unrecognized wide-character codes, including the terminating null wide-character
code of the input wide-character string
Then they shall attempt to convert the subject sequence to a floating-point number, and return the result.
The expected form of the subject sequence is an optional '+' or '-' sign, then one of the following:
A non-empty sequence of decimal digits optionally containing a radix character; then an optional exponent part consisting of the
wide character 'e' or the wide character 'E', optionally followed by a '+' or '-' wide
character, and then followed by one or more decimal digits
A 0x or 0X, then a non-empty sequence of hexadecimal digits optionally containing a radix character; then an optional binary
exponent part consisting of the wide character 'p' or the wide character 'P', optionally followed by a
'+' or '-' wide character, and then followed by one or more decimal digits
One of INF or INFINITY, or any other wide string equivalent except for case
One of NAN or NAN(n-wchar-sequenceopt), or any other wide string ignoring case in the NAN part,
where:
n-wchar-sequence:
digit
nondigit
n-wchar-sequence digit
n-wchar-sequence nondigit
The subject sequence is defined as the longest initial subsequence of the input wide string, starting with the first
non-white-space wide character, that is of the expected form. The subject sequence contains no wide characters if the input wide
string is not of the expected form.
If the subject sequence has the expected form for a floating-point number, the sequence of wide characters starting with the
first digit or the radix character (whichever occurs first) shall be interpreted as a floating constant according to the rules of
the C language, except that the radix character shall be used in place of a period, and that if neither an exponent part nor a
radix character appears in a decimal floating-point number, or if a binary exponent part does not appear in a hexadecimal
floating-point number, an exponent part of the appropriate type with value zero shall be assumed to follow the last digit in the
string. If the subject sequence begins with a , the sequence shall be interpreted as negated. A wide-character
sequence INF or INFINITY shall be interpreted as an infinity, if representable in the return type, else as if it were a floating
constant that is too large for the range of the return type. A wide-character sequence NAN or
NAN(n-wchar-sequenceopt) shall be interpreted as a quiet NaN, if supported in the return type,
else as if it were a subject sequence part that does not have the expected form; the meaning of the n-wchar sequences is
implementation-defined. A pointer to the final wide string shall be stored in the object pointed to by endptr, provided that
endptr is not a null pointer.
If the subject sequence has the hexadecimal form and FLT_RADIX is a power of 2, the conversion shall be rounded in an
implementation-defined manner.
[CX]  The
radix character shall be as defined in the current locale (category LC_NUMERIC ). In the POSIX locale, or in a locale where
the radix character is not defined, the radix character shall default to a  ('.').
In other than the C [CX]   or POSIX  locale, additional
locale-specific subject sequence forms may be accepted.
If the subject sequence is empty or does not have the expected form, no conversion shall be performed; the value of nptr
shall be stored in the object pointed to by endptr, provided that endptr is not a null pointer.
These functions shall not change the setting of errno if successful.
Since 0 is returned on error and is also a valid return on success, an application wishing to check for error situations should
set errno to 0, then call wcstod(), wcstof(), or wcstold(), then check errno.
RETURN VALUE
Upon successful completion, these functions shall return the converted value. If no conversion could be performed, 0 shall be
returned [CX]   and errno may be set to [EINVAL].
If the correct value would cause an overflow and default rounding is in effect, ±HUGE_VAL, ±HUGE_VALF, or ±HUGE_VALL shall be
returned (according to the sign of the value), and errno shall be set to [ERANGE].
If the correct value would cause underflow, a value whose magnitude is no greater than the smallest normalized positive number
in the return type shall be returned [CX]   and errno set to [ERANGE].
ERRORS
The wcstod() function shall fail if:
[ERANGE]
The value to be returned would cause overflow and default rounding is in effect [CX]   or the value
to be returned would cause underflow.
The wcstod() function may fail if:
[EINVAL]
[CX]  No
conversion could be performed.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
If the subject sequence has the hexadecimal form and FLT_RADIX is not a power of 2, and the result is not exactly representable,
the result should be one of the two numbers in the appropriate internal format that are adjacent to the hexadecimal floating source
value, with the extra stipulation that the error should have a correct sign for the current rounding direction.
If the subject sequence has the decimal form and at most DECIMAL_DIG (defined in ) significant digits, the result should be correctly rounded. If the subject
sequence D has the decimal form and more than DECIMAL_DIG significant digits, consider the two bounding, adjacent decimal
strings L and U, both having DECIMAL_DIG significant digits, such that the values of L, D, and U
satisfy "L ,
CHANGE HISTORY
First released in Issue 4. Derived from the MSE working draft.
Issue 5
The DESCRIPTION is updated to indicate that errno is not changed if the function is successful.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the RETURN VALUE and ERRORS sections, the [EINVAL] optional error condition is added if no conversion could be performed.
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The wcstod() prototype is updated.
The wcstof() and wcstold() functions are added.
If the correct value for wcstod() would cause underflow, the return value changed from 0 (as specified in Issue 5) to the
smallest normalized positive number.
The DESCRIPTION, RETURN VALUE, and APPLICATION USAGE sections are extensively updated.
ISO/IEC 9899:1999 standard, Technical Corrigendum 1 is incorporated.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/66 is applied, correcting the second paragraph in the RETURN
VALUE section.
Issue 7
Austin Group Interpretation 1003.1-2001 #015 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0723 [302] and XSH/TC1-2008/0724 [105] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0391 [584] and XSH/TC2-2008/0392 [796] are applied.
Issue 8
Austin Group Defect 1163 is applied, clarifying the handling of white space in the input string.
Austin Group Defect 1686 is applied, addressing some inconsistencies with strtod().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/realloc.html =====
realloc
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
realloc, reallocarray — memory reallocators
SYNOPSIS
#include
void *realloc(void *ptr, size_t size);
[CX]  void *reallocarray(void *ptr, size_t nelem, size_t
elsize);
DESCRIPTION
For realloc(): [CX]  The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The realloc() function shall deallocate the old object pointed to by ptr and return a pointer to a new object that
has the size specified by size. The contents of the new object shall be the same as that of the old object prior to
deallocation, up to the lesser of the new and old sizes. Any bytes in the new object beyond the size of the old object have
indeterminate values.
[CX]  The
reallocarray() function shall be equivalent to the call realloc(ptr, nelem * elsize) except
that overflow in the multiplication shall be an error.
If ptr is a null pointer, realloc() [CX]   or reallocarray()   shall be equivalent to malloc() for the specified
size. Otherwise, if ptr does not match a pointer earlier returned by aligned_alloc(), calloc(), malloc(), [ADV]   posix_memalign(),
realloc(),
[CX]
reallocarray(), or a function in POSIX.1-2024 that allocates memory as if by malloc(),   or if the
space has been deallocated by a call to free(), [CX]   reallocarray(),
or realloc(),  the behavior is undefined.
If size is non-zero and memory for the new object is not allocated, the old object shall not be deallocated.
The order and contiguity of storage allocated by successive calls to realloc() [CX]   or
reallocarray()   is unspecified. The pointer returned if
the allocation succeeds shall be suitably aligned so that it may be assigned to a pointer to any type of object with a fundamental
alignment requirement and then used to access such an object in the space allocated (until the space is explicitly freed or
reallocated). Each such allocation shall yield a pointer to an object disjoint from any other object. The pointer returned shall
point to the start (lowest byte address) of the allocated space. If the space cannot be allocated, a null pointer shall be
returned.
For purposes of determining the existence of a data race, realloc() [CX]   and
reallocarray()   shall each behave as though it accessed
only memory locations accessible through its argument and not other static duration storage. The function may, however, visibly
modify the storage that it allocates. Calls to aligned_alloc(), calloc(), free(), malloc(), [ADV]   posix_memalign(),
[CX]
reallocarray(),   and realloc() that allocate or
deallocate a particular region of memory shall occur in a single total order (see 4.15.1 Memory Ordering), and each such deallocation call shall synchronize
with the next allocation (if any) in this order.
RETURN VALUE
Upon successful completion, realloc() [CX]   and reallocarray()   shall return a pointer to the new object (which can have the same value as a pointer to the old
object), or a null pointer if the new object has not been allocated.
[OB]  If
size is 0,
[OB CX]
or either nelem or elsize is 0,
[OB]  either:
[OB]  A
null pointer shall be returned
[OB CX]
and, if ptr is not a null pointer, errno shall be
set to [EINVAL].
[OB]  A
pointer to the allocated space shall be returned, and the memory object pointed to by ptr shall be freed. The application
shall ensure that the pointer is not used to access an object.
If there is not enough available memory, realloc() [CX]   and reallocarray()   shall return a null pointer
[CX]  and
set errno to [ENOMEM].
ERRORS
The realloc() [CX]   and reallocarray()
functions shall fail if:
[ENOMEM]
[CX]
Insufficient memory is available.
[CX]  The
reallocarray() function shall fail if:
[ENOMEM]
The calculation nelem * elsize would overflow.
The realloc() [CX]   and reallocarray()
functions may fail if:
[EINVAL]
[CX]
The requested allocation size is 0 and the implementation does not support 0 sized allocations.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The ISO C standard makes it implementation-defined whether a call to realloc(p, 0) frees the space pointed to
by p if it returns a null pointer because memory for the new object was not allocated. POSIX.1 instead requires that
implementations set errno if a null pointer is returned and the space has not been freed, and POSIX applications should only
free the space if errno was changed.
RATIONALE
See the RATIONALE for malloc().
FUTURE DIRECTIONS
The ISO C standard states that invoking realloc() with a size argument equal to zero is an obsolescent
feature. This feature may be removed in a future version of this standard.
SEE ALSO
aligned_alloc(), calloc()
, free(), malloc()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the RETURN VALUE section, if there is not enough available memory, the setting of errno to [ENOMEM] is added.
The [ENOMEM] error condition is added.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0495 [400], XSH/TC1-2008/0496 [400], XSH/TC1-2008/0497 [400], and
XSH/TC1-2008/0498 [400] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0309 [526] and XSH/TC2-2008/0310 [526,688] are applied.
Issue 8
Austin Group Defect 374 is applied, adding the [EINVAL] error.
Austin Group Defect 1218 is applied, adding reallocarray().
Austin Group Defect 1302 is applied, aligning the realloc() function with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1387 is applied, changing the RATIONALE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mq_timedreceive.html =====
mq_receive
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mq_receive, mq_timedreceive — receive a message from a message queue (REALTIME)
SYNOPSIS
[MSG]  #include
ssize_t mq_receive(mqd_t mqdes, char *msg_ptr, size_t msg_len,
unsigned *msg_prio);
ssize_t mq_timedreceive(mqd_t mqdes, char *restrict msg_ptr,
size_t msg_len, unsigned *restrict msg_prio,
const struct timespec *restrict abstime);
DESCRIPTION
The mq_receive() function shall receive the oldest of the highest priority message(s) from the message queue specified by
mqdes. If the size of the buffer in bytes, specified by the msg_len argument, is less than the mq_msgsize
attribute of the message queue, the function shall fail and return an error. Otherwise, the selected message shall be removed from
the queue and copied to the buffer pointed to by the msg_ptr argument.
If the value of msg_len is greater than {SSIZE_MAX}, the result is implementation-defined.
If the argument msg_prio is not NULL, the priority of the selected message shall be stored in the location referenced by
msg_prio.
If the specified message queue is empty and O_NONBLOCK is not set in the message queue description associated with mqdes,
mq_receive() shall block until a message is enqueued on the message queue or until mq_receive() is interrupted by a
signal. If more than one thread is waiting to receive a message when a message arrives at an empty queue and the Priority
Scheduling option is supported, then the thread of highest priority that has been waiting the longest shall be selected to receive
the message. Otherwise, it is unspecified which waiting thread receives the message. If the specified message queue is empty and
O_NONBLOCK is set in the message queue description associated with mqdes, no message shall be removed from the queue, and
mq_receive() shall return an error.
The mq_timedreceive() function shall receive the oldest of the highest priority messages from the message queue specified
by mqdes as described for the mq_receive() function. However, if O_NONBLOCK was not specified when the message queue
was opened via the mq_open() function, and no message exists on the queue to satisfy
the receive, the wait for such a message shall be terminated when the specified timeout expires. If O_NONBLOCK is set, this
function is equivalent to mq_receive().
The timeout expires when the absolute time specified by abstime passes, as measured by the clock on which timeouts are
based (that is, when the value of that clock equals or exceeds abstime), or if the absolute time specified by abstime
has already been passed at the time of the call.
The timeout shall be based on the CLOCK_REALTIME clock. The resolution of the timeout shall be the resolution of the clock on
which it is based.
Under no circumstance shall the operation fail with a timeout if a message can be removed from the message queue immediately.
The validity of the abstime parameter need not be checked if a message can be removed from the message queue
immediately.
RETURN VALUE
Upon successful completion, the mq_receive() and mq_timedreceive() functions shall return the length of the
selected message in bytes and the message shall be removed from the queue. Otherwise, no message shall be removed from the queue,
the functions shall return a value of -1, and set errno to indicate the error.
ERRORS
These functions shall fail if:
[EAGAIN]
O_NONBLOCK was set in the message description associated with mqdes, and the specified message queue is empty.
[EBADF]
The mqdes argument is not a valid message queue descriptor open for reading.
[EMSGSIZE]
The specified message buffer size, msg_len, is less than the message size attribute of the message queue.
[EINTR]
The mq_receive() or mq_timedreceive() operation was interrupted by a signal.
[EINVAL]
The process or thread would have blocked, and the abstime parameter specified a nanoseconds field value less than zero
or greater than or equal to 1000 million.
[ETIMEDOUT]
The O_NONBLOCK flag was not set when the message queue was opened, but no message arrived on the queue before the specified
timeout expired.
These functions may fail if:
[EBADMSG]
The implementation has detected a data corruption problem with the message.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
mq_open(), mq_send(), msgctl(), msgget(), msgrcv(), msgsnd(), time()
XBD ,
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The mq_receive() function is marked as part of the Message Passing option.
The Open Group Corrigendum U021/4 is applied. The DESCRIPTION is changed to refer to msg_len rather than
maxsize.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Message
Passing option.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In this function it is possible for the return value to exceed the range of the type ssize_t (since size_t has a
larger range of positive values than ssize_t). A sentence restricting the size of the size_t object is added to the
description to resolve this conflict.
The mq_timedreceive() function is added for alignment with IEEE Std 1003.1d-1999.
The restrict keyword is added to the mq_timedreceive() prototype for alignment with the ISO/IEC 9899:1999
standard.
IEEE PASC Interpretation 1003.1 #109 is applied, correcting the return type for mq_timedreceive() from int to
ssize_t.
Issue 7
The mq_timedreceive() function is moved from the Timeouts option to the Base.
Functionality relating to the Timers option is moved to the Base.
Issue 8
Austin Group Defect 592 is applied, removing text relating to  from
the SYNOPSIS and DESCRIPTION sections.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/timer_create.html =====
timer_create
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
timer_create — create a per-process timer
SYNOPSIS
[CX]  #include
#include
int timer_create(clockid_t clockid, struct sigevent *restrict evp,
timer_t *restrict timerid);
DESCRIPTION
The timer_create() function shall create a per-process timer using the specified clock, clock_id, as the timing
base. The timer_create() function shall return, in the location referenced by timerid, a timer ID of type
timer_t used to identify the timer in timer requests. This timer ID shall be unique within the calling process until the
timer is deleted. The particular clock, clock_id, is defined in .
The timer whose ID is returned shall be in a disarmed state upon return from timer_create().
The evp argument, if non-NULL, points to a sigevent structure. This structure, allocated by the application,
defines the asynchronous notification to occur as specified in 2.4.1 Signal
Generation and Delivery when the timer expires. If the evp argument is NULL, the effect is as if the evp
argument pointed to a sigevent structure with the sigev_notify member having the value SIGEV_SIGNAL, the
sigev_signo having a default signal number, and the sigev_value member having the value of the timer ID.
Each implementation shall define a set of clocks that can be used as timing bases for per-process timers. All implementations
shall support CLOCK_REALTIME and CLOCK_MONOTONIC as values for clock_id.
Per-process timers shall not be inherited by a child process across a fork() and
shall be disarmed and deleted by an exec.
[CPT]
If _POSIX_CPUTIME is defined, implementations shall support clock_id values representing the CPU-time clock of the calling
process.
[TCT]
If _POSIX_THREAD_CPUTIME is defined, implementations shall support clock_id values representing the CPU-time clock of the
calling thread.
[CPT|TCT]  It is implementation-defined whether a timer_create() function will succeed if the value defined by clock_id
corresponds to the CPU-time clock of a process or thread different from the process or thread invoking the function.
[TSA]
If evp->sigev_sigev_notify is SIGEV_THREAD and sev->sigev_notify_attributes is not NULL, if the
attribute pointed to by sev->sigev_notify_attributes has a thread stack address specified by a call to pthread_attr_setstack(), the results are unspecified if the signal is
generated more than once.
RETURN VALUE
If the call succeeds, timer_create() shall return zero and update the location referenced by timerid to a
timer_t, which can be passed to the per-process timer calls. If an error occurs, the function shall return a value of -1 and
set errno to indicate the error. The value of timerid is undefined if an error occurs.
ERRORS
The timer_create() function shall fail if:
[EAGAIN]
The system lacks sufficient signal queuing resources to honor the request.
[EAGAIN]
The calling process has already created all of the timers it is allowed by this implementation.
[EINVAL]
The specified clock ID is not defined.
[ENOTSUP]
[CPT|TCT]  The implementation does not support the creation of a timer attached to the CPU-time clock that is specified by
clock_id and associated with a process or thread different from the process or thread invoking timer_create().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
If a timer is created which has evp->sigev_sigev_notify set to SIGEV_THREAD and the attribute pointed to by
evp->sigev_notify_attributes has a thread stack address specified by a call to pthread_attr_setstack(), the memory dedicated as a thread stack cannot be
recovered. The reason for this is that the threads created in response to a timer expiration are created detached, or in an
unspecified way if the thread attribute's detachstate is PTHREAD_CREATE_JOINABLE. In neither case is it valid to call
pthread_join(), which makes it impossible to determine the lifetime of the
created thread which thus means the stack memory cannot be reused.
RATIONALE
Periodic Timer Overrun and Resource Allocation
The specified timer facilities may deliver realtime signals (that is, queued signals) on implementations that support this
option. Since realtime applications cannot afford to lose notifications of asynchronous events, like timer expirations or
asynchronous I/O completions, it must be possible to ensure that sufficient resources exist to deliver the signal when the event
occurs. In general, this is not a difficulty because there is a one-to-one correspondence between a request and a subsequent signal
generation. If the request cannot allocate the signal delivery resources, it can fail the call with an [EAGAIN] error.
Periodic timers are a special case. A single request can generate an unspecified number of signals. This is not a problem if the
requesting process can service the signals as fast as they are generated, thus making the signal delivery resources available for
delivery of subsequent periodic timer expiration signals. But, in general, this cannot be assured—processing of periodic timer
signals may "overrun"; that is, subsequent periodic timer expirations may occur before the currently pending signal has been
delivered.
Also, for signals, according to the POSIX.1-1990 standard, if subsequent occurrences of a pending signal are generated, it is
implementation-defined whether a signal is delivered for each occurrence. This is not adequate for some realtime applications. So a
mechanism is required to allow applications to detect how many timer expirations were delayed without requiring an indefinite
amount of system resources to store the delayed expirations.
The specified facilities provide for an overrun count. The overrun count is defined as the number of extra timer expirations
that occurred between the time a timer expiration signal is generated and the time the signal is delivered. The signal-catching
function, if it is concerned with overruns, can retrieve this count on entry. With this method, a periodic timer only needs one
"signal queuing resource" that can be allocated at the time of the timer_create() function call.
A function is defined to retrieve the overrun count so that an application need not allocate static storage to contain the
count, and an implementation need not update this storage asynchronously on timer expirations. But, for some high-frequency
periodic applications, the overhead of an additional system call on each timer expiration may be prohibitive. The functions, as
defined, permit an implementation to maintain the overrun count in user space, associated with the timerid. The timer_getoverrun() function can then be implemented as a macro that uses the
timerid argument (which may just be a pointer to a user space structure containing the counter) to locate the overrun count
with no system call overhead. Other implementations, less concerned with this class of applications, can avoid the asynchronous
update of user space by maintaining the count in a system structure at the cost of the extra system call to obtain it.
Timer Expiration Signal Parameters
The realtime signals functionality supports an application-specific datum that is delivered to the extended signal handler. This
value is explicitly specified by the application, along with the signal number to be delivered, in a sigevent structure. The
type of the application-defined value can be either an integer constant or a pointer. This explicit specification of the value, as
opposed to always sending the timer ID, was selected based on existing practice.
It is common practice for realtime applications (on non-POSIX systems or realtime extended POSIX systems) to use the parameters
of event handlers as the case label of a switch statement or as a pointer to an application-defined data structure. Since
timer_ids are dynamically allocated by the timer_create() function, they can be used for neither of these functions
without additional application overhead in the signal handler; for example, to search an array of saved timer IDs to associate the
ID with a constant or application data structure.
FUTURE DIRECTIONS
None.
SEE ALSO
clock_getres(), timer_delete(), timer_getoverrun()
XBD ,
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The timer_create() function is marked as part of the Timers option.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Timers
option.
CPU-time clocks are added for alignment with IEEE Std 1003.1d-1999.
The DESCRIPTION is updated for alignment with IEEE Std 1003.1j-2000 by adding the requirement for the CLOCK_MONOTONIC
clock under the Monotonic Clock option.
The restrict keyword is added to the timer_create() prototype for alignment with the ISO/IEC 9899:1999
standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/138 is applied, updating the DESCRIPTION and APPLICATION USAGE
sections to describe the case when a timer is created with the notification method set to SIGEV_THREAD.
Issue 7
The timer_create() function is moved from the Timers option to the Base.
Issue 8
Austin Group Defect 1116 is applied, removing a reference to the Realtime Signals Extension option that existed in earlier
versions of this standard.
Austin Group Defect 1346 is applied, requiring support for Monotonic Clock.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/cnd_wait.html =====
cnd_timedwait
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cnd_timedwait, cnd_wait — wait on a condition
SYNOPSIS
#include
int cnd_timedwait(cnd_t * restrict cond, mtx_t * restrict mtx,
const struct timespec * restrict ts);
int cnd_wait(cnd_t *cond, mtx_t *mtx);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The cnd_timedwait() function shall atomically unlock the mutex pointed to by mtx and block until the condition
variable pointed to by cond is signaled by a call to cnd_signal() or to
cnd_broadcast(), or until after the TIME_UTC-based calendar time pointed to by
ts, or until it is unblocked due to an unspecified reason.
The cnd_wait() function shall atomically unlock the mutex pointed to by mtx and block until the condition variable
pointed to by cond is signaled by a call to cnd_signal() or to cnd_broadcast(), or until it is unblocked due to an unspecified reason.
[CX]
Atomically here means "atomically with respect to access by another thread to the mutex and then the condition variable". That
is, if another thread is able to acquire the mutex after the about-to-block thread has released it, then a subsequent call to
cnd_broadcast() or cnd_signal() in that thread shall behave as if it were issued after the about-to-block
thread has blocked.
When the calling thread becomes unblocked, these functions shall lock the mutex pointed to by mtx before they return. The
application shall ensure that the mutex pointed to by mtx is locked by the calling thread before it calls these
functions.
When using condition variables there is always a Boolean predicate involving shared variables associated with each condition
wait that is true if the thread should proceed. Spurious wakeups from the cnd_timedwait() and cnd_wait() functions
may occur. Since the return from cnd_timedwait() or cnd_wait() does not imply anything about the value of this
predicate, the predicate should be re-evaluated upon such return.
When a thread waits on a condition variable, having specified a particular mutex to either the cnd_timedwait() or the
cnd_wait() operation, a dynamic binding is formed between that mutex and condition variable that remains in effect as long
as at least one thread is blocked on the condition variable. During this time, the effect of an attempt by any thread to wait on
that condition variable using a different mutex is undefined. Once all waiting threads have been unblocked (as by the cnd_broadcast() operation), the next wait operation on that condition variable shall
form a new dynamic binding with the mutex specified by that wait operation. Even though the dynamic binding between condition
variable and mutex might be removed or replaced between the time a thread is unblocked from a wait on the condition variable and
the time that it returns to the caller or begins cancellation cleanup, the unblocked thread shall always re-acquire the mutex
specified in the condition wait operation call from which it is returning.
[CX]  A
condition wait (whether timed or not) is a cancellation point. When the cancelability type of a thread is set to
PTHREAD_CANCEL_DEFERRED, a side-effect of acting upon a cancellation request while in a condition wait is that the mutex is (in
effect) re-acquired before calling the first cancellation cleanup handler. The effect is as if the thread were unblocked, allowed
to execute up to the point of returning from the call to cnd_timedwait() or cnd_wait(), but at that point notices the
cancellation request and instead of returning to the caller of cnd_timedwait() or cnd_wait(), starts the thread
cancellation activities, which includes calling cancellation cleanup handlers.
A thread that has been unblocked because it has been canceled while blocked in a call to cnd_timedwait() or
cnd_wait() shall not consume any condition signal that may be directed concurrently at the condition variable if there are
other threads blocked on the condition variable.
When cnd_timedwait() times out, it shall nonetheless release and re-acquire the mutex referenced by mtx, and may
consume a condition signal directed concurrently at the condition variable.
[CX]
These functions shall not be affected if the calling thread executes a signal handler during the call, except that if a signal is
delivered to a thread waiting for a condition variable, upon return from the signal handler either the thread shall resume waiting
for the condition variable as if it was not interrupted, or it shall return thrd_success due to spurious wakeup.
The behavior is undefined if the value specified by the cond or mtx argument to these functions does not refer to
an initialized condition variable or an initialized mutex object, respectively.
RETURN VALUE
The cnd_timedwait() function shall return thrd_success upon success, or thrd_timedout if the time
specified in the call was reached without acquiring the requested resource, or thrd_error if the request could not be
honored.
The cnd_wait() function shall return thrd_success upon success or thrd_error if the request could not
be honored.
ERRORS
See RETURN VALUE.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
These functions are not affected by signal handlers (except as stated in the DESCRIPTION) for the reasons stated in XRAT
B.2.3 Error Numbers.
FUTURE DIRECTIONS
None.
SEE ALSO
cnd_broadcast(), cnd_destroy(), timespec_get()
XBD 4.15.2 Memory Synchronization,
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mtx_trylock.html =====
mtx_lock
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mtx_lock, mtx_timedlock, mtx_trylock, mtx_unlock — lock and unlock a mutex
SYNOPSIS
#include
int mtx_lock(mtx_t *mtx);
int mtx_timedlock(mtx_t *restrict mtx,
const struct timespec *restrict ts);
int mtx_trylock(mtx_t *mtx);
int mtx_unlock(mtx_t *mtx);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The mtx_lock() function shall block until it locks the mutex pointed to by mtx. If the mutex is non-recursive, the
application shall ensure that it is not already locked by the calling thread.
The mtx_timedlock() function shall block until it locks the mutex pointed to by mtx or until after the
TIME_UTC-based calendar time pointed to by ts. The application shall ensure that the specified mutex supports timeout.
[CX]  Under
no circumstance shall the function fail with a timeout if the mutex can be locked immediately. The validity of the ts
parameter need not be checked if the mutex can be locked immediately.
The mtx_trylock() function shall endeavor to lock the mutex pointed to by mtx. If the mutex is already locked (by
any thread, including the current thread), the function shall return without blocking. If the mutex is recursive and the mutex is
currently owned by the calling thread, the mutex lock count (see below) shall be incremented by one and the mtx_trylock()
function shall immediately return success.
[CX]
These functions shall not be affected if the calling thread executes a signal handler during the call; if a signal is delivered to
a thread waiting for a mutex, upon return from the signal handler the thread shall resume waiting for the mutex as if it was not
interrupted.
If a call to mtx_lock(), mtx_timedlock() or mtx_trylock() locks the mutex, prior calls to
mtx_unlock() on the same mutex shall synchronize with this lock operation.
The mtx_unlock() function shall unlock the mutex pointed to by mtx. The application shall ensure that the mutex
pointed to by mtx is locked by the calling thread. [CX]   If there are threads blocked on the mutex object referenced by
mtx when mtx_unlock() is called, resulting in the mutex becoming available, the scheduling policy shall determine
which thread shall acquire the mutex.
A recursive mutex shall maintain the concept of a lock count. When a thread successfully acquires a mutex for the first time,
the lock count shall be set to one. Every time a thread relocks this mutex, the lock count shall be incremented by one. Each time
the thread unlocks the mutex, the lock count shall be decremented by one. When the lock count reaches zero, the mutex shall become
available for other threads to acquire.
For purposes of determining the existence of a data race, mutex lock and unlock operations on mutexes of type mtx_t
behave as atomic operations. All lock and unlock operations on a particular mutex occur in some particular total order.
If mtx does not refer to an initialized mutex object, the behavior of these functions is undefined.
RETURN VALUE
The mtx_lock() and mtx_unlock() functions shall return thrd_success on success, or thrd_error if
the request could not be honored.
The mtx_timedlock() function shall return thrd_success on success, or thrd_timedout if the time
specified was reached without acquiring the requested resource, or thrd_error if the request could not be honored.
The mtx_trylock() function shall return thrd_success on success, or thrd_busy if the resource requested
is already in use, or thrd_error if the request could not be honored. The mtx_trylock() function can spuriously
fail to lock an unused resource, in which case it shall return thrd_busy.
ERRORS
See RETURN VALUE.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
These functions are not affected by signal handlers for the reasons stated in XRAT B.2.3 Error Numbers.
Since  has no equivalent of the mtx_timed mutex
property, if the  interfaces are implemented as a thin wrapper
around  interfaces (meaning mtx_t and
pthread_mutex_t are the same type), all mutexes support timeout and mtx_timedlock() will not fail for a mutex that
was not initialized with mtx_timed. Alternatively, implementations can use a less thin wrapper where mtx_t contains
additional properties that are not held in pthread_mutex_t in order to be able to return a failure indication from
mtx_timedlock() calls where the mutex was not initialized with mtx_timed.
FUTURE DIRECTIONS
None.
SEE ALSO
mtx_destroy(), timespec_get()
XBD
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/in6addr_any.html =====
in6addr_any
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
in6addr_any, in6addr_loopback — IPv6 address variables
SYNOPSIS
[IP6]  #include
const struct in6_addr in6addr_any;
const struct in6_addr in6addr_loopback;
DESCRIPTION
The in6addr_any variable is initialized by the system to contain the wildcard IPv6 address (::).
The in6addr_loopback variable is initialized by the system to contain the loopback IPv6 address (::1).
RETURN VALUE
None.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
These variables were only described on the XBD  page in
earlier versions of this standard.
FUTURE DIRECTIONS
None.
SEE ALSO
bind(), connect()
XBD
CHANGE HISTORY
First released in Issue 8. Derived from Issue 7 XBD .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/log.html =====
log
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
log, logf, logl — natural logarithm function
SYNOPSIS
#include
double log(double x);
float logf(float x);
long double logl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the natural logarithm of their argument x,
loge(x).
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the natural logarithm of x.
If x is ±0, a pole error shall occur and log(), logf(), and logl() shall return -HUGE_VAL,
-HUGE_VALF, and -HUGE_VALL, respectively.
For finite values of x that are less than 0, [MX]   or if x is -Inf,  a domain error shall occur, and [MX]   either a NaN (if supported), or   an implementation-defined value shall be returned.
[MX]  If
x is NaN, a NaN shall be returned.
If x is 1, +0 shall be returned.
If x is +Inf, x shall be returned.
ERRORS
These functions shall fail if:
Domain Error
The finite value of x is negative, [MX]   or x is -Inf.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
Pole Error
The value of x is zero.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the divide-by-zero floating-point exception shall
be raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
exp(), feclearexcept(),
fetestexcept(), isnan(),
log10(), log1p()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
The logf() and logl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atexit.html =====
atexit
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atexit — register a function to be called from .I exit () or after return from .I main ()
SYNOPSIS
#include
int atexit(void (*func)(void));
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The atexit() function shall register the function pointed to by func, to be called without arguments from exit(), or after return from the initial call to main(), or on the last thread
termination. If the exit() function is called, it is unspecified whether a call to the
atexit() function that does not happen before exit() is called will succeed.
At least 32 functions can be registered with atexit().
RETURN VALUE
Upon successful completion, atexit() shall return 0; otherwise, it shall return a non-zero value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The atexit() function registrations are distinct from the at_quick_exit() registrations, so applications might need to call both registration
functions with the same argument.
The functions registered by a call to atexit() must return to ensure that all registered functions are called.
The application should call sysconf() to obtain the value of {ATEXIT_MAX}, the
number of functions that can be registered. There is no way for an application to tell how many functions have already been
registered with atexit().
Since the behavior is undefined if the exit() function is called more than once,
portable applications calling atexit() must ensure that the exit() function is
not called when the functions registered by the atexit() function are called.
If a function registered by the atexit() function is called and a portable application needs to stop further exit() processing, it must call the _exit()
function or the _Exit() function or one of the functions which cause abnormal process
termination.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
at_quick_exit(), exec, exit(), sysconf()
XBD
CHANGE HISTORY
First released in Issue 4. Derived from the ANSI C standard.
Issue 6
Extensions beyond the ISO C standard are marked.
The DESCRIPTION is updated for alignment with the ISO/IEC 9899:1999 standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/19 is applied, adding further clarification to the APPLICATION
USAGE section.
Issue 8
Austin Group Defect 1302 is applied, aligning this function with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1646 is applied, removing redundant text relating to the exec
family of functions.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strcmp.html =====
strcmp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strcmp — compare two strings
SYNOPSIS
#include
int strcmp(const char *s1, const char *s2);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The strcmp() function shall compare the string pointed to by s1 to the string pointed to by s2.
The sign of a non-zero return value shall be determined by the sign of the difference between the values of the first pair of
bytes (both interpreted as type unsigned char) that differ in the strings being compared.
[CX]  The
strcmp() function shall not change the setting of errno on valid input.
RETURN VALUE
Upon completion, strcmp() shall return an integer greater than, equal to, or less than 0, if the string pointed to by
s1 is greater than, equal to, or less than the string pointed to by s2, respectively.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
Checking a Password Entry
The following example compares the information read from standard input to the value of the name of the user entry. If the
strcmp() function returns 0 (indicating a match), a further check will be made to see if the user entered the proper old
password. The crypt() function shall encrypt the old password entered by the user,
using the value of the encrypted password in the passwd structure as the salt. If this value matches the value of the
encrypted passwd in the structure, the entered password oldpasswd is the correct user's password. Finally, the
program encrypts the new password so that it can store the information in the passwd structure.
#include
#include
#include
...
int valid_change;
struct passwd *p;
char user[100];
char oldpasswd[100];
char newpasswd[100];
char savepasswd[100];
...
if (strcmp(p->pw_name, user) == 0) {
if (strcmp(p->pw_passwd, crypt(oldpasswd, p->pw_passwd)) == 0) {
strcpy(savepasswd, crypt(newpasswd, user));
p->pw_passwd = savepasswd;
valid_change = 1;
}
else {
fprintf(stderr, "Old password is not valid\n");
}
}
...
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
strncmp()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
Extensions beyond the ISO C standard are marked.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that strcmp() does not change the setting of errno on
valid input.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcrtomb.html =====
wcrtomb
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcrtomb — convert a wide-character code to a character (restartable)
SYNOPSIS
#include
size_t wcrtomb(char *restrict s, wchar_t wc, mbstate_t *restrict ps);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
If s is a null pointer, the wcrtomb() function shall be equivalent to the call:
wcrtomb(buf, L'\0', ps)
where buf is an internal buffer.
If s is not a null pointer, the wcrtomb() function shall determine the number of bytes needed to represent the
character that corresponds to the wide character given by wc (including any shift sequences), and store the resulting bytes
in the array whose first element is pointed to by s. At most {MB_CUR_MAX} bytes are stored. If wc is a null wide
character, a null byte shall be stored, preceded by any shift sequence needed to restore the initial shift state. The resulting
state described shall be the initial conversion state.
If ps is a null pointer, the wcrtomb() function shall use its own internal mbstate_t object, which is
initialized at program start-up to the initial conversion state. Otherwise, the mbstate_t object pointed to by ps
shall be used to completely describe the current conversion state of the associated character sequence. The implementation shall
behave as if no function defined in this volume of POSIX.1-2024 calls wcrtomb().
If called with a null ps argument, the wcrtomb() function need not be thread-safe; however, such calls shall avoid
data races with calls to wcrtomb() with a non-null argument and with calls to all other functions.
The behavior of this function shall be affected by the LC_CTYPE category of the current locale.
The wcrtomb() function shall not change the setting of errno if successful.
RETURN VALUE
The wcrtomb() function shall return the number of bytes stored in the array object (including any shift sequences). When
wc is not a valid wide character, an encoding error shall occur. In this case, the function shall store the value of the
macro [EILSEQ] in errno and shall return (size_t)-1; the conversion state shall be undefined.
ERRORS
The wcrtomb() function shall fail if:
[EILSEQ]
An invalid wide-character code is detected.
The wcrtomb() function may fail if:
[EINVAL]
[CX]
ps points to an object that contains an invalid conversion state.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
mbsinit(), wcsrtombs()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E).
Issue 6
In the DESCRIPTION, a note on using this function in a threaded application is added.
Extensions beyond the ISO C standard are marked.
The normative text is updated to avoid use of the term "must" for application requirements.
The wcrtomb() prototype is updated for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
Austin Group Interpretation 1003.1-2001 #148 is applied, clarifying that the wcrtomb() function need not be thread-safe
if called with a NULL ps argument.
Austin Group Interpretation 1003.1-2001 #170 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0714 [88] and XSH/TC1-2008/0715 [105] are applied.
Issue 8
Austin Group Defect 1302 is applied, aligning this function with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/expm1.html =====
expm1
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
expm1, expm1f, expm1l — compute exponential functions
SYNOPSIS
#include
double expm1(double x);
float expm1f(float x);
long double expm1l(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute ex-1.0.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions return ex-1.0.
If the correct value would cause overflow, a range error shall occur and expm1(), expm1f(), and expm1l()
shall return the value of the macro HUGE_VAL, HUGE_VALF, and HUGE_VALL, respectively.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, ±0 shall be returned.
If x is -Inf, -1 shall be returned.
If x is +Inf, x shall be returned.
[MXX]
If x is subnormal, x should be returned.
[MX]  If x is subnormal, a range error may occur and, if x is
not returned, expm1(), expm1f(), and expm1l() shall return an implementation-defined value no greater in
magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
ERRORS
These functions shall fail if:
Range Error
The result overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
These functions may fail if:
Range Error
[MX]
The value of x is subnormal.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The value of expm1(x) may be more accurate than exp(x)-1.0 for small values of x.
The expm1() and log1p() functions are useful for financial calculations of
((1+x)n-1)/x, namely:
expm1(n * log1p(x))/x
when x is very small (for example, when calculating small daily interest rates). These functions also simplify writing
accurate inverse hyperbolic functions.
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
exp(), feclearexcept(),
fetestexcept(), ilogb(),
log1p()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The expm1f() and expm1l() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The expm1() function is no longer marked as an extension.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0110 [68] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0103 [630] is applied.
Issue 8
Austin Group Defect 1382 is applied, rearranging the text describing the behavior when x is subnormal to avoid the need
for two shading changes.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/secure_getenv.html =====
getenv
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getenv, secure_getenv — get value of an environment variable
SYNOPSIS
#include
char *getenv(const char *name);
[CX]  char *secure_getenv(const char *name);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The getenv() function shall search the environment of the calling process (see XBD 8. Environment Variables) for the environment variable name if it exists and
return a pointer to the value of the environment variable. If the specified environment variable cannot be found, a null pointer
shall be returned. The application shall ensure that it does not modify the string pointed to by the getenv() function,
[CX]
unless it is part of a modifiable object previously placed in the environment by assigning a new value to environ
[XSI]
or by using putenv().
[CX]  The
pointer returned by getenv() shall point to a string within the environment data pointed to by environ.
Note:
This requirement is an extension to the ISO C standard, which allows getenv() to copy the data to an internal
buffer.
The secure_getenv() function shall be equivalent to getenv(), except that it shall return a null pointer if the
calling process does not meet all of the following security criteria:
The effective user ID and real user ID of the calling process were equal during program startup.
The effective group ID and real group ID of the calling process were equal during program startup.
Additional implementation-defined security criteria.
RETURN VALUE
Upon successful completion, getenv() shall return a pointer to a string containing the value for the specified
name. If the specified name cannot be found in the environment of the calling process, a null pointer shall be
returned.
[CX]
Upon successful completion, secure_getenv() shall return a pointer to a string containing the value for the specified
name. If the specified name cannot be found in the environment of the calling process, or the calling process does
not meet the security criteria listed in DESCRIPTION, a null pointer shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
Getting the Value of an Environment Variable
The following example gets the value of the HOME environment variable.
#include
...
const char *name = "HOME";
char *value;
value = getenv(name);
APPLICATION USAGE
None.
RATIONALE
The clearenv() function was considered but rejected. The putenv() function
has now been included for alignment with the Single UNIX Specification.
Some earlier versions of this standard did not require getenv() to be thread-safe because it was allowed to return a
value pointing to an internal buffer. However, this behavior allowed by the ISO C standard is no longer allowed by POSIX.1.
POSIX.1 requires the environment data to be available through environ[], so there is no reason why getenv() can't
return a pointer to the actual data instead of a copy. Therefore getenv() is now required to be thread-safe (except when
another thread modifies the environment).
Conforming applications are required not to directly modify the pointers to which environ points, but to use only the
setenv(), unsetenv(), and putenv() functions, or assignment to environ itself, to manipulate the process
environment. This constraint allows the implementation to properly manage the memory it allocates. This enables the implementation
to free any space it has allocated to strings (and perhaps the pointers to them) stored in environ when unsetenv() is called. A C runtime start-up procedure (that which invokes main() and
perhaps initializes environ) can also initialize a flag indicating that none of the environment has yet been copied to
allocated storage, or that the separate table has not yet been initialized. If the application switches to a complete new
environment by assigning a new value to environ, this can be detected by getenv(), setenv(), unsetenv(), or putenv() and the implementation can at that point reinitialize based on the new environment.
(This may include copying the environment strings into a new array and assigning environ to point to it.)
In fact, for higher performance of getenv(), implementations that do not provide putenv() could also maintain a separate copy of the environment in a data structure that
could be searched much more quickly (such as an indexed hash table, or a binary tree), and update both it and the linear list at
environ when setenv() or unsetenv() is invoked. On implementations that do provide putenv(), such a copy might still be worthwhile but would need to allow for the fact that
applications can directly modify the content of environment strings added with putenv(). For example, if an environment string found by searching the copy is one that was
added using putenv(), the implementation would need to check that the string in
environ still has the same name (and value, if the copy includes values), and whenever searching the copy produces no match
the implementation would then need to search each environment string in environ that was added using putenv() in case any of them have changed their names and now match. Thus, each use of
putenv() to add to the environment would reduce the speed advantage of having the
copy.
Performance of getenv() can be important for applications which have large numbers of environment variables. Typically,
applications like this use the environment as a resource database of user-configurable parameters. The fact that these variables
are in the user's shell environment usually means that any other program that uses environment variables (such as ls, which attempts to use COLUMNS ), or really almost any utility (LANG , LC_ALL
, and so on) is similarly slowed down by the linear search through the variables.
An implementation that maintains separate data structures, or even one that manages the memory it consumes, is not currently
required as it was thought it would reduce consensus among implementors who do not want to change their historical
implementations.
FUTURE DIRECTIONS
None.
SEE ALSO
exec, putenv(), setenv(), unsetenv()
XBD 8. Environment Variables,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
Normative text previously in the APPLICATION USAGE section is moved to the RETURN VALUE section.
A note indicating that this function need not be reentrant is added to the DESCRIPTION.
Issue 6
The following changes were made to align with the IEEE P1003.1a draft standard:
References added to the new setenv() and unsetenv() functions.
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
Austin Group Interpretation 1003.1-2001 #062 is applied, clarifying that a call to putenv() may also cause the string to be overwritten.
Austin Group Interpretation 1003.1-2001 #148 is applied, adding the FUTURE DIRECTIONS.
Austin Group Interpretation 1003.1-2001 #156 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0238 [75,428], XSH/TC1-2008/0239 [167], and XSH/TC1-2008/0240 [167] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0157 [656] is applied.
Issue 8
Austin Group Defects 188 and 1394 are applied, changing getenv() to be thread-safe.
Austin Group Defect 922 is applied, adding the secure_getenv() function.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_attr_getguardsize.html =====
pthread_attr_getguardsize
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_attr_getguardsize, pthread_attr_setguardsize — get and set the thread guardsize attribute
SYNOPSIS
#include
int pthread_attr_getguardsize(const pthread_attr_t *restrict attr,
size_t *restrict guardsize);
int pthread_attr_setguardsize(pthread_attr_t *attr,
size_t guardsize);
DESCRIPTION
The pthread_attr_getguardsize() function shall get the guardsize attribute in the attr object. This
attribute shall be returned in the guardsize parameter.
The pthread_attr_setguardsize() function shall set the guardsize attribute in the attr object. The new
value of this attribute shall be obtained from the guardsize parameter. If guardsize is zero, a guard area shall not
be provided for threads created with attr. If guardsize is greater than zero, a guard area of at least size
guardsize bytes shall be provided for each thread created with attr.
The guardsize attribute controls the size of the guard area for the created thread's stack. The guardsize
attribute provides protection against overflow of the stack pointer. If a thread's stack is created with guard protection, the
implementation allocates extra memory at the overflow end of the stack as a buffer against stack overflow of the stack pointer. If
an application overflows into this buffer an error shall result (possibly in a SIGSEGV signal being delivered to the thread).
A conforming implementation may round up the value contained in guardsize to a multiple of the configurable system
variable {PAGESIZE} (see ). If an implementation rounds up the
value of guardsize to a multiple of {PAGESIZE}, a call to pthread_attr_getguardsize() specifying attr shall
store in the guardsize parameter the guard size specified by the previous pthread_attr_setguardsize() function
call.
The default value of the guardsize attribute is implementation-defined.
If the stackaddr attribute has been set (that is, the caller is allocating and managing its own thread stacks), the
guardsize attribute shall be ignored and no protection shall be provided by the implementation. It is the responsibility of
the application to manage stack overflow along with stack allocation and management in this case.
The behavior is undefined if the value specified by the attr argument to pthread_attr_getguardsize() or
pthread_attr_setguardsize() does not refer to an initialized thread attributes object.
RETURN VALUE
If successful, the pthread_attr_getguardsize() and pthread_attr_setguardsize() functions shall return zero;
otherwise, an error number shall be returned to indicate the error.
ERRORS
These functions shall fail if:
[EINVAL]
The parameter guardsize is invalid.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
Retrieving the guardsize Attribute
This example shows how to obtain the guardsize attribute of a thread attribute object.
#include
pthread_attr_t thread_attr;
size_t  guardsize;
int     rc;
/* code initializing thread_attr */
...
rc = pthread_attr_getguardsize (&thread_attr, &guardsize);
if (rc != 0)  {
/* handle error */
...
}
else {
if (guardsize > 0) {
/* a guard area of at least guardsize bytes is provided */
...
}
else {
/* no guard area provided */
...
}
}
APPLICATION USAGE
None.
RATIONALE
The guardsize attribute is provided to the application for two reasons:
Overflow protection can potentially result in wasted system resources. An application that creates a large number of threads,
and which knows its threads never overflow their stack, can save system resources by turning off guard areas.
When threads allocate large data structures on the stack, large guard areas may be needed to detect stack overflow.
The default size of the guard area is left implementation-defined since on systems supporting very large page sizes, the
overhead might be substantial if at least one guard page is required by default.
If an implementation detects that the value specified by the attr argument to pthread_attr_getguardsize() or
pthread_attr_setguardsize() does not refer to an initialized thread attributes object, it is recommended that the function
should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD ,
CHANGE HISTORY
First released in Issue 5.
Issue 6
In the ERRORS section, a third [EINVAL] error condition is removed as it is covered by the second error condition.
The restrict keyword is added to the pthread_attr_getguardsize() prototype for alignment with the
ISO/IEC 9899:1999 standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/74 is applied, updating the ERRORS section to remove the
[EINVAL] error ("The attribute attr is invalid."), and replacing it with the optional [EINVAL] error.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/76 is applied, adding the example to the EXAMPLES section.
Issue 7
SD5-XSH-ERN-111 is applied, removing the reference to the stack attribute in the DESCRIPTION.
SD5-XSH-ERN-175 is applied, updating the DESCRIPTION to note that the default size of the guard area is
implementation-defined.
The pthread_attr_getguardsize() and pthread_attr_setguardsize() functions are moved from the XSI option to the
Base.
The [EINVAL] error for an uninitialized thread attributes object is removed; this condition results in undefined behavior.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getsockopt.html =====
getsockopt
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getsockopt — get the socket options
SYNOPSIS
#include
int getsockopt(int socket, int level, int option_name,
void *restrict option_value, socklen_t *restrict
option_len);
DESCRIPTION
The getsockopt() function manipulates options associated with a socket.
The getsockopt() function shall retrieve the value for the option specified by the option_name argument for the
socket specified by the socket argument. If the size of the option value is greater than option_len, the value stored
in the object pointed to by the option_value argument shall be silently truncated. Otherwise, the object pointed to by the
option_len argument shall be modified to indicate the actual length of the value.
The level argument specifies the protocol level at which the option resides. To retrieve options at the socket level,
specify the level argument as SOL_SOCKET. To retrieve options at other levels, supply the appropriate level identifier for
the protocol controlling the option. For example, to indicate that an option is interpreted by the TCP (Transmission Control
Protocol), set level to IPPROTO_TCP as defined in the  header.
The socket in use may require the process to have appropriate privileges to use the getsockopt() function.
The option_name argument specifies a single option to be retrieved. It can be one of the socket-level options defined in
and described in 2.10.16 Use of Options.
RETURN VALUE
Upon successful completion, getsockopt() shall return 0; otherwise, -1 shall be returned and errno set to indicate
the error.
ERRORS
The getsockopt() function shall fail if:
[EBADF]
The socket argument is not a valid file descriptor.
[EINVAL]
The specified option is invalid at the specified socket level.
[ENOPROTOOPT]
The option is not supported by the protocol.
[ENOTSOCK]
The socket argument does not refer to a socket.
The getsockopt() function may fail if:
[EACCES]
The calling process does not have appropriate privileges.
[EINVAL]
The socket has been shut down.
[ENOBUFS]
Insufficient resources are available in the system to complete the function.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.10.16 Use of Options, bind(), close(), endprotoent(), setsockopt(),
socket()
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
The restrict keyword is added to the getsockopt() prototype for alignment with the ISO/IEC 9899:1999
standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/47 is applied, updating the description of SO_LINGER in the
DESCRIPTION so that it blocks the calling thread rather than the process.
Issue 7
Austin Group Interpretation 1003.1-2001 #158 is applied, removing text relating to socket options that is now in 2.10.16 Use of Options.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/posix_spawn_file_actions_destroy.html =====
posix_spawn_file_actions_destroy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
posix_spawn_file_actions_destroy, posix_spawn_file_actions_init — destroy and initialize spawn file actions object
(ADVANCED REALTIME)
SYNOPSIS
[SPN]  #include
int posix_spawn_file_actions_destroy(posix_spawn_file_actions_t
*file_actions);
int posix_spawn_file_actions_init(posix_spawn_file_actions_t
*file_actions);
DESCRIPTION
The posix_spawn_file_actions_destroy() function shall destroy the object referenced by file_actions; the object
becomes, in effect, uninitialized. An implementation may cause posix_spawn_file_actions_destroy() to set the object
referenced by file_actions to an invalid value. A destroyed spawn file actions object can be reinitialized using
posix_spawn_file_actions_init(); the results of otherwise referencing the object after it has been destroyed are
undefined.
The posix_spawn_file_actions_init() function shall initialize the object referenced by file_actions to contain no
file actions for posix_spawn() or posix_spawnp() to perform.
A spawn file actions object is as defined in posix_spawn_file_actions_addclose().
The effect of initializing an already initialized spawn file actions object is undefined.
RETURN VALUE
Upon successful completion, these functions shall return zero; otherwise, an error number shall be returned to indicate the
error.
ERRORS
The posix_spawn_file_actions_init() function shall fail if:
[ENOMEM]
Insufficient memory exists to initialize the spawn file actions object.
The posix_spawn_file_actions_destroy() function may fail if:
[EINVAL]
The value specified by file_actions is invalid.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
These functions are part of the Spawn option and need not be provided on all implementations.
RATIONALE
Refer to the RATIONALE section in posix_spawn_file_actions_addclose().
FUTURE DIRECTIONS
None.
SEE ALSO
posix_spawn(), posix_spawn_file_actions_addclose()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1d-1999.
In the SYNOPSIS, the inclusion of  is no longer
required.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/csinh.html =====
csinh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
csinh, csinhf, csinhl — complex hyperbolic sine functions
SYNOPSIS
#include
double complex csinh(double complex z);
float complex csinhf(float complex z);
long double complex csinhl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex hyperbolic sine of z.
RETURN VALUE
These functions shall return the complex hyperbolic sine value.
[MXC]
csinh(conj(z)), csinhf(conjf(z)), and csinhl(conjl(z)) shall return
exactly the same value as conj(csinh(z)), conjf(csinhf(z)), and
conjl(csinhl(z)), respectively, and csinh(-z), csinhf(-z), and
csinhl(-z) shall return exactly the same value as -csinh(z), -csinhf(z), and
-csinhl(z), respectively, including for the special values of z below.
If z is +0 + i0, +0 + i0 shall be returned.
If z is +0 + iInf, ±0 + iNaN shall be returned and the invalid floating-point exception shall be raised;
the sign of the real part of the result is unspecified.
If z is +0 + iNaN, ±0 + iNaN shall be returned; the sign of the real part of the result is unspecified.
If z is x + iInf where x is positive and finite, NaN + iNaN shall be returned and the invalid
floating-point exception shall be raised.
If z is x + iNaN where x is non-zero and finite, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is +Inf + i0, +Inf + i0 shall be returned.
If z is +Inf + iy where y is positive and finite, +Inf (cos(y) + isin(y)) shall
be returned.
If z is +Inf + iInf, ±Inf + iNaN shall be returned and the invalid floating-point exception shall be
raised; the sign of the real part of the result is unspecified.
If z is +Inf + iNaN, ±Inf + iNaN shall be returned; the sign of the real part of the result is
unspecified.
If z is NaN + i0, NaN + i0 shall be returned.
If z is NaN + iy where y is any non-zero number, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is NaN + iNaN, NaN + iNaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
casinh()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_mutex_unlock.html =====
pthread_mutex_lock
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_mutex_lock, pthread_mutex_trylock, pthread_mutex_unlock — lock and unlock a mutex
SYNOPSIS
#include
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_trylock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
DESCRIPTION
The mutex object referenced by mutex shall be locked by a call to pthread_mutex_lock() that returns zero or
[EOWNERDEAD]. If the mutex is already locked by another thread, the calling thread shall block until the mutex becomes available.
This operation shall return with the mutex object referenced by mutex in the locked state with the calling thread as its
owner. If a thread attempts to relock a mutex that it has already locked, pthread_mutex_lock() shall behave as described in
the Relock column of the following table. If a thread attempts to unlock a mutex that it has not locked or a mutex which is
unlocked, pthread_mutex_unlock() shall behave as described in the Unlock When Not Owner column of the following
table.
Mutex Type
Robustness
Relock
Unlock When Not Owner
NORMAL
non-robust
deadlock
undefined behavior
NORMAL
robust
deadlock
error returned
ERRORCHECK
either
error returned
error returned
RECURSIVE
either
recursive (see below)
error returned
DEFAULT
non-robust
undefined behavior†
undefined behavior†
DEFAULT
robust
undefined behavior†
error returned
†
If the mutex type is PTHREAD_MUTEX_DEFAULT, the behavior of pthread_mutex_lock() may correspond to one of the three
other standard mutex types as described in the table above. If it does not correspond to one of those three, the behavior is
undefined for the cases marked †.
Where the table indicates recursive behavior, the mutex shall maintain the concept of a lock count. When a thread
successfully acquires a mutex for the first time, the lock count shall be set to one. Every time a thread relocks this mutex, the
lock count shall be incremented by one. Each time the thread unlocks the mutex, the lock count shall be decremented by one. When
the lock count reaches zero, the mutex shall become available for other threads to acquire.
The pthread_mutex_trylock() function shall be equivalent to pthread_mutex_lock(), except that if the
mutex object referenced by mutex is currently locked (by any thread, including the current thread), the call shall return
immediately. If the mutex type is PTHREAD_MUTEX_RECURSIVE and the mutex is currently owned by the calling thread, the mutex lock
count shall be incremented by one and the pthread_mutex_trylock() function shall immediately return success.
The pthread_mutex_unlock() function shall release the mutex object referenced by mutex. The manner in
which a mutex is released is dependent upon the mutex's type attribute. If there are threads blocked on the mutex object referenced
by mutex when pthread_mutex_unlock() is called, resulting in the mutex becoming available, the scheduling policy
shall determine which thread shall acquire the mutex.
(In the case of PTHREAD_MUTEX_RECURSIVE mutexes, the mutex shall become available when the count reaches zero and
the calling thread no longer has any locks on this mutex.)
If a signal is delivered to a thread waiting for a mutex, upon return from the signal handler the thread shall
resume waiting for the mutex as if it was not interrupted.
If mutex is a robust mutex and the process containing the owning thread terminated while holding the mutex
lock, a call to pthread_mutex_lock() shall return the error value [EOWNERDEAD]. If mutex is a robust mutex and the
owning thread terminated while holding the mutex lock, a call to pthread_mutex_lock() may return the error value
[EOWNERDEAD] even if the process in which the owning thread resides has not terminated. In these cases, the mutex shall be locked
by the calling thread but the state it protects is marked as inconsistent. The application should ensure that the state is made
consistent for reuse and when that is complete call pthread_mutex_consistent(). If the application is unable to recover the
state, it should unlock the mutex without a prior call to pthread_mutex_consistent(), after which the mutex is marked permanently
unusable.
If mutex does not refer to an initialized mutex object, the behavior of pthread_mutex_lock(),
pthread_mutex_trylock(), and pthread_mutex_unlock() is undefined.
RETURN VALUE
If successful, the pthread_mutex_lock(), pthread_mutex_trylock(), and pthread_mutex_unlock() functions
shall return zero; otherwise, an error number shall be returned to indicate the error.
ERRORS
The pthread_mutex_lock() and pthread_mutex_trylock() functions shall fail if:
[EAGAIN]
The mutex could not be acquired because the maximum number of recursive locks for mutex has been exceeded.
[EAGAIN]
The mutex is a robust mutex and the system resources available for robust mutexes owned would be exceeded.
[EINVAL]
[RPP|TPP]  The mutex was created with the protocol attribute having the value PTHREAD_PRIO_PROTECT and the calling thread's
priority is higher than the mutex's current priority ceiling.
[ENOTRECOVERABLE]
The state protected by the mutex is not recoverable.
[EOWNERDEAD]
The mutex is a robust mutex and the process containing the previous owning thread terminated while holding the mutex lock. The
mutex lock shall be acquired by the calling thread and it is up to the new owner to make the state consistent.
The pthread_mutex_lock() function shall fail if:
[EDEADLK]
The mutex type is PTHREAD_MUTEX_ERRORCHECK and the current thread already owns the mutex.
The pthread_mutex_trylock() function shall fail if:
[EBUSY]
The mutex could not be acquired because it was already locked.
The pthread_mutex_unlock() function shall fail if:
[EPERM]
The mutex type is PTHREAD_MUTEX_ERRORCHECK or PTHREAD_MUTEX_RECURSIVE, or the mutex is a robust mutex, and the current thread
does not own the mutex.
The pthread_mutex_lock() and pthread_mutex_trylock() functions may fail if:
[EOWNERDEAD]
The mutex is a robust mutex and the previous owning thread terminated while holding the mutex lock. The mutex lock shall be
acquired by the calling thread and it is up to the new owner to make the state consistent.
The pthread_mutex_lock() function may fail if:
[EDEADLK]
A deadlock condition was detected.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications that have assumed that non-zero return values are errors will need updating for use with robust mutexes, since a
valid return for a thread acquiring a mutex which is protecting a currently inconsistent state is [EOWNERDEAD]. Applications that
do not check the error returns, due to ruling out the possibility of such errors arising, should not use robust mutexes. If an
application is supposed to work with normal and robust mutexes it should check all return values for error conditions and if
necessary take appropriate action.
RATIONALE
Mutex objects are intended to serve as a low-level primitive from which other thread synchronization functions can be built. As
such, the implementation of mutexes should be as efficient as possible, and this has ramifications on the features available at the
interface.
The mutex functions and the particular default settings of the mutex attributes have been motivated by the desire
to not preclude fast, inlined implementations of mutex locking and unlocking.
Since most attributes only need to be checked when a thread is going to be blocked, the use of attributes does not
slow the (common) mutex-locking case.
Likewise, while being able to extract the thread ID of the owner of a mutex might be desirable, it would require
storing the current thread ID when each mutex is locked, and this could incur unacceptable levels of overhead. Similar arguments
apply to a mutex_tryunlock operation.
For further rationale on the extended mutex types, see XRAT Threads Extensions.
If an implementation detects that the value specified by the mutex argument does not refer to an initialized
mutex object, it is recommended that the function should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_mutex_clocklock(), pthread_mutex_consistent(), pthread_mutex_destroy(), pthread_mutexattr_getrobust()
XBD 4.15.2 Memory Synchronization,
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_mutex_lock(), pthread_mutex_trylock(), and pthread_mutex_unlock() functions are marked as part
of the Threads option.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX
Specification:
The behavior when attempting to relock a mutex is defined.
The pthread_mutex_timedlock() function is added to
the SEE ALSO section for alignment with IEEE Std 1003.1d-1999.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/98 is applied, updating the ERRORS section so that
the [EDEADLK] error includes detection of a deadlock condition. The RATIONALE section is also reworded to take into account
non-XSI-conformant systems.
Issue 7
SD5-XSH-ERN-43 is applied, marking the "shall fail" case of the [EINVAL] error as dependent on the Thread Priority Protection
option.
Changes are made from The Open Group Technical Standard, 2006, Extended API Set Part 3.
The pthread_mutex_lock(), pthread_mutex_trylock(), and pthread_mutex_unlock() functions are
moved from the Threads option to the Base.
The following extended mutex types are moved from the XSI option to the Base:
PTHREAD_MUTEX_NORMAL
PTHREAD_MUTEX_ERRORCHECK
PTHREAD_MUTEX_RECURSIVE
PTHREAD_MUTEX_DEFAULT
The DESCRIPTION is updated to clarify the behavior when mutex does not refer to an initialized mutex.
The ERRORS section is updated to account properly for all of the various mutex types.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0461 [121], XSH/TC1-2008/0462 [92,428], and XSH/TC1-2008/0463
[121] are applied.
Issue 8
Austin Group Defect 354 is applied, adding the [EAGAIN] error for exceeding system resources available for robust mutexes
owned.
Austin Group Defect 1115 is applied, changing "the thread" to "the calling thread".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/thrd_sleep.html =====
thrd_sleep
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
thrd_sleep — suspend execution for an interval
SYNOPSIS
#include
int thrd_sleep(const struct timespec *duration,
struct timespec *remaining);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The thrd_sleep() function shall suspend execution of the calling thread until either the interval specified by
duration has elapsed or a signal is delivered to the calling thread whose action is to invoke a signal-catching function or
to terminate the process. If interrupted by a signal and the remaining argument is not null, the amount of time remaining
(the requested interval minus the time actually slept) shall be stored in the interval it points to. The duration and
remaining arguments can point to the same object.
The suspension time may be longer than requested because the interval is rounded up to an integer multiple of the sleep
resolution or because of the scheduling of other activity by the system. But, except for the case of being interrupted by a signal,
the suspension time shall not be less than that specified, as measured by the system clock TIME_UTC.
RETURN VALUE
The thrd_sleep() function shall return zero if the requested time has elapsed, -1 if it has been interrupted by a signal,
or a negative value (which may also be -1) if it fails for any other reason. [CX]  If it returns a
negative value, it shall set errno to indicate the error.
ERRORS
[CX]  The
thrd_sleep() function shall fail if:
[EINTR]
The thrd_sleep() function was interrupted by a signal.
[EINVAL]
The duration argument specified a nanosecond value less than zero or greater than or equal to 1000 million.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Since the return value may be -1 for errors other than [EINTR], applications should examine errno to distinguish [EINTR]
from other errors (and thus determine whether the unslept time is available in the interval pointed to by remaining).
RATIONALE
The thrd_sleep() function is identical to the nanosleep() function
except that the return value may be any negative value when it fails with an error other than [EINTR].
FUTURE DIRECTIONS
None.
SEE ALSO
nanosleep()
XBD ,
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/c32rtomb.html =====
c16rtomb
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
c16rtomb, c32rtomb — convert a Unicode character code to a character (restartable)
SYNOPSIS
#include
size_t c16rtomb(char *restrict s, char16_t c16, mbstate_t *restrict ps);
size_t c32rtomb(char *restrict s, char32_t c32, mbstate_t *restrict
ps);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
If s is a null pointer, the c16rtomb() function shall be equivalent to the call:
c16rtomb(buf, L'\0', ps)
where buf is an internal buffer.
If s is not a null pointer, the c16rtomb() function shall determine the number of bytes needed to represent the
character that corresponds to the wide character given by c16 (including any shift sequences), and store the resulting bytes
in the array whose first element is pointed to by s. At most {MB_CUR_MAX} bytes shall be stored. If c16 is a null
wide character, a null byte shall be stored, preceded by any shift sequence needed to restore the initial shift state; the
resulting state described shall be the initial conversion state.
If ps is a null pointer, the c16rtomb() function shall use its own internal mbstate_t object, which shall
be initialized at program start-up to the initial conversion state. Otherwise, the mbstate_t object pointed to by ps
shall be used to completely describe the current conversion state of the associated character sequence.
The behavior of this function is affected by the LC_CTYPE category of the current locale.
The mbrtoc16() function shall not change the setting of errno if
successful.
The c32rtomb() function shall behave the same way as c16rtomb() except that the second parameter shall be an
object of type char32_t instead of char16_t. References to c16 in the above description shall apply as if they
were c32 when they are being read as describing c32rtomb().
If called with a null ps argument, the c16rtomb() function need not be thread-safe; however, such calls shall
avoid data races with calls to c16rtomb() with a non-null argument and with calls to all other functions.
If called with a null ps argument, the c32rtomb() function need not be thread-safe; however, such calls shall
avoid data races with calls to c32rtomb() with a non-null argument and with calls to all other functions.
The implementation shall behave as if no function defined in this volume of POSIX.1-2024 calls c16rtomb() or
c32rtomb() with a null pointer for ps.
RETURN VALUE
These functions shall return the number of bytes stored in the array object (including any shift sequences). When c16 or
c32 is not a valid wide character, an encoding error shall occur. In this case, the function shall store the value of the
macro [EILSEQ] in errno and shall return (size_t)-1; the conversion state is unspecified.
ERRORS
These functions shall fail if:
[EILSEQ]
An invalid wide-character code is detected.
These functions may fail if:
[EINVAL]
[CX]
ps points to an object that contains an invalid conversion state.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
mbrtoc16()
XBD
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strtol.html =====
strtol
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strtol, strtoll — convert a string to a long integer
SYNOPSIS
#include
long strtol(const char *restrict nptr, char **restrict endptr, int base);
long long strtoll(const char *restrict nptr, char **restrict endptr,
int base)
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall convert the initial portion of the string pointed to by nptr to a type long and long
long representation, respectively. First, they decompose the input string into three parts:
An initial, possibly empty, sequence of white-space bytes
A subject sequence interpreted as an integer represented in some radix determined by the value of base
A final string of one or more unrecognized characters, including the terminating NUL character of the input string.
Then they shall attempt to convert the subject sequence to an integer, and return the result.
If the value of base is 0, the expected form of the subject sequence is that of a decimal constant, octal constant, or
hexadecimal constant, any of which may be preceded by a '+' or '-' sign. A decimal constant begins with a
non-zero digit, and consists of a sequence of decimal digits. An octal constant consists of the prefix '0' optionally
followed by a sequence of the digits '0' to '7' only. A hexadecimal constant consists of the prefix 0x or 0X
followed by a sequence of the decimal digits and letters 'a' (or 'A') to 'f' (or 'F') with
values 10 to 15 respectively.
If the value of base is between 2 and 36, the expected form of the subject sequence is a sequence of letters and digits
representing an integer with the radix specified by base, optionally preceded by a '+' or '-' sign. The
letters from 'a' (or 'A') to 'z' (or 'Z') inclusive are ascribed the values 10 to 35; only
letters whose ascribed values are less than that of base are permitted. If the value of base is 16, the characters 0x
or 0X may optionally precede the sequence of letters and digits, following the sign if present.
The subject sequence is defined as the longest initial subsequence of the input string, starting with the first non-white-space
byte, that is of the expected form. The subject sequence shall contain no characters if the input string is empty or consists
entirely of white-space bytes, or if the first non-white-space byte is other than a sign or a permissible letter or digit.
If the subject sequence has the expected form and the value of base is 0, the sequence of characters starting with the
first digit shall be interpreted as an integer constant. If the subject sequence has the expected form and the value of base
is between 2 and 36, it shall be used as the base for conversion, ascribing to each letter its value as given above. If the subject
sequence begins with a , the resulting value shall be the negative of the converted value. A pointer to the
final string shall be stored in the object pointed to by endptr, provided that endptr is not a null pointer.
In other than the C [CX]   or POSIX  locale, additional
locale-specific subject sequence forms may be accepted.
If the subject sequence is empty or does not have the expected form, no conversion is performed; the value of nptr shall
be stored in the object pointed to by endptr, provided that endptr is not a null pointer.
These functions shall not change the setting of errno if successful.
Since 0, {LONG_MIN} or {LLONG_MIN}, and {LONG_MAX} or {LLONG_MAX} are returned on error and are also valid returns on success,
an application wishing to check for error situations should set errno to 0, then call strtol() or strtoll(),
then check errno.
RETURN VALUE
Upon successful completion, these functions shall return the converted value, if any. If no conversion could be performed, 0
shall be returned [CX]   and errno may be set to [EINVAL].
[CX]  If
the value of base is not supported, 0 shall be returned and errno shall be set to [EINVAL].
If the correct value is outside the range of representable values, {LONG_MIN}, {LONG_MAX}, {LLONG_MIN}, or {LLONG_MAX} shall be
returned (according to the sign of the value), and errno set to [ERANGE].
ERRORS
These functions shall fail if:
[EINVAL]
[CX]
The value of base is not supported.
[ERANGE]
The value to be returned is not representable.
These functions may fail if:
[EINVAL]
No conversion could be performed.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Since the value of *endptr is unspecified if the value of base is not supported, applications should either ensure
that base has a supported value (0 or between 2 and 36) before the call, or check for an [EINVAL] error before examining
*endptr.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
fscanf(), isalpha(), strtod()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate that errno is not changed if the function is successful.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the RETURN VALUE and ERRORS sections, the [EINVAL] optional error condition is added if no conversion could be performed.
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The strtol() prototype is updated.
The strtoll() function is added.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0616 [453], XSH/TC1-2008/0617 [105], XSH/TC1-2008/0618 [453],
XSH/TC1-2008/0619 [453], and XSH/TC1-2008/0620 [453] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0351 [892], XSH/TC2-2008/0352 [584], XSH/TC2-2008/0353 [796], and
XSH/TC2-2008/0354 [892] are applied.
Issue 8
Austin Group Defect 700 is applied, clarifying how a subject sequence beginning with  is converted.
Austin Group Defect 1163 is applied, clarifying the handling of white space in the input string.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/htobe16.html =====
be16toh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
be16toh, be32toh, be64toh, htobe16, htobe32, htobe64, htole16, htole32, htole64, le16toh, le32toh, le64toh — convert
values between host and specified byte order
SYNOPSIS
#include
uint16_t be16toh(uint16_t big_endian_16bits);
uint32_t be32toh(uint32_t big_endian_32bits);
uint64_t be64toh(uint64_t big_endian_64bits);
uint16_t htobe16(uint16_t host_16bits);
uint32_t htobe32(uint32_t host_32bits);
uint64_t htobe64(uint64_t host_64bits);
uint16_t htole16(uint16_t host_16bits);
uint32_t htole32(uint32_t host_32bits);
uint64_t htole64(uint64_t host_64bits);
uint16_t le16toh(uint16_t little_endian_16bits);
uint32_t le32toh(uint32_t little_endian_32bits);
uint64_t le64toh(uint64_t little_endian_64bits);
DESCRIPTION
These functions shall convert integer values of various sizes between host representations and representations in a specified
order.
On some implementations, these functions are defined as macros.
A little-endian representation of an integer has the least significant byte stored as the first byte, with the significance of
the bytes increasing as the byte address increases. A big-endian representation has the most significant byte as the first byte,
with the significance of the bytes reducing as the byte address increases.
Note:
Network byte order is big-endian.
For example, the uint32_t value 0x01020304 is represented as the four bytes 0x04, 0x03, 0x02, 0x01 on a little-endian
host, and as 0x01, 0x02, 0x03, 0x04 on a big-endian host.
For each of the sizes 16, 32 and 64, the htobeSIZE() function shall convert from whatever order the host uses to
big-endian representation, htoleSIZE() shall convert to little-endian representation, beSIZEtoh() shall convert from
big-endian to host order, and leSIZEtoh() shall convert from little-endian to host order.
RETURN VALUE
These functions shall return an unsigned integer of the appropriate size and representation.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
#include
#include
#include
int main(int argc, char *argv[])
{
uint32_t val;
if (argc > 1) {
val = (uint32_t)strtoul(argv[1], NULL, 0);
printf("Value: %08x\n", val);
printf("As bytes:\n");
union {
uint32_t asint;
unsigned char asbytes[sizeof(uint32_t)];
} u;
printf("Little endian: ");
u.asint = htole32(val);
for (int i = 0; i  is included:
htobe32
htonl
htobe16
htons
be32toh
ntohl
be16toh
ntohs
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
htonl()
XBD ,
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_attr_setscope.html =====
pthread_attr_getscope
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_attr_getscope, pthread_attr_setscope — get and set the contentionscope attribute (REALTIME
THREADS)
SYNOPSIS
[TPS]  #include
int pthread_attr_getscope(const pthread_attr_t *restrict attr,
int *restrict contentionscope);
int pthread_attr_setscope(pthread_attr_t *attr, int contentionscope);
DESCRIPTION
The pthread_attr_getscope() and pthread_attr_setscope() functions, respectively, shall get and set the
contentionscope attribute in the attr object.
The contentionscope attribute may have the values PTHREAD_SCOPE_SYSTEM, signifying system scheduling contention scope, or
PTHREAD_SCOPE_PROCESS, signifying process scheduling contention scope. The symbols PTHREAD_SCOPE_SYSTEM and PTHREAD_SCOPE_PROCESS
are defined in the  header.
The behavior is undefined if the value specified by the attr argument to pthread_attr_getscope() or
pthread_attr_setscope() does not refer to an initialized thread attributes object.
RETURN VALUE
If successful, the pthread_attr_getscope() and pthread_attr_setscope() functions shall return zero; otherwise, an
error number shall be returned to indicate the error.
ERRORS
The pthread_attr_setscope() function shall fail if:
[ENOTSUP]
An attempt was made to set the attribute to an unsupported value.
The pthread_attr_setscope() function may fail if:
[EINVAL]
The value of contentionscope is not valid.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
After these attributes have been set, a thread can be created with the specified attributes using pthread_create(). Using these routines does not affect the current running
thread.
See 2.9.4 Thread Scheduling for further details on thread
scheduling attributes and their default settings.
RATIONALE
If an implementation detects that the value specified by the attr argument to pthread_attr_getscope() or
pthread_attr_setscope() does not refer to an initialized thread attributes object, it is recommended that the function
should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_attr_destroy(), pthread_attr_getinheritsched(), pthread_attr_getschedpolicy(), pthread_attr_getschedparam(), pthread_create()
XBD ,
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Marked as part of the Realtime Threads Feature Group.
Issue 6
The pthread_attr_getscope() and pthread_attr_setscope() functions are marked as part of the Threads and Thread
Execution Scheduling options.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Thread
Execution Scheduling option.
The restrict keyword is added to the pthread_attr_getscope() prototype for alignment with the
ISO/IEC 9899:1999 standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/81 is applied, adding a reference to 2.9.4 Thread Scheduling in the APPLICATION USAGE section.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/82 is applied, updating the ERRORS section to include optional
errors for the case when attr refers to an uninitialized thread attribute object.
Issue 7
The pthread_attr_getscope() and pthread_attr_setscope() functions are marked only as part of the Thread Execution
Scheduling option as the Threads option is now part of the Base.
The [EINVAL] error for an uninitialized thread attributes object is removed; this condition results in undefined behavior.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0453 [314] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0264 [757] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/htons.html =====
htonl
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
htonl, htons, ntohl, ntohs — convert values between host and network byte order
SYNOPSIS
#include
uint32_t htonl(uint32_t hostlong);
uint16_t htons(uint16_t hostshort);
uint32_t ntohl(uint32_t netlong);
uint16_t ntohs(uint16_t netshort);
DESCRIPTION
These functions shall convert 16-bit and 32-bit quantities between network byte order and host byte order.
On some implementations, these functions are defined as macros.
The uint32_t and uint16_t types are defined in .
RETURN VALUE
The htonl() and htons() functions shall return the argument value converted from host to network byte order.
The ntohl() and ntohs() functions shall return the argument value converted from network to host byte order.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
These functions are most often used in conjunction with IPv4 addresses and ports as returned by gethostent() and getservent().
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
be16toh(), endhostent(),
endservent()
XBD , ,
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
Issue 8
Austin Group Defect 162 is applied, adding be16toh() and  to the SEE ALSO section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/abs.html =====
abs
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
abs — return an integer absolute value
SYNOPSIS
#include
int abs(int i);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The abs() function shall compute the absolute value of its integer operand, i. If the result cannot be
represented, the behavior is undefined.
RETURN VALUE
The abs() function shall return the absolute value of its integer operand.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Since POSIX.1 requires a two's complement representation of int, the absolute value of the negative integer with the
largest magnitude {INT_MIN} is not representable, thus abs(INT_MIN) is undefined.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
fabs(), labs()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
Extensions beyond the ISO C standard are marked.
Issue 8
Austin Group Defect 1108 is applied, changing the APPLICATION USAGE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getdate.html =====
getdate
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getdate — convert user format date and time
SYNOPSIS
[XSI]  #include
struct tm *getdate(const char *string);
DESCRIPTION
The getdate() function shall convert a string representation of a date or time into a broken-down time.
The external variable or macro getdate_err, which has type int, is used by getdate() to return error
values. It is unspecified whether getdate_err is a macro or an identifier declared with external linkage, and whether or not
it is a modifiable lvalue. If a macro definition is suppressed in order to access an actual object, or a program defines an
identifier with the name getdate_err, the behavior is undefined.
Templates are used to parse and interpret the input string. The templates are contained in a text file identified by the
environment variable DATEMSK . The DATEMSK variable should be set to indicate the full pathname of the file that
contains the templates. The first line in the template that matches the input specification is used for interpretation and
conversion into the internal time format.
The following conversion specifications shall be supported:
%%
Equivalent to %.
%a
Abbreviated weekday name.
%A
Full weekday name.
%b
Abbreviated month name.
%B
Full month name.
%c
Locale's appropriate date and time representation.
%C
Century number [00,99]; leading zeros are permitted but not required.
%d
Day of month [01,31]; the leading 0 is optional.
%D
Date as %m/%d/%y.
%e
Equivalent to %d.
%h
Abbreviated month name.
%H
Hour [00,23].
%I
Hour [01,12].
%m
Month number [01,12].
%M
Minute [00,59].
%n
Equivalent to .
%p
Locale's equivalent of either AM or PM.
%r
The locale's appropriate representation of time in 12-hour clock notation, if the 12-hour format is supported in the locale
(see XBD 7.3.5 LC_TIME). In the POSIX locale, this shall be
equivalent to %I:%M:%S %p.
%R
Time as %H:%M.
%S
Seconds [00,60]. The range goes to 60 (rather than stopping at 59) to allow positive leap seconds to be expressed. Since leap
seconds cannot be predicted by any algorithm, leap second data has to come from some external source.
%t
Equivalent to .
%T
Time as %H:%M:%S.
%w
Weekday number (Sunday = [0,6]).
%x
Locale's appropriate date representation.
%X
Locale's appropriate time representation.
%y
Year within century. When a century is not otherwise specified, values in the range [69,99] shall refer to years 1969 to 1999
inclusive, and values in the range [00,68] shall refer to years 2000 to 2068 inclusive.
Note:
It is expected that in a future version of this standard the default century inferred from a 2-digit year will change. (This
would apply to all commands accepting a 2-digit year as input.)
%Y
Year as "ccyy" (for example, 2001).
%Z
Timezone name or no characters if no timezone exists. If the timezone supplied by %Z is not the timezone that
getdate() expects, an invalid input specification error shall result. The getdate() function calculates an expected
timezone based on information supplied to the function (such as the hour, day, and month).
The match between the template and input specification performed by getdate() shall be case-insensitive.
The month and weekday names can consist of any combination of upper and lowercase letters. The process can request that the
input date or time specification be in a specific language by setting the LC_TIME category (see setlocale()).
Leading zeros are not necessary for the descriptors that allow leading zeros. However, at most two digits are allowed for those
descriptors, including leading zeros. Extra white space in either the template file or in string shall be ignored.
The results are undefined if the conversion specifications %c, %x, and %X include unsupported
conversion specifications.
The following rules apply for converting the input specification into the internal format:
If %Z is being scanned, then getdate() shall initialize the broken-down time to be the current time in the
scanned timezone. Otherwise, it shall initialize the broken-down time based on the current local time as if localtime() had been called.
If only the weekday is given, the day chosen shall be the day, starting with today and moving into the future, which first
matches the named day.
If only the month (and no year) is given, the month chosen shall be the month, starting with the current month and moving into
the future, which first matches the named month. The first day of the month shall be assumed if no day is given.
If no hour, minute, and second are given, the current hour, minute, and second shall be assumed.
If no date is given, the hour chosen shall be the hour, starting with the current hour and moving into the future, which first
matches the named hour.
If a conversion specification in the DATEMSK file does not correspond to one of the conversion specifications above, the
behavior is unspecified.
The getdate() function need not be thread-safe.
RETURN VALUE
Upon successful completion, getdate() shall return a pointer to a struct tm. Otherwise, it shall return a null
pointer and set getdate_err to indicate the error.
ERRORS
The getdate() function shall fail in the following cases, setting getdate_err to the value shown in the list
below. Any changes to errno are unspecified.
The DATEMSK environment variable is null or undefined.
The template file cannot be opened for reading.
Failed to get file status information.
The template file is not a regular file.
An I/O error is encountered while reading the template file.
Memory allocation failed (not enough memory available).
There is no line in the template that matches the input.
Invalid input specification. For example, February 31; or a time is specified that cannot be represented in a time_t
(representing the time in seconds since the Epoch).
The following sections are informative.
EXAMPLES
The following example shows the possible contents of a template:
%m
%A %B %d, %Y, %H:%M:%S
%A
%B
%m/%d/%y %I %p
%d,%m,%Y %H:%M
at %A the %dst of %B in %Y
run job at %I %p,%B %dnd
%A den %d. %B %Y %H.%M Uhr
The following are examples of valid input specifications for the template in Example 1:
getdate("10/1/87 4 PM");
getdate("Friday");
getdate("Friday September 18, 1987, 10:30:30");
getdate("24,9,1986 10:30");
getdate("at monday the 1st of december in 1986");
getdate("run job at 3 PM, december 2nd");
If the LC_TIME category is set to a German locale that includes freitag as a weekday name and oktober as a
month name, the following would be valid:
getdate("freitag den 10. oktober 1986 10.30 Uhr");
The following example shows how local date and time specification can be defined in the template:
Invocation
Line in Template
getdate("11/27/86")
%m/%d/%y
getdate("27.11.86")
%d.%m.%y
getdate("86-11-27")
%y-%m-%d
getdate("Friday 12:00:00")
%A %H:%M:%S
The following examples help to illustrate the above rules assuming that the current date is Mon Sep 22 12:19:47
EDT 1986 and the LC_TIME category is set to the default C or POSIX locale:
Input
Line in Template
Date
Mon
%a
Mon Sep 22 12:19:47 EDT 1986
Sun
%a
Sun Sep 28 12:19:47 EDT 1986
Fri
%a
Fri Sep 26 12:19:47 EDT 1986
September
%B
Mon Sep 1 12:19:47 EDT 1986
January
%B
Thu Jan 1 12:19:47 EST 1987
December
%B
Mon Dec 1 12:19:47 EST 1986
Sep Mon
%b %a
Mon Sep 1 12:19:47 EDT 1986
Jan Fri
%b %a
Fri Jan 2 12:19:47 EST 1987
Dec Mon
%b %a
Mon Dec 1 12:19:47 EST 1986
Jan Wed 1989
%b %a %Y
Wed Jan 4 12:19:47 EST 1989
Fri 9
%a %H
Fri Sep 26 09:00:00 EDT 1986
Feb 10:30
%b %H:%S
Sun Feb 1 10:00:30 EST 1987
10:30
%H:%M
Tue Sep 23 10:30:00 EDT 1986
13:30
%H:%M
Mon Sep 22 13:30:00 EDT 1986
APPLICATION USAGE
Although historical versions of getdate() did not require that  declare the external variable getdate_err, this volume of POSIX.1-2024
does require it. The standard developers encourage applications to remove declarations of getdate_err and instead
incorporate the declaration by including .
Applications should use %Y (4-digit years) in preference to %y (2-digit years).
RATIONALE
In standard locales, the conversion specifications %c, %x, and %X do not include unsupported
conversion specifiers and so the text regarding results being undefined is not a problem in that case.
FUTURE DIRECTIONS
None.
SEE ALSO
ctime(), localtime(), setlocale(), strftime(), times()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
The last paragraph of the DESCRIPTION is added.
The %C conversion specification is added, and the exact meaning of the %y conversion
specification is clarified in the DESCRIPTION.
A note indicating that this function need not be reentrant is added to the DESCRIPTION.
The %R conversion specification is changed to follow historical practice.
Issue 6
The DESCRIPTION is updated to refer to "seconds since the Epoch" rather than "seconds since 00:00:00 UTC (Coordinated
Universal Time), January 1 1970" for consistency with other time functions.
The description of %S is updated so that the valid range is [00,60] rather than [00,61].
The DESCRIPTION is updated to refer to conversion specifications instead of field descriptors for consistency with
other functions.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
The description of the getdate_err value is expanded.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0152 [796] is applied.
Issue 8
Austin Group Defect 1307 is applied, changing the %r conversion in relation to locales that do not support the 12-hour
clock format.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/dprintf.html =====
fprintf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
asprintf, dprintf, fprintf, printf, snprintf, sprintf — print formatted output
SYNOPSIS
#include
[CX]  int asprintf(char **restrict ptr, const char *restrict format,
...);
int dprintf(int fildes, const char *restrict format, ...);
int fprintf(FILE *restrict stream, const char *restrict format, ...);
int printf(const char *restrict format, ...);
int snprintf(char *restrict s, size_t n,
const char *restrict format, ...);
int sprintf(char *restrict s, const char *restrict format, ...);
DESCRIPTION
[CX]  Except for asprintf(), dprintf(), and the behavior of the %lc conversion when passed a null wide
character, the functionality described on this reference page is aligned with the ISO C standard. Any other conflict between
the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard for all fprintf(), printf(), snprintf(), and sprintf() functionality except in relation to the
%lc conversion when passed a null wide character.
The fprintf() function shall place output on the named output stream. The printf() function shall place
output on the standard output stream stdout. The sprintf() function shall place output followed by the null byte,
'\0', in consecutive bytes starting at *s; it is the user's responsibility to ensure that enough space is
available.
[CX]  The
asprintf() function shall be equivalent to sprintf(), except that the output string shall be written to dynamically
allocated memory, allocated as if by a call to malloc(), of sufficient length to hold
the resulting string, including a terminating null byte. If the call to asprintf() is successful, the address of this
dynamically allocated string shall be stored in the location referenced by ptr.
The dprintf() function shall be equivalent to the fprintf() function, except that dprintf() shall write
output to the file associated with the file descriptor specified by the fildes argument rather than place output on a
stream.
The snprintf() function shall be equivalent to sprintf(), with the addition of the n argument which limits
the number of bytes written to the buffer referred to by s. If n is zero, nothing shall be written and s may
be a null pointer. Otherwise, output bytes beyond the n-1st shall be discarded instead of being written to the array, and a
null byte is written at the end of the bytes actually written into the array.
If copying takes place between objects that overlap as a result of a call to sprintf() or snprintf(), the results
are undefined.
Each of these functions converts, formats, and prints its arguments under control of the format. The application shall
ensure that the format is a character string, beginning and ending in its initial shift state, if any. The format is composed of
zero or more directives: ordinary characters, which are simply copied to the output stream, and conversion
specifications, each of which shall result in the fetching of zero or more arguments. The results are undefined if there are
insufficient arguments for the format. If the format is exhausted while arguments remain, the excess arguments shall be evaluated
but are otherwise ignored.
[CX]
Conversions can be applied to the nth argument after the format in the argument list, rather than to the next unused
argument. In this case, the conversion specifier character % (see below) is replaced by the sequence
"%n$", where n is a decimal integer in the range [1,{NL_ARGMAX}], giving the position of the
argument in the argument list. This feature provides for the definition of format strings that select arguments in an order
appropriate to specific languages (see the EXAMPLES section).
The format can contain either numbered argument conversion specifications (that is, those introduced by
"%n$" and optionally containing the "*m$" forms of field width and precision), or
unnumbered argument conversion specifications (that is, those introduced by the % character and optionally containing the
* form of field width and precision), but not both. The only exception to this is that %% can be mixed with the
"%n$" form. The results of mixing numbered and unnumbered argument specifications in a format string are
undefined. When numbered argument specifications are used, specifying the Nth argument requires that all the leading
arguments, from the first to the (N-1)th, are specified in the format string.
In format strings containing the "%n$" form of conversion specification, numbered arguments in the
argument list can be referenced from the format string as many times as required.
In format strings containing the % form of conversion specification, each conversion specification uses the first
unused argument in the argument list.
[CX]  All
forms of the fprintf() functions allow for the insertion of a language-dependent radix character in the output string. The
radix character is defined in the current locale (category LC_NUMERIC ). In the POSIX locale, or in a locale where the radix
character is not defined, the radix character shall default to a  ('.').
Each conversion specification is introduced by the '%' character [CX]   or by the
character sequence "%n$",   after
which the following appear in sequence:
Zero or more flags (in any order), which modify the meaning of the conversion specification.
An optional minimum field width. If the converted value has fewer bytes than the field width, it shall be padded with
characters by default on the left; it shall be padded on the right if the left-adjustment flag ('-'),
described below, is given to the field width. The field width takes the form of an  ('*'), [CX]   or in
conversion specifications introduced by "%n$" the "*m$" string,  described below, or a decimal integer.
An optional precision that gives the minimum number of digits to appear for the d, i, o,
u, x, and X conversion specifiers; the number of digits to appear after the radix character for the
a, A, e, E, f, and F conversion specifiers; the maximum number of significant
digits for the g and G conversion specifiers; or the maximum number of bytes to be printed from a string in the
s [XSI]   and S   conversion specifiers. The
precision takes the form of a  ('.') followed either by an  ('*'), [CX]   or in
conversion specifications introduced by "%n$" the "*m$" string,  described below, or an optional decimal digit string, where a null digit
string is treated as zero. If a precision appears with any other conversion specifier, the behavior is undefined.
An optional length modifier that specifies the size of the argument.
A conversion specifier character that indicates the type of conversion to be applied.
A field width, or precision, or both, may be indicated by an  ('*'). In this case an argument of type
int supplies the field width or precision. Applications shall ensure that arguments specifying field width, or precision, or
both appear in that order before the argument, if any, to be converted. A negative field width is taken as a '-' flag
followed by a positive field width. A negative precision is taken as if the precision were omitted. [CX]   In format
strings containing conversion specifications introduced by "%n$", in addition to being indicated by the
decimal digit string, a field width may be indicated by the sequence "*m$" and precision by the sequence
".*m$", where m is a decimal integer in the range [1,{NL_ARGMAX}] giving the position in the
argument list (after the format argument) of an integer argument containing the field width or precision, for example:
printf("%1$d:%2$.*3$d:%4$.*3$d\n", hour, min, precision, sec);
The flag characters and their meanings are:
'
[CX]
(The .) The integer portion of the result of a decimal conversion (%i, %d, %u,
%f, %F, %g, or %G) shall be formatted with thousands' grouping characters. For other
conversions the behavior is undefined. The non-monetary grouping character is used.
-
The result of the conversion shall be left-justified within the field. The conversion is right-justified if this flag is not
specified.
+
The result of a signed conversion shall always begin with a sign ('+' or '-'). The conversion shall begin
with a sign only when a negative value is converted if this flag is not specified.
If the first character of a signed conversion is not a sign or if a signed conversion results in no characters, a
shall be prefixed to the result. This means that if the  and '+' flags both appear, the  flag
shall be ignored.
#
Specifies that the value is to be converted to an alternative form. For o conversion, it shall increase the precision,
if and only if necessary, to force the first digit of the result to be a zero (if the value and precision are both 0, a single 0 is
printed). For x or X conversion specifiers, a non-zero result shall have 0x (or 0X) prefixed to it. For
a, A, e, E, f, F, g, and G conversion specifiers, the
result shall always contain a radix character, even if no digits follow the radix character. Without this flag, a radix character
appears in the result of these conversions only if a digit follows it. For g and G conversion specifiers,
trailing zeros shall not be removed from the result as they normally are. For other conversion specifiers, the behavior is
undefined.
0
For d, i, o, u, x, X, a, A, e, E,
f, F, g, and G conversion specifiers, leading zeros (following any indication of sign or base)
are used to pad to the field width rather than performing space padding, except when converting an infinity or NaN. If the
'0' and '-' flags both appear, the '0' flag is ignored. For d, i, o,
u, x, and X conversion specifiers, if a precision is specified, the '0' flag shall be ignored.
[CX]
If the '0' and  flags both appear, the grouping characters are inserted before zero padding. For
other conversions, the behavior is undefined.
The length modifiers and their meanings are:
hh
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a signed char or unsigned char argument (the argument will have been promoted according to the integer
promotions, but its value shall be converted to signed char or unsigned char before printing); or that a following
n conversion specifier applies to a pointer to a signed char argument.
h
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a short or unsigned short argument (the argument will have been promoted according to the integer
promotions, but its value shall be converted to short or unsigned short before printing); or that a following
n conversion specifier applies to a pointer to a short argument.
l (ell)
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a long or unsigned long argument; that a following n conversion specifier applies to a pointer to
a long argument; that a following c conversion specifier applies to a wint_t argument; that a following
s conversion specifier applies to a pointer to a wchar_t argument; or has no effect on a following a,
A, e, E, f, F, g, or G conversion specifier.
ll (ell-ell)
Specifies that a following d, i, o, u, x, or X conversion specifier applies
to a long long or unsigned long long argument; or that a following n conversion specifier applies to a
pointer to a long long argument.
j
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to an intmax_t or uintmax_t argument; or that a following n conversion specifier applies to a
pointer to an intmax_t argument.
z
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a size_t or the corresponding signed integer type argument; or that a following n conversion specifier
applies to a pointer to a signed integer type corresponding to a size_t argument.
t
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a ptrdiff_t or the corresponding unsigned type argument; or that a following n conversion
specifier applies to a pointer to a ptrdiff_t argument.
L
Specifies that a following a, A, e, E, f, F, g, or G
conversion specifier applies to a long double argument.
If a length modifier appears with any conversion specifier other than as specified above, the behavior is undefined.
The conversion specifiers and their meanings are:
d, i
The int argument shall be converted to a signed decimal in the style "[-]dddd". The precision
specifies the minimum number of digits to appear; if the value being converted can be represented in fewer digits, it shall be
expanded with leading zeros. The default precision is 1. The result of converting zero with an explicit precision of zero shall be
no characters.
o
The unsigned argument shall be converted to unsigned octal format in the style "dddd". The
precision specifies the minimum number of digits to appear; if the value being converted can be represented in fewer digits, it
shall be expanded with leading zeros. The default precision is 1. The result of converting zero with an explicit precision of zero
shall be no characters.
u
The unsigned argument shall be converted to unsigned decimal format in the style "dddd". The
precision specifies the minimum number of digits to appear; if the value being converted can be represented in fewer digits, it
shall be expanded with leading zeros. The default precision is 1. The result of converting zero with an explicit precision of zero
shall be no characters.
x
The unsigned argument shall be converted to unsigned hexadecimal format in the style "dddd";
the letters "abcdef" are used. The precision specifies the minimum number of digits to appear; if the value being
converted can be represented in fewer digits, it shall be expanded with leading zeros. The default precision is 1. The result of
converting zero with an explicit precision of zero shall be no characters.
X
Equivalent to the x conversion specifier, except that letters "ABCDEF" are used instead of
"abcdef".
f, F
The double argument shall be converted to decimal notation in the style
"[-]ddd.ddd", where the number of digits after the radix character is equal to the
precision specification. If the precision is missing, it shall be taken as 6; if the precision is explicitly zero and no
'#' flag is present, no radix character shall appear. If a radix character appears, at least one digit appears before it.
The low-order digit shall be rounded in an implementation-defined manner.
A double argument representing an infinity shall be converted in one of the styles "[-]inf" or
"[-]infinity"; which style is implementation-defined. A double argument representing a NaN shall be converted in
one of the styles "[-]nan(n-char-sequence)" or "[-]nan"; which style, and the meaning of any
n-char-sequence, is implementation-defined. The F conversion specifier produces "INF",
"INFINITY", or "NAN" instead of "inf", "infinity", or "nan", respectively.
e, E
The double argument shall be converted in the style
"[-]d.ddde±dd", where there is one digit before the radix character (which
is non-zero if the argument is non-zero) and the number of digits after it is equal to the precision; if the precision is missing,
it shall be taken as 6; if the precision is zero and no '#' flag is present, no radix character shall appear. The
low-order digit shall be rounded in an implementation-defined manner. The E conversion specifier shall produce a number
with 'E' instead of 'e' introducing the exponent. The exponent shall always contain at least two digits. If the
value is zero, the exponent shall be zero.
A double argument representing an infinity or NaN shall be converted in the style of an f or F
conversion specifier.
g, G
The double argument representing a floating-point number shall be converted in the style f or e (or in
the style F or E in the case of a G conversion specifier), depending on the value converted and the
precision. Let P equal the precision if non-zero, 6 if the precision is omitted, or 1 if the precision is zero. Then, if a
conversion with style E would have an exponent of X:
If P>X>=-4, the conversion shall be with style f (or F) and precision
P-(X+1).
Otherwise, the conversion shall be with style e (or E) and precision P-1.
Finally, unless the '#' flag is used, any trailing zeros shall be removed from the fractional portion of the result and
the decimal-point character shall be removed if there is no fractional portion remaining.
A double argument representing an infinity or NaN shall be converted in the style of an f or F
conversion specifier.
a, A
A double argument representing a floating-point number shall be converted in the style
"[-]0xh.hhhhp±d", where there is one hexadecimal digit (which shall be
non-zero if the argument is a normalized floating-point number and is otherwise unspecified) before the decimal-point character and
the number of hexadecimal digits after it is equal to the precision; if the precision is missing and FLT_RADIX is a power of 2,
then the precision shall be sufficient for an exact representation of the value; if the precision is missing and FLT_RADIX is not a
power of 2, then the precision shall be sufficient to distinguish values of type double, except that trailing zeros may be
omitted; if the precision is zero and the '#' flag is not specified, no decimal-point character shall appear. The letters
"abcdef" shall be used for a conversion and the letters "ABCDEF" for A conversion. The
A conversion specifier produces a number with 'X' and 'P' instead of 'x' and 'p'. The
exponent shall always contain at least one digit, and only as many more digits as necessary to represent the decimal exponent of 2.
If the value is zero, the exponent shall be zero.
A double argument representing an infinity or NaN shall be converted in the style of an f or F
conversion specifier.
c
The int argument shall be converted to an unsigned char, and the resulting byte shall be written.
If an l (ell) qualifier is present, [CX]   the wint_t argument shall be converted to a multi-byte
sequence as if by a call to wcrtomb() with a pointer to storage of at least
MB_CUR_MAX bytes, the wint_t argument converted to wchar_t, and an initial shift state, and the resulting byte(s)
written.
s
The argument shall be a pointer to an array of char. Bytes from the array shall be written up to (but not including) any
terminating null byte. If the precision is specified, no more than that many bytes shall be written. If the precision is not
specified or is greater than the size of the array, the application shall ensure that the array contains a null byte.
If an l (ell) qualifier is present, the argument shall be a pointer to an array of type wchar_t. Wide characters
from the array shall be converted to characters (each as if by a call to the wcrtomb() function, with the conversion state described by an mbstate_t object
initialized to zero before the first wide character is converted) up to and including a terminating null wide character. The
resulting characters shall be written up to (but not including) the terminating null character (byte). If no precision is
specified, the application shall ensure that the array contains a null wide character. If a precision is specified, no more than
that many characters (bytes) shall be written (including shift sequences, if any), and the array shall contain a null wide
character if, to equal the character sequence length given by the precision, the function would need to access a wide character one
past the end of the array. In no case shall a partial character be written.
p
The argument shall be a pointer to void. The value of the pointer is converted to a sequence of printable characters, in
an implementation-defined manner.
n
The argument shall be a pointer to an integer into which is written the number of bytes written to the output so far by this
call to one of the fprintf() functions. No argument is converted.
C
[XSI]
Equivalent to lc.
S
[XSI]
Equivalent to ls.
%
Write a '%' character; no argument shall be converted. The application shall ensure that the complete conversion
specification is %%.
If a conversion specification does not match one of the above forms, the behavior is undefined. If any argument is not the
correct type for the corresponding conversion specification, the behavior is undefined.
In no case shall a nonexistent or small field width cause truncation of a field; if the result of a conversion is wider than the
field width, the field shall be expanded to contain the conversion result. Characters generated by fprintf() and
printf() are printed as if fputc() had been called.
For the a and A conversion specifiers, if FLT_RADIX is a power of 2, the value shall be correctly rounded to a
hexadecimal floating number with the given precision.
For a and A conversions, if FLT_RADIX is not a power of 2 and the result is not exactly representable in the
given precision, the result should be one of the two adjacent numbers in hexadecimal floating style with the given precision, with
the extra stipulation that the error should have a correct sign for the current rounding direction.
For the e, E, f, F, g, and G conversion specifiers, if the number of
significant decimal digits is at most DECIMAL_DIG, then the result should be correctly rounded. If the number of significant
decimal digits is more than DECIMAL_DIG but the source value is exactly representable with DECIMAL_DIG digits, then the result
should be an exact representation with trailing zeros. Otherwise, the source value is bounded by two adjacent decimal strings
L
#include
#include
#include
char *strperm (mode_t);
...
struct stat statbuf;
struct passwd *pwd;
struct group *grp;
...
printf("%10.10s", strperm (statbuf.st_mode));
printf("%4d", statbuf.st_nlink);
if ((pwd = getpwuid(statbuf.st_uid)) != NULL)
printf(" %-8.8s", pwd->pw_name);
else
printf(" %-8ld", (long) statbuf.st_uid);
if ((grp = getgrgid(statbuf.st_gid)) != NULL)
printf(" %-8.8s", grp->gr_name);
else
printf(" %-8ld", (long) statbuf.st_gid);
printf("%9jd", (intmax_t) statbuf.st_size);
...
Printing a Localized Date String
The following example gets a localized date string. The nl_langinfo()
function shall return the localized date string, which specifies the order and layout of the date. The strftime() function takes this information and, using the tm structure for values,
places the date and time information into datestring. The printf() function then outputs datestring and the
name of the entry.
#include
#include
#include
...
struct dirent *dp;
struct tm *tm;
char datestring[256];
...
strftime(datestring, sizeof(datestring), nl_langinfo (D_T_FMT), tm);
printf(" %s %s\n", datestring, dp->d_name);
...
Printing Error Information
The following example uses fprintf() to write error information to standard error.
In the first group of calls, the program tries to open the password lock file named LOCKFILE. If the file already exists,
this is an error, as indicated by the O_EXCL flag on the open() function. If the call
fails, the program assumes that someone else is updating the password file, and the program exits.
The next group of calls saves a new password file as the current password file by creating a link between LOCKFILE and
the new password file PASSWDFILE.
#include
#include
#include
#include
#include
#include
#include
#include
#define LOCKFILE "/etc/ptmp"
#define PASSWDFILE "/etc/passwd"
...
int pfd;
...
if ((pfd = open(LOCKFILE, O_WRONLY | O_CREAT | O_EXCL,
S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) == -1)
{
fprintf(stderr, "Cannot open /etc/ptmp. Try again later.\n");
exit(1);
}
...
if (link(LOCKFILE,PASSWDFILE) == -1) {
fprintf(stderr, "Link error: %s\n", strerror(errno));
exit(1);
}
...
Printing Usage Information
The following example checks to make sure the program has the necessary arguments, and uses fprintf() to print usage
information if the expected number of arguments is not present.
#include
#include
...
char *Options = "hdbtl";
...
if (argc  ('*') in the format
string; this ensures the correct number of decimal places for the element based on the number of elements requested.
#include
...
long i;
char *keystr;
int elementlen, len;
...
while (len
#include
#include
#include
#include
#include
...
char *pathname;
struct passwd *pw;
size_t len;
...
// digits required for pid_t is number of bits times
// log2(10) = approx 10/33
len = strlen(pw->pw_dir) + 1 + 1+(sizeof(pid_t)*80+32)/33 +
sizeof ".out";
pathname = malloc(len);
if (pathname != NULL)
{
snprintf(pathname, len, "%s/%jd.out", pw->pw_dir,
(intmax_t)getpid());
...
}
Reporting an Event
The following example loops until an event has timed out. The pause() function
waits forever unless it receives a signal. The fprintf() statement should never occur due to the possible return values of
pause().
#include
#include
#include
#include
...
while (!event_complete) {
...
if (pause() != -1 || errno != EINTR)
fprintf(stderr, "pause: unknown error: %s\n", strerror(errno));
}
...
Printing Monetary Information
The following example uses strfmon() to convert a number and store it as a
formatted monetary string named convbuf. If the first number is printed, the program prints the format and the description;
otherwise, it just prints the number.
#include
#include
...
struct tblfmt {
char *format;
char *description;
};
struct tblfmt table[] = {
{ "%n", "default formatting" },
{ "%11n", "right align within an 11 character field" },
{ "%#5n", "aligned columns for values up to 99999" },
{ "%=*#5n", "specify a fill character" },
{ "%=0#5n", "fill characters do not use grouping" },
{ "%^#5n", "disable the grouping separator" },
{ "%^#5.0n", "round off to whole units" },
{ "%^#5.4n", "increase the precision" },
{ "%(#5n", "use an alternative pos/neg style" },
{ "%!(#5n", "disable the currency symbol" },
};
...
float input[3];
int i, j;
char convbuf[100];
...
strfmon(convbuf, sizeof(convbuf), table[i].format, input[j]);
if (j == 0) {
printf("%s  %s      %s\n", table[i].format,
convbuf, table[i].description);
}
else {
printf("    %s\n", convbuf);
}
...
Printing Wide Characters
The following example prints a series of wide characters. Suppose that "L`@`" expands to three bytes:
wchar_t wz [3] = L"@@";       // Zero-terminated
wchar_t wn [3] = L"@@@";      // Unterminated
fprintf (stdout,"%ls", wz);   // Outputs 6 bytes
fprintf (stdout,"%ls", wn);   // Undefined because wn has no terminator
fprintf (stdout,"%4ls", wz);  // Outputs 3 bytes
fprintf (stdout,"%4ls", wn);  // Outputs 3 bytes; no terminator needed
fprintf (stdout,"%9ls", wz);  // Outputs 6 bytes
fprintf (stdout,"%9ls", wn);  // Outputs 9 bytes; no terminator needed
fprintf (stdout,"%10ls", wz); // Outputs 6 bytes
fprintf (stdout,"%10ls", wn); // Undefined because wn has no terminator
In the last line of the example, after processing three characters, nine bytes have been output. The fourth character must then
be examined to determine whether it converts to one byte or more. If it converts to more than one byte, the output is only nine
bytes. Since there is no fourth character in the array, the behavior is undefined.
APPLICATION USAGE
If the application calling fprintf() has any objects of type wint_t or wchar_t, it must also include the
header to have these objects defined.
The space allocated by a successful call to asprintf() should be subsequently freed by a call to free().
RATIONALE
If an implementation detects that there are insufficient arguments for the format, it is recommended that the function should
fail and report an [EINVAL] error.
The behavior specified for the %lc conversion differs slightly from the specification in the ISO C standard, in
that printing the null wide character produces a null byte instead of 0 bytes of output as would be required by a strict reading of
the ISO C standard's direction to behave as if applying the %ls specifier to a wchar_t array whose first
element is the null wide character. Requiring a multi-byte output for every possible wide character, including the null character,
matches historical practice, and provides consistency with %c in fprintf() and with both %c and
%lc in fwprintf(). It is anticipated that a future edition of the
ISO C standard will change to match the behavior specified here.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fputc(), fscanf(), setlocale(), strfmon(), strlcat(), wcrtomb(), wcslcat()
XBD 7. Locale, , ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
Aligned with ISO/IEC 9899:1990/Amendment 1:1995 (E). Specifically, the l (ell) qualifier can now be used with
c and s conversion specifiers.
The snprintf() function is new in Issue 5.
Issue 6
Extensions beyond the ISO C standard are marked.
The normative text is updated to avoid use of the term "must" for application requirements.
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The prototypes for fprintf(), printf(), snprintf(), and sprintf() are updated, and the XSI shading
is removed from snprintf().
The description of snprintf() is aligned with the ISO C standard. Note that this supersedes the snprintf()
description in The Open Group Base Resolution bwg98-006, which changed the behavior from Issue 5.
The DESCRIPTION is updated.
The DESCRIPTION is updated to use the terms "conversion specifier" and "conversion specification" consistently.
ISO/IEC 9899:1999 standard, Technical Corrigendum 1 is incorporated.
An example of printing wide characters is added.
Issue 7
Austin Group Interpretation 1003.1-2001 #161 is applied, updating the DESCRIPTION of the 0 flag.
Austin Group Interpretation 1003.1-2001 #170 is applied.
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #68 (SD5-XSH-ERN-70) is applied, revising the description of g
and G.
SD5-XSH-ERN-174 is applied.
The dprintf() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 1.
Functionality relating to the %n$ form of conversion specification and the  flag is moved from the
XSI option to the Base.
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0163 [302], XSH/TC1-2008/0164 [316], XSH/TC1-2008/0165 [316],
XSH/TC1-2008/0166 [451,291], and XSH/TC1-2008/0167 [14] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0126 [894], XSH/TC2-2008/0127 [557], and XSH/TC2-2008/0128 [936] are
applied.
Issue 8
Austin Group Defect 986 is applied, adding strlcat() and wcslcat() to the SEE ALSO section.
Austin Group Defect 1020 is applied, clarifying that the snprintf() argument n limits the number of bytes written
to s; it is not necessarily the same as the size of s.
Austin Group Defect 1021 is applied, changing "output error" to "error" in the RETURN VALUE section.
Austin Group Defect 1137 is applied, clarifying the use of "%n$" and "*m$" in
conversion specifications.
Austin Group Defect 1205 is applied, changing the description of the % conversion specifier.
Austin Group Defect 1219 is applied, removing the snprintf()-specific [EOVERFLOW] error.
Austin Group Defect 1496 is applied, adding the asprintf() function.
Austin Group Defect 1562 is applied, clarifying that it is the application's responsibility to ensure that the format is a
character string, beginning and ending in its initial shift state, if any.
Austin Group Defect 1647 is applied, changing the description of the c conversion specifier and updating the statement
that this volume of POSIX.1-2024 defers to the ISO C standard so that it excludes the %lc conversion when passed a
null wide character.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/inet_pton.html =====
inet_ntop
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
inet_ntop, inet_pton — convert IPv4 and IPv6 addresses between binary and text form
SYNOPSIS
#include
const char *inet_ntop(int af, const void *restrict src,
char *restrict dst, socklen_t size);
int inet_pton(int af, const char *restrict src, void *restrict dst);
DESCRIPTION
The inet_ntop() function shall convert a numeric address into a text string suitable for presentation. The af
argument shall specify the family of the address. This can be AF_INET [IP6]
or AF_INET6.  The src argument points to a buffer holding an IPv4 address if the af argument is AF_INET,
[IP6]
or an IPv6 address if the af argument is AF_INET6;  the
address needs to be in network byte order. The dst argument points to a buffer where the function stores the resulting text
string; it shall not be NULL. The size argument specifies the size of this buffer, which shall be large enough to hold the
text string (INET_ADDRSTRLEN characters for IPv4, [IP6]   INET6_ADDRSTRLEN characters for IPv6).
The inet_pton() function shall convert an address in its standard text presentation form into its numeric binary form.
The af argument shall specify the family of the address. The AF_INET [IP6]   and AF_INET6
address families shall be supported. The src argument points
to the string being passed in. The dst argument points to a buffer into which the function stores the numeric address; this
shall be large enough to hold the numeric address (32 bits for AF_INET, [IP6]
128 bits for AF_INET6).
If the af argument of inet_pton() is AF_INET, the src string shall be in the standard IPv4 dotted-decimal
form:
ddd.ddd.ddd.ddd
where "ddd" is a one to three digit decimal number between 0 and 255. Leading zeros shall be allowed. The
inet_pton() function does not accept other formats (such as the octal numbers, hexadecimal numbers, and fewer than four
numbers that inet_addr() accepts).
[IP6]
If the af argument of inet_pton() is AF_INET6, the src string shall be in one of the following standard IPv6
text forms:
The preferred form is "x:x:x:x:x:x:x:x", where the 'x's are the hexadecimal values of the eight 16-bit pieces
of the address. Leading zeros in individual fields can be omitted, but there shall be one to four hexadecimal digits in every
field.
A string of contiguous zero fields in the preferred form can be shown as "::". The "::" can only appear once
in an address. Unspecified addresses ("0:0:0:0:0:0:0:0") may be represented simply as "::".
A third form that is sometimes more convenient when dealing with a mixed environment of IPv4 and IPv6 nodes is
"x:x:x:x:x:x:d.d.d.d", where the 'x's are the hexadecimal values of the six high-order 16-bit pieces of the
address, and the 'd's are the decimal values of the four low-order 8-bit pieces of the address (standard IPv4
representation).
Note:
A more extensive description of the standard representations of IPv6 addresses can be found in RFC 4291.
RETURN VALUE
The inet_ntop() function shall return a pointer to the buffer containing the text string if the conversion succeeds, and
NULL otherwise, and set errno to indicate the error.
The inet_pton() function shall return 1 if the conversion succeeds, with the address pointed to by dst in network
byte order. It shall return 0 if the input is not a valid IPv4 dotted-decimal string [IP6]   or a valid
IPv6 address string,  or -1 with errno set to [EAFNOSUPPORT]
if the af argument is unknown.
ERRORS
The inet_ntop() and inet_pton() functions shall fail if:
[EAFNOSUPPORT]
The af argument is invalid.
[ENOSPC]
The size of the inet_ntop() result buffer is inadequate.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
inet_addr()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
IPv6 extensions are marked.
The restrict keyword is added to the inet_ntop() and inet_pton() prototypes for alignment with the
ISO/IEC 9899:1999 standard.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/29 is applied, adding "the address must be in network byte
order" to the end of the fourth sentence of the first paragraph in the DESCRIPTION.
Issue 7
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0178 [777] is applied.
Issue 8
Austin Group Defect 1102 is applied, removing a reference to the inet_addr()
page from the DESCRIPTION.
Austin Group Defect 1573 is applied, clarifying that leading zeros are allowed in the IPv4 dotted-decimal form accepted by
inet_pton().
Austin Group Defect 1685 is applied, updating RFC references.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/casinf.html =====
casin
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
casin, casinf, casinl — complex arc sine functions
SYNOPSIS
#include
double complex casin(double complex z);
float complex casinf(float complex z);
long double complex casinl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex arc sine of z, with branch cuts outside the interval [-1, +1] along the
real axis.
RETURN VALUE
These functions shall return the complex arc sine value, in the range of a strip mathematically unbounded along the imaginary
axis and in the interval [-ℼ/2, +ℼ/2] along the real axis.
[MXC]
casin(conj(iz)), casinf(conjf(iz)), and casinl(conjl(iz)) shall
return exactly the same value as conj(casin(iz)), conjf(casinf(iz)), and
conjl(casinl(iz)), respectively, and casin(-iz), casinf(-iz), and
casinl(-iz) shall return exactly the same value as -casin(iz), -casinf(iz), and
-casinl(iz), respectively, including for the special values of iz below.
If iz is +0 + i0, -i (0 + i0) shall be returned.
If iz is x + iInf where x is positive-signed and finite, -i (+Inf + iℼ/2) shall be
returned.
If iz is x + iNaN where x is finite, -i (NaN + iNaN) shall be returned and the invalid
floating-point exception may be raised.
If iz is +Inf + iy where y is positive-signed and finite, -i (+Inf + i0) shall be
returned.
If iz is +Inf + iInf, -i (+Inf + iℼ/4) shall be returned.
If iz is +Inf + iNaN, -i (+Inf + iNaN) shall be returned.
If iz is NaN + i0, -i (NaN + i0) shall be returned.
If iz is NaN + iy where y is non-zero and finite, -i (NaN + iNaN) shall be returned and the
invalid floating-point exception may be raised.
If iz is NaN + iInf, -i (±Inf + iNaN) shall be returned; the sign of the imaginary part of the
result is unspecified.
If iz is NaN + iNaN, -i (NaN + iNaN) shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The MXC special cases for casin() are derived from those for casinh() by
applying the formula casin(z) = -i casinh(iz).
FUTURE DIRECTIONS
None.
SEE ALSO
casinh(), csin()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sigtimedwait.html =====
sigtimedwait
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sigtimedwait, sigwaitinfo — wait for queued signals
SYNOPSIS
[CX]  #include
int sigtimedwait(const sigset_t *restrict set,
siginfo_t *restrict info,
const struct timespec *restrict timeout);
int sigwaitinfo(const sigset_t *restrict set,
siginfo_t *restrict info);
DESCRIPTION
The sigtimedwait() function shall be equivalent to sigwaitinfo() except that if none of the signals specified by
set are pending, sigtimedwait() shall wait for the time interval specified in the timespec structure
referenced by timeout. If the timespec structure pointed to by timeout is zero-valued and if none of the
signals specified by set are pending, then sigtimedwait() shall return immediately with an error. If timeout
is the null pointer, the behavior is unspecified. The CLOCK_MONOTONIC clock shall be used to measure the time interval specified by
the timeout argument.
The sigwaitinfo() function selects the pending signal from the set specified by set. Should any of multiple
pending signals in the range SIGRTMIN to SIGRTMAX be selected, it shall be the lowest numbered one. The selection order between
realtime and non-realtime signals, or between multiple pending non-realtime signals, is unspecified. If no signal in set is
pending at the time of the call, the calling thread shall be suspended until one or more signals in set become pending or
until it is interrupted by an unblocked, caught signal.
The sigwaitinfo() function shall be equivalent to the sigwait() function,
except that the return value and the error reporting method are different (see RETURN VALUE), and that if the info argument
is non-NULL, the selected signal number shall be stored in the si_signo member, and the cause of the signal shall be stored
in the si_code member. If any value is queued to the selected signal, the first such queued value shall be dequeued and, if
the info argument is non-NULL, the value shall be stored in the si_value member of info. The system resource
used to queue the signal shall be released and returned to the system for other use. If no value is queued, the content of the
si_value member is undefined. If no further signals are queued for the selected signal, the pending indication for that
signal shall be reset.
RETURN VALUE
Upon successful completion (that is, one of the signals specified by set is pending or is generated) sigwaitinfo()
and sigtimedwait() shall return the selected signal number. Otherwise, the function shall return a value of -1 and set
errno to indicate the error.
ERRORS
The sigtimedwait() function shall fail if:
[EAGAIN]
No signal specified by set was generated within the specified timeout period.
The sigtimedwait() and sigwaitinfo() functions may fail if:
[EINTR]
The wait was interrupted by an unblocked, caught signal. It shall be documented in system documentation whether this error
causes these functions to fail.
The sigtimedwait() function may also fail if:
[EINVAL]
The timeout argument specified a tv_nsec value less than zero or greater than or equal to 1000 million.
An implementation should only check for this error if no signal is pending in set and it is necessary to wait.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The sigtimedwait() function times out and returns an [EAGAIN] error. Application developers should note that this is
inconsistent with other functions such as pthread_cond_timedwait()
that return [ETIMEDOUT].
Note that in order to ensure that generated signals are queued and signal values passed to sigqueue() are available in si_value, applications which use sigwaitinfo() or
sigtimedwait() need to set the SA_SIGINFO flag for each signal in the set (see 2.4 Signal Concepts). This means setting each signal to be handled by a
three-argument signal-catching function, even if the handler will never be called. It is not possible (portably) to set a signal
handler to SIG_DFL while setting the SA_SIGINFO flag, because assigning to the sa_handler member of struct sigaction
instead of the sa_sigaction member would result in undefined behavior, and SIG_DFL need not be assignment-compatible with
sa_sigaction. Even if an assignment of SIG_DFL to sa_sigaction is accepted by the compiler, the implementation need
not treat this value as special—it could just be taken as the address of a signal-catching function.
RATIONALE
Existing programming practice on realtime systems uses the ability to pause waiting for a selected set of events and handle the
first event that occurs in-line instead of in a signal-handling function. This allows applications to be written in an
event-directed style similar to a state machine. This style of programming is useful for largescale transaction processing in which
the overall throughput of an application and the ability to clearly track states are more important than the ability to minimize
the response time of individual event handling.
It is possible to construct a signal-waiting macro function out of the realtime signal function mechanism defined in this volume
of POSIX.1-2024. However, such a macro has to include the definition of a generalized handler for all signals to be waited on. A
significant portion of the overhead of handler processing can be avoided if the signal-waiting function is provided by the kernel.
This volume of POSIX.1-2024 therefore provides two signal-waiting functions—one that waits indefinitely and one with a timeout—as
part of the overall realtime signal function specification.
The specification of a function with a timeout allows an application to be written that can be broken out of a wait after a set
period of time if no event has occurred. It was argued that setting a timer event before the wait and recognizing the timer event
in the wait would also implement the same functionality, but at a lower performance level. Because of the performance degradation
associated with the user-level specification of a timer event and the subsequent cancellation of that timer event after the wait
completes for a valid event, and the complexity associated with handling potential race conditions associated with the user-level
method, the separate function has been included.
Note that the semantics of the sigwaitinfo() function are nearly identical to that of the sigwait() function defined by this volume of POSIX.1-2024. The only difference is that
sigwaitinfo() returns the queued signal value in the value argument. The return of the queued value is required so
that applications can differentiate between multiple events queued to the same signal number.
The two distinct functions are being maintained because some implementations may choose to implement the POSIX Threads Extension
functions and not implement the queued signals extensions. Note, though, that sigwaitinfo() does not return the queued value
if the value argument is NULL, so the POSIX Threads Extension sigwait()
function can be implemented as a macro on sigwaitinfo().
The sigtimedwait() function was separated from the sigwaitinfo() function to address concerns regarding the
overloading of the timeout pointer to indicate indefinite wait (no timeout), timed wait, and immediate return, and concerns
regarding consistency with other functions where the conditional and timed waits were separate functions from the pure blocking
function. The semantics of sigtimedwait() are specified such that sigwaitinfo() could be implemented as a macro with
a null pointer for timeout.
The sigwait functions provide a synchronous mechanism for threads to wait for asynchronously-generated signals. One
important question was how many threads that are suspended in a call to a sigwait()
function for a signal should return from the call when the signal is sent. Four choices were considered:
Return an error for multiple simultaneous calls to sigwait functions for the same signal.
One or more threads return.
All waiting threads return.
Exactly one thread returns.
Prohibiting multiple calls to sigwait() for the same signal was felt to be overly
restrictive. The "one or more" behavior made implementation of conforming packages easy at the expense of forcing POSIX threads
clients to protect against multiple simultaneous calls to sigwait() in application
code in order to achieve predictable behavior. There was concern that the "all waiting threads" behavior would result in "signal
broadcast storms", consuming excessive CPU resources by replicating the signals in the general case. Furthermore, no convincing
examples could be presented that delivery to all was either simpler or more powerful than delivery to one.
Thus, the consensus was that exactly one thread that was suspended in a call to a sigwait function for a signal should
return when that signal occurs. This is not an onerous restriction as:
A multi-way signal wait can be built from the single-way wait.
Signals should only be handled by application-level code, as library routines cannot guess what the application wants to do with
signals generated for the entire process.
Applications can thus arrange for a single thread to wait for any given signal and call any needed routines upon its
arrival.
In an application that is using signals for interprocess communication, signal processing is typically done in one place.
Alternatively, if the signal is being caught so that process cleanup can be done, the signal handler thread can call separate
process cleanup routines for each portion of the application. Since the application main line started each portion of the
application, it is at the right abstraction level to tell each portion of the application to clean up.
Certainly, there exist programming styles where it is logical to consider waiting for a single signal in multiple threads. A
simple sigwait_multiple() routine can be constructed to achieve this goal. A possible implementation would be to have each
sigwait_multiple() caller registered as having expressed interest in a set of signals. The caller then waits on a
thread-specific condition variable. A single server thread calls a sigwait()
function on the union of all registered signals. When the sigwait() function
returns, the appropriate state is set and condition variables are broadcast. New sigwait_multiple() callers may cause the
pending sigwait() call to be canceled and reissued in order to update the set of
signals being waited for.
FUTURE DIRECTIONS
None.
SEE ALSO
2.4 Signal Concepts, 2.8.1 Realtime Signals, pause(), pthread_sigmask(),
sigaction(), sigpending(),
sigsuspend(), sigwait()
XBD ,
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension and the POSIX Threads Extension.
Issue 6
These functions are marked as part of the Realtime Signals Extension option.
The Open Group Corrigendum U035/3 is applied. The SYNOPSIS of the sigwaitinfo() function has been corrected so that the
second argument is of type siginfo_t *.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Realtime
Signals Extension option.
The DESCRIPTION is updated for alignment with IEEE Std 1003.1j-2000 by specifying that the CLOCK_MONOTONIC clock, if
supported, is used to measure timeout intervals.
The restrict keyword is added to the sigtimedwait() and sigwaitinfo() prototypes for alignment with the
ISO/IEC 9899:1999 standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/130 is applied, restoring wording in the RETURN VALUE section to
that in the original base document ("An implementation should only check for this error if no signal is pending in set and
it is necessary to wait").
Issue 7
The sigtimedwait() and sigwaitinfo() functions are moved from the Realtime Signals Extension option to the
Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0583 [392] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0333 [815] is applied.
Issue 8
Austin Group Defect 1346 is applied, requiring support for Monotonic Clock.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sched_setparam.html =====
sched_setparam
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sched_setparam — set scheduling parameters (REALTIME)
SYNOPSIS
[PS]  #include
int sched_setparam(pid_t pid, const struct sched_param *param);
DESCRIPTION
The sched_setparam() function shall set the scheduling parameters of the process specified by pid to the values
specified by the sched_param structure pointed to by param. The value of the sched_priority member in the
sched_param structure shall be any integer within the inclusive priority range for the current scheduling policy of the
process specified by pid. Higher numerical values for the priority represent higher priorities. If the value of pid
is negative, the behavior of the sched_setparam() function is unspecified.
If a process specified by pid exists, and if the calling process has permission, the scheduling parameters shall be set
for the process whose process ID is equal to pid.
If pid is zero, the scheduling parameters shall be set for the calling process.
The conditions under which one process has permission to change the scheduling parameters of another process are
implementation-defined.
Implementations may require the requesting process to have appropriate privileges to set its own scheduling parameters or those
of another process.
See Scheduling Policies for a description on how this function
affects the scheduling of the threads within the target process.
If the current scheduling policy for the target process is not SCHED_FIFO, SCHED_RR, [SS]  or SCHED_SPORADIC,
the result is implementation-defined; this case includes the
SCHED_OTHER policy.
[SS]  The
specified sched_ss_repl_period shall be greater than or equal to the specified sched_ss_init_budget for the function
to succeed; if it is not, then the function shall fail.
The value of sched_ss_max_repl shall be within the inclusive range [1,{SS_REPL_MAX}] for the function to succeed; if not,
the function shall fail. It is unspecified whether the sched_ss_repl_period and sched_ss_init_budget values are
stored as provided by this function or are rounded to align with the resolution of the clock being used.
This function is not atomic with respect to other threads in the process. Threads may continue to execute while this function
call is in the process of changing the scheduling policy for the underlying kernel-scheduled entities used by the process
contention scope threads.
RETURN VALUE
If successful, the sched_setparam() function shall return zero.
If the call to sched_setparam() is unsuccessful, the priority shall remain unchanged, and the function shall return a
value of -1 and set errno to indicate the error.
ERRORS
The sched_setparam() function shall fail if:
[EINVAL]
One or more of the requested scheduling parameters is outside the range defined for the scheduling policy of the specified
pid.
[EPERM]
The requesting process does not have permission to set the scheduling parameters for the specified process, or does not have
appropriate privileges to invoke sched_setparam().
[ESRCH]
No process can be found corresponding to that specified by pid.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
Scheduling Policies, sched_getparam(), sched_getscheduler(), sched_setscheduler()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The sched_setparam() function is marked as part of the Process Scheduling option.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Process
Scheduling option.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the DESCRIPTION, the effect of this function on a thread's scheduling parameters is added.
Sections describing two-level scheduling and atomicity of the function are added.
The SCHED_SPORADIC scheduling policy is added for alignment with IEEE Std 1003.1d-1999.
IEEE PASC Interpretation 1003.1 #100 is applied.
Issue 7
Austin Group Interpretation 1003.1-2001 #061 is applied, updating the DESCRIPTION.
Austin Group Interpretation 1003.1-2001 #119 is applied, clarifying the accuracy requirements for the
sched_ss_repl_period and sched_ss_init_budget values.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/creal.html =====
creal
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
creal, crealf, creall — complex real functions
SYNOPSIS
#include
double creal(double complex z);
float crealf(float complex z);
long double creall(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the real part of z.
RETURN VALUE
These functions shall return the real part value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
For a variable z of type complex:
z == creal(z) + cimag(z)*I
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
carg(), cimag(), conj(), cproj()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sem_open.html =====
sem_open
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sem_open — initialize and open a named semaphore
SYNOPSIS
#include
sem_t *sem_open(const char *name, int oflag, ...);
DESCRIPTION
The sem_open() function shall establish a connection between a named semaphore and a process. A named semaphore may be
implemented using a file descriptor. Following a call to sem_open() with semaphore name name, the process may
reference the semaphore associated with name using the semaphore handle returned from the call. This semaphore can be used
in subsequent calls to sem_clockwait(), sem_close(), sem_post(), sem_timedwait(), sem_trywait(), and
sem_wait(). The semaphore remains usable by this process until the semaphore is
closed by a successful call to sem_close(), _exit(), or one of the exec functions.
The oflag argument controls whether the semaphore is created or merely accessed by the call to sem_open(). The
following flag bits may be set in oflag:
O_CREAT
This flag is used to create a semaphore if it does not already exist. If O_CREAT is set and the semaphore already exists, then
O_CREAT has no effect, except as noted under O_EXCL. Otherwise, sem_open() creates a named semaphore. The O_CREAT flag
requires a third and a fourth argument: mode, which is of type mode_t, and value, which is of type
unsigned. The semaphore is created with an initial value of value. Valid initial values for semaphores are less than
or equal to {SEM_VALUE_MAX}.
The user ID of the semaphore shall be set to the effective user ID of the process. The group ID of the semaphore shall be set to
the effective group ID of the process; however, if the name argument is visible in the file system, the group ID may be set
to the group ID of the containing directory. The permission bits of the semaphore are set to the value of the mode argument
except those set in the file mode creation mask of the process. When bits in mode other than the file permission bits are
specified, the effect is unspecified.
After the semaphore named name has been created by sem_open() with the O_CREAT flag, other processes can connect
to the semaphore by calling sem_open() with the same value of name.
O_EXCL
If O_EXCL and O_CREAT are set, sem_open() fails if the semaphore name exists. The check for the existence of the
semaphore and the creation of the semaphore if it does not exist are atomic with respect to other processes executing
sem_open() with O_EXCL and O_CREAT set. If O_EXCL is set and O_CREAT is not set, the effect is undefined.
If flags other than O_CREAT and O_EXCL are specified in the oflag parameter, the effect is unspecified.
The name argument points to a string naming a semaphore object. It is unspecified whether the name appears in the file
system and is visible to functions that take pathnames as arguments. The name argument conforms to the construction rules
for a pathname, except that the interpretation of  characters other than the leading  character in
name is implementation-defined, and that the length limits for the name argument are implementation-defined and need
not be the same as the pathname limits {PATH_MAX} and {NAME_MAX}. If name begins with the  character, then
processes calling sem_open() with the same value of name shall refer to the same semaphore object, as long as that
name has not been removed. If name does not begin with the  character, the effect is
implementation-defined.
If a process makes multiple successful calls to sem_open() with the same value for name, there have been no
intervening calls to sem_unlink() for name, and at least one open handle
for this semaphore has not been closed with a sem_close() call, it is
implementation-defined whether the same handle or a unique handle is returned for each such successful call.
References to copies of the semaphore produce undefined results.
RETURN VALUE
Upon successful completion, the sem_open() function shall return the address of the semaphore. Otherwise, it shall return
a value of SEM_FAILED and set errno to indicate the error. The symbol SEM_FAILED is defined in the  header. No successful return from sem_open() shall return the
value SEM_FAILED.
ERRORS
If any of the following conditions occur, the sem_open() function shall return SEM_FAILED and set errno to the
corresponding value:
[EACCES]
The named semaphore exists and the permissions specified by oflag are denied, or the named semaphore does not exist and
permission to create the named semaphore is denied.
[EEXIST]
O_CREAT and O_EXCL are set and the named semaphore already exists.
[EINTR]
The sem_open() operation was interrupted by a signal.
[EINVAL]
The sem_open() operation is not supported for the given name, or O_CREAT was specified in oflag and value
was greater than {SEM_VALUE_MAX}.
[ENOENT]
O_CREAT is not set and the named semaphore does not exist.
[ENOMEM]
There is insufficient memory for the creation of the new named semaphore.
[ENOSPC]
There is insufficient space on a storage device for the creation of the new named semaphore.
If any of the following conditions occur, the sem_open() function may return SEM_FAILED and set errno to the
corresponding value:
[EMFILE]
Too many semaphore descriptors or file descriptors are currently in use by this process.
[ENAMETOOLONG]
The length of the name argument exceeds {_POSIX_PATH_MAX} on systems that do not support the XSI option [XSI]   or exceeds
{_XOPEN_PATH_MAX} on XSI systems,   or has a pathname component
that is longer than {_POSIX_NAME_MAX} on systems that do not support the XSI option [XSI]   or longer
than {_XOPEN_NAME_MAX} on XSI systems.
[ENFILE]
Too many semaphore descriptors or file descriptors are currently open in the system.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
Early drafts required an error return value of -1 with the type sem_t * for the sem_open() function, which is not
guaranteed to be portable across implementations. The revised text provides the symbolic error code SEM_FAILED to eliminate the
type conflict.
FUTURE DIRECTIONS
A future version might require the sem_open() and sem_unlink()
functions to have semantics similar to normal file system operations.
SEE ALSO
semctl(), semget(), semop(), sem_clockwait(), sem_close(), sem_post(), sem_trywait(), sem_unlink()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The sem_open() function is marked as part of the Semaphores option.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Semaphores
option.
The sem_timedwait() function is added to the SEE ALSO section for alignment
with IEEE Std 1003.1d-1999.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/117 is applied, updating the DESCRIPTION to add the sem_timedwait() function for alignment with IEEE Std 1003.1d-1999.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/118 is applied, updating the DESCRIPTION to describe the
conditions to return the same semaphore address on a call to sem_open(). The words "and at least one previous successful
sem_open() call for this semaphore has not been matched with a sem_close()
call" are added.
Issue 7
Austin Group Interpretation 1003.1-2001 #066 is applied, updating the [ENOSPC] error case and adding the [ENOMEM] error
case.
Austin Group Interpretation 1003.1-2001 #077 is applied, clarifying the name argument and adding [ENAMETOOLONG] as a
"may fail" error.
Austin Group Interpretation 1003.1-2001 #141 is applied, adding FUTURE DIRECTIONS.
SD5-XSH-ERN-170 is applied, updating the DESCRIPTION to clarify the wording for setting the user ID and group ID of the
semaphore.
The sem_open() function is moved from the Semaphores option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0527 [37] is applied.
Issue 8
Austin Group Defect 368 is applied, adding a statement that a named semaphore may be implemented using a file descriptor and
changing the ERRORS section.
Austin Group Defect 1216 is applied, adding sem_clockwait().
Austin Group Defect 1324 is applied, making it implementation-defined whether the same handle or a unique handle is returned
when multiple successful calls to sem_open() are made with the same value for name.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ccosl.html =====
ccos
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ccos, ccosf, ccosl — complex cosine functions
SYNOPSIS
#include
double complex ccos(double complex z);
float complex ccosf(float complex z);
long double complex ccosl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex cosine of z.
RETURN VALUE
These functions shall return the complex cosine value.
[MXC]
ccos(conj(iz)), ccosf(conjf(iz)), and ccosl(conjl(iz)) shall return
exactly the same value as conj(ccos(iz)), conjf(ccosf(iz)), and
conjl(ccosl(iz)), respectively, and ccos(-iz), ccosf(-iz), and
ccosl(-iz) shall return exactly the same value as ccos(iz), ccosf(iz), and
ccosl(iz), respectively, including for the special values of iz below.
If iz is +0 + i0, 1 + i0 shall be returned.
If iz is +0 + iInf, NaN ± i0 shall be returned and the invalid floating-point exception shall be raised;
the sign of the imaginary part of the result is unspecified.
If iz is +0 + iNaN, NaN ± i0 shall be returned; the sign of the imaginary part of the result is
unspecified.
If iz is x + iInf where x is non-zero and finite, NaN + iNaN shall be returned and the
invalid floating-point exception shall be raised.
If iz is x + iNaN where x is non-zero and finite, NaN + iNaN shall be returned and the
invalid floating-point exception may be raised.
If iz is +Inf + i0, +Inf + i0 shall be returned.
If iz is +Inf + iy where y is non-zero and finite, +Inf (cos(y) + isin(y))
shall be returned.
If iz is +Inf + iInf, ±Inf + iNaN shall be returned and the invalid floating-point exception shall be
raised; the sign of the real part of the result is unspecified.
If iz is +Inf + iNaN, +Inf + iNaN shall be returned.
If iz is NaN + i0, NaN ± i0 shall be returned; the sign of the imaginary part of the result is
unspecified.
If iz is NaN + iy where y is any non-zero number, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If iz is NaN + iNaN, NaN + iNaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The MXC special cases for ccos() are derived from those for ccosh() by
applying the formula ccos(z) = ccosh(iz).
FUTURE DIRECTIONS
None.
SEE ALSO
ccosh(), cacos()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_mutexattr_getprotocol.html =====
pthread_mutexattr_getprotocol
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_mutexattr_getprotocol, pthread_mutexattr_setprotocol — get and set the protocol attribute of the mutex
attributes object (REALTIME THREADS)
SYNOPSIS
[MC1]  #include
int pthread_mutexattr_getprotocol(const pthread_mutexattr_t
*restrict attr, int *restrict protocol);
int pthread_mutexattr_setprotocol(pthread_mutexattr_t *attr,
int protocol);
DESCRIPTION
The pthread_mutexattr_getprotocol() and pthread_mutexattr_setprotocol() functions, respectively, shall get and set
the protocol attribute of a mutex attributes object pointed to by attr which was previously created by the function pthread_mutexattr_init().
The protocol attribute defines the protocol to be followed in utilizing mutexes. The value of protocol may be one
of:
[RPI|TPI]
PTHREAD_PRIO_INHERIT
[MC1]
PTHREAD_PRIO_NONE
[RPP|TPP]
PTHREAD_PRIO_PROTECT
which are defined in the  header. The default value of the
attribute shall be PTHREAD_PRIO_NONE.
When a thread owns a mutex with the PTHREAD_PRIO_NONE protocol attribute, its priority and scheduling shall not be
affected by its mutex ownership.
[RPI]
When a thread is blocking higher priority threads because of owning one or more robust mutexes with the PTHREAD_PRIO_INHERIT
protocol attribute, it shall execute at the higher of its priority or the priority of the highest priority thread waiting on
any of the robust mutexes owned by this thread and initialized with this protocol.
[TPI]
When a thread is blocking higher priority threads because of owning one or more non-robust mutexes with the PTHREAD_PRIO_INHERIT
protocol attribute, it shall execute at the higher of its priority or the priority of the highest priority thread waiting on
any of the non-robust mutexes owned by this thread and initialized with this protocol.
[RPP]
When a thread owns one or more robust mutexes initialized with the PTHREAD_PRIO_PROTECT protocol, it shall execute at the higher of
its priority or the highest of the priority ceilings of all the robust mutexes owned by this thread and initialized with this
attribute, regardless of whether other threads are blocked on any of these robust mutexes or not.
[TPP]
When a thread owns one or more non-robust mutexes initialized with the PTHREAD_PRIO_PROTECT protocol, it shall execute at the
higher of its priority or the highest of the priority ceilings of all the non-robust mutexes owned by this thread and initialized
with this attribute, regardless of whether other threads are blocked on any of these non-robust mutexes or not.
If a thread simultaneously owns several mutexes initialized with different protocols, it shall execute at the highest of the
priorities that it would have obtained by each of these protocols.
[RPI|TPI]  When a thread makes a call to pthread_mutex_lock(), the mutex was
initialized with the protocol attribute having the value PTHREAD_PRIO_INHERIT, when the calling thread is blocked because the mutex
is owned by another thread, that owner thread shall inherit the priority level of the calling thread as long as it continues to own
the mutex. The implementation shall update its execution priority to the maximum of its assigned priority and all its inherited
priorities. Furthermore, if this owner thread itself becomes blocked on another mutex with the protocol attribute having the
value PTHREAD_PRIO_INHERIT, the same priority inheritance effect shall be propagated to this other owner thread, in a recursive
manner.
The behavior is undefined if the value specified by the attr argument to pthread_mutexattr_getprotocol() or
pthread_mutexattr_setprotocol() does not refer to an initialized mutex attributes object.
RETURN VALUE
Upon successful completion, the pthread_mutexattr_getprotocol() and pthread_mutexattr_setprotocol() functions
shall return zero; otherwise, an error number shall be returned to indicate the error.
ERRORS
The pthread_mutexattr_setprotocol() function shall fail if:
[ENOTSUP]
The value specified by protocol is an unsupported value.
The pthread_mutexattr_getprotocol() and pthread_mutexattr_setprotocol() functions may fail if:
[EINVAL]
The value specified by protocol is invalid.
[EPERM]
The caller does not have the privilege to perform the operation.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
If an implementation detects that the value specified by the attr argument to pthread_mutexattr_getprotocol() or
pthread_mutexattr_setprotocol() does not refer to an initialized mutex attributes object, it is recommended that the
function should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_cond_destroy(), pthread_create(), pthread_mutex_destroy()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Marked as part of the Realtime Threads Feature Group.
Issue 6
The pthread_mutexattr_getprotocol() and pthread_mutexattr_setprotocol() functions are marked as part of the
Threads option and either the Thread Priority Protection or Thread Priority Inheritance options.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Thread
Priority Protection or Thread Priority Inheritance options.
The restrict keyword is added to the pthread_mutexattr_getprotocol() prototype for alignment with the
ISO/IEC 9899:1999 standard.
Issue 7
SD5-XSH-ERN-135 is applied, updating the DESCRIPTION to define a default value for the protocol attribute.
SD5-XSH-ERN-188 is applied, updating the DESCRIPTION.
The pthread_mutexattr_getprotocol() and pthread_mutexattr_setprotocol() functions are moved from the Threads
option to require support of either the Non-Robust Mutex Priority Protection option or the Non-Robust Mutex Priority Inheritance
option or the Robust Mutex Priority Protection option or the Robust Mutex Priority Inheritance option.
The [EINVAL] error for an uninitialized mutex attributes object is removed; this condition results in undefined behavior.
Issue 8
Austin Group Defect 1610 is applied, moving text relating to the effects of PTHREAD_PRIO_INHERIT and PTHREAD_PRIO_PROTECT on
scheduling queues to Scheduling Policies.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/msgrcv.html =====
msgrcv
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
msgrcv — XSI message receive operation
SYNOPSIS
[XSI]  #include
ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long
msgtyp,
int msgflg);
DESCRIPTION
The msgrcv() function operates on XSI message queues (see XBD 3.206
Message Queue). It is unspecified whether this function interoperates with the realtime interprocess communication
facilities defined in 2.8 Realtime.
The msgrcv() function shall read a message from the queue associated with the message queue identifier specified by
msqid and place it in the user-defined buffer pointed to by msgp.
The application shall ensure that the argument msgp points to a user-defined buffer that contains first a field of type
long specifying the type of the message, and then a data portion that holds the data bytes of the message. The structure
below is an example of what this user-defined buffer might look like:
struct mymsg {
long    mtype;     /* Message type. */
char    mtext[1];  /* Message text. */
}
The structure member mtype is the received message's type as specified by the sending process.
The structure member mtext is the text of the message.
The argument msgsz specifies the size in bytes of mtext. The received message shall be truncated to msgsz
bytes if it is larger than msgsz and (msgflg & MSG_NOERROR) is non-zero. The truncated part of the message shall be
lost and no indication of the truncation shall be given to the calling process.
If the value of msgsz is greater than {SSIZE_MAX}, the result is implementation-defined.
The argument msgtyp specifies the type of message requested as follows:
If msgtyp is 0, the first message on the queue shall be received.
If msgtyp is greater than 0, the first message of type msgtyp shall be received.
If msgtyp is less than 0, the first message of the lowest type that is less than or equal to the absolute value of
msgtyp shall be received.
The argument msgflg specifies the action to be taken if a message of the desired type is not on the queue. These are as
follows:
If (msgflg & IPC_NOWAIT) is non-zero, the calling thread shall return immediately with a return value of -1 and
errno set to [ENOMSG].
If (msgflg & IPC_NOWAIT) is 0, the calling thread shall suspend execution until one of the following occurs:
A message of the desired type is placed on the queue.
The message queue identifier msqid is removed from the system; when this occurs, errno shall be set to [EIDRM] and
-1 shall be returned.
The calling thread receives a signal that is to be caught; in this case a message is not received and the calling thread resumes
execution in the manner prescribed in sigaction().
Upon successful completion, the following actions are taken with respect to the data structure associated with msqid:
msg_qnum shall be decremented by 1.
msg_lrpid shall be set to the process ID of the calling process.
msg_rtime shall be set to the current time, as described in 2.7.1
IPC General Description.
RETURN VALUE
Upon successful completion, msgrcv() shall return a value equal to the number of bytes actually placed into the buffer
mtext. Otherwise, no message shall be received, msgrcv() shall return -1, and errno shall be set to indicate
the error.
ERRORS
The msgrcv() function shall fail if:
[E2BIG]
The value of mtext is greater than msgsz and (msgflg & MSG_NOERROR) is 0.
[EACCES]
Operation permission is denied to the calling process; see 2.7 XSI
Interprocess Communication.
[EIDRM]
The message queue identifier msqid is removed from the system.
[EINTR]
The msgrcv() function was interrupted by a signal.
[EINVAL]
msqid is not a valid message queue identifier.
[ENOMSG]
The queue does not contain a message of the desired type and (msgflg & IPC_NOWAIT) is non-zero.
The following sections are informative.
EXAMPLES
Receiving a Message
The following example receives the first message on the queue (based on the value of the msgtyp argument, 0). The queue
is identified by the msqid argument (assuming that the value has previously been set). This call specifies that an error
should be reported if no message is available, but not if the message is too large. The message size is calculated directly using
the sizeof operator.
#include
...
int result;
int msqid;
struct message {
long type;
char text[20];
} msg;
long msgtyp = 0;
...
result = msgrcv(msqid, (void *) &msg, sizeof(msg.text),
msgtyp, MSG_NOERROR | IPC_NOWAIT);
APPLICATION USAGE
The POSIX Realtime Extension defines alternative interfaces for interprocess communication (IPC). Application developers who
need to use IPC should design their applications so that modules using the IPC routines described in 2.7 XSI Interprocess Communication can be easily modified to use the alternative
interfaces.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.7 XSI Interprocess Communication, 2.8 Realtime, mq_close(),
mq_getattr(), mq_notify(),
mq_open(), mq_receive(),
mq_send(), mq_setattr(),
mq_unlink(), msgctl(), msgget(), msgsnd(), sigaction()
XBD 3.206 Message Queue,
CHANGE HISTORY
First released in Issue 2. Derived from Issue 2 of the SVID.
Issue 5
The type of the return value is changed from int to ssize_t, and a warning is added to the DESCRIPTION about
values of msgsz larger the {SSIZE_MAX}.
The note about use of POSIX Realtime Extension IPC routines has been moved from FUTURE DIRECTIONS to the APPLICATION USAGE
section.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0398 [345] and XSH/TC1-2008/0399 [421] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mq_send.html =====
mq_send
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mq_send, mq_timedsend — send a message to a message queue (REALTIME)
SYNOPSIS
[MSG]  #include
int mq_send(mqd_t mqdes, const char *msg_ptr, size_t msg_len,
unsigned msg_prio);
int mq_timedsend(mqd_t mqdes, const char *msg_ptr, size_t msg_len,
unsigned msg_prio, const struct timespec *abstime);
DESCRIPTION
The mq_send() function shall add the message pointed to by the argument msg_ptr to the message queue specified by
mqdes. The msg_len argument specifies the length of the message, in bytes, pointed to by msg_ptr. The value of
msg_len shall be less than or equal to the mq_msgsize attribute of the message queue, or mq_send() shall
fail.
If the specified message queue is not full, mq_send() shall behave as if the message is inserted into the message queue
at the position indicated by the msg_prio argument. A message with a larger numeric value of msg_prio shall be
inserted before messages with lower values of msg_prio. A message shall be inserted after other messages in the queue, if
any, with equal msg_prio. The value of msg_prio shall be less than {MQ_PRIO_MAX}.
If the specified message queue is full and O_NONBLOCK is not set in the message queue description associated with mqdes,
mq_send() shall block until space becomes available to enqueue the message, or until mq_send() is interrupted by a
signal. If more than one thread is waiting to send when space becomes available in the message queue and the Priority Scheduling
option is supported, then the thread of the highest priority that has been waiting the longest shall be unblocked to send its
message. Otherwise, it is unspecified which waiting thread is unblocked. If the specified message queue is full and O_NONBLOCK is
set in the message queue description associated with mqdes, the message shall not be queued and mq_send() shall
return an error.
The mq_timedsend() function shall add a message to the message queue specified by mqdes in the manner defined for
the mq_send() function. However, if the specified message queue is full and O_NONBLOCK is not set in the message queue
description associated with mqdes, the wait for sufficient room in the queue shall be terminated when the specified timeout
expires. If O_NONBLOCK is set in the message queue description, this function shall be equivalent to mq_send().
The timeout shall expire when the absolute time specified by abstime passes, as measured by the clock on which timeouts
are based (that is, when the value of that clock equals or exceeds abstime), or if the absolute time specified by
abstime has already been passed at the time of the call.
The timeout shall be based on the CLOCK_REALTIME clock. The resolution of the timeout shall be the resolution of the clock on
which it is based.
Under no circumstance shall the operation fail with a timeout if there is sufficient room in the queue to add the message
immediately. The validity of the abstime parameter need not be checked when there is sufficient room in the queue.
RETURN VALUE
Upon successful completion, the mq_send() and mq_timedsend() functions shall return a value of zero. Otherwise, no
message shall be enqueued, the functions shall return -1, and errno shall be set to indicate the error.
ERRORS
The mq_send() and mq_timedsend() functions shall fail if:
[EAGAIN]
The O_NONBLOCK flag is set in the message queue description associated with mqdes, and the specified message queue is
full.
[EBADF]
The mqdes argument is not a valid message queue descriptor open for writing.
[EINTR]
A signal interrupted the call to mq_send() or mq_timedsend().
[EINVAL]
The value of msg_prio was outside the valid range.
[EINVAL]
The process or thread would have blocked, and the abstime parameter specified a nanoseconds field value less than zero
or greater than or equal to 1000 million.
[EMSGSIZE]
The specified message length, msg_len, exceeds the message size attribute of the message queue.
[ETIMEDOUT]
The O_NONBLOCK flag was not set when the message queue was opened, but the timeout expired before the message could be added to
the queue.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The value of the symbol {MQ_PRIO_MAX} limits the number of priority levels supported by the application. Message priorities
range from 0 to {MQ_PRIO_MAX}-1.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
mq_open(), mq_receive(),
mq_setattr(), time()
XBD ,
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The mq_send() function is marked as part of the Message Passing option.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Message
Passing option.
The mq_timedsend() function is added for alignment with IEEE Std 1003.1d-1999.
Issue 7
The mq_timedsend() function is moved from the Timeouts option to the Base.
Functionality relating to the Timers option is moved to the Base.
Issue 8
Austin Group Defect 592 is applied, removing text relating to  from
the SYNOPSIS and DESCRIPTION sections.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/lldiv.html =====
ldiv
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ldiv, lldiv — compute quotient and remainder of a long division
SYNOPSIS
#include
ldiv_t ldiv(long numer, long denom);
lldiv_t lldiv(long long numer, long long denom);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the quotient and remainder of the division of the numerator numer by the denominator
denom. If the division is inexact, the resulting quotient is the long integer (for the ldiv() function) or
long long integer (for the lldiv() function) of lesser magnitude that is the nearest to the algebraic quotient. If
the result cannot be represented, the behavior is undefined; otherwise, quot * denom+rem shall equal
numer.
RETURN VALUE
The ldiv() function shall return a structure of type ldiv_t, comprising both the quotient and the remainder. The
structure shall include the following members, in any order:
long   quot;    /* Quotient */
long   rem;     /* Remainder */
The lldiv() function shall return a structure of type lldiv_t, comprising both the quotient and the remainder. The
structure shall include the following members, in any order:
long long   quot;    /* Quotient */
long long   rem;     /* Remainder */
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
div()
XBD
CHANGE HISTORY
First released in Issue 4. Derived from the ISO C standard.
Issue 6
The lldiv() function is added for alignment with the ISO/IEC 9899:1999 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ptsname.html =====
ptsname
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ptsname, ptsname_r — get name of the subsidiary pseudo-terminal device
SYNOPSIS
[XSI]  #include
char *ptsname(int fildes);
int ptsname_r(int fildes, char *name, size_t namesize);
DESCRIPTION
The ptsname() function shall return the name of the subsidiary pseudo-terminal device associated with a manager
pseudo-terminal device. The fildes argument is a file descriptor that refers to the manager device. The ptsname()
function shall return a pointer to a string containing the pathname of the corresponding subsidiary device.
The ptsname() function need not be thread-safe.
The ptsname_r() function shall store the name of the subsidiary pseudo-terminal device corresponding to fildes in
the character array referenced by name. The array is namesize characters long and should have space for the name and
the terminating null character. The maximum length of the terminal name shall be {TTY_NAME_MAX}.
RETURN VALUE
Upon successful completion, ptsname() shall return a pointer to a string which is the name of the pseudo-terminal
subsidiary device. Upon failure, ptsname() shall return a null pointer and may set errno. This could occur if
fildes is an invalid file descriptor or if the subsidiary device name does not exist in the file system.
The application shall not modify the string returned. The returned pointer might be invalidated or the string content might be
overwritten by a subsequent call to ptsname(). The returned pointer and the string content might also be invalidated if the
calling thread is terminated.
If successful, the ptsname_r() function shall return zero. Otherwise, an error number shall be returned to indicate the
error.
ERRORS
The ptsname_r() function shall fail if:
[EBADF]
The fildes argument is not a valid file descriptor.
[EINVAL]
The name argument is a null pointer.
[ERANGE]
The value of namesize is smaller than the length of the string to be returned including the terminating null
character.
The ptsname() function may fail if:
[EBADF]
The fildes argument is not a valid file descriptor.
The ptsname() and ptsname_r() functions may fail if:
[EINVAL] or [ENOTTY]
The file associated with the fildes argument is not a manager pseudo-terminal device.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The ptsname_r() function is required to make it possible for a multi-threaded program to safely determine the name of a
subsidiary device. Although the name of the device is constrained by {TTY_NAME_MAX}, this value might not be a compile-time
constant, so an application can rely on repeated calls with successively larger buffers until the result is no longer [ERANGE] as
an alternative for properly sizing the buffer.
Historically, some versions of ptsname() did not set errno even when returning a null pointer. However,
ptsname_r() is required to either populate the buffer with a valid name or return an error value.
See also the RATIONALE section for posix_openpt().
FUTURE DIRECTIONS
None.
SEE ALSO
grantpt(), open(), posix_openpt(), ttyname(), unlockpt()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
A note indicating that this function need not be reentrant is added to the DESCRIPTION.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0468 [75] and XSH/TC1-2008/0469 [96] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0298 [503], XSH/TC2-2008/0299 [656], and XSH/TC2-2008/0300 [503] are
applied.
Issue 8
Austin Group Defect 508 is applied, adding the ptsname_r() function.
Austin Group Defect 1466 is applied, changing the terminology used for pseudo-terminal devices.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mtx_init.html =====
mtx_destroy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mtx_destroy, mtx_init — destroy and initialize a mutex
SYNOPSIS
#include
void mtx_destroy(mtx_t *mtx);
int mtx_init(mtx_t *mtx, int type);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The mtx_destroy() function shall release any resources used by the mutex pointed to by mtx. A destroyed mutex
object can be reinitialized using mtx_init(); the results of otherwise referencing the object after it has been destroyed
are undefined. It shall be safe to destroy an initialized mutex that is unlocked. Attempting to destroy a locked mutex, or a mutex
that another thread is attempting to lock, or a mutex that is being used in a cnd_timedwait() or cnd_wait() call by
another thread, results in undefined behavior. The behavior is undefined if the value specified by the mtx argument to
mtx_destroy() does not refer to an initialized mutex.
The mtx_init() function shall initialize a mutex object with properties indicated by type, whose valid values
include:
mtx_plain
for a simple non-recursive mutex,
mtx_timed
for a non-recursive mutex that supports timeout,
mtx_plain|mtx_recursive
for a simple recursive mutex, or
mtx_timed|mtx_recursive
for a recursive mutex that supports timeout.
If the mtx_init() function succeeds, it shall set the mutex pointed to by mtx to a value that uniquely identifies
the newly initialized mutex. Upon successful initialization, the state of the mutex shall become initialized and unlocked.
Attempting to initialize an already initialized mutex results in undefined behavior.
[CX]  See
2.9.9 Synchronization Object Copies and Alternative Mappings for
further requirements.
These functions shall not be affected if the calling thread executes a signal handler during the call.
RETURN VALUE
The mtx_destroy() function shall not return a value.
The mtx_init() function shall return thrd_success on success or thrd_error if the request could not be
honored.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
A mutex can be destroyed immediately after it is unlocked. However, since attempting to destroy a locked mutex, or a mutex that
another thread is attempting to lock, or a mutex that is being used in a cnd_timedwait() or cnd_wait() call by
another thread results in undefined behavior, care must be taken to ensure that no other thread may be referencing the mutex.
RATIONALE
These functions are not affected by signal handlers for the reasons stated in XRAT B.2.3 Error Numbers.
FUTURE DIRECTIONS
None.
SEE ALSO
cnd_timedwait(), mtx_lock()
XBD
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/_Fork.html =====
fork
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fork — create a new process
SYNOPSIS
#include
pid_t fork(void);
pid_t _Fork(void);
DESCRIPTION
The fork() function shall create a new process. The new process (child process) shall be an exact copy of the calling
process (parent process) except as detailed below:
The child process shall have a unique process ID.
The child process ID also shall not match any active process group ID.
The child process shall have a different parent process ID, which shall be the process ID of the calling process.
The child process shall have its own copy of the parent's file descriptors, except for those whose FD_CLOFORK flag is set (see
fcntl()). Each of the child's file descriptors shall refer to the same open file
description with the corresponding file descriptor of the parent.
The child process shall have its own copy of the parent's open directory streams. Each open directory stream in the child
process may share directory stream positioning with the corresponding directory stream of the parent.
The child process shall have its own copy of the parent's message catalog descriptors.
The child process values of tms_utime, tms_stime, tms_cutime, and tms_cstime shall be set to 0.
The time left until an alarm clock signal shall be reset to zero, and the alarm, if any, shall be canceled; see alarm().
[XSI]
All semadj values shall be cleared.
Process-owned file locks set by the parent process shall not be inherited by the child process.
The set of signals pending for the child process shall be initialized to the empty set.
[XSI]
Interval timers shall be reset in the child process.
Any semaphores that are open in the parent process shall also be open in the child process.
[ML]  The
child process shall not inherit any address space memory locks established by the parent process via calls to mlockall() or mlock().
Memory mappings created in the parent shall be retained in the child process. MAP_PRIVATE mappings inherited from the parent
shall also be MAP_PRIVATE mappings in the child, and any modifications to the data in these mappings made by the parent prior to
calling fork() shall be visible to the child. Any modifications to the data in MAP_PRIVATE mappings made by the parent after
fork() returns shall be visible only to the parent. Modifications to the data in MAP_PRIVATE mappings made by the child
shall be visible only to the child.
[PS]  For
the SCHED_FIFO and SCHED_RR scheduling policies, the child process shall inherit the policy and priority settings of the parent
process during a fork() function. For other scheduling policies, the policy and priority settings on fork() are
implementation-defined.
Per-process timers created by the parent shall not be inherited by the child process.
[MSG]
The child process shall have its own copy of the message queue descriptors of the parent. Each of the message descriptors of the
child shall refer to the same open message queue description as the corresponding message descriptor of the parent.
No asynchronous input or asynchronous output operations shall be inherited by the child process. Any use of asynchronous control
blocks created by the parent produces undefined behavior.
A process shall be created with a single thread. If a multi-threaded process calls fork(), the new process shall contain
a replica of the calling thread and its entire address space, possibly including the states of mutexes and other resources.
Consequently, the application shall ensure that the child process only executes async-signal-safe operations until such time as one
of the exec functions is successful.
Any locks held by any thread in the calling process that have been set to be process-shared shall not be held by the child
process. For locks held by any thread in the calling process that have not been set to be process-shared, any attempt by the child
process to perform any operation on the lock results in undefined behavior (regardless of whether the calling process is
single-threaded or multi-threaded).
[CPT]
The initial value of the CPU-time clock of the child process shall be set to zero.
[TCT]
The initial value of the CPU-time clock of the single thread of the child process shall be set to zero.
All other process characteristics defined by POSIX.1-2024 shall be the same in the parent and child processes. The inheritance
of process characteristics not defined by POSIX.1-2024 is unspecified by POSIX.1-2024.
After fork(), both the parent and the child processes shall be capable of executing independently before either one
terminates.
The _Fork() function shall be equivalent to fork(), except that fork handlers established by means of the pthread_atfork() function shall not be called and _Fork() shall be
async-signal-safe.
RETURN VALUE
Upon successful completion, fork() shall return 0 to the child process and shall return the process ID of the child
process to the parent process. Both processes shall continue to execute from the fork() function. Otherwise, -1 shall be
returned to the parent process, no child process shall be created, and errno shall be set to indicate the error.
ERRORS
These functions shall fail if:
[EAGAIN]
The system lacked the necessary resources to create another process, or the system-imposed limit on the total number of
processes under execution system-wide or by a single user {CHILD_MAX} would be exceeded.
These functions may fail if:
[ENOMEM]
Insufficient storage space is available.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
When a multi-threaded process calls fork() or _Fork(), there is no guarantee that thread-specific memory, such as
stacks or thread-local storage, associated with threads in the parent other than the calling thread will still be available in the
child. This is because threads in the parent other than the calling thread do not exist in the child. Consequently, the
implementation of fork() or _Fork() could remove that memory from the address space in the child, or reuse it for
other purposes before returning or (in the case of fork()) calling any of the fork handlers registered by pthread_atfork(). Therefore, applications should avoid using any pointers to
thread-specific memory in the child that were passed to the calling thread from other threads in the parent.
RATIONALE
Many historical implementations have timing windows where a signal sent to a process group (for example, an interactive SIGINT)
just prior to or during execution of fork() is delivered to the parent following the fork() but not to the child
because the fork() code clears the child's set of pending signals. This volume of POSIX.1-2024 does not require, or even
permit, this behavior. However, it is pragmatic to expect that problems of this nature may continue to exist in implementations
that appear to conform to this volume of POSIX.1-2024 and pass available verification suites. This behavior is only a consequence
of the implementation failing to make the interval between signal generation and delivery totally invisible. From the application's
perspective, a fork() call should appear atomic. A signal that is generated prior to the fork() should be delivered
prior to the fork(). A signal sent to the process group after the fork() should be delivered to both parent and
child. The implementation may actually initialize internal data structures corresponding to the child's set of pending signals to
include signals sent to the process group during the fork(). Since the fork() call can be considered as atomic from
the application's perspective, the set would be initialized as empty and such signals would have arrived after the fork();
see also .
One approach that has been suggested to address the problem of signal inheritance across fork() is to add an [EINTR]
error, which would be returned when a signal is detected during the call. While this is preferable to losing signals, it was not
considered an optimal solution. Although it is not recommended for this purpose, such an error would be an allowable extension for
an implementation.
The [ENOMEM] error value is reserved for those implementations that detect and distinguish such a condition. This condition
occurs when an implementation detects that there is not enough memory to create the process. This is intended to be returned when
[EAGAIN] is inappropriate because there can never be enough memory (either primary or secondary storage) to perform the operation.
Since fork() duplicates an existing process, this must be a condition where there is sufficient memory for one such process,
but not for two. Many historical implementations actually return [ENOMEM] due to temporary lack of memory, a case that is not
generally distinct from [EAGAIN] from the perspective of a conforming application.
Part of the reason for including the optional error [ENOMEM] is because the SVID specifies it and it should be reserved for the
error condition specified there. The condition is not applicable on many implementations.
IEEE Std 1003.1-1988 neglected to require concurrent execution of the parent and child of fork(). A system that
single-threads processes was clearly not intended and is considered an unacceptable "toy implementation" of this volume of
POSIX.1-2024. The only objection anticipated to the phrase "executing independently" is testability, but this assertion should be
testable. Such tests require that both the parent and child can block on a detectable action of the other, such as a write to a
pipe or a signal. An interactive exchange of such actions should be possible for the system to conform to the intent of this volume
of POSIX.1-2024.
The [EAGAIN] error exists to warn applications that such a condition might occur. Whether it occurs or not is not in any
practical sense under the control of the application because the condition is usually a consequence of the user's use of the
system, not of the application's code. Thus, no application can or should rely upon its occurrence under any circumstances, nor
should the exact semantics of what concept of "user" is used be of concern to the application developer. Validation writers
should be cognizant of this limitation.
There are two reasons why POSIX programmers call fork(). One reason is to create a new thread of control within the same
program (which was originally only possible in POSIX by creating a new process); the other is to create a new process running a
different program. In the latter case, the call to fork() is soon followed by a call to one of the exec functions.
The general problem with making fork() work in a multi-threaded world is what to do with all of the threads. There are
two alternatives. One is to copy all of the threads into the new process. This causes the programmer or implementation to deal with
threads that are suspended on system calls or that might be about to execute system calls that should not be executed in the new
process. The other alternative is to copy only the thread that calls fork(). This creates the difficulty that the state of
process-local resources is usually held in process memory. If a thread that is not calling fork() holds a resource, that
resource is never released in the child process because the thread whose job it is to release the resource does not exist in the
child process.
When a programmer is writing a multi-threaded program, the first described use of fork(), creating new threads in the
same program, is provided by the pthread_create() function. The fork()
function is thus used only to run new programs, and the effects of calling functions that require certain resources between the
call to fork() and the call to an exec function are undefined.
The addition of the forkall() function to the standard was considered and rejected. The forkall() function lets
all the threads in the parent be duplicated in the child. This essentially duplicates the state of the parent in the child. This
allows threads in the child to continue processing and allows locks and the state to be preserved without explicit pthread_atfork() code. The calling process has to ensure that the threads processing
state that is shared between the parent and child (that is, file descriptors or MAP_SHARED memory) behaves properly after
forkall(). For example, if a thread is reading a file descriptor in the parent when forkall() is called, then two
threads (one in the parent and one in the child) are reading the file descriptor after the forkall(). If this is not desired
behavior, the parent process has to synchronize with such threads before calling forkall().
When forkall() is called, threads, other than the calling thread, that are in functions that can return with an [EINTR]
error may have those functions return [EINTR] if the implementation cannot ensure that the function behaves correctly in the parent
and child. In particular, pthread_cond_clockwait(), pthread_cond_timedwait(), and pthread_cond_wait() need to return in order to ensure that the condition has not
changed. These functions can be awakened by a spurious condition wakeup rather than returning [EINTR].
FUTURE DIRECTIONS
None.
SEE ALSO
alarm(), exec, fcntl(), pthread_atfork(), semop(), signal(), times()
XBD 4.15.2 Memory Synchronization, ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is changed for alignment with the POSIX Realtime Extension and the POSIX Threads Extension.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
The following changes were made to align with the IEEE P1003.1a draft standard:
The effect of fork() on a pending alarm call in the child process is clarified.
The description of CPU-time clock semantics is added for alignment with IEEE Std 1003.1d-1999.
The description of tracing semantics is added for alignment with IEEE Std 1003.1q-2000.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/17 is applied, adding text to the DESCRIPTION and RATIONALE
relating to fork handlers registered by the pthread_atfork() function and
async-signal safety.
Issue 7
Austin Group Interpretation 1003.1-2001 #080 is applied, clarifying the status of asynchronous input and asynchronous output
operations and asynchronous control lists in the DESCRIPTION.
Functionality relating to the Asynchronous Input and Output, Memory Mapped Files, Timers, and Threads options is moved to the
Base.
Functionality relating to message catalog descriptors is moved from the XSI option to the Base.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0123 [858] is applied.
Issue 8
Austin Group Defects 62, 1361, and 1383 are applied, adding the _Fork() function and removing the requirement for
fork() to be async-signal-safe.
Austin Group Defect 768 is applied, adding OFD-owned file locks.
Austin Group Defect 1112 is applied, clarifying the requirements for a child of a multi-threaded process and for process-shared
and non-process-shared locks held by any thread in the calling process.
Austin Group Defect 1114 is applied, changing the APPLICATION USAGE section.
Austin Group Defect 1216 is applied, adding pthread_cond_clockwait().
Austin Group Defect 1318 is applied, adding FD_CLOFORK.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mkdir.html =====
mkdir
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mkdir, mkdirat — make a directory
SYNOPSIS
#include
int mkdir(const char *path, mode_t mode);
[OH] #include
int mkdirat(int fd, const char *path, mode_t mode);
DESCRIPTION
The mkdir() function shall create a new directory with name path. The file permission bits [XSI]   and S_ISVTX
bit   of the new directory shall be initialized from
mode. The file permission bits of the mode argument shall be modified by the file creation mask of the process.
When bits in mode other than the file permission bits [XSI]
and S_ISVTX   are set, the meaning of these additional bits is implementation-defined.
The directory's user ID shall be set to the process' effective user ID. The directory's group ID shall be set to the group ID of
the parent directory or to the effective group ID of the process. Implementations shall provide a way to initialize the directory's
group ID to the group ID of the parent directory. Implementations may, but need not, provide an implementation-defined way to
initialize the directory's group ID to the effective group ID of the calling process.
The newly created directory shall be an empty directory.
If path names a symbolic link, mkdir() shall fail and set errno to [EEXIST].
Upon successful completion, mkdir() shall mark for update the last data access, last data modification, and last file
status change timestamps of the directory. Also, the last data modification and last file status change timestamps of the directory
that contains the new entry shall be marked for update.
The mkdirat() function shall be equivalent to the mkdir() function except in the case where path specifies
a relative path. In this case the newly created directory is created relative to the directory associated with the file descriptor
fd instead of the current working directory. If the access mode of the open file description associated with the file
descriptor is not O_SEARCH, the function shall check whether directory searches are permitted using the current permissions of the
directory underlying the file descriptor. If the access mode is O_SEARCH, the function shall not perform the check.
If mkdirat() is passed the special value AT_FDCWD in the fd parameter, the current working directory shall be used
and the behavior shall be identical to a call to mkdir().
RETURN VALUE
Upon successful completion, these functions shall return 0. Otherwise, these functions shall return -1 and set errno to
indicate the error. If -1 is returned, no directory shall be created.
ERRORS
These functions shall fail if:
[EACCES]
Search permission is denied on a component of the path prefix, or write permission is denied on the parent directory of the
directory to be created.
[EEXIST]
The named file exists.
[EILSEQ]
The last pathname component of path is not a portable filename, and cannot be created in the target directory.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path argument.
[EMLINK]
The link count of the parent directory would exceed {LINK_MAX}.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of the path prefix of path does not name an existing file or path is an empty string.
[ENOSPC]
The file system does not contain enough space to hold the contents of the new directory or to extend the parent directory of
the new directory.
[ENOTDIR]
A component of the path prefix names an existing file that is neither a directory nor a symbolic link to a directory.
[EROFS]
The parent directory resides on a read-only file system.
In addition, the mkdirat() function shall fail if:
[EACCES]
The access mode of the open file description associated with fd is not O_SEARCH and the permissions of the directory
underlying fd do not permit directory searches.
[EBADF]
The path argument does not specify an absolute path and the fd argument is neither AT_FDCWD nor a valid file
descriptor open for reading or searching.
[ENOTDIR]
The path argument is not an absolute path and fd is a file descriptor associated with a non-directory file.
These functions may fail if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
The following sections are informative.
EXAMPLES
Creating a Directory
The following example shows how to create a directory named /home/cnd/mod1, with read/write/search permissions for owner
and group, and with read/search permissions for others.
#include
#include
int status;
...
status = mkdir("/home/cnd/mod1", S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
APPLICATION USAGE
None.
RATIONALE
The mkdir() function originated in 4.2 BSD and was added to System V in Release 3.0.
4.3 BSD detects [ENAMETOOLONG].
The POSIX.1-1990 standard required that the group ID of a newly created directory be set to the group ID of its parent directory
or to the effective group ID of the creating process. FIPS 151-2 required that implementations provide a way to have the group ID
be set to the group ID of the containing directory, but did not prohibit implementations also supporting a way to set the group ID
to the effective group ID of the creating process. Conforming applications should not assume which group ID will be used. If it
matters, an application can use chown() to set the group ID after the directory is
created, or determine under what conditions the implementation will set the desired group ID.
The purpose of the mkdirat() function is to create a directory in directories other than the current working directory
without exposure to race conditions. Any part of the path of a file could be changed in parallel to the call to mkdir(),
resulting in unspecified behavior. By opening a file descriptor for the target directory and using the mkdirat() function it
can be guaranteed that the newly created directory is located relative to the desired directory.
Implementations are encouraged to have mkdir() and mkdirat() report an [EILSEQ] error if the last component of
path contains any bytes that have the encoded value of a  character.
FUTURE DIRECTIONS
None.
SEE ALSO
chmod(), mkdtemp(),
mknod(), umask()
XBD , ,
CHANGE HISTORY
First released in Issue 3. Included for alignment with the POSIX.1-1988 standard.
Issue 6
In the SYNOPSIS, the optional include of the  header is
removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
The [ELOOP] mandatory error condition is added.
A second [ENAMETOOLONG] is added as an optional error condition.
The following changes were made to align with the IEEE P1003.1a draft standard:
The [ELOOP] optional error condition is added.
Issue 7
Austin Group Interpretation 1003.1-2001 #143 is applied.
The mkdirat() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 2.
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0375 [461], XSH/TC1-2008/0376 [324], XSH/TC1-2008/0377 [277],
XSH/TC1-2008/0378 [278], and XSH/TC1-2008/0379 [278] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0210 [873], XSH/TC2-2008/0211 [591], XSH/TC2-2008/0212 [817],
XSH/TC2-2008/0213 [817], and XSH/TC2-2008/0214 [591] are applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defects 293 and 1734 are applied, adding the [EILSEQ] error.
Austin Group Defect 1522 is applied, adding requirements relating to the S_ISVTX bit.
Austin Group Defect 1729 is applied, changing the description of the [ENOENT] error.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/dbm_firstkey.html =====
dbm_clearerr
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
dbm_clearerr, dbm_close, dbm_delete, dbm_error, dbm_fetch, dbm_firstkey, dbm_nextkey, dbm_open, dbm_store — database
functions
SYNOPSIS
[XSI]  #include
int dbm_clearerr(DBM *db);
void dbm_close(DBM *db);
int dbm_delete(DBM *db, datum key);
int dbm_error(DBM *db);
datum dbm_fetch(DBM *db, datum key);
datum dbm_firstkey(DBM *db);
datum dbm_nextkey(DBM *db);
DBM *dbm_open(const char *file, int open_flags, mode_t file_mode);
int dbm_store(DBM *db, datum key, datum content, int
store_mode);
DESCRIPTION
These functions create, access, and modify a database.
A datum consists of at least two members, dptr and dsize. The dptr member points to an object that
is dsize bytes in length. Arbitrary binary data, as well as character strings, may be stored in the object pointed to by
dptr.
A database shall be stored in one or two files. When one file is used, the name of the database file shall be formed by
appending the suffix .db to the file argument given to dbm_open(). When two files are used, the names of the
database files shall be formed by appending the suffixes .dir and .pag respectively to the file argument.
The dbm_open() function shall open a database. The file argument to the function is the pathname of the database.
Values for the open_flags argument are constructed by a bitwise-inclusive OR of flags from the following list, defined in
. Applications shall specify exactly one of the first three values
(file access modes) below in the value of open_flags:
O_RDONLY
Open the database, and the underlying file(s) used to store the database, for reading only.
O_RDWR
Open the database, and the underlying file(s) used to store the database, for reading and writing.
O_WRONLY
Open the database for writing only. The underlying file(s) used to store the database shall be opened for reading and
writing.
Any combination of the following can be used:
O_CLOEXEC
If set, the FD_CLOEXEC flag for the new file descriptor(s) used to open the underlying file(s) shall be set.
O_CREAT
If the database exists, this flag has no effect except as noted under O_EXCL below. Otherwise, the database shall be created;
the user ID of the underlying file(s) shall be set to the effective user ID of the process; the group ID of the underlying file(s)
shall be set to the group ID of the file's parent directory or to the effective group ID of the process. Implementations shall
provide a way to initialize the group ID to the group ID of the parent directory. Implementations may, but need not, provide an
implementation-defined way to initialize the group ID to the effective group ID of the calling process.
O_DSYNC
[SIO]
Write I/O operations on the file(s) used to store the database shall complete as defined by synchronized I/O data integrity
completion.
O_EXCL
If O_CREAT and O_EXCL are set, dbm_open() shall fail if the database exists according to the following criteria. If the
database is stored in a file with a .db suffix, a check for the existence of the file and the creation of the file if it
does not exist shall be performed as a single atomic operation. If the database is stored in files with .pag and .dir
suffixes, this atomic existence check and creation operation shall be performed for each file, but it is unspecified which file is
first. If the first file is successfully created and the second file is found to exist, the first file should be removed before
dbm_open() returns.
If O_EXCL is set and O_CREAT is not set, the result is undefined.
O_RSYNC
[SIO]
Read I/O operations on the file(s) used to store the database shall complete at the same level of integrity as specified by the
O_DSYNC and O_SYNC flags. If both O_DSYNC and O_RSYNC are set in oflag, all I/O operations on the file(s) shall complete as defined
by synchronized I/O data integrity completion. If both O_SYNC and O_RSYNC are set in flags, all I/O operations on the file(s) shall
complete as defined by synchronized I/O file integrity completion.
O_SYNC
Write I/O operations on the file(s) used to store the database shall complete as defined by synchronized I/O file integrity
completion.
O_TRUNC
If the database exists and is successfully opened O_RDWR or O_WRONLY, it shall be emptied, and the mode and owner of the
underlying file(s) shall be unchanged. The result of using O_TRUNC without either O_RDWR or O_WRONLY is undefined.
The behaviour of other flags described for the flags argument of open() is
unspecified.
The file_mode argument has the same meaning as the third argument of open()
and shall apply to the underlying file(s) used to store the database.
The dbm_open() function need not accept pathnames longer than {PATH_MAX}-4 bytes (including the terminating null), or
pathnames with a last component longer than {NAME_MAX}-4 bytes (excluding the terminating null).
The dbm_close() function shall close a database. The application shall ensure that argument db is a pointer to a
dbm structure that has been returned from a call to dbm_open().
These database functions shall support an internal block size large enough to support key/content pairs of at least 1023
bytes.
The dbm_fetch() function shall read a record from a database. The argument db is a pointer to a database structure
that has been returned from a call to dbm_open(). The argument key is a datum that has been initialized by the
application to the value of the key that matches the key of the record the program is fetching.
The dbm_store() function shall write a record to a database. The argument db is a pointer to a database structure
that has been returned from a call to dbm_open(). The argument key is a datum that has been initialized by the
application to the value of the key that identifies (for subsequent reading, writing, or deleting) the record the application is
writing. The argument content is a datum that has been initialized by the application to the value of the record the
program is writing. The argument store_mode controls whether dbm_store() replaces any pre-existing record that has
the same key that is specified by the key argument. The application shall set store_mode to either DBM_INSERT or
DBM_REPLACE. If the database contains a record that matches the key argument and store_mode is DBM_REPLACE, the
existing record shall be replaced with the new record. If the database contains a record that matches the key argument and
store_mode is DBM_INSERT, the existing record shall be left unchanged and the new record ignored. If the database does not
contain a record that matches the key argument and store_mode is either DBM_INSERT or DBM_REPLACE, the new record
shall be inserted in the database.
If the sum of a key/content pair exceeds the internal block size, the result is unspecified. Moreover, the application shall
ensure that all key/content pairs that hash together fit on a single block. The dbm_store() function shall return an error
in the event that a disk block fills with inseparable data.
The dbm_delete() function shall delete a record and its key from the database. The argument db is a pointer to a
database structure that has been returned from a call to dbm_open(). The argument key is a datum that has been
initialized by the application to the value of the key that identifies the record the program is deleting.
The dbm_firstkey() function shall return the first key in the database. The argument db is a pointer to a database
structure that has been returned from a call to dbm_open().
The dbm_nextkey() function shall return the next key in the database. The argument db is a pointer to a database
structure that has been returned from a call to dbm_open(). The application shall ensure that the dbm_firstkey()
function is called before calling dbm_nextkey(). Subsequent calls to dbm_nextkey() return the next key until all of
the keys in the database have been returned.
The dbm_error() function shall return the error condition of the database. The argument db is a pointer to a
database structure that has been returned from a call to dbm_open().
The dbm_clearerr() function shall clear the error condition of the database. The argument db is a pointer to a
database structure that has been returned from a call to dbm_open().
The dptr pointers returned by these functions may point into static storage that may be changed by subsequent calls.
These functions need not be thread-safe.
RETURN VALUE
The dbm_store() and dbm_delete() functions shall return 0 when they succeed and a negative value when they
fail.
The dbm_store() function shall return 1 if it is called with a flags value of DBM_INSERT and the function finds an
existing record with the same key.
The dbm_error() function shall return 0 if the error condition is not set and return a non-zero value if the error
condition is set.
The return value of dbm_clearerr() is unspecified.
The dbm_firstkey() and dbm_nextkey() functions shall return a key datum. When the end of the database is
reached, the dptr member of the key is a null pointer. If an error is detected, the dptr member of the key shall be a
null pointer and the error condition of the database shall be set.
The dbm_fetch() function shall return a content datum. If no record in the database matches the key or if an error
condition has been detected in the database, the dptr member of the content shall be a null pointer.
The dbm_open() function shall return a pointer to a database structure. If an error is detected during the operation,
dbm_open() shall return a (DBM *)0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The following code can be used to traverse the database:
for(key = dbm_firstkey(db); key.dptr != NULL; key = dbm_nextkey(db))
The dbm_* functions provided in this library should not be confused in any way with those of a general-purpose database
management system. These functions do not provide for multiple search keys per entry, they do not protect against multi-user access
(in other words they do not lock records or files), and they do not provide the many other useful database functions that are found
in more robust database management systems. Creating and updating databases by use of these functions is relatively slow because of
data copies that occur upon hash collisions. These functions are useful for applications requiring fast lookup of relatively static
information that is to be indexed by a single key.
Note that a strictly conforming application is extremely limited by these functions: since there is no way to determine that the
keys in use do not all hash to the same value (although that would be rare), a strictly conforming application cannot be guaranteed
that it can store more than one block's worth of data in the database. As long as a key collision does not occur, additional data
may be stored, but because there is no way to determine whether an error is due to a key collision or some other error condition
(dbm_error() being effectively a Boolean), once an error is detected, the
application is effectively limited to guessing what the error might be if it wishes to continue using these functions.
The dbm_delete() function need not physically reclaim file space, although it does make it available for reuse by the
database.
After calling dbm_store() or dbm_delete() during a pass through the keys by dbm_firstkey() and
dbm_nextkey(), the application should reset the database by calling dbm_firstkey() before again calling
dbm_nextkey(). The contents of these files are unspecified and may not be portable.
Applications should take care that database pathname arguments specified to dbm_open() are not prefixes of unrelated
files. This might be done, for example, by placing databases in a separate directory.
Since some implementations use three characters for a suffix and others use four characters for a suffix, applications should
ensure that the maximum portable pathname length passed to dbm_open() is no greater than {PATH_MAX}-4 bytes, with the last
component of the pathname no greater than {NAME_MAX}-4 bytes.
RATIONALE
and having .dir as its suffix. The second file containing all data and having .pag as its suffix. This has been
changed not to specify the use of the files and to allow newer implementations of the Berkeley DB interface using a single file
that have evolved while remaining compatible with the application programming interface. The standard developers considered
removing the specific suffixes altogether but decided to retain them so as not to pollute the application file name space more than
necessary and to allow for portable backups of the database.
FUTURE DIRECTIONS
A future revision of this standard may mandate the file removal that is currently recommended (by the use of "should") in the
description of O_EXCL.
SEE ALSO
open()
XBD ,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Normative text previously in the APPLICATION USAGE section is moved to the DESCRIPTION.
A note indicating that these functions need not be reentrant is added to the DESCRIPTION.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
Austin Group Interpretation 1003.1-2001 #042 is applied so that the DESCRIPTION permits newer implementations of the Berkeley DB
interface.
Austin Group Interpretation 1003.1-2001 #156 is applied.
Issue 8
Austin Group Defect 1057 is applied, clarifying how the O_ flags defined for use with open() apply to dbm_open().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/log1pl.html =====
log1p
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
log1p, log1pf, log1pl — compute a natural logarithm
SYNOPSIS
#include
double log1p(double x);
float log1pf(float x);
long double log1pl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute loge(1.0 + x).
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the natural logarithm of 1.0 + x.
If x is -1, a pole error shall occur and log1p(), log1pf(), and log1pl() shall return -HUGE_VAL,
-HUGE_VALF, and -HUGE_VALL, respectively.
For finite values of x that are less than -1, [MX]   or if x is -Inf,  a domain error shall occur, and [MX]   either a NaN (if supported), or   an implementation-defined value shall be returned.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, or +Inf, x shall be returned.
[MXX]
If x is subnormal, x should be returned.
[MX]  If x is subnormal, a range error may occur and, if x is
not returned, log1p(), log1pf(), and log1pl() shall return an implementation-defined value no greater in
magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
ERRORS
These functions shall fail if:
Domain Error
The finite value of x is less than -1, [MX]   or x is -Inf.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
Pole Error
The value of x is -1.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the divide-by-zero floating-point exception shall
be raised.
These functions may fail if:
Range Error
[MX]
The value of x is subnormal.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), log()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
The log1p() function is no longer marked as an extension.
The log1pf() and log1pl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0364 [68] is applied.
Issue 8
Austin Group Defect 1382 is applied, rearranging the text describing the behavior when x is subnormal to avoid the need
for two shading changes.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/semctl.html =====
semctl
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
semctl — XSI semaphore control operations
SYNOPSIS
[XSI]  #include
int semctl(int semid, int semnum, int cmd, ...);
DESCRIPTION
The semctl() function operates on XSI semaphores (see XBD 4.20
Semaphore). It is unspecified whether this function interoperates with the realtime interprocess communication facilities
defined in 2.8 Realtime.
The semctl() function provides a variety of semaphore control operations as specified by cmd. The fourth argument
is optional and depends upon the operation requested. If required, it is of type union semun, which the application shall
explicitly declare:
union semun {
int val;
struct semid_ds *buf;
unsigned short  *array;
} arg;
Each operation shall be performed atomically.
The following semaphore control operations as specified by cmd are executed with respect to the semaphore specified by
semid and semnum. The level of permission required for each operation is shown with each command; see 2.7 XSI Interprocess Communication. The symbolic names for the values of
cmd are defined in the  header:
GETVAL
Return the value of semval; see . Requires read
permission.
SETVAL
Set the value of semval to arg.val, where arg is the value of the fourth argument to semctl(). When
this command is successfully executed, the semadj value corresponding to the specified semaphore in all processes is
cleared. Also, the sem_ctime timestamp shall be set to the current time, as described in 2.7.1 IPC General Description. Requires alter permission; see 2.7 XSI Interprocess Communication.
GETPID
Return the value of sempid. Requires read permission.
GETNCNT
Return the value of semncnt. Requires read permission.
GETZCNT
Return the value of semzcnt. Requires read permission.
The following values of cmd operate on each semval in the set of semaphores:
GETALL
Return the value of semval for each semaphore in the semaphore set and place into the array pointed to by
arg.array, where arg is the fourth argument to semctl(). Requires read permission.
SETALL
Set the value of semval for each semaphore in the semaphore set according to the array pointed to by arg.array,
where arg is the fourth argument to semctl(). When this command is successfully executed, the semadj values
corresponding to each specified semaphore in all processes are cleared. Also, the sem_ctime timestamp shall be set to the
current time, as described in 2.7.1 IPC General Description.
Requires alter permission.
The following values of cmd are also available:
IPC_STAT
Place the current value of each member of the semid_ds data structure associated with semid into the structure
pointed to by arg.buf, where arg is the fourth argument to semctl(). The contents of this structure are
defined in . Requires read permission.
IPC_SET
Set the value of the following members of the semid_ds data structure associated with semid to the corresponding
value found in the structure pointed to by arg.buf, where arg is the fourth argument to semctl():
sem_perm.uid
sem_perm.gid
sem_perm.mode
The mode bits specified in 2.7.1 IPC General Description are
copied into the corresponding bits of the sem_perm.mode associated with semid. The stored values of any other bits
are unspecified. The sem_ctime timestamp shall be set to the current time, as described in 2.7.1 IPC General Description.
This command can only be executed by a process that has an effective user ID equal to either that of a process with appropriate
privileges or to the value of sem_perm.cuid or sem_perm.uid in the semid_ds data structure associated with
semid.
IPC_RMID
Remove the semaphore identifier specified by semid from the system and destroy the set of semaphores and semid_ds
data structure associated with it. This command can only be executed by a process that has an effective user ID equal to either
that of a process with appropriate privileges or to the value of sem_perm.cuid or sem_perm.uid in the semid_ds
data structure associated with semid.
RETURN VALUE
If successful, the value returned by semctl() depends on cmd as follows:
GETVAL
The value of semval.
GETPID
The value of sempid.
GETNCNT
The value of semncnt.
GETZCNT
The value of semzcnt.
All others
0.
Otherwise, semctl() shall return -1 and set errno to indicate the error.
ERRORS
The semctl() function shall fail if:
[EACCES]
Operation permission is denied to the calling process; see 2.7 XSI
Interprocess Communication.
[EINVAL]
The value of semid is not a valid semaphore identifier, or the value of semnum is less than 0 or greater than or
equal to sem_nsems, or the value of cmd is not a valid command.
[EPERM]
The argument cmd is equal to IPC_RMID or IPC_SET and the effective user ID of the calling process is not equal to that
of a process with appropriate privileges and it is not equal to the value of sem_perm.cuid or sem_perm.uid in the
data structure associated with semid.
[ERANGE]
The argument cmd is equal to SETVAL or SETALL and the value to which semval is to be set is greater than the
system-imposed maximum.
The following sections are informative.
EXAMPLES
Refer to semop().
APPLICATION USAGE
The fourth parameter in the SYNOPSIS section is now specified as "..." in order to avoid a clash with the ISO C
standard when referring to the union semun (as defined in Issue 3) and for backwards-compatibility.
The POSIX Realtime Extension defines alternative interfaces for interprocess communication. Application developers who need to
use IPC should design their applications so that modules using the IPC routines described in 2.7 XSI Interprocess Communication can be easily modified to use the alternative
interfaces.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.7 XSI Interprocess Communication, 2.8 Realtime, semget(),
semop(), sem_close(), sem_destroy(), sem_getvalue(),
sem_init(), sem_open(),
sem_post(), sem_trywait(),
sem_unlink()
XBD 4.20 Semaphore,
CHANGE HISTORY
First released in Issue 2. Derived from Issue 2 of the SVID.
Issue 5
The note about use of POSIX Realtime Extension IPC routines has been moved from FUTURE DIRECTIONS to the APPLICATION USAGE
section.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0532 [345], XSH/TC1-2008/0533 [345], XSH/TC1-2008/0534 [345], and
XSH/TC1-2008/0535 [335] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0319 [532] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/cexpf.html =====
cexp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cexp, cexpf, cexpl — complex exponential functions
SYNOPSIS
#include
double complex cexp(double complex z);
float complex cexpf(float complex z);
long double complex cexpl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex exponent of z, defined as ez.
RETURN VALUE
These functions shall return the complex exponential value of z.
[MXC]
cexp(conj(z)), cexpf(conjf(z)), and cexpl(conjl(z)) shall return
exactly the same value as conj(cexp(z)), conjf(cexpf(z)), and
conjl(cexpl(z)), respectively, including for the special values of z below.
If z is ±0 + i0, 1 + i0 shall be returned.
If z is x + iInf where x is finite, NaN + iNaN shall be returned and the invalid
floating-point exception shall be raised.
If z is x + iNaN where x is finite, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is +Inf + i0, +Inf + i0 shall be returned.
If z is -Inf + iy where y is finite, +0 (cos(y) + isin(y)) shall be
returned.
If z is +Inf + iy where y is non-zero and finite, +Inf (cos(y) + isin(y)) shall
be returned.
If z is -Inf + iInf, ±0 ± i0 shall be returned; the signs of the real and imaginary parts of the result are
unspecified.
If z is +Inf + iInf, ±Inf + iNaN shall be returned and the invalid floating-point exception shall be
raised; the sign of the real part of the result is unspecified.
If z is -Inf + iNaN, ±0 ± i0 shall be returned; the signs of the real and imaginary parts of the result are
unspecified.
If z is +Inf + iNaN, ±Inf + iNaN shall be returned; the sign of the real part of the result is
unspecified.
If z is NaN + i0, NaN + i0 shall be returned.
If z is NaN + iy where y is any non-zero number, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is NaN + iNaN, NaN + iNaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
clog()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mrand48.html =====
drand48
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
drand48, erand48, jrand48, lcong48, lrand48, mrand48, nrand48, seed48, srand48 — generate uniformly distributed
pseudo-random numbers
SYNOPSIS
[XSI]  #include
double drand48(void);
double erand48(unsigned short xsubi[3]);
long jrand48(unsigned short xsubi[3]);
void lcong48(unsigned short param[7]);
long lrand48(void);
long mrand48(void);
long nrand48(unsigned short xsubi[3]);
unsigned short *seed48(unsigned short seed16v[3]);
void srand48(long seedval);
DESCRIPTION
This family of functions shall generate pseudo-random numbers using a linear congruential algorithm and 48-bit integer
arithmetic.
The drand48() and erand48() functions shall return non-negative, double-precision, floating-point values,
uniformly distributed over the interval [0.0,1.0).
The lrand48() and nrand48() functions shall return non-negative, long integers, uniformly distributed over the
interval [0,231).
The mrand48() and jrand48() functions shall return signed long integers uniformly distributed over the interval
[-231,231).
The srand48(), seed48(), and lcong48() functions are initialization entry points, one of which should be
invoked before either drand48(), lrand48(), or mrand48() is called. (Although it is not recommended practice,
constant default initializer values shall be supplied automatically if drand48(), lrand48(), or mrand48() is
called without a prior call to an initialization entry point.) The erand48(), nrand48(), and jrand48()
functions do not require an initialization entry point to be called first.
All the routines work by generating a sequence of 48-bit integer values,
\(X_{i}\),
according to the linear congruential formula:
\(X_{n+1}=\left(a X_n+c\right)_{\bmod m} \quad n \geq 0\)
The parameter m=248; hence 48-bit integer arithmetic is performed. Unless lcong48() is invoked, the multiplier
value a and the addend value c are given by:
\(
\begin{aligned}
& a= \text { 5DEECE66D }_{16}=273673163155_8 \\
& c=\mathrm{B}_{16}=13_8
\end{aligned}
\)
The value returned by any of the drand48(), erand48(), jrand48(), lrand48(), mrand48(), or
nrand48() functions is computed by first generating the next 48-bit \(X_{i}\) in the sequence. \(X_{i}\) is then converted
to the return value as follows:
For drand48() and erand48() the value shall be 2-48 times \(X_{i}\).
For jrand48() and mrand48() the value shall be the largest integer not greater than 2-16 times \(X_{i}\).
For lrand48() and nrand48() the value shall be the largest integer not greater than 2-17 times \(X_{i}\).
The drand48(), lrand48(), and mrand48() functions store the last 48-bit \(X_{i}\) generated in an internal
buffer; that is why the application shall ensure that these are initialized prior to being invoked. The erand48(),
nrand48(), and jrand48() functions require the calling program to provide storage for the successive \(X_{i}\) values
in the array specified as an argument when the functions are invoked. That is why these routines do not have to be initialized; the
calling program merely has to place the desired initial value of \(X_{i}\) into the array and pass it as an argument. By using
different arguments, erand48(), nrand48(), and jrand48() allow separate modules of a large program to generate
several independent streams of pseudo-random numbers; that is, the sequence of numbers in each stream shall not
depend upon how many times the routines are called to generate numbers for the other streams.
The initializer function srand48() sets the high-order 32 bits of \(X_{i}\) to the low-order 32 bits contained in its
argument. The low-order 16 bits of \(X_{i}\) are set to the arbitrary value 330E16.
The initializer function seed48() sets the value of \(X_{i}\) to the 48-bit value specified in the argument array. The
low-order 16 bits of \(X_{i}\) are set to the low-order 16 bits of seed16v[0]. The mid-order 16 bits of \(X_{i}\) are
set to the low-order 16 bits of seed16v[1]. The high-order 16 bits of \(X_{i}\) are set to the low-order 16 bits of
seed16v[2]. In addition, the previous value of \(X_{i}\) is copied into a 48-bit internal buffer, used only by
seed48(), and a pointer to this buffer is the value returned by seed48(). This returned pointer, which can just be
ignored if not needed, is useful if a program is to be restarted from a given point at some future time—use the pointer to get at
and store the last \(X_{i}\) value, and then use this value to reinitialize via seed48() when the program is restarted.
The initializer function lcong48() allows the user to specify the initial \(X_{i}\), the multiplier value a, and the
addend value c. Argument array elements param[0-2] specify \(X_{i}\), param[3-5] specify the
multiplier a, and param[6] specifies the 16-bit addend c. After lcong48() is called, a subsequent call to
either srand48() or seed48() shall restore the standard multiplier and addend values, a and c,
specified above.
The drand48(), lrand48(), and mrand48() functions need not be thread-safe.
RETURN VALUE
As described in the DESCRIPTION above.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
The following program tests that the required pseudo-random number generator is used by these functions.
#include
#include
int main() {
{
unsigned short xsubi[3] = {37174, 64810, 11603};
double d = erand48(xsubi);
assert(d >= 0.896);
assert(d = 0.337);
assert(d = 0.647);
assert(d = 0.500);
assert(d = 0.506);
assert(d
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
A note indicating that the drand48(), lrand48(), and mrand48() functions need not be reentrant is added to
the DESCRIPTION.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0083 [743] is applied.
Issue 8
Austin Group Defect 1107 is applied, clarifying how the return value is calculated from  \(X_{i}\) for each function.
Austin Group Defect 1134 is applied, adding getentropy().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ccos.html =====
ccos
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ccos, ccosf, ccosl — complex cosine functions
SYNOPSIS
#include
double complex ccos(double complex z);
float complex ccosf(float complex z);
long double complex ccosl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex cosine of z.
RETURN VALUE
These functions shall return the complex cosine value.
[MXC]
ccos(conj(iz)), ccosf(conjf(iz)), and ccosl(conjl(iz)) shall return
exactly the same value as conj(ccos(iz)), conjf(ccosf(iz)), and
conjl(ccosl(iz)), respectively, and ccos(-iz), ccosf(-iz), and
ccosl(-iz) shall return exactly the same value as ccos(iz), ccosf(iz), and
ccosl(iz), respectively, including for the special values of iz below.
If iz is +0 + i0, 1 + i0 shall be returned.
If iz is +0 + iInf, NaN ± i0 shall be returned and the invalid floating-point exception shall be raised;
the sign of the imaginary part of the result is unspecified.
If iz is +0 + iNaN, NaN ± i0 shall be returned; the sign of the imaginary part of the result is
unspecified.
If iz is x + iInf where x is non-zero and finite, NaN + iNaN shall be returned and the
invalid floating-point exception shall be raised.
If iz is x + iNaN where x is non-zero and finite, NaN + iNaN shall be returned and the
invalid floating-point exception may be raised.
If iz is +Inf + i0, +Inf + i0 shall be returned.
If iz is +Inf + iy where y is non-zero and finite, +Inf (cos(y) + isin(y))
shall be returned.
If iz is +Inf + iInf, ±Inf + iNaN shall be returned and the invalid floating-point exception shall be
raised; the sign of the real part of the result is unspecified.
If iz is +Inf + iNaN, +Inf + iNaN shall be returned.
If iz is NaN + i0, NaN ± i0 shall be returned; the sign of the imaginary part of the result is
unspecified.
If iz is NaN + iy where y is any non-zero number, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If iz is NaN + iNaN, NaN + iNaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The MXC special cases for ccos() are derived from those for ccosh() by
applying the formula ccos(z) = ccosh(iz).
FUTURE DIRECTIONS
None.
SEE ALSO
ccosh(), cacos()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/memccpy.html =====
memccpy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
memccpy — copy bytes in memory
SYNOPSIS
[XSI]  #include
void *memccpy(void *restrict s1, const void *restrict s2,
int c, size_t n);
DESCRIPTION
The memccpy() function shall copy bytes from memory area s2 into s1, stopping after the first occurrence of
byte c (converted to an unsigned char) is copied, or after n bytes are copied, whichever comes first. If
copying takes place between objects that overlap, the behavior is undefined.
The memccpy() function shall not change the setting of errno on valid input.
RETURN VALUE
The memccpy() function shall return a pointer to the byte after the copy of c in s1, or a null pointer if
c was not found in the first n bytes of s2.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The memccpy() function does not check for the overflow of the receiving memory area.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The restrict keyword is added to the memccpy() prototype for alignment with the ISO/IEC 9899:1999
standard.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that memccpy() does not change the setting of errno on
valid input.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/tcgetwinsize.html =====
tcgetwinsize
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
tcgetwinsize — get the size of a terminal window
SYNOPSIS
#include
int tcgetwinsize(int fildes, struct winsize *winsize_p);
DESCRIPTION
The tcgetwinsize() function shall get the terminal window size associated with the terminal referred to by fildes
and store it in the winsize structure pointed to by winsize_p. The fildes argument is an open file descriptor
associated with a terminal. The winsize_p argument is a pointer to a winsize structure.
If the terminal referred to by fildes was opened without O_TTY_INIT and is not a pseudo-terminal, and the terminal window
size has not been set by a call to tcsetwinsize(), the terminal window size is
unspecified.
If the terminal was opened with O_TTY_INIT or is a pseudo-terminal, and the terminal window size has not been set by a call to
tcsetwinsize(), the terminal window size shall be set to an appropriate default
(see open()).
If the terminal window size has been set by a call to tcsetwinsize(), the
values set by that call shall be returned.
RETURN VALUE
Upon successful completion, 0 shall be returned. Otherwise, -1 shall be returned and errno set to indicate the error.
ERRORS
The tcgetwinsize() function shall fail if:
[EBADF]
The fildes argument is not a valid file descriptor.
[ENOTTY]
The file associated with fildes is not a terminal.
The following sections are informative.
EXAMPLES
#include
#include
#include
#include
#include
#include
#include
static volatile sig_atomic_t vrow;
static volatile sig_atomic_t vcol;
static volatile sig_atomic_t newsize;
static void winch_handler(int signum)
{
struct winsize ws;
int sav_errno = errno;
(void)signum; // prevent compiler warning that signum is unused
// set volatile vars to new winsize, or 0 if unavailable or
// too large
if (tcgetwinsize(STDERR_FILENO, &ws) == -1)
{
vrow = vcol = 0;
}
else
{
if (ws.ws_row
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcsrtombs.html =====
wcsrtombs
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcsnrtombs, wcsrtombs — convert a wide-character string to a character string (restartable)
SYNOPSIS
#include
[CX]  size_t wcsnrtombs(char *restrict dst, const wchar_t **restrict
src,
size_t nwc, size_t len, mbstate_t *restrict
ps);
size_t wcsrtombs(char *restrict dst, const wchar_t **restrict src,
size_t len, mbstate_t *restrict ps);
DESCRIPTION
For wcsrtombs(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The wcsrtombs() function shall convert a sequence of wide characters from the array indirectly pointed to by src
into a sequence of corresponding characters, beginning in the conversion state described by the object pointed to by ps. If
dst is not a null pointer, the converted characters shall then be stored into the array pointed to by dst. Conversion
continues up to and including a terminating null wide character, which shall also be stored. Conversion shall stop earlier in the
following cases:
When a code is reached that does not correspond to a valid character
When the next character would exceed the limit of len total bytes to be stored in the array pointed to by dst (and
dst is not a null pointer)
Each conversion shall take place as if by a call to the wcrtomb() function.
If dst is not a null pointer, the pointer object pointed to by src shall be assigned either a null pointer (if
conversion stopped due to reaching a terminating null wide character) or the address just past the last wide character converted
(if any). If conversion stopped due to reaching a terminating null wide character, the resulting state described shall be the
initial conversion state.
If ps is a null pointer, the wcsrtombs() function shall use its own internal mbstate_t object, which is
initialized at program start-up to the initial conversion state. Otherwise, the mbstate_t object pointed to by ps
shall be used to completely describe the current conversion state of the associated character sequence.
If called with a null ps argument, the wcsrtombs() function need not be thread-safe; however, such calls shall
avoid data races with calls to wcsrtombs() with a non-null argument and with calls to all other functions.
[CX]  The
wcsnrtombs() function shall be equivalent to the wcsrtombs() function, except that the conversion is limited to the
first nwc wide characters.
If called with a null ps argument, the wcsnrtombs() function need not be thread-safe; however, such calls shall
avoid data races with calls to wcsnrtombs() with a non-null argument and with calls to all other functions.
These functions shall not change the setting of errno if successful.
The behavior of these functions shall be affected by the LC_CTYPE category of the current locale.
The implementation shall behave as if no function defined in System Interfaces volume of POSIX.1-2024 calls these functions.
RETURN VALUE
If conversion stops because a code is reached that does not correspond to a valid character, an encoding error occurs. In this
case, these functions shall store the value of the macro [EILSEQ] in errno and return (size_t)-1; the conversion
state is undefined. Otherwise, these functions shall return the number of bytes in the resulting character sequence, not including
the terminating null (if any).
ERRORS
These functions shall fail if:
[EILSEQ]
A wide-character code does not correspond to a valid character.
These functions may fail if:
[EINVAL]
[CX]
ps points to an object that contains an invalid conversion state.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
mbsinit(), wcrtomb()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E).
Issue 6
In the DESCRIPTION, a note on using this function in a threaded application is added.
Extensions beyond the ISO C standard are marked.
The normative text is updated to avoid use of the term "must" for application requirements.
The wcsrtombs() prototype is updated for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
Austin Group Interpretation 1003.1-2001 #148 is applied, clarifying that the wcsrtombs() function need not be thread-safe
if called with a NULL ps argument.
Austin Group Interpretation 1003.1-2001 #170 is applied.
The wcsnrtombs() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 1.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0722 [109,105] is applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/tcflow.html =====
tcflow
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
tcflow — suspend or restart the transmission or reception of data
SYNOPSIS
#include
int tcflow(int fildes, int action);
DESCRIPTION
The tcflow() function shall suspend or restart transmission or reception of data on the object referred to by
fildes, depending on the value of action. The fildes argument is an open file descriptor associated with a
terminal.
If action is TCOOFF, output shall be suspended.
If action is TCOON, suspended output shall be restarted.
If action is TCIOFF and fildes refers to a terminal device, the system shall transmit a STOP character, which is
intended to cause the terminal device to stop transmitting data to the system. If fildes is associated with a
pseudo-terminal, the STOP character need not be transmitted.
If action is TCION and fildes refers to a terminal device, the system shall transmit a START character, which is
intended to cause the terminal device to start transmitting data to the system. If fildes is associated with a
pseudo-terminal, the START character need not be transmitted.
The default on the opening of a terminal file is that neither its input nor its output are suspended.
Attempts to use tcflow() from a process which is a member of a background process group on a fildes associated
with its controlling terminal, shall cause the process group to be sent a SIGTTOU signal. If the calling thread is blocking SIGTTOU
signals or the process is ignoring SIGTTOU signals, the process shall be allowed to perform the operation, and no signal is
sent.
RETURN VALUE
Upon successful completion, 0 shall be returned. Otherwise, -1 shall be returned and errno set to indicate the error.
ERRORS
The tcflow() function shall fail if:
[EBADF]
The fildes argument is not a valid file descriptor.
[EINVAL]
The action argument is not a supported value.
[EIO]
The process group of the writing process is orphaned, the calling thread is not blocking SIGTTOU, and the process is not
ignoring SIGTTOU.
[ENOTTY]
The file associated with fildes is not a terminal.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
tcsendbreak()
XBD 11. General Terminal Interface,
CHANGE HISTORY
First released in Issue 3. Included for alignment with the POSIX.1-1988 standard.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The [EIO] error is added.
Issue 7
SD5-XSH-ERN-190 is applied, clarifying in the DESCRIPTION the transmission of START and STOP characters.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0642 [79], XSH/TC1-2008/0643 [79], and XSH/TC1-2008/0644 [79] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_self.html =====
pthread_self
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_self — get the calling thread ID
SYNOPSIS
#include
pthread_t pthread_self(void);
DESCRIPTION
The pthread_self() function shall return the thread ID of the calling thread.
RETURN VALUE
The pthread_self() function shall always be successful and no return value is reserved to indicate an error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The pthread_self() function provides a capability similar to the getpid()
function for processes and the rationale is the same: the creation call does not provide the thread ID to the created thread.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_create(), pthread_equal()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_self() function is marked as part of the Threads option.
Issue 7
Austin Group Interpretation 1003.1-2001 #063 is applied, updating the RETURN VALUE section.
The pthread_self() function is moved from the Threads option to the Base.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/encrypt.html =====
encrypt
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
encrypt — encoding function (CRYPT)
SYNOPSIS
[OB XSI]  #include
void encrypt(char block[64], int edflag);
DESCRIPTION
The encrypt() function shall provide access to an implementation-defined encoding algorithm. The key generated by
setkey() is used to encrypt the string block with encrypt().
The block argument to encrypt() shall be an array of length 64 bytes containing only the bytes with values of 0
and 1. The array is modified in place to a similar array using the key set by setkey(). If edflag is 0, the argument is encoded. If edflag is 1, the argument
may be decoded (see the APPLICATION USAGE section); if the argument is not decoded, errno shall be set to [ENOSYS].
The encrypt() function shall not change the setting of errno if successful. An application wishing to check for
error situations should set errno to 0 before calling encrypt(). If errno is non-zero on return, an error has
occurred.
The encrypt() function need not be thread-safe.
RETURN VALUE
The encrypt() function shall not return a value.
ERRORS
The encrypt() function shall fail if:
[ENOSYS]
The functionality is not supported on this implementation.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The encrypt() function historically used the DES block cipher, which is no longer considered secure.
In some environments, decoding might not be implemented. This is related to some Government restrictions on encryption and
decryption routines. Historical practice has been to ship a different version of the encryption library without the decryption
feature in the routines supplied. Thus the exported version of encrypt() does encoding but not decoding.
RATIONALE
None.
FUTURE DIRECTIONS
The encrypt() function may be removed in a future version.
SEE ALSO
crypt(), setkey()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
A note indicating that this function need not be reentrant is added to the DESCRIPTION.
Issue 6
In the DESCRIPTION, the note about reentrancy is expanded to cover thread-safety.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0085 [899] is applied.
Issue 8
Austin Group Defect 1192 is applied, marking the encrypt() function as obsolescent.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/perror.html =====
perror
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
perror — write error messages to standard error
SYNOPSIS
#include
void perror(const char *s);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The perror() function shall map the error number accessed through the symbol errno to a language-dependent error
message, which shall be written to the standard error stream as follows:
First (if s is not a null pointer and the character pointed to by s is not the null byte), the string pointed to
by s followed by a  and a .
Then an error message string followed by a .
The contents of the error message strings shall be the same as those returned by strerror() with argument errno.
[CX]  The
perror() function shall mark for update the last data modification and last file status change timestamps of the file
associated with the standard error stream at some time between its successful completion and exit(), abort(), or the completion of fflush() or fclose() on stderr.
The perror() function shall not change the orientation of the standard error stream.
On error, perror() shall set the error indicator for the stream to which stderr points, and shall set errno
to indicate the error.
Since no value is returned, an application wishing to check for error situations should call clearerr(stderr)
before calling perror(), then if ferror(stderr) returns non-zero, the value of errno indicates which
error occurred.
RETURN VALUE
The perror() function shall not return a value.
ERRORS
[CX]
Refer to fputc().
The following sections are informative.
EXAMPLES
Printing an Error Message for a Function
The following example replaces bufptr with a buffer that is the necessary size. If an error occurs, the perror()
function prints a message and the program exits.
#include
#include
...
char *bufptr;
size_t szbuf;
...
if ((bufptr = malloc(szbuf)) == NULL) {
perror("malloc"); exit(2);
}
...
APPLICATION USAGE
Application writers may prefer to use alternative interfaces instead of perror(), such as strerror_r() in combination with fprintf().
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
fprintf(), fputc(), psiginfo(), strerror()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
A paragraph is added to the DESCRIPTION indicating that perror() does not change the orientation of the standard error
stream.
Issue 6
Extensions beyond the ISO C standard are marked.
Issue 7
SD5-XSH-ERN-95 is applied.
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0429 [389,401], XSH/TC1-2008/0430 [389], and XSH/TC1-2008/0431 [389,401] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/setresgid.html =====
setresgid
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
setresgid — set real group ID, effective group ID, and saved set-group-ID
SYNOPSIS
[XSI]  #include
int setresgid(gid_t rgid, gid_t egid, gid_t sgid);
DESCRIPTION
The setresgid() function shall set the real group ID, effective group ID, and saved set-group-ID of the calling process
to the values specified by rgid, egid, and sgid, respectively.
If an argument is -1, the corresponding ID shall not be changed.
Only a process with appropriate privileges can set the real group ID, effective group ID, and saved set-group-ID to any valid
value.
A non-privileged process can set its real group ID, effective group ID, and saved set-group-ID, each to one of the values that
it currently holds in its real group ID, effective group ID, or saved set-group-ID.
The real group ID, effective group ID, and saved set-group-ID can be set to different values in the same call.
Any supplementary group IDs of the calling process shall remain unchanged.
RETURN VALUE
Upon successful completion, 0 shall be returned. Otherwise, -1 shall be returned and errno set to indicate the error, and
none of the IDs shall be changed.
ERRORS
The setresgid() function shall fail if:
[EINVAL]
The value of the rgid, egid, or sgid argument is invalid or out-of-range.
[EPERM]
The calling process does not have appropriate privileges and an attempt was made to change the real group ID, effective group
ID, or saved set-group-ID to a value that is not currently present in one of those IDs.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
exec, getegid(), geteuid(), getgid(), getresgid(), getresuid(), getuid(), setegid(), seteuid(), setgid(), setregid(), setresuid(), setreuid(), setuid()
XBD
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strncasecmp_l.html =====
strcasecmp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strcasecmp, strcasecmp_l, strncasecmp, strncasecmp_l — case-insensitive string comparisons
SYNOPSIS
#include
int strcasecmp(const char *s1, const char *s2);
int strcasecmp_l(const char *s1, const char *s2,
locale_t locale);
int strncasecmp(const char *s1, const char *s2, size_t n);
int strncasecmp_l(const char *s1, const char *s2,
size_t n, locale_t locale);
DESCRIPTION
The strcasecmp() and strcasecmp_l() functions shall compare, while ignoring differences in case, the string
pointed to by s1 to the string pointed to by s2. The strncasecmp() and strncasecmp_l() functions shall
compare, while ignoring differences in case, not more than n bytes from the string pointed to by s1 to the string
pointed to by s2.
The strcasecmp() and strncasecmp() functions use the current locale to determine the case of the characters.
The strcasecmp_l() and strncasecmp_l() functions use the locale represented by locale to determine the case
of the characters.
When the LC_CTYPE category of the locale being used is from the POSIX locale, these functions shall behave as if the
strings had been converted to lowercase and then a byte comparison performed, and errno shall not be changed on valid input.
Otherwise, the results are unspecified.
The behavior is undefined if the locale argument to strcasecmp_l() or strncasecmp_l() is the special locale
object LC_GLOBAL_LOCALE or is not a valid locale object handle.
RETURN VALUE
Upon completion, strcasecmp() and strcasecmp_l() shall return an integer greater than, equal to, or less than 0,
if the string pointed to by s1 is, ignoring case, greater than, equal to, or less than the string pointed to by s2,
respectively.
Upon successful completion, strncasecmp() and strncasecmp_l() shall return an integer greater than, equal to, or
less than 0, if the possibly null-terminated array pointed to by s1 is, ignoring case, greater than, equal to, or less than
the possibly null-terminated array pointed to by s2, respectively.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
wcscasecmp()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 7
The strcasecmp() and strncasecmp() functions are moved from the XSI option to the Base.
The strcasecmp_l() and strncasecmp_l() functions are added from The Open Group Technical Standard, 2006, Extended
API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0589 [302], XSH/TC1-2008/0590 [294], XSH/TC1-2008/0591 [283], and
XSH/TC1-2008/0592 [283] are applied.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that errno is not changed on valid input.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/memcpy.html =====
memcpy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
memcpy — copy bytes in memory
SYNOPSIS
#include
void *memcpy(void *restrict s1, const void *restrict s2, size_t n);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The memcpy() function shall copy n bytes from the object pointed to by s2 into the object pointed to by
s1. If copying takes place between objects that overlap, the behavior is undefined.
[CX]  The
memcpy() function shall not change the setting of errno on valid input.
RETURN VALUE
The memcpy() function shall return s1; no return value is reserved to indicate an error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The memcpy() function does not check for the overflow of the receiving memory area.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The memcpy() prototype is updated for alignment with the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that memcpy() does not change the setting of errno on
valid input.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strlen.html =====
strlen
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strlen, strnlen — get length of fixed size string
SYNOPSIS
#include
size_t strlen(const char *s);
[CX]  size_t strnlen(const char *s, size_t maxlen);
DESCRIPTION
For strlen(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The strlen() function shall compute the number of bytes in the string to which s points, not including the
terminating NUL character.
[CX]  The
strnlen() function shall compute the smaller of the number of bytes in the array to which s points, not including any
terminating NUL character, or the value of the maxlen argument. The strnlen() function shall never examine more than
maxlen bytes of the array pointed to by s.
[CX]  The
strlen() and strnlen() functions shall not change the setting of errno on valid input.
RETURN VALUE
The strlen() function shall return the length of s; no return value shall be reserved to indicate an error.
[CX]  The
strnlen() function shall return the number of bytes preceding the first null byte in the array to which s points, if
s contains a null byte within the first maxlen bytes; otherwise, it shall return maxlen.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
Getting String Lengths
The following example sets the maximum length of key and data by using strlen() to get the lengths of those
strings.
#include
...
struct element {
char *key;
char *data;
};
...
char *key, *data;
int len;
*keylength = *datalength = 0;
...
if ((len = strlen(key)) > *keylength)
*keylength = len;
if ((len = strlen(data)) > *datalength)
*datalength = len;
...
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
strlcat(), wcslen()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The RETURN VALUE section is updated to indicate that strlen() returns the length of s, and not s itself as
was previously stated.
Issue 7
The strnlen() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 1.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0344 [560] is applied.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that strlen() and strnlen() do not change the setting of
errno on valid input.
Austin Group Defect 986 is applied, adding strlcat() to the SEE ALSO section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wprintf.html =====
fwprintf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fwprintf, swprintf, wprintf — print formatted wide-character output
SYNOPSIS
#include
#include
int fwprintf(FILE *restrict stream, const wchar_t *restrict format, ...);
int swprintf(wchar_t *restrict ws, size_t n,
const wchar_t *restrict format, ...);
int wprintf(const wchar_t *restrict format, ...);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The fwprintf() function shall place output on the named output stream. The wprintf() function shall place
output on the standard output stream stdout. The swprintf() function shall place output followed by the null wide
character in consecutive wide characters starting at *ws; no more than n wide characters shall be written, including
a terminating null wide character, which is always added (unless n is zero).
Each of these functions shall convert, format, and print its arguments under control of the format wide-character string.
The format is composed of zero or more directives: ordinary wide-characters, which are simply copied to the output
stream, and conversion specifications, each of which results in the fetching of zero or more arguments. The results are
undefined if there are insufficient arguments for the format. If the format is exhausted while arguments remain, the
excess arguments are evaluated but are otherwise ignored.
[CX]
Conversions can be applied to the nth argument after the format in the argument list, rather than to the next unused
argument. In this case, the conversion specifier wide character % (see below) is replaced by the sequence "%n$",
where n is a decimal integer in the range [1,{NL_ARGMAX}], giving the position of the argument in the argument list. This
feature provides for the definition of format wide-character strings that select arguments in an order appropriate to
specific languages (see the EXAMPLES section).
The format can contain either numbered argument conversion specifications (that is, those introduced by
"%n$" and optionally containing the "*m$" forms of field width and precision), or
unnumbered argument conversion specifications (that is, those introduced by the % character and optionally containing the
* form of field width and precision), but not both. The only exception to this is that %% can be mixed with the
"%n$" form. The results of mixing numbered and unnumbered argument specifications in a format
wide-character string are undefined. When numbered argument specifications are used, specifying the Nth argument requires
that all the leading arguments, from the first to the (N-1)th, are specified in the format wide-character string.
In format wide-character strings containing the "%n$" form of conversion specification, numbered
arguments in the argument list can be referenced from the format wide-character string as many times as required.
In format wide-character strings containing the % form of conversion specification, each argument in the
argument list shall be used exactly once. It is unspecified whether an encoding error occurs if the format string contains
wchar_t values that do not correspond to members of the character set of the current locale and the specified semantics do
not require that value to be processed by wcrtomb().
[CX]  All
forms of the fwprintf() function allow for the insertion of a locale-dependent radix character in the output string, output
as a wide-character value. The radix character is defined in the current locale (category LC_NUMERIC ). In the POSIX locale,
or in a locale where the radix character is not defined, the radix character shall default to a  ('.').
Each conversion specification is introduced by the '%' wide character [CX]   or by the
wide-character sequence "%n$",   after
which the following appear in sequence:
Zero or more flags (in any order), which modify the meaning of the conversion specification.
An optional minimum field width. If the converted value has fewer wide characters than the field width, it shall be
padded with  characters by default on the left; it shall be padded on the right, if the left-adjustment flag
('-'), described below, is given to the field width. The field width takes the form of an  ('*'),
[CX]
or in conversion specifications introduced by "%n$" the "*m$" string,
described below, or a decimal integer.
An optional precision that gives the minimum number of digits to appear for the d, i, o,
u, x, and X conversion specifiers; the number of digits to appear after the radix character for the
a, A, e, E, f, and F conversion specifiers; the maximum number of significant
digits for the g and G conversion specifiers; or the maximum number of wide characters to be printed from a
string in the s conversion specifiers. The precision takes the form of a  ('.') followed either by
an  ('*'), [CX]   or in conversion specifications introduced by "%n$" the
"*m$" string,  described below, or an
optional decimal digit string, where a null digit string is treated as 0. If a precision appears with any other conversion wide
character, the behavior is undefined.
An optional length modifier that specifies the size of the argument.
A conversion specifier wide character that indicates the type of conversion to be applied.
A field width, or precision, or both, may be indicated by an  ('*'). In this case an argument of type
int supplies the field width or precision. Applications shall ensure that arguments specifying field width, or precision, or
both appear in that order before the argument, if any, to be converted. A negative field width is taken as a '-' flag
followed by a positive field width. A negative precision is taken as if the precision were omitted. [CX]   In
format wide-character strings containing conversion specifications introduced by "%n$", in addition
to being indicated by the decimal digit string, a field width may be indicated by the sequence "*m$" and
precision by the sequence ".*m$", where m is a decimal integer in the range [1,{NL_ARGMAX}] giving
the position in the argument list (after the format argument) of an integer argument containing the field width or
precision, for example:
wprintf(L"%1$d:%2$.*3$d:%4$.*3$d\n", hour, min, precision, sec);
The flag wide characters and their meanings are:
'
[CX]
(The .) The integer portion of the result of a decimal conversion (%i, %d, %u,
%f, %F, %g, or %G) shall be formatted with thousands' grouping wide characters. For other
conversions, the behavior is undefined. The numeric grouping wide character is used.
-
The result of the conversion shall be left-justified within the field. The conversion shall be right-justified if this flag is
not specified.
+
The result of a signed conversion shall always begin with a sign ('+' or '-'). The conversion shall begin
with a sign only when a negative value is converted if this flag is not specified.
If the first wide character of a signed conversion is not a sign, or if a signed conversion results in no wide characters, a
shall be prefixed to the result. This means that if the  and '+' flags both appear, the
flag shall be ignored.
#
Specifies that the value is to be converted to an alternative form. For o conversion, it shall increase the precision,
if and only if necessary, to force the first digit of the result to be zero (if the value and precision are both 0, a single 0 is
printed). For x or X conversion specifiers, a non-zero result shall have 0x (or 0X) prefixed to it. For
a, A, e, E, f, F, g, and G conversion specifiers, the
result shall always contain a radix character, even if no digits follow it. Without this flag, a radix character appears in the
result of these conversions only if a digit follows it. For g and G conversion specifiers, trailing zeros shall
not be removed from the result as they normally are. For other conversion specifiers, the behavior is undefined.
0
For d, i, o, u, x, X, a, A, e, E,
f, F, g, and G conversion specifiers, leading zeros (following any indication of sign or base)
are used to pad to the field width rather than performing space padding, except when converting an infinity or NaN. If the
'0' and '-' flags both appear, the '0' flag shall be ignored. For d, i, o,
u, x, and X conversion specifiers, if a precision is specified, the '0' flag shall be ignored.
[CX]
If the '0' and  flags both appear, the grouping wide characters are inserted before zero padding.
For other conversions, the behavior is undefined.
The length modifiers and their meanings are:
hh
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a signed char or unsigned char argument (the argument will have been promoted according to the integer
promotions, but its value shall be converted to signed char or unsigned char before printing); or that a following
n conversion specifier applies to a pointer to a signed char argument.
h
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a short or unsigned short argument (the argument will have been promoted according to the integer
promotions, but its value shall be converted to short or unsigned short before printing); or that a following
n conversion specifier applies to a pointer to a short argument.
l (ell)
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a long or unsigned long argument; that a following n conversion specifier applies to a pointer to
a long argument; that a following c conversion specifier applies to a wint_t argument; that a following
s conversion specifier applies to a pointer to a wchar_t argument; or has no effect on a following a,
A, e, E, f, F, g, or G conversion specifier.
ll (ell-ell)
Specifies that a following d, i, o, u, x, or X conversion specifier applies
to a long long or unsigned long long argument; or that a following n conversion specifier applies to a
pointer to a long long argument.
j
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to an intmax_t or uintmax_t argument; or that a following n conversion specifier applies to a
pointer to an intmax_t argument.
z
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a size_t or the corresponding signed integer type argument; or that a following n conversion specifier
applies to a pointer to a signed integer type corresponding to a size_t argument.
t
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a ptrdiff_t or the corresponding unsigned type argument; or that a following n conversion
specifier applies to a pointer to a ptrdiff_t argument.
L
Specifies that a following a, A, e, E, f, F, g, or G
conversion specifier applies to a long double argument.
If a length modifier appears with any conversion specifier other than as specified above, the behavior is undefined.
The conversion specifiers and their meanings are:
d, i
The int argument shall be converted to a signed decimal in the style "[-]dddd". The precision specifies
the minimum number of digits to appear; if the value being converted can be represented in fewer digits, it shall be expanded with
leading zeros. The default precision shall be 1. The result of converting zero with an explicit precision of zero shall be no wide
characters.
o
The unsigned argument shall be converted to unsigned octal format in the style "dddd". The precision specifies
the minimum number of digits to appear; if the value being converted can be represented in fewer digits, it shall be expanded with
leading zeros. The default precision shall be 1. The result of converting zero with an explicit precision of zero shall be no wide
characters.
u
The unsigned argument shall be converted to unsigned decimal format in the style "dddd". The precision
specifies the minimum number of digits to appear; if the value being converted can be represented in fewer digits, it shall be
expanded with leading zeros. The default precision shall be 1. The result of converting zero with an explicit precision of zero
shall be no wide characters.
x
The unsigned argument shall be converted to unsigned hexadecimal format in the style "dddd"; the letters
"abcdef" are used. The precision specifies the minimum number of digits to appear; if the value being converted can be
represented in fewer digits, it shall be expanded with leading zeros. The default precision shall be 1. The result of converting
zero with an explicit precision of zero shall be no wide characters.
X
Equivalent to the x conversion specifier, except that letters "ABCDEF" are used instead of
"abcdef".
f, F
The double argument shall be converted to decimal notation in the style "[-]ddd.ddd", where the number
of digits after the radix character shall be equal to the precision specification. If the precision is missing, it shall be taken
as 6; if the precision is explicitly zero and no '#' flag is present, no radix character shall appear. If a radix
character appears, at least one digit shall appear before it. The value shall be rounded in an implementation-defined manner to the
appropriate number of digits.
A double argument representing an infinity shall be converted in one of the styles "[-]inf" or
"[-]infinity"; which style is implementation-defined. A double argument representing a NaN shall be converted in
one of the styles "[-]nan" or "[-]nan(n-char-sequence)"; which style, and the meaning of any
n-char-sequence, is implementation-defined. The F conversion specifier produces "INF",
"INFINITY", or "NAN" instead of "inf", "infinity", or "nan", respectively.
e, E
The double argument shall be converted in the style "[-]d.ddde±dd", where there shall be one
digit before the radix character (which is non-zero if the argument is non-zero) and the number of digits after it shall be equal
to the precision; if the precision is missing, it shall be taken as 6; if the precision is zero and no '#' flag is
present, no radix character shall appear. The value shall be rounded in an implementation-defined manner to the appropriate number
of digits. The E conversion wide character shall produce a number with 'E' instead of 'e' introducing
the exponent. The exponent shall always contain at least two digits. If the value is zero, the exponent shall be zero.
A double argument representing an infinity or NaN shall be converted in the style of an f or F
conversion specifier.
g, G
The double argument representing a floating-point number shall be converted in the style f or e (or in
the style F or E in the case of a G conversion specifier), depending on the value converted and the
precision. Let P equal the precision if non-zero, 6 if the precision is omitted, or 1 if the precision is zero. Then, if a
conversion with style E would have an exponent of X:
If P>X>=-4, the conversion shall be with style f (or F) and precision
P-(X+1).
Otherwise, the conversion shall be with style e (or E) and precision P-1.
Finally, unless the '#' flag is used, any trailing zeros shall be removed from the fractional portion of the result and
the decimal-point character shall be removed if there is no fractional portion remaining.
A double argument representing an infinity or NaN shall be converted in the style of an f or F
conversion specifier.
a, A
A double argument representing a floating-point number shall be converted in the style
"[-]0xh.hhhhp±d", where there shall be one hexadecimal digit (which is
non-zero if the argument is a normalized floating-point number and is otherwise unspecified) before the decimal-point wide
character and the number of hexadecimal digits after it shall be equal to the precision; if the precision is missing and FLT_RADIX
is a power of 2, then the precision shall be sufficient for an exact representation of the value; if the precision is missing and
FLT_RADIX is not a power of 2, then the precision shall be sufficient to distinguish values of type double, except that
trailing zeros may be omitted; if the precision is zero and the '#' flag is not specified, no decimal-point wide character
shall appear. The letters "abcdef" are used for a conversion and the letters "ABCDEF" for A
conversion. The A conversion specifier produces a number with 'X' and 'P' instead of 'x' and
'p'. The exponent shall always contain at least one digit, and only as many more digits as necessary to represent the
decimal exponent of 2. If the value is zero, the exponent shall be zero.
A double argument representing an infinity or NaN shall be converted in the style of an f or F
conversion specifier.
c
If no l (ell) qualifier is present, the int argument shall be converted to a wide character as if by calling
the btowc() function and the resulting wide character shall be written. Otherwise, the
wint_t argument shall be converted to wchar_t, and written.
s
If no l (ell) qualifier is present, the application shall ensure that the argument is a pointer to a character array
containing a character sequence beginning in the initial shift state. Characters from the array shall be converted as if by
repeated calls to the mbrtowc() function, with the conversion state described by an
mbstate_t object initialized to zero before the first character is converted, and written up to (but not including) the
terminating null wide character. If the precision is specified, no more than that many wide characters shall be written. If the
precision is not specified, or is greater than the size of the array, the application shall ensure that the array contains a null
wide character.
If an l (ell) qualifier is present, the application shall ensure that the argument is a pointer to an array of type
wchar_t. Wide characters from the array shall be written up to (but not including) a terminating null wide character. If no
precision is specified, or is greater than the size of the array, the application shall ensure that the array contains a null wide
character. If a precision is specified, no more than that many wide characters shall be written.
p
The application shall ensure that the argument is a pointer to void. The value of the pointer shall be converted to a
sequence of printable wide characters in an implementation-defined manner.
n
The application shall ensure that the argument is a pointer to an integer into which is written the number of wide characters
written to the output so far by this call to one of the fwprintf() functions. No argument shall be converted, but one shall
be consumed. If the conversion specification includes any flags, a field width, or a precision, the behavior is undefined.
C
[XSI]
Equivalent to lc.
S
[XSI]
Equivalent to ls.
%
Write a '%' wide character; no argument shall be converted. The application shall ensure that the complete conversion
specification is %%.
If a conversion specification does not match one of the above forms, the behavior is undefined.
In no case does a nonexistent or small field width cause truncation of a field; if the result of a conversion is wider than the
field width, the field shall be expanded to contain the conversion result. Characters generated by fwprintf() and
wprintf() shall be printed as if fputwc() had been called.
For a and A conversions, if FLT_RADIX is not a power of 2 and the result is not exactly representable in the
given precision, the result should be one of the two adjacent numbers in hexadecimal floating style with the given precision, with
the extra stipulation that the error should have a correct sign for the current rounding direction.
For e, E, f, F, g, and G conversion specifiers, if the number of
significant decimal digits is at most DECIMAL_DIG, then the result should be correctly rounded. If the number of significant
decimal digits is more than DECIMAL_DIG but the source value is exactly representable with DECIMAL_DIG digits, then the result
should be an exact representation with trailing zeros. Otherwise, the source value is bounded by two adjacent decimal strings
L , ,
CHANGE HISTORY
First released in Issue 5. Included for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E).
Issue 6
The Open Group Corrigendum U040/1 is applied to the RETURN VALUE section, describing the case if n or more wide
characters are requested to be written using swprintf().
The normative text is updated to avoid use of the term "must" for application requirements.
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The prototypes for fwprintf(), swprintf(), and wprintf() are updated.
The DESCRIPTION is updated.
The hh, ll, j, t, and z length modifiers are added.
The a, A, and F conversion characters are added.
XSI shading is removed from the description of character string representations of infinity and NaN floating-point values.
The DESCRIPTION is updated to use the terms "conversion specifier" and "conversion specification" consistently.
ISO/IEC 9899:1999 standard, Technical Corrigendum 1 is incorporated.
Issue 7
Austin Group Interpretation 1003.1-2001 #161 is applied, updating the DESCRIPTION of the 0 flag.
Austin Group Interpretation 1003.1-2001 #170 is applied.
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #68 (SD5-XSH-ERN-70) is applied, revising the description of g
and G.
Functionality relating to the "%n$" form of conversion specification and the  flag is moved from the
XSI option to the Base.
The [EOVERFLOW] error is added for swprintf().
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0226 [302] and XSH/TC1-2008/0227 [14] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0144 [73], XSH/TC2-2008/0145 [894], XSH/TC2-2008/0146 [557], and
XSH/TC2-2008/0147 [936] are applied.
Issue 8
Austin Group Defect 1021 is applied, changing "output error" to "error" in the RETURN VALUE section and changing the
requirements for [EOVERFLOW].
Austin Group Defect 1137 is applied, clarifying the use of "%n$" and "*m$" in
conversion specifications.
Austin Group Defect 1205 is applied, changing the description of the % conversion specifier.
Austin Group Defect 1219 is applied, changing the swprintf()-specific [EOVERFLOW] error.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fchdir.html =====
fchdir
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fchdir — change working directory
SYNOPSIS
#include
int fchdir(int fildes);
DESCRIPTION
The fchdir() function shall be equivalent to chdir() except that the
directory that is to be the new current working directory is specified by the file descriptor fildes.
A conforming application can obtain a file descriptor for a file of type directory using open(), provided that the file status flags and access modes do not contain O_WRONLY or
O_RDWR.
RETURN VALUE
Upon successful completion, fchdir() shall return 0. Otherwise, it shall return -1 and set errno to indicate the
error. On failure the current working directory shall remain unchanged.
ERRORS
The fchdir() function shall fail if:
[EACCES]
Search permission is denied for the directory referenced by fildes.
[EBADF]
The fildes argument is not an open file descriptor.
[ENOTDIR]
The open file descriptor fildes does not refer to a directory.
The fchdir() may fail if:
[EINTR]
A signal was caught during the execution of fchdir().
[EIO]
An I/O error occurred while reading from or writing to the file system.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
chdir(), dirfd()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 7
The fchdir() function is moved from the XSI option to the Base.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/posix_spawn.html =====
posix_spawn
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
posix_spawn, posix_spawnp — spawn a process (ADVANCED REALTIME)
SYNOPSIS
[SPN]  #include
int posix_spawn(pid_t *restrict pid, const char *restrict path,
const posix_spawn_file_actions_t *restrict file_actions,
const posix_spawnattr_t *restrict attrp,
char *const argv[restrict], char *const envp[restrict]);
int posix_spawnp(pid_t *restrict pid, const char *restrict file,
const posix_spawn_file_actions_t *restrict file_actions,
const posix_spawnattr_t *restrict attrp,
char *const argv[restrict], char *const envp[restrict]);
DESCRIPTION
The posix_spawn() and posix_spawnp() functions shall create a new process (child process) from the specified
process image. The new process image shall be constructed from a regular executable file called the new process image file.
When a C program is executed as the result of this call, it shall be entered as a C-language function call as follows:
int main(int argc, char *argv[]);
where argc is the argument count and argv is an array of character pointers to the arguments themselves. In
addition, the following variable:
extern char **environ;
shall be initialized as a pointer to an array of character pointers to the environment strings.
The argument argv is an array of character pointers to null-terminated strings. The last member of this array shall be a
null pointer and is not counted in argc. These strings constitute the argument list available to the new process image. The
value in argv[0] should point to a filename string that is associated with the process image being started by the
posix_spawn() or posix_spawnp() function.
The argument envp is an array of character pointers to null-terminated strings. These strings constitute the environment
for the new process image. The environment array is terminated by a null pointer.
The number of bytes available for the combined argument and environment lists of the child process is {ARG_MAX}. The
implementation shall specify in the system documentation (see XBD 2.
Conformance) whether any list overhead, such as length words, null terminators, pointers, or alignment bytes, is included
in this total.
The path argument to posix_spawn() is a pathname that identifies the new process image file to execute; if the
pathname does not start with a , it shall be interpreted relative to the working directory of the child process after
all file_actions have been performed.
The file parameter to posix_spawnp() shall be used to construct a pathname that identifies the new process image
file. If the file parameter contains a  character, the file parameter shall be used as the pathname for
the new process image file. Otherwise, the path prefix for this file shall be obtained by a search of the directories passed as the
environment variable PATH (see XBD 8. Environment Variables), using
the working directory of the child process after all file_actions have been performed. If this environment variable is not
defined, the results of the search are implementation-defined. However, if at least one of the exec family of functions would fail with [ENOEXEC] because the process image contents are not
executable, this shall cause posix_spawnp() to fail rather than attempting a fallback to invoking the process as a shell
script passed to sh.
If file_actions is a null pointer, then file descriptors open in the calling process shall remain open in the child
process, except for those whose FD_CLOEXEC or FD_CLOFORK flag is set (see fcntl()),
and except for file descriptors that are closed by a fork handler (if fork handlers are called). For those file descriptors that
remain open, the child process shall not inherit any process-owned file locks, but all remaining attributes of the corresponding
open file descriptions (see fcntl()), shall remain unchanged. The current working
directory of the child process shall be the same as it is in the parent process.
If file_actions is not a null pointer, then the file descriptors open in the child process shall be those open in the
calling process as modified by FD_CLOFORK file descriptor flags, fork handlers (if they are called), the spawn file actions object
pointed to by file_actions, and the FD_CLOEXEC flag of each remaining open file descriptor after the spawn file actions have
been processed. The effective order of processing the spawn file actions shall be:
The set of open file descriptors for the child process shall initially be the same set as is open for the calling process,
except for those that have the FD_CLOFORK flag set and any that are closed by fork handlers (if they are called). The child process
shall not inherit any file locks, but all remaining attributes of the corresponding open file descriptions (see fcntl()), shall remain unchanged.
The signal mask, signal default actions, and the effective user and group IDs for the child process shall be changed as
specified in the attributes object referenced by attrp.
The file actions specified by the spawn file actions object shall be performed in the order in which they were added to the
spawn file actions object, and relative pathnames in a given action shall be interpreted in relation to the tracked working
directory. The tracked working directory shall begin with the current working directory of the parent process, and can be altered
according to chdir or fchdir file actions; the current working directory of the child process shall be the final
state of the tracked working directory after all file actions have been applied.
Any file descriptor that has its FD_CLOEXEC flag set shall be closed.
If file descriptor 0, 1, or 2 would otherwise be closed in the new process image created by posix_spawn() or
posix_spawnp(), implementations may open an unspecified file for the file descriptor in the new process image. If a standard
utility or a conforming application is executed with file descriptor 0 not open for reading or with file descriptor 1 or 2 not open
for writing, the environment in which the utility or application is executed shall be deemed non-conforming, and consequently the
utility or application might not behave as described in this standard.
The posix_spawnattr_t spawn attributes object type is defined in . It shall contain at least the attributes defined below.
If the POSIX_SPAWN_SETPGROUP flag is set in the spawn-flags attribute of the object referenced by attrp, and the
spawn-pgroup attribute of the same object is non-zero, then the child's process group shall be as specified in the
spawn-pgroup attribute of the object referenced by attrp.
As a special case, if the POSIX_SPAWN_SETPGROUP flag is set in the spawn-flags attribute of the object referenced by
attrp, and the spawn-pgroup attribute of the same object is set to zero, then the child shall be in a new process
group with a process group ID equal to its process ID.
If the POSIX_SPAWN_SETSID flag is set in the spawn-flags attribute of the object referenced by attrp, the child
process shall be the session leader of a new session, shall be the process group leader of a new process group, and shall have no
controlling terminal. The process group ID of the child process shall be set equal to the process ID of the child process. The
child process shall be the only process in the new process group and the only process in the new session.
If both the POSIX_SPAWN_SETPGROUP flag and the POSIX_SPAWN_SETSID flag are set in the spawn-flags attribute of the object
referenced by attrp, the behavior is unspecified.
If neither the POSIX_SPAWN_SETPGROUP flag nor the POSIX_SPAWN_SETSID flag is set in the spawn-flags attribute of the
object referenced by attrp, the new child process shall inherit the parent's process group.
[PS]  If
the POSIX_SPAWN_SETSCHEDPARAM flag is set in the spawn-flags attribute of the object referenced by attrp, but
POSIX_SPAWN_SETSCHEDULER is not set, the new process image shall initially have the scheduling policy of the calling process with
the scheduling parameters specified in the spawn-schedparam attribute of the object referenced by attrp.
If the POSIX_SPAWN_SETSCHEDULER flag is set in the spawn-flags attribute of the object referenced by attrp
(regardless of the setting of the POSIX_SPAWN_SETSCHEDPARAM flag), the new process image shall initially have the scheduling policy
specified in the spawn-schedpolicy attribute of the object referenced by attrp and the scheduling parameters
specified in the spawn-schedparam attribute of the same object.
The POSIX_SPAWN_RESETIDS flag in the spawn-flags attribute of the object referenced by attrp governs the effective
user ID of the child process. If this flag is not set, the child process shall inherit the effective user ID of the parent process.
If this flag is set, the effective user ID of the child process shall be reset to the parent's real user ID. In either case, if the
set-user-ID mode bit of the new process image file is set, the effective user ID of the child process shall become that file's
owner ID before the new process image begins execution.
The POSIX_SPAWN_RESETIDS flag in the spawn-flags attribute of the object referenced by attrp also governs the
effective group ID of the child process. If this flag is not set, the child process shall inherit the effective group ID of the
parent process. If this flag is set, the effective group ID of the child process shall be reset to the parent's real group ID. In
either case, if the set-group-ID mode bit of the new process image file is set, the effective group ID of the child process shall
become that file's group ID before the new process image begins execution.
If the POSIX_SPAWN_SETSIGMASK flag is set in the spawn-flags attribute of the object referenced by attrp, the
child process shall initially have the signal mask specified in the spawn-sigmask attribute of the object referenced by
attrp.
If the POSIX_SPAWN_SETSIGDEF flag is set in the spawn-flags attribute of the object referenced by attrp, the
signals specified in the spawn-sigdefault attribute of the same object shall be set to their default actions in the child
process. Signals set to the default action in the parent process shall be set to the default action in the child process.
Signals set to be caught by the calling process shall be set to the default action in the child process.
Except for SIGCHLD, signals set to be ignored by the calling process image shall be set to be ignored by the child process,
unless otherwise specified by the POSIX_SPAWN_SETSIGDEF flag being set in the spawn-flags attribute of the object referenced
by attrp and the signals being indicated in the spawn-sigdefault attribute of the object referenced by
attrp.
If the SIGCHLD signal is set to be ignored by the calling process, it is unspecified whether the SIGCHLD signal is set to be
ignored or to the default action in the child process, unless otherwise specified by the POSIX_SPAWN_SETSIGDEF flag being set in
the spawn_flags attribute of the object referenced by attrp and the SIGCHLD signal being indicated in the
spawn_sigdefault attribute of the object referenced by attrp.
If the value of the attrp pointer is a null pointer, then the default values are used.
All process attributes, other than those influenced by the attributes set in the object referenced by attrp as specified
above or by the file descriptor manipulations specified in file_actions, shall appear in the new process image as though
fork() had been called to create a child process and then a member of the exec family of functions had been called by the child process to execute the new process
image.
It is implementation-defined whether the fork handlers are run when posix_spawn() or posix_spawnp() is called.
RETURN VALUE
Upon successful completion, posix_spawn() and posix_spawnp() shall return the process ID of the child process to
the parent process, in the variable pointed to by a non-null pid argument, and shall return zero as the function return
value. Otherwise, no child process shall be created, the value stored into the variable pointed to by a non-null pid is
unspecified, and an error number shall be returned as the function return value to indicate the error. If the pid argument
is a null pointer, the process ID of the child is not returned to the caller.
ERRORS
These functions may fail if:
[EINVAL]
The value specified by file_actions or attrp is invalid.
If this error occurs after the calling process successfully returns from the posix_spawn() or posix_spawnp()
function, the child process may exit with exit status 127.
If posix_spawn() or posix_spawnp() fail for any of the reasons that would cause fork() or one of the exec family of functions to
fail, including when the corresponding exec function would attempt a fallback to
sh instead of failing with [ENOEXEC], an error value shall be returned as described by
fork() and exec, respectively; or, if the
error occurs after the calling process successfully returns, the child process shall exit with exit status 127.
If POSIX_SPAWN_SETPGROUP is set in the spawn-flags attribute of the object referenced by attrp, and
posix_spawn() or posix_spawnp() fails while changing the child's process group, an error value shall be returned as
described by setpgid(); or, if the error occurs after the calling process
successfully returns, the child process shall exit with exit status 127.
If POSIX_SPAWN_SETSID is set in the spawn-flags attribute of the object referenced by attrp, and
posix_spawn() or posix_spawnp() fails while creating the new session, changing the child's session ID, or changing
the child's process group, an error value shall be returned as described by setsid();
or, if the error occurs after the calling process successfully returns, the child process shall exit with exit status 127.
[PS]  If
POSIX_SPAWN_SETSCHEDPARAM is set and POSIX_SPAWN_SETSCHEDULER is not set in the spawn-flags attribute of the object
referenced by attrp, then if posix_spawn() or posix_spawnp() fails for any of the reasons that would cause
sched_setparam() to fail, an error value shall be returned as described by
sched_setparam(); or, if the error occurs after the calling process
successfully returns, the child process shall exit with exit status 127.
If POSIX_SPAWN_SETSCHEDULER is set in the spawn-flags attribute of the object referenced by attrp, and if
posix_spawn() or posix_spawnp() fails for any of the reasons that would cause sched_setscheduler() to fail, an error value shall be returned as described by
sched_setscheduler(); or, if the error occurs after the calling process
successfully returns, the child process shall exit with exit status 127.
If the file_actions argument is not a null pointer, and specifies any chdir, close, dup2,
fchdir, or open actions to be performed, and if posix_spawn() or posix_spawnp() fails for any of the
reasons that would cause chdir(), close(), dup2(), fchdir(), or open() to fail, other than
attempting a close() on a file descriptor that is in range but already closed, an
error value shall be returned as described by chdir(), close(), dup2(), fchdir(), and open(), respectively; or, if the
error occurs after the calling process successfully returns, the child process shall exit with exit status 127. An open file action
may, by itself, result in any of the errors described by close() or dup2(), in addition to those described by open().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
These functions are part of the Spawn option and need not be provided on all implementations.
See also the APPLICATION USAGE section for exec.
RATIONALE
The posix_spawn() function and its close relation posix_spawnp() have been introduced to overcome the following perceived
difficulties with fork(): the fork()
function is difficult or impossible to implement without swapping or dynamic address translation.
Swapping is generally too slow for a realtime environment.
Dynamic address translation is not available everywhere that POSIX might be useful.
Processes are too useful to simply option out of POSIX whenever it must run without address translation or other MMU
services.
Thus, POSIX needs process creation and file execution primitives that can be efficiently implemented without address translation
or other MMU services.
The posix_spawn() function is implementable as a library routine, but both posix_spawn() and posix_spawnp()
are designed as kernel operations. Also, although they may be an efficient replacement for many fork()/exec pairs, their goal is to provide useful process creation primitives for
systems that have difficulty with fork(), not to provide drop-in replacements for
fork()/exec.
This view of the role of posix_spawn() and posix_spawnp() influenced the design of their API. It does not attempt
to provide the full functionality of fork()/exec in which arbitrary
user-specified operations of any sort are permitted between the creation of the child process and the execution of the new process
image; any attempt to reach that level would need to provide a programming language as parameters. Instead, posix_spawn()
and posix_spawnp() are process creation primitives like the Start_Process and Start_Process_Search Ada
language bindings package POSIX_Process_Primitives and also like those in many operating systems that are not UNIX systems,
but with some POSIX-specific additions.
To achieve its coverage goals, posix_spawn() and posix_spawnp() have control of seven types of inheritance: file
descriptors, current working directory, process group ID, user and group ID, signal mask, scheduling, and whether each signal
ignored in the parent will remain ignored in the child, or be reset to its default action in the child.
Control of file descriptors is required to allow an independently written child process image to access data streams opened by
and even generated or read by the parent process without being specifically coded to know which parent files and file descriptors
are to be used. Control of the current working directory is required because the parent process may want to constrain the resources
that the child process can reach from its current working directory or affect how relative pathnames are interpreted, while
recognizing that a multi-threaded parent process would require a lot of overhead to safely change its own working directory prior
to creating the child process. Control of the process group ID is required to control how the job control of the child process
relates to that of the parent.
Control of the signal mask and signal defaulting is sufficient to support the implementation of system(). Although support for system() is not
explicitly one of the goals for posix_spawn() and posix_spawnp(), it is covered under the "at least 50%" coverage
goal.
The intention is that the normal file descriptor inheritance across fork(), the
subsequent effect of the specified spawn file actions, and the normal file descriptor inheritance across one of the exec family of functions should fully specify open file inheritance. The implementation need make
no decisions regarding the set of open file descriptors when the child process image begins execution, those decisions having
already been made by the caller and expressed as the set of open file descriptors and their FD_CLOEXEC and FD_CLOFORK flags at the
time of the call, the actions of fork handlers (if they are called), and the spawn file actions object specified in the call. We
have been assured that in cases where the POSIX Start_Process Ada primitives have been implemented in a library, this method
of controlling file descriptor inheritance may be implemented very easily.
We can identify several problems with posix_spawn() and posix_spawnp(), but there does not appear to be a solution
that introduces fewer problems. Environment modification for child process attributes not specifiable via the attrp or
file_actions arguments must be done in the parent process, and since the parent generally wants to save its context, it is
more costly than similar functionality with fork()/exec. It is also complicated
to modify the environment of a multi-threaded process temporarily, since all threads must agree when it is safe for the environment
to be changed. However, this cost is only borne by those invocations of posix_spawn() and posix_spawnp() that use the
additional functionality. Since extensive modifications are not the usual case, and are particularly unlikely in time-critical
code, keeping much of the environment control out of posix_spawn() and posix_spawnp() is appropriate design.
The posix_spawn() and posix_spawnp() functions do not have all the power of fork()/exec. This is to be expected. The fork() function is a wonderfully powerful operation. We do not expect to duplicate its
functionality in a simple, fast function with no special hardware requirements. It is worth noting that posix_spawn() and
posix_spawnp() are very similar to the process creation operations on many operating systems that are not UNIX systems.
Requirements
The requirements for posix_spawn() and posix_spawnp() are:
They must be implementable without an MMU or unusual hardware.
They must be compatible with existing POSIX standards.
Additional goals are:
They should be efficiently implementable.
They should be able to replace at least 50% of typical executions of fork().
A system with posix_spawn() and posix_spawnp() and without fork()
should be useful, at least for realtime applications.
A system with fork() and the exec family
should be able to implement posix_spawn() and posix_spawnp() as library routines.
Two-Syntax
POSIX exec has several calling sequences with approximately the same functionality.
These appear to be required for compatibility with existing practice. Since the existing practice for the posix_spawn*()
functions is otherwise substantially unlike POSIX, we feel that simplicity outweighs compatibility. There are, therefore, only two
names for the posix_spawn*() functions.
The parameter list does not differ between posix_spawn() and posix_spawnp(); posix_spawnp() interprets the
second parameter more elaborately than posix_spawn().
Compatibility with POSIX.5 (Ada)
The Start_Process and Start_Process_Search procedures from the POSIX_Process_Primitives package from the
Ada language binding to POSIX.1 encapsulate fork() and exec functionality in a manner similar to that of posix_spawn() and posix_spawnp().
Originally, in keeping with our simplicity goal, the standard developers had limited the capabilities of posix_spawn() and
posix_spawnp() to a subset of the capabilities of Start_Process and Start_Process_Search; certain non-default
capabilities were not supported. However, based on suggestions by the ballot group to improve file descriptor mapping or drop it,
and on the advice of an Ada Language Bindings working group member, the standard developers decided that posix_spawn() and
posix_spawnp() should be sufficiently powerful to implement Start_Process and Start_Process_Search. The
rationale is that if the Ada language binding to such a primitive had already been approved as an IEEE standard, there can be
little justification for not approving the functionally-equivalent parts of a C binding. The only three capabilities provided by
posix_spawn() and posix_spawnp() that are not provided by Start_Process and Start_Process_Search are
optionally specifying the child's process group ID, the set of signals to be reset to default signal handling in the child process,
and the child's scheduling policy and parameters.
For the Ada language binding for Start_Process to be implemented with posix_spawn(), that binding would need to
explicitly pass an empty signal mask and the parent's environment to posix_spawn() whenever the caller of
Start_Process allowed these arguments to default, since posix_spawn() does not provide such defaults. The ability of
Start_Process to mask user-specified signals during its execution is functionally unique to the Ada language binding and
must be dealt with in the binding separately from the call to posix_spawn().
Process Group
The process group inheritance field can be used to join the child process with an existing process group. By assigning a value
of zero to the spawn-pgroup attribute of the object referenced by attrp, the setpgid() mechanism will place the child process in a new process group.
Threads
Without the posix_spawn() and posix_spawnp() functions, systems without address translation can still use threads
to give an abstraction of concurrency. In many cases, thread creation suffices, but it is not always a good substitute. The
posix_spawn() and posix_spawnp() functions are considerably "heavier" than thread creation. Processes have several
important attributes that threads do not. Even without address translation, a process may have base-and-bound memory protection.
Each process has a process environment including security attributes and file capabilities, and powerful scheduling attributes.
Processes abstract the behavior of non-uniform-memory-architecture multi-processors better than threads, and they are more
convenient to use for activities that are not closely linked.
The posix_spawn() and posix_spawnp() functions may not bring support for multiple processes to every
configuration. Process creation is not the only piece of operating system support required to support multiple processes. The total
cost of support for multiple processes may be quite high in some circumstances. Existing practice shows that support for multiple
processes is uncommon and threads are common among "tiny kernels". There should, therefore, probably continue to be AEPs for
operating systems with only one process.
Asynchronous Error Notification
A library implementation of posix_spawn() or posix_spawnp() may not be able to detect all possible errors before
it forks the child process. POSIX.1-2024 provides for an error indication returned from a child process which could not
successfully complete the spawn operation via a special exit status which may be detected using the status value returned by
wait(), waitid(), and waitpid().
The stat_val interface and the macros used to interpret it are not well suited to the purpose of returning API errors,
but they are the only path available to a library implementation. Thus, an implementation may cause the child process to exit with
exit status 127 for any error detected during the spawn process after the posix_spawn() or posix_spawnp() function
has successfully returned.
The standard developers had proposed using two additional macros to interpret stat_val. The first, WIFSPAWNFAIL, would
have detected a status that indicated that the child exited because of an error detected during the posix_spawn() or
posix_spawnp() operations rather than during actual execution of the child process image; the second, WSPAWNERRNO, would
have extracted the error value if WIFSPAWNFAIL indicated a failure. Unfortunately, the ballot group strongly opposed this because
it would make a library implementation of posix_spawn() or posix_spawnp() dependent on kernel modifications to
waitpid() to be able to embed special information in stat_val to indicate a
spawn failure.
The 8 bits of child process exit status that are guaranteed by POSIX.1-2024 to be accessible to the waiting parent process are
insufficient to disambiguate a spawn error from any other kind of error that may be returned by an arbitrary process image. No
other bits of the exit status are required to be visible in stat_val, so these macros could not be strictly implemented at
the library level. Reserving an exit status of 127 for such spawn errors is consistent with the use of this value by system() and popen() to signal failures in these
operations that occur after the function has returned but before a shell is able to execute. The exit status of 127 does not
uniquely identify this class of error, nor does it provide any detailed information on the nature of the failure. Note that a
kernel implementation of posix_spawn() or posix_spawnp() is permitted (and encouraged) to return any possible error
as the function value, thus providing more detailed failure information to the parent process.
Thus, no special macros are available to isolate asynchronous posix_spawn() or posix_spawnp() errors. Instead,
errors detected by the posix_spawn() or posix_spawnp() operations in the context of the child process before the new
process image executes are reported by setting the child's exit status to 127. The calling process may use the WIFEXITED and
WEXITSTATUS macros on the stat_val stored by the wait() or waitpid() functions to detect spawn failures to the extent that other status values with
which the child process image may exit (before the parent can conclusively determine that the child process image has begun
execution) are distinct from exit status 127.
FUTURE DIRECTIONS
None.
SEE ALSO
alarm(), chmod(),
close(), dup(), exec, exit(), fcntl(), fork(), fstatat(), kill(), open(), posix_spawn_file_actions_addchdir(), posix_spawn_file_actions_addclose(), posix_spawn_file_actions_adddup2(), posix_spawn_file_actions_destroy(), posix_spawnattr_destroy(), posix_spawnattr_getsigdefault(), posix_spawnattr_getflags(), posix_spawnattr_getpgroup(), posix_spawnattr_getschedparam(), posix_spawnattr_getschedpolicy(), posix_spawnattr_getsigmask(), sched_setparam(), sched_setscheduler(), setpgid()
, setsid(), setuid(), times(), wait(), waitid()
XBD 8. Environment Variables,
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1d-1999.
IEEE PASC Interpretation 1003.1 #103 is applied, noting that the signal default actions are changed as well as the signal mask
in step 2.
IEEE PASC Interpretation 1003.1 #132 is applied.
Issue 7
Functionality relating to the Threads option is moved to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0433 [291], XSH/TC1-2008/0434 [173], and XSH/TC1-2008/0435 [173] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0255 [824] is applied.
Issue 8
Austin Group Defect 370 is applied, requiring that attempting to close a file descriptor that is in range but already closed is
not treated as an error.
Austin Group Defect 768 is applied, adding OFD-owned file locks.
Austin Group Defect 1044 is applied, adding POSIX_SPAWN_SETSID.
Austin Group Defect 1208 is applied, adding posix_spawn_file_actions_addchdir() and posix_spawn_file_actions_addfchdir().
Austin Group Defect 1318 is applied, adding FD_CLOFORK and clarifying that the inherited set of file descriptors is affected by
the actions of fork handlers (if they are called).
Austin Group Defect 1328 is applied, adding the restrict keyword to the third parameter of posix_spawn() and
posix_spawnp().
Austin Group Defect 1362 is applied, removing parentheses around some text intended to be normative.
Austin Group Defect 1674 is applied, adding a requirement that posix_spawnp() does not fallback to executing sh when the corresponding exec function would do so
instead of failing with [ENOEXEC].
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/inet_ntop.html =====
inet_ntop
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
inet_ntop, inet_pton — convert IPv4 and IPv6 addresses between binary and text form
SYNOPSIS
#include
const char *inet_ntop(int af, const void *restrict src,
char *restrict dst, socklen_t size);
int inet_pton(int af, const char *restrict src, void *restrict dst);
DESCRIPTION
The inet_ntop() function shall convert a numeric address into a text string suitable for presentation. The af
argument shall specify the family of the address. This can be AF_INET [IP6]
or AF_INET6.  The src argument points to a buffer holding an IPv4 address if the af argument is AF_INET,
[IP6]
or an IPv6 address if the af argument is AF_INET6;  the
address needs to be in network byte order. The dst argument points to a buffer where the function stores the resulting text
string; it shall not be NULL. The size argument specifies the size of this buffer, which shall be large enough to hold the
text string (INET_ADDRSTRLEN characters for IPv4, [IP6]   INET6_ADDRSTRLEN characters for IPv6).
The inet_pton() function shall convert an address in its standard text presentation form into its numeric binary form.
The af argument shall specify the family of the address. The AF_INET [IP6]   and AF_INET6
address families shall be supported. The src argument points
to the string being passed in. The dst argument points to a buffer into which the function stores the numeric address; this
shall be large enough to hold the numeric address (32 bits for AF_INET, [IP6]
128 bits for AF_INET6).
If the af argument of inet_pton() is AF_INET, the src string shall be in the standard IPv4 dotted-decimal
form:
ddd.ddd.ddd.ddd
where "ddd" is a one to three digit decimal number between 0 and 255. Leading zeros shall be allowed. The
inet_pton() function does not accept other formats (such as the octal numbers, hexadecimal numbers, and fewer than four
numbers that inet_addr() accepts).
[IP6]
If the af argument of inet_pton() is AF_INET6, the src string shall be in one of the following standard IPv6
text forms:
The preferred form is "x:x:x:x:x:x:x:x", where the 'x's are the hexadecimal values of the eight 16-bit pieces
of the address. Leading zeros in individual fields can be omitted, but there shall be one to four hexadecimal digits in every
field.
A string of contiguous zero fields in the preferred form can be shown as "::". The "::" can only appear once
in an address. Unspecified addresses ("0:0:0:0:0:0:0:0") may be represented simply as "::".
A third form that is sometimes more convenient when dealing with a mixed environment of IPv4 and IPv6 nodes is
"x:x:x:x:x:x:d.d.d.d", where the 'x's are the hexadecimal values of the six high-order 16-bit pieces of the
address, and the 'd's are the decimal values of the four low-order 8-bit pieces of the address (standard IPv4
representation).
Note:
A more extensive description of the standard representations of IPv6 addresses can be found in RFC 4291.
RETURN VALUE
The inet_ntop() function shall return a pointer to the buffer containing the text string if the conversion succeeds, and
NULL otherwise, and set errno to indicate the error.
The inet_pton() function shall return 1 if the conversion succeeds, with the address pointed to by dst in network
byte order. It shall return 0 if the input is not a valid IPv4 dotted-decimal string [IP6]   or a valid
IPv6 address string,  or -1 with errno set to [EAFNOSUPPORT]
if the af argument is unknown.
ERRORS
The inet_ntop() and inet_pton() functions shall fail if:
[EAFNOSUPPORT]
The af argument is invalid.
[ENOSPC]
The size of the inet_ntop() result buffer is inadequate.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
inet_addr()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
IPv6 extensions are marked.
The restrict keyword is added to the inet_ntop() and inet_pton() prototypes for alignment with the
ISO/IEC 9899:1999 standard.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/29 is applied, adding "the address must be in network byte
order" to the end of the fourth sentence of the first paragraph in the DESCRIPTION.
Issue 7
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0178 [777] is applied.
Issue 8
Austin Group Defect 1102 is applied, removing a reference to the inet_addr()
page from the DESCRIPTION.
Austin Group Defect 1573 is applied, clarifying that leading zeros are allowed in the IPv4 dotted-decimal form accepted by
inet_pton().
Austin Group Defect 1685 is applied, updating RFC references.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getwc.html =====
getwc
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getwc — get a wide character from a stream
SYNOPSIS
#include
#include
wint_t getwc(FILE *stream);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The getwc() function shall be equivalent to fgetwc(), except that if it is
implemented as a macro it may evaluate stream more than once, so the argument should never be an expression with
side-effects.
RETURN VALUE
Refer to fgetwc().
ERRORS
Refer to fgetwc().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Since it may be implemented as a macro, getwc() may treat incorrectly a stream argument with side-effects. In
particular, getwc(*f++) does not necessarily work as expected. Therefore, use of this function is not recommended;
fgetwc() should be used instead.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fgetwc()
XBD ,
CHANGE HISTORY
First released as a World-wide Portability Interface in Issue 4. Derived from the MSE working draft.
Issue 5
The Optional Header (OH) marking is removed from .
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0270 [14] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/catopen.html =====
catopen
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
catopen — open a message catalog
SYNOPSIS
#include
nl_catd catopen(const char *name, int oflag);
DESCRIPTION
The catopen() function shall open a message catalog and return a message catalog descriptor. The name argument
specifies the name of the message catalog to be opened. If name contains a '/', then name specifies a
pathname for the message catalog. Otherwise, [XSI]   the environment variable NLSPATH is used with name
substituted for the %N conversion specification (see XBD 8. Environment
Variables); if NLSPATH exists in the environment when the process starts, then if the process has appropriate
privileges, the behavior of catopen() is undefined. If NLSPATH does not exist in the environment, or if a message
catalog cannot be found in any of the components specified by NLSPATH , then   an implementation-defined default path shall be used. This default may be affected by the setting
of LC_MESSAGES if the value of oflag is NL_CAT_LOCALE, or the LANG environment variable if oflag is 0.
[XSI]  When
searching NLSPATH , catopen() shall ignore any files it finds that are not
valid message catalog files.
A message catalog descriptor shall remain valid in a process until that process closes it, or a successful call to one of the
exec functions. A change in the setting of the LC_MESSAGES category may
invalidate existing open catalogs.
If a file descriptor is used to implement message catalog descriptors, the FD_CLOEXEC flag shall be set; see .
If the value of the oflag argument is 0, the LANG environment variable is used to locate the catalog without
regard to the LC_MESSAGES category. If the oflag argument is NL_CAT_LOCALE, the LC_MESSAGES category is used
to locate the message catalog (see XBD 8.2 Internationalization Variables
).
RETURN VALUE
Upon successful completion, catopen() shall return a message catalog descriptor for use on subsequent calls to catgets() and catclose(). Otherwise,
catopen() shall return (nl_catd) -1 and set errno to indicate the error.
ERRORS
The catopen() function may fail if:
[EACCES]
Search permission is denied for the component of the path prefix of the message catalog or read permission is denied for the
message catalog.
[EMFILE]
All file descriptors available to the process are currently open.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
[ENFILE]
Too many files are currently open in the system.
[ENOENT]
The name argument contains a '/' and does not name an existing message catalog, the name argument does
not contain a '/' and searching [XSI]  NLSPATH (if set) and then   the implementation-defined default path for a message catalog with that name failed, one or more
files exist but all are of an invalid format, or the name argument points to an empty string.
[ENOMEM]
Insufficient storage space is available.
[ENOTDIR]
A component of the path prefix of the message catalog names an existing file that is neither a directory nor a symbolic link to
a directory, or the pathname of the message catalog contains at least one non- character and ends with one or more
trailing  characters and the last pathname component names an existing file that is neither a directory nor a symbolic
link to a directory.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Some implementations of catopen() use malloc() to allocate space for
internal buffer areas. The catopen() function may fail if there is insufficient storage space available to accommodate these
buffers.
Conforming applications must assume that message catalog descriptors are not valid after a call to one of the exec functions.
Application developers should be aware that guidelines for the location of message catalogs have not yet been developed.
Therefore they should take care to avoid conflicting with catalogs used by other applications and the standard utilities.
To be sure that messages produced by an application running with appropriate privileges cannot be used by an attacker setting an
unexpected value for NLSPATH in the environment to confuse a system administrator, such applications should use pathnames
containing a '/' to get defined behavior when using catopen() to open a message catalog.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
catclose(), catgets()
XBD 8. Environment Variables, , ,
CHANGE HISTORY
First released in Issue 2.
Issue 7
Austin Group Interpretation 1003.1-2001 #143 is applied.
SD5-XBD-ERN-4 is applied, changing the definition of the [EMFILE] error.
The catopen() function is moved from the XSI option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0045 [324] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0054 [645], XSH/TC2-2008/0055 [497], and XSH/TC2-2008/0056 [497] are
applied.
Issue 8
Austin Group Defect 1122 is applied, clarifying that catopen() ignores files that are not valid message catalog files
when performing an NLSPATH search.
Austin Group Defect 1516 is applied, adding XSI shading to text relating to NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getline.html =====
getdelim
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getdelim, getline — read a delimited record from stream
SYNOPSIS
[CX]  #include
ssize_t getdelim(char **restrict lineptr, size_t *restrict n,
int delimiter, FILE *restrict stream);
ssize_t getline(char **restrict lineptr, size_t *restrict n,
FILE *restrict stream);
DESCRIPTION
The getdelim() function shall read from stream until it encounters a character matching the delimiter
character. The delimiter argument is an int, the value of which the application shall ensure is a character
representable as an unsigned char of equal value that terminates the read process. If the delimiter argument has any
other value, the behavior is undefined.
The application shall ensure that *lineptr is a valid argument that could be passed to the free() function. If *n is non-zero, the application shall ensure that *lineptr
either points to an object of size at least *n bytes, or is a null pointer.
If *lineptr is a null pointer or if the object pointed to by *lineptr is of insufficient size, an object shall be
allocated as if by malloc() or the object shall be reallocated as if by realloc(), respectively, such that the object is large enough to hold the characters to be
written to it, including the terminating NUL, and *n shall be set to the new size. If the object was allocated, or if the
reallocation operation moved the object, *lineptr shall be updated to point to the new object or new location. The
characters read, including any delimiter, shall be stored in the object, and a terminating NUL added when the delimiter or
end-of-file is encountered.
The getline() function shall be equivalent to the getdelim() function with the delimiter character equal to
the  character.
The getdelim() and getline() functions may mark the last data access timestamp of the file associated with
stream for update. The last data access timestamp shall be marked for update by the first successful execution of fgetc(), fgets(), fread(), fscanf(), getc(), getchar(), getdelim(),
getline(), or scanf() using stream that returns data not supplied by a
prior call to ungetc().
RETURN VALUE
Upon successful completion, the getline() and getdelim() functions shall return the number of bytes written into
the buffer, including the delimiter character if one was encountered before EOF, but excluding the terminating NUL character. If
the end-of-file indicator for the stream is set, or if no characters were read and the stream is at end-of-file, the end-of-file
indicator for the stream shall be set and the function shall return -1. If an error occurs, the error indicator for the stream
shall be set, and the function shall return -1 and set errno to indicate the error.
ERRORS
For the conditions under which the getdelim() and getline() functions shall fail and may fail, refer to fgetc().
In addition, these functions shall fail if:
[EINVAL]
lineptr or n is a null pointer.
[ENOMEM]
Insufficient memory is available.
These functions may fail if:
[EOVERFLOW]
The number of bytes to be written into the buffer, including the delimiter character (if encountered), would exceed
{SSIZE_MAX}.
The following sections are informative.
EXAMPLES
#include
#include
int main(void)
{
FILE *fp;
char *line = NULL;
size_t len = 0;
ssize_t read;
fp = fopen("/etc/motd", "r");
if (fp == NULL)
exit(1);
while ((read = getline(&line, &len, fp)) != -1) {
printf("Retrieved line of length %zu :\n", read);
printf("%s", line);
}
if (ferror(fp)) {
/* handle error */
}
free(line);
fclose(fp);
return 0;
}
APPLICATION USAGE
Setting *lineptr to a null pointer and *n to zero are allowed and a recommended way to start parsing a file.
The ferror() or feof() functions
should be used to distinguish between an error condition and an end-of-file condition.
Although a null terminator is always supplied after the line, note that strlen(*lineptr) will be smaller than the
return value if the line contains embedded NUL characters.
RATIONALE
These functions are widely used to solve the problem that the fgets() function has
with long lines. The functions automatically enlarge the target buffers if needed. These are especially useful since they reduce
code needed for applications.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fgetc(), fgets(), free(), malloc(), realloc()
XBD
CHANGE HISTORY
First released in Issue 7.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0237 [14] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0153 [569], XSH/TC2-2008/0154 [571], and XSH/TC2-2008/0155 [570] are
applied.
Issue 8
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
Austin Group Defect 1621 is applied, changing "NUL terminator" to "null terminator".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strfmon_l.html =====
strfmon
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strfmon, strfmon_l — convert monetary value to a string
SYNOPSIS
#include
ssize_t strfmon(char *restrict s, size_t maxsize,
const char *restrict format, ...);
ssize_t strfmon_l(char *restrict s, size_t maxsize,
locale_t locale, const char *restrict format,
...);
DESCRIPTION
The strfmon() function shall place characters into the array pointed to by s as controlled by the string pointed
to by format. No more than maxsize bytes are placed into the array.
The format is a character string, beginning and ending in its initial state, if any, that contains two types of objects:
plain characters, which are simply copied to the output stream, and conversion specifications, each of which shall
result in the fetching of zero or more arguments which are converted and formatted. The results are undefined if there are
insufficient arguments for the format. If the format is exhausted while arguments remain, the excess arguments are simply
ignored.
The application shall ensure that a conversion specification consists of the following sequence:
A '%' character
Optional flags
Optional field width
Optional left precision
Optional right precision
A required conversion specifier character that determines the conversion to be performed
The strfmon_l() function shall be equivalent to the strfmon() function, except that the locale data used is from
the locale represented by locale.
Flags
One or more of the following optional flags can be specified to control the conversion:
=f
An '=' followed by a single character f which is used as the numeric fill character. In order to work with
precision or width counts, the fill character shall be a single byte character; if not, the behavior is undefined. The default
numeric fill character is the . This flag does not affect field width filling which always uses the .
This flag is ignored unless a left precision (see below) is specified.
^
Do not format the currency amount with grouping characters. The default is to insert the grouping characters if defined for the
current locale.
+ or (
Specify the style of representing positive and negative currency amounts. Only one of '+' or '(' may be
specified.
If '+' is specified, the locale's positive_sign and negative_sign values shall be used (for example, in
many locales, the empty string if positive and '-' if negative). However, if both values would be returned by localeconv() as empty strings, strfmon() shall fail. The placement of the signs
(if not empty) shall depend on the locale settings:
For the n conversion specifier, the placement specified by the locale's p_sign_posn and n_sign_posn
values shall be used.
For the i conversion specifier, the placement specified by the locale's int_p_sign_posn and
int_n_sign_posn values shall be used.
If a sign's placement cannot be determined from these locale values because a value that needs to be used would be returned by
localeconv() as 0 or {CHAR_MAX}, the sign shall be placed as if the relevant
value was 1.
If '(' is specified, negative amounts shall be enclosed within parentheses and the locale's positive_sign and
negative_sign values shall not be used.
If neither flag is specified, the style used shall depend on the locale settings:
For the n conversion specifier, the style specified by the locale's p_sign_posn and n_sign_posn values
shall be used.
For the i conversion specifier, the style specified by the locale's int_p_sign_posn and int_n_sign_posn
values shall be used.
If the style cannot be determined from these locale values because a value that needs to be used would be returned by localeconv() as {CHAR_MAX}, the style used shall be that specified for the '+'
flag; if this would cause strfmon() to fail because the locale's positive_sign and negative_sign values would
both be returned by localeconv() as empty strings, strfmon() shall behave
as if the negative_sign value was the string "-".
!
Suppress the currency symbol from the output conversion.
-
Specify the alignment. If this flag is present the result of the conversion is left-justified (padded to the right) rather than
right-justified. This flag shall be ignored unless a field width (see below) is specified.
Field Width
w
A decimal digit string w specifying a minimum field width in bytes in which the result of the conversion is
right-justified (or left-justified if the flag '-' is specified). The default is 0.
Left Precision
#n
A '#' followed by a decimal digit string n specifying a maximum number of digits expected to be formatted to
the left of the radix character. This option can be used to keep the formatted output from multiple calls to the strfmon()
function aligned in the same columns. It can also be used to fill unused positions with a special character as in
"$***123.45". This option causes an amount to be formatted as if it has the number of digits specified by n. If
more than n digit positions are required, this conversion specification is ignored. Digit positions in excess of those
actually required are filled with the numeric fill character (see the =f flag above).
If grouping has not been suppressed with the '^' flag, and it is defined for the current locale, grouping separators
are inserted before the fill characters (if any) are added. Grouping separators are not applied to fill characters even if the fill
character is a digit.
To ensure alignment, any characters appearing before or after the number in the formatted output such as currency or sign
symbols are padded as necessary with  characters to make their positive and negative formats an equal length.
Right Precision
.p
A  followed by a decimal digit string p specifying the number of digits after the radix character. If the
value of the right precision p is 0, no radix character appears. If a right precision is not included, a default specified
by the current locale is used. The amount being formatted is rounded to the specified number of digits prior to formatting.
Conversion Specifier Characters
The conversion specifier characters and their meanings are:
i
The double argument is formatted according to the locale's international currency format (for example, in the US: USD
1,234.56). If the argument is ±Inf or NaN, the result of the conversion is unspecified.
n
The double argument is formatted according to the locale's national currency format (for example, in the US: $1,234.56).
If the argument is ±Inf or NaN, the result of the conversion is unspecified.
%
Convert to a '%'; no argument is converted. The entire conversion specification shall be %%.
Locale Information
The LC_MONETARY category of the current locale affects the behavior of this function including the monetary radix
character (which may be different from the numeric radix character affected by the LC_NUMERIC category), the grouping
separator, the currency symbols, and formats. The international currency symbol should be conformant with the ISO 4217:2015
standard.
If the value of maxsize is greater than {SSIZE_MAX}, the result is implementation-defined.
The behavior is undefined if the locale argument to strfmon_l() is the special locale object LC_GLOBAL_LOCALE or
is not a valid locale object handle.
RETURN VALUE
If all conversions are successful and the total number of resulting bytes including the terminating null byte is not more than
maxsize, these functions shall return the number of bytes placed into the array pointed to by s, not including the
terminating NUL character. Otherwise, -1 shall be returned, the contents of the array are unspecified, and errno shall be
set to indicate the error.
ERRORS
These functions shall fail if:
[E2BIG]
Conversion stopped due to lack of space in the buffer.
[EINVAL]
The '+' flag was included in a conversion specification and the locale's positive_sign and negative_sign
values would both be returned by localeconv() as empty strings.
The following sections are informative.
EXAMPLES
Given a locale for the US and the values 123.45, -123.45, and 3456.781, the following output might be produced. Square brackets
("[]") are used in this example to delimit the output.
%n         [$123.45]         Default formatting
[-$123.45]
[$3,456.78]
%11n       [    $123.45]     Right align within an 11-character field
[   -$123.45]
[  $3,456.78]
%#5n       [ $   123.45]     Aligned columns for values up to 99999
[-$   123.45]
[ $ 3,456.78]
%=*#5n     [ $***123.45]     Specify a fill character
[-$***123.45]
[ $*3,456.78]
%=0#5n     [ $000123.45]     Fill characters do not use grouping
[-$000123.45]     even if the fill character is a digit
[ $03,456.78]
%^#5n      [ $  123.45]      Disable the grouping separator
[-$  123.45]
[ $ 3456.78]
%^#5.0n    [ $  123]         Round off to whole units
[-$  123]
[ $ 3457]
%^#5.4n    [ $  123.4500]    Increase the precision
[-$  123.4500]
[ $ 3456.7810]
%(#5n      [ $   123.45 ]    Use an alternative pos/neg style
[($   123.45)]
[ $ 3,456.78 ]
%!(#5n     [    123.45 ]     Disable the currency symbol
[(   123.45)]
[  3,456.78 ]
%-14#5.4n  [ $   123.4500 ]  Left-justify the output
[-$   123.4500 ]
[ $ 3,456.7810 ]
%14#5.4n   [  $   123.4500]  Corresponding right-justified output
[ -$   123.4500]
[  $ 3,456.7810]
See also the EXAMPLES section in fprintf().
APPLICATION USAGE
The '+' flag should be used with care, because if the locale's positive_sign and negative_sign values are
both empty strings, there is no way to distinguish negative from positive values with signs and therefore strfmon() fails.
If the application has a preference for signs but parentheses are acceptable, it should try strfmon() with the '+'
flag first, and if it fails with [EINVAL] then repeat the call without the '+' flag.
RATIONALE
The [EINVAL] error condition applies only when the '+' flag is used because this flag indicates that the application
requires the use of signs, and if there are no signs in the locale data then this requirement cannot be satisfied. When neither
'+' nor '(' is used, the application is requesting whatever formatting is appropriate for the locale, and so
strfmon() has a fallback of using a '-' sign for negative values in cases where the locale data does not indicate
parentheses should be used and has no signs.
FUTURE DIRECTIONS
Lowercase conversion characters are reserved for future standards use and uppercase for implementation-defined use.
SEE ALSO
fprintf(), localeconv()
XBD
CHANGE HISTORY
First released in Issue 4.
Issue 5
Moved from ENHANCED I18N to BASE.
The [ENOSYS] error is removed.
Text is added to the DESCRIPTION warning about values of maxsize that are greater than {SSIZE_MAX}.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
The restrict keyword is added to the strfmon() prototype for alignment with the ISO/IEC 9899:1999
standard.
The EXAMPLES section is reworked, clarifying the output format.
Issue 7
SD5-XSH-ERN-29 is applied, updating the examples for %(#5n and %!(#5n.
SD5-XSH-ERN-233 is applied, changing the definition of the '+' or '(' flags to refer to multiple locales.
The strfmon() function is moved from the XSI option to the Base.
The strfmon_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0602 [302], XSH/TC1-2008/0603 [283], and XSH/TC1-2008/0604 [283] are
applied.
Issue 8
Austin Group Defect 1199 is applied, changing the requirements for the '+' and '(' flags and adding the
[EINVAL] error.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strtold.html =====
strtod
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strtod, strtof, strtold — convert a string to a double-precision number
SYNOPSIS
#include
double strtod(const char *restrict nptr, char **restrict endptr);
float strtof(const char *restrict nptr, char **restrict endptr);
long double strtold(const char *restrict nptr, char **restrict endptr);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall convert the initial portion of the string pointed to by nptr to double, float, and
long double representation, respectively. First, they decompose the input string into three parts:
An initial, possibly empty, sequence of white-space bytes
A subject sequence interpreted as a floating-point constant or representing infinity or NaN
A final string of one or more unrecognized characters, including the terminating NUL character of the input string
Then they shall attempt to convert the subject sequence to a floating-point number, and return the result.
The expected form of the subject sequence is an optional '+' or '-' sign, then one of the following:
A non-empty sequence of decimal digits optionally containing a radix character; then an optional exponent part consisting of the
character 'e' or the character 'E', optionally followed by a '+' or '-' character, and then
followed by one or more decimal digits
A 0x or 0X, then a non-empty sequence of hexadecimal digits optionally containing a radix character; then an optional binary
exponent part consisting of the character 'p' or the character 'P', optionally followed by a '+' or
'-' character, and then followed by one or more decimal digits
One of INF or INFINITY, ignoring case
One of NAN or NAN(n-char-sequenceopt), ignoring case in the NAN part, where:
n-char-sequence:
digit
nondigit
n-char-sequence digit
n-char-sequence nondigit
The subject sequence is defined as the longest initial subsequence of the input string, starting with the first non-white-space
byte, that is of the expected form. The subject sequence contains no characters if the input string is not of the expected
form.
If the subject sequence has the expected form for a floating-point number, the sequence of characters starting with the first
digit or the decimal-point character (whichever occurs first) shall be interpreted as a floating constant of the C language, except
that the radix character shall be used in place of a period, and that if neither an exponent part nor a radix character appears in
a decimal floating-point number, or if a binary exponent part does not appear in a hexadecimal floating-point number, an exponent
part of the appropriate type with value zero is assumed to follow the last digit in the string. If the subject sequence begins with
a , the sequence shall be interpreted as negated. A character sequence INF or INFINITY shall be interpreted as
an infinity, if representable in the return type, else as if it were a floating constant that is too large for the range of the
return type. A character sequence NAN or NAN(n-char-sequenceopt) shall be interpreted as a quiet
NaN, if supported in the return type, else as if it were a subject sequence part that does not have the expected form; the meaning
of the n-char sequences is implementation-defined. A pointer to the final string is stored in the object pointed to by
endptr, provided that endptr is not a null pointer.
If the subject sequence has the hexadecimal form and FLT_RADIX is a power of 2, the value resulting from the conversion is
correctly rounded.
[CX]  The
radix character is defined in the current locale (category LC_NUMERIC ). In the POSIX locale, or in a locale where the radix
character is not defined, the radix character shall default to a  ('.').
In other than the C [CX]   or POSIX  locale, additional
locale-specific subject sequence forms may be accepted.
If the subject sequence is empty or does not have the expected form, no conversion shall be performed; the value of nptr
is stored in the object pointed to by endptr, provided that endptr is not a null pointer.
These functions shall not change the setting of errno if successful.
Since 0 is returned on error and is also a valid return on success, an application wishing to check for error situations should
set errno to 0, then call strtod(), strtof(), or strtold(), then check errno.
RETURN VALUE
Upon successful completion, these functions shall return the converted value. If no conversion could be performed, 0 shall be
returned, and errno may be set to [EINVAL].
If the correct value would cause an overflow and default rounding is in effect, ±HUGE_VAL, ±HUGE_VALF, or ±HUGE_VALL shall be
returned (according to the sign of the value), and errno shall be set to [ERANGE].
If the correct value would cause an underflow, a value whose magnitude is no greater than the smallest normalized positive
number in the return type shall be returned [CX]   and errno set to [ERANGE].
ERRORS
These functions shall fail if:
[ERANGE]
The value to be returned would cause overflow and default rounding is in effect [CX]   or the value
to be returned would cause underflow.
These functions may fail if:
[EINVAL]
[CX]  No
conversion could be performed.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
If the subject sequence has the hexadecimal form and FLT_RADIX is not a power of 2, and the result is not exactly representable,
the result should be one of the two numbers in the appropriate internal format that are adjacent to the hexadecimal floating source
value, with the extra stipulation that the error should have a correct sign for the current rounding direction.
If the subject sequence has the decimal form and at most DECIMAL_DIG (defined in ) significant digits, the result should be correctly rounded. If the subject
sequence D has the decimal form and more than DECIMAL_DIG significant digits, consider the two bounding, adjacent decimal
strings L and U, both having DECIMAL_DIG significant digits, such that the values of L, D, and U
satisfy L ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate that errno is not changed if the function is successful.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the RETURN VALUE and ERRORS sections, the [EINVAL] optional error condition is added if no conversion could be performed.
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The strtod() function is updated.
The strtof() and strtold() functions are added.
The DESCRIPTION is extensively revised.
ISO/IEC 9899:1999 standard, Technical Corrigendum 1 is incorporated.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/61 is applied, correcting the second paragraph in the RETURN
VALUE section. This change clarifies the sign of the return value.
Issue 7
Austin Group Interpretation 1003.1-2001 #015 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0610 [302], XSH/TC1-2008/0611 [94], and XSH/TC1-2008/0612 [105] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0348 [584] and XSH/TC2-2008/0349 [796] are applied.
Issue 8
Austin Group Defect 1163 is applied, clarifying the handling of white space in the input string.
Austin Group Defect 1213 is applied, correcting some typographic errors in the APPLICATION USAGE section.
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1686 is applied, adding CX shading to some text in the RETURN VALUE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/setenv.html =====
setenv
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
setenv — add or change environment variable
SYNOPSIS
[CX]  #include
int setenv(const char *envname, const char *envval, int overwrite);
DESCRIPTION
The setenv() function shall update or add a variable in the environment of the calling process. The envname
argument points to a string containing the name of an environment variable to be added or altered. The environment variable shall
be set to the value to which envval points. The function shall fail if envname points to a string which contains an
'=' character. If the environment variable named by envname already exists and the value of overwrite is
non-zero, the function shall return success and the environment shall be updated. If the environment variable named by
envname already exists and the value of overwrite is zero, the function shall return success and the environment
shall remain unchanged.
The setenv() function shall update the list of pointers to which environ points.
The strings described by envname and envval are copied by this function.
The setenv() function need not be thread-safe.
RETURN VALUE
Upon successful completion, zero shall be returned. Otherwise, -1 shall be returned, errno set to indicate the error, and
the environment shall be unchanged.
ERRORS
The setenv() function shall fail if:
[EINVAL]
The envname argument points to an empty string or points to a string containing an '=' character.
[ENOMEM]
Insufficient memory was available to add a variable or its value to the environment.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
See exec() for restrictions on changing the environment in multi-threaded
applications.
RATIONALE
Unanticipated results may occur if setenv() changes the external variable environ. In particular, if the optional
envp argument to main() is present, it is not changed, and thus may point to an obsolete copy of the environment (as
may any other copy of environ). However, other than the aforementioned restriction, the standard developers intended that
the traditional method of walking through the environment by way of the environ pointer must be supported.
It was decided that setenv() should be required by this version because it addresses a piece of missing functionality,
and does not impose a significant burden on the implementor.
There was considerable debate as to whether the System V putenv() function or the
BSD setenv() function should be required as a mandatory function. The setenv() function was chosen because it
permitted the implementation of the unsetenv() function to delete environmental
variables, without specifying an additional interface. The putenv() function is
available as part of the XSI option.
The standard developers considered requiring that setenv() indicate an error when a call to it would result in exceeding
{ARG_MAX}. The requirement was rejected since the condition might be temporary, with the application eventually reducing the
environment size. The ultimate success or failure depends on the size at the time of a call to exec, which returns an indication of this error condition.
See also the RATIONALE section in getenv().
FUTURE DIRECTIONS
None.
SEE ALSO
exec, getenv(), putenv(), unsetenv()
XBD , ,
CHANGE HISTORY
First released in Issue 6. Derived from the IEEE P1003.1a draft standard.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/55 is applied, adding references to exec in the APPLICATION USAGE and SEE ALSO sections.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0549 [167], XSH/TC1-2008/0550 [185], XSH/TC1-2008/0551 [167], and
XSH/TC1-2008/0552 [38] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/setlogmask.html =====
closelog
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
closelog, openlog, setlogmask, syslog — control system log
SYNOPSIS
[XSI]  #include
void closelog(void);
void openlog(const char *ident, int logopt, int facility);
int setlogmask(int maskpri);
void syslog(int priority, const char *message, ... /* arguments */);
DESCRIPTION
The syslog() function shall send a message to an implementation-defined logging facility, which may log it in an
implementation-defined system log, write it to the system console, forward it to a list of users, or forward it to the logging
facility on another host over the network. The logged message shall include a message header and a message body. The message header
contains at least a timestamp and a tag string.
The message body is generated from the message and following arguments in the same manner as if these were arguments to
printf(), except that the additional conversion specification %m shall be
recognized; it shall convert no arguments, shall cause the output of the error message string associated with the value of
errno on entry to syslog(), and may be mixed with argument specifications of the "%n$" form.
If a complete conversion specification with the m conversion specifier character is not just %m, the behavior is
undefined. A trailing  may be added if needed.
Values of the priority argument are formed by OR'ing together a severity-level value and an optional facility value. If
no facility value is specified, the current default facility value is used.
Possible values of severity level include:
LOG_EMERG
A panic condition.
LOG_ALERT
A condition that should be corrected immediately, such as a corrupted system database.
LOG_CRIT
Critical conditions, such as hard device errors.
LOG_ERR
Errors.
LOG_WARNING
Warning messages.
LOG_NOTICE
Conditions that are not error conditions, but that may require special handling.
LOG_INFO
Informational messages.
LOG_DEBUG
Messages that contain information normally of use only when debugging a program.
The facility indicates the application or system component generating the message. Possible facility values include:
LOG_USER
Messages generated by arbitrary processes. This is the default facility identifier if none is specified.
LOG_LOCAL0
Reserved for local use.
LOG_LOCAL1
Reserved for local use.
LOG_LOCAL2
Reserved for local use.
LOG_LOCAL3
Reserved for local use.
LOG_LOCAL4
Reserved for local use.
LOG_LOCAL5
Reserved for local use.
LOG_LOCAL6
Reserved for local use.
LOG_LOCAL7
Reserved for local use.
The openlog() function shall set process attributes that affect subsequent calls to syslog(). The ident
argument is a a pointer to a null-terminated identifier that shall be prepended (without the null terminator) to every message. The
application shall ensure that the string pointed to by ident remains valid during the syslog() calls that will
prepend this identifier; however, it is unspecified whether changes made to the string will change the identifier prepended by
later syslog() calls. The logopt argument indicates logging options. Values for logopt are constructed by a
bitwise-inclusive OR of zero or more of the following:
LOG_PID
Log the process ID with each message. This is useful for identifying specific processes.
LOG_CONS
Write messages to the system console if they cannot be sent to the logging facility. The syslog() function ensures that
the process does not acquire the console as a controlling terminal in the process of writing the message.
LOG_NDELAY
Open the connection to the logging facility immediately. Normally the open is delayed until the first message is logged. This
is useful for programs that need to manage the order in which file descriptors are allocated.
LOG_ODELAY
Delay open until syslog() is called.
LOG_NOWAIT
Do not wait for child processes that may have been created during the course of logging the message. This option should be used
by processes that enable notification of child termination using SIGCHLD, since syslog() may otherwise block waiting for a
child whose exit status has already been collected.
The facility argument encodes a default facility to be assigned to all messages that do not have an explicit facility
already encoded. The initial default facility is LOG_USER.
The openlog() and syslog() functions may allocate a file descriptor. It is not necessary to call openlog()
prior to calling syslog(). If a file descriptor is allocated, the FD_CLOEXEC flag shall be set; see .
The closelog() function shall close any open file descriptors allocated by previous calls to openlog() or
syslog().
The setlogmask() function shall set the log priority mask for the current process to maskpri and return the
previous mask. If the maskpri argument is 0, the current log mask is not modified. Calls by the current process to
syslog() with a priority not set in maskpri shall be rejected. The default log mask allows all priorities to be
logged. A call to openlog() is not required prior to calling setlogmask().
The LOG_MASK(pri) and LOG_UPTO(pri) macros can be used to ensure a value or range of severity levels is properly
encoded for the setlogmask() maskpri argument in a portable manner. The masks produced by these macros can be OR'ed
or AND'ed with other priority masks (for example,
LOG_UPTO(LOG_WARNING) | LOG_MASK(LOG_DEBUG)
and
LOG_UPTO(LOG_DEBUG) & ~((LOG_MASK(LOG_NOTICE) | LOG_MASK(LOG_INFO))
would produce the same priority mask).
Symbolic constants for use as values of the logopt, facility, priority, and maskpri arguments are
defined in the  header.
RETURN VALUE
The setlogmask() function shall return the previous log priority mask. The closelog(), openlog(), and
syslog() functions shall not return a value.
ERRORS
The openlog() and syslog() functions may fail if:
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum allowable number of files is currently open in the system.
The following sections are informative.
EXAMPLES
Using openlog()
The following example causes subsequent calls to syslog() to log the process ID with each message, and to write messages
to the system console if they cannot be sent to the logging facility.
#include
char *ident = "Process demo";
int logopt = LOG_PID | LOG_CONS;
int facility = LOG_USER;
...
openlog(ident, logopt, facility);
Using setlogmask()
The following example causes subsequent calls to syslog() to accept error messages, and to reject all other messages.
#include
int result;
int mask = LOG_MASK (LOG_ERR);
...
result = setlogmask(mask);
Using syslog
The following example sends the message "This is a message" to the default logging facility, marking the message as an
error message generated by random processes.
#include
char *message = "This is a message";
int priority = LOG_ERR | LOG_USER;
...
syslog(priority, message);
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
fprintf()
XBD ,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/13 is applied, correcting the EXAMPLES section.
Issue 8
Austin Group Defect 368 is applied, adding a requirement for FD_CLOEXEC to be set if a file descriptor is allocated, and adding
the [EMFILE] and [ENFILE] errors.
Austin Group Defect 1033 is applied, adding the LOG_UPTO macro.
Austin Group Defect 1244 is applied, clarifying the handling of the ident argument.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_mutexattr_setpshared.html =====
pthread_mutexattr_getpshared
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_mutexattr_getpshared, pthread_mutexattr_setpshared — get and set the process-shared attribute
SYNOPSIS
[TSH]  #include
int pthread_mutexattr_getpshared(const pthread_mutexattr_t
*restrict attr, int *restrict pshared);
int pthread_mutexattr_setpshared(pthread_mutexattr_t *attr,
int pshared);
DESCRIPTION
The pthread_mutexattr_getpshared() function shall obtain the value of the process-shared attribute from the
attributes object referenced by attr.
The pthread_mutexattr_setpshared() function shall set the process-shared attribute in an initialized attributes
object referenced by attr.
The process-shared attribute is set to PTHREAD_PROCESS_SHARED to permit a mutex to be operated upon by any thread that
has access to the memory where the mutex is allocated, even if the mutex is allocated in memory that is shared by multiple
processes. See 2.9.9 Synchronization Object Copies and Alternative
Mappings for further requirements. The default value of the attribute shall be PTHREAD_PROCESS_PRIVATE.
The behavior is undefined if the value specified by the attr argument to pthread_mutexattr_getpshared() or
pthread_mutexattr_setpshared() does not refer to an initialized mutex attributes object.
RETURN VALUE
Upon successful completion, pthread_mutexattr_setpshared() shall return zero; otherwise, an error number shall be
returned to indicate the error.
Upon successful completion, pthread_mutexattr_getpshared() shall return zero and store the value of the
process-shared attribute of attr into the object referenced by the pshared parameter. Otherwise, an error
number shall be returned to indicate the error.
ERRORS
The pthread_mutexattr_setpshared() function may fail if:
[EINVAL]
The new value specified for the attribute is outside the range of legal values for that attribute.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
If an implementation detects that the value specified by the attr argument to pthread_mutexattr_getpshared() or
pthread_mutexattr_setpshared() does not refer to an initialized mutex attributes object, it is recommended that the function
should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_cond_destroy(), pthread_create(), pthread_mutex_destroy(), pthread_mutexattr_destroy()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_mutexattr_getpshared() and pthread_mutexattr_setpshared() functions are marked as part of the Threads
and Thread Process-Shared Synchronization options.
The restrict keyword is added to the pthread_mutexattr_getpshared() prototype for alignment with the
ISO/IEC 9899:1999 standard.
Issue 7
The pthread_mutexattr_getpshared() and pthread_mutexattr_setpshared() functions are marked only as part of the
Thread Process-Shared Synchronization option as the Threads option is now part of the Base.
The [EINVAL] error for an uninitialized mutex attributes object is removed; this condition results in undefined behavior.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0281 [972] and XSH/TC2-2008/0282 [757] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getwchar.html =====
getwchar
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getwchar — get a wide character from a stdin stream
SYNOPSIS
#include
wint_t getwchar(void);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The getwchar() function shall be equivalent to getwc(stdin).
RETURN VALUE
Refer to fgetwc().
ERRORS
Refer to fgetwc().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
If the wint_t value returned by getwchar() is stored into a variable of type wchar_t and then compared
against the wint_t macro WEOF, the result may be incorrect. Only the wint_t type is guaranteed to be able to
represent any wide character and WEOF.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fgetwc(), getwc()
XBD
CHANGE HISTORY
First released as a World-wide Portability Interface in Issue 4. Derived from the MSE working draft.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0271 [14] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fmod.html =====
fmod
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fmod, fmodf, fmodl — floating-point remainder value function
SYNOPSIS
#include
double fmod(double x, double y);
float fmodf(float x, float y);
long double fmodl(long double x, long double y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall return the floating-point remainder of the division of x by y.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
These functions shall return the value x-i*y, for some integer i such that, if y is non-zero,
the result has the same sign as x and magnitude less than the magnitude of y.
If the correct value would cause underflow, [MXX]   and is not representable,   a range error may occur, and fmod(), modf(),
and fmodl() shall return [MXX]   0.0, or   (if the IEC 60559
Floating-Point option is not supported) an implementation-defined value no greater in magnitude than DBL_MIN, FLT_MIN, and
LDBL_MIN, respectively.
[MX]  If
x or y is NaN, a NaN shall be returned, and none of the conditions below shall be considered.
If y is zero, a domain error shall occur, and a NaN shall be returned.
If x is infinite, a domain error shall occur, and a NaN shall be returned.
If x is ±0 and y is not zero, ±0 shall be returned.
If x is not infinite and y is ±Inf, x shall be returned.
When subnormal results are supported, the returned value shall be exact and shall be independent of the current rounding
direction mode.
ERRORS
These functions shall fail if:
Domain Error
[MX]
The x argument is infinite or y is zero.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
These functions may fail if:
Range Error
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), isnan()
4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The behavior for when the y argument is zero is now defined.
The fmodf() and fmodl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0151 [68], XSH/TC1-2008/0152 [320], and XSH/TC1-2008/0153 [68] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0120 [605] is applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/lsearch.html =====
lsearch
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
lsearch, lfind — linear search and update
SYNOPSIS
[XSI]  #include
void *lsearch(const void *key, void *base, size_t *nelp, size_t
width,
int (*compar)(const void *, const void *));
void *lfind(const void *key, const void *base, size_t *nelp,
size_t width, int (*compar)(const void *, const void *));
DESCRIPTION
The lsearch() function shall linearly search the table and return a pointer into the table for the matching entry. If the
entry does not occur, it shall be added at the end of the table. The key argument points to the entry to be sought in the
table. The base argument points to the first element in the table. The width argument is the size of an element in
bytes. The nelp argument points to an integer containing the current number of elements in the table. The integer to which
nelp points shall be incremented if the entry is added to the table. The compar argument points to a comparison
function which the application shall supply (for example, strcmp()). It is called
with two arguments that point to the elements being compared. The application shall ensure that the function returns 0 if the
elements are equal, and non-zero otherwise.
The lfind() function shall be equivalent to lsearch(), except that if the entry is not found, it is not added to
the table. Instead, a null pointer is returned.
RETURN VALUE
If the searched for entry is found, both lsearch() and lfind() shall return a pointer to it. Otherwise,
lfind() shall return a null pointer and lsearch() shall return a pointer to the newly added element.
Both functions shall return a null pointer in case of error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
Storing Strings in a Table
This fragment reads in less than or equal to TABSIZE strings of length less than or equal to ELSIZE and stores them in a table,
eliminating duplicates.
#include
#include
#include
#define TABSIZE 50
#define ELSIZE 120
...
char line[ELSIZE], tab[TABSIZE][ELSIZE];
size_t nel = 0;
...
while (fgets(line, ELSIZE, stdin) != NULL && nel
#include
...
char line[ELSIZE], tab[TABSIZE][ELSIZE];
size_t nel = 0;
char *findline;
void *entry;
findline = "This is a test.\n";
entry = lfind(findline, tab, &nel, ELSIZE, (
int (*)(const void *, const void *)) strcmp);
APPLICATION USAGE
The comparison function need not compare every byte, so arbitrary data may be contained in the elements in addition to the
values being compared.
Undefined results can occur if there is not enough room in the table to add a new item.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
hcreate(), tdelete()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/be16toh.html =====
be16toh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
be16toh, be32toh, be64toh, htobe16, htobe32, htobe64, htole16, htole32, htole64, le16toh, le32toh, le64toh — convert
values between host and specified byte order
SYNOPSIS
#include
uint16_t be16toh(uint16_t big_endian_16bits);
uint32_t be32toh(uint32_t big_endian_32bits);
uint64_t be64toh(uint64_t big_endian_64bits);
uint16_t htobe16(uint16_t host_16bits);
uint32_t htobe32(uint32_t host_32bits);
uint64_t htobe64(uint64_t host_64bits);
uint16_t htole16(uint16_t host_16bits);
uint32_t htole32(uint32_t host_32bits);
uint64_t htole64(uint64_t host_64bits);
uint16_t le16toh(uint16_t little_endian_16bits);
uint32_t le32toh(uint32_t little_endian_32bits);
uint64_t le64toh(uint64_t little_endian_64bits);
DESCRIPTION
These functions shall convert integer values of various sizes between host representations and representations in a specified
order.
On some implementations, these functions are defined as macros.
A little-endian representation of an integer has the least significant byte stored as the first byte, with the significance of
the bytes increasing as the byte address increases. A big-endian representation has the most significant byte as the first byte,
with the significance of the bytes reducing as the byte address increases.
Note:
Network byte order is big-endian.
For example, the uint32_t value 0x01020304 is represented as the four bytes 0x04, 0x03, 0x02, 0x01 on a little-endian
host, and as 0x01, 0x02, 0x03, 0x04 on a big-endian host.
For each of the sizes 16, 32 and 64, the htobeSIZE() function shall convert from whatever order the host uses to
big-endian representation, htoleSIZE() shall convert to little-endian representation, beSIZEtoh() shall convert from
big-endian to host order, and leSIZEtoh() shall convert from little-endian to host order.
RETURN VALUE
These functions shall return an unsigned integer of the appropriate size and representation.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
#include
#include
#include
int main(int argc, char *argv[])
{
uint32_t val;
if (argc > 1) {
val = (uint32_t)strtoul(argv[1], NULL, 0);
printf("Value: %08x\n", val);
printf("As bytes:\n");
union {
uint32_t asint;
unsigned char asbytes[sizeof(uint32_t)];
} u;
printf("Little endian: ");
u.asint = htole32(val);
for (int i = 0; i  is included:
htobe32
htonl
htobe16
htons
be32toh
ntohl
be16toh
ntohs
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
htonl()
XBD ,
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/feupdateenv.html =====
feupdateenv
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
feupdateenv — update floating-point environment
SYNOPSIS
#include
int feupdateenv(const fenv_t *envp);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The feupdateenv() function shall attempt to save the currently raised floating-point exceptions in its automatic storage,
attempt to install the floating-point environment represented by the object pointed to by envp, and then attempt to raise
the saved floating-point exceptions. The argument envp shall point to an object set by a call to feholdexcept() or fegetenv(), or equal
a floating-point environment macro.
RETURN VALUE
The feupdateenv() function shall return a zero value if and only if all the required actions were successfully carried
out.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
The following example shows sample code to hide spurious underflow floating-point exceptions:
#include
double f(double x)
{
#pragma STDC FENV_ACCESS ON
double result;
fenv_t save_env;
feholdexcept(&save_env);
// compute result
if (/* test spurious underflow */)
feclearexcept(FE_UNDERFLOW);
feupdateenv(&save_env);
return result;
}
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
fegetenv(), feholdexcept()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
ISO/IEC 9899:1999 standard, Technical Corrigendum 1 is incorporated.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_mutexattr_destroy.html =====
pthread_mutexattr_destroy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_mutexattr_destroy, pthread_mutexattr_init — destroy and initialize the mutex attributes object
SYNOPSIS
#include
int pthread_mutexattr_destroy(pthread_mutexattr_t *attr);
int pthread_mutexattr_init(pthread_mutexattr_t *attr);
DESCRIPTION
The pthread_mutexattr_destroy() function shall destroy a mutex attributes object; the object becomes, in effect,
uninitialized. An implementation may cause pthread_mutexattr_destroy() to set the object referenced by attr to an
invalid value.
A destroyed attr attributes object can be reinitialized using pthread_mutexattr_init(); the results of otherwise
referencing the object after it has been destroyed are undefined.
The pthread_mutexattr_init() function shall initialize a mutex attributes object attr with the default value for
all of the attributes defined by the implementation.
Results are undefined if pthread_mutexattr_init() is called specifying an already initialized attr attributes
object.
After a mutex attributes object has been used to initialize one or more mutexes, any function affecting the attributes object
(including destruction) shall not affect any previously initialized mutexes.
The behavior is undefined if the value specified by the attr argument to pthread_mutexattr_destroy() does not
refer to an initialized mutex attributes object.
RETURN VALUE
Upon successful completion, pthread_mutexattr_destroy() and pthread_mutexattr_init() shall return zero; otherwise,
an error number shall be returned to indicate the error.
ERRORS
The pthread_mutexattr_init() function shall fail if:
[ENOMEM]
Insufficient memory exists to initialize the mutex attributes object.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
If an implementation detects that the value specified by the attr argument to pthread_mutexattr_destroy() does not
refer to an initialized mutex attributes object, it is recommended that the function should fail and report an [EINVAL] error.
See pthread_attr_destroy() for a general explanation of attributes.
Attributes objects allow implementations to experiment with useful extensions and permit extension of this volume of POSIX.1-2024
without changing the existing functions. Thus, they provide for future extensibility of this volume of POSIX.1-2024 and reduce the
temptation to standardize prematurely on semantics that are not yet widely implemented or understood.
Examples of possible additional mutex attributes that have been discussed are spin_only, limited_spin,
no_spin, recursive, and metered. (To explain what the latter attributes might mean: recursive mutexes would
allow for multiple re-locking by the current owner; metered mutexes would transparently keep records of queue length, wait time,
and so on.) Since there is not yet wide agreement on the usefulness of these resulting from shared implementation and usage
experience, they are not yet specified in this volume of POSIX.1-2024. Mutex attributes objects, however, make it possible to test
out these concepts for possible standardization at a later time.
Mutex Attributes and Performance
Care has been taken to ensure that the default values of the mutex attributes have been defined such that mutexes initialized
with the defaults have simple enough semantics so that the locking and unlocking can be done with the equivalent of a test-and-set
instruction (plus possibly a few other basic instructions).
There is at least one implementation method that can be used to reduce the cost of testing at lock-time if a mutex has
non-default attributes. One such method that an implementation can employ (and this can be made fully transparent to fully
conforming POSIX applications) is to secretly pre-lock any mutexes that are initialized to non-default attributes. Any later
attempt to lock such a mutex causes the implementation to branch to the "slow path" as if the mutex were unavailable; then, on
the slow path, the implementation can do the "real work" to lock a non-default mutex. The underlying unlock operation is more
complicated since the implementation never really wants to release the pre-lock on this kind of mutex. This illustrates that,
depending on the hardware, there may be certain optimizations that can be used so that whatever mutex attributes are considered
"most frequently used" can be processed most efficiently.
Process Shared Memory and Synchronization
The existence of memory mapping functions in this volume of POSIX.1-2024 leads to the possibility that an application may
allocate the synchronization objects from this section in memory that is accessed by multiple processes (and therefore, by threads
of multiple processes).
In order to permit such usage, while at the same time keeping the usual case (that is, usage within a single process) efficient,
a process-shared option has been defined.
If an implementation supports the _POSIX_THREAD_PROCESS_SHARED option, then the process-shared attribute can be used to
indicate that mutexes or condition variables may be accessed by threads of multiple processes.
The default setting of PTHREAD_PROCESS_PRIVATE has been chosen for the process-shared attribute so that the most
efficient forms of these synchronization objects are created by default.
Synchronization variables that are initialized with the PTHREAD_PROCESS_PRIVATE process-shared attribute may only be
operated on by threads in the process that initialized them. Synchronization variables that are initialized with the
PTHREAD_PROCESS_SHARED process-shared attribute may be operated on by any thread in any process that has access to it. In
particular, these processes may exist beyond the lifetime of the initializing process. For example, the following code implements a
simple counting semaphore in a mapped file that may be used by many processes.
/* sem.h */
struct semaphore {
pthread_mutex_t lock;
pthread_cond_t nonzero;
unsigned count;
};
typedef struct semaphore semaphore_t;
semaphore_t *semaphore_create(char *semaphore_name);
semaphore_t *semaphore_open(char *semaphore_name);
void semaphore_post(semaphore_t *semap);
void semaphore_wait(semaphore_t *semap);
void semaphore_close(semaphore_t *semap);
/* sem.c */
#include
#include
#include
#include
#include
#include "sem.h"
semaphore_t *
semaphore_create(char *semaphore_name)
{
int fd;
semaphore_t *semap;
pthread_mutexattr_t psharedm;
pthread_condattr_t psharedc;
fd = open(semaphore_name, O_RDWR | O_CREAT | O_EXCL, 0666);
if (fd lock, &psharedm);
(void) pthread_cond_init(&semap->nonzero, &psharedc);
semap->count = 0;
return (semap);
}
semaphore_t *
semaphore_open(char *semaphore_name)
{
int fd;
semaphore_t *semap;
fd = open(semaphore_name, O_RDWR, 0666);
if (fd lock);
if (semap->count == 0)
pthread_cond_signal(&semapx->nonzero);
semap->count++;
pthread_mutex_unlock(&semap->lock);
}
void
semaphore_wait(semaphore_t *semap)
{
pthread_mutex_lock(&semap->lock);
while (semap->count == 0)
pthread_cond_wait(&semap->nonzero, &semap->lock);
semap->count--;
pthread_mutex_unlock(&semap->lock);
}
void
semaphore_close(semaphore_t *semap)
{
munmap((void *) semap, sizeof(semaphore_t));
}
The following code is for three separate processes that create, post, and wait on a semaphore in the file /tmp/semaphore.
Once the file is created, the post and wait programs increment and decrement the counting semaphore (waiting and waking as
required) even though they did not initialize the semaphore.
/* create.c */
#include "pthread.h"
#include "sem.h"
int
main(void)
{
semaphore_t *semap;
semap = semaphore_create("/tmp/semaphore");
if (semap == NULL)
exit(1);
semaphore_close(semap);
return (0);
}
/* post.c */
#include "pthread.h"
#include "sem.h"
int
main(void)
{
semaphore_t *semap;
semap = semaphore_open("/tmp/semaphore");
if (semap == NULL)
exit(1);
semaphore_post(semap);
semaphore_close(semap);
return (0);
}
/* wait.c */
#include "pthread.h"
#include "sem.h"
int
main(void)
{
semaphore_t *semap;
semap = semaphore_open("/tmp/semaphore");
if (semap == NULL)
exit(1);
semaphore_wait(semap);
semaphore_close(semap);
return (0);
}
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_cond_destroy(), pthread_create(), pthread_mutex_destroy()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_mutexattr_destroy() and pthread_mutexattr_init() functions are marked as part of the Threads
option.
IEEE PASC Interpretation 1003.1c #27 is applied, updating the ERRORS section.
Issue 7
The pthread_mutexattr_destroy() and pthread_mutexattr_init() functions are moved from the Threads option to the
Base.
The [EINVAL] error for an uninitialized mutex attributes object is removed; this condition results in undefined behavior.
Issue 8
Austin Group Defect 1195 is applied, changing "main()" to "main(void)".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/setpriority.html =====
getpriority
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getpriority, setpriority — get and set the nice value
SYNOPSIS
[XSI]  #include
int getpriority(int which, id_t who);
int setpriority(int which, id_t who, int value);
DESCRIPTION
The getpriority() function shall obtain the nice value of a process, process group, or user. The setpriority()
function shall set the nice value of a process, process group, or user to value+{NZERO}.
Target processes are specified by the values of the which and who arguments. The which argument may be one
of the following values: PRIO_PROCESS, PRIO_PGRP, or PRIO_USER, indicating that the who argument is to be interpreted as a
process ID, a process group ID, or an effective user ID, respectively. A 0 value for the who argument specifies the current
process, process group, or user.
The nice value set with setpriority() shall be applied to the process. If the process is multi-threaded, the nice value
shall affect all system scope threads in the process.
If more than one process is specified, getpriority() shall return value {NZERO} less than the lowest nice value
pertaining to any of the specified processes, and setpriority() shall set the nice values of all of the specified processes
to value+{NZERO}.
The default nice value is {NZERO}; lower nice values shall cause more favorable scheduling. While the range of valid nice values
is [0,{NZERO}*2-1], implementations may enforce more restrictive limits. If value+{NZERO} is less than the system's lowest
supported nice value, setpriority() shall set the nice value to the lowest supported value; if value+{NZERO} is
greater than the system's highest supported nice value, setpriority() shall set the nice value to the highest supported
value.
Only a process with appropriate privileges can lower its nice value.
[PS|TPS]
Any processes or threads using SCHED_FIFO or SCHED_RR shall be unaffected by a call to setpriority(). This is not considered
an error. A process which subsequently reverts to SCHED_OTHER need not have its priority affected by such a setpriority()
call.
The effect of changing the nice value may vary depending on the process-scheduling algorithm in effect.
Since getpriority() can return the value -1 upon successful completion, it is necessary to set errno to 0 prior to
a call to getpriority(). If getpriority() returns the value -1, then errno can be checked to see if an error
occurred or if the value is a legitimate nice value.
RETURN VALUE
Upon successful completion, getpriority() shall return an integer in the range -{NZERO} to {NZERO}-1. Otherwise, -1 shall
be returned and errno set to indicate the error.
Upon successful completion, setpriority() shall return 0; otherwise, -1 shall be returned and errno set to
indicate the error.
ERRORS
The getpriority() and setpriority() functions shall fail if:
[ESRCH]
No process could be located using the which and who argument values specified.
[EINVAL]
The value of the which argument was not recognized, or the value of the who argument is not a valid process ID,
process group ID, or user ID.
In addition, setpriority() may fail if:
[EPERM]
A process was located, but neither the real nor effective user ID of the executing process match the effective user ID of the
process whose nice value is being changed.
[EACCES]
A request was made to change the nice value to a lower numeric value and the current process does not have appropriate
privileges.
The following sections are informative.
EXAMPLES
Using getpriority()
The following example returns the current scheduling priority for the process ID returned by the call to getpid().
#include
...
int which = PRIO_PROCESS;
id_t pid;
int ret;
pid = getpid();
ret = getpriority(which, pid);
Using setpriority()
The following example sets the priority for the current process ID to -20.
#include
...
int which = PRIO_PROCESS;
id_t pid;
int priority = -20;
int ret;
pid = getpid();
ret = setpriority(which, pid, priority);
APPLICATION USAGE
The getpriority() and setpriority() functions work with an offset nice value (nice value -{NZERO}). The nice value
is in the range [0,2*{NZERO} -1], while the return value for getpriority() and the third parameter for setpriority()
are in the range [-{NZERO},{NZERO} -1].
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
nice(), sched_get_priority_max(), sched_setscheduler()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
The DESCRIPTION is reworded in terms of the nice value rather than priority to avoid confusion with functionality in the
POSIX Realtime Extension.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/j1.html =====
j0
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
j0, j1, jn — Bessel functions of the first kind
SYNOPSIS
[XSI]  #include
double j0(double x);
double j1(double x);
double jn(int n, double x);
DESCRIPTION
The j0(), j1(), and jn() functions shall compute Bessel functions of x of the first kind of orders
0, 1, and n, respectively.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the relevant Bessel value of x of the first kind.
If the x argument is finite and too large in magnitude, or the correct result would cause underflow [MXX]   and is not
representable,  a range error may occur, and the function shall
return [MXX]   0.0, or  (if the IEC 60559 Floating-Point option is not
supported) an implementation-defined value no greater in magnitude than DBL_MIN.
[MXX]  If
the correct result would cause underflow, and is representable, a range error may occur and the correct value shall be returned.
[MXX]
If x is +Inf, +0 shall be returned.
[MXX]
If x is NaN, a NaN shall be returned.
ERRORS
These functions may fail if:
Range Error
The value of x was too large in magnitude, or an underflow occurred.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
No other errors shall occur.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), isnan(), y0()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The may fail [EDOM] error is removed for the case for NaN.
The RETURN VALUE and ERRORS sections are reworked for alignment of the error handling with the ISO/IEC 9899:1999
standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0350 [68] is applied.
Issue 8
Austin Group Defect 714 is applied, changing the behavior of these functions for special cases to be a better match for their
mathematical behavior.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ispunct_l.html =====
ispunct
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ispunct, ispunct_l — test for a punctuation character
SYNOPSIS
#include
int ispunct(int c);
[CX]  int ispunct_l(int c, locale_t locale);
DESCRIPTION
For ispunct(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The ispunct() [CX]   and ispunct_l()
functions shall test whether c is a character of class punct in the current locale, [CX]   or in the
locale represented by locale,  respectively; see XBD 7. Locale.
The c argument is an int, the value of which the application shall ensure is a character representable as an
unsigned char or equal to the value of the macro EOF. If the argument has any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to ispunct_l() is the special locale object LC_GLOBAL_LOCALE or is not a
valid locale object handle.
RETURN VALUE
The ispunct() [CX]   and ispunct_l()
functions shall return non-zero if c is a punctuation character; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
isalnum(), isalpha(), isblank(), iscntrl(), isdigit(), isgraph(), islower(), isprint(), isspace(), isupper(), isxdigit(), setlocale(), uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The ispunct_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0300 [302], XSH/TC1-2008/0301 [283], and XSH/TC1-2008/0302 [283] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/close.html =====
close
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
close, posix_close — close a file descriptor
SYNOPSIS
#include
int close(int fildes);
int posix_close(int fildes, int flag);
DESCRIPTION
The close() function shall deallocate the file descriptor indicated by fildes. To deallocate means to make the
file descriptor available for return by subsequent calls to open() or other functions
that allocate file descriptors. All process-owned file locks that the calling process owns on the file associated with the file
descriptor shall be unlocked.
If close() is interrupted by a signal that is to be caught, then it is unspecified whether it returns -1 with
errno set to [EINTR] and fildes remaining open, or returns -1 with errno set to [EINPROGRESS] and
fildes being closed, or returns 0 to indicate successful completion; except that if POSIX_CLOSE_RESTART is defined as 0,
then the option of returning -1 with errno set to [EINTR] and fildes remaining open shall not occur. If
close() returns -1 with errno set to [EINTR], it is unspecified whether fildes can subsequently be passed to
any function except close() or posix_close() without error. For all other error situations (except for [EBADF] where
fildes was invalid), fildes shall be closed. If fildes was closed even though the close operation is
incomplete, the close operation shall continue asynchronously and the process shall have no further ability to track the completion
or final status of the close operation.
When all file descriptors associated with a pipe or FIFO special file are closed, any data remaining in the pipe or FIFO shall
be discarded.
When all file descriptors associated with an open file description have been closed, the open file description shall be
freed.
If the link count of the file is 0, when all file descriptors associated with the file are closed, the space occupied by the
file shall be freed and the file shall no longer be accessible.
[XSI]
If fildes refers to the manager side of a pseudo-terminal, and this is the last close, a SIGHUP signal shall be sent to the
controlling process, if any, for which the subsidiary side of the pseudo-terminal is the controlling terminal. It is unspecified
whether closing the manager side of the pseudo-terminal flushes all queued input and output.
When there is an outstanding cancelable asynchronous I/O operation against fildes when close() is called, that I/O
operation may be canceled. An I/O operation that is not canceled completes as if the close() operation had not yet occurred.
All operations that are not canceled shall complete as if the close() blocked until the operations completed. The
close() operation itself need not block awaiting such I/O completion. Whether any I/O operation is canceled, and which I/O
operation may be canceled upon close(), is implementation-defined.
If a memory mapped file [SHM]   or a shared memory object
remains referenced at the last close (that is, a process has it mapped), then the entire contents of the memory object shall
persist until the memory object becomes unreferenced. If this is the last close of a memory mapped file [SHM]   or a shared
memory object   and the close results in the memory object
becoming unreferenced, and the memory object has been unlinked, then the memory object shall be removed.
When all file descriptors associated with a socket have been closed, the socket shall be destroyed. If the socket is in
connection-mode, and the SO_LINGER option is set for the socket with non-zero linger time, and the socket has untransmitted data,
then close() shall block for up to the current linger interval until all data is transmitted.
The posix_close() function shall be equivalent to the close() function, except with the modifications based on the
flag argument as described below. If flag is 0, then posix_close() shall not return -1 with errno set
to [EINTR], which implies that fildes will always be closed (except for [EBADF], where fildes was invalid). If
flag includes POSIX_CLOSE_RESTART and POSIX_CLOSE_RESTART is defined as a non-zero value, and posix_close() is
interrupted by a signal that is to be caught, then posix_close() may return -1 with errno set to [EINTR], in which
case fildes shall be left open; however, it is unspecified whether fildes can subsequently be passed to any function
except close() or posix_close() without error. If flag is invalid, posix_close() may fail with errno
set to [EINVAL], but shall otherwise behave as if flag had been 0 and close fildes.
RETURN VALUE
Upon successful completion, 0 shall be returned; otherwise, -1 shall be returned and errno set to indicate the error.
ERRORS
The close() and posix_close() functions shall fail if:
[EBADF]
The fildes argument is not a open file descriptor.
[EINPROGRESS]
The function was interrupted by a signal and fildes was closed but the close operation is continuing
asynchronously.
The close() and posix_close() functions may fail if:
[EINTR]
The function was interrupted by a signal, POSIX_CLOSE_RESTART is defined as non-zero, and (in the case of posix_close())
the flag argument included POSIX_CLOSE_RESTART, in which case fildes is still open.
[EIO]
An I/O error occurred while reading from or writing to the file system.
The posix_close() function may fail if:
[EINVAL]
The value of the flag argument is invalid.
The close() and posix_close() functions shall not return an [EAGAIN] or [EWOULDBLOCK] error. If
POSIX_CLOSE_RESTART is zero, the close() function shall not return an [EINTR] error. The posix_close() function shall
not return an [EINTR] error unless flag includes a non-zero POSIX_CLOSE_RESTART.
The following sections are informative.
EXAMPLES
Reassigning a File Descriptor
The following example closes the file descriptor associated with standard output for the current process, re-assigns standard
output to a new file descriptor, and closes the original file descriptor to clean up. This example assumes that the file descriptor
0 (which is the descriptor for standard input) is not closed.
#include
...
int pfd;
...
close(1);
dup(pfd);
close(pfd);
...
Incidentally, this is exactly what could be achieved using:
dup2(pfd, 1);
close(pfd);
Closing a File Descriptor
In the following example, close() is used to close a file descriptor after an unsuccessful attempt is made to associate
that file descriptor with a stream.
#include
#include
#include
#define LOCKFILE "/etc/ptmp"
...
int pfd;
FILE *fpfd;
...
if ((fpfd = fdopen (pfd, "w")) == NULL) {
close(pfd);
unlink(LOCKFILE);
exit(1);
}
...
APPLICATION USAGE
An application that had used the stdio routine fopen() to open a file should
use the corresponding fclose() routine rather than close(). Once a file is
closed, the file descriptor no longer exists, since the integer corresponding to it no longer refers to a file.
Implementations may use file descriptors that must be inherited into child processes for the child process to remain conforming,
such as for message catalog or tracing purposes. Therefore, an application that calls close() on an arbitrary integer risks
non-conforming behavior, and close() can only portably be used on file descriptor values that the application has obtained
through explicit actions, as well as the three file descriptors corresponding to the standard file streams. In multi-threaded
parent applications, the practice of calling close() in a loop after fork() and
before an exec call in order to avoid a race condition of leaking an unintended file
descriptor into a child process, is therefore unsafe, and the race should instead be combatted by opening all file descriptors with
the FD_CLOEXEC bit set unless the file descriptor is intended to be inherited across exec.
Usage of close() on file descriptors STDIN_FILENO, STDOUT_FILENO, or STDERR_FILENO should immediately be followed by an
operation to reopen these file descriptors. Unexpected behavior will result if any of these file descriptors is left in a closed
state (for example, an [EBADF] error from perror()) or if an unrelated open() or similar call later in the application accidentally allocates a file to one of these
well-known file descriptors. Furthermore, a close() followed by a reopen operation (e.g., open(), dup(), etc.) is not atomic; dup2() should be used to change standard file descriptors.
RATIONALE
The use of interruptible device close routines should be discouraged to avoid problems with the implicit closes of file
descriptors, such as by exec, process termination, or dup2(). This volume of POSIX.1-2024 only intends to permit such behavior by specifying the
[EINTR] error condition for close() and posix_close() with non-zero POSIX_CLOSE_RESTART, to allow applications a
portable way to resume waiting for an event associated with the close operation (for example, a tape drive rewinding) after
receiving an interrupt. This standard also permits implementations to define POSIX_CLOSE_RESTART to 0 if they do not choose to
provide a way to restart an interrupted close action. Although the file descriptor is left open on [EINTR], it might no longer be
usable; that is, passing it to any function except close() or posix_close() might result in an error such as [EIO].
If an application must guarantee that data will not be lost, it is recommended that the application use fsync() or fdatasync() prior to the close
operation, rather than leaving the close operation to deal with pending I/O and risk an interrupt.
Earlier versions of this standard left the state of fildes unspecified after errors such as [EINTR] and [EIO]; and
implementations differed on whether close() left fildes open after [EINTR]. This was unsatisfactory once threads were
introduced, since multi-threaded applications need to know whether fildes has been closed. Applications cannot blindly call
close() again, because if fildes was closed by the first call another thread could have been allocated a file
descriptor with the same value as fildes, which must not be closed by the first thread. On the other hand, the alternative
of never retrying close() would lead to a file descriptor leak in implementations where close() did not close
fildes, although such a leak may be harmless if the process is about to exit or the file descriptor is marked FD_CLOEXEC and
the process is about to be replaced by exec. This standard introduced
posix_close() with a flag argument that allows a choice between the two possible error behaviors, and leaves it
unspecified which of the two behaviors is implemented by close() (although it is guaranteed to be one of the two behaviors
of posix_close(), rather than leaving things completely unspecified as in earlier versions of the standard).
Note that the standard requires that close() and posix_close() must leave fildes open after [EINTR] (in the
cases where [EINTR] is permitted) and must close the file descriptor regardless of all other errors (except [EBADF], where
fildes is already invalid). In general, portable applications should only retry a close() after checking for [EINTR]
(and on implementations where POSIX_CLOSE_RESTART is defined to be zero, this retry loop will be dead code), and risk a file
descriptor leak if a retry loop is not attempted. It should also be noted that [EINTR] is only possible if close() can be
interrupted; if no signal handlers are installed, then close() will not be interrupted. Conversely, if a single-threaded
application can guarantee that no file descriptors are opened or closed in signal handlers, then a retry loop without checking for
[EINTR] will be harmless (since the retry will fail with [EBADF]), but guaranteeing that no external libraries introduce the use of
threading can be difficult. There are additional guarantees for applications which will only ever be used on systems where
POSIX_CLOSE_RESTART is defined as 0. These observations should help in determining whether an application needs to have its
close() calls audited for replacement with posix_close().
It should also be noted that the requirement for posix_close() with a flag of 0 to always close fildes,
even if an error is reported, is similar to the requirements on fclose() to always
release the stream, even if an error is encountered while flushing data.
Implementations that previously always closed fildes can meet the new requirements by translating [EINTR] to
[EINPROGRESS] in close(); and may define POSIX_CLOSE_RESTART to 0 rather than having to add restart semantics. On the other
hand, implementations that previously left fildes open on [EINTR] can map that to posix_close() with
POSIX_CLOSE_RESTART, and must add the semantics of posix_close() when flag is 0; one possibility is by calling the
original close() implementation, checking for failure, and on [EINTR], using actions similar to dup2() to replace the incomplete close operation with another file descriptor that can be
closed immediately by another call to the original close(), all before returning to the application. Either way,
close() should always map to one of the two behaviors of posix_close(), and implementations are encouraged to keep
the behavior of close() unchanged so as not to break implementation-specific expectations of older applications that were
relying on behavior not specified by older versions of this standard.
The standard developers considered introducing a thread-local variable that close() would set to indicate whether it had
closed fildes when returning -1. However, this was rejected in favor of the simpler solution of tightening close() to
guarantee that fildes is closed except for [EINTR], and exposing a choice of whether to expect [EINTR] by adding
posix_close(). Additionally, while the name posix_close() is new to this standard, it is reminiscent of at least one
implementation that introduced an alternate system call named close_nocancel() in order to allow an application to choose
whether restart semantics were desired.
Another consideration was whether implementations might return [EAGAIN] as an extension and whether close() should be
required to leave the file descriptor open in this case, since [EAGAIN] normally implies an operation should be retried. It seemed
very unlikely that any implementation would have a legitimate reason to return [EAGAIN] or [EWOULDBLOCK], and therefore this
requirement would mean applications have to include code for an error case that will never be used. Therefore close() is now
forbidden from returning [EAGAIN] and [EWOULDBLOCK] errors.
Note that the requirement for close() on a socket to block for up to the current linger interval is not conditional on
the O_NONBLOCK setting.
The standard developers rejected a proposal to add closefrom() to the standard. Because the standard permits
implementations to use inherited file descriptors as a means of providing a conforming environment for the child process, it is not
possible to standardize an interface that closes arbitrary file descriptors above a certain value while still guaranteeing a
conforming environment.
FUTURE DIRECTIONS
None.
SEE ALSO
dup(), exec, exit(), fclose(), fopen(), fork(), open(), perror(), unlink()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Realtime Extension.
Issue 6
The DESCRIPTION related to a STREAMS-based file or pseudo-terminal is marked as part of the XSI STREAMS Option Group.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The [EIO] error condition is added as an optional error.
The DESCRIPTION is updated to describe the state of the fildes file descriptor as unspecified if an I/O error occurs and
an [EIO] error condition is returned.
Text referring to sockets is added to the DESCRIPTION.
The DESCRIPTION is updated for alignment with IEEE Std 1003.1j-2000 by specifying that shared memory objects and
memory mapped files (and not typed memory objects) are the types of memory objects to which the paragraph on last closes
applies.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/12 is applied, correcting the XSH shaded text relating to the
manager side of a pseudo-terminal. The reason for the change is that the behavior of pseudo-terminals and regular terminals should
be as much alike as possible in this case; the change achieves that and matches historical behavior.
Issue 7
Functionality relating to the XSI STREAMS option is marked obsolescent.
Functionality relating to the Asynchronous Input and Output and Memory Mapped Files options is moved to the Base.
Austin Group Interpretation 1003.1-2001 #139 is applied, clarifying that the requirement for close() on a socket to block
for up to the current linger interval is not conditional on the O_NONBLOCK setting.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0059 [419], XSH/TC1-2008/0060 [149], and XSH/TC1-2008/0061 [149] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0069 [555] is applied.
Issue 8
Austin Group Defect 529 is applied, adding the posix_close() function and changing requirements for the close()
function relating to [EINTR].
Austin Group Defect 768 is applied, adding OFD-owned file locks.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
Austin Group Defect 1466 is applied, changing the terminology used for pseudo-terminal devices.
Austin Group Defect 1525 is applied, clarifying that a socket is not destroyed until all file descriptors associated with it
have been closed.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/towctrans.html =====
towctrans
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
towctrans, towctrans_l — wide-character transliteration
SYNOPSIS
#include
wint_t towctrans(wint_t wc, wctrans_t desc);
[CX]  wint_t towctrans_l(wint_t wc, wctrans_t desc,
locale_t locale);
DESCRIPTION
For towctrans(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The towctrans() [CX]   and towctrans_l()
functions shall transliterate the wide-character code wc using the mapping described by desc.
The current setting of the LC_CTYPE category in the current locale [CX]   or in the
locale represented by locale,   respectively, should be
the same as during the call to wctrans() [CX]   or wctrans_l()   that
returned the value desc.
If the value of desc is invalid (that is, not obtained by a call to wctrans() or desc is invalidated by a subsequent call to setlocale() that has affected category LC_CTYPE ), the result is unspecified.
[CX]  If
the value of desc is invalid (that is, not obtained by a call to wctrans_l() with the same locale object locale) the result is unspecified.
[CX]  An
application wishing to check for error situations should set errno to 0 before calling towctrans() or
towctrans_l().
If errno is non-zero on return, an error has occurred.
The behavior is undefined if the locale argument to towctrans_l() is the special locale object LC_GLOBAL_LOCALE or
is not a valid locale object handle.
RETURN VALUE
If successful, the towctrans() [CX]   and towctrans_l()   functions shall return the mapped value of wc using the mapping described by desc,
or the value of wc unchanged if desc is zero. [CX]   Otherwise, they shall return wc unchanged.
ERRORS
These functions may fail if:
[EINVAL]
[CX]
desc contains an invalid transliteration descriptor.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The strings "tolower" and "toupper" are reserved for the standard mapping names. In the table below, the
functions in the left column are equivalent to the functions in the right column.
towlower(wc)            towctrans(wc, wctrans("tolower"))
towlower_l(wc, locale)  towctrans_l(wc, wctrans("tolower"), locale)
towupper(wc)            towctrans(wc, wctrans("toupper"))
towupper_l(wc, locale)  towctrans_l(wc, wctrans("toupper"), locale)
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
towlower(), towupper(),
wctrans()
XBD
CHANGE HISTORY
First released in Issue 5. Derived from ISO/IEC 9899:1990/Amendment 1:1995 (E).
Issue 6
Extensions beyond the ISO C standard are marked.
Issue 7
The towctrans_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0675 [302], XSH/TC1-2008/0676 [283], and XSH/TC1-2008/0677 [283] are
applied.
Issue 8
Austin Group Defect 1302 is applied, aligning the towctrans() function with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/exp2f.html =====
exp2
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
exp2, exp2f, exp2l — exponential base 2 functions
SYNOPSIS
#include
double exp2(double x);
float exp2f(float x);
long double exp2l(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the base-2 exponential of x.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return 2x.
If the correct value would cause overflow, a range error shall occur and exp2(), exp2f(), and exp2l() shall
return the value of the macro HUGE_VAL, HUGE_VALF, and HUGE_VALL, respectively.
If the correct value would cause underflow, [MXX]   and is not representable,   a range error may occur, and exp2(), exp2f(), and exp2l() shall return
[MXX]
0.0, or   (if the IEC 60559 Floating-Point option is not
supported) an implementation-defined value no greater in magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, 1 shall be returned.
If x is -Inf, +0 shall be returned.
If x is +Inf, x shall be returned.
[MXX]
If the correct value would cause underflow, and is representable, a range error may occur and the correct value shall be returned.
ERRORS
These functions shall fail if:
Range Error
The result overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
These functions may fail if:
Range Error
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
exp(), feclearexcept(),
fetestexcept(), isnan(),
log()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0108 [68] and XSH/TC1-2008/0109 [68] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0102 [630] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strptime.html =====
strptime
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strptime — date and time conversion
SYNOPSIS
[XSI]  #include
char *strptime(const char *restrict buf, const char *restrict format,
struct tm *restrict tm);
DESCRIPTION
The strptime() function shall convert the character string pointed to by buf to values which are stored in the
tm structure pointed to by tm, using the format specified by format.
The application shall ensure that the format is a character string, beginning and ending in its initial shift state, if any. The
format is composed of zero or more directives. Each directive is composed of one of the following: one or more white-space bytes;
an ordinary character (neither '%' nor a white-space byte); or a conversion specification.
Each conversion specification is introduced by the '%' character after which the following appear in sequence:
An optional flag, the zero character ('0') or the  character ('+'), which is ignored.
An optional field width. If a field width is specified, it shall be interpreted as a string of decimal digits that determine the
maximum number of bytes converted for the conversion rather than the number of bytes specified below in the description of the
conversion specifiers.
An optional E or O modifier.
A terminating conversion specifier character that indicates the type of conversion to be applied.
The conversions are determined using the LC_TIME category of the current locale. The application shall ensure that there
are white-space bytes or other non-alphanumeric bytes between any two conversion specifications unless all of the adjacent
conversion specifications convert a known, fixed number of characters. In the following list, the maximum number of characters
scanned (excluding the one matching the next directive) is as follows:
If a maximum field width is specified, then that number
Otherwise, the pattern "{x}" indicates that the maximum is x
Otherwise, the pattern "[x,y]" indicates that the value shall fall within the range given (both bounds being
inclusive), and the maximum number of characters scanned shall be the maximum required to represent any value in the range without
leading zeros and without a leading
The following conversion specifiers are supported.
The results are unspecified if a modifier is specified with a flag or with a minimum field width, or if a field width is
specified for any conversion specifier other than C, F, G, Y, or Z.
a
The day of the week, using the locale's weekday names; either the abbreviated or full name can be specified. The tm_wday
member of the tm structure pointed to by tm shall be set to the corresponding day of the week number (Sunday=0).
A
Equivalent to %a.
b
The month, using the locale's month names; either the abbreviated or full version of either the default or the alternative
month name can be specified. The tm_mon member of the tm structure pointed to by tm shall be set to the
corresponding month number.
B
Equivalent to %b.
c
Replaced by the locale's appropriate date and time representation. The members of the tm structure pointed to by
tm shall be set as specified for the conversions present in the locale's d_t_fmt value.
C
All but the last two digits of the year {2}; leading zeros shall be permitted but shall not be required. A leading '+'
or '-' character shall be permitted before any leading zeros but shall not be required. The tm_year member of the
tm structure pointed to by tm shall be set to the number formed by appending the last two digits of the year to these
digits, minus 1900. If a y conversion is also performed, the last two digits of the year shall be those processed by the
y conversion; otherwise, they shall be 00.
d
The day of the month [01,31]; leading zeros shall be permitted but shall not be required. The tm_mday member of the
tm structure pointed to by tm shall be set to this number.
D
Equivalent to %m/%d/%y.
e
Equivalent to %d.
F
This specifier is similar to %Y-%m-%d where the characters up to the first  separator shall be
converted as for %Y but with unlimited field width, the characters between the two  separators shall
be converted as for %m, and the characters after the last  separator shall be converted as for
%d. If a field width is specified, each of the %Y, %m, and %d conversions shall not convert any
characters past the overall %F field width. The members of the tm structure pointed to by tm shall be set as
specified for the Y, m, and d conversions.
g
The last 2 digits of the week-based year (see below) as a decimal number (for example, 77). Leading zeros shall be permitted
but shall not be required. A leading '+' or '-' character shall be permitted before any leading zeros but shall
not be required. The effect of this year, if any, on the tm structure pointed to by tm is unspecified.
G
The week-based year (see below) as a decimal number (for example, 1977). Leading zeros shall be permitted but shall not be
required. A leading '+' or '-' character shall be permitted before any leading zeros but shall not be required.
The effect of this year, if any, on the tm structure pointed to by tm is unspecified.
h
Equivalent to %b.
H
The hour (24-hour clock) [00,23]; leading zeros shall be permitted but shall not be required. The tm_hour member of the
tm structure pointed to by tm shall be set to this number.
I
The hour (12-hour clock) [01,12]; leading zeros shall be permitted but shall not be required. If a p conversion is
also performed, the tm_hour member of the tm structure pointed to by tm shall be set to the hour, by the
24-hour clock, corresponding to the combined results of the I and p conversions. If a p conversion is
not also performed, the behavior is unspecified.
j
The day number of the year [001,366]; leading zeros shall be permitted but shall not be required. The tm_yday member of
the tm structure pointed to by tm shall be set to this number minus 1.
m
The month number [01,12]; leading zeros shall be permitted but shall not be required. The tm_mon member of the tm
structure pointed to by tm shall be set to this number minus 1.
M
The minute [00,59]; leading zeros shall be permitted but shall not be required. The tm_min member of the tm
structure pointed to by tm shall be set to this number.
n
Any white-space bytes.
p
The locale's equivalent of a.m. or p.m. If an I conversion is also performed, the tm_hour member of the
tm structure pointed to by tm shall be set as specified for the I conversion; otherwise, the behavior is
unspecified.
r
12-hour clock time, if the 12-hour format is supported in the locale (see XBD 7.3.5 LC_TIME); in the POSIX locale, this shall be equivalent to
%I:%M:%S %p. The members of the tm structure pointed to by tm shall be set as
specified for the conversions present in the locale's t_fmt_ampm value.
R
Equivalent to %H:%M.
s
The number of seconds since the Epoch as a decimal number (see XBD 4.19
Seconds Since the Epoch); leading zeros shall be permitted but shall not be required. The effect of this number, if any,
on the tm structure pointed to by tm is unspecified.
S
The seconds [00,60]; leading zeros shall be permitted but shall not be required. The tm_sec member of the tm
structure pointed to by tm shall be set to this number.
t
Any white-space bytes.
T
Equivalent to %H:%M:%S.
u
The weekday as a decimal number [1,7], with 1 representing Monday. The tm_wday member of the tm structure pointed
to by tm shall be set to this number modulo 7.
U
The week number of the year (Sunday as the first day of the week) as a decimal number [00,53]; leading zeros shall be permitted
but shall not be required. The effect of this week number, if any, on the tm structure pointed to by tm is
unspecified.
V
The week number of the week-based year (see below) as a decimal number [01,53]. Leading zeros shall be permitted but shall not
be required. The effect of this week number, if any, on the tm structure pointed to by tm is unspecified.
w
The weekday as a decimal number [0,6], with 0 representing Sunday. The tm_wday member of the tm structure pointed
to by tm shall be set to this number.
W
The week number of the year (Monday as the first day of the week) as a decimal number [00,53]; leading zeros shall be permitted
but shall not be required. The effect of this week number, if any, on the tm structure pointed to by tm is
unspecified.
x
The date, using the locale's date format. The members of the tm structure pointed to by tm shall be set as
specified for the conversions present in the locale's d_fmt value.
X
The time, using the locale's time format. The members of the tm structure pointed to by tm shall be set as
specified for the conversions present in the locale's t_fmt value.
y
The last two digits of the year; leading zeros shall be permitted but shall not be required. A leading '+' or
'-' character shall be permitted before any leading zeros but shall not be required. If a C conversion is not
also performed, values in the range [69,99] shall refer to years 1969 to 1999 inclusive and values in the range [00,68] shall refer
to years 2000 to 2068 inclusive. If a C conversion is also performed, the tm_year member of the tm structure
pointed to by tm shall be set as specified for the C conversion; otherwise, the tm_year member shall be set
to the calculated year minus 1900.
Note:
It is expected that in a future version of this standard the default century inferred from a 2-digit year will change. (This
would apply to all commands accepting a 2-digit year as input.)
Y
The full year {4}; leading zeros shall be permitted but shall not be required. A leading '+' or '-' character
shall be permitted before any leading zeros but shall not be required. The tm_year member of the tm structure pointed
to by tm shall be set to this number minus 1900.
z
The offset from UTC in the ISO 8601:2019 standard format (+hhmm or -hhmm). For example, "-0430"
means 4 hours 30 minutes behind UTC (west of Greenwich). The effect of this offset, if any, on the tm structure pointed to
by tm is unspecified.
Z
The timezone name. If this name matches the name pointed to by tzname[1], and the names pointed to by tzname[0]
and tzname[1] differ, then the tm_isdst member of the tm structure pointed to by tm shall be set to 1.
Otherwise, if this name matches the name pointed to by tzname[0] then the tm_isdst member of the tm structure
pointed to by tm shall be set to 0. The tm_zone and tm_gmtoff members of the structure may also be set in an
unspecified manner. Members other than tm_isdst, tm_zone, and tm_gmtoff may be affected if an s
conversion is also performed but shall otherwise not be affected.
%
Replaced by %.
Modified Conversion Specifiers
Some conversion specifiers can be modified by the E and O modifier characters to indicate that an alternative
format or specification should be used rather than the one normally used by the unmodified conversion specifier. If the alternative
format or specification does not exist in the current locale, the behavior shall be as if the unmodified conversion specification
were used.
%Ec
The locale's alternative appropriate date and time representation.
%EC
The name of the base year (period) in the locale's alternative representation.
%Ex
The locale's alternative date representation.
%EX
The locale's alternative time representation.
%Ey
The offset from %EC (year only) in the locale's alternative representation.
%EY
The full alternative year representation.
%Ob
Equivalent to %b.
%OB
Equivalent to %b.
%Od
The day of the month using the locale's alternative numeric symbols; leading zeros shall be permitted but shall not be
required.
%Oe
Equivalent to %Od.
%Oh
Equivalent to %b.
%OH
The hour (24-hour clock) using the locale's alternative numeric symbols.
%OI
The hour (12-hour clock) using the locale's alternative numeric symbols.
%Om
The month using the locale's alternative numeric symbols.
%OM
The minutes using the locale's alternative numeric symbols.
%OS
The seconds using the locale's alternative numeric symbols.
%OU
The week number of the year (Sunday as the first day of the week) using the locale's alternative numeric symbols.
%OV
The same as %V but using the locale's alternative numeric symbols.
%Ow
The number of the weekday (Sunday=0) using the locale's alternative numeric symbols.
%OW
The week number of the year (Monday as the first day of the week) using the locale's alternative numeric symbols.
%Oy
The year (offset from %C) using the locale's alternative numeric symbols.
%g, %G, and %V convert values according to the ISO 8601:2019 standard week-based year. In this
system, weeks begin on a Monday and week 1 of the week-based year is the week that includes January 4th, which is also the week
that includes the first Thursday of the year, and is also the first week that contains at least four days in the year. If the first
Monday of January is the 2nd, 3rd, or 4th, the preceding days are part of the last week of the preceding week-based year (thus, the
string "1998 53 6" with format specifier "%G %V %u" represents Saturday 2nd January 1999). If December 29th,
30th, or 31st is a Monday, it and any following days are part of week 1 of the following week-based year (thus, the string
"1998 01 2" with format specifier "%G %V %u" represents Tuesday 30th December 1997).
A conversion specification composed of white-space bytes is executed by scanning input up to the first non-white-space byte
(which remains unscanned), or until no more characters can be scanned.
A conversion specification that is an ordinary character is executed by scanning the next character from the buffer. If the
character scanned from the buffer differs from the one comprising the directive, the directive fails, and the differing and
subsequent characters remain unscanned.
A series of conversion specifications composed of %n, %t, white-space bytes, or any combination is executed by
scanning up to the first non-white-space byte (which remains unscanned), or until no more characters can be scanned.
Any other conversion specification is executed by scanning characters until a character matching the next directive is scanned,
or until no more characters can be scanned. These characters, except the one matching the next directive, are then compared to the
locale values associated with the conversion specifier. If a match is found, values for the affected tm structure members
are set as specified in the description of the conversion specification. Case is ignored when matching items in buf such as
month or weekday names. If no match is found, strptime() fails and no more characters are scanned.
RETURN VALUE
Upon successful completion, strptime() shall return a pointer to the character following the last character parsed.
Otherwise, a null pointer shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
Convert a Date-Plus-Time String to Broken-Down Time and Then into
Seconds
The following example demonstrates the use of strptime() to convert a string into broken-down time. The broken-down time
is then converted into seconds since the Epoch using mktime().
#include
...
struct tm tm;
time_t t;
if (strptime("6 Dec 2001 12:33:45", "%d %b %Y %H:%M:%S", &tm) == NULL)
/* Handle error */;
printf("year: %d; month: %d; day: %d;\n",
tm.tm_year, tm.tm_mon, tm.tm_mday);
printf("hour: %d; minute: %d; second: %d\n",
tm.tm_hour, tm.tm_min, tm.tm_sec);
printf("week day: %d; year day: %d\n", tm.tm_wday, tm.tm_yday);
tm.tm_isdst = -1;      /* Not set by strptime(); tells mktime()
to determine whether daylight saving time
is in effect */
t = mktime(&tm);
if (t == -1)
/* Handle error */;
printf("seconds since the Epoch: %ld\n", (long) t);"
APPLICATION USAGE
Several "equivalent to" formats and the special processing of white-space characters are provided in order to ease the use of
identical format strings for strftime() and strptime().
It should be noted that dates constructed by the strftime() function with the
%Y or %C%y conversion specifiers may have values larger than 9999. If the strptime() function is used to
read such values using %C%y or %Y, the year values will be truncated to four digits. Applications should use
%+w%y or %+xY with w and x set large enough to contain the full
value of any years that will be printed or scanned.
The effect of the s conversion is unspecified because existing implementations differ in behavior. Some do a conversion
equivalent to gmtime(), ignoring all available timezone information; some do a
conversion equivalent to localtime(), using the same timezone it would use and
ignoring any timezone information provided by a z or Z conversion. Although none has been observed, there may be
existing (or future) implementations that use timezone information provided by a z or Z conversion, although
using the latter would not be reliable as timezone names are often ambiguous. Applications that need to convert a seconds since the
Epoch value to a tm structure should call gmtime() or localtime() (or their thread-safe equivalents) directly.
The effect of the z conversion is unspecified because existing implementations differ in behavior. Some just use it to
set the tm_gmtoff member of the tm structure; some use the value to adjust the other field members to represent UTC,
convert the resulting time to a seconds since the Epoch value, and then convert back to a tm structure by the equivalent of
localtime(). An application that needs either of these behaviors should perform
the necessary processing explicitly itself.
Although the Z conversion might be expected to set the tm_zone member of the tm structure, no existing
implementation has been found that sets it. Applications that need it set should set it explicitly after calling
strptime().
See also the APPLICATION USAGE section in strftime().
It is unspecified whether multiple calls to strptime() using the same tm structure will update the current
contents of the structure or overwrite all contents of the structure. Conforming applications should make a single call to
strptime() with a format and all data needed to completely specify the date and time being converted.
RATIONALE
See the RATIONALE section for strftime().
FUTURE DIRECTIONS
None.
SEE ALSO
fprintf(), fscanf(), strftime(), time()
XBD
CHANGE HISTORY
First released in Issue 4.
Issue 5
Moved from ENHANCED I18N to BASE.
The [ENOSYS] error is removed.
The exact meaning of the %y and %Oy specifiers is clarified in the DESCRIPTION.
Issue 6
The Open Group Corrigendum U033/5 is applied. The %r specifier description is reworded.
The normative text is updated to avoid use of the term "must" for application requirements.
The restrict keyword is added to the strptime() prototype for alignment with the ISO/IEC 9899:1999
standard.
The Open Group Corrigendum U047/2 is applied.
The DESCRIPTION is updated to use the terms "conversion specifier" and "conversion specification" for consistency with
strftime().
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/133 is applied, adding the example to the EXAMPLES section.
Issue 7
Austin Group Interpretation 1003.1-2001 #041 is applied, updating the DESCRIPTION and APPLICATION USAGE sections.
Austin Group Interpretation 1003.1-2001 #163 is applied.
SD5-XSH-ERN-67 is applied, correcting the APPLICATION USAGE to remove the impression that %Y is 4-digit years.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0345 [920] and XSH/TC2-2008/0346 [919] are applied.
Issue 8
Austin Group Defect 169 is applied, adding the s conversion.
Austin Group Defects 258 and 1166 are applied, adding the Ob, OB, and Oh modified conversions.
Austin Group Defect 879 is applied, adding the F, g, G, u, V, z, and
Z conversions and the OV modified conversion, and adding a statement to the week number conversions that their
effect on the tm structure pointed to by tm is unspecified.
Austin Group Defect 1163 is applied, clarifying the handling of white space in the format string.
Austin Group Defect 1307 is applied, changing the r conversion in relation to locales that do not support the 12-hour
clock format.
Austin Group Defect 1562 is applied, clarifying that it is the application's responsibility to ensure that the format is a
character string, beginning and ending in its initial shift state, if any.
Austin Group Defect 1727 is applied, clarifying which members of the tm structure are updated by each conversion.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fma.html =====
fma
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fma, fmaf, fmal — floating-point multiply-add
SYNOPSIS
#include
double fma(double x, double y, double z);
float fmaf(float x, float y, float z);
long double fmal(long double x, long double y, long double z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute (x * y) + z, rounded as one ternary operation: they shall
compute the value (as if) to infinite precision and round once to the result format, according to the rounding mode characterized
by the value of FLT_ROUNDS.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return (x * y) + z, rounded as one ternary
operation.
If the result overflows or underflows, a range error may occur. [MX]
On systems that support the IEC 60559 Floating-Point
option, if the result overflows a range error shall occur.
If x or y are NaN, a NaN shall be returned.
If x multiplied by y is an exact infinity and z is also an infinity but with the opposite sign, a domain
error shall occur, and either a NaN (if supported), or an implementation-defined value shall be returned.
If one of x and y is infinite, the other is zero, and z is not a NaN, a domain error shall occur, and
either a NaN (if supported), or an implementation-defined value shall be returned.
If one of x and y is infinite, the other is zero, and z is a NaN, a NaN shall be returned and a domain
error may occur.
If x*y is not 0*Inf nor Inf*0 and z is a NaN, a NaN shall be returned.
ERRORS
These functions shall fail if:
Domain Error
[MX]
The value of x*y+z is invalid, or the value x*y is invalid and z is not a NaN.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
Range Error
[MX]
The result overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
These functions may fail if:
Domain Error
[MX]
The value x*y is invalid and z is a NaN.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
Range Error
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
Range Error
The result overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
In many cases, clever use of floating (fused) multiply-add leads to much improved code; but its unexpected use by the
compiler can undermine carefully written code. The FP_CONTRACT macro can be used to disallow use of floating multiply-add; and the
fma() function guarantees its use where desired. Many current machines provide hardware floating multiply-add instructions;
software implementation can be used for others.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #57 (SD5-XSH-ERN-69) is applied, adding a "may fail" range error for
non-MX systems.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fegetenv.html =====
fegetenv
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fegetenv, fesetenv — get and set current floating-point environment
SYNOPSIS
#include
int fegetenv(fenv_t *envp);
int fesetenv(const fenv_t *envp);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The fegetenv() function shall attempt to store the current floating-point environment in the object pointed to by
envp.
The fesetenv() function shall attempt to establish the floating-point environment represented by the object pointed to by
envp. The argument envp shall point to an object set by a call to fegetenv() or feholdexcept(), or equal a floating-point environment macro. The fesetenv()
function does not raise floating-point exceptions, but only installs the state of the floating-point status flags represented
through its argument.
RETURN VALUE
If the representation was successfully stored, fegetenv() shall return zero. Otherwise, it shall return a non-zero value.
If the environment was successfully established, fesetenv() shall return zero. Otherwise, it shall return a non-zero
value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feholdexcept(), feupdateenv()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
ISO/IEC 9899:1999 standard, Technical Corrigendum 1 is incorporated.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/truncf.html =====
trunc
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
trunc, truncf, truncl — round to truncated integer value
SYNOPSIS
#include
double trunc(double x);
float truncf(float x);
long double truncl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall round their argument to the integer value, in floating format, nearest to but no larger in magnitude than
the argument.
[MX]
These functions may raise the inexact floating-point exception for finite non-integer arguments.
RETURN VALUE
Upon successful completion, these functions shall return the truncated integer value.
[MX]  The
returned value shall be exact, shall be independent of the current rounding direction mode, and shall have the same sign as
x.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0 or ±Inf, x shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The integral value returned by these functions need not be expressible as an intmax_t. The return value should be tested
before assigning it to an integer type to avoid the undefined results of an integer overflow.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0684 [346] is applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/symlinkat.html =====
symlink
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
symlink, symlinkat — make a symbolic link
SYNOPSIS
#include
int symlink(const char *path1, const char *path2);
[OH] #include
int symlinkat(const char *path1, int fd, const char *path2);
DESCRIPTION
The symlink() function shall create a symbolic link called path2 that contains the string pointed to by
path1 (path2 is the name of the symbolic link created, path1 is the string contained in the symbolic
link).
The string pointed to by path1 shall be treated only as a string and shall not be validated as a pathname.
If the symlink() function fails for any reason other than [EIO], any file named by path2 shall be unaffected.
If path2 names a symbolic link, symlink() shall fail and set errno to [EEXIST].
The symbolic link's user ID shall be set to the process' effective user ID. The symbolic link's group ID shall be set to the
group ID of the parent directory or to the effective group ID of the process. Implementations shall provide a way to initialize the
symbolic link's group ID to the group ID of the parent directory. Implementations may, but need not, provide an
implementation-defined way to initialize the symbolic link's group ID to the effective group ID of the calling process.
The values of the file mode bits for the created symbolic link are unspecified. All interfaces specified by POSIX.1-2024 shall
behave as if the contents of symbolic links can always be read, except that the value of the file mode bits returned in the
st_mode field of the stat structure is unspecified.
Upon successful completion, symlink() shall mark for update the last data access, last data modification, and last file
status change timestamps of the symbolic link. Also, the last data modification and last file status change timestamps of the
directory that contains the new entry shall be marked for update.
The symlinkat() function shall be equivalent to the symlink() function except in the case where path2
specifies a relative path. In this case the symbolic link is created relative to the directory associated with the file descriptor
fd instead of the current working directory. If the access mode of the open file description associated with the file
descriptor is not O_SEARCH, the function shall check whether directory searches are permitted using the current permissions of the
directory underlying the file descriptor. If the access mode is O_SEARCH, the function shall not perform the check.
If symlinkat() is passed the special value AT_FDCWD in the fd parameter, the current working directory shall be
used and the behavior shall be identical to a call to symlink().
RETURN VALUE
Upon successful completion, these functions shall return 0. Otherwise, these functions shall return -1 and set errno to
indicate the error.
ERRORS
These functions shall fail if:
[EACCES]
Write permission is denied in the directory where the symbolic link is being created, or search permission is denied for a
component of the path prefix of path2.
[EEXIST]
The path2 argument names an existing file.
[EILSEQ]
The last pathname component of path2 is not a portable filename, and cannot be created in the target directory.
[EIO]
An I/O error occurs while reading from or writing to the file system.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path2 argument.
[ENAMETOOLONG]
The length of a component of the pathname specified by the path2 argument is longer than {NAME_MAX} or the length of the
path1 argument is longer than {SYMLINK_MAX}.
[ENOENT]
A component of the path prefix of path2 does not name an existing file or path2 is an empty string.
[ENOENT] or [ENOTDIR]
The path2 argument contains at least one non- character and ends with one or more trailing
characters. If path2 without the trailing  characters would name an existing file, an [ENOENT] error shall not
occur.
[ENOSPC]
The directory in which the entry for the new symbolic link is being placed cannot be extended because no space is left on the
file system containing the directory, or the new symbolic link cannot be created because no space is left on the file system which
shall contain the link, or the file system is out of file-allocation resources.
[ENOTDIR]
A component of the path prefix of path2 names an existing file that is neither a directory nor a symbolic link to a
directory.
[EROFS]
The new symbolic link would reside on a read-only file system.
The symlinkat() function shall fail if:
[EACCES]
The access mode of the open file description associated with fd is not O_SEARCH and the permissions of the directory
underlying fd do not permit directory searches.
[EBADF]
The path2 argument does not specify an absolute path and the fd argument is neither AT_FDCWD nor a valid file
descriptor open for reading or searching.
[ENOTDIR]
The path2 argument is not an absolute path and fd is a file descriptor associated with a non-directory file.
These functions may fail if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path2 argument.
[ENAMETOOLONG]
The length of the path2 argument exceeds {PATH_MAX} or pathname resolution of a symbolic link in the path2 argument
produced an intermediate result with a length that exceeds {PATH_MAX}.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Like a hard link, a symbolic link allows a file to have multiple logical names. The presence of a hard link guarantees the
existence of a file, even after the original name has been removed. A symbolic link provides no such assurance; in fact, the file
named by the path1 argument need not exist when the link is created. A symbolic link can cross file system boundaries.
Normal permission checks are made on each component of the symbolic link pathname during its resolution.
RATIONALE
The purpose of the symlinkat() function is to create symbolic links in directories other than the current working
directory without exposure to race conditions. Any part of the path of a file could be changed in parallel to a call to
symlink(), resulting in unspecified behavior. By opening a file descriptor for the target directory and using the
symlinkat() function it can be guaranteed that the created symbolic link is located relative to the desired directory.
Implementations are encouraged to have symlink() and symlinkat() report an [EILSEQ] error if the last component of
path2 contains any bytes that have the encoded value of a  character.
FUTURE DIRECTIONS
None.
SEE ALSO
fdopendir(), fstatat(),
lchown(), link(), open(), readlink(), rename(), unlink()
XBD ,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The following changes were made to align with the IEEE P1003.1a draft standard:
The DESCRIPTION text is updated.
The [ELOOP] optional error condition is added.
Issue 7
Austin Group Interpretation 1003.1-2001 #143 is applied.
The symlinkat() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 2.
Additions have been made describing how symlink() sets the user and group IDs and file mode of the symbolic link, and its
effect on timestamps.
Changes are made to allow a directory to be opened for searching.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0627 [146,428], XSH/TC1-2008/0628 [461], XSH/TC1-2008/0629 [146,428],
XSH/TC1-2008/0630 [146,428,436], XSH/TC1-2008/0631 [324], XSH/TC1-2008/0632 [278], XSH/TC1-2008/0633 [278], and XSH/TC1-2008/0634
[151] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0357 [873], XSH/TC2-2008/0358 [591], XSH/TC2-2008/0359 [641],
XSH/TC2-2008/0360 [817], XSH/TC2-2008/0361 [822], XSH/TC2-2008/0362 [817], and XSH/TC2-2008/0363 [591] are applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defect 293 is applied, adding the [EILSEQ] error.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/shmat.html =====
shmat
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
shmat — XSI shared memory attach operation
SYNOPSIS
[XSI]  #include
void *shmat(int shmid, const void *shmaddr, int shmflg);
DESCRIPTION
The shmat() function operates on XSI shared memory (see XBD 3.332
Shared Memory Object). It is unspecified whether this function interoperates with the realtime interprocess communication
facilities defined in 2.8 Realtime.
The shmat() function attaches the shared memory segment associated with the shared memory identifier specified by
shmid to the address space of the calling process. The segment is attached at the address specified by one of the following
criteria:
If shmaddr is a null pointer, the segment is attached at the first available address as selected by the system.
If shmaddr is not a null pointer and (shmflg & SHM_RND) is non-zero, the segment is attached at the address given
by ((char *)shmaddr - ((uintptr_t)shmaddr % SHMLBA)). The character '%' is the C-language
remainder operator.
If shmaddr is not a null pointer and (shmflg & SHM_RND) is 0, the segment is attached at the address given by
shmaddr.
The segment is attached for reading if (shmflg & SHM_RDONLY) is non-zero and the calling process has read permission;
otherwise, if (shmflg & SHM_RDONLY) is 0 and the calling process has read and write permission, the segment is attached for
reading and writing.
RETURN VALUE
Upon successful completion, shmat() shall increment the value of shm_nattch in the data structure associated with
the shared memory ID of the attached shared memory segment and return the segment's start address. Also, the shm_atime
timestamp shall be set to the current time, as described in 2.7.1 IPC General
Description.
Otherwise, the shared memory segment shall not be attached, shmat() shall return SHM_FAILED, and errno shall be
set to indicate the error.
ERRORS
The shmat() function shall fail if:
[EACCES]
Operation permission is denied to the calling process; see 2.7 XSI
Interprocess Communication.
[EINVAL]
The value of shmid is not a valid shared memory identifier, the shmaddr is not a null pointer, and the value of
((char *)shmaddr - ((uintptr_t)shmaddr % SHMLBA)) is an illegal address for attaching shared memory; or
the shmaddr is not a null pointer, (shmflg & SHM_RND) is 0, and the value of shmaddr is an illegal address for
attaching shared memory.
[EMFILE]
The number of shared memory segments attached to the calling process would exceed the system-imposed limit.
[ENOMEM]
The available data space is not large enough to accommodate the shared memory segment.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The POSIX Realtime Extension defines alternative interfaces for interprocess communication. Application developers who need to
use IPC should design their applications so that modules using the IPC routines described in 2.7 XSI Interprocess Communication can be easily modified to use the alternative
interfaces.
RATIONALE
The symbol SHM_FAILED is used for the failure return of shmat() for consistency with MAP_FAILED for mmap(). However, SHM_FAILED is required to have the same value as ((void
*)(intptr_t)-1) to provide backwards compatibility for applications written to earlier versions of this standard, where
the failure return was specified as (void *)-1. This means that implementations need to ensure that shmat() cannot
return ((void *)(intptr_t)-1) on a successful call.
FUTURE DIRECTIONS
None.
SEE ALSO
2.7 XSI Interprocess Communication, 2.8 Realtime, exec, exit(), fork(), shmctl(), shmdt(), shmget(), shm_open(), shm_unlink()
XBD 3.332 Shared Memory Object,
CHANGE HISTORY
First released in Issue 2. Derived from Issue 2 of the SVID.
Issue 5
Moved from SHARED MEMORY to BASE.
The note about use of POSIX Realtime Extension IPC routines has been moved from FUTURE DIRECTIONS to a new APPLICATION USAGE
section.
Issue 6
The Open Group Corrigendum U021/13 is applied.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0572 [345] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0327 [522] is applied.
Issue 8
Austin Group Defect 1237 is applied, changing "shmaddr - ..." to "(char *)shmaddr - ...".
Austin Group Defect 1238 is applied, changing the DESCRIPTION to avoid an ambiguous use of "it".
Austin Group Defect 1239 is applied, adding SHM_FAILED.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcslen.html =====
wcslen
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcslen, wcsnlen — get length of a fixed-sized wide-character string
SYNOPSIS
#include
size_t wcslen(const wchar_t *ws);
[CX]  size_t wcsnlen(const wchar_t *ws, size_t maxlen);
DESCRIPTION
For wcslen(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The wcslen() function shall compute the number of wide-character codes in the wide-character string to which ws
points, not including the terminating null wide-character code.
[CX]  The
wcsnlen() function shall compute the smaller of the number of wide characters in the array to which ws points, not
including any terminating null wide-character code, and the value of maxlen. The wcsnlen() function shall never
examine more than the first maxlen characters of the wide-character array pointed to by ws.
[CX]  The
wcslen() and wcsnlen() functions shall not change the setting of errno on valid input.
RETURN VALUE
The wcslen() function shall return the length of ws.
[CX]  The
wcsnlen() function shall return the number of wide characters preceding the first null wide-character code in the array to
which ws points, if ws contains a null wide-character code within the first maxlen wide characters; otherwise,
it shall return maxlen.
No return values are reserved to indicate an error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
strlen(), wcslcat()
XBD
CHANGE HISTORY
First released in Issue 4. Derived from the MSE working draft.
Issue 7
The wcsnlen() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 1.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0390 [560] is applied.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that wcslen() and wcsnlen() do not change the setting of
errno on valid input.
Austin Group Defect 986 is applied, adding wcslcat() to the SEE ALSO section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/setegid.html =====
setegid
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
setegid — set the effective group ID
SYNOPSIS
#include
int setegid(gid_t gid);
DESCRIPTION
If gid is equal to the real group ID or the saved set-group-ID, or if the process has appropriate privileges,
setegid() shall set the effective group ID of the calling process to gid; the real group ID, saved set-group-ID, and
any supplementary group IDs shall remain unchanged.
The setegid() function shall not affect the supplementary group list in any way.
RETURN VALUE
Upon successful completion, 0 shall be returned; otherwise, -1 shall be returned and errno set to indicate the error.
ERRORS
The setegid() function shall fail if:
[EINVAL]
The value of the gid argument is invalid and is not supported by the implementation.
[EPERM]
The process does not have appropriate privileges and gid does not match the real group ID or the saved
set-group-ID.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
Refer to the RATIONALE section in setuid().
FUTURE DIRECTIONS
None.
SEE ALSO
exec, getegid(), geteuid(), getgid(), getresgid(), getresuid(), getuid(), seteuid(), setgid(), setregid(), setresgid(), setresuid(), setreuid(), setuid()
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from the IEEE P1003.1a draft standard.
Issue 8
Austin Group Defect 1344 is applied, adding getresgid(), getresuid(), setresgid(), and setresuid() to SEE ALSO.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/popen.html =====
popen
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
popen — initiate pipe streams to or from a process
SYNOPSIS
[CX]  #include
FILE *popen(const char *command, const char *mode);
DESCRIPTION
The popen() function shall execute the command specified by the string command. It shall create a pipe between the
calling program and the executed command, and shall return a pointer to a stream that can be used to either read from or write to
the pipe.
The environment of the executed command shall be as if a child process were created within the popen() call using the
fork() function, and the child invoked the sh
utility using the call:
execl(, "sh", "-c", "--", command, (char *)0);
where  is an unspecified pathname for the sh utility. It is
implementation-defined whether the handlers registered with pthread_atfork()
are called as part of the creation of the child process.
The popen() function shall ensure that any streams from previous popen() calls that remain open in the parent
process are closed in the new child process, regardless of the FD_CLOEXEC or FD_CLOFORK status of the file descriptor underlying
those streams.
The mode argument to popen() is a string that specifies I/O mode:
If mode starts with 'r', when the child process is started, its file descriptor STDOUT_FILENO shall be the
writable end of the pipe, and the file descriptor fileno(stream) in the calling process, where stream is the
stream pointer returned by popen(), shall be the readable end of the pipe. The FD_CLOFORK flag shall be cleared on both the
STDOUT_FILENO file descriptor passed to the child process and the file descriptor underlying the returned stream.
If mode starts with 'w', when the child process is started its file descriptor STDIN_FILENO shall be the
readable end of the pipe, and the file descriptor fileno(stream) in the calling process, where stream is the
stream pointer returned by popen(), shall be the writable end of the pipe. The FD_CLOFORK flag shall be cleared on both the
STDOUT_FILENO file descriptor passed to the child process and the file descriptor underlying the returned stream.
If mode includes a second character of 'e', then the file descriptor underlying the stream returned to the
calling process by popen() shall have the FD_CLOEXEC flag atomically set. Additionally, if the implementation creates the
file descriptor for use by the child process from within the parent process, then that file descriptor shall have the FD_CLOEXEC
flag atomically set within the parent process. If mode does not have a second character, the FD_CLOEXEC flag of the
underlying file descriptor returned by popen() shall be clear.
If mode is any other value, the result is unspecified.
After popen(), both the parent and the child process shall be capable of executing independently before either
terminates.
Pipe streams are byte-oriented.
RETURN VALUE
Upon successful completion, popen() shall return a pointer to an open stream that can be used to read or write to the
pipe. Otherwise, it shall return a null pointer and may set errno to indicate the error.
ERRORS
The popen() function shall fail if:
[EMFILE]
{STREAM_MAX} streams are currently open in the calling process.
The popen() function may fail if:
[EMFILE]
{FOPEN_MAX} streams are currently open in the calling process.
[EINVAL]
The mode argument is invalid.
The popen() function may also set errno values as described by fork()
or pipe().
The following sections are informative.
EXAMPLES
Using popen() to Obtain a List of Files from the ls Utility
The following example demonstrates the use of popen() and pclose() to
execute the command ls* in order to obtain a list of files in the current directory:
#include
...
FILE *fp;
int status;
char path[PATH_MAX];
fp = popen("ls *", "r");
if (fp == NULL)
/* Handle error */;
while (fgets(path, PATH_MAX, fp) != NULL)
printf("%s", path);
status = pclose(fp);
if (status == -1) {
/* Error reported by pclose() */
...
} else {
/* Use macros described under wait() to inspect `status' in order
to determine success/failure of command executed by popen() */
...
}
APPLICATION USAGE
Since open files are shared, a mode 'r' command can be used as an input filter and a mode 'w' command as an
output filter.
Buffered reading before opening an input filter may leave the standard input of that filter mispositioned. Similar problems with
an output filter may be prevented by careful buffer flushing; for example, with fflush().
A stream opened by popen() should be closed by pclose().
The behavior of popen() is specified for values of mode of "r", "w", "re", and
"we". Other modes such as "rb" and "wb" might be supported by specific implementations, but these would
not be portable features. Note that historical implementations of popen() only check to see if the first character of
mode is 'r'. Thus, a mode of "robert the robot" would be treated as mode "r", and a
mode of "anything else" would be treated as mode "w".
If the application calls waitpid() or waitid() with a pid argument greater than 0, and it still has a stream that was called
with popen() open, it must ensure that pid does not refer to the process started by popen().
To determine whether or not the environment specified in the Shell and Utilities volume of POSIX.1-2024 is present, use the
function call:
sysconf(_SC_2_VERSION)
(See sysconf()).
RATIONALE
The popen() function should not be used by programs that have set user (or group) ID privileges. The fork() and exec family of functions (except
execlp() and execvp()), should be used
instead. This prevents any unforeseen manipulation of the environment of the user that could cause execution of commands not
anticipated by the calling program.
If the original and popen()ed processes both intend to read or write or read and write a common file, and either will be
using FILE-type C functions (fread(), fwrite(), and so on), the rules for sharing file handles must be observed (see 2.5.1 Interaction of File Descriptors and Standard I/O Streams).
The 'e' mode modifier to popen() is necessary to avoid a data race in multi-threaded applications. Without it,
the parent's file descriptor is leaked into a second child process created by one thread in the window between another thread
creating the pipe via popen() then using fileno() and fcntl() on the result. Also, if the popen() implementation temporarily has the child's
file descriptor open within the parent, then that file descriptor could also be leaked if it is not atomically FD_CLOEXEC for the
duration in which it is open in the parent.
The standard only requires that the implementation atomically set FD_CLOEXEC on file descriptors created in the parent process
when the 'e' mode modifier is in effect; implementations may also do so when the 'e' modifier is not in use,
provided that the FD_CLOEXEC bit is eventually cleared before popen() completes, however, this is not required because any
application worried about the potential file descriptor leak will already be using the 'e' modifier.
Implementations are encouraged to add support for a "wf" mode which creates the pipe as if by calling pipe2() with the O_CLOFORK flag and then clearing FD_CLOFORK for the read side of the pipe.
This prevents the write side from leaking into child processes created by other threads, ensuring the child created by
popen() will get end-of-file when the parent closes the write side (although the read side can still be leaked).
Unfortunately there is no way (short of temporarily preventing other threads from creating child processes, or implementing an
atomic create-pipe-and-fork system call) to implement an "rf" mode with the equivalent guarantee that the child created by
popen() will be the only writer. Therefore multi-threaded applications that do not have complete control over process
creation cannot rely on getting end-of-file on the stream and need to use an alternative method of indicating the end of
communications.
Although the standard is clear that a conforming application should not call popen() when file descriptor 0 or 1 is
closed, implementations are encouraged to handle these cases correctly.
The following two examples demonstrate possible implementations of popen() using other standard functions. These examples
are designed to show FD_CLOEXEC handling rather than all aspects of thread safety, and implementations are encouraged to improve
the locking mechanism around the state list to be more efficient, as well as to be more robust if file descriptor 0 or 1 is
returned as either part of the pipe. Also, remember that other implementations are possible, including one that uses an
implementation-specific means of creating a pipe between parent and child where the parent process never has access to the child's
end of the pipe. Both of these examples make use of the following helper functions, documented but not implemented here, to do the
bookkeeping necessary to properly close all file descriptors created by other popen() calls regardless of their FD_CLOEXEC
or FD_CLOFORK status:
/* Obtain mutual exclusion lock, so that no concurrent popen() or
pclose() calls are simultaneously modifying the list of tracked
children. */
static void popen_lock(void);
/* Release mutual exclusion lock, without changing errno. */
static void popen_unlock(void);
/* Add the pid and stream pair to the list of tracked children, prior
to any code that can clear FD_CLOEXEC on the file descriptor
associated with stream. To be used while holding the lock. */
static void popen_add_pair(FILE *stream, pid_t pid);
/* Given a stream, return the associated pid, or -1 with errno set if
the stream was not created by popen(). To be used while holding
the lock. */
static pid_t popen_get_pid(FILE *stream);
/* Remove stream and its corresponding pid from the list of tracked
children. To be used while holding the lock. */
static void popen_remove(FILE *stream);
/* If stream is NULL, return the first tracked child; otherwise,
return the next tracked child. Return NULL if all tracked children
have been returned. To be used while holding the lock. */
static FILE *popen_next(FILE *stream);
The first example is based on fork():
#include
#include
#include
#include
#include
FILE *popen(const char *command, const char *mode)
{
int fds[2];
pid_t pid;
FILE *stream;
int target = mode[0] == 'w'; /* index of fds used by parent */
/* Validate mode */
if ((mode[0] != 'w' && mode[0] != 'r') ||
mode[1 + (mode[1] == 'e')]) {
errno = EINVAL;
return NULL;
}
/* Create pipe and stream with FD_CLOEXEC set */
if (pipe2(fds, O_CLOEXEC) = 0)
fcntl(fds[target], F_SETFD, flags & ~FD_CLOEXEC);
}
return stream;
}
The second example is based on posix_spawn():
#include
#include
#include
#include
#include
#include
extern char **environ;
FILE *popen(const char *command, const char *mode)
{
int fds[2];
pid_t pid;
FILE *stream;
int target = mode[0] == 'w'; /* index of fds used by parent */
const char *argv[] = { "sh", "-c", "--", command, NULL };
posix_spawn_file_actions_t actions;
int saved;
FILE *tracked;
/* Validate mode */
if ((mode[0] != 'w' && mode[0] != 'r') ||
mode[1 + (mode[1] == 'e')]) {
errno = EINVAL;
return NULL;
}
/* Create pipe and stream with FD_CLOEXEC set */
if (pipe2(fds, O_CLOEXEC) = 0)
fcntl(fds[target], F_SETFD, flags & ~FD_CLOEXEC);
}
return stream;
}
Both examples can share a common pclose() implementation.
int pclose(FILE *stream)
{
int status;
popen_lock();
pid_t pid = popen_get_pid(stream);
if (pid  ('-') or  ('+'), as it would then be interpreted as containing options. Now
that implementations are required to pass the "--", applications no longer need to do this.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fork(), pclose(), pipe(), sysconf(), system(), wait(), waitid()
XBD
XCU sh
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
A statement is added to the DESCRIPTION indicating that pipe streams are byte-oriented.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The optional [EMFILE] error condition is added.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/67 is applied, adding the example to the EXAMPLES section.
Issue 7
Austin Group Interpretation 1003.1-2001 #029 is applied, clarifying the values for mode in the DESCRIPTION.
SD5-XSH-ERN-149 is applied, changing the {STREAM_MAX} [EMFILE] error condition from a "may fail" to a "shall fail".
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0432 [14] is applied.
Issue 8
Austin Group Defects 411 and 1318 are applied, adding the 'e' mode modifier and FD_CLOFORK, and adding example
implementations of popen() and pclose() in the RATIONALE section.
Austin Group Defect 1317 is applied, making it implementation-defined whether the handlers registered with pthread_atfork() are called.
Austin Group Defect 1440 is applied, adding a "--" argument to the specified execl() call.
Austin Group Defect 1526 is applied, making typographic changes relating to mode values for consistency with fopen().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/setutxent.html =====
endutxent
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
endutxent, getutxent, getutxid, getutxline, pututxline, setutxent — user accounting database functions
SYNOPSIS
[XSI]  #include
void endutxent(void);
struct utmpx *getutxent(void);
struct utmpx *getutxid(const struct utmpx *id);
struct utmpx *getutxline(const struct utmpx *line);
struct utmpx *pututxline(const struct utmpx *utmpx);
void setutxent(void);
DESCRIPTION
These functions shall provide access to the user accounting database.
The getutxent() function shall read the next entry from the user accounting database. If the database is not already
open, it shall open it. If it reaches the end of the database, it shall fail.
The getutxid() function shall search forward from the current point in the database. If the ut_type value of the
utmpx structure pointed to by id is BOOT_TIME, OLD_TIME, or NEW_TIME, then it shall stop when it finds an entry with
a matching ut_type value. If the ut_type value is INIT_PROCESS, LOGIN_PROCESS, USER_PROCESS, or DEAD_PROCESS, then it
shall stop when it finds an entry whose type is one of these four and whose ut_id member matches the ut_id member of
the utmpx structure pointed to by id. If the end of the database is reached without a match, getutxid() shall
fail.
The getutxline() function shall search forward from the current point in the database until it finds an entry of the type
LOGIN_PROCESS or USER_PROCESS which also has a ut_line value matching that in the utmpx structure pointed to by
line. If the end of the database is reached without a match, getutxline() shall fail.
The getutxid() or getutxline() function may cache data. For this reason, to use getutxline() to search for
multiple occurrences, the application shall zero out the static data after each success, or getutxline() may return a
pointer to the same utmpx structure.
There is one exception to the rule about clearing the structure before further reads are done. The implicit read done by
pututxline() (if it finds that it is not already at the correct place in the user accounting database) shall not modify the
static structure returned by getutxent(), getutxid(), or getutxline(), if the application has modified this
structure and passed the pointer back to pututxline().
For all entries that match a request, the ut_type member indicates the type of the entry. Other members of the entry
shall contain meaningful data based on the value of the ut_type member as follows:
ut_type Member
Other Members with Meaningful Data
EMPTY
No others
BOOT_TIME
ut_tv
OLD_TIME
ut_tv
NEW_TIME
ut_tv
USER_PROCESS
ut_id, ut_user (login name of the user), ut_line, ut_pid, ut_tv
INIT_PROCESS
ut_id, ut_pid, ut_tv
LOGIN_PROCESS
ut_id, ut_user (implementation-defined name of the login process), ut_line, ut_pid,
ut_tv
DEAD_PROCESS
ut_id, ut_pid, ut_tv
An implementation that provides extended security controls may impose implementation-defined restrictions on
accessing the user accounting database. In particular, the system may deny the existence of some or all of the user accounting
database entries associated with users other than the caller.
If the process has appropriate privileges, the pututxline() function shall write out the structure into the
user accounting database. It shall search for a record as if by getutxid() that satisfies the request. If this search
succeeds, then the entry shall be replaced. Otherwise, a new entry shall be made at the end of the user accounting database.
The endutxent() function shall close the user accounting database.
The setutxent() function shall reset the input to the beginning of the database. This should be done before
each search for a new entry if it is desired that the entire database be examined.
These functions need not be thread-safe.
RETURN VALUE
Upon successful completion, getutxent(), getutxid(), and getutxline() shall return a pointer to a
utmpx structure containing a copy of the requested entry in the user accounting database. Otherwise, a null pointer shall be
returned.
The return value may point to a static area which is overwritten by a subsequent call to getutxid() or
getutxline().
Upon successful completion, pututxline() shall return a pointer to a utmpx structure containing a
copy of the entry added to the user accounting database. Otherwise, a null pointer shall be returned.
The endutxent() and setutxent() functions shall not return a value.
ERRORS
No errors are defined for the endutxent(), getutxent(), getutxid(), getutxline(), and
setutxent() functions.
The pututxline() function may fail if:
[EPERM]
The process does not have appropriate privileges.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The sizes of the arrays in the structure can be found using the sizeof operator.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Normative text previously in the APPLICATION USAGE section is moved to the DESCRIPTION.
A note indicating that these functions need not be reentrant is added to the DESCRIPTION.
Issue 6
In the DESCRIPTION, the note about reentrancy is expanded to cover thread-safety.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0090 [213,428] and XSH/TC1-2008/0091 [213] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getdelim.html =====
getdelim
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getdelim, getline — read a delimited record from stream
SYNOPSIS
[CX]  #include
ssize_t getdelim(char **restrict lineptr, size_t *restrict n,
int delimiter, FILE *restrict stream);
ssize_t getline(char **restrict lineptr, size_t *restrict n,
FILE *restrict stream);
DESCRIPTION
The getdelim() function shall read from stream until it encounters a character matching the delimiter
character. The delimiter argument is an int, the value of which the application shall ensure is a character
representable as an unsigned char of equal value that terminates the read process. If the delimiter argument has any
other value, the behavior is undefined.
The application shall ensure that *lineptr is a valid argument that could be passed to the free() function. If *n is non-zero, the application shall ensure that *lineptr
either points to an object of size at least *n bytes, or is a null pointer.
If *lineptr is a null pointer or if the object pointed to by *lineptr is of insufficient size, an object shall be
allocated as if by malloc() or the object shall be reallocated as if by realloc(), respectively, such that the object is large enough to hold the characters to be
written to it, including the terminating NUL, and *n shall be set to the new size. If the object was allocated, or if the
reallocation operation moved the object, *lineptr shall be updated to point to the new object or new location. The
characters read, including any delimiter, shall be stored in the object, and a terminating NUL added when the delimiter or
end-of-file is encountered.
The getline() function shall be equivalent to the getdelim() function with the delimiter character equal to
the  character.
The getdelim() and getline() functions may mark the last data access timestamp of the file associated with
stream for update. The last data access timestamp shall be marked for update by the first successful execution of fgetc(), fgets(), fread(), fscanf(), getc(), getchar(), getdelim(),
getline(), or scanf() using stream that returns data not supplied by a
prior call to ungetc().
RETURN VALUE
Upon successful completion, the getline() and getdelim() functions shall return the number of bytes written into
the buffer, including the delimiter character if one was encountered before EOF, but excluding the terminating NUL character. If
the end-of-file indicator for the stream is set, or if no characters were read and the stream is at end-of-file, the end-of-file
indicator for the stream shall be set and the function shall return -1. If an error occurs, the error indicator for the stream
shall be set, and the function shall return -1 and set errno to indicate the error.
ERRORS
For the conditions under which the getdelim() and getline() functions shall fail and may fail, refer to fgetc().
In addition, these functions shall fail if:
[EINVAL]
lineptr or n is a null pointer.
[ENOMEM]
Insufficient memory is available.
These functions may fail if:
[EOVERFLOW]
The number of bytes to be written into the buffer, including the delimiter character (if encountered), would exceed
{SSIZE_MAX}.
The following sections are informative.
EXAMPLES
#include
#include
int main(void)
{
FILE *fp;
char *line = NULL;
size_t len = 0;
ssize_t read;
fp = fopen("/etc/motd", "r");
if (fp == NULL)
exit(1);
while ((read = getline(&line, &len, fp)) != -1) {
printf("Retrieved line of length %zu :\n", read);
printf("%s", line);
}
if (ferror(fp)) {
/* handle error */
}
free(line);
fclose(fp);
return 0;
}
APPLICATION USAGE
Setting *lineptr to a null pointer and *n to zero are allowed and a recommended way to start parsing a file.
The ferror() or feof() functions
should be used to distinguish between an error condition and an end-of-file condition.
Although a null terminator is always supplied after the line, note that strlen(*lineptr) will be smaller than the
return value if the line contains embedded NUL characters.
RATIONALE
These functions are widely used to solve the problem that the fgets() function has
with long lines. The functions automatically enlarge the target buffers if needed. These are especially useful since they reduce
code needed for applications.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fgetc(), fgets(), free(), malloc(), realloc()
XBD
CHANGE HISTORY
First released in Issue 7.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0237 [14] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0153 [569], XSH/TC2-2008/0154 [571], and XSH/TC2-2008/0155 [570] are
applied.
Issue 8
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
Austin Group Defect 1621 is applied, changing "NUL terminator" to "null terminator".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_cleanup_push.html =====
pthread_cleanup_pop
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_cleanup_pop, pthread_cleanup_push — establish cancellation handlers
SYNOPSIS
#include
void pthread_cleanup_pop(int execute);
void pthread_cleanup_push(void (*routine)(void*), void *arg);
DESCRIPTION
The pthread_cleanup_pop() function shall remove the routine at the top of the calling thread's cancellation cleanup stack
and optionally invoke it (if execute is non-zero).
The pthread_cleanup_push() function shall push the specified cancellation cleanup handler routine onto the calling
thread's cancellation cleanup stack. The cancellation cleanup handler shall be popped from the cancellation cleanup stack and
invoked with the argument arg when:
The thread exits (that is, calls pthread_exit()).
The thread acts upon a cancellation request.
The thread calls pthread_cleanup_pop() with a non-zero execute argument.
It is unspecified whether pthread_cleanup_push() and pthread_cleanup_pop() are macros or functions. If a macro
definition is suppressed in order to access an actual function, or a program defines an external identifier with any of these
names, the behavior is undefined. The application shall ensure that they appear as statements, and in pairs within the same lexical
scope (that is, the pthread_cleanup_push() macro may be thought to expand to a token list whose first token is '{'
with pthread_cleanup_pop() expanding to a token list whose last token is the corresponding '}').
The effect of calling longjmp() or siglongjmp() is undefined if there have been any calls to pthread_cleanup_push()
or pthread_cleanup_pop() made without the matching call since the jump buffer was filled. The effect of calling longjmp() or siglongjmp() from inside a
cancellation cleanup handler is also undefined unless the jump buffer was also filled in the cancellation cleanup handler.
Invoking a cancellation cleanup handler may terminate the execution of any code block being executed by the thread whose
execution began after the corresponding invocation of pthread_cleanup_push().
The effect of the use of return, break, continue, and goto to prematurely leave a code block
described by a pair of pthread_cleanup_push() and pthread_cleanup_pop() functions calls is undefined.
RETURN VALUE
The pthread_cleanup_push() and pthread_cleanup_pop() functions shall not return a value.
ERRORS
No errors are defined.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
The following is an example using thread primitives to implement a cancelable, writers-priority read-write lock:
typedef struct {
pthread_mutex_t lock;
pthread_cond_t rcond,
wcond;
int lock_count; /*  0 .. Held by lock_count readers. */
/* = 0 .. Held by nobody. */
int waiting_writers; /* Count of waiting writers. */
} rwlock;
void
waiting_reader_cleanup(void *arg)
{
rwlock *l;
l = (rwlock *) arg;
pthread_mutex_unlock(&l->lock);
}
void
lock_for_read(rwlock *l)
{
pthread_mutex_lock(&l->lock);
pthread_cleanup_push(waiting_reader_cleanup, l);
while ((l->lock_count waiting_writers != 0))
pthread_cond_wait(&l->rcond, &l->lock);
l->lock_count++;
/*
* Note the pthread_cleanup_pop executes
* waiting_reader_cleanup.
*/
pthread_cleanup_pop(1);
}
void
release_read_lock(rwlock *l)
{
pthread_mutex_lock(&l->lock);
if (--l->lock_count == 0)
pthread_cond_signal(&l->wcond);
pthread_mutex_unlock(&l->lock);
}
void
waiting_writer_cleanup(void *arg)
{
rwlock *l;
l = (rwlock *) arg;
if ((--l->waiting_writers == 0) && (l->lock_count >= 0)) {
/*
* This only happens if we have been canceled. If the
* lock is not held by a writer, there may be readers who
* were blocked because waiting_writers was positive; they
* can now be unblocked.
*/
pthread_cond_broadcast(&l->rcond);
}
pthread_mutex_unlock(&l->lock);
}
void
lock_for_write(rwlock *l)
{
pthread_mutex_lock(&l->lock);
l->waiting_writers++;
pthread_cleanup_push(waiting_writer_cleanup, l);
while (l->lock_count != 0)
pthread_cond_wait(&l->wcond, &l->lock);
l->lock_count = -1;
/*
* Note the pthread_cleanup_pop executes
* waiting_writer_cleanup.
*/
pthread_cleanup_pop(1);
}
void
release_write_lock(rwlock *l)
{
pthread_mutex_lock(&l->lock);
l->lock_count = 0;
if (l->waiting_writers == 0)
pthread_cond_broadcast(&l->rcond);
else
pthread_cond_signal(&l->wcond);
pthread_mutex_unlock(&l->lock);
}
/*
* This function is called to initialize the read/write lock.
*/
void
initialize_rwlock(rwlock *l)
{
pthread_mutex_init(&l->lock, pthread_mutexattr_default);
pthread_cond_init(&l->wcond, pthread_condattr_default);
pthread_cond_init(&l->rcond, pthread_condattr_default);
l->lock_count = 0;
l->waiting_writers = 0;
}
reader_thread()
{
lock_for_read(&lock);
pthread_cleanup_push(release_read_lock, &lock);
/*
* Thread has read lock.
*/
pthread_cleanup_pop(1);
}
writer_thread()
{
lock_for_write(&lock);
pthread_cleanup_push(release_write_lock, &lock);
/*
* Thread has write lock.
*/
pthread_cleanup_pop(1);
}
APPLICATION USAGE
The two routines that push and pop cancellation cleanup handlers, pthread_cleanup_push() and
pthread_cleanup_pop(), can be thought of as left and right-parentheses. They always need to be matched.
RATIONALE
The restriction that the two routines that push and pop cancellation cleanup handlers, pthread_cleanup_push() and
pthread_cleanup_pop(), have to appear in the same lexical scope allows for efficient macro or compiler implementations and
efficient storage management. A sample implementation of these routines as macros might look like this:
#define pthread_cleanup_push(rtn,arg) { \
struct _pthread_handler_rec __cleanup_handler, **__head; \
__cleanup_handler.rtn = rtn; \
__cleanup_handler.arg = arg; \
(void) pthread_getspecific(_pthread_handler_key, &__head); \
__cleanup_handler.next = *__head; \
*__head = &__cleanup_handler;
#define pthread_cleanup_pop(ex) \
*__head = __cleanup_handler.next; \
if (ex) (*__cleanup_handler.rtn)(__cleanup_handler.arg); \
}
A more ambitious implementation of these routines might do even better by allowing the compiler to note that the cancellation
cleanup handler is a constant and can be expanded inline.
This volume of POSIX.1-2024 currently leaves unspecified the effect of calling longjmp() from a signal handler executing in a POSIX System Interfaces function. If an
implementation wants to allow this and give the programmer reasonable behavior, the longjmp() function has to call all cancellation cleanup handlers that have been pushed but
not popped since the time setjmp() was called.
Consider a multi-threaded function called by a thread that uses signals. If a signal were delivered to a signal handler during
the operation of qsort() and that handler were to call longjmp() (which, in turn, did not call the cancellation cleanup handlers) the helper
threads created by the qsort() function would not be canceled. Instead, they would
continue to execute and write into the argument array even though the array might have been popped off the stack.
Note that the specified cleanup handling mechanism is especially tied to the C language and, while the requirement for a uniform
mechanism for expressing cleanup is language-independent, the mechanism used in other languages may be quite different. In
addition, this mechanism is really only necessary due to the lack of a real exception mechanism in the C language, which would be
the ideal solution.
There is no notion of a cancellation cleanup-safe function. If an application has no cancellation points in its signal handlers,
blocks any signal whose handler may have cancellation points while calling async-unsafe functions, or disables cancellation while
calling async-unsafe functions, all functions may be safely called from cancellation cleanup routines.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_cancel(), pthread_setcancelstate()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_cleanup_pop() and pthread_cleanup_push() functions are marked as part of the Threads option.
The APPLICATION USAGE section is added.
The normative text is updated to avoid use of the term "must" for application requirements.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/88 is applied, updating the DESCRIPTION to describe the
consequences of prematurely leaving a code block defined by the pthread_cleanup_push() and pthread_cleanup_pop()
functions.
Issue 7
The pthread_cleanup_pop() and pthread_cleanup_push() functions are moved from the Threads option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0454 [229] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0268 [624] is applied.
Issue 8
Austin Group Defect 613 is applied, clarifying the relationship of automatic object lifetimes to cancellation cleanup
functions.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/gethostid.html =====
gethostid
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
gethostid — get an identifier for the current host
SYNOPSIS
[XSI]  #include
long gethostid(void);
DESCRIPTION
The gethostid() function shall retrieve a 32-bit identifier for the current host.
RETURN VALUE
Upon successful completion, gethostid() shall return an identifier for the current host.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
This volume of POSIX.1-2024 does not define the domain in which the return value is unique.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
initstate()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/socket.html =====
socket
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
socket — create an endpoint for communication
SYNOPSIS
#include
int socket(int domain, int type, int protocol);
DESCRIPTION
The socket() function shall create an unbound socket in a communications domain, and return a file descriptor that can be
used in later function calls that operate on sockets. The file descriptor shall be allocated as described in 2.6 File Descriptor Allocation.
The socket() function takes the following arguments:
domain
Specifies the communications domain in which a socket is to be created.
type
Specifies the type of socket to be created.
protocol
Specifies a particular protocol to be used with the socket. Specifying a protocol of 0 causes socket() to use an
unspecified default protocol appropriate for the requested socket type.
The domain argument specifies the address family used in the communications domain. The address families supported by the
system are implementation-defined.
Symbolic constants that can be used for the domain argument are defined in the  header.
The type argument specifies the socket type, which determines the semantics of communication over the socket. The
following socket types are defined; implementations may specify additional socket types:
SOCK_STREAM
Provides sequenced, reliable, bidirectional, connection-mode byte streams, and may provide a transmission mechanism for
out-of-band data.
SOCK_DGRAM
Provides datagrams, which are connectionless-mode, unreliable messages of fixed maximum length.
SOCK_SEQPACKET
Provides sequenced, reliable, bidirectional, connection-mode transmission paths for records. A record can be sent using one or more
output operations and received using one or more input operations, but a single operation never transfers part of more than one
record. Record boundaries are visible to the receiver via the MSG_EOR flag.
Additionally, the type argument can contain the bitwise-inclusive OR of flags from the following list:
SOCK_CLOEXEC
Atomically set the FD_CLOEXEC flag on the new file descriptor.
SOCK_CLOFORK
Atomically set the FD_CLOFORK flag on the new file descriptor.
SOCK_NONBLOCK
Set the O_NONBLOCK file status flag on the new file description.
Implementations may define additional flags.
If the protocol argument is non-zero, it shall specify a protocol that is supported by the address family. If the
protocol argument is zero, the default protocol for this address family and type shall be used. The protocols supported by
the system are implementation-defined.
The process may need to have appropriate privileges to use the socket() function or to create some sockets.
RETURN VALUE
Upon successful completion, socket() shall return a non-negative integer, the socket file descriptor. Otherwise, a value
of -1 shall be returned and errno set to indicate the error.
ERRORS
The socket() function shall fail if:
[EAFNOSUPPORT]
The implementation does not support the specified address family.
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
No more file descriptors are available for the system.
[EPROTONOSUPPORT]
The value of protocol is non-zero and either the protocol is not supported by the address family or the protocol is not
supported by the implementation.
[EPROTOTYPE]
The value of protocol is non-zero and the socket type is not supported by the protocol.
[ESOCKTNOSUPPORT]
[OB]
or [EPROTONOSUPPORT] or [EPROTOTYPE]
The socket type is not supported by the address family, or the socket type is not supported by the implementation.
The socket() function may fail if:
[EACCES]
The process does not have appropriate privileges.
[ENOBUFS]
Insufficient resources were available in the system to perform the operation.
[ENOMEM]
Insufficient memory was available to fulfill the request.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The documentation for specific address families specifies which protocols each address family supports. The documentation for
specific protocols specifies which socket types each protocol supports.
The application can determine whether an address family is supported by trying to create a socket with domain set to the
protocol in question.
RATIONALE
The use of the SOCK_CLOEXEC and SOCK_CLOFORK flags in the type argument of socket() is necessary to avoid a data
race in multi-threaded applications. Without SOCK_CLOFORK, a file descriptor is leaked into a child process created by one thread
in the window between another thread calling socket() and using fcntl() to set
the FD_CLOFORK flag. Without SOCK_CLOEXEC, a file descriptor intentionally inherited by child processes is similarly leaked into an
executed program if FD_CLOEXEC is not set atomically. The SOCK_NONBLOCK flag is for convenience in avoiding additional fcntl() calls.
Historically the standard did not specify the errno value to be used when the socket type is not supported, and there
were differences between implementations. Some reused the existing standard [EPROTONOSUPPORT] or [EPROTOTYPE] values while others
set errno to a (then) non-standard value of [ESOCKTNOSUPPORT]. All three values are permitted in this version of the
standard, but the use of [EPROTONOSUPPORT] or [EPROTOTYPE] is considered to be misleading when no protocol is specified (that is,
the value of protocol is zero) and consequently those alternatives have been marked obsolescent. If protocol is
non-zero, since there is no precedence between error conditions, all three values will still be permitted even after the
obsolescent alternatives for the [ESOCKTNOSUPPORT] condition have been removed.
FUTURE DIRECTIONS
A future version of this standard may disallow setting errno to [EPROTONOSUPPORT] or [EPROTOTYPE] when the socket type is
not supported and protocol is zero.
SEE ALSO
2.6 File Descriptor Allocation, accept, bind, close, connect, getsockname, getsockopt, listen, recv, recvfrom, recvmsg, send, sendmsg, setsockopt, shutdown, socketpair
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
Issue 7
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0335 [835] is applied.
Issue 8
Austin Group Defects 411 and 1318 are applied, adding SOCK_CLOEXEC, SOCK_CLOFORK, and SOCK_NONBLOCK.
Austin Group Defect 1067 is applied, adding the [ESOCKTNOSUPPORT] error and changing the [EPROTONOSUPPORT] and [EPROTOTYPE]
errors.
Austin Group Defect 1475 is applied, adding close() to the SEE ALSO section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/endprotoent.html =====
endprotoent
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
endprotoent, getprotobyname, getprotobynumber, getprotoent, setprotoent — network protocol database
functions
SYNOPSIS
#include
void endprotoent(void);
struct protoent *getprotobyname(const char *name);
struct protoent *getprotobynumber(int proto);
struct protoent *getprotoent(void);
void setprotoent(int stayopen);
DESCRIPTION
These functions shall retrieve information about protocols. This information is considered to be stored in a database that can
be accessed sequentially or randomly. The implementation of this database is unspecified.
The setprotoent() function shall open a connection to the database, and set the next entry to the first entry. If the
stayopen argument is non-zero, the connection to the network protocol database shall not be closed after each call to
getprotoent() (either directly, or indirectly through one of the other getproto*() functions), and the implementation
may maintain an open file descriptor for the database. If a file descriptor is used, the FD_CLOEXEC flag shall be set; see .
The getprotobyname() function shall search the database from the beginning and find the first entry for which the
protocol name specified by name matches the p_name member, opening and closing a connection to the database as
necessary.
The getprotobynumber() function shall search the database from the beginning and find the first entry for which the
protocol number specified by proto matches the p_proto member, opening and closing a connection to the database as
necessary.
The getprotoent() function shall read the next entry of the database, opening and closing a connection to the database as
necessary.
The getprotobyname(), getprotobynumber(), and getprotoent() functions shall each return a pointer to a
protoent structure, the members of which shall contain the fields of an entry in the network protocol database.
The endprotoent() function shall close the connection to the database, releasing any open file descriptor.
These functions need not be thread-safe.
RETURN VALUE
Upon successful completion, getprotobyname(), getprotobynumber(), and getprotoent() return a pointer to a
protoent structure if the requested entry was found, and a null pointer if the end of the database was reached or the
requested entry was not found. Otherwise, a null pointer is returned.
The application shall not modify the structure to which the return value points, nor any storage areas pointed to by pointers
within the structure. The returned pointer, and pointers within the structure, might be invalidated or the structure or the storage
areas might be overwritten by a subsequent call to getprotobyname(), getprotobynumber(), or getprotoent(). The
returned pointer, and pointers within the structure, might also be invalidated if the calling thread is terminated.
ERRORS
The getprotobyname(), getprotobynumber(), getprotoent(), and setprotoent() functions may fail
if:
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum allowable number of files is currently open in the system.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0085 [75] and XSH/TC1-2008/0086 [75] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0091 [656] is applied.
Issue 8
Austin Group Defect 368 is applied, adding a requirement for FD_CLOEXEC to be set if a file descriptor is used, and adding the
[EMFILE] and [ENFILE] errors.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/expm1l.html =====
expm1
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
expm1, expm1f, expm1l — compute exponential functions
SYNOPSIS
#include
double expm1(double x);
float expm1f(float x);
long double expm1l(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute ex-1.0.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions return ex-1.0.
If the correct value would cause overflow, a range error shall occur and expm1(), expm1f(), and expm1l()
shall return the value of the macro HUGE_VAL, HUGE_VALF, and HUGE_VALL, respectively.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, ±0 shall be returned.
If x is -Inf, -1 shall be returned.
If x is +Inf, x shall be returned.
[MXX]
If x is subnormal, x should be returned.
[MX]  If x is subnormal, a range error may occur and, if x is
not returned, expm1(), expm1f(), and expm1l() shall return an implementation-defined value no greater in
magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
ERRORS
These functions shall fail if:
Range Error
The result overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
These functions may fail if:
Range Error
[MX]
The value of x is subnormal.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The value of expm1(x) may be more accurate than exp(x)-1.0 for small values of x.
The expm1() and log1p() functions are useful for financial calculations of
((1+x)n-1)/x, namely:
expm1(n * log1p(x))/x
when x is very small (for example, when calculating small daily interest rates). These functions also simplify writing
accurate inverse hyperbolic functions.
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
exp(), feclearexcept(),
fetestexcept(), ilogb(),
log1p()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The expm1f() and expm1l() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The expm1() function is no longer marked as an extension.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0110 [68] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0103 [630] is applied.
Issue 8
Austin Group Defect 1382 is applied, rearranging the text describing the behavior when x is subnormal to avoid the need
for two shading changes.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_rwlock_timedrdlock.html =====
pthread_rwlock_clockrdlock
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_rwlock_clockrdlock, pthread_rwlock_timedrdlock — lock a read-write lock for reading
SYNOPSIS
#include
int pthread_rwlock_clockrdlock(pthread_rwlock_t *restrict rwlock,
clockid_t clock_id, const struct timespec *restrict
abstime);
int pthread_rwlock_timedrdlock(pthread_rwlock_t *restrict rwlock,
const struct timespec *restrict abstime);
DESCRIPTION
The pthread_rwlock_clockrdlock() and pthread_rwlock_timedrdlock() functions shall apply a read lock to the
read-write lock referenced by rwlock as in the pthread_rwlock_rdlock() function. However, if the lock cannot be acquired
without waiting for other threads to unlock the lock, this wait shall be terminated when the specified timeout expires. The timeout
shall expire when the absolute time specified by abstime passes, as measured by the clock on which timeouts are based (that
is, when the value of that clock equals or exceeds abstime), or if the absolute time specified by abstime has already
been passed at the time of the call.
For pthread_rwlock_timedrdlock(), the timeout shall be based on the CLOCK_REALTIME clock. For
pthread_rwlock_clockrdlock(), the timeout shall be based on the clock specified by the clock_id argument. The
resolution of the timeout shall be the resolution of the clock on which it is based. Implementations shall support passing
CLOCK_REALTIME and CLOCK_MONOTONIC to pthread_rwlock_clockrdlock() as the clock_id argument.
Under no circumstances shall the function fail with a timeout if the lock can be acquired immediately. The validity of the
abstime parameter need not be checked if the lock can be immediately acquired.
If a signal that causes a signal handler to be executed is delivered to a thread blocked on a read-write lock via a call to
pthread_rwlock_clockrdlock() or pthread_rwlock_timedrdlock(), upon return from the signal handler the thread shall
resume waiting for the lock as if it was not interrupted.
The calling thread may deadlock if at the time the call is made it holds a write lock on rwlock. The results are
undefined if these functions are called with an uninitialized read-write lock.
RETURN VALUE
The pthread_rwlock_clockrdlock() and pthread_rwlock_timedrdlock() functions shall return zero if the lock for
reading on the read-write lock object referenced by rwlock is acquired. Otherwise, an error number shall be returned to
indicate the error.
ERRORS
The pthread_rwlock_clockrdlock() and pthread_rwlock_timedrdlock() functions shall fail if:
[ETIMEDOUT]
The lock could not be acquired before the specified timeout expired.
The pthread_rwlock_clockrdlock() and pthread_rwlock_timedrdlock() functions may fail if:
[EAGAIN]
The read lock could not be acquired because the maximum number of read locks for lock would be exceeded.
[EDEADLK]
A deadlock condition was detected or the calling thread already holds a write lock on rwlock.
[EINVAL]
The abstime nanosecond value is less than zero or greater than or equal to 1000 million, or the
pthread_rwlock_clockrdlock() function was passed an invalid or unsupported clock_id value.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications using these functions may be subject to priority inversion, as discussed in XBD 3.275 Priority Inversion.
RATIONALE
If an implementation detects that the value specified by the rwlock argument to pthread_rwlock_clockrdlock() or
pthread_rwlock_timedrdlock() does not refer to an initialized read-write lock object, it is recommended that the function
should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_rwlock_clockwrlock(), pthread_rwlock_destroy(), pthread_rwlock_rdlock(), pthread_rwlock_trywrlock(), pthread_rwlock_unlock()
XBD 3.275 Priority Inversion, 4.15.2 Memory Synchronization, ,
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1j-2000.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/102 is applied, updating the ERRORS section so that the
[EDEADLK] error includes detection of a deadlock condition.
Issue 7
The pthread_rwlock_timedrdlock() function is moved from the Timeouts option to the Base.
The [EINVAL] error for an uninitialized read-write lock object is removed; this condition results in undefined behavior.
Issue 8
Austin Group Defect 592 is applied, removing text relating to  from
the SYNOPSIS and DESCRIPTION sections.
Austin Group Defects 1216 and 1472 are applied, adding pthread_rwlock_clockrdlock().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/modfl.html =====
modf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
modf, modff, modfl — decompose a floating-point number
SYNOPSIS
#include
double modf(double x, double *iptr);
float modff(float value, float *iptr);
long double modfl(long double value, long double *iptr);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall break the argument x into integral and fractional parts, each of which has the same sign as the
argument. It stores the integral part as a double (for the modf() function), a float (for the modff()
function), or a long double (for the modfl() function), in the object pointed to by iptr.
RETURN VALUE
Upon successful completion, these functions shall return the signed fractional part of x.
[MX]  The
returned value shall be exact and shall be independent of the current rounding direction mode.
If x is NaN, a NaN shall be returned, and *iptr shall be set to a NaN.
If x is ±Inf, ±0 shall be returned, and *iptr shall be set to ±Inf.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The modf() function computes the function result and *iptr such that:
a = modf(x, iptr) ;
x == a+*iptr ;
allowing for the usual floating-point inaccuracies.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
frexp(), isnan(), ldexp()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The modff() and modfl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/35 is applied, correcting the code example in the APPLICATION
USAGE section.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/modf.html =====
modf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
modf, modff, modfl — decompose a floating-point number
SYNOPSIS
#include
double modf(double x, double *iptr);
float modff(float value, float *iptr);
long double modfl(long double value, long double *iptr);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall break the argument x into integral and fractional parts, each of which has the same sign as the
argument. It stores the integral part as a double (for the modf() function), a float (for the modff()
function), or a long double (for the modfl() function), in the object pointed to by iptr.
RETURN VALUE
Upon successful completion, these functions shall return the signed fractional part of x.
[MX]  The
returned value shall be exact and shall be independent of the current rounding direction mode.
If x is NaN, a NaN shall be returned, and *iptr shall be set to a NaN.
If x is ±Inf, ±0 shall be returned, and *iptr shall be set to ±Inf.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The modf() function computes the function result and *iptr such that:
a = modf(x, iptr) ;
x == a+*iptr ;
allowing for the usual floating-point inaccuracies.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
frexp(), isnan(), ldexp()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The modff() and modfl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/35 is applied, correcting the code example in the APPLICATION
USAGE section.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/setpgid.html =====
setpgid
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
setpgid — set process group ID for job control
SYNOPSIS
#include
int setpgid(pid_t pid, pid_t pgid);
DESCRIPTION
The setpgid() function shall either join an existing process group or create a new process group within the session of
the calling process.
The process group ID of a session leader shall not change.
Upon successful completion, the process group ID of the process with a process ID that matches pid shall be set to
pgid.
As a special case, if pid is 0, the process ID of the calling process shall be used. Also, if pgid is 0, the
process ID of the indicated process shall be used.
RETURN VALUE
Upon successful completion, setpgid() shall return 0; otherwise, -1 shall be returned and errno shall be set to
indicate the error.
ERRORS
The setpgid() function shall fail if:
[EACCES]
The value of the pid argument matches the process ID of a child process of the calling process and the child process has
successfully executed one of the exec functions.
[EINVAL]
The value of the pgid argument is less than 0, or is not a value supported by the implementation.
[EPERM]
The process indicated by the pid argument is a session leader.
[EPERM]
The value of the pid argument matches the process ID of a child process of the calling process and the child process is
not in the same session as the calling process.
[EPERM]
The value of the pgid argument is valid but does not match the process ID of the process indicated by the pid
argument and there is no process with a process group ID that matches the value of the pgid argument in the same session as
the calling process.
[ESRCH]
The value of the pid argument does not match the process ID of the calling process or of a child process of the calling
process.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The setpgid() function shall group processes together for the purpose of signaling, placement in foreground or
background, and other job control actions.
The setpgid() function is similar to the setpgrp() function of 4.2 BSD, except that 4.2 BSD allowed the specified
new process group to assume any value. This presents certain security problems and is more flexible than necessary to support job
control.
To provide tighter security, setpgid() only allows the calling process to join a process group already in use inside its
session or create a new process group whose process group ID was equal to its process ID.
When a job control shell spawns a new job, the processes in the job must be placed into a new process group via
setpgid(). There are two timing constraints involved in this action:
The new process must be placed in the new process group before the appropriate program is launched via one of the exec functions.
The new process must be placed in the new process group before the shell can correctly send signals to the new process
group.
To address these constraints, the following actions are performed. The new processes call setpgid() to alter their own
process groups after fork() but before exec. This satisfies the first constraint. Under 4.3 BSD, the second constraint is satisfied by
the synchronization property of vfork(); that is, the shell is suspended until the child has completed the exec, thus ensuring that the child has completed the setpgid(). A new version of fork() with this same synchronization property was considered, but it was decided instead to
merely allow the parent shell process to adjust the process group of its child processes via setpgid(). Both timing
constraints are now satisfied by having both the parent shell and the child attempt to adjust the process group of the child
process; it does not matter which succeeds first.
Since it would be confusing to an application to have its process group change after it began executing (that is, after
exec), and because the child process would already have adjusted its process group
before this, the [EACCES] error was added to disallow this.
One non-obvious use of setpgid() is to allow a job control shell to return itself to its original process group (the one
in effect when the job control shell was executed). A job control shell does this before returning control back to its parent when
it is terminating or suspending itself as a way of restoring its job control "state" back to what its parent would expect. (Note
that the original process group of the job control shell typically matches the process group of its parent, but this is not
necessarily always the case.)
FUTURE DIRECTIONS
None.
SEE ALSO
exec, getpgrp(), setsid(), tcsetpgrp()
XBD ,
CHANGE HISTORY
First released in Issue 3. Included for alignment with the POSIX.1-1988 standard.
Issue 6
In the SYNOPSIS, the optional include of the  header is
removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
The setpgid() function is mandatory since _POSIX_JOB_CONTROL is required to be defined in this version. This is a FIPS
requirement.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/56 is applied, changing the wording in the DESCRIPTION from
"the process group ID of the indicated process shall be used" to "the process ID of the indicated process shall be used". This
change reverts the wording to as in the ISO POSIX-1:1996 standard; it appeared to be an unintentional change.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/log10.html =====
log10
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
log10, log10f, log10l — base 10 logarithm function
SYNOPSIS
#include
double log10(double x);
float log10f(float x);
long double log10l(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the base 10 logarithm of their argument x, log10(x).
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the base 10 logarithm of x.
If x is ±0, a pole error shall occur and log10(), log10f(), and log10l() shall return -HUGE_VAL,
-HUGE_VALF, and -HUGE_VALL, respectively.
For finite values of x that are less than 0, [MX]   or if x is -Inf,  a domain error shall occur, and [MX]   either a NaN (if supported), or   an implementation-defined value shall be returned.
[MX]  If
x is NaN, a NaN shall be returned.
If x is 1, +0 shall be returned.
If x is +Inf, +Inf shall be returned.
ERRORS
These functions shall fail if:
Domain Error
The finite value of x is negative, [MX]   or x is -Inf.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
Pole Error
The value of x is zero.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the divide-by-zero floating-point exception shall
be raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), isnan(), log(), pow()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
The log10f() and log10l() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/tcsendbreak.html =====
tcsendbreak
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
tcsendbreak — send a break for a specific duration
SYNOPSIS
#include
int tcsendbreak(int fildes, int duration);
DESCRIPTION
If the terminal is using asynchronous serial data transmission, tcsendbreak() shall cause transmission of a continuous
stream of zero-valued bits for a specific duration. If duration is 0, it shall cause transmission of zero-valued bits for at
least 0.25 seconds, and not more than 0.5 seconds. If duration is not 0, it shall send zero-valued bits for an
implementation-defined period of time.
The fildes argument is an open file descriptor associated with a terminal.
If the terminal is not using asynchronous serial data transmission, it is implementation-defined whether tcsendbreak()
sends data to generate a break condition or returns without taking any action.
Attempts to use tcsendbreak() from a process which is a member of a background process group on a fildes
associated with its controlling terminal shall cause the process group to be sent a SIGTTOU signal. If the calling thread is
blocking SIGTTOU signals or the process is ignoring SIGTTOU signals, the process shall be allowed to perform the operation, and no
signal is sent.
RETURN VALUE
Upon successful completion, 0 shall be returned. Otherwise, -1 shall be returned and errno set to indicate the error.
ERRORS
The tcsendbreak() function shall fail if:
[EBADF]
The fildes argument is not a valid file descriptor.
[EIO]
The process group of the writing process is orphaned, the calling thread is not blocking SIGTTOU, and the process is not
ignoring SIGTTOU.
[ENOTTY]
The file associated with fildes is not a terminal.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD 11. General Terminal Interface,
CHANGE HISTORY
First released in Issue 3. Included for alignment with the POSIX.1-1988 standard.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the DESCRIPTION, text previously conditional on _POSIX_JOB_CONTROL is now mandated. This is a FIPS requirement.
The [EIO] error is added.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0649 [79], XSH/TC1-2008/0650 [79], and XSH/TC1-2008/0651 [79] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/be64toh.html =====
be16toh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
be16toh, be32toh, be64toh, htobe16, htobe32, htobe64, htole16, htole32, htole64, le16toh, le32toh, le64toh — convert
values between host and specified byte order
SYNOPSIS
#include
uint16_t be16toh(uint16_t big_endian_16bits);
uint32_t be32toh(uint32_t big_endian_32bits);
uint64_t be64toh(uint64_t big_endian_64bits);
uint16_t htobe16(uint16_t host_16bits);
uint32_t htobe32(uint32_t host_32bits);
uint64_t htobe64(uint64_t host_64bits);
uint16_t htole16(uint16_t host_16bits);
uint32_t htole32(uint32_t host_32bits);
uint64_t htole64(uint64_t host_64bits);
uint16_t le16toh(uint16_t little_endian_16bits);
uint32_t le32toh(uint32_t little_endian_32bits);
uint64_t le64toh(uint64_t little_endian_64bits);
DESCRIPTION
These functions shall convert integer values of various sizes between host representations and representations in a specified
order.
On some implementations, these functions are defined as macros.
A little-endian representation of an integer has the least significant byte stored as the first byte, with the significance of
the bytes increasing as the byte address increases. A big-endian representation has the most significant byte as the first byte,
with the significance of the bytes reducing as the byte address increases.
Note:
Network byte order is big-endian.
For example, the uint32_t value 0x01020304 is represented as the four bytes 0x04, 0x03, 0x02, 0x01 on a little-endian
host, and as 0x01, 0x02, 0x03, 0x04 on a big-endian host.
For each of the sizes 16, 32 and 64, the htobeSIZE() function shall convert from whatever order the host uses to
big-endian representation, htoleSIZE() shall convert to little-endian representation, beSIZEtoh() shall convert from
big-endian to host order, and leSIZEtoh() shall convert from little-endian to host order.
RETURN VALUE
These functions shall return an unsigned integer of the appropriate size and representation.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
#include
#include
#include
int main(int argc, char *argv[])
{
uint32_t val;
if (argc > 1) {
val = (uint32_t)strtoul(argv[1], NULL, 0);
printf("Value: %08x\n", val);
printf("As bytes:\n");
union {
uint32_t asint;
unsigned char asbytes[sizeof(uint32_t)];
} u;
printf("Little endian: ");
u.asint = htole32(val);
for (int i = 0; i  is included:
htobe32
htonl
htobe16
htons
be32toh
ntohl
be16toh
ntohs
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
htonl()
XBD ,
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/isprint.html =====
isprint
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
isprint, isprint_l — test for a printable character
SYNOPSIS
#include
int isprint(int c);
[CX]  int isprint_l(int c, locale_t locale);
DESCRIPTION
For isprint(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The isprint() [CX]   and isprint_l()
functions shall test whether c is a character of class print in the current locale, [CX]   or in the
locale represented by locale,  respectively; see XBD 7. Locale.
The c argument is an int, the value of which the application shall ensure is a character representable as an
unsigned char or equal to the value of the macro EOF. If the argument has any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to isprint_l() is the special locale object LC_GLOBAL_LOCALE or is not a
valid locale object handle.
RETURN VALUE
The isprint() [CX]   and isprint_l()
functions shall return non-zero if c is a printable character; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
isalnum(), isalpha(), isblank(), iscntrl(), isdigit(), isgraph(), islower(), ispunct(), isspace(), isupper(), isxdigit(), setlocale(), uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The isprint_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0297 [302], XSH/TC1-2008/0298 [283], and XSH/TC1-2008/0299 [283] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/times.html =====
times
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
times — get process and waited-for child process times
SYNOPSIS
#include
clock_t times(struct tms *buffer);
DESCRIPTION
The times() function shall fill the tms structure pointed to by buffer with time-accounting information.
The tms structure is defined in .
All times are measured in terms of the number of clock ticks used.
The times of a terminated child process shall be included in the tms_cutime and tms_cstime elements of the parent
when wait(), waitid(), or waitpid() returns the process ID of this terminated child. If a child process has not waited
for its children, their times shall not be included in its times.
The tms_utime structure member is the CPU time charged for the execution of user instructions of the calling process.
The tms_stime structure member is the CPU time charged for execution by the system on behalf of the calling process.
The tms_cutime structure member is the sum of the tms_utime and tms_cutime times of the child
processes.
The tms_cstime structure member is the sum of the tms_stime and tms_cstime times of the child
processes.
RETURN VALUE
Upon successful completion, times() shall return the elapsed real time, in clock ticks, since an arbitrary point in the
past (for example, system start-up time). This point does not change from one invocation of times() within the process to
another. The return value may overflow the possible range of type clock_t. If times() fails, (clock_t)-1 shall
be returned and errno set to indicate the error.
ERRORS
The times() function shall fail if:
[EOVERFLOW]
The return value would overflow the range of clock_t.
The following sections are informative.
EXAMPLES
Timing a Database Lookup
The following example defines two functions, start_clock() and end_clock(), that are used to time a lookup. It
also defines variables of type clock_t and tms to measure the duration of transactions. The start_clock()
function saves the beginning times given by the times() function. The end_clock() function gets the ending times and
prints the difference between the two times.
#include
#include
...
void start_clock(void);
void end_clock(char *msg);
...
static clock_t st_time;
static clock_t en_time;
static struct tms st_cpu;
static struct tms en_cpu;
...
void
start_clock()
{
st_time = times(&st_cpu);
}
/* This example assumes that the result of each subtraction
is within the range of values that can be represented in
an integer type. */
void
end_clock(char *msg)
{
en_time = times(&en_cpu);
fputs(msg,stdout);
printf("Real Time: %jd, User Time %jd, System Time %jd\n",
(intmax_t)(en_time - st_time),
(intmax_t)(en_cpu.tms_utime - st_cpu.tms_utime),
(intmax_t)(en_cpu.tms_stime - st_cpu.tms_stime));
}
APPLICATION USAGE
Applications should use sysconf(_SC_CLK_TCK) to determine the number of clock ticks per second as it may vary from system
to system.
RATIONALE
The accuracy of the times reported is intentionally left unspecified to allow implementations flexibility in design, from
uniprocessor to multi-processor networks.
The inclusion of times of child processes is recursive, so that a parent process may collect the total times of all of its
descendants. But the times of a child are only added to those of its parent when its parent successfully waits on the child. Thus,
it is not guaranteed that a parent process can always see the total times of all its descendants; see also the discussion of the
term "realtime" in alarm().
If the type clock_t is defined to be a signed 32-bit integer, it overflows in somewhat more than a year if there are 60
clock ticks per second, or less than a year if there are 100. There are individual systems that run continuously for longer than
that. This volume of POSIX.1-2024 permits an implementation to make the reference point for the returned value be the start-up time
of the process, rather than system start-up time.
The term "charge" in this context has nothing to do with billing for services. The operating system accounts for time used in
this way. That information must be correct, regardless of how that information is used.
FUTURE DIRECTIONS
None.
SEE ALSO
alarm(), exec, fork(), sysconf(), time(), wait(), waitid()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 7
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0371 [644] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/srand48.html =====
drand48
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
drand48, erand48, jrand48, lcong48, lrand48, mrand48, nrand48, seed48, srand48 — generate uniformly distributed
pseudo-random numbers
SYNOPSIS
[XSI]  #include
double drand48(void);
double erand48(unsigned short xsubi[3]);
long jrand48(unsigned short xsubi[3]);
void lcong48(unsigned short param[7]);
long lrand48(void);
long mrand48(void);
long nrand48(unsigned short xsubi[3]);
unsigned short *seed48(unsigned short seed16v[3]);
void srand48(long seedval);
DESCRIPTION
This family of functions shall generate pseudo-random numbers using a linear congruential algorithm and 48-bit integer
arithmetic.
The drand48() and erand48() functions shall return non-negative, double-precision, floating-point values,
uniformly distributed over the interval [0.0,1.0).
The lrand48() and nrand48() functions shall return non-negative, long integers, uniformly distributed over the
interval [0,231).
The mrand48() and jrand48() functions shall return signed long integers uniformly distributed over the interval
[-231,231).
The srand48(), seed48(), and lcong48() functions are initialization entry points, one of which should be
invoked before either drand48(), lrand48(), or mrand48() is called. (Although it is not recommended practice,
constant default initializer values shall be supplied automatically if drand48(), lrand48(), or mrand48() is
called without a prior call to an initialization entry point.) The erand48(), nrand48(), and jrand48()
functions do not require an initialization entry point to be called first.
All the routines work by generating a sequence of 48-bit integer values,
\(X_{i}\),
according to the linear congruential formula:
\(X_{n+1}=\left(a X_n+c\right)_{\bmod m} \quad n \geq 0\)
The parameter m=248; hence 48-bit integer arithmetic is performed. Unless lcong48() is invoked, the multiplier
value a and the addend value c are given by:
\(
\begin{aligned}
& a= \text { 5DEECE66D }_{16}=273673163155_8 \\
& c=\mathrm{B}_{16}=13_8
\end{aligned}
\)
The value returned by any of the drand48(), erand48(), jrand48(), lrand48(), mrand48(), or
nrand48() functions is computed by first generating the next 48-bit \(X_{i}\) in the sequence. \(X_{i}\) is then converted
to the return value as follows:
For drand48() and erand48() the value shall be 2-48 times \(X_{i}\).
For jrand48() and mrand48() the value shall be the largest integer not greater than 2-16 times \(X_{i}\).
For lrand48() and nrand48() the value shall be the largest integer not greater than 2-17 times \(X_{i}\).
The drand48(), lrand48(), and mrand48() functions store the last 48-bit \(X_{i}\) generated in an internal
buffer; that is why the application shall ensure that these are initialized prior to being invoked. The erand48(),
nrand48(), and jrand48() functions require the calling program to provide storage for the successive \(X_{i}\) values
in the array specified as an argument when the functions are invoked. That is why these routines do not have to be initialized; the
calling program merely has to place the desired initial value of \(X_{i}\) into the array and pass it as an argument. By using
different arguments, erand48(), nrand48(), and jrand48() allow separate modules of a large program to generate
several independent streams of pseudo-random numbers; that is, the sequence of numbers in each stream shall not
depend upon how many times the routines are called to generate numbers for the other streams.
The initializer function srand48() sets the high-order 32 bits of \(X_{i}\) to the low-order 32 bits contained in its
argument. The low-order 16 bits of \(X_{i}\) are set to the arbitrary value 330E16.
The initializer function seed48() sets the value of \(X_{i}\) to the 48-bit value specified in the argument array. The
low-order 16 bits of \(X_{i}\) are set to the low-order 16 bits of seed16v[0]. The mid-order 16 bits of \(X_{i}\) are
set to the low-order 16 bits of seed16v[1]. The high-order 16 bits of \(X_{i}\) are set to the low-order 16 bits of
seed16v[2]. In addition, the previous value of \(X_{i}\) is copied into a 48-bit internal buffer, used only by
seed48(), and a pointer to this buffer is the value returned by seed48(). This returned pointer, which can just be
ignored if not needed, is useful if a program is to be restarted from a given point at some future time—use the pointer to get at
and store the last \(X_{i}\) value, and then use this value to reinitialize via seed48() when the program is restarted.
The initializer function lcong48() allows the user to specify the initial \(X_{i}\), the multiplier value a, and the
addend value c. Argument array elements param[0-2] specify \(X_{i}\), param[3-5] specify the
multiplier a, and param[6] specifies the 16-bit addend c. After lcong48() is called, a subsequent call to
either srand48() or seed48() shall restore the standard multiplier and addend values, a and c,
specified above.
The drand48(), lrand48(), and mrand48() functions need not be thread-safe.
RETURN VALUE
As described in the DESCRIPTION above.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
The following program tests that the required pseudo-random number generator is used by these functions.
#include
#include
int main() {
{
unsigned short xsubi[3] = {37174, 64810, 11603};
double d = erand48(xsubi);
assert(d >= 0.896);
assert(d = 0.337);
assert(d = 0.647);
assert(d = 0.500);
assert(d = 0.506);
assert(d
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
A note indicating that the drand48(), lrand48(), and mrand48() functions need not be reentrant is added to
the DESCRIPTION.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0083 [743] is applied.
Issue 8
Austin Group Defect 1107 is applied, clarifying how the return value is calculated from  \(X_{i}\) for each function.
Austin Group Defect 1134 is applied, adding getentropy().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sleep.html =====
sleep
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sleep — suspend execution for an interval of time
SYNOPSIS
#include
unsigned sleep(unsigned seconds);
DESCRIPTION
The sleep() function shall cause the calling thread to be suspended from execution until either the number of realtime
seconds specified by the argument seconds has elapsed or a signal is delivered to the calling thread and its action is to
invoke a signal-catching function or to terminate the process. The suspension time may be longer than requested due to the
scheduling of other activity by the system.
In single-threaded programs, sleep() may make use of SIGALRM. In multi-threaded programs, sleep() shall not make
use of SIGALRM and the remainder of this DESCRIPTION does not apply.
If a SIGALRM signal is generated for the calling process during execution of sleep() and if the SIGALRM signal is being
ignored or blocked from delivery, it is unspecified whether sleep() returns when the SIGALRM signal is scheduled. If the
signal is being blocked, it is also unspecified whether it remains pending after sleep() returns or it is discarded.
If a SIGALRM signal is generated for the calling process during execution of sleep(), except as a result of a prior call
to alarm(), and if the SIGALRM signal is not being ignored or blocked from delivery,
it is unspecified whether that signal has any effect other than causing sleep() to return.
If a signal-catching function interrupts sleep() and examines or changes either the time a SIGALRM is scheduled to be
generated, the action associated with the SIGALRM signal, or whether the SIGALRM signal is blocked from delivery, the results are
unspecified.
If a signal-catching function interrupts sleep() and calls siglongjmp()
or longjmp() to restore an environment saved prior to the sleep() call, the
action associated with the SIGALRM signal and the time at which a SIGALRM signal is scheduled to be generated are unspecified. It
is also unspecified whether the SIGALRM signal is blocked, unless the signal mask of the process is restored as part of the
environment.
RETURN VALUE
If sleep() returns because the requested time has elapsed, the value returned shall be 0. If sleep() returns due
to delivery of a signal, the return value shall be the "unslept" amount (the requested time minus the time actually slept) in
seconds.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
There are two general approaches to the implementation of the sleep() function. One is to use the alarm() function to schedule a SIGALRM signal and then suspend the calling thread waiting for
that signal. The other is to implement an independent facility. This volume of POSIX.1-2024 permits either approach in
single-threaded programs, but the simple alarm/suspend implementation is not appropriate for multi-threaded programs.
In order to comply with the requirement that no primitive shall change a process attribute unless explicitly described by this
volume of POSIX.1-2024, an implementation using SIGALRM must carefully take into account any SIGALRM signal scheduled by previous
alarm() calls, the action previously established for SIGALRM, and whether SIGALRM was
blocked. If a SIGALRM has been scheduled before the sleep() would ordinarily complete, the sleep() must be shortened
to that time and a SIGALRM generated (possibly simulated by direct invocation of the signal-catching function) before
sleep() returns. If a SIGALRM has been scheduled after the sleep() would ordinarily complete, it must be rescheduled
for the same time before sleep() returns. The action and blocking for SIGALRM must be saved and restored.
Historical implementations often implement the SIGALRM-based version using alarm()
and pause(). One such implementation is prone to infinite hangups, as described in
pause(). Another such implementation uses the C-language setjmp() and longjmp() functions to avoid that
window. That implementation introduces a different problem: when the SIGALRM signal interrupts a signal-catching function installed
by the user to catch a different signal, the longjmp() aborts that signal-catching
function. An implementation based on sigprocmask(), alarm(), and sigsuspend() can avoid these
problems.
Despite all reasonable care, there are several very subtle, but detectable and unavoidable, differences between the two types of
implementations. These are the cases mentioned in this volume of POSIX.1-2024 where some other activity relating to SIGALRM takes
place, and the results are stated to be unspecified. All of these cases are sufficiently unusual as not to be of concern to most
applications.
See also the discussion of the term realtime in alarm().
Since sleep() can be implemented using alarm(), the discussion about alarms
occurring early under alarm() applies to sleep() as well.
Application developers should note that the type of the argument seconds and the return value of sleep() is
unsigned. That means that a Strictly Conforming POSIX System Interfaces Application cannot pass a value greater than the
minimum guaranteed value for {UINT_MAX}, which the ISO C standard sets as 65535, and any application passing a larger value is
restricting its portability. A different type was considered, but historical implementations, including those with a 16-bit
int type, consistently use either unsigned or int.
Scheduling delays may cause the process to return from the sleep() function significantly after the requested time. In
such cases, the return value should be set to zero, since the formula (requested time minus the time actually spent) yields a
negative number and sleep() returns an unsigned.
FUTURE DIRECTIONS
A future version of this standard may require that sleep() does not make use of SIGALRM in all programs, not just
multi-threaded programs.
SEE ALSO
alarm(), nanosleep(), pause(), sigaction(), sigsetjmp(), timer_create()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Threads Extension.
Issue 6
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/132 is applied, making a correction in the RATIONALE
section.
Issue 7
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0334 [625] is applied.
Issue 8
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/tanf.html =====
tan
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
tan, tanf, tanl — tangent function
SYNOPSIS
#include
double tan(double x);
float tanf(float x);
long double tanl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the tangent of their argument x, measured in radians.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the tangent of x.
If the correct value would cause underflow, [MXX]   and is not representable,   a range error may occur, and tan(), tanf(), and tanl() shall return
[MXX]
0.0, or   (if IEC 60559 Floating-Point is not supported)
an implementation-defined value no greater in magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, x shall be returned.
If x is ±Inf, a domain error shall occur, and either a NaN (if supported), or an implementation-defined value shall be
returned.
[MXX]
If x is subnormal, x should be returned.
[MX]  If x is subnormal, a range error may occur and, if x is
not returned, tan(), tanf(), and tanl() shall return an implementation-defined value no greater in magnitude
than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
[MXX]
If the correct value would cause underflow, and is representable, a range error may occur and the correct value shall be returned.
[XSI]
If the correct value would cause overflow, a range error shall occur and tan(), tanf(), and tanl() shall
return ±HUGE_VAL, ±HUGE_VALF, and ±HUGE_VALL, respectively, with the same sign as the correct value of the function.
ERRORS
These functions shall fail if:
Domain Error
[MX]
The value of x is ±Inf.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
Range Error
[XSI]
The result overflows
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
These functions may fail if:
Range Error
The result underflows, [MX]   or the value of x is subnormal.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
Taking the Tangent of a 45-Degree Angle
#include
...
double radians = 45.0 * M_PI / 180;
double result;
...
result = tan (radians);
APPLICATION USAGE
There are no known floating-point representations such that for a normal argument, tan(x) is either overflow or
underflow.
These functions may lose accuracy when their argument is near a multiple of ℼ/2 or is far from 0.0.
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
atan(), feclearexcept(),
fetestexcept(), isnan()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The last two paragraphs of the DESCRIPTION were included as APPLICATION USAGE notes in previous issues.
Issue 6
The tanf() and tanl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/64 is applied, correcting the last paragraph in the RETURN VALUE
section.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0635 [68], XSH/TC1-2008/0636 [68], and XSH/TC1-2008/0637 [68] are
applied.
Issue 8
Austin Group Defect 1382 is applied, rearranging the text describing the behavior when x is subnormal to avoid the need
for two shading changes.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getgrgid_r.html =====
getgrgid
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getgrgid, getgrgid_r — get group database entry for a group ID
SYNOPSIS
#include
struct group *getgrgid(gid_t gid);
int getgrgid_r(gid_t gid, struct group *grp, char *buffer,
size_t bufsize, struct group **result);
DESCRIPTION
The getgrgid() function shall search the group database for an entry with a matching gid.
The getgrgid() function need not be thread-safe.
Applications wishing to check for error situations should set errno to 0 before calling getgrgid(). If
getgrgid() returns a null pointer and errno is set to non-zero, an error occurred.
The getgrgid_r() function shall update the group structure pointed to by grp and store a pointer to that
structure at the location pointed to by result. The structure shall contain an entry from the group database with a matching
gid. Storage referenced by the group structure is allocated from the memory provided with the buffer parameter, which
is bufsize bytes in size. A call to sysconf(_SC_GETGR_R_SIZE_MAX) returns either -1 without changing errno or
an initial value suggested for the size of this buffer. A null pointer shall be returned at the location pointed to by
result on error or if the requested entry is not found.
RETURN VALUE
Upon successful completion, getgrgid() shall return a pointer to a struct group with the structure defined in
with a matching entry if one is found. The getgrgid() function
shall return a null pointer if either the requested entry was not found, or an error occurred. If the requested entry was not
found, errno shall not be changed. On error, errno shall be set to indicate the error.
The application shall not modify the structure to which the return value points, nor any storage areas pointed to by pointers
within the structure. The returned pointer, and pointers within the structure, might be invalidated or the structure or the storage
areas might be overwritten by a subsequent call to getgrent(), getgrgid(),
or getgrnam(). The returned pointer, and pointers within the structure, might also
be invalidated if the calling thread is terminated.
If successful, the getgrgid_r() function shall return zero; otherwise, an error number shall be returned to indicate the
error.
ERRORS
The getgrgid() and getgrgid_r() functions may fail if:
[EIO]
An I/O error has occurred.
[EINTR]
A signal was caught during getgrgid().
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum allowable number of files is currently open in the system.
The getgrgid_r() function shall fail if:
[ERANGE]
Insufficient storage was supplied via buffer and bufsize to contain the data to be referenced by the resulting
group structure.
The following sections are informative.
EXAMPLES
Note that sysconf(_SC_GETGR_R_SIZE_MAX) may return -1 if there is no hard limit on the size of the buffer needed to store
all the groups returned. This example shows how an application can allocate a buffer of sufficient size to work with
getgrgid_r().
long int initlen = sysconf(_SC_GETGR_R_SIZE_MAX);
size_t len;
if (initlen == -1)
/* Default initial length. */
len = 1024;
else
len = (size_t) initlen;
struct group result;
struct group *resultp;
char *buffer = malloc(len);
if (buffer == NULL)
...handle error...
int e;
while ((e = getgrgid_r(42, &result, buffer, len, &resultp)) == ERANGE)
{
size_t newlen = 2 * len;
if (newlen
#include
#include
...
struct stat statbuf;
struct group *grp;
...
if ((grp = getgrgid(statbuf.st_gid)) != NULL)
printf(" %-8.8s", grp->gr_name);
else
printf(" %-8d", statbuf.st_gid);
...
APPLICATION USAGE
The getgrgid_r() function is thread-safe and shall return values in a user-supplied buffer instead of possibly using a
static data area that may be overwritten by each call.
Portable applications should take into account that it is usual for an implementation to return -1 from sysconf() indicating that there is no maximum for _SC_GETGR_R_SIZE_MAX.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
endgrent(), getgrnam(),
sysconf()
XBD ,
CHANGE HISTORY
First released in Issue 1. Derived from System V Release 2.0.
Issue 5
Normative text previously in the APPLICATION USAGE section is moved to the RETURN VALUE section.
The getgrgid_r() function is included for alignment with the POSIX Threads Extension.
A note indicating that the getgrgid() function need not be reentrant is added to the DESCRIPTION.
Issue 6
The getgrgid_r() function is marked as part of the Thread-Safe Functions option.
The Open Group Corrigendum U028/3 is applied, correcting text in the DESCRIPTION describing matching the gid.
In the DESCRIPTION, the note about reentrancy is expanded to cover thread-safety.
In the SYNOPSIS, the optional include of the  header is
removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
In the RETURN VALUE section, the requirement to set errno on error is added.
The [EIO], [EINTR], [EMFILE], and [ENFILE] optional error conditions are added.
The APPLICATION USAGE section is updated to include a note on the thread-safe function and its avoidance of possibly using a
static data area.
IEEE PASC Interpretation 1003.1 #116 is applied, changing the description of the size of the buffer from bufsize
characters to bytes.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
SD5-XBD-ERN-4 is applied, changing the definition of the [EMFILE] error.
SD5-XSH-ERN-166 is applied.
The getgrgid_r() function is moved from the Thread-Safe Functions option to the Base.
A minor addition is made to the EXAMPLES section, reminding the application developer to free memory allocated as if by malloc().
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0241 [75] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0160 [808], XSH/TC2-2008/0161 [808], XSH/TC2-2008/0162 [656], and
XSH/TC2-2008/0163 [808] are applied.
Issue 8
Austin Group Defect 398 is applied, changing the [ERANGE] error from "may fail" to "shall fail".
Austin Group Defect 1570 is applied, removing extra spacing in "==".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/clogl.html =====
clog
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
clog, clogf, clogl — complex natural logarithm functions
SYNOPSIS
#include
double complex clog(double complex z);
float complex clogf(float complex z);
long double complex clogl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex natural (base e) logarithm of z, with a branch cut along the negative
real axis.
RETURN VALUE
These functions shall return the complex natural logarithm value, in the range of a strip mathematically unbounded along the
real axis and in the interval [-iℼ, +iℼ] along the imaginary axis.
[MXC]
clog(conj(z)), clogf(conjf(z)), and clogl(conjl(z)) shall return
exactly the same value as conj(clog(z)), conjf(clogf(z)), and
conjl(clogl(z)), respectively, including for the special values of z below.
If z is -0 + i0, -Inf + iℼ shall be returned and the divide-by-zero floating-point exception shall be
raised.
If z is +0 + i0, -Inf + i0 shall be returned and the divide-by-zero floating-point exception shall be
raised.
If z is x + iInf where x is finite, +Inf + iℼ/2 shall be returned.
If z is x + iNaN where x is finite, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is -Inf + iy where y is positive-signed and finite, +Inf + iℼ shall be returned.
If z is +Inf + iy where y is positive-signed and finite, +Inf + i0 shall be returned.
If z is -Inf + iInf, +Inf + i3ℼ/4 shall be returned.
If z is +Inf + iInf, +Inf + iℼ/4 shall be returned.
If z is ±Inf + iNaN, +Inf + iNaN shall be returned.
If z is NaN + iy where y is finite, NaN + iNaN shall be returned and the invalid floating-point
exception may be raised.
If z is NaN + iInf, +Inf + iNaN shall be returned.
If z is NaN + iNaN, NaN + iNaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
cexp()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/frexp.html =====
frexp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
frexp, frexpf, frexpl — extract significand and exponent from a double precision number
SYNOPSIS
#include
double frexp(double num, int *exp);
float frexpf(float num, int *exp);
long double frexpl(long double num, int *exp);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall break a floating-point number num into a normalized fraction and an integral power of 2. The
integer exponent shall be stored in the int object pointed to by exp; if the integer exponent is outside the range of
int, the results are unspecified.
RETURN VALUE
For finite arguments, these functions shall return the value x, such that x has a magnitude in the interval [½,1)
or 0, and num equals x times 2 raised to the power *exp.
[MX]
When the radix of the argument is a power of 2, the returned value shall be exact and shall be independent of the current rounding
direction mode.
If num is NaN, a NaN shall be returned, and the value of *exp is unspecified.
If num is ±0, ±0 shall be returned, and the value of *exp shall be 0.
If num is ±Inf, num shall be returned, and the value of *exp is unspecified.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
isnan(), ldexp(), modf()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The frexpf() and frexpl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1753 is applied, changing the NAME section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/endhostent.html =====
endhostent
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
endhostent, gethostent, sethostent — network host database functions
SYNOPSIS
#include
void endhostent(void);
struct hostent *gethostent(void);
void sethostent(int stayopen);
DESCRIPTION
These functions shall retrieve information about hosts. This information is considered to be stored in a database that can be
accessed sequentially or randomly. The implementation of this database is unspecified.
Note:
In many cases this database is implemented by the Domain Name System, as documented in RFC 1034, RFC 1035, and
RFC 3596.
The sethostent() function shall open a connection to the database and set the next entry for retrieval to the first entry
in the database. If the stayopen argument is non-zero, the connection shall not be closed by a call to gethostent(),
and the implementation may maintain an open file descriptor. If a file descriptor is opened, the FD_CLOEXEC flag shall be set; see
.
The gethostent() function shall read the next entry in the database, opening and closing a connection to the database as
necessary.
Entries shall be returned in hostent structures.
The endhostent() function shall close the connection to the database, releasing any open file descriptor.
These functions need not be thread-safe.
RETURN VALUE
Upon successful completion, the gethostent() function shall return a pointer to a hostent structure if the
requested entry was found, and a null pointer if the end of the database was reached or the requested entry was not found.
The application shall not modify the structure to which the return value points, nor any storage areas pointed to by pointers
within the structure. The returned pointer, and pointers within the structure, might be invalidated or the structure or the storage
areas might be overwritten by a subsequent call to gethostent(). The returned pointer, and pointers within the structure,
might also be invalidated if the calling thread is terminated.
ERRORS
The gethostent() and sethostent() functions may fail if:
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum allowable number of files is currently open in the system.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
endservent()
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0081 [75,428] and XSH/TC1-2008/0082 [75] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0089 [656] is applied.
Issue 8
Austin Group Defect 368 is applied, adding a requirement for FD_CLOEXEC to be set if a file descriptor is opened, and adding the
[EMFILE] and [ENFILE] errors.
Austin Group Defect 1685 is applied, updating RFC references.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/readv.html =====
readv
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
readv — read a vector
SYNOPSIS
[XSI]  #include
ssize_t readv(int fildes, const struct iovec *iov, int iovcnt);
DESCRIPTION
The readv() function shall be equivalent to read(), except as described
below. The readv() function shall place the input data into the iovcnt buffers specified by the members of the
iov array: iov[0], iov[1], ..., iov[iovcnt-1]. The iovcnt argument is valid if greater
than 0 and less than or equal to {IOV_MAX}.
Each iovec entry specifies the base address and length of an area in memory where data should be placed. The
readv() function shall always fill an area completely before proceeding to the next.
Upon successful completion, readv() shall mark for update the last data access timestamp of the file.
RETURN VALUE
Refer to read().
ERRORS
Refer to read().
In addition, the readv() function shall fail if:
[EINVAL]
The sum of the iov_len values in the iov array overflowed an ssize_t.
The readv() function may fail if:
[EINVAL]
The iovcnt argument was less than or equal to 0, or greater than {IOV_MAX}.
The following sections are informative.
EXAMPLES
Reading Data into an Array
The following example reads data from the file associated with the file descriptor fd into the buffers specified by
members of the iov array.
#include
#include
#include
...
ssize_t bytes_read;
int fd;
char buf0[20];
char buf1[30];
char buf2[40];
int iovcnt;
struct iovec iov[3];
iov[0].iov_base = buf0;
iov[0].iov_len = sizeof(buf0);
iov[1].iov_base = buf1;
iov[1].iov_len = sizeof(buf1);
iov[2].iov_base = buf2;
iov[2].iov_len = sizeof(buf2);
...
iovcnt = sizeof(iov) / sizeof(struct iovec);
bytes_read = readv(fd, iov, iovcnt);
...
APPLICATION USAGE
None.
RATIONALE
Refer to read().
FUTURE DIRECTIONS
None.
SEE ALSO
read(), writev()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 6
Split out from the read() reference page.
Issue 7
Changes are made related to support for finegrained timestamps.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_condattr_init.html =====
pthread_condattr_destroy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_condattr_destroy, pthread_condattr_init — destroy and initialize the condition variable attributes
object
SYNOPSIS
#include
int pthread_condattr_destroy(pthread_condattr_t *attr);
int pthread_condattr_init(pthread_condattr_t *attr);
DESCRIPTION
The pthread_condattr_destroy() function shall destroy a condition variable attributes object; the object becomes, in
effect, uninitialized. An implementation may cause pthread_condattr_destroy() to set the object referenced by attr to
an invalid value. A destroyed attr attributes object can be reinitialized using pthread_condattr_init(); the results
of otherwise referencing the object after it has been destroyed are undefined.
The pthread_condattr_init() function shall initialize a condition variable attributes object attr with the default
value for all of the attributes defined by the implementation.
Results are undefined if pthread_condattr_init() is called specifying an already initialized attr attributes
object.
After a condition variable attributes object has been used to initialize one or more condition variables, any function affecting
the attributes object (including destruction) shall not affect any previously initialized condition variables.
This volume of POSIX.1-2024 requires two attributes, the clock attribute and the process-shared attribute.
Additional attributes, their default values, and the names of the associated functions to get and set those attribute values are
implementation-defined.
The behavior is undefined if the value specified by the attr argument to pthread_condattr_destroy() does not refer
to an initialized condition variable attributes object.
RETURN VALUE
If successful, the pthread_condattr_destroy() and pthread_condattr_init() functions shall return zero; otherwise,
an error number shall be returned to indicate the error.
ERRORS
The pthread_condattr_init() function shall fail if:
[ENOMEM]
Insufficient memory exists to initialize the condition variable attributes object.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
A process-shared attribute has been defined for condition variables for the same reason it has been defined for
mutexes.
If an implementation detects that the value specified by the attr argument to pthread_condattr_destroy() does not
refer to an initialized condition variable attributes object, it is recommended that the function should fail and report an
[EINVAL] error.
See also pthread_attr_destroy() and pthread_mutex_destroy().
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_attr_destroy(), pthread_cond_destroy(), pthread_condattr_getpshared(), pthread_create(), pthread_mutex_destroy()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_condattr_destroy() and pthread_condattr_init() functions are marked as part of the Threads option.
Issue 7
The pthread_condattr_destroy() and pthread_condattr_init() functions are moved from the Threads option to the
Base.
The [EINVAL] error for an uninitialized condition variable attributes object is removed; this condition results in undefined
behavior.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/nextafter.html =====
nextafter
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
nextafter, nextafterf, nextafterl, nexttoward, nexttowardf, nexttowardl — next representable floating-point
number
SYNOPSIS
#include
double nextafter(double x, double y);
float nextafterf(float x, float y);
long double nextafterl(long double x, long double y);
double nexttoward(double x, long double y);
float nexttowardf(float x, long double y);
long double nexttowardl(long double x, long double y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The nextafter(), nextafterf(), and nextafterl() functions shall compute the next representable
floating-point value following x in the direction of y. Thus, if y is less than x, nextafter()
shall return the largest representable floating-point number less than x. The nextafter(), nextafterf(), and
nextafterl() functions shall return y if x equals y.
The nexttoward(), nexttowardf(), and nexttowardl() functions shall be equivalent to the corresponding
nextafter() functions, except that the second parameter shall have type long double and the functions shall return
y converted to the type of the function if x equals y.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the next representable floating-point value following x in the
direction of y.
If x==y, y (of the type x) shall be returned.
[MX]
Even though underflow or overflow can occur, the returned value shall be independent of the current rounding direction mode.
If x is finite and the correct function value would overflow, a range error shall occur and ±HUGE_VAL, ±HUGE_VALF, and
±HUGE_VALL (with the same sign as x) shall be returned as appropriate for the return type of the function.
[MX]  If
x or y is NaN, a NaN shall be returned.
[MX]  If
x!=y and the correct function value is subnormal, zero, or underflows, a range error shall occur, and
[MXX]
the correct function value (if representable) or
[MX]  0.0 shall be returned.
ERRORS
These functions shall fail if:
Range Error
The correct value overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
Range Error
[MX]
The correct value is subnormal or underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
When  is included, note that the return type of
nextafter() depends on the generic typing deduced from both arguments, while the return type of nexttoward() depends
only on the generic typing of the first argument.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The nextafter() function is no longer marked as an extension.
The nextafterf(), nextafterl(), nexttoward(), nexttowardf(), and nexttowardl() functions are
added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0407 [68] and XSH/TC1-2008/0408 [357] are applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wmemchr.html =====
wmemchr
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wmemchr — find a wide character in memory
SYNOPSIS
#include
wchar_t *wmemchr(const wchar_t *ws, wchar_t wc, size_t n);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The wmemchr() function shall locate the first occurrence of wc in the initial n wide characters of the
object pointed to by ws. This function shall not be affected by locale and all wchar_t values shall be treated
identically. The null wide character and wchar_t values not corresponding to valid characters shall not be treated
specially.
If n is zero, the application shall ensure that ws is a valid pointer and the function behaves as if no valid
occurrence of wc is found.
[CX]  The
wmemchr() function shall not change the setting of errno on valid input.
RETURN VALUE
The wmemchr() function shall return a pointer to the located wide character, or a null pointer if the wide character does
not occur in the object.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
wmemcmp(), wmemcpy(), wmemmove(), wmemset()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E).
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that wmemchr() does not change the setting of errno on
valid input.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wctype_l.html =====
wctype
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wctype, wctype_l — define character class
SYNOPSIS
#include
wctype_t wctype(const char *property);
[CX]  wctype_t wctype_l(const char *property, locale_t locale);
DESCRIPTION
For wctype(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The wctype() [CX]   and wctype_l()
functions are defined for valid character class names as defined in the current locale [CX]   or in the
locale represented by locale,   respectively.
The property argument is a string identifying a generic character class for which codeset-specific type information is
required. The following character class names shall be defined in all locales:
alnum
alpha
blank
cntrl
digit
graph
lower
print
punct
space
upper
xdigit
Additional character class names defined in the locale definition file (category LC_CTYPE ) can also be
specified.
These functions shall return a value of type wctype_t, which can be used as the second argument to
subsequent calls of iswctype() [CX]   and iswctype_l().
The wctype() [CX]   and wctype_l()
functions shall determine values of wctype_t according to the rules of the coded character set defined by character
type information in the current locale [CX]   or in the locale represented by locale,   respectively (category LC_CTYPE ).
The values returned by wctype() shall be valid until a call to setlocale() that modifies the category LC_CTYPE .
[CX]  The values returned by wctype_l() shall be valid only in calls to iswctype_l() with a locale represented by locale with the same LC_CTYPE
category value.
The behavior is undefined if the locale argument to wctype_l() is the special locale object
LC_GLOBAL_LOCALE or is not a valid locale object handle.
RETURN VALUE
The wctype() [CX]   and wctype_l()
functions shall return 0 if the given character class name is not valid for the current locale (category LC_CTYPE );
otherwise, they shall return an object of type wctype_t that can be used in calls to iswctype() [CX]   and iswctype_l().
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
iswctype()
XBD
CHANGE HISTORY
First released in Issue 4.
Issue 5
The following change has been made in this version for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E):
The SYNOPSIS has been changed to indicate that this function and associated data types are now made visible by
inclusion of the  header rather than .
Issue 7
The wctype_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0736 [302], XSH/TC1-2008/0737 [283], and XSH/TC1-2008/0738
[283] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_barrier_wait.html =====
pthread_barrier_wait
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_barrier_wait — synchronize at a barrier
SYNOPSIS
#include
int pthread_barrier_wait(pthread_barrier_t *barrier);
DESCRIPTION
The pthread_barrier_wait() function shall synchronize participating threads at the barrier referenced by barrier.
The calling thread shall block until the required number of threads have called pthread_barrier_wait() specifying the
barrier.
When the required number of threads have called pthread_barrier_wait() specifying the barrier, the constant
PTHREAD_BARRIER_SERIAL_THREAD shall be returned to one unspecified thread and zero shall be returned to each of the remaining
threads. At this point, the barrier shall be reset to the state it had as a result of the most recent pthread_barrier_init() function that referenced it.
The constant PTHREAD_BARRIER_SERIAL_THREAD is defined in  and
its value shall be distinct from any other value returned by pthread_barrier_wait().
The results are undefined if this function is called with an uninitialized barrier.
If a signal is delivered to a thread blocked on a barrier, upon return from the signal handler the thread shall resume waiting
at the barrier if the barrier wait has not completed (that is, if the required number of threads have not arrived at the barrier
during the execution of the signal handler); otherwise, the thread shall continue as normal from the completed barrier wait. Until
the thread in the signal handler returns from it, it is unspecified whether other threads may proceed past the barrier once they
have all reached it.
A thread that has blocked on a barrier shall not prevent any unblocked thread that is eligible to use the same processing
resources from eventually making forward progress in its execution. Eligibility for processing resources shall be determined by the
scheduling policy.
RETURN VALUE
Upon successful completion, the pthread_barrier_wait() function shall return PTHREAD_BARRIER_SERIAL_THREAD for a single
(arbitrary) thread synchronized at the barrier and zero for each of the other threads. Otherwise, an error number shall be returned
to indicate the error.
ERRORS
This function shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications using this function may be subject to priority inversion, as discussed in XBD 3.275 Priority Inversion.
RATIONALE
If an implementation detects that the value specified by the barrier argument to pthread_barrier_wait() does not
refer to an initialized barrier object, it is recommended that the function should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_barrier_destroy()
XBD 3.275 Priority Inversion, 4.15.2 Memory Synchronization,
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1j-2000.
In the SYNOPSIS, the inclusion of  is no longer
required.
Issue 7
The pthread_barrier_wait() function is moved from the Barriers option to the Base.
The [EINVAL] error for an uninitialized barrier object is removed; this condition results in undefined behavior.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/cproj.html =====
cproj
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cproj, cprojf, cprojl — complex projection functions
SYNOPSIS
#include
double complex cproj(double complex z);
float complex cprojf(float complex z);
long double complex cprojl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute a projection of z onto the Riemann sphere: z projects to z, except that all
complex infinities (even those with one infinite part and one NaN part) project to positive infinity on the real axis. If z
has an infinite part, then cproj(z) shall be equivalent to:
INFINITY + I * copysign(0.0, cimag(z))
RETURN VALUE
These functions shall return the value of the projection onto the Riemann sphere.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
Two topologies are commonly used in complex mathematics: the complex plane with its continuum of infinities, and the Riemann
sphere with its single infinity. The complex plane is better suited for transcendental functions, the Riemann sphere for algebraic
functions. The complex types with their multiplicity of infinities provide a useful (though imperfect) model for the complex plane.
The cproj() function helps model the Riemann sphere by mapping all infinities to one, and should be used just before any
operation, especially comparisons, that might give spurious results for any of the other infinities. Note that a complex value with
one infinite part and one NaN part is regarded as an infinity, not a NaN, because if one part is infinite, the complex value is
infinite independent of the value of the other part. For the same reason, cabs()
returns an infinity if its argument has an infinite part and a NaN part.
FUTURE DIRECTIONS
None.
SEE ALSO
carg(), cimag(), conj(), creal()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/vwscanf.html =====
vfwscanf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
vfwscanf, vswscanf, vwscanf — wide-character formatted input of a stdarg argument list
SYNOPSIS
#include
#include
#include
int vfwscanf(FILE *restrict stream, const wchar_t *restrict format,
va_list arg);
int vswscanf(const wchar_t *restrict ws, const wchar_t *restrict format,
va_list arg);
int vwscanf(const wchar_t *restrict format, va_list arg);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The vfwscanf(), vswscanf(), and vwscanf() functions shall be equivalent to the fwscanf(), swscanf(), and wscanf() functions, respectively, except that instead of being called with a variable number
of arguments, they are called with an argument list as defined in the  header. These functions shall not invoke the va_end macro. As these
functions invoke the va_arg macro, the value of ap after the return is unspecified.
RETURN VALUE
Refer to fwscanf().
ERRORS
Refer to fwscanf().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications using these functions should call va_end(ap) afterwards to clean up.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fwscanf()
XBD , ,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0706 [14] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/islower_l.html =====
islower
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
islower, islower_l — test for a lowercase letter
SYNOPSIS
#include
int islower(int c);
[CX]  int islower_l(int c, locale_t locale);
DESCRIPTION
For islower(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The islower() [CX]   and islower_l()
functions shall test whether c is a character of class lower in the current locale, [CX]   or in the
locale represented by locale,  respectively; see XBD 7. Locale.
The c argument is an int, the value of which the application shall ensure is a character representable as an
unsigned char or equal to the value of the macro EOF. If the argument has any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to islower_l() is the special locale object LC_GLOBAL_LOCALE or is not a
valid locale object handle.
RETURN VALUE
The islower() [CX]   and islower_l()
functions shall return non-zero if c is a lowercase letter; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
Testing for a Lowercase Letter
Two examples follow, the first using islower(), the second using multiple concurrent locales and islower_l().
The examples test whether the value is a lowercase letter, based on the current locale, then use it as part of a key value.
/* Example 1 -- using islower() */
#include
#include
#include
...
char *keystr;
int elementlen, len;
unsigned char c;
...
setlocale(LC_ALL, "");
...
len = 0;
while (len
#include
#include
...
char *keystr;
int elementlen, len;
unsigned char c;
...
locale_t loc = newlocale (LC_ALL_MASK, "", (locale_t) 0);
...
len = 0;
while (len ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements and an example is added.
Issue 7
The islower_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0292 [302], XSH/TC1-2008/0293 [283], XSH/TC1-2008/0294 [283],
XSH/TC1-2008/0295 [302], and XSH/TC1-2008/0296 [304] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/opterr.html =====
getopt
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getopt, optarg, opterr, optind, optopt — command option parsing
SYNOPSIS
#include
int getopt(int argc, char * const argv[], const char *optstring);
extern char *optarg;
extern int opterr, optind, optopt;
DESCRIPTION
The getopt() function is a command-line parser that shall follow Utility Syntax Guidelines 3, 4, 5, 6, 7, 9, and 10 in
XBD 12.2 Utility Syntax Guidelines.
The parameters argc and argv are the argument count and argument array as passed to main() (see exec()). The argument optstring is a string of recognized option characters; if a
character is followed by a , the option takes an argument. All option characters allowed by Utility Syntax Guideline 3
are allowed in optstring. The optstring argument can optionally start with a  ('+'), which
shall have no effect on behavior in a conforming environment. If a  occurs anywhere besides the first character of
optstring, the behavior is unspecified. The implementation may accept other characters as an extension.
The variable optind is the index of the next element of the argv[] vector to be processed. It shall be initialized
to 1 by the system, and getopt() shall update it when it finishes with each element of argv[]. If the application
sets optind to zero before calling getopt(), the behavior is unspecified. When an element of argv[] contains
multiple option characters, it is unspecified how getopt() determines which options have already been processed.
The getopt() function shall return the next option character (if one is found) from argv that matches a character
in optstring (excluding an optional leading ), if there is one that matches. If the option takes an
argument, getopt() shall set the variable optarg to point to the option-argument as follows:
If the option was the last character in the string pointed to by an element of argv, then optarg shall contain the
next element of argv, and optind shall be incremented by 2. If the resulting value of optind is greater than
argc, this indicates a missing option-argument, and getopt() shall return an error indication.
Otherwise, optarg shall point to the string following the option character in that element of argv, and
optind shall be incremented by 1.
If, when getopt() is called, any of the following is true:
argv[optind]  is a null pointer
*argv[optind]  is not the character '-'
argv[optind]  points to the string "-"
getopt() shall return -1 without changing optind. If:
argv[optind]   points to the string "--"
getopt() shall return -1 after incrementing optind.
If getopt() encounters a  as an option character, or an option character that is not contained in
optstring after an optional leading , it shall return the  ('?') character.
If it detects a missing option-argument, it shall return the  character (':') if the first character of
optstring after an optional  was a , or a  character ('?')
otherwise. In either case, getopt() shall set the variable optopt to the option character that caused the error. If
the application has not set the variable opterr to 0, and the first character of optstring after an optional
is not a , getopt() shall also print a diagnostic message to stderr in the format
specified for the getopts utility, unless the stderr stream has wide
orientation, in which case the behavior is undefined.
The getopt() function need not be thread-safe.
RETURN VALUE
The getopt() function shall return the next option character specified on the command line.
A  (':') shall be returned if getopt() detects a missing argument and the first character of
optstring after an optional  was a  (':').
A  ('?') shall be returned if getopt() encounters a  as an option character,
encounters an option character not in optstring, or detects a missing argument and the first character of optstring
after an optional  was not a  (':').
Otherwise, getopt() shall return -1 when all command line options are parsed.
ERRORS
If the application has not set the variable opterr to 0, the first character of optstring is not a ,
and a write error occurs while getopt() is printing a diagnostic message to stderr, then the error indicator for
stderr shall be set; but getopt() shall still succeed and the value of errno after getopt() is
unspecified.
The following sections are informative.
EXAMPLES
Parsing Command Line Options
The following code fragment shows how you might process the arguments for a utility that can take the mutually-exclusive options
a and b and the options f and o, both of which require arguments:
#include
#include
#include
int
main(int argc, char *argv[ ])
{
int c;
int bflg = 0, aflg = 0, errflg = 0;
char *ifile;
char *ofile;
. . .
while ((c = getopt(argc, argv, ":abf:o:")) != -1) {
switch(c) {
case 'a':
if (bflg)
errflg++;
else
aflg++;
break;
case 'b':
if (aflg)
errflg++;
else
bflg++;
break;
case 'f':
ifile = optarg;
break;
case 'o':
ofile = optarg;
break;
case ':':       /* -f or -o without operand */
fprintf(stderr,
"Option -%c requires an operand\n", optopt);
errflg++;
break;
case '?':
fprintf(stderr,
"Unrecognized option: '-%c'\n", optopt);
errflg++;
}
}
if (errflg) {
fprintf(stderr, "usage: . . . ");
exit(2);
}
for ( ; optind
#include
...
const char *Options = "hdbtl";
...
int dbtype, c;
char *st;
...
dbtype = 0;
while ((c = getopt(argc, argv, Options)) != -1) {
if ((st = strchr(Options, c)) != NULL) {
dbtype = st - Options;
break;
}
}
APPLICATION USAGE
The getopt() function is only required to support option characters included in Utility Syntax Guideline 3. Many
historical implementations of getopt() support other characters as options. This is an allowed extension, but applications
that use extensions are not maximally portable. Note that support for multi-byte option characters is only possible when such
characters can be represented as type int.
Applications which use wide-character output functions with stderr should ensure that any calls to getopt() do not
write to stderr, either by setting opterr to 0 or by ensuring the first character of optstring is always a
.
While ferror(stderr) may be used to detect failures to write a diagnostic to stderr when getopt()
returns '?', the value of errno is unspecified in such a condition. Applications desiring more control over
handling write failures should set opterr to 0 and independently perform output to stderr, rather than relying on
getopt() to do the output.
RATIONALE
The optopt variable represents historical practice and allows the application to obtain the identity of the invalid
option.
The description has been written to make it clear that getopt(), like the getopts utility, deals with option-arguments whether separated from the option by
characters or not. Note that the requirements on getopt() and getopts are more stringent than the Utility Syntax Guidelines.
The getopt() function shall return -1, rather than EOF, so that  is not required.
The special significance of a  as the first character of optstring makes getopt() consistent with the
getopts utility. It allows an application to make a distinction between a missing
argument and an incorrect option letter without having to examine the option letter. It is true that a missing argument can only be
detected in one case, but that is a case that has to be considered.
In some non-conforming environments, the use of a leading  in optstring forces getopt() to behave
in a conforming way, when it would otherwise have non-conforming behavior. Its use has been standardized to allow applications to
be written that can guarantee behavior consistent with this specification even in an otherwise non-conforming environment. If both
and  are used at the beginning of optstring, the  must be first.
Note that the use of a leading  in optstring is only standardized for getopt(). Use of a
is intentionally left unspecified for the getopts utility, where
historical implementations did not require a leading  for conforming behavior, and because some historical
getopts implementations used a leading  for a different
extension.
FUTURE DIRECTIONS
None.
SEE ALSO
exec
XBD 12.2 Utility Syntax Guidelines,
XCU getopts
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
A note indicating that the getopt() function need not be reentrant is added to the DESCRIPTION.
Issue 6
IEEE PASC Interpretation 1003.2 #150 is applied.
Austin Group Interpretation 1003.1-2001 #156 is applied.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0248 [318], XSH/TC1-2008/0249 [460], XSH/TC1-2008/0250 [189],
XSH/TC1-2008/0251 [189], XSH/TC1-2008/0252 [189], and XSH/TC1-2008/0253 [460] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0169 [608] is applied.
Issue 8
Austin Group Defect 191 is applied, allowing a leading  in optstring.
Austin Group Defect 1179 is applied, adding some missing '}' characters at the end of the example code.
Austin Group Defect 1523 is applied, clarifying the conditions under which getopt() returns -1 without changing
optind.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_attr_getdetachstate.html =====
pthread_attr_getdetachstate
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_attr_getdetachstate, pthread_attr_setdetachstate — get and set the detachstate attribute
SYNOPSIS
#include
int pthread_attr_getdetachstate(const pthread_attr_t *attr,
int *detachstate);
int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);
DESCRIPTION
The detachstate attribute controls whether the thread is created in a detached state. If the thread is created detached,
then use of the ID of the newly created thread by the pthread_detach() or
pthread_join() function is an error.
The pthread_attr_getdetachstate() and pthread_attr_setdetachstate() functions, respectively, shall get and set the
detachstate attribute in the attr object.
For pthread_attr_getdetachstate(), detachstate shall be set to either PTHREAD_CREATE_DETACHED or
PTHREAD_CREATE_JOINABLE.
For pthread_attr_setdetachstate(), the application shall set detachstate to either PTHREAD_CREATE_DETACHED or
PTHREAD_CREATE_JOINABLE.
A value of PTHREAD_CREATE_DETACHED shall cause all threads created with attr to be in the detached state, whereas using a
value of PTHREAD_CREATE_JOINABLE shall cause all threads created with attr to be in the joinable state. The default value of
the detachstate attribute shall be PTHREAD_CREATE_JOINABLE.
The behavior is undefined if the value specified by the attr argument to pthread_attr_getdetachstate() or
pthread_attr_setdetachstate() does not refer to an initialized thread attributes object.
RETURN VALUE
Upon successful completion, pthread_attr_getdetachstate() and pthread_attr_setdetachstate() shall return a value
of 0; otherwise, an error number shall be returned to indicate the error.
The pthread_attr_getdetachstate() function stores the value of the detachstate attribute in detachstate if
successful.
ERRORS
The pthread_attr_setdetachstate() function shall fail if:
[EINVAL]
The value of detachstate was not valid
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
Retrieving the detachstate Attribute
This example shows how to obtain the detachstate attribute of a thread attribute object.
#include
pthread_attr_t thread_attr;
int            detachstate;
int            rc;
/* code initializing thread_attr */
...
rc = pthread_attr_getdetachstate (&thread_attr, &detachstate);
if (rc!=0) {
/* handle error */
...
}
else {
/* legal values for detachstate are:
* PTHREAD_CREATE_DETACHED or PTHREAD_CREATE_JOINABLE
*/
...
}
APPLICATION USAGE
None.
RATIONALE
If an implementation detects that the value specified by the attr argument to pthread_attr_getdetachstate() or
pthread_attr_setdetachstate() does not refer to an initialized thread attributes object, it is recommended that the function
should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_attr_destroy(), pthread_attr_getstacksize(), pthread_create()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_attr_setdetachstate() and pthread_attr_getdetachstate() functions are marked as part of the Threads
option.
The normative text is updated to avoid use of the term "must" for application requirements.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/72 is applied, adding the example to the EXAMPLES section.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/73 is applied, updating the ERRORS section to include the
optional [EINVAL] error.
Issue 7
The pthread_attr_setdetachstate() and pthread_attr_getdetachstate() functions are moved from the Threads option to
the Base.
The [EINVAL] error for an uninitialized thread attributes object is removed; this condition results in undefined behavior.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strtok.html =====
strtok
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strtok, strtok_r — split string into tokens
SYNOPSIS
#include
char *strtok(char *restrict s, const char *restrict sep);
[CX]  char *strtok_r(char *restrict s, const char *restrict sep,
char **restrict state);
DESCRIPTION
For strtok(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
A sequence of calls to strtok() breaks the string pointed to by s into a sequence of tokens, each of which is
delimited by a byte from the string pointed to by sep. The first call in the sequence has s as its first argument,
and is followed by calls with a null pointer as their first argument. The separator string pointed to by sep may be
different from call to call.
The first call in the sequence searches the string pointed to by s for the first byte that is not contained in the
current separator string pointed to by sep. If no such byte is found, then there are no tokens in the string pointed to by
s and strtok() shall return a null pointer. If such a byte is found, it is the start of the first token.
The strtok() function then searches from there for a byte that is contained in the current separator string. If no
such byte is found, the current token extends to the end of the string pointed to by s, and subsequent searches for a token
shall return a null pointer. If such a byte is found, it is overwritten by a NUL character, which terminates the current token. The
strtok() function saves a pointer to the following byte, from which the next search for a token shall start.
Each subsequent call, with a null pointer as the value of the first argument, starts searching from the saved pointer and
behaves as described above.
The implementation shall behave as if no function defined in this volume of POSIX.1-2024 calls strtok().
The strtok() function need not be thread-safe; however, strtok() shall avoid data races with all other
functions.
[CX]  The
strtok_r() function shall be equivalent to strtok(), except that strtok_r() shall be thread-safe and the
argument state points to a user-provided pointer that allows strtok_r() to maintain state between calls which scan
the same string. The application shall ensure that the pointer pointed to by state is unique for each string (s)
being processed concurrently by strtok_r() calls. The application need not initialize the pointer pointed to by state
to any particular value. The implementation shall not update the pointer pointed to by state to point (directly or
indirectly) to resources, other than within the string s, that need to be freed or released by the caller.
[CX]  The
strtok() and strtok_r() functions shall not change the setting of errno on valid input.
RETURN VALUE
Upon successful completion, strtok() shall return a pointer to the first byte of a token. Otherwise, if there is no
token, strtok() shall return a null pointer.
[CX]  The
strtok_r() function shall return a pointer to the token found, or a null pointer when no token is found.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
Searching for Word Separators
The following example searches for tokens separated by  characters.
#include
...
char *token;
char line[] = "LINE TO BE SEPARATED";
char *search = " ";
/* Token will point to "LINE". */
token = strtok(line, search);
/* Token will point to "TO". */
token = strtok(NULL, search);
Find First two Fields in a Buffer
The following example uses strtok() to find two character strings (a key and data associated with that key) separated by
any combination of , , or  characters at the start of the array of characters pointed to by
buffer.
#include
...
char    *buffer;
...
struct element {
char *key;
char *data;
} e;
...
// Load the buffer...
...
// Get the key and its data...
e.key = strtok(buffer, " \t\n");
e.data = strtok(NULL, " \t\n");
// Process the rest of the contents of the buffer...
...
APPLICATION USAGE
Note that if sep is the empty string, strtok() and strtok_r() return a pointer to the remainder of the
string being tokenized.
The strtok_r() function is thread-safe and stores its state in a user-supplied buffer instead of possibly using a static
data area that may be overwritten by an unrelated call from another thread.
RATIONALE
The strtok() function searches for a separator string within a larger string. It returns a pointer to the last substring
between separator strings. This function uses static storage to keep track of the current string position between calls. The new
function, strtok_r(), takes an additional argument, state, to keep track of the current position in the string.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The strtok_r() function is included for alignment with the POSIX Threads Extension.
A note indicating that the strtok() function need not be reentrant is added to the DESCRIPTION.
Issue 6
Extensions beyond the ISO C standard are marked.
The strtok_r() function is marked as part of the Thread-Safe Functions option.
In the DESCRIPTION, the note about reentrancy is expanded to cover thread-safety.
The APPLICATION USAGE section is updated to include a note on the thread-safe function and its avoidance of possibly using a
static data area.
The restrict keyword is added to the strtok() and strtok_r() prototypes for alignment with the
ISO/IEC 9899:1999 standard.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
SD5-XSH-ERN-235 is applied, correcting an example.
The strtok_r() function is moved from the Thread-Safe Functions option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0615 [177] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0350 [878] is applied.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that strtok() and strtok_r() do not change the setting of
errno on valid input.
Austin Group Defect 1302 is applied, aligning the strtok() function with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/towlower.html =====
towlower
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
towlower, towlower_l — transliterate uppercase wide-character code to lowercase
SYNOPSIS
#include
wint_t towlower(wint_t wc);
[CX]  wint_t towlower_l(wint_t wc, locale_t locale);
DESCRIPTION
For towlower(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The towlower() [CX]  and towlower_l()
functions have as a domain a type wint_t, the value of which the application shall ensure is a character representable
as a wchar_t, and a wide-character code corresponding to a valid character in the locale used by the function or the value
of WEOF. If the argument has any other value, the behavior is undefined. If the argument of towlower() [CX]   or
towlower_l()  represents an uppercase wide-character code,
and there exists a corresponding lowercase wide-character code as defined by character type information in the current locale
[CX]
or in the locale represented by locale,
respectively (category LC_CTYPE ), the result shall be the corresponding lowercase wide-character code. All other
arguments in the domain are returned unchanged.
[CX]  The
behavior is undefined if the locale argument to towlower_l() is the special locale object LC_GLOBAL_LOCALE or is not
a valid locale object handle.
RETURN VALUE
Upon successful completion, the towlower() [CX]   and towlower_l()   functions shall return the lowercase letter corresponding to the argument passed; otherwise, they
shall return the argument unchanged.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
setlocale(), uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 4.
Issue 5
The following change has been made in this version for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E):
The SYNOPSIS has been changed to indicate that this function and associated data types are now made visible by inclusion of the
header rather than .
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The towlower_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0678 [302], XSH/TC1-2008/0679 [283], and XSH/TC1-2008/0680 [283] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0373 [685] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ffsll.html =====
ffs
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ffs, ffsl, ffsll — find first set bit
SYNOPSIS
[XSI]  #include
int ffs(int i);
int ffsl(long i);
int ffsll(long long i);
DESCRIPTION
The ffs(), ffsl(), and ffsll() functions shall find the first bit set (beginning with the least significant
bit) in i, and return the index of that bit. Bits are numbered starting at one (the least significant bit).
RETURN VALUE
The ffs(), ffsl(), and ffsll() functions shall return the index of the first bit set. If i is 0,
then these functions shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 8
Austin Group Defect 617 is applied, adding ffsl() and ffsll().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/nexttowardf.html =====
nextafter
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
nextafter, nextafterf, nextafterl, nexttoward, nexttowardf, nexttowardl — next representable floating-point
number
SYNOPSIS
#include
double nextafter(double x, double y);
float nextafterf(float x, float y);
long double nextafterl(long double x, long double y);
double nexttoward(double x, long double y);
float nexttowardf(float x, long double y);
long double nexttowardl(long double x, long double y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The nextafter(), nextafterf(), and nextafterl() functions shall compute the next representable
floating-point value following x in the direction of y. Thus, if y is less than x, nextafter()
shall return the largest representable floating-point number less than x. The nextafter(), nextafterf(), and
nextafterl() functions shall return y if x equals y.
The nexttoward(), nexttowardf(), and nexttowardl() functions shall be equivalent to the corresponding
nextafter() functions, except that the second parameter shall have type long double and the functions shall return
y converted to the type of the function if x equals y.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the next representable floating-point value following x in the
direction of y.
If x==y, y (of the type x) shall be returned.
[MX]
Even though underflow or overflow can occur, the returned value shall be independent of the current rounding direction mode.
If x is finite and the correct function value would overflow, a range error shall occur and ±HUGE_VAL, ±HUGE_VALF, and
±HUGE_VALL (with the same sign as x) shall be returned as appropriate for the return type of the function.
[MX]  If
x or y is NaN, a NaN shall be returned.
[MX]  If
x!=y and the correct function value is subnormal, zero, or underflows, a range error shall occur, and
[MXX]
the correct function value (if representable) or
[MX]  0.0 shall be returned.
ERRORS
These functions shall fail if:
Range Error
The correct value overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
Range Error
[MX]
The correct value is subnormal or underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
When  is included, note that the return type of
nextafter() depends on the generic typing deduced from both arguments, while the return type of nexttoward() depends
only on the generic typing of the first argument.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The nextafter() function is no longer marked as an extension.
The nextafterf(), nextafterl(), nexttoward(), nexttowardf(), and nexttowardl() functions are
added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0407 [68] and XSH/TC1-2008/0408 [357] are applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/asinf.html =====
asin
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
asin, asinf, asinl — arc sine function
SYNOPSIS
#include
double asin(double x);
float asinf(float x);
long double asinl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the principal value of the arc sine of their argument x. The value of x should be in
the range [-1,1].
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the arc sine of x, in the range [-ℼ/2,ℼ/2] radians.
For finite values of x not in the range [-1,1], a domain error shall occur, and [MX]   either a NaN
(if supported), or   an implementation-defined value shall be
returned.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, x shall be returned.
If x is ±Inf, a domain error shall occur, and a NaN shall be returned.
[MXX]
If x is subnormal, x should be returned.
[MX]  If x is subnormal, a range error may occur and, if x is
not returned, asin(), asinf(), and asinl() shall return an implementation-defined value no greater in
magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
ERRORS
These functions shall fail if:
Domain Error
The x argument is finite and is not in the range [-1,1], [MX]
or is ±Inf.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
These functions may fail if:
Range Error
[MX]
The value of x is subnormal.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), isnan(), sin()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The asinf() and asinl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0034 [320] and XSH/TC1-2008/0035 [68] are applied.
Issue 8
Austin Group Defect 1382 is applied, rearranging the text describing the behavior when x is subnormal to avoid the need
for two shading changes.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/be32toh.html =====
be16toh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
be16toh, be32toh, be64toh, htobe16, htobe32, htobe64, htole16, htole32, htole64, le16toh, le32toh, le64toh — convert
values between host and specified byte order
SYNOPSIS
#include
uint16_t be16toh(uint16_t big_endian_16bits);
uint32_t be32toh(uint32_t big_endian_32bits);
uint64_t be64toh(uint64_t big_endian_64bits);
uint16_t htobe16(uint16_t host_16bits);
uint32_t htobe32(uint32_t host_32bits);
uint64_t htobe64(uint64_t host_64bits);
uint16_t htole16(uint16_t host_16bits);
uint32_t htole32(uint32_t host_32bits);
uint64_t htole64(uint64_t host_64bits);
uint16_t le16toh(uint16_t little_endian_16bits);
uint32_t le32toh(uint32_t little_endian_32bits);
uint64_t le64toh(uint64_t little_endian_64bits);
DESCRIPTION
These functions shall convert integer values of various sizes between host representations and representations in a specified
order.
On some implementations, these functions are defined as macros.
A little-endian representation of an integer has the least significant byte stored as the first byte, with the significance of
the bytes increasing as the byte address increases. A big-endian representation has the most significant byte as the first byte,
with the significance of the bytes reducing as the byte address increases.
Note:
Network byte order is big-endian.
For example, the uint32_t value 0x01020304 is represented as the four bytes 0x04, 0x03, 0x02, 0x01 on a little-endian
host, and as 0x01, 0x02, 0x03, 0x04 on a big-endian host.
For each of the sizes 16, 32 and 64, the htobeSIZE() function shall convert from whatever order the host uses to
big-endian representation, htoleSIZE() shall convert to little-endian representation, beSIZEtoh() shall convert from
big-endian to host order, and leSIZEtoh() shall convert from little-endian to host order.
RETURN VALUE
These functions shall return an unsigned integer of the appropriate size and representation.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
#include
#include
#include
int main(int argc, char *argv[])
{
uint32_t val;
if (argc > 1) {
val = (uint32_t)strtoul(argv[1], NULL, 0);
printf("Value: %08x\n", val);
printf("As bytes:\n");
union {
uint32_t asint;
unsigned char asbytes[sizeof(uint32_t)];
} u;
printf("Little endian: ");
u.asint = htole32(val);
for (int i = 0; i  is included:
htobe32
htonl
htobe16
htons
be32toh
ntohl
be16toh
ntohs
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
htonl()
XBD ,
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/raise.html =====
raise
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
raise — send a signal to the executing process
SYNOPSIS
#include
int raise(int sig);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The raise() function shall send the signal sig to the executing [CX]   thread or
process.  If a signal handler is called, the raise() function
shall not return until after the signal handler does.
[CX]  The
effect of the raise() function shall be equivalent to calling:
pthread_kill(pthread_self(), sig);
RETURN VALUE
Upon successful completion, 0 shall be returned. Otherwise, a non-zero value shall be returned [CX]   and
errno shall be set to indicate the error.
ERRORS
The raise() function shall fail if:
[EINVAL]
[CX]
The value of the sig argument is an invalid signal number.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The term "thread" is an extension to the ISO C standard.
FUTURE DIRECTIONS
None.
SEE ALSO
kill(), sigaction()
XBD ,
CHANGE HISTORY
First released in Issue 4. Derived from the ANSI C standard.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Threads Extension.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the RETURN VALUE section, the requirement to set errno on error is added.
The [EINVAL] error condition is added.
Issue 7
Functionality relating to the Threads option is moved to the Base.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_setcanceltype.html =====
pthread_setcancelstate
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_setcancelstate, pthread_setcanceltype, pthread_testcancel — set cancelability state
SYNOPSIS
#include
int pthread_setcancelstate(int state, int *oldstate);
int pthread_setcanceltype(int type, int *oldtype);
void pthread_testcancel(void);
DESCRIPTION
The pthread_setcancelstate() function shall atomically both set the calling thread's cancelability state to the indicated
state and return the previous cancelability state at the location referenced by oldstate. Legal values for
state are PTHREAD_CANCEL_ENABLE and PTHREAD_CANCEL_DISABLE.
The pthread_setcanceltype() function shall atomically both set the calling thread's cancelability type to the indicated
type and return the previous cancelability type at the location referenced by oldtype. Legal values for type
are PTHREAD_CANCEL_DEFERRED and PTHREAD_CANCEL_ASYNCHRONOUS.
The cancelability state and type of any newly created threads, including the thread in which main() was first invoked,
shall be PTHREAD_CANCEL_ENABLE and PTHREAD_CANCEL_DEFERRED respectively.
The pthread_testcancel() function shall create a cancellation point in the calling thread. The
pthread_testcancel() function shall have no effect if cancelability is disabled.
The pthread_setcancelstate() function shall be async-signal-safe.
RETURN VALUE
If successful, the pthread_setcancelstate() and pthread_setcanceltype() functions shall return zero; otherwise, an
error number shall be returned to indicate the error.
ERRORS
The pthread_setcancelstate() function may fail if:
[EINVAL]
The specified state is not PTHREAD_CANCEL_ENABLE or PTHREAD_CANCEL_DISABLE.
The pthread_setcanceltype() function may fail if:
[EINVAL]
The specified type is not PTHREAD_CANCEL_DEFERRED or PTHREAD_CANCEL_ASYNCHRONOUS.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
In order to write a signal handler for an asynchronous signal which can run safely in a cancellable thread,
pthread_setcancelstate() must be used to disable cancellation for the duration of any calls that the signal handler makes
which are cancellation points. However, earlier versions of the standard did not permit strictly conforming applications to call
pthread_setcancelstate() from a signal handler since it was not required to be async-signal-safe. On non-conforming
implementations where pthread_setcancelstate() is not async-signal-safe, alternatives are to ensure either that the
corresponding signals are blocked during execution of functions that are not async-cancel-safe or that cancellation is disabled
during times when those signals could be delivered.
RATIONALE
The pthread_setcancelstate() and pthread_setcanceltype() functions control the points at which a thread may be
asynchronously canceled. For cancellation control to be usable in modular fashion, some rules need to be followed.
An object can be considered to be a generalization of a procedure. It is a set of procedures and global variables written as a
unit and called by clients not known by the object. Objects may depend on other objects.
First, cancelability should only be disabled on entry to an object, never explicitly enabled. On exit from an object, the
cancelability state should always be restored to its value on entry to the object.
This follows from a modularity argument: if the client of an object (or the client of an object that uses that object) has
disabled cancelability, it is because the client does not want to be concerned about cleaning up if the thread is canceled while
executing some sequence of actions. If an object is called in such a state and it enables cancelability and a cancellation request
is pending for that thread, then the thread is canceled, contrary to the wish of the client that disabled.
Second, the cancelability type may be explicitly set to either deferred or asynchronous upon entry to an object.
But as with the cancelability state, on exit from an object the cancelability type should always be restored to its value on entry
to the object.
Finally, only functions that are cancel-safe may be called from a thread that is asynchronously cancelable.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_cancel()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_setcancelstate(), pthread_setcanceltype(), and pthread_testcancel() functions are marked as
part of the Threads option.
Issue 7
The pthread_setcancelstate(), pthread_setcanceltype(), and pthread_testcancel() functions are moved from
the Threads option to the Base.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0294 [622] and XSH/TC2-2008/0295 [615] are applied.
Issue 8
Austin Group Defect 841 is applied, requiring pthread_setcancelstate() to be async-signal-safe.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/vsprintf.html =====
vfprintf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
vasprintf, vdprintf, vfprintf, vprintf, vsnprintf, vsprintf — format output of a stdarg argument list
SYNOPSIS
#include
#include
[CX]  int vasprintf(char **restrict ptr, const char *restrict format,
va_list ap);
int vdprintf(int fildes, const char *restrict format, va_list ap);
int vfprintf(FILE *restrict stream, const char *restrict format,
va_list ap);
int vprintf(const char *restrict format, va_list ap);
int vsnprintf(char *restrict s, size_t n, const char *restrict format,
va_list ap);
int vsprintf(char *restrict s, const char *restrict format, va_list
ap);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The [CX]
vasprintf(), vdprintf(),  vfprintf(),
vprintf(), vsnprintf(), and vsprintf() functions shall be equivalent to the [CX]  asprintf(), dprintf(),  fprintf(), printf(), snprintf(), and sprintf() functions respectively, except that instead of being called with a variable number
of arguments, they are called with an argument list as defined by .
These functions shall not invoke the va_end macro. As these functions invoke the va_arg macro, the value of
ap after the return is unspecified.
RETURN VALUE
Refer to fprintf().
ERRORS
Refer to fprintf().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications using these functions should call va_end(ap) afterwards to clean up.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fprintf()
XBD ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The vsnprintf() function is added.
Issue 6
The vfprintf(), vprintf(), vsnprintf(), and vsprintf() functions are updated for alignment with the
ISO/IEC 9899:1999 standard.
Issue 7
The vdprintf() function is added to complement the dprintf() function from
The Open Group Technical Standard, 2006, Extended API Set Part 1.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0703 [14] is applied.
Issue 8
Austin Group Defect 1496 is applied, adding the vasprintf() function.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ctanl.html =====
ctan
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ctan, ctanf, ctanl — complex tangent functions
SYNOPSIS
#include
double complex ctan(double complex z);
float complex ctanf(float complex z);
long double complex ctanl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex tangent of z.
RETURN VALUE
These functions shall return the complex tangent value.
[MXC]
ctan(conj(iz)), ctanf(conjf(iz)), and ctanl(conjl(iz)) shall return
exactly the same value as conj(ctan(iz)), conjf(ctanf(iz)), and
conjl(ctanl(iz)), respectively, and ctan(-iz), ctanf(-iz), and
ctanl(-iz) shall return exactly the same value as -ctan(iz), -ctanf(iz), and
-ctanl(iz), respectively, including for the special values of iz below.
If iz is +0 + i0, -i (+0 + i0) shall be returned.
If iz is 0 + iInf, -i (0 + iNaN) shall be returned and the invalid floating-point exception shall be
raised.
If iz is x + iInf where x is non-zero and finite, -i (NaN + iNaN) shall be returned
and the invalid floating-point exception shall be raised.
If iz is 0 + iNaN, -i (0 + iNaN) shall be returned.
If iz is x + iNaN where x is non-zero and finite, -i (NaN + iNaN) shall be returned
and the invalid floating-point exception may be raised.
If iz is +Inf + iy where y is positive-signed and finite, -i (1 + i0 sin(2y))
shall be returned.
If iz is +Inf + iInf, -i (1 ± i0) shall be returned; the sign of the real part of the result is
unspecified.
If iz is +Inf + iNaN, -i (1 ± i0) shall be returned; the sign of the real part of the result is
unspecified.
If iz is NaN + i0, -i (NaN + i0) shall be returned.
If iz is NaN + iy where y is any non-zero number, -i (NaN + iNaN) shall be returned and the
invalid floating-point exception may be raised.
If iz is NaN + iNaN, -i (NaN + iNaN) shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The MXC special cases for ctan() are derived from those for ctanh() by
applying the formula ctan(z) = -ictanh(iz).
FUTURE DIRECTIONS
None.
SEE ALSO
catan(), ctanh()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/psignal.html =====
psiginfo
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
psiginfo, psignal — write signal information to standard error
SYNOPSIS
[CX]  #include
void psiginfo(const siginfo_t *pinfo, const char *message);
void psignal(int signum, const char *message);
DESCRIPTION
The psiginfo() and psignal() functions shall write a language-dependent message associated with a signal number to
the standard error stream as follows:
First, if message is not a null pointer and is not the empty string, the string pointed to by the message argument
shall be written, followed by a  and a .
Then the signal description string associated with signum or with the signal indicated by pinfo shall be written,
followed by a .
For psiginfo(), the application shall ensure that the argument pinfo references a valid siginfo_t
structure. For psignal(), if signum is not a valid signal number, the behavior is implementation-defined.
The psiginfo() and psignal() functions shall not change the orientation of the standard error stream.
The psiginfo() and psignal() functions shall mark for update the last data modification and last file status
change timestamps of the file associated with the standard error stream at some time between their successful completion and
exit(), abort(), or the completion of
fflush() or fclose() on
stderr.
The psiginfo() and psignal() functions shall not change the setting of errno if successful.
On error, the psiginfo() and psignal() functions shall set the error indicator for the stream to which
stderr points, and shall set errno to indicate the error.
Since no value is returned, an application wishing to check for error situations should set errno to 0, then call
psiginfo() or psignal(), then check errno.
RETURN VALUE
These functions shall not return a value.
ERRORS
Refer to fputc().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
As an alternative to setting errno to zero before the call and checking if it is non-zero afterwards, applications can
use ferror() to detect whether psiginfo() or psignal() encountered an
error.
An application wishing to use this method to check for error situations should call clearerr(stderr) before
calling psiginfo() or psignal(), then if ferror(stderr) returns non-zero, the value of errno
indicates which error occurred.
RATIONALE
System V historically has psignal() and psiginfo() in  . However, the
header is not specified in the Base Definitions volume of POSIX.1-2024, and the type siginfo_t is
defined in .
FUTURE DIRECTIONS
None.
SEE ALSO
fputc(), perror(), strsignal()
XBD
CHANGE HISTORY
First released in Issue 7.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0447 [399,428], XSH/TC1-2008/0448 [399], and XSH/TC1-2008/0449 [399,401] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0260 [629] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_rwlock_timedwrlock.html =====
pthread_rwlock_clockwrlock
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_rwlock_clockwrlock, pthread_rwlock_timedwrlock — lock a read-write lock for writing
SYNOPSIS
#include
int pthread_rwlock_clockwrlock(pthread_rwlock_t *restrict rwlock,
clockid_t clock_id, const struct timespec *restrict
abstime);
int pthread_rwlock_timedwrlock(pthread_rwlock_t *restrict rwlock,
const struct timespec *restrict abstime);
DESCRIPTION
The pthread_rwlock_clockwrlock() and pthread_rwlock_timedwrlock() functions shall apply a write lock to the
read-write lock referenced by rwlock as in the pthread_rwlock_wrlock() function. However, if the lock cannot be acquired
without waiting for other threads to unlock the lock, this wait shall be terminated when the specified timeout expires. The timeout
shall expire when the absolute time specified by abstime passes, as measured by the clock on which timeouts are based (that
is, when the value of that clock equals or exceeds abstime), or if the absolute time specified by abstime has already
been passed at the time of the call.
For pthread_rwlock_timedwrlock(), the timeout shall be based on the CLOCK_REALTIME clock. For
pthread_rwlock_clockwrlock(), the timeout shall be based on the clock specified by the clock_id argument. The
resolution of the timeout shall be the resolution of the clock on which it is based. Implementations shall support passing
CLOCK_REALTIME and CLOCK_MONOTONIC to pthread_rwlock_clockwrlock() as the clock_id argument.
Under no circumstances shall the function fail with a timeout if the lock can be acquired immediately. The validity of the
abstime parameter need not be checked if the lock can be immediately acquired.
If a signal that causes a signal handler to be executed is delivered to a thread blocked on a read-write lock via a call to
pthread_rwlock_clockwrlock() or pthread_rwlock_timedwrlock(), upon return from the signal handler the thread shall
resume waiting for the lock as if it was not interrupted.
The calling thread may deadlock if at the time the call is made it holds the read-write lock. The results are undefined if these
functions are called with an uninitialized read-write lock.
RETURN VALUE
The pthread_rwlock_clockwrlock() and pthread_rwlock_timedwrlock() functions shall return zero if the lock for
writing on the read-write lock object referenced by rwlock is acquired. Otherwise, an error number shall be returned to
indicate the error.
ERRORS
The pthread_rwlock_clockwrlock() and pthread_rwlock_timedwrlock() functions shall fail if:
[ETIMEDOUT]
The lock could not be acquired before the specified timeout expired.
The pthread_rwlock_clockwrlock() and pthread_rwlock_timedwrlock() functions may fail if:
[EDEADLK]
A deadlock condition was detected or the calling thread already holds the rwlock.
[EINVAL]
The abstime nanosecond value is less than zero or greater than or equal to 1000 million, or the
pthread_rwlock_clockwrlock() function was passed an invalid or unsupported clock_id value.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications using these functions may be subject to priority inversion, as discussed in XBD 3.275 Priority Inversion.
RATIONALE
If an implementation detects that the value specified by the rwlock argument to pthread_rwlock_clockwrlock() or
pthread_rwlock_timedwrlock() does not refer to an initialized read-write lock object, it is recommended that the function
should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_rwlock_clockrdlock(), pthread_rwlock_destroy(), pthread_rwlock_rdlock(), pthread_rwlock_trywrlock(), pthread_rwlock_unlock()
XBD 3.275 Priority Inversion, 4.15.2 Memory Synchronization, ,
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1j-2000.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/103 is applied, updating the ERRORS section so that the
[EDEADLK] error includes detection of a deadlock condition.
Issue 7
The pthread_rwlock_timedwrlock() function is moved from the Timeouts option to the Base.
The [EINVAL] error for an uninitialized read-write lock object is removed; this condition results in undefined behavior.
Issue 8
Austin Group Defect 592 is applied, removing text relating to  from
the SYNOPSIS and DESCRIPTION sections.
Austin Group Defects 1216 and 1472 are applied, adding pthread_rwlock_clockwrlock().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/logf.html =====
log
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
log, logf, logl — natural logarithm function
SYNOPSIS
#include
double log(double x);
float logf(float x);
long double logl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the natural logarithm of their argument x,
loge(x).
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the natural logarithm of x.
If x is ±0, a pole error shall occur and log(), logf(), and logl() shall return -HUGE_VAL,
-HUGE_VALF, and -HUGE_VALL, respectively.
For finite values of x that are less than 0, [MX]   or if x is -Inf,  a domain error shall occur, and [MX]   either a NaN (if supported), or   an implementation-defined value shall be returned.
[MX]  If
x is NaN, a NaN shall be returned.
If x is 1, +0 shall be returned.
If x is +Inf, x shall be returned.
ERRORS
These functions shall fail if:
Domain Error
The finite value of x is negative, [MX]   or x is -Inf.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
Pole Error
The value of x is zero.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the divide-by-zero floating-point exception shall
be raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
exp(), feclearexcept(),
fetestexcept(), isnan(),
log10(), log1p()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
The logf() and logl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/copysign.html =====
copysign
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
copysign, copysignf, copysignl — number manipulation function
SYNOPSIS
#include
double copysign(double x, double y);
float copysignf(float x, float y);
long double copysignl(long double x, long double y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall produce a value with the magnitude of x and the sign of y. On implementations that represent
a signed zero but do not treat negative zero consistently in arithmetic operations, these functions regard the sign of zero as
positive.
RETURN VALUE
Upon successful completion, these functions shall return a value with the magnitude of x and the sign of y.
[MX]  The
returned value shall be exact and shall be independent of the current rounding direction mode.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
signbit()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcwidth.html =====
wcwidth
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcwidth — number of column positions of a wide-character code
SYNOPSIS
[XSI]  #include
int wcwidth(wchar_t wc);
DESCRIPTION
The wcwidth() function shall determine the number of column positions required for the wide character wc. The
application shall ensure that the value of wc is a character representable as a wchar_t, and is a wide-character code
corresponding to a valid character in the current locale.
The wcwidth() function shall not change the setting of errno on valid input.
RETURN VALUE
The wcwidth() function shall either return 0 (if wc is a null wide-character code), or return the number of column
positions to be occupied by the wide-character code wc, or return -1 (if wc does not correspond to a printable
wide-character code).
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
This function was removed from the final ISO/IEC 9899:1990/Amendment 1:1995 (E), and the return value for a non-printable
wide character is not specified.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
wcswidth()
XBD
CHANGE HISTORY
First released as a World-wide Portability Interface in Issue 4. Derived from the MSE working draft.
Issue 6
The Open Group Corrigendum U021/12 is applied. This function is marked as an extension.
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that wcwidth() does not change the setting of errno on
valid input.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/acoshl.html =====
acosh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
acosh, acoshf, acoshl — inverse hyperbolic cosine functions
SYNOPSIS
#include
double acosh(double x);
float acoshf(float x);
long double acoshl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the inverse hyperbolic cosine of their argument x.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the inverse hyperbolic cosine of their argument.
For finite values of x
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The acosh() function is no longer marked as an extension.
The acoshf() and acoshl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0025 [320] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/cnd_broadcast.html =====
cnd_broadcast
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cnd_broadcast, cnd_signal — broadcast or signal a condition
SYNOPSIS
#include
int cnd_broadcast(cnd_t *cond);
int cnd_signal(cnd_t *cond);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The cnd_broadcast() function shall, [CX]   as a single atomic operation,   determine which threads, if any, are blocked on the condition variable pointed to by
cond and unblock all of these threads.
The cnd_signal() function shall, [CX]   as a single atomic operation,   determine which threads, if any, are blocked on the condition variable pointed to by
cond and unblock at least one of these threads.
If these functions determine that there are no threads blocked on the condition variable pointed to by cond, they shall
have no effect and shall return thrd_success.
[CX]  If
more than one thread is blocked on a condition variable, the scheduling policy shall determine the order in which threads are
unblocked. When each thread unblocked as a result of a cnd_broadcast() or cnd_signal() returns from its call to
cnd_wait() or cnd_timedwait(),
the thread shall own the mutex with which it called cnd_wait() or cnd_timedwait(). The thread(s) that are unblocked shall contend for the mutex
according to the scheduling policy (if applicable), and as if each had called mtx_lock().
The cnd_broadcast() and cnd_signal() functions can be called by a thread whether or not it currently owns the
mutex that threads calling cnd_wait() or cnd_timedwait() have associated with the condition variable during their waits;
however, if predictable scheduling behavior is required, then that mutex shall be locked by the thread calling
cnd_broadcast() or cnd_signal().
These functions shall not be affected if the calling thread executes a signal handler during the call.
The behavior is undefined if the value specified by the cond argument to cnd_broadcast() or cnd_signal()
does not refer to an initialized condition variable.
RETURN VALUE
These functions shall return thrd_success on success, or thrd_error if the request could not be honored.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
See the APPLICATION USAGE section for pthread_cond_broadcast(),
substituting cnd_broadcast() for pthread_cond_broadcast() and
cnd_signal() for pthread_cond_signal().
RATIONALE
As for pthread_cond_broadcast() and pthread_cond_signal(), spurious wakeups may occur with cnd_broadcast()
and cnd_signal(), necessitating that applications code a predicate-testing-loop around the condition wait. (See the
RATIONALE section for pthread_cond_broadcast().)
These functions are not affected by signal handlers for the reasons stated in XRAT B.2.3 Error Numbers.
FUTURE DIRECTIONS
None.
SEE ALSO
cnd_destroy(), cnd_timedwait(), pthread_cond_broadcast()
XBD 4.15.2 Memory Synchronization,
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcsrchr.html =====
wcsrchr
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcsrchr — wide-character string scanning operation
SYNOPSIS
#include
wchar_t *wcsrchr(const wchar_t *ws, wchar_t wc);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The wcsrchr() function shall locate the last occurrence of wc in the wide-character string pointed to by
ws. The application shall ensure that the value of wc is a character representable as a type wchar_t and a
wide-character code corresponding to a valid character in the current locale. The terminating null wide-character code shall be
considered to be part of the wide-character string.
[CX]  The
wcsrchr() function shall not change the setting of errno on valid input.
RETURN VALUE
Upon successful completion, wcsrchr() shall return a pointer to the wide-character code or a null pointer if wc
does not occur in the wide-character string.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
wcschr()
XBD
CHANGE HISTORY
First released in Issue 4. Derived from the MSE working draft.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that wcsrchr() does not change the setting of errno on
valid input.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/scalblnl.html =====
scalbln
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
scalbln, scalblnf, scalblnl, scalbn, scalbnf, scalbnl — compute exponent using FLT_RADIX
SYNOPSIS
#include
double scalbln(double x, long n);
float scalblnf(float x, long n);
long double scalblnl(long double x, long n);
double scalbn(double x, int n);
float scalbnf(float x, int n);
long double scalbnl(long double x, int n);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute x * FLT_RADIXn efficiently, not normally by
computing FLT_RADIXn explicitly.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return x * FLT_RADIXn.
[MX]  If
the calculation does not overflow or underflow, the returned value shall be exact and shall be independent of the current rounding
direction mode.
If the result would cause overflow, a range error shall occur and these functions shall return ±HUGE_VAL, ±HUGE_VALF, and
±HUGE_VALL (according to the sign of x) as appropriate for the return type of the function.
If the correct value would cause underflow, [MXX]   and is not representable,   a range error may occur, and scalbln(), scalblnf(), scalblnl(),
scalbn(), scalbnf(), and scalbnl() shall return [MXX]
0.0, or   (if IEC 60559 Floating-Point is not supported) an implementation-defined value no greater in
magnitude than DBL_MIN, FLT_MIN, LDBL_MIN, DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0 or ±Inf, x shall be returned.
If n is 0, x shall be returned.
[MXX]
If the correct value would cause underflow, and is representable, a range error may occur and the correct value shall be returned.
ERRORS
These functions shall fail if:
Range Error
The result overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
These functions may fail if:
Range Error
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
These functions are named so as to avoid conflicting with the historical definition of the scalb() function from the
Single UNIX Specification. The difference is that the scalb() function has a second argument of double instead of
int. The scalb() function is not part of the ISO C standard. The three functions whose second type is
long are provided because the factor required to scale from the smallest positive floating-point value to the largest finite
one, on many implementations, is too large to represent in the minimum-width int format.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0521 [68] and XSH/TC1-2008/0522 [68] are applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/shmctl.html =====
shmctl
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
shmctl — XSI shared memory control operations
SYNOPSIS
[XSI]  #include
int shmctl(int shmid, int cmd, struct shmid_ds *buf);
DESCRIPTION
The shmctl() function operates on XSI shared memory (see XBD 3.332
Shared Memory Object). It is unspecified whether this function interoperates with the realtime interprocess communication
facilities defined in 2.8 Realtime.
The shmctl() function provides a variety of shared memory control operations as specified by cmd. The following
values for cmd are available:
IPC_STAT
Place the current value of each member of the shmid_ds data structure associated with shmid into the structure
pointed to by buf. The contents of the structure are defined in .
IPC_SET
Set the value of the following members of the shmid_ds data structure associated with shmid to the corresponding
value found in the structure pointed to by buf:
shm_perm.uid
shm_perm.gid
shm_perm.mode    Low-order nine bits.
Also, the shm_ctime timestamp shall be set to the current time, as described in 2.7.1 IPC General Description.
IPC_SET can only be executed by a process that has an effective user ID equal to either that of a process with appropriate
privileges or to the value of shm_perm.cuid or shm_perm.uid in the shmid_ds data structure associated with
shmid.
IPC_RMID
Remove the shared memory identifier specified by shmid from the system. The shared memory segment and shmid_ds
data structure associated with it shall be destroyed when all processes with the segment attached have either detached the segment
or terminated. If the segment is not attached to any process, it shall be destroyed immediately. IPC_RMID can only be executed by a
process that has an effective user ID equal to either that of a process with appropriate privileges or to the value of
shm_perm.cuid or shm_perm.uid in the shmid_ds data structure associated with shmid.
RETURN VALUE
Upon successful completion, shmctl() shall return 0; otherwise, it shall return -1 and set errno to indicate the
error.
ERRORS
The shmctl() function shall fail if:
[EACCES]
The argument cmd is equal to IPC_STAT and the calling process does not have read permission; see 2.7 XSI Interprocess Communication.
[EINVAL]
The value of shmid is not a valid shared memory identifier, or the value of cmd is not a valid command.
[EPERM]
The argument cmd is equal to IPC_RMID or IPC_SET and the effective user ID of the calling process is not equal to that
of a process with appropriate privileges and it is not equal to the value of shm_perm.cuid or shm_perm.uid in the
data structure associated with shmid.
The shmctl() function may fail if:
[EOVERFLOW]
The cmd argument is IPC_STAT and the gid or uid value is too large to be stored in the structure pointed
to by the buf argument.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The POSIX Realtime Extension defines alternative interfaces for interprocess communication. Application developers who need to
use IPC should design their applications so that modules using the IPC routines described in 2.7 XSI Interprocess Communication can be easily modified to use the alternative
interfaces.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.7 XSI Interprocess Communication, 2.8 Realtime, shmat(), shmdt(), shmget(), shm_open(), shm_unlink()
XBD 3.332 Shared Memory Object,
CHANGE HISTORY
First released in Issue 2. Derived from Issue 2 of the SVID.
Issue 5
Moved from SHARED MEMORY to BASE.
The note about use of POSIX Realtime Extension IPC routines has been moved from FUTURE DIRECTIONS to a new APPLICATION USAGE
section.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0573 [345] is applied.
Issue 8
Austin Group Defect 1240 is applied, clarifying the description of IPC_RMID.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/dup2.html =====
dup
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
dup, dup2, dup3 — duplicate an open file descriptor
SYNOPSIS
#include
int dup(int fildes);
int dup2(int fildes, int fildes2);
int dup3(int fildes, int fildes2, int flag);
DESCRIPTION
The dup() function provides an alternative interface to the service provided by fcntl() using the F_DUPFD command. The call dup(fildes) shall be equivalent
to:
fcntl(fildes, F_DUPFD, 0);
The dup2() function shall cause the file descriptor fildes2 to refer to the same open file description as the file
descriptor fildes and to share any locks, and shall return fildes2. If fildes2 is already a valid open file
descriptor, it shall be closed first, unless fildes is equal to fildes2 in which case dup2() shall return
fildes2 without closing it. If the close operation fails to close fildes2, dup2() shall return -1 without
changing the open file description to which fildes2 refers. If fildes is not a valid file descriptor, dup2()
shall return -1 and shall not close fildes2. If fildes2 is less than 0 or greater than or equal to {OPEN_MAX},
dup2() shall return -1 with errno set to [EBADF].
Upon successful completion, if fildes is not equal to fildes2, the FD_CLOEXEC and FD_CLOFORK flags associated with
fildes2 shall be cleared. If fildes is equal to fildes2, the FD_CLOEXEC and FD_CLOFORK flags associated with
fildes2 shall not be changed.
The dup3() function shall be equivalent to the dup2() function, except that it shall be an error if fildes
is equal to fildes2, and the state of FD_CLOEXEC and FD_CLOFORK on the fildes2 file descriptor shall be determined
solely by the flag argument, which can be constructed from a bitwise-inclusive OR of flags from the following list:
O_CLOEXEC
Atomically set the FD_CLOEXEC flag on fildes2.
O_CLOFORK
Atomically set the FD_CLOFORK flag on fildes2.
[TYM]
If fildes refers to a typed memory object, the result of the dup2() or dup3() functions is unspecified.
RETURN VALUE
Upon successful completion a non-negative integer, namely the file descriptor, shall be returned; otherwise, -1 shall be
returned and errno set to indicate the error.
ERRORS
The dup() function shall fail if:
[EBADF]
The fildes argument is not a valid open file descriptor.
[EMFILE]
All file descriptors available to the process are currently open.
The dup2() and dup3() functions shall fail if:
[EBADF]
The fildes argument is not a valid open file descriptor or the argument fildes2 is negative or greater than or
equal to {OPEN_MAX}.
[EINTR]
The function was interrupted by a signal.
The dup3() function shall fail if:
[EINVAL]
The fildes and fildes2 arguments are equal.
The dup2() and dup3() functions may fail if:
[EIO]
An I/O error occurred while attempting to close fildes2.
The dup3() function may fail if:
[EINVAL]
The value of the flag argument is invalid.
The following sections are informative.
EXAMPLES
Redirecting Standard Output to a File
The following example closes standard output for the current processes, re-assigns standard output to go to the file referenced
by pfd, and closes the original file descriptor to clean up.
#include
...
int pfd;
...
close(1);
dup(pfd);
close(pfd);
...
Redirecting Error Messages
The following example redirects messages from stderr to stdout.
#include
...
dup2(1, 2);
...
APPLICATION USAGE
Implementations may use file descriptors that must be inherited into child processes for the child process to remain conforming,
such as for message catalog or tracing purposes. Therefore, an application that calls dup2() with an arbitrary integer for
fildes2 risks non-conforming behavior, and dup2() can only portably be used to overwrite file descriptor values that
the application has obtained through explicit actions, or for the three file descriptors corresponding to the standard file
streams. In order to avoid a race condition of leaking an unintended file descriptor into a child process or executed program, an
application should consider opening all file descriptors with the FD_CLOFORK or FD_CLOEXEC flag, or both flags, set unless the file
descriptor is intended to be inherited by child processes or executed programs, respectively.
RATIONALE
The dup() function is redundant. Its services are also provided by the fcntl() function. It has been included in this volume of POSIX.1-2024 primarily for historical
reasons, since many existing applications use it. On the other hand, the dup2() function provides unique services, as no
other interface is able to atomically replace an existing file descriptor.
The dup2() function is not marked obsolescent because it presents a type-safe version of functionality provided in a
type-unsafe version by fcntl(). It is used in the POSIX Ada binding.
The dup2() function is not intended for use in critical regions as a synchronization mechanism.
In the description of [EBADF], the case of fildes being out of range is covered by the given case of fildes not
being valid. The descriptions for fildes and fildes2 are different because the only kind of invalidity that is
relevant for fildes2 is whether it is out of range; that is, it does not matter whether fildes2 refers to an open
file when the dup2() call is made.
The dup3() function with the O_CLOEXEC and O_CLOFORK flags is necessary to avoid a data race in multi-threaded
applications. Without O_CLOFORK, a file descriptor is leaked into a child process created by one thread in the window between
another thread creating a file descriptor with dup2() and then using fcntl() to
set the FD_CLOFORK flag. Without O_CLOEXEC, a file descriptor intentionally inherited by child processes is similarly leaked into
an executed program if FD_CLOEXEC is not set atomically. The safe counterpart for avoiding the same race with dup() is the
use of the F_DUPFD_CLOFORK or F_DUPFD_CLOEXEC action of the fcntl() function.
FUTURE DIRECTIONS
None.
SEE ALSO
close(), fcntl(), open()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 7
SD5-XSH-ERN-187 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0075 [149,428] and XSH/TC1-2008/0076 [149] are applied.
Issue 8
Austin Group Defects 411, 1318, 1483, and 1577 are applied, adding dup3() and FD_CLOFORK.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/if_nameindex.html =====
if_nameindex
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
if_nameindex — return all network interface names and indexes
SYNOPSIS
#include
struct if_nameindex *if_nameindex(void);
DESCRIPTION
The if_nameindex() function shall return an array of if_nameindex structures, one structure per interface. The end
of the array is indicated by a structure with an if_index field of zero and an if_name field of NULL.
Applications should call if_freenameindex() to release the memory that
may be dynamically allocated by this function, after they have finished using it.
RETURN VALUE
An array of structures identifying local interfaces. A null pointer is returned upon an error, with errno set to indicate
the error.
ERRORS
The if_nameindex() function may fail if:
[ENOBUFS]
Insufficient resources are available to complete the function.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
getsockopt(), if_freenameindex(), if_indextoname(), if_nametoindex(), setsockopt()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_mutex_destroy.html =====
pthread_mutex_destroy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_mutex_destroy, pthread_mutex_init — destroy and initialize a mutex
SYNOPSIS
#include
int pthread_mutex_destroy(pthread_mutex_t *mutex);
int pthread_mutex_init(pthread_mutex_t *restrict mutex,
const pthread_mutexattr_t *restrict attr);
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
DESCRIPTION
The pthread_mutex_destroy() function shall destroy the mutex object referenced by mutex; the mutex object becomes,
in effect, uninitialized. An implementation may cause pthread_mutex_destroy() to set the object referenced by mutex
to an invalid value.
A destroyed mutex object can be reinitialized using pthread_mutex_init(); the results of otherwise referencing the object
after it has been destroyed are undefined.
It shall be safe to destroy an initialized mutex that is unlocked. Attempting to destroy a locked mutex, or a mutex that another
thread is attempting to lock, or a mutex that is being used in a pthread_cond_clockwait(), pthread_cond_timedwait(), or pthread_cond_wait() call by another thread, results in undefined behavior.
The pthread_mutex_init() function shall initialize the mutex referenced by mutex with attributes specified by
attr. If attr is NULL, the default mutex attributes are used; the effect shall be the same as passing the address of
a default mutex attributes object. Upon successful initialization, the state of the mutex becomes initialized and unlocked.
See 2.9.9 Synchronization Object Copies and Alternative Mappings
for further requirements.
Attempting to initialize an already initialized mutex results in undefined behavior.
In cases where default mutex attributes are appropriate, the macro PTHREAD_MUTEX_INITIALIZER can be used to initialize mutexes.
The effect shall be equivalent to dynamic initialization by a call to pthread_mutex_init() with parameter attr
specified as NULL, except that no error checks are performed.
The behavior is undefined if the value specified by the mutex argument to pthread_mutex_destroy() does not refer
to an initialized mutex.
The behavior is undefined if the value specified by the attr argument to pthread_mutex_init() does not refer to an
initialized mutex attributes object.
RETURN VALUE
If successful, the pthread_mutex_destroy() and pthread_mutex_init() functions shall return zero; otherwise, an
error number shall be returned to indicate the error.
ERRORS
The pthread_mutex_init() function shall fail if:
[EAGAIN]
The system lacked the necessary resources (other than memory) to initialize another mutex.
[ENOMEM]
Insufficient memory exists to initialize the mutex.
[EPERM]
The caller does not have the privilege to perform the operation.
The pthread_mutex_init() function may fail if:
[EINVAL]
The attributes object referenced by attr has the robust mutex attribute set without the process-shared attribute being
set.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
If an implementation detects that the value specified by the mutex argument to pthread_mutex_destroy() does not
refer to an initialized mutex, it is recommended that the function should fail and report an [EINVAL] error.
If an implementation detects that the value specified by the mutex argument to pthread_mutex_destroy() or
pthread_mutex_init() refers to a locked mutex or a mutex that is referenced (for example, while being used in a pthread_cond_clockwait(), pthread_cond_timedwait(), or pthread_cond_wait() call) by another thread, or detects that the value specified
by the mutex argument to pthread_mutex_init() refers to an already initialized mutex, it is recommended that the
function should fail and report an [EBUSY] error.
If an implementation detects that the value specified by the attr argument to pthread_mutex_init() does not refer
to an initialized mutex attributes object, it is recommended that the function should fail and report an [EINVAL] error.
Alternate Implementations Possible
This volume of POSIX.1-2024 supports several alternative implementations of mutexes. An implementation may store the lock
directly in the object of type pthread_mutex_t. Alternatively, an implementation may store the lock in the heap and merely
store a pointer, handle, or unique ID in the mutex object. Either implementation has advantages or may be required on certain
hardware configurations. So that portable code can be written that is invariant to this choice, this volume of POSIX.1-2024 does
not define assignment or equality for this type, and it uses the term "initialize" to reinforce the (more restrictive) notion
that the lock may actually reside in the mutex object itself.
Note that this precludes an over-specification of the type of the mutex or condition variable and motivates the opaqueness of
the type.
An implementation is permitted, but not required, to have pthread_mutex_destroy() store an illegal value into the mutex.
This may help detect erroneous programs that try to lock (or otherwise reference) a mutex that has already been destroyed.
Tradeoff Between Error Checks and Performance Supported
Many error conditions that can occur are not required to be detected by the implementation in order to let implementations trade
off performance versus degree of error checking according to the needs of their specific applications and execution
environment. As a general rule, conditions caused by the system (such as insufficient memory) are required to be detected, but
conditions caused by an erroneously coded application (such as failing to provide adequate synchronization to prevent a mutex from
being deleted while in use) are specified to result in undefined behavior.
A wide range of implementations is thus made possible. For example, an implementation intended for application debugging may
implement all of the error checks, but an implementation running a single, provably correct application under very tight
performance constraints in an embedded computer might implement minimal checks. An implementation might even be provided in two
versions, similar to the options that compilers provide: a full-checking, but slower version; and a limited-checking, but faster
version. To forbid this optionality would be a disservice to users.
By carefully limiting the use of "undefined behavior" only to things that an erroneous (badly coded) application might do, and
by defining that resource-not-available errors are mandatory, this volume of POSIX.1-2024 ensures that a fully-conforming
application is portable across the full range of implementations, while not forcing all implementations to add overhead to check
for numerous things that a correct program never does. When the behavior is undefined, no error number is specified to be returned
on implementations that do detect the condition. This is because undefined behavior means anything can happen, which
includes returning with any value (which might happen to be a valid, but different, error number). However, since the error number
might be useful to application developers when diagnosing problems during application development, a recommendation is made in
rationale that implementors should return a particular error number if their implementation does detect the condition.
Why No Limits are Defined
Defining symbols for the maximum number of mutexes and condition variables was considered but rejected because the number of
these objects may change dynamically. Furthermore, many implementations place these objects into application memory; thus, there is
no explicit maximum.
Static Initializers for Mutexes and Condition Variables
Providing for static initialization of statically allocated synchronization objects allows modules with private static
synchronization variables to avoid runtime initialization tests and overhead. Furthermore, it simplifies the coding of
self-initializing modules. Such modules are common in C libraries, where for various reasons the design calls for
self-initialization instead of requiring an explicit module initialization function to be called. An example use of static
initialization follows.
Without static initialization, a self-initializing routine foo() might look as follows:
static pthread_once_t foo_once = PTHREAD_ONCE_INIT;
static pthread_mutex_t foo_mutex;
void foo_init()
{
pthread_mutex_init(&foo_mutex, NULL);
}
void foo()
{
pthread_once(&foo_once, foo_init);
pthread_mutex_lock(&foo_mutex);
/* Do work. */
pthread_mutex_unlock(&foo_mutex);
}
With static initialization, the same routine could be coded as follows:
static pthread_mutex_t foo_mutex = PTHREAD_MUTEX_INITIALIZER;
void foo()
{
pthread_mutex_lock(&foo_mutex);
/* Do work. */
pthread_mutex_unlock(&foo_mutex);
}
Note that the static initialization both eliminates the need for the initialization test inside pthread_once() and the fetch of &foo_mutex to learn the address to be passed to
pthread_mutex_lock() or pthread_mutex_unlock().
Thus, the C code written to initialize static objects is simpler on all systems and is also faster on a large class of systems;
those where the (entire) synchronization object can be stored in application memory.
Yet the locking performance question is likely to be raised for machines that require mutexes to be allocated out of special
memory. Such machines actually have to have mutexes and possibly condition variables contain pointers to the actual hardware locks.
For static initialization to work on such machines, pthread_mutex_lock()
also has to test whether or not the pointer to the actual lock has been allocated. If it has not, pthread_mutex_lock() has to initialize it before use. The reservation of such
resources can be made when the program is loaded, and hence return codes have not been added to mutex locking and condition
variable waiting to indicate failure to complete initialization.
This runtime test in pthread_mutex_lock() would at first seem to be
extra work; an extra test is required to see whether the pointer has been initialized. On most machines this would actually be
implemented as a fetch of the pointer, testing the pointer against zero, and then using the pointer if it has already been
initialized. While the test might seem to add extra work, the extra effort of testing a register is usually negligible since no
extra memory references are actually done. As more and more machines provide caches, the real expenses are memory references, not
instructions executed.
Alternatively, depending on the machine architecture, there are often ways to eliminate all overhead in the most
important case: on the lock operations that occur after the lock has been initialized. This can be done by shifting more
overhead to the less frequent operation: initialization. Since out-of-line mutex allocation also means that an address has to be
dereferenced to find the actual lock, one technique that is widely applicable is to have static initialization store a bogus value
for that address; in particular, an address that causes a machine fault to occur. When such a fault occurs upon the first attempt
to lock such a mutex, validity checks can be done, and then the correct address for the actual lock can be filled in. Subsequent
lock operations incur no extra overhead since they do not "fault". This is merely one technique that can be used to support
static initialization, while not adversely affecting the performance of lock acquisition. No doubt there are other techniques that
are highly machine-dependent.
The locking overhead for machines doing out-of-line mutex allocation is thus similar for modules being implicitly initialized,
where it is improved for those doing mutex allocation entirely inline. The inline case is thus made much faster, and the
out-of-line case is not significantly worse.
Besides the issue of locking performance for such machines, a concern is raised that it is possible that threads would serialize
contending for initialization locks when attempting to finish initializing statically allocated mutexes. (Such finishing would
typically involve taking an internal lock, allocating a structure, storing a pointer to the structure in the mutex, and releasing
the internal lock.) First, many implementations would reduce such serialization by hashing on the mutex address. Second, such
serialization can only occur a bounded number of times. In particular, it can happen at most as many times as there are statically
allocated synchronization objects. Dynamically allocated objects would still be initialized via pthread_mutex_init() or
pthread_cond_init().
Finally, if none of the above optimization techniques for out-of-line allocation yields sufficient performance for an
application on some implementation, the application can avoid static initialization altogether by explicitly initializing all
synchronization objects with the corresponding pthread_*_init() functions, which are supported by all implementations. An
implementation can also document the tradeoffs and advise which initialization technique is more efficient for that particular
implementation.
Destroying Mutexes
A mutex can be destroyed immediately after it is unlocked. However, since attempting to destroy a locked mutex, or a mutex that
another thread is attempting to lock, or a mutex that is being used in a pthread_cond_clockwait(), pthread_cond_timedwait(), or pthread_cond_wait() call by another thread, results in undefined behavior, care
must be taken to ensure that no other thread may be referencing the mutex.
Robust Mutexes
Implementations are required to provide robust mutexes for mutexes with the process-shared attribute set to
PTHREAD_PROCESS_SHARED. Implementations are allowed, but not required, to provide robust mutexes when the process-shared attribute
is set to PTHREAD_PROCESS_PRIVATE.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_mutex_getprioceiling(), pthread_mutexattr_getrobust(), pthread_mutex_clocklock(), pthread_mutex_lock(), pthread_mutexattr_getpshared()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_mutex_destroy() and pthread_mutex_init() functions are marked as part of the Threads option.
The pthread_mutex_timedlock() function is added to the SEE ALSO
section for alignment with IEEE Std 1003.1d-1999.
IEEE PASC Interpretation 1003.1c #34 is applied, updating the DESCRIPTION.
The restrict keyword is added to the pthread_mutex_init() prototype for alignment with the ISO/IEC 9899:1999
standard.
Issue 7
Changes are made from The Open Group Technical Standard, 2006, Extended API Set Part 3.
The pthread_mutex_destroy() and pthread_mutex_init() functions are moved from the Threads option to the Base.
The [EINVAL] error for an uninitialized mutex or an uninitialized mutex attributes object is removed; this condition results in
undefined behavior.
The [EBUSY] error for a locked mutex, a mutex that is referenced, or an already initialized mutex is removed; this condition
results in undefined behavior.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0460 [70,428] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0278 [811], XSH/TC2-2008/0279 [972], and XSH/TC2-2008/0280 [811] are
applied.
Issue 8
Austin Group Defect 1216 is applied, adding pthread_cond_clockwait().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcscat.html =====
wcscat
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcscat — concatenate two wide-character strings
SYNOPSIS
#include
wchar_t *wcscat(wchar_t *restrict ws1, const wchar_t *restrict ws2);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The wcscat() function shall append a copy of the wide-character string pointed to by ws2 (including the
terminating null wide-character code) to the end of the wide-character string pointed to by ws1. The initial wide-character
code of ws2 shall overwrite the null wide-character code at the end of ws1. If copying takes place between objects
that overlap, the behavior is undefined.
[CX]  The
wcscat() function shall not change the setting of errno on valid input.
RETURN VALUE
The wcscat() function shall return ws1; no return value is reserved to indicate an error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
wcsncat()
XBD
CHANGE HISTORY
First released in Issue 4. Derived from the MSE working draft.
Issue 6
The Open Group Corrigendum U040/2 is applied. In the RETURN VALUE section, s1 is changed to ws1.
The wcscat() prototype is updated for alignment with the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that wcscat() does not change the setting of errno on
valid input.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/bind_textdomain_codeset.html =====
bindtextdomain
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
bindtextdomain, bind_textdomain_codeset, textdomain — text domain manipulation functions
SYNOPSIS
#include
char *bindtextdomain(const char *domainname, const char *dirname);
char *bind_textdomain_codeset(const char *domainname,
const char *codeset);
char *textdomain(const char *domainname);
DESCRIPTION
The textdomain() function shall set or query the name of the current text domain of the calling process. The application
shall ensure that the domainname argument is either a null pointer (when querying), an empty string, or a string that, when
used by the gettext family of functions to construct a pathname to a messages object, results in a valid pathname. For
portable applications, it should only contain characters from the portable filename character set.
The text domain setting made by the last successful call to textdomain() shall remain in effect across subsequent calls
to setlocale(), uselocale(), and
the gettext family of functions.
Applications should not use text domains whose names begin with the strings "SYS_" or "libc". These prefixes
are reserved for implementation use.
The current setting of the text domain can be queried without affecting the current state of the domain by calling
textdomain() with domainname set to a null pointer. Calling textdomain() with a domainname argument of
an empty string shall set the text domain to the default domain, "messages".
The bindtextdomain() function shall set or query the binding of a text domain to a dirname that is used by the
gettext family of functions to construct a pathname to a messages object in the text domain:
If domainname is a null pointer or an empty string, bindtextdomain() shall make no changes and return a null
pointer without changing errno.
Otherwise, if dirname is a non-empty string:
If domainname is not already bound, bindtextdomain() shall bind the text domain specified by domainname to
the pathname pointed to by dirname and return the bound directory pathname on success or a null pointer on failure.
If domainname is already bound, bindtextdomain() shall replace the existing binding with the pathname pointed to
by dirname and return the bound directory pathname on success or a null pointer on failure. On failure, the existing binding
shall remain unchanged.
It is unspecified whether the bindtextdomain() function performs pathname resolution on dirname, or whether that
is done by the gettext family of functions.
Otherwise, if dirname is a null pointer:
If domainname is bound, the function shall return the bound directory pathname.
If domainname is not bound, the function shall return the implementation-defined default directory pathname used by the
gettext family of functions.
Otherwise, dirname is an empty string and the behavior is unspecified.
If a text domain is bound to a relative pathname and the current working directory is changed after the binding is established,
the pathnames used by the gettext family of functions to locate messages objects for that text domain are unspecified.
The bind_textdomain_codeset() function shall set or query the binding of a text domain to the output codeset used by the
gettext family of functions for message strings retrieved from messages objects for the text domain specified by
domainname:
If domainname is a null pointer or an empty string, bind_textdomain_codeset() shall make no changes and return a
null pointer without changing errno.
Otherwise, if codeset is a non-empty string:
If domainname is not already bound, bind_textdomain_codeset() shall bind the text domain specified by
domainname to the codeset pointed to by codeset and return the newly bound codeset on success or a null pointer on
failure.
If domainname is already bound, bind_textdomain_codeset() shall replace the existing binding with the codeset
pointed to by codeset and return the newly bound codeset on success or a null pointer on failure. On failure, the existing
binding shall remain unchanged.
The application shall ensure that the codeset argument, if non-empty, is a valid codeset name that can be used as the
tocode argument of the iconv_open() function, and that in the codeset it
specifies, the  character corresponds to a single null byte.
Otherwise, if codeset is a null pointer:
If domainname is bound, the function shall return the bound codeset.
If domainname is not bound, the function shall return the implementation-defined default codeset used by the
gettext family of functions.
Otherwise, codeset is an empty string and the behavior is unspecified.
If codeset is a null pointer and domainname is a non-empty string, bind_textdomain_codeset() shall return
the current codeset for the named domain, or a null pointer if a codeset has not yet been set. The bind_textdomain_codeset()
function can be called multiple times. If successfully called multiple times with the same domainname argument, the last
such call shall override the setting made by the previous such call.
RETURN VALUE
The return value from a successful textdomain() call shall be a pointer to a string containing the current setting of the
text domain. If domainname is a null pointer, textdomain() shall return a pointer to the string containing the
current text domain. If textdomain() was not previously called and domainname is a null string, the name of the
default text domain shall be returned. The name of the default text domain shall be the string "messages". If
textdomain() fails, a null pointer shall be returned and errno shall be set to indicate the error.
For bindtextdomain() return values see the DESCRIPTION. When bindtextdomain() is called with a non-empty
domainname and returns a null pointer, it shall set errno to indicate the error. When bindtextdomain() returns
a pathname for a bound text domain, the return value shall be a pointer to a copy of the dirname string passed to the
bindtextdomain() call that created the binding. The returned string shall remain valid until the next successful call to
bindtextdomain() with a non-empty dirname and same domainname. The application shall ensure that it does not
modify the returned string.
A call to the bind_textdomain_codeset() function with a non-empty domainname argument shall return one of the
following:
The currently bound codeset name for that text domain if codeset is a null pointer
The newly bound codeset if codeset is non-empty
A null pointer without changing errno if no codeset has yet been bound for that text domain
The application shall ensure that it does not modify the returned string. A subsequent call to bind_textdomain_codeset()
with a non-empty domainname argument might invalidate the returned pointer or overwrite the string content. The returned
pointer might also be invalidated if the calling thread is terminated. If bind_textdomain_codeset() fails, a null pointer
shall be returned and errno shall be set to indicate the error.
ERRORS
For the conditions under which bindtextdomain()—if it performs pathname resolution—fails and may fail, refer to open().
In addition, the textdomain(), bindtextdomain(), and bind_textdomain_codeset() functions may fail if:
[ENOMEM]
Insufficient memory available.
The following sections are informative.
EXAMPLES
See the examples for gettext().
APPLICATION USAGE
A text domainname is limited to {TEXTDOMAIN_MAX} bytes.
Application developers are responsible for ensuring that the text domain used is not used by other applications. To minimize the
chances of collision, developers can prefix text domains with their company or application name (or both) and an underscore. For
example, if your application name was "foo" and you wanted to use the text domain "errors", you could instead use
the text domain "foo_errors". Note that if an application can be installed with a configurable name, a text domain prefix
based on the application name should change with the application name.
Specifying a relative pathname to the bindtextdomain() function should be avoided, since it may result in messages
objects being searched for in a directory relative to the current working directory of the calling process; if the process calls
the chdir() function, the directory searched for may also be changed.
Since pathname resolution of dirname might not be performed by bindtextdomain(), but could be performed later by
the gettext family of functions, and since the latter have no way to report an error, applications should verify, using for
example stat(), that the directory is accessible if this is desired.
RATIONALE
Although the return type of these functions ought to be const char *, it is char * to match historical
practice.
Pathname resolution of the dirname argument passed to bindtextdomain() may be performed by bindtextdomain()
itself or by the gettext family of functions. If pathname resolution fails in one of the gettext family of functions,
it is neither allowed to modify errno nor to return an error, but if pathname resolution fails in bindtextdomain(),
it is required to report an error and set errno just like open() does.
Historically, bindtextdomain() did not perform pathname resolution. However, the standard developers decided to allow
this as an option so that future implementations can, if desired, open a file descriptor for that directory in
bindtextdomain() and then use that file descriptor with openat() in the
gettext family of functions.
The dirname parameter to bindtextdomain() may need to be copied to avoid the possibility of the application
releasing the memory used by the argument while the gettext family of functions may still need to reference it.
When bindtextdomain() is called with a non-empty domainname and an empty dirname, historical
implementations of the gettext family of functions use the empty string for the dirname part of the messages object
pathname, resulting in an absolute pathname of the form /localename/categoryname/textdomainname.mo. The
standard developers did not believe this behavior to be useful. Using the empty dirname case as a way to remove an existing
binding seemed to be a more useful behavior, and would be consistent with the behavior of textdomain(). However, because no
historical implementations behave this way, the behavior is left unspecified.
Some implementations set errno to [EAGAIN] to signal memory allocation failures that might succeed if retried and
[ENOMEM] for failures that are unlikely to ever succeed, for example due to configured limits. 2.3 Error Numbers permits this behavior; when multiple error conditions are
simultaneously true there is no precedence between them.
FUTURE DIRECTIONS
A future version of this standard may require implementations to prefix implementation-provided text domains with either
"SYS_" or a prefix related to the implementor's company name to avoid namespace collisions.
A future version of this standard may require bindtextdomain() to remove any binding for domainname when called
with a non-empty domainname and an empty dirname.
SEE ALSO
gettext(), iconv_open(), setlocale(), uselocale()
XBD ,
XCU msgfmt, xgettext
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_attr_setguardsize.html =====
pthread_attr_getguardsize
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_attr_getguardsize, pthread_attr_setguardsize — get and set the thread guardsize attribute
SYNOPSIS
#include
int pthread_attr_getguardsize(const pthread_attr_t *restrict attr,
size_t *restrict guardsize);
int pthread_attr_setguardsize(pthread_attr_t *attr,
size_t guardsize);
DESCRIPTION
The pthread_attr_getguardsize() function shall get the guardsize attribute in the attr object. This
attribute shall be returned in the guardsize parameter.
The pthread_attr_setguardsize() function shall set the guardsize attribute in the attr object. The new
value of this attribute shall be obtained from the guardsize parameter. If guardsize is zero, a guard area shall not
be provided for threads created with attr. If guardsize is greater than zero, a guard area of at least size
guardsize bytes shall be provided for each thread created with attr.
The guardsize attribute controls the size of the guard area for the created thread's stack. The guardsize
attribute provides protection against overflow of the stack pointer. If a thread's stack is created with guard protection, the
implementation allocates extra memory at the overflow end of the stack as a buffer against stack overflow of the stack pointer. If
an application overflows into this buffer an error shall result (possibly in a SIGSEGV signal being delivered to the thread).
A conforming implementation may round up the value contained in guardsize to a multiple of the configurable system
variable {PAGESIZE} (see ). If an implementation rounds up the
value of guardsize to a multiple of {PAGESIZE}, a call to pthread_attr_getguardsize() specifying attr shall
store in the guardsize parameter the guard size specified by the previous pthread_attr_setguardsize() function
call.
The default value of the guardsize attribute is implementation-defined.
If the stackaddr attribute has been set (that is, the caller is allocating and managing its own thread stacks), the
guardsize attribute shall be ignored and no protection shall be provided by the implementation. It is the responsibility of
the application to manage stack overflow along with stack allocation and management in this case.
The behavior is undefined if the value specified by the attr argument to pthread_attr_getguardsize() or
pthread_attr_setguardsize() does not refer to an initialized thread attributes object.
RETURN VALUE
If successful, the pthread_attr_getguardsize() and pthread_attr_setguardsize() functions shall return zero;
otherwise, an error number shall be returned to indicate the error.
ERRORS
These functions shall fail if:
[EINVAL]
The parameter guardsize is invalid.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
Retrieving the guardsize Attribute
This example shows how to obtain the guardsize attribute of a thread attribute object.
#include
pthread_attr_t thread_attr;
size_t  guardsize;
int     rc;
/* code initializing thread_attr */
...
rc = pthread_attr_getguardsize (&thread_attr, &guardsize);
if (rc != 0)  {
/* handle error */
...
}
else {
if (guardsize > 0) {
/* a guard area of at least guardsize bytes is provided */
...
}
else {
/* no guard area provided */
...
}
}
APPLICATION USAGE
None.
RATIONALE
The guardsize attribute is provided to the application for two reasons:
Overflow protection can potentially result in wasted system resources. An application that creates a large number of threads,
and which knows its threads never overflow their stack, can save system resources by turning off guard areas.
When threads allocate large data structures on the stack, large guard areas may be needed to detect stack overflow.
The default size of the guard area is left implementation-defined since on systems supporting very large page sizes, the
overhead might be substantial if at least one guard page is required by default.
If an implementation detects that the value specified by the attr argument to pthread_attr_getguardsize() or
pthread_attr_setguardsize() does not refer to an initialized thread attributes object, it is recommended that the function
should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD ,
CHANGE HISTORY
First released in Issue 5.
Issue 6
In the ERRORS section, a third [EINVAL] error condition is removed as it is covered by the second error condition.
The restrict keyword is added to the pthread_attr_getguardsize() prototype for alignment with the
ISO/IEC 9899:1999 standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/74 is applied, updating the ERRORS section to remove the
[EINVAL] error ("The attribute attr is invalid."), and replacing it with the optional [EINVAL] error.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/76 is applied, adding the example to the EXAMPLES section.
Issue 7
SD5-XSH-ERN-111 is applied, removing the reference to the stack attribute in the DESCRIPTION.
SD5-XSH-ERN-175 is applied, updating the DESCRIPTION to note that the default size of the guard area is
implementation-defined.
The pthread_attr_getguardsize() and pthread_attr_setguardsize() functions are moved from the XSI option to the
Base.
The [EINVAL] error for an uninitialized thread attributes object is removed; this condition results in undefined behavior.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/lgammaf.html =====
lgamma
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
lgamma, lgammaf, lgammal, signgam — log gamma function
SYNOPSIS
#include
double lgamma(double x);
float lgammaf(float x);
long double lgammal(long double x);
[XSI]  extern int signgam;
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute
\(
\log _e \mid \Gamma(x) \mid \text { where } \Gamma(x) \text { is defined as } \int_0^{\infty} e^{-t} t^{x-1} d t \text {. }
\)
The argument \(x\) need not be a non-positive integer \( (\Gamma(x) \) is defined over the reals,
except the non-positive integers).
[XSI]
The sign of
\( \Gamma(x) \)
shall be returned in the external integer signgam. If \(x\) is NaN,
-Inf, or a negative integer, the value of signgam is unspecified.
If concurrent calls are made to these functions, the value of signgam is indeterminate.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the logarithmic gamma of \(x\).
If \(x\) is a non-positive integer, a pole error shall occur and lgamma(), lgammaf(), and lgammal()
shall return +HUGE_VAL, +HUGE_VALF, and +HUGE_VALL, respectively.
If the correct value would cause overflow, a range error shall occur and lgamma(), lgammaf(), and lgammal()
shall return ±HUGE_VAL, ±HUGE_VALF, and ±HUGE_VALL (having the same sign as the correct value), respectively.
[MX]  If
\(x\) is NaN, a NaN shall be returned.
If \(x\) is 1 or 2, +0 shall be returned.
If \(x\) is ±Inf, +Inf shall be returned.
ERRORS
These functions shall fail if:
Pole Error
The \(x\) argument is a negative integer or zero.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If
the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the divide-by-zero floating-point exception
shall be raised.
Range Error
The result overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If
the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall
be raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are
independent of each other, but at least one of them must be non-zero.
If the value of signgam will be obtained after a call to lgamma(), lgammaf(), or lgammal(), in order
to ensure that the value will not be altered by another call in a different thread, applications should either restrict calls to
these functions to be from a single thread or use a lock such as a mutex or spin lock to protect a critical section starting before
the function call and ending after the value of signgam has been obtained.
RATIONALE
Earlier versions of this standard did not require lgamma(), lgammaf(), and lgammal() to be thread-safe
because signgam was a global variable. They are now required to be thread-safe to align with the ISO C standard (which,
since the introduction of threads in 2011, requires that they avoid data races), with the exception that they need not avoid data
races when storing a value in the signgam variable. Since signgam is not specified by the ISO C standard, this
exception is not a conflict with that standard.
FUTURE DIRECTIONS
None.
SEE ALSO
exp, feclearexcept, fetestexcept, isnan
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 3.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
A note indicating that this function need not be reentrant is added to the DESCRIPTION.
Issue 6
The lgamma() function is no longer marked as an extension.
The lgammaf() and lgammal() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Functionality relating to the XSI option is marked.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
The DESCRIPTION is clarified regarding the value of signgam when \(x\) is Nan, -Inf, or a negative integer.
Issue 8
Austin Group Defect 1002 is applied, reinstating the requirement for the sign of \( \Gamma(x) \) to be
returned in signgam, which had been accidentally removed in Issue 7.
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sigsetjmp.html =====
sigsetjmp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sigsetjmp — set jump point for a non-local goto
SYNOPSIS
[CX]  #include
int sigsetjmp(sigjmp_buf env, int savemask);
DESCRIPTION
The sigsetjmp() function shall be equivalent to the setjmp() function,
except as follows:
References to setjmp() are equivalent to sigsetjmp().
References to longjmp() are equivalent to siglongjmp().
If the value of the savemask argument is not 0, sigsetjmp() shall also save the current signal mask of the calling
thread as part of the calling environment.
RETURN VALUE
If the return is from a successful direct invocation, sigsetjmp() shall return 0. If the return is from a call to
siglongjmp(), sigsetjmp() shall return a non-zero value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The distinction between setjmp()/longjmp() and sigsetjmp()/siglongjmp() is only significant for programs which use sigaction(), sigprocmask(), or sigsuspend().
Note that since this function is defined in terms of setjmp(), if savemask
is zero, it is unspecified whether the signal mask is saved.
RATIONALE
The ISO C standard specifies various restrictions on the usage of the setjmp() macro in order to permit implementors to recognize the name in the compiler and not
implement an actual function. These same restrictions apply to the sigsetjmp() macro.
There are processors that cannot easily support these calls, but this was not considered a sufficient reason to exclude
them.
4.2 BSD and 4.3 BSD provided functions named _setjmp() and _longjmp() that, together with setjmp() and longjmp(), provided the same
functionality as sigsetjmp() and siglongjmp(). On those systems, setjmp() and longjmp() saved and restored
signal masks, while _setjmp() and _longjmp() did not. On System V Release 3 and in corresponding issues of the SVID,
setjmp() and longjmp() were explicitly
defined not to save and restore signal masks. In order to permit existing practice in both cases, the relation of setjmp() and longjmp() to signal masks is not
specified, and a new set of functions is defined instead.
The longjmp() and siglongjmp()
functions operate as in the previous issue provided the matching setjmp() or
sigsetjmp() has been performed in the same thread. Non-local jumps into contexts saved by other threads would be at best a
questionable practice and were not considered worthy of standardization.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_sigmask(), siglongjmp(), signal(), sigsuspend()
XBD
CHANGE HISTORY
First released in Issue 3. Included for alignment with the POSIX.1-1988 standard.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Threads Extension.
Issue 6
The DESCRIPTION is reworded in terms of setjmp().
The SYNOPSIS is marked CX since the presence of this function in the  header is an extension over the ISO C standard.
Issue 8
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/gmtime_r.html =====
gmtime
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
gmtime, gmtime_r — convert a time value to a broken-down UTC time
SYNOPSIS
#include
struct tm *gmtime(const time_t *timer);
[CX]  struct tm *gmtime_r(const time_t *restrict timer,
struct tm *restrict result);
DESCRIPTION
For gmtime(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The gmtime() function shall convert the time in seconds since the Epoch pointed to by timer into a broken-down
time, expressed as Coordinated Universal Time (UTC).
[CX]  The
relationship between a time in seconds since the Epoch used as an argument to gmtime() and the tm structure (defined
in the  header) is that the result shall be as specified in the
expression given in the definition of seconds since the Epoch (see XBD 4.19
Seconds Since the Epoch), where the names in the structure and in the expression correspond.
The same relationship shall apply for gmtime_r().
The gmtime() function need not be thread-safe; however, gmtime() shall avoid data races with all functions other
than itself, asctime(), ctime(), and
localtime().
The asctime(), ctime(),
gmtime(), and localtime() functions shall return values in one of two
static objects: a broken-down time structure and an array of type char. Execution of any of the functions that return a
pointer to one of these object types may overwrite the information in any object of the same type pointed to by the value returned
from any previous call to any of them.
[CX]  The
gmtime_r() function shall convert the time in seconds since the Epoch pointed to by timer into a broken-down time
expressed as Coordinated Universal Time (UTC). The broken-down time is stored in the structure referred to by result. The
gmtime_r() function shall also return the address of the same structure.
RETURN VALUE
Upon successful completion, the gmtime() function shall return a pointer to a struct tm. If an error is detected,
gmtime() shall return a null pointer [CX]   and set errno to indicate the error.
Upon successful completion, gmtime_r() shall return the address of the structure pointed to by the argument
result. The structure's tm_zone member shall be set to a pointer to the string "UTC", which shall have
static storage duration. If an error is detected, gmtime_r() shall return a null pointer and set errno to indicate
the error.
ERRORS
The gmtime() [CX]   and gmtime_r()
functions shall fail if:
[EOVERFLOW]
[CX]
The result cannot be represented.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The gmtime_r() function is thread-safe and returns values in a user-supplied buffer instead of possibly using a static
data area that may be overwritten by each call.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
asctime(), clock(), ctime(), difftime(), futimens(), localtime(), mktime(), strftime(), strptime(), time()
XBD 4.19 Seconds Since the Epoch,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
A note indicating that the gmtime() function need not be reentrant is added to the DESCRIPTION.
The gmtime_r() function is included for alignment with the POSIX Threads Extension.
Issue 6
The gmtime_r() function is marked as part of the Thread-Safe Functions option.
Extensions beyond the ISO C standard are marked.
The APPLICATION USAGE section is updated to include a note on the thread-safe function and its avoidance of possibly using a
static data area.
The restrict keyword is added to the gmtime_r() prototype for alignment with the ISO/IEC 9899:1999
standard.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/27 is applied, adding the [EOVERFLOW] error.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/48 is applied, updating the error handling for
gmtime_r().
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
The gmtime_r() function is moved from the Thread-Safe Functions option to the Base.
Issue 8
Austin Group Defect 1302 is applied, aligning the gmtime() function with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1376 is applied, removing CX shading from some text derived from the ISO C standard and updating it to
match the ISO C standard.
Austin Group Defect 1533 is applied, adding tm_gmtoff and tm_zone to the tm structure.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/timer_getoverrun.html =====
timer_getoverrun
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
timer_getoverrun, timer_gettime, timer_settime — per-process timers
SYNOPSIS
[CX]  #include
int timer_getoverrun(timer_t timerid);
int timer_gettime(timer_t timerid, struct itimerspec *value);
int timer_settime(timer_t timerid, int flags,
const struct itimerspec *restrict value,
struct itimerspec *restrict ovalue);
DESCRIPTION
The timer_gettime() function shall store the amount of time until the specified timer, timerid, expires and the
reload value of the timer into the space pointed to by the value argument. The it_value member of this structure
shall contain the amount of time before the timer expires, or zero if the timer is disarmed. This value is returned as the interval
until timer expiration, even if the timer was armed with absolute time. The it_interval member of value shall contain
the reload value last set by timer_settime().
The timer_settime() function shall set the time until the next expiration of the timer specified by timerid from
the it_value member of the value argument and arm the timer if the it_value member of value is
non-zero. If the specified timer was already armed when timer_settime() is called, this call shall reset the time until next
expiration to the value specified. If the it_value member of value is zero, the timer shall be disarmed. The
effect of disarming or resetting a timer with pending expiration notifications is unspecified.
If the flag TIMER_ABSTIME is not set in the argument flags, timer_settime() shall behave as if the time until next
expiration is set to be equal to the interval specified by the it_value member of value. That is, the timer shall
expire in it_value nanoseconds from when the call is made. If the flag TIMER_ABSTIME is set in the argument flags,
timer_settime() shall behave as if the time until next expiration is set to be equal to the difference between the absolute
time specified by the it_value member of value and the current value of the clock associated with timerid.
That is, the timer shall expire when the clock reaches the value specified by the it_value member of value. If the
specified time has already passed, the function shall succeed and the expiration notification shall be made.
The reload value of the timer shall be set to the value specified by the it_interval member of value. When a timer
is armed with a non-zero it_interval, a periodic (or repetitive) timer is specified.
Time values that are between two consecutive non-negative integer multiples of the resolution of the specified timer shall be
rounded up to the larger multiple of the resolution. Quantization error shall not cause the timer to expire earlier than the
rounded time value.
If the argument ovalue is not NULL, the timer_settime() function shall store, in the location referenced by
ovalue, a value representing the previous amount of time before the timer would have expired, or zero if the timer was
disarmed, together with the previous timer reload value. Timers shall not expire before their scheduled time.
Only a single signal shall be queued to the process for a given timer at any point in time. When a timer for which a signal is
still pending expires, no signal shall be queued, and a timer overrun shall occur. When a timer expiration signal is delivered to
or accepted by a process, the timer_getoverrun() function shall return the timer expiration overrun count for the specified
timer. The overrun count returned contains the number of extra timer expirations that occurred between the time the signal was
generated (queued) and when it was delivered or accepted, up to but not including an implementation-defined maximum of
{DELAYTIMER_MAX}. If the number of such extra expirations is greater than or equal to {DELAYTIMER_MAX}, then the overrun count
shall be set to {DELAYTIMER_MAX}. The value returned by timer_getoverrun() shall apply to the most recent expiration signal
delivery or acceptance for the timer. If no expiration signal has been delivered for the timer, the return value of
timer_getoverrun() is unspecified.
The behavior is undefined if the value specified by the timerid argument to timer_getoverrun(),
timer_gettime(), or timer_settime() does not correspond to a timer ID returned by timer_create() but not yet deleted by timer_delete().
RETURN VALUE
If the timer_getoverrun() function succeeds, it shall return the timer expiration overrun count as explained above.
If the timer_gettime() or timer_settime() functions succeed, a value of 0 shall be returned.
If an error occurs for any of these functions, the value -1 shall be returned, and errno set to indicate the error.
ERRORS
The timer_settime() function shall fail if:
[EINVAL]
A value structure specified a nanosecond value less than zero or greater than or equal to 1000 million, and the
it_value member of that structure did not specify zero seconds and nanoseconds.
The timer_settime() function may fail if:
[EINVAL]
The it_interval member of value is not zero and the timer was created with notification by creation of a new
thread (sigev_sigev_notify was SIGEV_THREAD) and a fixed stack address has been set in the thread attribute pointed to by
sigev_notify_attributes.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Using fixed stack addresses is problematic when timer expiration is signaled by the creation of a new thread. Since it cannot be
assumed that the thread created for one expiration is finished before the next expiration of the timer, it could happen that two
threads use the same memory as a stack at the same time. This is invalid and produces undefined results.
RATIONALE
Practical clocks tick at a finite rate, with rates of 100 hertz and 1000 hertz being common. The inverse of this tick rate is
the clock resolution, also called the clock granularity, which in either case is expressed as a time duration, being 10
milliseconds and 1 millisecond respectively for these common rates. The granularity of practical clocks implies that if one reads a
given clock twice in rapid succession, one may get the same time value twice; and that timers must wait for the next clock tick
after the theoretical expiration time, to ensure that a timer never returns too soon. Note also that the granularity of the clock
may be significantly coarser than the resolution of the data format used to set and get time and interval values. Also note that
some implementations may choose to adjust time and/or interval values to exactly match the ticks of the underlying clock.
This volume of POSIX.1-2024 defines functions that allow an application to determine the implementation-supported resolution for
the clocks and requires an implementation to document the resolution supported for timers and nanosleep() if they differ from the supported clock resolution. This is more of a
procurement issue than a runtime application issue.
If an implementation detects that the value specified by the timerid argument to timer_getoverrun(),
timer_gettime(), or timer_settime() does not correspond to a timer ID returned by timer_create() but not yet deleted by timer_delete(), it is recommended that the function should fail and report an [EINVAL]
error.
FUTURE DIRECTIONS
None.
SEE ALSO
clock_getres(), timer_create()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The timer_getoverrun(), timer_gettime(), and timer_settime() functions are marked as part of the Timers
option.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Timers
option.
The [EINVAL] error condition is updated to include the following: "and the it_value member of that structure did not
specify zero seconds and nanoseconds." This change is for IEEE PASC Interpretation 1003.1 #89.
The DESCRIPTION for timer_getoverrun() is updated to clarify that "If no expiration signal has been delivered for the
timer, or if the Realtime Signals Extension is not supported, the return value of timer_getoverrun() is unspecified".
The restrict keyword is added to the timer_settime() prototype for alignment with the ISO/IEC 9899:1999
standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/140 is applied, updating the ERRORS section so that the
mandatory [EINVAL] error ("The timerid argument does not correspond to an ID returned by timer_create() but not yet deleted by timer_delete()") becomes optional.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/141 is applied, updating the ERRORS section to include an
optional [EINVAL] error for the case when a timer is created with the notification method set to SIGEV_THREAD. APPLICATION USAGE
text is also added.
Issue 7
The timer_getoverrun(), timer_gettime(), and timer_settime() functions are moved from the Timers option to
the Base.
Functionality relating to the Realtime Signals Extension option is moved to the Base.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0370 [659] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/tolower.html =====
tolower
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
tolower, tolower_l — transliterate uppercase characters to lowercase
SYNOPSIS
#include
int tolower(int c);
[CX]  int tolower_l(int c, locale_t locale);
DESCRIPTION
For tolower(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The tolower() [CX]   and tolower_l()
functions have as a domain a type int, the value of which is representable as an unsigned char or the value of
EOF. If the argument has any other value, the behavior is undefined. If the argument of tolower() [CX]   or
tolower_l()   represents an uppercase letter, and there
exists a corresponding lowercase letter as defined by character type information in the current locale [CX]   or in the
locale represented by locale,   respectively (category
LC_CTYPE ), the result shall be the corresponding lowercase letter. All other arguments in the domain are returned
unchanged.
[CX]  The
behavior is undefined if the locale argument to tolower_l() is the special locale object LC_GLOBAL_LOCALE or is not a
valid locale object handle.
RETURN VALUE
Upon successful completion, the tolower() [CX]   and tolower_l()   functions shall return the lowercase letter corresponding to the argument passed; otherwise, they
shall return the argument unchanged.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
setlocale(), uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
Extensions beyond the ISO C standard are marked.
Issue 7
The tolower_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0671 [283] and XSH/TC1-2008/0672 [283] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getpeername.html =====
getpeername
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getpeername — get the name of the peer socket
SYNOPSIS
#include
int getpeername(int socket, struct sockaddr *restrict address,
socklen_t *restrict address_len);
DESCRIPTION
The getpeername() function shall retrieve the peer address of the specified socket, store this address in the
sockaddr structure pointed to by the address argument, and store the length of this address in the object pointed to
by the address_len argument.
The address_len argument points to a socklen_t object which on input specifies the length of the supplied
sockaddr structure, and on output specifies the length of the peer address. If the actual length of the address is greater
than the length of the supplied sockaddr structure, the stored address shall be truncated.
If the protocol permits connections by unbound clients, and the peer is not bound, then the value stored in the object pointed
to by address is unspecified.
RETURN VALUE
Upon successful completion, 0 shall be returned. Otherwise, -1 shall be returned and errno set to indicate the error.
ERRORS
The getpeername() function shall fail if:
[EBADF]
The socket argument is not a valid file descriptor.
[EINVAL]
The socket has been shut down.
[ENOTCONN]
The socket is not connected or otherwise has not had the peer pre-specified.
[ENOTSOCK]
The socket argument does not refer to a socket.
[EOPNOTSUPP]
The operation is not supported for the socket protocol.
The getpeername() function may fail if:
[ENOBUFS]
Insufficient resources were available in the system to complete the call.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
For AF_UNIX sockets, it is recommended that address points to a buffer of length greater than sizeof(struct
sockaddr_un) which has been initialized with null bytes. That way, even if the implementation supports the use of all bytes of
sun_path without a terminating null byte, the larger buffer guarantees that the sun_path member can then be passed to
other interfaces that expect a null-terminated string. If no truncation occurred based on the input value of address_len, it
is unspecified whether the returned address_len will be sizeof(struct sockaddr_un), or merely a value at least as
large as offsetof(struct sockaddr_un, sun_path) plus the number of non-null bytes stored in sun_path.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
accept(), bind(), getsockname(), socket()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
The restrict keyword is added to the getpeername() prototype for alignment with the ISO/IEC 9899:1999
standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0254 [464] is applied.
Issue 8
Austin Group Defect 561 is applied, adding a paragraph about sun_path to APPLICATION USAGE.
Austin Group Defect 1565 is applied, changing the description of address_len.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mtx_timedlock.html =====
mtx_lock
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mtx_lock, mtx_timedlock, mtx_trylock, mtx_unlock — lock and unlock a mutex
SYNOPSIS
#include
int mtx_lock(mtx_t *mtx);
int mtx_timedlock(mtx_t *restrict mtx,
const struct timespec *restrict ts);
int mtx_trylock(mtx_t *mtx);
int mtx_unlock(mtx_t *mtx);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The mtx_lock() function shall block until it locks the mutex pointed to by mtx. If the mutex is non-recursive, the
application shall ensure that it is not already locked by the calling thread.
The mtx_timedlock() function shall block until it locks the mutex pointed to by mtx or until after the
TIME_UTC-based calendar time pointed to by ts. The application shall ensure that the specified mutex supports timeout.
[CX]  Under
no circumstance shall the function fail with a timeout if the mutex can be locked immediately. The validity of the ts
parameter need not be checked if the mutex can be locked immediately.
The mtx_trylock() function shall endeavor to lock the mutex pointed to by mtx. If the mutex is already locked (by
any thread, including the current thread), the function shall return without blocking. If the mutex is recursive and the mutex is
currently owned by the calling thread, the mutex lock count (see below) shall be incremented by one and the mtx_trylock()
function shall immediately return success.
[CX]
These functions shall not be affected if the calling thread executes a signal handler during the call; if a signal is delivered to
a thread waiting for a mutex, upon return from the signal handler the thread shall resume waiting for the mutex as if it was not
interrupted.
If a call to mtx_lock(), mtx_timedlock() or mtx_trylock() locks the mutex, prior calls to
mtx_unlock() on the same mutex shall synchronize with this lock operation.
The mtx_unlock() function shall unlock the mutex pointed to by mtx. The application shall ensure that the mutex
pointed to by mtx is locked by the calling thread. [CX]   If there are threads blocked on the mutex object referenced by
mtx when mtx_unlock() is called, resulting in the mutex becoming available, the scheduling policy shall determine
which thread shall acquire the mutex.
A recursive mutex shall maintain the concept of a lock count. When a thread successfully acquires a mutex for the first time,
the lock count shall be set to one. Every time a thread relocks this mutex, the lock count shall be incremented by one. Each time
the thread unlocks the mutex, the lock count shall be decremented by one. When the lock count reaches zero, the mutex shall become
available for other threads to acquire.
For purposes of determining the existence of a data race, mutex lock and unlock operations on mutexes of type mtx_t
behave as atomic operations. All lock and unlock operations on a particular mutex occur in some particular total order.
If mtx does not refer to an initialized mutex object, the behavior of these functions is undefined.
RETURN VALUE
The mtx_lock() and mtx_unlock() functions shall return thrd_success on success, or thrd_error if
the request could not be honored.
The mtx_timedlock() function shall return thrd_success on success, or thrd_timedout if the time
specified was reached without acquiring the requested resource, or thrd_error if the request could not be honored.
The mtx_trylock() function shall return thrd_success on success, or thrd_busy if the resource requested
is already in use, or thrd_error if the request could not be honored. The mtx_trylock() function can spuriously
fail to lock an unused resource, in which case it shall return thrd_busy.
ERRORS
See RETURN VALUE.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
These functions are not affected by signal handlers for the reasons stated in XRAT B.2.3 Error Numbers.
Since  has no equivalent of the mtx_timed mutex
property, if the  interfaces are implemented as a thin wrapper
around  interfaces (meaning mtx_t and
pthread_mutex_t are the same type), all mutexes support timeout and mtx_timedlock() will not fail for a mutex that
was not initialized with mtx_timed. Alternatively, implementations can use a less thin wrapper where mtx_t contains
additional properties that are not held in pthread_mutex_t in order to be able to return a failure indication from
mtx_timedlock() calls where the mutex was not initialized with mtx_timed.
FUTURE DIRECTIONS
None.
SEE ALSO
mtx_destroy(), timespec_get()
XBD
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/expl.html =====
exp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
exp, expf, expl — exponential function
SYNOPSIS
#include
double exp(double x);
float expf(float x);
long double expl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the base-e exponential of x.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the exponential value of x.
If the correct value would cause overflow, a range error shall occur and exp(), expf(), and expl() shall
return the value of the macro HUGE_VAL, HUGE_VALF, and HUGE_VALL, respectively.
If the correct value would cause underflow, [MXX]   and is not representable,  a range error may occur, and exp(), expf(), and expl() shall return [MXX]   0.0, or
(if the IEC 60559 Floating-Point option is not supported) an
implementation-defined value no greater in magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, 1 shall be returned.
If x is -Inf, +0 shall be returned.
If x is +Inf, x shall be returned.
[MXX]
If the correct value would cause underflow, and is representable, a range error may occur and the correct value shall be returned.
ERRORS
These functions shall fail if:
Range Error
The result overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
These functions may fail if:
Range Error
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
Computing the Density of the Standard Normal Distribution
This function shows an implementation for the density of the standard normal distribution using exp(). This example uses
the constant M_PI which is part of the XSI option.
#include
double
normal_density (double x)
{
return exp(-x*x/2) / sqrt (2*M_PI);
}
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), isnan(), log()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The expf() and expl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/26 is applied, adding the example to the EXAMPLES section.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0106 [68] and XSH/TC1-2008/0107 [68] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0101 [630] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/hypotl.html =====
hypot
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
hypot, hypotf, hypotl — Euclidean distance function
SYNOPSIS
#include
double hypot(double x, double y);
float hypotf(float x, float y);
long double hypotl(long double x, long double y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the value of the square root of
x2+y2 without undue overflow or underflow.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the length of the hypotenuse of a right-angled triangle with sides of
length x and y.
If the correct value would cause overflow, a range error shall occur and hypot(), hypotf(), and hypotl()
shall return the value of the macro HUGE_VAL, HUGE_VALF, and HUGE_VALL, respectively.
[MX]  If
x or y is ±Inf, +Inf shall be returned (even if one of x or y is NaN).
If x or y is NaN, and the other is not ±Inf, a NaN shall be returned.
[MXX]
If both arguments are subnormal and the correct result is subnormal, a range error may occur and the correct result shall be
returned.
ERRORS
These functions shall fail if:
Range Error
The result overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
These functions may fail if:
Range Error
[MX]
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
See the EXAMPLES section in atan2().
APPLICATION USAGE
hypot(x,y), hypot(y,x), and hypot(x, -y) are equivalent.
hypot(x, ±0) is equivalent to fabs(x).
Underflow only happens when both x and y are subnormal and the (inexact) result is also subnormal.
These functions take precautions against overflow during intermediate steps of the computation.
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
atan2(), feclearexcept(),
fetestexcept(), isnan(),
sqrt()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The hypot() function is no longer marked as an extension.
The hypotf() and hypotl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/49 is applied, updating the EXAMPLES section.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0273 [68] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strcat.html =====
strcat
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strcat — concatenate two strings
SYNOPSIS
#include
char *strcat(char *restrict s1, const char *restrict s2);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The strcat() function shall append a copy of the string pointed to by s2 (including the terminating NUL character)
to the end of the string pointed to by s1. The initial byte of s2 overwrites the NUL character at the end of
s1. If copying takes place between objects that overlap, the behavior is undefined.
[CX]  The
strcat() function shall not change the setting of errno on valid input.
RETURN VALUE
The strcat() function shall return s1; no return value is reserved to indicate an error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
This version is aligned with the ISO C standard; this does not affect compatibility with XPG3 applications. Reliable error
detection by this function was never guaranteed.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
strncat()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The strcat() prototype is updated for alignment with the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that strcat() does not change the setting of errno on
valid input.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/msgget.html =====
msgget
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
msgget — get the XSI message queue identifier
SYNOPSIS
[XSI]  #include
int msgget(key_t key, int msgflg);
DESCRIPTION
The msgget() function operates on XSI message queues (see XBD 3.206
Message Queue). It is unspecified whether this function interoperates with the realtime interprocess communication
facilities defined in 2.8 Realtime.
The msgget() function shall return the message queue identifier associated with the argument key.
A message queue identifier, associated message queue, and data structure (see ), shall be created for the argument key if one of the following is
true:
The argument key is equal to IPC_PRIVATE.
The argument key does not already have a message queue identifier associated with it, and (msgflg & IPC_CREAT) is
non-zero.
Upon creation, the data structure associated with the new message queue identifier shall be initialized as follows:
msg_perm.cuid, msg_perm.uid, msg_perm.cgid, and msg_perm.gid shall be set to the effective user ID
and effective group ID, respectively, of the calling process.
The low-order 9 bits of msg_perm.mode shall be set to the low-order 9 bits of msgflg.
msg_qnum, msg_lspid, msg_lrpid, msg_stime, and msg_rtime shall be set to 0.
msg_ctime shall be set to the current time, as described in 2.7.1
IPC General Description.
msg_qbytes shall be set to the system limit.
RETURN VALUE
Upon successful completion, msgget() shall return a non-negative integer, namely a message queue identifier. Otherwise,
it shall return -1 and set errno to indicate the error.
ERRORS
The msgget() function shall fail if:
[EACCES]
A message queue identifier exists for the argument key, but operation permission as specified by the low-order 9 bits of
msgflg would not be granted; see 2.7 XSI Interprocess
Communication.
[EEXIST]
A message queue identifier exists for the argument key but ((msgflg & IPC_CREAT) && (msgflg &
IPC_EXCL)) is non-zero.
[ENOENT]
A message queue identifier does not exist for the argument key and (msgflg & IPC_CREAT) is 0.
[ENOSPC]
A message queue identifier is to be created but the system-imposed limit on the maximum number of allowed message queue
identifiers system-wide would be exceeded.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The POSIX Realtime Extension defines alternative interfaces for interprocess communication (IPC). Application developers who
need to use IPC should design their applications so that modules using the IPC routines described in 2.7 XSI Interprocess Communication can be easily modified to use the alternative
interfaces.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.7 XSI Interprocess Communication, 2.8 Realtime, ftok(), mq_close(), mq_getattr(), mq_notify(), mq_open(), mq_receive(), mq_send(), mq_setattr(), mq_unlink(), msgctl(), msgrcv(), msgsnd()
XBD 3.206 Message Queue,
CHANGE HISTORY
First released in Issue 2. Derived from Issue 2 of the SVID.
Issue 5
The note about use of POSIX Realtime Extension IPC routines has been moved from FUTURE DIRECTIONS to a new APPLICATION USAGE
section.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0396 [345] and XSH/TC1-2008/0397 [344] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strftime_l.html =====
strftime
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strftime, strftime_l — convert date and time to a string
SYNOPSIS
#include
size_t strftime(char *restrict s, size_t maxsize,
const char *restrict format, const struct tm *restrict
timeptr);
[CX]  size_t strftime_l(char *restrict s, size_t maxsize,
const char *restrict format, const struct tm *restrict
timeptr,
locale_t locale);
DESCRIPTION
For strftime(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The strftime() function shall place bytes into the array pointed to by s as controlled by the string pointed to by
format. The application shall ensure that the format is a character string, beginning and ending in its initial shift state,
if any. The format string consists of zero or more conversion specifications and ordinary characters.
Each conversion specification is introduced by the '%' character after which the following appear in sequence:
[CX]  An
optional flag:
0
The zero character ('0'), which specifies that the character used as the padding character is '0',
+
The  character ('+'), which specifies that the character used as the padding character is
'0', and that if and only if the field being produced consumes more than four bytes to represent a year (for %F,
%G, or %Y) or more than two bytes to represent the year divided by 100 (for %C) then a leading
character shall be included if the year being processed is greater than or equal to zero or a leading
character ('-') shall be included if the year is less than zero.
The default padding character is unspecified.
An optional minimum field width. If the converted value, including any leading '+' or '-' sign, has fewer
bytes than the minimum field width and the padding character is not the NUL character, the output shall be padded on the left
(after any leading '+' or '-' sign) with the padding character.
An optional E or O modifier.
A terminating conversion specifier character that indicates the type of conversion to be applied.
[CX]  The
results are unspecified if more than one flag character is specified, a flag character is specified without a minimum field width;
a minimum field width is specified without a flag character; a modifier is specified with a flag or with a minimum field width; or
if a minimum field width is specified for any conversion specifier other than C, F, G, or Y.
All ordinary characters (including the terminating NUL character) are copied unchanged into the array. If copying takes place
between objects that overlap, the behavior is undefined. No more than maxsize bytes are placed into the array. Each
conversion specifier is replaced by appropriate characters as described in the following list. The appropriate characters are
determined using the LC_TIME category of the current locale and by the values of zero or more members of the broken-down
time structure pointed to by timeptr, as specified in brackets in the description. If any of the specified values are
outside the normal range, the characters stored are unspecified.
[CX]  The
strftime_l() function shall be equivalent to the strftime() function, except that the locale data used is from the
locale represented by locale.
Local timezone information shall be set as though strftime() called tzset().
The following conversion specifiers shall be supported:
a
Replaced by the locale's abbreviated weekday name. [tm_wday]
A
Replaced by the locale's full weekday name. [tm_wday]
b
Replaced by the locale's abbreviated month name. [tm_mon]
B
Replaced by the locale's full month name. [tm_mon]
c
Replaced by the locale's appropriate date and time representation. (See the Base Definitions volume of POSIX.1-2024, .)
C
Replaced by the year divided by 100 and truncated to an integer, as a decimal number. [tm_year]
If a minimum field width is not specified:
If the year is between 0 and 9999 inclusive, two characters shall be placed into the array pointed to by s, including a
leading '0' if there would otherwise be only a single digit.
[CX]  If
the year is less than 0 or greater than 9999, the number of characters placed into the array pointed to by s shall be the
number of digits and leading sign characters (if any) in the result of dividing the year by 100 and truncating, or two, whichever
is greater.
[CX]  If
a minimum field width is specified, the number of characters placed into the array pointed to by s shall be the number of
digits and leading sign characters (if any) in the result of dividing the year by 100 and truncating, or the minimum field width,
whichever is greater.
d
Replaced by the day of the month as a decimal number [01,31]. [tm_mday]
D
Equivalent to %m/%d/%y. [tm_mon, tm_mday, tm_year]
e
Replaced by the day of the month as a decimal number [1,31]; a single digit is preceded by a space. [tm_mday]
F
Equivalent to %Y-%m-%d if no flag and no minimum field width are specified. (For years between 1000 and 9999 inclusive this
provides the ISO 8601:2019 standard complete representation, extended format date representation of a specific day.)
[tm_year, tm_mon, tm_mday]
[CX]  If
a minimum field width of x is specified, the year shall be output as if by the Y specifier (described below) with
whatever flag was given and a minimum field width of x-6. If x is less than 6, the behavior shall be as if x
equalled 6.
If the minimum field width is specified to be 10, and the year is four digits long, then the output string produced shall match
the ISO 8601:2019 standard subclause 4.1.2.2 complete representation, extended format date representation of a specific day.
If a + flag is specified, a minimum field width of x is specified, and x-7 bytes are sufficient to hold the digits of
the year (not including any needed sign character), then the output shall match the ISO 8601:2019 standard subclause 4.1.2.4
complete representation, expanded format date representation of a specific day.
g
Replaced by the last 2 digits of the week-based year (see below) as a decimal number [00,99]. [tm_year, tm_wday,
tm_yday]
G
Replaced by the week-based year (see below) as a decimal number (for example, 1977). [tm_year, tm_wday,
tm_yday]
[CX]  If
a minimum field width is specified, the number of characters placed into the array pointed to by s shall be the number of
digits and leading sign characters (if any) in the year, or the minimum field width, whichever is greater.
h
Equivalent to %b. [tm_mon]
H
Replaced by the hour (24-hour clock) as a decimal number [00,23]. [tm_hour]
I
Replaced by the hour (12-hour clock) as a decimal number [01,12]. [tm_hour]
j
Replaced by the day of the year as a decimal number [001,366]. [tm_yday]
m
Replaced by the month as a decimal number [01,12]. [tm_mon]
M
Replaced by the minute as a decimal number [00,59]. [tm_min]
n
Replaced by a .
p
Replaced by the locale's equivalent of either a.m. or p.m. [tm_hour]
r
Replaced by the time in 12-hour clock notation; [CX]   if the 12-hour format is not supported in the locale, this shall
be either an empty string or the time in a 24-hour clock notation. In the POSIX locale this shall be equivalent to
%I:%M:%S %p.  [tm_hour,
tm_min, tm_sec]
R
Replaced by the time in 24-hour notation (%H:%M). [tm_hour, tm_min]
s
[CX]
Replaced by the number of seconds since the Epoch as a decimal number, calculated as described for mktime(). [tm_year, tm_mon, tm_mday, tm_hour, tm_min,
tm_sec, tm_isdst]
S
Replaced by the second as a decimal number [00,60]. [tm_sec]
t
Replaced by a .
T
Replaced by the time (%H:%M:%S). [tm_hour, tm_min, tm_sec]
u
Replaced by the weekday as a decimal number [1,7], with 1 representing Monday. [tm_wday]
U
Replaced by the week number of the year as a decimal number [00,53]. The first Sunday of January is the first day of week 1;
days in the new year before this are in week 0. [tm_year, tm_wday, tm_yday]
V
Replaced by the week number of the year (Monday as the first day of the week) as a decimal number [01,53]. If the week
containing 1 January has four or more days in the new year, then it is considered week 1. Otherwise, it is the last week of the
previous year, and the next week is week 1. Both January 4th and the first Thursday of January are always in week 1.
[tm_year, tm_wday, tm_yday]
w
Replaced by the weekday as a decimal number [0,6], with 0 representing Sunday. [tm_wday]
W
Replaced by the week number of the year as a decimal number [00,53]. The first Monday of January is the first day of week 1;
days in the new year before this are in week 0. [tm_year, tm_wday, tm_yday]
x
Replaced by the locale's appropriate date representation. (See the Base Definitions volume of POSIX.1-2024, .)
X
Replaced by the locale's appropriate time representation. (See the Base Definitions volume of POSIX.1-2024, .)
y
Replaced by the last two digits of the year as a decimal number [00,99]. [tm_year]
Y
Replaced by the year as a decimal number (for example, 1997). [tm_year]
[CX]  If
a minimum field width is specified, the number of characters placed into the array pointed to by s shall be the number of
digits and leading sign characters (if any) in the year, or the minimum field width, whichever is greater.
z
Replaced by the offset from UTC in the ISO 8601:2019 standard format (+hhmm or -hhmm), or by no
characters if no timezone is determinable. For example, "-0430" means 4 hours 30 minutes behind UTC (west of Greenwich).
[CX]
If tm_isdst is zero, the standard time offset is used. If tm_isdst is greater than zero, the daylight saving
time offset is used. If tm_isdst is negative, no characters are returned.
[tm_isdst, [CX]  tm_gmtoff  ]
Z
Replaced by the timezone name or abbreviation, or by no bytes if no timezone information exists. [tm_isdst,
[CX]
tm_zone  ]
%
Replaced by %.
If a conversion specification does not correspond to any of the above, the behavior is undefined.
[CX]  If
a struct tm broken-down time structure is created by localtime() or
localtime_r(), or modified by mktime(), and the value of TZ is subsequently modified, the results of the %Z
and %z strftime() conversion specifiers are undefined, when strftime() is called with such a broken-down
time structure.
If a struct tm broken-down time structure is created or modified by gmtime() or gmtime_r(), it is unspecified
whether the result of the %Z and %z conversion specifiers shall refer to UTC or the current local timezone, when
strftime() is called with such a broken-down time structure.
Modified Conversion Specifiers
Some conversion specifiers can be modified by the E or O modifier characters to indicate that an alternative
format or specification should be used rather than the one normally used by the unmodified conversion specifier. If the alternative
format or specification does not exist for the current locale (see ERA in XBD 7.3.5 LC_TIME), the behavior shall be as if the unmodified conversion
specification were used.
%Ec
Replaced by the locale's alternative appropriate date and time representation.
%EC
Replaced by the name of the base year (period) in the locale's alternative representation.
%Ex
Replaced by the locale's alternative date representation.
%EX
Replaced by the locale's alternative time representation.
%Ey
Replaced by the offset from %EC (year only) in the locale's alternative representation.
%EY
Replaced by the full alternative year representation.
%Ob
[CX]
Replaced by the locale's abbreviated alternative month name.
%OB
[CX]
Replaced by the locale's alternative appropriate full month name.
%Od
Replaced by the day of the month, using the locale's alternative numeric symbols, filled as needed with leading zeros if there
is any alternative symbol for zero; otherwise, with leading  characters.
%Oe
Replaced by the day of the month, using the locale's alternative numeric symbols, filled as needed with leading
characters.
%OH
Replaced by the hour (24-hour clock) using the locale's alternative numeric symbols.
%OI
Replaced by the hour (12-hour clock) using the locale's alternative numeric symbols.
%Om
Replaced by the month using the locale's alternative numeric symbols.
%OM
Replaced by the minutes using the locale's alternative numeric symbols.
%OS
Replaced by the seconds using the locale's alternative numeric symbols.
%Ou
Replaced by the weekday as a number in the locale's alternative representation (Monday=1).
%OU
Replaced by the week number of the year (Sunday as the first day of the week, rules corresponding to %U) using the
locale's alternative numeric symbols.
%OV
Replaced by the week number of the year (Monday as the first day of the week, rules corresponding to %V) using the
locale's alternative numeric symbols.
%Ow
Replaced by the number of the weekday (Sunday=0) using the locale's alternative numeric symbols.
%OW
Replaced by the week number of the year (Monday as the first day of the week) using the locale's alternative numeric
symbols.
%Oy
Replaced by the year (offset from %C) using the locale's alternative numeric symbols.
%g, %G, and %V give values according to the ISO 8601:2019 standard week-based year. In this
system, weeks begin on a Monday and week 1 of the year is the week that includes January 4th, which is also the week that includes
the first Thursday of the year, and is also the first week that contains at least four days in the year. If the first Monday of
January is the 2nd, 3rd, or 4th, the preceding days are part of the last week of the preceding year; thus, for Saturday 2nd January
1999, %G is replaced by 1998 and %V is replaced by 53. If December 29th, 30th, or 31st is a Monday, it and any
following days are part of week 1 of the following year. Thus, for Tuesday 30th December 1997, %G is replaced by 1998 and
%V is replaced by 01.
If a conversion specifier is not one of the above, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to strftime_l() is the special locale object LC_GLOBAL_LOCALE or is not
a valid locale object handle.
RETURN VALUE
If successful, these functions shall return the number of bytes placed into the array pointed to by s, not including the
terminating NUL character. [CX]  If successful, errno shall not be changed.  Otherwise, 0 shall be returned, [CX]   errno shall be set to indicate the error,  and the contents of the array are unspecified.
ERRORS
[CX]
These functions shall fail if:
[ERANGE]
The total number of resulting bytes including the terminating NUL character is more than maxsize.
These functions may fail if:
[EINVAL]
The format string includes a %s conversion and the number of seconds since the Epoch would be negative.
[EOVERFLOW]
The format string includes a %s conversion and the number of seconds since the Epoch cannot be represented in a
time_t.
The following sections are informative.
EXAMPLES
Getting a Localized Date String
The following example first sets the locale to the user's default. The locale information will be used in the nl_langinfo() and strftime() functions. The nl_langinfo() function returns the localized date string which specifies how the date is
laid out. The strftime() function takes this information and, using the tm structure for values, places the date and
time information into datestring.
#include
#include
#include
...
struct tm *tm;
char datestring[256];
...
setlocale (LC_ALL, "");
...
strftime (datestring, sizeof(datestring), nl_langinfo (D_T_FMT), tm);
...
APPLICATION USAGE
A return value of 0 may indicate either success or failure if a format is the empty string or consists of conversion
specifications such as %p or %Z that are replaced by no characters in the current locale or because of the
current setting of tzname[], respectively. To distinguish between success and failure when strftime() returns 0, an
application can set errno to 0 before calling strftime() and test whether errno is 0 afterwards.
The range of values for %S is [00,60] rather than [00,59] to allow for the occasional leap second.
Some of the conversion specifications are duplicates of others. They are included for compatibility with nl_cxtime() and
nl_ascxtime(), which were published in Issue 2.
The %C, %F, %G, and %Y format specifiers in strftime() always print full values, but
the strptime() %C, %F, and %Y format specifiers only
scan two digits (assumed to be the first two digits of a four-digit year) for %C and four digits (assumed to be the entire
(four-digit) year) for %F and %Y. This mimics the behavior of printf() and scanf(); that is:
printf("%2d", x = 1000);
prints "1000", but:
scanf(%2d", &x);
when given "1000" as input will only store 10 in x). Applications using extended ranges of years must be sure
that the number of digits specified for scanning years with strptime() matches the
number of digits that will actually be present in the input stream. Historic implementations of the %Y conversion
specification (with no flags and no minimum field width) produced different output formats. Some always produced at least four
digits (with 0 fill for years from 0 through 999) while others only produced the number of digits present in the year (with no fill
and no padding). These two forms can be produced with the '0' flag and a minimum field width options using the conversions
specifications %04Y and %01Y, respectively. Similarly, because %Y is part of %F, field widths
of 10 and 7 (%010F, %07F), respectively, produce the same effect in the year portion of the %F
conversion result.
In the past, the C and POSIX standards specified that %F produced an ISO 8601:2019 standard date format, but
didn't specify which one. For years in the range [1000,9999], POSIX.1-2024 requires that the output produced match the
ISO 8601:2019 standard complete representation extended format (YYYY-MM-DD) and for years greater than 9999 produce output
that matches the ISO 8601:2019 standard expanded representation extended format
±Y'-[Ywidth]u".15m''[Ywidth]u"-.15m'YYYY-MM-DD). For years less than 1000, %F is not required to produce an
ISO 8601:2019 standard format when used without specifying at least a minimum field width. As stated above, some
implementations pad %Y conversions with zeros to four digits, in which case %F produces an ISO 8601:2019
standard format; other implementations do not pad %Y with zeros, in which case %F does not produce an
ISO 8601:2019 standard format. To fully meet ISO 8601:2019 standard requirements, the producer and consumer must agree on
a date format that has a specific number of bytes reserved to hold the characters used to represent the years that is sufficiently
large to hold all values that will be shared. For example, the %+13F conversion specification will produce output matching
the format "±YYYYYY-MM-DD" (a leading '+' or '-' sign; a six-digit, 0-filled year; a '-'; a
two-digit, leading 0-filled month; another '-'; and the two-digit, leading 0-filled day within the month).
Note that if the year being printed is greater than 9999, the resulting string from the unadorned %F conversion
specifications will not conform to the ISO 8601:2019 standard extended format, complete representation for a date and will
instead be an extended format, expanded representation (presumably without the required agreement between the date's producer and
consumer).
In the C or POSIX locale, the E and O modifiers are ignored and the replacement strings for the following
specifiers are:
%a
The first three characters of %A.
%A
One of Sunday, Monday, ..., Saturday.
%b
The first three characters of %B.
%B
One of January, February, ..., December.
%c
Equivalent to %a %b %e %T %Y.
%p
One of AM or PM.
%r
Equivalent to %I:%M:%S %p.
%x
Equivalent to %m/%d/%y.
%X
Equivalent to %T.
%Z
Implementation-defined.
RATIONALE
The %Y conversion specification to strftime() was frequently assumed to be a four-digit year, but the ISO C
standard does not specify that %Y is restricted to any subset of allowed values from the tm_year field. Similarly,
the %C conversion specification was assumed to be a two-digit field and the first part of the output from the %F
conversion specification was assumed to be a four-digit field. Since tm_year is a signed int with a width of at least
32 bits and time_t is required to have a width of at least 64 bits (in conforming programming environments), these
assumptions no longer hold.
POSIX.1-2024 now allows the format specifications %0xC, %0xF, %0xG, and %0xY (where
'x' is a string of decimal digits used to specify printing and scanning of a string of x decimal digits) with
leading zero fill characters. Allowing applications to set the field width enables them to agree on the number of digits to be
printed and scanned in the ISO 8601:2019 standard expanded representation of a year (for %F, %G, and
%Y) or all but the last two digits of the year (for %C). This is based on a feature in some versions of GNU
libc's strftime(). The GNU version allows specifying space, zero, or no-fill characters in strftime() format
strings, but does not allow any flags to be specified in strptime() format strings.
These implementations also allow these flags to be specified for any numeric field. POSIX.1-2024 only requires the zero fill flag
('0') and only requires that it be recognized when processing %C, %F, %G, and %Y
specifications when a minimum field width is also specified. The '0' flag is the only flag needed to produce and scan the
ISO 8601:2019 standard year fields using the extended format forms. POSIX.1-2024 also allows applications to specify the same
flag and field width specifiers to be used in both strftime() and strptime()
format strings for symmetry. Systems may provide other flag characters and may accept flags in conjunction with conversion
specifiers other than %C, %F, %G, and %Y; but portable applications cannot depend on such
extensions.
POSIX.1-2024 now also allows the format specifications %+xC, %+xF, %+xG, and %+xY (where
'x' is a string of decimal digits used to specify printing and scanning of a string of 'x' decimal digits) with
leading zero fill characters and a leading '+' sign character if the year being converted is more than four digits or a
minimum field width is specified that allows room for more than four digits for the year. This allows date providers and consumers
to agree on a specific number of digits to represent a year as required by the ISO 8601:2019 standard expanded representation
formats. The expanded representation formats all require the year to begin with a leading '+' or '-' sign. (All
of these specifiers can also provide a leading '-' sign for negative years. Since negative years and the year 0 don't fit
well with the Gregorian or Julian calendars, the normal ranges of dates start with year 1. The ISO C standard allows
tm_year to assume values corresponding to years before year 1, but the use of such years provided unspecified results.)
Some earlier version of this standard specified that applications wanting to use strptime() to scan dates and times printed by strftime() should provide non-digit
characters between fields to separate years from months and days. It also supported %F to print and scan the
ISO 8601:2019 standard extended format, complete representation date for years 1 through 9999 (i.e., YYYY-MM-DD). However,
many applications were written to print (using strftime()) and scan (using strptime()) dates written using the basic format complete representation (four-digit years)
and truncated representation (two-digit years) specified by the ISO 8601:2019 standard representation of dates and times which
do not have any separation characters between fields. The ISO 8601:2019 standard also specifies basic format expanded
representation where the creator and consumer of these fields agree beforehand to represent years as leading zero-filled strings of
an agreed length of more than four digits to represent a year (again with no separation characters when year, month, and day are
all displayed). Applications producing and consuming expanded representations are encouraged to use the '+' flag and an
appropriate maximum field width to scan the year including the leading sign. Note that even without the '+' flag, years
less than zero may be represented with a leading  for %F, %G, and %Y conversion
specifications. Using negative years results in unspecified behavior.
If a format specification %+xF with the field width x greater than 11 is specified and the width is large enough
to display the full year, the output string produced will match the ISO 8601:2019 standard subclause 4.1.2.4 expanded
representation, extended format date representation for a specific day. (For years in the range [1,99999], %+12F is
sufficient for an agreed five-digit year with a leading sign using the ISO 8601:2019 standard expanded representation,
extended format for a specific day "±YYYYY-MM-DD".) Note also that years less than 0 may produce a leading
character ('-') when using %Y or %C whether or not the '0' or '+'
flags are used.
The difference between the '0' flag and the '+' flag is whether the leading '+' character will be
provided for years >9999 as required for the ISO 8601:2019 standard extended representation format containing a year. For
example:
Year
Conversion Specification
strftime() Output
strptime() Scan Back
1970
%Y
1970
1970
1970
%+4Y
1970
1970
27
%Y
27 or 0027
27
270
%Y
270 or 0270
270
270
%+4Y
0270
270
17
%C%y
0017
17
270
%C%y
0270
270
12345
%Y
12345
1234*
12345
%+4Y
+12345
123*
12345
%05Y
12345
12345
270
%+5Y or %+3C%y
+0270
270
12345
%+5Y or %+3C%y
+12345
1234*
12345
%06Y or %04C%y
012345
12345
12345
%+6Y or %+4C%y
+12345
12345
123456
%08Y or %06C%y
00123456
123456
123456
%+8Y or %+6C%y
+0123456
123456
In the cases above marked with a * in the strptime() scan back
field, the implied or specified number of characters scanned by strptime() was less
than the number of characters output by strftime() using the same format; so the remaining digits of the year were dropped
when the output date produced by strftime() was scanned back in by strptime().
FUTURE DIRECTIONS
None.
SEE ALSO
asctime(), clock(), ctime(), difftime(), futimens(), getdate(), gmtime(), localtime(), mktime(), strptime(), time(), tzset(), uselocale()
XBD 7.3.5 LC_TIME,
CHANGE HISTORY
First released in Issue 3.
Issue 5
The description of %OV is changed to be consistent with %V and defines Monday as the first day of the
week.
The description of %Oy is clarified.
Issue 6
Extensions beyond the ISO C standard are marked.
The Open Group Corrigendum U033/8 is applied. The %V conversion specifier is changed from "Otherwise, it
is week 53 of the previous year, and the next week is week 1" to "Otherwise, it is the last week of the previous year, and the
next week is week 1".
The following new requirements on POSIX implementations derive from alignment with the Single UNIX
Specification:
The %C, %D, %e, %h, %n, %r, %R, %t, and
%T conversion specifiers are added.
The modified conversion specifiers are added for consistency with the ISO POSIX-2 standard date utility.
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The strftime() prototype is updated.
The DESCRIPTION is extensively revised.
The %z conversion specifier is added.
An example is added.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/60 is applied.
Issue 7
Austin Group Interpretation 1003.1-2001 #163 is applied.
The strftime_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part
4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0605 [283], XSH/TC1-2008/0606 [283], XSH/TC1-2008/0607 [193],
and XSH/TC1-2008/0608 [193] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0340 [584], XSH/TC2-2008/0341 [796], XSH/TC2-2008/0342 [584],
and XSH/TC2-2008/0343 [584] are applied.
Issue 8
Austin Group Defects 169, 1386, and 1612 are applied, adding the s conversion and requiring errno to be
unchanged on success and set on error.
Austin Group Defects 258 and 1166 are applied, adding the OB and Ob modified conversions.
Austin Group Defect 472 is applied, changing the description of the C conversion.
Austin Group Defect 739 is applied, changing the %F conversion to match the ISO C standard when no
flag and no minimum field width are specified.
Austin Group Defect 1125 is applied, changing "Local timezone information is used" to "Local timezone
information shall be set".
Austin Group Defect 1253 is applied, changing "daylight savings" to "daylight saving".
Austin Group Defect 1307 is applied, changing the r conversion in relation to locales that do not support
the 12-hour clock format.
Austin Group Defects 1313 and 1354 are applied, changing text relating to the ISO 8601:2019 standard in the
APPLICATION USAGE section.
Austin Group Defect 1462 is applied, changing the RATIONALE section.
Austin Group Defect 1533 is applied, adding tm_gmtoff and tm_zone to the tm structure.
Austin Group Defect 1562 is applied, clarifying that it is the application's responsibility to ensure that the
format is a character string, beginning and ending in its initial shift state, if any.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/iconv_close.html =====
iconv_close
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
iconv_close — codeset conversion deallocation function
SYNOPSIS
#include
int iconv_close(iconv_t cd);
DESCRIPTION
The iconv_close() function shall deallocate the conversion descriptor cd and all other associated resources
allocated by iconv_open().
If a file descriptor is used to implement the type iconv_t, that file descriptor shall be closed.
RETURN VALUE
Upon successful completion, 0 shall be returned; otherwise, -1 shall be returned and errno set to indicate the error.
ERRORS
The iconv_close() function may fail if:
[EBADF]
The conversion descriptor is invalid.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
iconv(), iconv_open()
XBD
CHANGE HISTORY
First released in Issue 4. Derived from the HP-UX Manual.
Issue 7
The iconv_close() function is moved from the XSI option to the Base.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/imaxabs.html =====
imaxabs
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
imaxabs — return absolute value
SYNOPSIS
#include
intmax_t imaxabs(intmax_t j);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The imaxabs() function shall compute the absolute value of an integer j. If the result cannot be represented, the
behavior is undefined.
RETURN VALUE
The imaxabs() function shall return the absolute value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Since POSIX.1 requires a two's complement representation of intmax_t, the absolute value of the negative integer with the
largest magnitude {INTMAX_MIN} is not representable, thus imaxabs(INTMAX_MIN) is undefined.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
imaxdiv()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1108 is applied, changing the APPLICATION USAGE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/posix_spawn_file_actions_addfchdir.html =====
posix_spawn_file_actions_addchdir
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
posix_spawn_file_actions_addchdir, posix_spawn_file_actions_addfchdir — add chdir or fchdir action to spawn file
actions object (ADVANCED REALTIME)
SYNOPSIS
[SPN]  #include
int posix_spawn_file_actions_addchdir(posix_spawn_file_actions_t
*restrict file_actions, const char *restrict path);
int posix_spawn_file_actions_addfchdir(posix_spawn_file_actions_t
*file_actions, int fildes);
DESCRIPTION
The posix_spawn_file_actions_addchdir() function shall add a chdir action to the object referenced by
file_actions that shall cause the working directory to be set to path (as if chdir(path) had been
called) when a new process is spawned using this file actions object. A relative path shall be interpreted in relation to
the working directory determined by any prior actions. The string pointed to by path shall be copied by the
posix_spawn_file_actions_addchdir() function.
The posix_spawn_file_actions_addfchdir() function shall add an fchdir action to the object referenced by
file_actions that shall cause the working directory to be set to fildes (as if fchdir(fildes) had been
called) when a new process is spawned using this file actions object.
A spawn file actions object is as defined in posix_spawn_file_actions_addclose().
RETURN VALUE
Upon successful completion, these functions shall return zero; otherwise, an error number shall be returned to indicate the
error.
ERRORS
The posix_spawn_file_actions_addfchdir() function shall fail if:
[EBADF]
The value specified by fildes is negative.
These functions shall fail if:
[ENOMEM]
Insufficient memory exists to add to the spawn file actions object.
These functions may fail if:
[EINVAL]
The value specified by file_actions is invalid.
It shall not be considered an error for the path or fildes argument passed to these functions to specify a
pathname or file descriptor for which the specified operation could not be performed at the time of the call. Any such error shall
be detected when the associated file actions object is later used during a posix_spawn() or posix_spawnp()
operation.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The posix_spawn_file_actions_addchdir() and posix_spawn_file_actions_addfchdir() functions are part of the Spawn
option and need not be provided on all implementations.
Changing the working directory of a child process can be useful when invoking utilities such as pax. Furthermore, the ability to add fchdir actions to posix_spawn() gives the caller as much control over relative pathnames processed in the
context of the child as it would otherwise have using openat(), since all file
actions are processed in sequence in the context of the child at a point where the child process is still single-threaded. Without
chdir or fchdir actions, changing the working directory of the child would require a shim utility (some
implementations provide
env -C /new/path program args...
as an extension, but the standard does not require this extension), or else temporarily changing the working directory in the
parent process prior to calling posix_spawn() (but this requires locking in a
multi-threaded process, to ensure that no other thread is impacted by the temporary change to global state).
File actions are performed in a new process created by posix_spawn() or
posix_spawnp() in the same order that they were added to the file actions
object. Thus, the execution of an open action that was created by a call to posix_spawn_file_actions_addopen() that specifies a relative path
will be affected by the execution of a chdir or fchdir action that was created by a previous call to
posix_spawn_file_actions_addchdir() or posix_spawn_file_actions_addfchdir(). Likewise, a relative path passed to
posix_spawn() will be affected by the last chdir or fchdir action
in the file action list.
RATIONALE
Refer to the RATIONALE section in posix_spawn_file_actions_addclose().
FUTURE DIRECTIONS
None.
SEE ALSO
chdir(), fchdir(), posix_spawn(), posix_spawn_file_actions_addclose(), posix_spawn_file_actions_destroy()
XBD
CHANGE HISTORY
First released in Issue 8. Derived from Solaris posix_spawn_file_actions_addchdir_np.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/setservent.html =====
endservent
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
endservent, getservbyname, getservbyport, getservent, setservent — network services database functions
SYNOPSIS
#include
void endservent(void);
struct servent *getservbyname(const char *name, const char *proto);
struct servent *getservbyport(int port, const char *proto);
struct servent *getservent(void);
void setservent(int stayopen);
DESCRIPTION
These functions shall retrieve information about network services. This information is considered to be stored in a database
that can be accessed sequentially or randomly. The implementation of this database is unspecified.
The setservent() function shall open a connection to the database, and set the next entry to the first entry. If the
stayopen argument is non-zero, the net database shall not be closed after each call to the getservent()
function (either directly, or indirectly through one of the other getserv*() functions), and the implementation may maintain
an open file descriptor for the database. If a file descriptor is used, the FD_CLOEXEC flag shall be set; see .
The getservent() function shall read the next entry of the database, opening and closing a connection to the database as
necessary.
The getservbyname() function shall search the database from the beginning and find the first entry for which the service
name specified by name matches the s_name member and the protocol name specified by proto matches the
s_proto member, opening and closing a connection to the database as necessary. If proto is a null pointer, any value
of the s_proto member shall be matched.
The getservbyport() function shall search the database from the beginning and find the first entry for which the port
specified by port matches the s_port member and the protocol name specified by proto matches the
s_proto member, opening and closing a connection to the database as necessary. If proto is a null pointer, any value
of the s_proto member shall be matched. The port argument shall be a value obtained by converting a uint16_t
in network byte order to int.
The getservbyname(), getservbyport(), and getservent() functions shall each return a pointer to a
servent structure, the members of which shall contain the fields of an entry in the network services database.
The endservent() function shall close the database, releasing any open file descriptor.
These functions need not be thread-safe.
RETURN VALUE
Upon successful completion, getservbyname(), getservbyport(), and getservent() return a pointer to a
servent structure if the requested entry was found, and a null pointer if the end of the database was reached or the
requested entry was not found. Otherwise, a null pointer is returned.
The application shall not modify the structure to which the return value points, nor any storage areas pointed to by pointers
within the structure. The returned pointer, and pointers within the structure, might be invalidated or the structure or the storage
areas might be overwritten by a subsequent call to getservbyname(), getservbyport(), or getservent(). The
returned pointer, and pointers within the structure, might also be invalidated if the calling thread is terminated.
ERRORS
The getservbyname(), getservbyport(), getservent(), and setservent() functions may fail if:
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum allowable number of files is currently open in the system.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The port argument of getservbyport() need not be compatible with the port values of all address families.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
endhostent(), endprotoent(), htonl(), inet_addr()
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
SD5-XBD-ERN-14 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0088 [75] and XSH/TC1-2008/0089 [75] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0095 [656] is applied.
Issue 8
Austin Group Defect 368 is applied, adding a requirement for FD_CLOEXEC to be set if a file descriptor is used, and adding the
[EMFILE] and [ENFILE] errors.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fmtmsg.html =====
fmtmsg
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fmtmsg — display a message in the specified format on standard error and/or a system console
SYNOPSIS
[XSI]  #include
int fmtmsg(long classification, const char *label, int severity,
const char *text, const char *action, const char
*tag);
DESCRIPTION
The fmtmsg() function shall display messages in a specified format instead of the traditional printf() function.
Based on a message's classification component, fmtmsg() shall write a formatted message either to standard error, to the
console, or to both.
A formatted message consists of up to five components as defined below. The component classification is not part of a
message displayed to the user, but defines the source of the message and directs the display of the formatted message.
classification
Contains the sum of identifying values constructed from the constants defined below. Any one identifier from a subclass may be
used in combination with a single identifier from a different subclass. Two or more identifiers from the same subclass should not
be used together, with the exception of identifiers from the display subclass. (Both display subclass identifiers may be used so
that messages can be displayed to both standard error and the system console.)
Major Classifications
Identifies the source of the condition. Identifiers are: MM_HARD (hardware), MM_SOFT (software), and MM_FIRM (firmware).
Message Source Subclassifications
Identifies the type of software in which the problem is detected. Identifiers are: MM_APPL (application), MM_UTIL (utility), and
MM_OPSYS (operating system).
Display Subclassifications
Indicates where the message is to be displayed. Identifiers are: MM_PRINT to display the message on the standard error stream,
MM_CONSOLE to display the message on the system console. One or both identifiers may be used.
Status Subclassifications
Indicates whether the application can recover from the condition. Identifiers are: MM_RECOVER (recoverable) and MM_NRECOV
(non-recoverable).
An additional identifier, MM_NULLMC, indicates that no classification component is supplied for the message.
label
Identifies the source of the message. The format is two fields separated by a . The first field is up to 10 bytes,
the second is up to 14 bytes.
severity
Indicates the seriousness of the condition. Identifiers for the levels of severity are:
MM_HALT
Indicates that the application has encountered a severe fault and is halting. Produces the string "HALT".
MM_ERROR
Indicates that the application has detected a fault. Produces the string "ERROR".
MM_WARNING
Indicates a condition that is out of the ordinary, that might be a problem, and should be watched. Produces the string
"WARNING".
MM_INFO
Provides information about a condition that is not in error. Produces the string "INFO".
MM_NOSEV
Indicates that no severity level is supplied for the message.
text
Describes the error condition that produced the message. The character string is not limited to a specific size. If the
character string is empty, then the text produced is unspecified.
action
Describes the first step to be taken in the error-recovery process. The fmtmsg() function precedes the action string
with the prefix: "TO FIX:". The action string is not limited to a specific size.
tag
An identifier that references on-line documentation for the message. Suggested usage is that tag includes the
label and a unique identifying number. A sample tag is "XSI:cat:146".
The MSGVERB environment variable (for message verbosity) shall determine for fmtmsg() which message components it
is to select when writing messages to standard error. The value of MSGVERB shall be a -separated list of
optional keywords. Valid keywords are: label, severity, text, action, and tag. If MSGVERB
contains a keyword for a component and the component's value is not the component's null value, fmtmsg() shall include that
component in the message when writing the message to standard error. If MSGVERB does not include a keyword for a message
component, that component shall not be included in the display of the message. The keywords may appear in any order. If
MSGVERB is not defined, if its value is the null string, if its value is not of the correct format, or if it contains
keywords other than the valid ones listed above, fmtmsg() shall select all components.
MSGVERB shall determine which components are selected for display to standard error. All message components shall be
included in console messages.
RETURN VALUE
The fmtmsg() function shall return one of the following values:
MM_OK
The function succeeded.
MM_NOTOK
The function failed completely.
MM_NOMSG
The function was unable to generate a message on standard error, but otherwise succeeded.
MM_NOCON
The function was unable to generate a console message, but otherwise succeeded.
ERRORS
None.
The following sections are informative.
EXAMPLES
The following example of fmtmsg():
fmtmsg(MM_PRINT, "XSI:cat", MM_ERROR, "illegal option",
"refer to cat in user's reference manual", "XSI:cat:001")
produces a complete message in the specified message format:
XSI:cat: ERROR: illegal option
TO FIX: refer to cat in user's reference manual XSI:cat:001
When the environment variable MSGVERB is set as follows:
MSGVERB=severity:text:action
and Example 1 is used, fmtmsg() produces:
ERROR: illegal option
TO FIX: refer to cat in user's reference manual
APPLICATION USAGE
One or more message components may be systematically omitted from messages generated by an application by using the null value
of the argument for that component.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
fprintf()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fgets.html =====
fgets
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fgets — get a string from a stream
SYNOPSIS
#include
char *fgets(char *restrict s, int n, FILE *restrict stream);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The fgets() function shall read bytes from stream into the array pointed to by s until n-1 bytes are
read, or a  is read and transferred to s, or an end-of-file condition is encountered. A null byte shall be
written immediately after the last byte read into the array. If the end-of-file condition is encountered before any bytes are read,
the contents of the array pointed to by s shall not be changed.
[CX]  The
fgets() function may mark the last data access timestamp of the file associated with stream for update. The last data
access timestamp shall be marked for update by the first successful execution of fgetc(), fgets(), fread(), fscanf(), getc(), getchar(), getdelim(), getline(), or scanf() using stream that
returns data not supplied by a prior call to ungetc().
RETURN VALUE
Upon successful completion, fgets() shall return s. If the stream is at end-of-file, the end-of-file indicator for
the stream shall be set and fgets() shall return a null pointer. If an error occurs, the error indicator for the stream
shall be set, fgets() shall return a null pointer, [CX]   and shall set errno to indicate the error.
ERRORS
Refer to fgetc().
The following sections are informative.
EXAMPLES
Reading Input
The following example uses fgets() to read lines of input. It assumes that the file it is reading is a text file and that
lines in this text file are no longer than 16384 (or {LINE_MAX} if it is less than 16384 on the implementation where it is running)
bytes long. (Note that the standard utilities have no line length limit if sysconf(_SC_LINE_MAX) returns -1 without setting
errno. This example assumes that sysconf(_SC_LINE_MAX) will not fail.)
#include
#include
#include
#define MYLIMIT 16384
char *line;
int line_max;
if (LINE_MAX >= MYLIMIT) {
// Use maximum line size of MYLIMIT. If LINE_MAX is
// bigger than our limit, sysconf() cannot report a
// smaller limit.
line_max = MYLIMIT;
} else {
long limit = sysconf(_SC_LINE_MAX);
line_max = (limit  MYLIMIT) ? MYLIMIT : (int)limit;
}
// line_max + 1 leaves room for the null byte added by fgets().
line = malloc(line_max + 1);
if (line == NULL) {
// out of space
...
return error;
}
while (fgets(line, line_max + 1, fp) != NULL) {
// Verify that a full line has been read ...
// If not, report an error or prepare to treat the
// next time through the loop as a read of a
// continuation of the current line.
...
// Process line ...
...
}
free(line);
...
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fgetc(), fopen(), fread(), fscanf(), getc(), getchar(), getdelim(), ungetc()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
Extensions beyond the ISO C standard are marked.
The prototype for fgets() is changed for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
Austin Group Interpretation 1003.1-2001 #051 is applied, updating the list of functions that mark the last data access timestamp
for update.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0134 [182] and XSH/TC1-2008/0135 [14] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0114 [468] is applied.
Issue 8
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
Austin Group Defect 1624 is applied, changing the RETURN VALUE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/remquof.html =====
remquo
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
remquo, remquof, remquol — remainder functions
SYNOPSIS
#include
double remquo(double x, double y, int *quo);
float remquof(float x, float y, int *quo);
long double remquol(long double x, long double y, int *quo);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The remquo(), remquof(), and remquol() functions shall compute the same remainder as the remainder(), remainderf(), and remainderl() functions, respectively. In the object pointed to by quo, they store
a value whose sign is the sign of x/y and whose magnitude is congruent modulo 2n to
the magnitude of the integral quotient of x/y, where n is an implementation-defined integer greater than or
equal to 3. If y is zero, the value stored in the object pointed to by quo is unspecified.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
These functions shall return x REM y.
[MX]
When subnormal results are supported, the returned value shall be exact.
If NaN is supported and a NaN is returned, the value stored in the object pointed to by quo is unspecified.
On systems that do not support the IEC 60559 Floating-Point option, if y is zero, it is implementation-defined whether a
domain error occurs or zero is returned.
[MX]  If
x or y is NaN, a NaN shall be returned.
If x is ±Inf or y is zero and the other argument is non-NaN, a domain error shall occur, and a NaN shall be
returned.
ERRORS
These functions shall fail if:
Domain Error
[MX]
The x argument is ±Inf, or the y argument is ±0 and the other argument is non-NaN.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
These functions may fail if:
Domain Error
The y argument is zero.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
These functions are intended for implementing argument reductions which can exploit a few low-order bits of the quotient. Note
that x may be so large in magnitude relative to y that an exact representation of the quotient is not practical.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), remainder()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #56 (SD5-XSH-ERN-83) is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0507 [320] is applied.
Issue 8
Austin Group Defect 713 is applied, clarifying the behavior when a NaN is returned.
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mbsnrtowcs.html =====
mbsrtowcs
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mbsnrtowcs, mbsrtowcs — convert a character string to a wide-character string (restartable)
SYNOPSIS
#include
[CX]  size_t mbsnrtowcs(wchar_t *restrict dst, const char **restrict
src,
size_t nmc, size_t len, mbstate_t *restrict
ps);
size_t mbsrtowcs(wchar_t *restrict dst, const char **restrict src,
size_t len, mbstate_t *restrict ps);
DESCRIPTION
For mbsrtowcs(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The mbsrtowcs() function shall convert a sequence of characters, beginning in the conversion state described by the
object pointed to by ps, from the array indirectly pointed to by src into a sequence of corresponding wide
characters. If dst is not a null pointer, the converted characters shall be stored into the array pointed to by dst.
Conversion continues up to and including a terminating null character, which shall also be stored. Conversion shall stop early in
either of the following cases:
A sequence of bytes is encountered that does not form a valid character.
len codes have been stored into the array pointed to by dst (and dst is not a null pointer).
Each conversion shall take place as if by a call to the mbrtowc() function.
If dst is not a null pointer, the pointer object pointed to by src shall be assigned either a null pointer (if
conversion stopped due to reaching a terminating null character) or the address just past the last character converted (if any). If
conversion stopped due to reaching a terminating null character, and if dst is not a null pointer, the resulting state
described shall be the initial conversion state.
If ps is a null pointer, the mbsrtowcs() function shall use its own internal mbstate_t object, which is
initialized at program start-up to the initial conversion state. Otherwise, the mbstate_t object pointed to by ps
shall be used to completely describe the current conversion state of the associated character sequence.
[CX]  The
mbsnrtowcs() function shall be equivalent to the mbsrtowcs() function, except that the conversion of characters
indirectly pointed to by src is limited to at most nmc bytes (the size of the input buffer), and under conditions
where mbsrtowcs() would assign the address just past the last character converted (if any) to the pointer object pointed to
by src, mbsnrtowcs() shall instead assign the address just past the last byte processed (if any) to that pointer
object. If the input buffer ends with an incomplete character, conversion shall stop at the end of the input buffer; a subsequent
call to mbsnrtowcs() with an input buffer that starts with the remainder of the incomplete character shall correctly
complete the conversion of that character.
The behavior of these functions shall be affected by the LC_CTYPE category of the current locale.
The implementation shall behave as if no function defined in this volume of POSIX.1-2024 calls these functions.
[CX]  If
called with a null ps argument, the mbsnrtowcs() function need not be thread-safe; however, such calls shall avoid
data races with calls to mbsnrtowcs() with a non-null argument and with calls to all other functions.
If called with a null ps argument, the mbsrtowcs() function need not be thread-safe; however, such calls shall
avoid data races with calls to mbsrtowcs() with a non-null argument and with calls to all other functions.
The mbsrtowcs() function shall not change the setting of errno if successful.
RETURN VALUE
If the input conversion encounters a sequence of bytes that do not form a valid character, an encoding error occurs. In this
case, these functions shall store the value of the macro [EILSEQ] in errno and shall return (size_t)-1; the
conversion state is undefined. Otherwise, these functions shall return the number of characters successfully converted, not
including the terminating null (if any).
ERRORS
These functions shall fail if:
[EILSEQ]
An invalid character sequence is detected. [CX]   In the POSIX locale an [EILSEQ] error cannot occur since all byte
values are valid characters.
These functions may fail if:
[EINVAL]
[CX]
ps points to an object that contains an invalid conversion state.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
iconv(), mbrtowc(),
mbsinit()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E).
Issue 6
The mbsrtowcs() prototype is updated for alignment with the ISO/IEC 9899:1999 standard.
The [EINVAL] error condition is marked CX.
Issue 7
Austin Group Interpretation 1003.1-2001 #170 is applied.
The mbsnrtowcs() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 1.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0370 [109,105] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0205 [601], XSH/TC2-2008/0206 [663], and XSH/TC2-2008/0207 [601] are
applied.
Issue 8
Austin Group Defect 616 is applied, requiring that when the mbsnrtowcs() input buffer ends with an incomplete character,
conversion stops at the end of the input buffer (not at the end of the previous character, if any).
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/cosf.html =====
cos
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cos, cosf, cosl — cosine function
SYNOPSIS
#include
double cos(double x);
float cosf(float x);
long double cosl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the cosine of their argument x, measured in radians.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the cosine of x.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, the value 1.0 shall be returned.
If x is ±Inf, a domain error shall occur, and a NaN shall be returned.
ERRORS
These functions shall fail if:
Domain Error
[MX]
The x argument is ±Inf.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
Taking the Cosine of a 45-Degree Angle
#include
...
double radians = 45 * M_PI / 180;
double result;
...
result = cos(radians);
APPLICATION USAGE
These functions may lose accuracy when their argument is near an odd multiple of ℼ/2 or is far from 0.
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
acos(), feclearexcept(),
fetestexcept(), isnan(),
sin(), tan()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The cosf() and cosl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0063 [320] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/aligned_alloc.html =====
aligned_alloc
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
aligned_alloc — allocate memory with a specified alignment
SYNOPSIS
#include
void *aligned_alloc(size_t alignment, size_t size);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The aligned_alloc() function shall allocate unused space for an object whose alignment is specified by alignment,
whose size in bytes is specified by size, and whose value is indeterminate.
The order and contiguity of storage allocated by successive calls to aligned_alloc() is unspecified. Each such allocation
shall yield a pointer to an object disjoint from any other object. The pointer returned shall point to the start (lowest byte
address) of the allocated space. If the value of alignment is not a valid alignment supported by the implementation, a null
pointer shall be returned. If the space cannot be allocated, a null pointer shall be returned. If the size of the space requested
is 0, the behavior is implementation-defined: either a null pointer shall be returned to indicate an error, or the behavior shall
be as if the size were some non-zero value, except that the behavior is undefined if the returned pointer is used to access an
object.
For purposes of determining the existence of a data race, aligned_alloc() shall behave as though it accessed only memory
locations accessible through its arguments and not other static duration storage. The function may, however, visibly modify the
storage that it allocates. Calls to aligned_alloc(), calloc(), free(), malloc(), [ADV]   posix_memalign(),
[CX]
reallocarray(),
and realloc() that allocate or deallocate a particular region of memory shall
occur in a single total order (see 4.15.1 Memory Ordering), and each
such deallocation call shall synchronize with the next allocation (if any) in this order.
RETURN VALUE
Upon successful completion, aligned_alloc() shall return a pointer to the allocated space; if size is 0, the
application shall ensure that the pointer is not used to access an object.
Otherwise, it shall return a null pointer [CX]   and set errno to indicate the error.
ERRORS
The aligned_alloc() function shall fail if:
[EINVAL]
[CX]
The value of alignment is not a valid alignment supported by the implementation.
[ENOMEM]
[CX]
Insufficient storage space is available.
The aligned_alloc() function may fail if:
[EINVAL]
[CX]
size is 0 and the implementation does not support 0 sized allocations.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
See the RATIONALE for malloc().
FUTURE DIRECTIONS
None.
SEE ALSO
calloc(), free(), getrlimit(), malloc(), posix_memalign(), realloc()
XBD
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/exec.html =====
exec
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
environ, execl, execle, execlp, execv, execve, execvp, fexecve — execute a file
SYNOPSIS
#include
extern char **environ;
int execl(const char *path, const char *arg0, ... /*, (char *)0 */);
int execle(const char *path, const char *arg0, ... /*,
(char *)0, char *const envp[]*/);
int execlp(const char *file, const char *arg0, ... /*, (char *)0 */);
int execv(const char *path, char *const argv[]);
int execve(const char *path, char *const argv[], char *const envp[]);
int execvp(const char *file, char *const argv[]);
int fexecve(int fd, char *const argv[], char *const envp[]);
DESCRIPTION
The exec family of functions shall replace the current process image with a new process image. The new image shall be
constructed from a regular, executable file called the new process image file. There shall be no return from a successful
exec, because the calling process image is overlaid by the new process image.
The fexecve() function shall be equivalent to the execve() function except that the file to be executed is
determined by the file descriptor fd instead of a pathname. The file offset of fd is ignored.
When a C-language program is executed as a result of a call to one of the exec family of functions, it shall be entered
as a C-language function call as follows:
int main (int argc, char *argv[]);
where argc is the argument count and argv is an array of character pointers to the arguments themselves. In
addition, the following variable, which needs to be declared by the user if it is to be used directly:
extern char **environ;
is initialized as a pointer to an array of character pointers to the environment strings. The argv and environ
arrays are each terminated by a null pointer. The null pointer terminating the argv array is not counted in argc.
Applications can change the entire environment in a single operation by assigning the environ variable to point to an
array of character pointers to the new environment strings. After assigning a new value to environ, applications should not
rely on the new environment strings remaining part of the environment, as a call to getenv(), secure_getenv(),
[XSI]
putenv(),  setenv(), unsetenv(), or any function that is
dependent on an environment variable may, on noticing that environ has changed, copy the environment strings to a new array
and assign environ to point to it.
Any application that directly modifies the pointers to which the environ variable points has undefined behavior.
Conforming multi-threaded applications shall not use the environ variable to access or modify any environment variable
while any other thread is concurrently modifying any environment variable. A call to any function dependent on any environment
variable shall be considered a use of the environ variable to access that environment variable.
The arguments specified by a program with one of the exec functions shall be passed on to the new process image in the
corresponding main() arguments.
For the execl(), execle(), execv(), and execve() functions, the argument path points to a
pathname that identifies the new process image file.
For the execlp() and execvp() functions, the argument file is used to construct a pathname that identifies
the new process image file. If the file argument contains a  character, the file argument shall be used
as the pathname for this file. Otherwise, the path prefix for this file is obtained by a search of the directories passed as the
environment variable PATH (see XBD 8. Environment Variables). If
this environment variable is not present, the results of the search are implementation-defined.
There are two distinct ways in which the contents of the process image file may cause the execution to fail, distinguished by
the setting of errno to either [ENOEXEC] or [EINVAL] (see the ERRORS section). In the cases where the other members of the
exec family of functions would fail and set errno to [ENOEXEC], the execlp() and execvp() functions
shall execute a command interpreter and the environment of the executed command shall be as if the process invoked the sh utility using execl() as follows:
execl(, , file, , (char *)0);
where  is an unspecified pathname for the sh utility,
is an unspecified string, file is the process image file, and where  is zero or more
parameters corresponding to any initial non-null arguments passed after arg0 for execlp() or to any initial non-null
members of argv starting at argv[1] for execvp().
The arguments represented by arg0,... are pointers to null-terminated character strings. These strings shall constitute
the argument list available to the new process image. The list is terminated by a null pointer. The argument arg0 should
point to a filename string that is associated with the process being started by one of the exec functions.
The argument argv is an array of character pointers to null-terminated strings. The application shall ensure that the
last member of this array is a null pointer. These strings shall constitute the argument list available to the new process image.
The value in argv[0] should point to a filename string that is associated with the process being started by one of the
exec functions.
The argument envp is an array of character pointers to null-terminated strings. These strings shall constitute the
environment for the new process image. The envp array is terminated by a null pointer.
For those forms not containing an envp pointer (execl(), execv(),
execlp(), and execvp()), the environment for the new process image shall be taken from the external variable
environ in the calling process.
The number of bytes available for the new process' combined argument and environment lists is {ARG_MAX}. It is
implementation-defined whether null terminators, pointers, and/or any alignment bytes are included in this total.
File descriptors open in the calling process image shall remain open in the new process image, except for those whose
close-on-exec flag FD_CLOEXEC is set. For those file descriptors that remain open, all attributes of the open file
description shall remain unchanged and the FD_CLOFORK file descriptor flag, if set, shall remain set. For any file descriptor that
is closed for this reason, process-owned file locks that the calling process owns on the file associated with the file descriptor
shall be unlocked as a result of the close, as described in close(). File locks that
are not unlocked by closing of file descriptors remain unchanged.
If file descriptor 0, 1, or 2 would otherwise be closed after a successful call to one of the exec family of functions,
implementations may open an unspecified file for the file descriptor in the new process image. If a standard utility or a
conforming application is executed with file descriptor 0 not open for reading or with file descriptor 1 or 2 not open for writing,
the environment in which the utility or application is executed shall be deemed non-conforming, and consequently the utility or
application might not behave as described in this standard.
Directory streams open in the calling process image shall be closed in the new process image.
The state of the floating-point environment in the initial thread of the new process image shall be set to the default.
The state of conversion descriptors and message catalog descriptors in the new process image is undefined.
For the new process image, the equivalent of:
setlocale(LC_ALL, "C")
shall be executed at start-up.
Signals set to the default action (SIG_DFL) in the calling process image shall be set to the default action in the new process
image. Except for SIGCHLD, signals set to be ignored (SIG_IGN) by the calling process image shall be set to be ignored by the new
process image. Signals set to be caught by the calling process image shall be set to the default action in the new process image
(see ).
If the SIGCHLD signal is set to be ignored by the calling process image, it is unspecified whether the SIGCHLD signal is set to
be ignored or to the default action in the new process image.
[XSI]
After a successful call to any of the exec functions, alternate signal stacks are not preserved and the SA_ONSTACK flag
shall be cleared for all signals.
After a successful call to any of the exec functions, any functions previously registered by the atexit(), at_quick_exit(), or pthread_atfork() functions are no longer registered.
[XSI]
If the ST_NOSUID bit is set for the file system containing the new process image file, then the effective user ID, effective group
ID, saved set-user-ID, and saved set-group-ID are unchanged in the new process image. Otherwise,  if the set-user-ID mode bit of the new process image file is set, the effective user ID of the new
process image shall be set to the user ID of the new process image file. Similarly, if the set-group-ID mode bit of the new process
image file is set, the effective group ID of the new process image shall be set to the group ID of the new process image file. The
real user ID, real group ID, and supplementary group IDs of the new process image shall remain the same as those of the calling
process image. The effective user ID and effective group ID of the new process image shall be saved (as the saved set-user-ID and
the saved set-group-ID) for use by setuid().
[XSI]
Any shared memory segments attached to the calling process image shall not be attached to the new process image.
Any named semaphores open in the calling process shall be closed as if by appropriate calls to sem_close(). Any unnamed semaphores open in the calling process shall be destroyed as if
by calls to sem_destroy().
[TYM]
Any blocks of typed memory that were mapped in the calling process are unmapped, as if munmap() was implicitly called to unmap them.
[ML]
Memory locks established by the calling process via calls to mlockall() or mlock() shall be removed. If locked pages in the address space of the calling process are also
mapped into the address spaces of other processes and are locked by those processes, the locks established by the other processes
shall be unaffected by the call by this process to the exec function. If the exec function fails, the effect on
memory locks is unspecified.
Memory mappings created in the process are unmapped before the address space is rebuilt for the new process image.
When the calling process image does not use the SCHED_FIFO, SCHED_RR, [SS]
or SCHED_SPORADIC   scheduling policies, the scheduling policy and parameters of the new process image and the initial
thread in that new process image are implementation-defined.
[PS]
When the calling process image uses the SCHED_FIFO, SCHED_RR, or SCHED_SPORADIC scheduling policies, the process policy and
scheduling parameter settings shall not be changed by a call to an exec function.  [TPS]   The initial thread in the new process image shall inherit the process scheduling policy and
parameters. It shall have the default system contention scope, but shall inherit its allocation domain from the calling process
image.
Per-process timers created by the calling process shall be deleted before replacing the current process image with the new
process image.
[MSG]
All open message queue descriptors in the calling process shall be closed, as described in mq_close().
Any outstanding asynchronous I/O operations may be canceled. Those asynchronous I/O operations that are not canceled shall
complete as if the exec function had not yet occurred, but any associated signal notifications shall be suppressed. It is
unspecified whether the exec function itself blocks awaiting such I/O completion. In no event, however, shall the new
process image created by the exec function be affected by the presence of outstanding asynchronous I/O operations at the
time the exec function is called. Whether any I/O is canceled, and which I/O may be canceled upon exec, is
implementation-defined.
[CPT]
The new process image shall inherit the CPU-time clock of the calling process image. This inheritance means that the process
CPU-time clock of the process being exec-ed shall not be reinitialized or altered as a result of the exec function
other than to reflect the time spent by the process executing the exec function itself.
[TCT]
The initial value of the CPU-time clock of the initial thread of the new process image shall be set to zero.
The thread ID of the initial thread in the new process image is unspecified.
The size and location of the stack on which the initial thread in the new process image runs is unspecified.
The initial thread in the new process image shall have its cancellation type set to PTHREAD_CANCEL_DEFERRED and its cancellation
state set to PTHREAD_CANCEL_ENABLED.
The initial thread in the new process image shall have all thread-specific data values set to NULL and all thread-specific data
keys shall be removed by the call to exec without running destructors.
The initial thread in the new process image shall be joinable, as if created with the detachstate attribute set to
PTHREAD_CREATE_JOINABLE.
The new process shall inherit at least the following attributes from the calling process image:
[XSI]
Nice value (see nice())
[XSI]
semadj values (see semop())
Process ID
Parent process ID
Process group ID
Session membership
Real user ID
Real group ID
Supplementary group IDs
Time left until an alarm clock signal (see alarm())
Current working directory
Root directory
File mode creation mask (see umask())
File size limit (see getrlimit() and setrlimit())
Process signal mask (see pthread_sigmask())
Pending signal (see sigpending())
tms_utime, tms_stime, tms_cutime, and tms_cstime (see times())
Resource limits
Controlling terminal
The initial thread of the new process shall inherit at least the following attributes from the calling thread:
Signal mask (see sigprocmask() and pthread_sigmask())
Pending signals (see sigpending())
All other process attributes defined in this volume of POSIX.1-2024 shall be inherited in the new process image from the old
process image. All other thread attributes defined in this volume of POSIX.1-2024 shall be inherited in the initial thread in the
new process image from the calling thread in the old process image. The inheritance of process or thread attributes not defined by
this volume of POSIX.1-2024 is implementation-defined.
A call to any exec function from a process with more than one thread shall result in all threads being terminated and the
new executable image being loaded and executed. No destructor functions or cleanup handlers shall be called.
Upon successful completion, the exec functions shall mark for update the last data access timestamp of the file. If an
exec function failed but was able to locate the process image file, whether the last data access timestamp is marked for
update is unspecified. Should the exec function succeed, the process image file shall be considered to have been opened with
open(). The corresponding close() shall be
considered to occur at a time after this open, but before process termination or successful completion of a subsequent call to one
of the exec functions, posix_spawn(), or posix_spawnp(). The argv[] and envp[] arrays of pointers and the strings
to which those arrays point shall not be modified by a call to one of the exec functions, except as a consequence of
replacing the process image.
The saved resource limits in the new process image are set to be a copy of the process' corresponding hard and soft limits.
RETURN VALUE
If one of the exec functions returns to the calling process image, an error has occurred; the return value shall be -1,
and errno shall be set to indicate the error.
ERRORS
The exec functions shall fail if:
[E2BIG]
The number of bytes used by the new process image's argument list and environment list is greater than the system-imposed limit
of {ARG_MAX} bytes.
[EACCES]
The new process image file is not a regular file and the implementation does not support execution of files of its type.
[EINVAL]
The new process image file has appropriate privileges and has a recognized executable binary format, but the system does not
support execution of a file with this format.
The exec functions, except for fexecve(), shall fail if:
[EACCES]
Search permission is denied for a directory listed in the new process image file's path prefix, or the new process image file
denies execution permission.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path or file argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of path or file does not name an existing file or path or file is an empty string.
[ENOTDIR]
A component of the new process image file's path prefix names an existing file that is neither a directory nor a symbolic link
to a directory, or the new process image file's pathname contains at least one non- character and ends with one or
more trailing  characters and the last pathname component names an existing file that is neither a directory nor a
symbolic link to a directory.
The exec functions, except for execlp() and execvp(), shall fail if:
[ENOEXEC]
The new process image file has the appropriate access permission but has an unrecognized format.
The fexecve() function shall fail if:
[EBADF]
The fd argument is not a valid file descriptor open for executing.
The exec functions may fail if:
[ENOMEM]
The new process image requires more memory than is allowed by the hardware or system-imposed memory management
constraints.
The exec functions, except for fexecve(), may fail if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path or file argument.
[ENAMETOOLONG]
The length of the path argument or the length of the pathname constructed from the file argument exceeds {PATH_MAX},
or pathname resolution of a symbolic link produced an intermediate result with a length that exceeds {PATH_MAX}.
[ETXTBSY]
The new process image file is a pure procedure (shared text) file that is currently open for writing by some process.
The following sections are informative.
EXAMPLES
Using execl()
The following example executes the ls command, specifying the pathname of the
executable (/bin/ls) and using arguments supplied directly to the command to produce single-column output.
#include
int ret;
...
ret = execl ("/bin/ls", "ls", "-1", (char *)0);
Using execle()
The following example is similar to Using execl(). In addition, it specifies the environment
for the new process image using the env argument.
#include
int ret;
char *env[] = { "HOME=/usr/home", "LOGNAME=home", (char *)0 };
...
ret = execle ("/bin/ls", "ls", "-l", (char *)0, env);
Using execlp()
The following example searches for the location of the ls command among the
directories specified by the PATH environment variable.
#include
int ret;
...
ret = execlp ("ls", "ls", "-l", (char *)0);
Using execv()
The following example passes arguments to the ls command in the cmd array.
#include
int ret;
char *cmd[] = { "ls", "-l", (char *)0 };
...
ret = execv ("/bin/ls", cmd);
Using execve()
The following example passes arguments to the ls command in the cmd array, and
specifies the environment for the new process image using the env argument.
#include
int ret;
char *cmd[] = { "ls", "-l", (char *)0 };
char *env[] = { "HOME=/usr/home", "LOGNAME=home", (char *)0 };
...
ret = execve ("/bin/ls", cmd, env);
Using execvp()
The following example searches for the location of the ls command among the
directories specified by the PATH environment variable, and passes arguments to the ls command in the cmd array.
#include
int ret;
char *cmd[] = { "ls", "-l", (char *)0 };
...
ret = execvp ("ls", cmd);
APPLICATION USAGE
As the state of conversion descriptors and message catalog descriptors in the new process image is undefined, conforming
applications should not rely on their use and should close them prior to calling one of the exec functions.
Applications that require other than the default POSIX locale as the global locale in the new process image should call setlocale() with the appropriate parameters.
When assigning a new value to the environ variable, applications should ensure that the environment to which it will
point contains at least the following:
Any implementation-defined variables required by the implementation to provide a conforming environment. See the _CS_V8_ENV
entry in  and confstr() for details.
A value for PATH which finds conforming versions of all standard utilities before any other versions.
The same constraint applies to the envp array passed to execle() or execve(), in order to ensure that the
new process image is invoked in a conforming environment.
Applications should not execute programs with file descriptor 0 not open for reading or with file descriptor 1 or 2 not open for
writing, as this might cause the executed program to misbehave. In order not to pass on these file descriptors to an executed
program, applications should not just close them but should reopen them on, for example, /dev/null. Some implementations may
reopen them automatically, but applications should not rely on this being done.
If an application wants to perform an integrity test of the file being executed before executing it, the file will need to be
opened with read permission to perform the integrity test.
Since execute permission is checked by fexecve(), the file description fd need not have been opened with the
O_EXEC flag. However, if the file to be executed denies read and write permission for the process preparing to do the exec,
the only way to provide the fd to fexecve() will be to use the O_EXEC flag when opening fd. In this case, the
application will not be able to perform an integrity test since it will not be able to read the contents of the file.
Note that when a file descriptor is opened with O_RDONLY, O_RDWR, or O_WRONLY mode, the file descriptor can be used to read,
read and write, or write the file, respectively, even if the mode of the file changes after the file was opened. Using the O_EXEC
open mode is different; fexecve() will ignore the mode that was used when the file descriptor was opened and the exec
will fail if the mode of the file associated with fd does not grant execute permission to the calling process at the time
fexecve() is called.
RATIONALE
Early proposals required that the value of argc passed to main() be "one or greater". This was driven by the
same requirement in drafts of the ISO C standard. In fact, historical implementations have passed a value of zero when no
arguments are supplied to the caller of the exec functions. This requirement was removed from the ISO C standard and
subsequently removed from this volume of POSIX.1-2024 as well. The wording, in particular the use of the word should,
requires a Strictly Conforming POSIX Application to pass at least one argument to the exec function, thus guaranteeing that
argc be one or greater when invoked by such an application. In fact, this is good practice, since many existing applications
reference argv[0] without first checking the value of argc.
The requirement on a Strictly Conforming POSIX Application also states that the value passed as the first argument be a filename
string associated with the process being started. Although some existing applications pass a pathname rather than a filename string
in some circumstances, a filename string is more generally useful, since the common usage of argv[0] is in printing
diagnostics. In some cases the filename passed is not the actual filename of the file; for example, many implementations of the
login utility use a convention of prefixing a  ('-') to the actual filename, which indicates to
the command interpreter being invoked that it is a "login shell".
Also, note that the test and [ utilities require specific strings for the
argv[0] argument to have deterministic behavior across all implementations.
Historically, there have been two ways that implementations can exec shell scripts.
One common historical implementation is that the execl(), execv(), execle(), and execve() functions
return an [ENOEXEC] error for any file not recognizable as executable, including a shell script. When the execlp() and
execvp() functions encounter such a file, they assume the file to be a shell script and invoke a known command interpreter
to interpret such files. This is now required by POSIX.1-2024. These implementations of execvp() and execlp() only
give the [ENOEXEC] error in the rare case of a problem with the command interpreter's executable file. Because of these
implementations, the [ENOEXEC] error is not mentioned for execlp() or execvp(), although implementations can still
give it.
Another way that some historical implementations handle shell scripts is by recognizing the first two bytes of the file as the
character string "#!" and using the remainder of the first line of the file as the name of the command interpreter to
execute.
One potential source of confusion noted by the standard developers is over how the contents of a process image file affect the
behavior of the exec family of functions. The following is a description of the actions taken:
If the process image file is a valid executable (in a format that is executable and valid and having appropriate privileges) for
this system, then the system executes the file.
If the process image file has appropriate privileges and is in a format that is executable but not valid for this system (such
as a recognized binary for another architecture), then this is an error and errno is set to [EINVAL] (see later RATIONALE on
[EINVAL]).
If the process image file has appropriate privileges but is not otherwise recognized:
If this is a call to execlp() or execvp(), then they invoke a command interpreter assuming that the process image
file is a shell script.
If this is not a call to execlp() or execvp(), then an error occurs and errno is set to [ENOEXEC].
Applications that do not require to access their arguments may use the form:
main(void)
as specified in the ISO C standard. However, the implementation will always provide the two arguments argc and
argv, even if they are not used.
Some implementations provide a third argument to main() called envp. This is defined as a pointer to the
environment. The ISO C standard specifies invoking main() with two arguments, so implementations are required to
support applications written this way. Since this volume of POSIX.1-2024 defines the global variable environ, which is also
provided by historical implementations and can be used anywhere that envp could be used, there is no functional need for the
envp argument. Applications should use the getenv() function rather than
accessing the environment directly via either envp or environ. Implementations are required to support the
two-argument calling sequence, but this does not prohibit an implementation from supporting envp as an optional third
argument.
This volume of POSIX.1-2024 specifies that signals set to SIG_IGN remain set to SIG_IGN, and that the new process image inherits
the signal mask of the thread that called exec in the old process image. This is consistent with historical implementations,
and it permits some useful functionality, such as the nohup command. However, it
should be noted that many existing applications wrongly assume that they start with certain signals set to the default action
and/or unblocked. In particular, applications written with a simpler signal model that does not include blocking of signals, such
as the one in the ISO C standard, may not behave properly if invoked with some signals blocked. Therefore, it is best not to
block or ignore signals across execs without explicit reason to do so, and especially not to block signals across
execs of arbitrary (not closely cooperating) programs.
The exec functions always save the value of the effective user ID and effective group ID of the process at the completion
of the exec, whether or not the set-user-ID or the set-group-ID bit of the process image file is set.
The statement about argv[] and envp[] being constants is included to make explicit to future writers of language
bindings that these objects are completely constant. Due to a limitation of the ISO C standard, it is not possible to state
that idea in standard C. Specifying two levels of const-qualification for the argv[] and envp[]
parameters for the exec functions may seem to be the natural choice, given that these functions do not modify either the
array of pointers or the characters to which the function points, but this would disallow existing correct code. Instead, only the
array of pointers is noted as constant. The table of assignment compatibility for dst=src derived from the ISO C
standard summarizes the compatibility:
dst:
char *[]
const char *[]
char *const[]
const char *const[]
src:
char *[]
VALID
—
VALID
—
const char *[]
—
VALID
—
VALID
char * const []
—
—
VALID
—
const char *const[]
—
—
—
VALID
Since all existing code has a source type matching the first row, the column that gives the most valid combinations
is the third column. The only other possibility is the fourth column, but using it would require a cast on the argv or
envp arguments. It is unfortunate that the fourth column cannot be used, because the declaration a non-expert would
naturally use would be that in the second row.
The ISO C standard and this volume of POSIX.1-2024 do not conflict on the use of environ, but some
historical implementations of environ may cause a conflict. As long as environ is treated in the same way as an entry
point (for example, fork()), it conforms to both standards. A library can contain
fork(), but if there is a user-provided fork(), that fork() is given precedence and no
problem ensues. The situation is similar for environ: the definition in this volume of POSIX.1-2024 is to be used if there
is no user-provided environ to take precedence. At least three implementations are known to exist that solve this
problem.
[E2BIG]
The limit {ARG_MAX} applies not just to the size of the argument list, but to the sum of that and the size of the environment
list.
[EFAULT]
Some historical systems return [EFAULT] rather than [ENOEXEC] when the new process image file is corrupted. They are
non-conforming.
[EINVAL]
This error condition was added to POSIX.1-2024 to allow an implementation to detect executable files generated for different
architectures, and indicate this situation to the application. Historical implementations of shells, execvp(), and
execlp() that encounter an [ENOEXEC] error will execute a shell on the assumption that the file is a shell script. This will
not produce the desired effect when the file is a valid executable for a different architecture. An implementation may now choose
to avoid this problem by returning [EINVAL] when a valid executable for a different architecture is encountered. Some historical
implementations return [EINVAL] to indicate that the path argument contains a character with the high order bit set. The
standard developers chose to deviate from historical practice for the following reasons:
The new utilization of [EINVAL] will provide some measure of utility to the user community.
Historical use of [EINVAL] is not acceptable in an internationalized operating environment.
[ENAMETOOLONG]
Since the file pathname may be constructed by taking elements in the PATH variable and putting them together with the
filename, the [ENAMETOOLONG] error condition could also be reached this way.
[ETXTBSY]
System V returns this error when the executable file is currently open for writing by some process. This volume of POSIX.1-2024
neither requires nor prohibits this behavior.
Other systems (such as System V) may return [EINTR] from exec. This is not addressed by this volume of
POSIX.1-2024, but implementations may have a window between the call to exec and the time that a signal could cause one of
the exec calls to return with [EINTR].
An explicit statement regarding the floating-point environment (as defined in the  header) was added to make it clear that the floating-point environment is set
to its default when a call to one of the exec functions succeeds. The requirements for inheritance or setting to the default
for other process and thread start-up functions is covered by more generic statements in their descriptions and can be summarized
as follows:
posix_spawn()
Set to default.
fork()
Inherit.
pthread_create()
Inherit.
The purpose of the fexecve() function is to enable executing a file which has been verified to be the
intended file. It is possible to actively check the file by reading from the file descriptor and be sure that the file is not
exchanged for another between the reading and the execution. Alternatively, a function like openat() can be used to open a file which has been found by reading the content of a
directory using readdir().
When execlp() or execvp() fall back to invoking sh because
of an [ENOEXEC] condition, the standard leaves the process name (what becomes argv[0] in the resulting sh process) unspecified. Existing implementations vary on whether they pass a variation of
"sh", or preserve the original arg0. There are existing implementations of sh that behave differently depending on the contents of argv[0], such that blindly passing
the original arg0 on to the fallback execution can fail to invoke a compliant shell environment. Because of the requirements
on how sh handles its command line arguments, the shell script will see $0
containing the pathname of the script being executed, regardless of the value of argv[0].
FUTURE DIRECTIONS
None.
SEE ALSO
alarm(), atexit(), chmod(), close(), confstr(), exit(), fcntl(), fork(), fstatvfs(), getenv(), getrlimit(), mknod(), mmap(), nice(), open(), posix_spawn(), pthread_atfork(), pthread_sigmask(), putenv(),
readdir(), semop(), setlocale(), shmat(), sigaction(), sigaltstack(),
sigpending(), system(),
times(), umask()
XBD 8. Environment Variables,
XCU test
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Realtime Extension and the POSIX Threads Extension.
Large File Summit extensions are added.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the DESCRIPTION, behavior is defined for when the process image file is not a valid executable.
In this version, _POSIX_SAVED_IDS is mandated, thus the effective user ID and effective group ID of the new
process image shall be saved (as the saved set-user-ID and the saved set-group-ID) for use by the setuid() function.
The [ELOOP] mandatory error condition is added.
A second [ENAMETOOLONG] is added as an optional error condition.
The [ETXTBSY] optional error condition is added.
The following changes were made to align with the IEEE P1003.1a draft standard:
The [EINVAL] mandatory error condition is added.
The [ELOOP] optional error condition is added.
The description of CPU-time clock semantics is added for alignment with IEEE Std 1003.1d-1999.
The DESCRIPTION is updated for alignment with IEEE Std 1003.1j-2000 by adding semantics for typed
memory.
The normative text is updated to avoid use of the term "must" for application requirements.
The description of tracing semantics is added for alignment with IEEE Std 1003.1q-2000.
IEEE PASC Interpretation 1003.1 #132 is applied.
The DESCRIPTION is updated to make it explicit that the floating-point environment in the new process image is set
to the default.
The DESCRIPTION and RATIONALE are updated to include clarifications of how the contents of a process image file
affect the behavior of the exec functions.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/15 is applied, adding a new paragraph to the
DESCRIPTION and text to the end of the APPLICATION USAGE section. This change addresses a security concern, where implementations
may want to reopen file descriptors 0, 1, and 2 for programs with the set-user-id or set-group-id file mode bits calling the
exec family of functions.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/24 is applied, applying changes to the DESCRIPTION,
addressing which attributes are inherited by threads, and behavioral requirements for threads attributes.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/25 is applied, updating text in the RATIONALE from
"the process signal mask be unchanged across an exec" to "the new process image inherits the signal mask of the thread
that called exec in the old process image".
Issue 7
Austin Group Interpretation 1003.1-2001 #047 is applied, adding the description of _CS_V7_ENV to the APPLICATION USAGE.
Austin Group Interpretation 1003.1-2001 #143 is applied.
The fexecve() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 2.
Functionality relating to the Asynchronous Input and Output, Memory Mapped Files, Threads, and Timers options is
moved to the Base.
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0095 [386], XSH/TC1-2008/0096 [167], XSH/TC1-2008/0097 [291],
XSH/TC1-2008/0098 [173], XSH/TC1-2008/0099 [296], XSH/TC1-2008/00100 [324], XSH/TC1-2008/00101 [296], XSH/TC1-2008/00102 [302],
XSH/TC1-2008/00103 [167], XSH/TC1-2008/00104 [173], and XSH/TC1-2008/00105 [291,429] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0097 [584], XSH/TC2-2008/0098 [898], and XSH/TC2-2008/0099
[734] are applied.
Issue 8
Austin Group Defects 51 and 1669 are applied, moving the getrlimit() and
setrlimit() functions from the XSI option to the Base.
Austin Group Defect 368 is applied, adding a requirement for unnamed semaphores to be destroyed.
Austin Group Defect 768 is applied, adding OFD-owned file locks.
Austin Group Defect 922 is applied, adding the secure_getenv()
function.
Austin Group Defect 1284 is applied, changing "checksum test" to "integrity test" in the APPLICATION USAGE
section.
Austin Group Defect 1318 is applied, adding FD_CLOFORK.
Austin Group Defect 1330 is applied, removing obsolescent interfaces and changing "_V7_" to "_V8_".
Austin Group Defect 1435 is applied, adding function lists to the descriptions of the path and file
arguments.
Austin Group Defect 1645 is applied, making it unspecified what string is passed to the shell in argv[0]
when executed by execlp() or execvp().
Austin Group Defect 1646 is applied, adding at_quick_exit() to
the list of registration functions whose registrations are not inherited across exec.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fstatvfs.html =====
fstatvfs
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fstatvfs, statvfs — get file system information
SYNOPSIS
#include
int fstatvfs(int fildes, struct statvfs *buf);
int statvfs(const char *restrict path, struct statvfs *restrict buf);
DESCRIPTION
The fstatvfs() function shall obtain information about the file system containing the file referenced by
fildes.
The statvfs() function shall obtain information about the file system containing the file named by path.
For both functions, the buf argument is a pointer to a statvfs structure that shall be filled. Read, write, or
execute permission of the named file is not required.
The following flags can be returned in the f_flag member:
ST_RDONLY
Read-only file system.
ST_NOSUID
Setuid/setgid bits ignored by exec.
It is unspecified whether all members of the statvfs structure have meaningful values on all file systems.
RETURN VALUE
Upon successful completion, statvfs() shall return 0. Otherwise, it shall return -1 and set errno to indicate the
error.
ERRORS
The fstatvfs() and statvfs() functions shall fail if:
[EIO]
An I/O error occurred while reading the file system.
[EINTR]
A signal was caught during execution of the function.
[EOVERFLOW]
One of the values to be returned cannot be represented correctly in the structure pointed to by buf.
The fstatvfs() function shall fail if:
[EBADF]
The fildes argument is not an open file descriptor.
The statvfs() function shall fail if:
[EACCES]
Search permission is denied on a component of the path prefix.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of path does not name an existing file or path is an empty string.
[ENOTDIR]
A component of the path prefix names an existing file that is neither a directory nor a symbolic link to a directory, or the
path argument contains at least one non- character and ends with one or more trailing  characters
and the last pathname component names an existing file that is neither a directory nor a symbolic link to a directory.
The statvfs() function may fail if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
The following sections are informative.
EXAMPLES
Obtaining File System Information Using fstatvfs()
The following example shows how to obtain file system information for the file system upon which the file named
/home/cnd/mod1 resides, using the fstatvfs() function. The /home/cnd/mod1 file is opened with read/write
privileges and the open file descriptor is passed to the fstatvfs() function.
#include
#include
struct statvfs buffer;
int            status;
...
fildes = open("/home/cnd/mod1", O_RDWR);
status  = fstatvfs(fildes, &buffer);
Obtaining File System Information Using statvfs()
The following example shows how to obtain file system information for the file system upon which the file named
/home/cnd/mod1 resides, using the statvfs() function.
#include
struct statvfs buffer;
int            status;
...
status = statvfs("/home/cnd/mod1", &buffer);
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
chmod(), chown()
, creat(), dup(), exec, fcntl(), futimens(), link(), mknod(), open(), pipe(), read(), time(), unlink(), write()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Large File Summit extensions are added.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
The restrict keyword is added to the statvfs() prototype for alignment with the ISO/IEC 9899:1999
standard.
The wording of the mandatory [ELOOP] error condition is updated, and a second optional [ELOOP] error condition is added.
Issue 7
Austin Group Interpretation 1003.1-2001 #143 is applied.
SD5-XSH-ERN-68 is applied, correcting the EXAMPLES section.
The fstatvfs() and statvfs() functions are moved from the XSI option to the Base.
The [ENOTDIR] error condition is clarified to cover the condition where the last component of a pathname exists but is not a
directory or a symbolic link to a directory.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0203 [324] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fdiml.html =====
fdim
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fdim, fdimf, fdiml — compute positive difference between two floating-point numbers
SYNOPSIS
#include
double fdim(double x, double y);
float fdimf(float x, float y);
long double fdiml(long double x, long double y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall determine the positive difference between their arguments. If x is greater than y,
x-y is returned. If x is less than or equal to y, +0 is returned.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the positive difference value.
If x-y is positive and overflows, a range error shall occur and fdim(), fdimf(), and fdiml()
shall return the value of the macro HUGE_VAL, HUGE_VALF, and HUGE_VALL, respectively.
If the correct value would cause underflow, a range error may occur, and fdim(), fdimf(), and fdiml() shall
return [MXX]   the correct value, or   (if the IEC 60559
Floating-Point option is not supported) an implementation-defined value no greater in magnitude than DBL_MIN, FLT_MIN, and
LDBL_MIN, respectively.
[MX]  If
x or y is NaN, a NaN shall be returned.
ERRORS
The fdim() function shall fail if:
Range Error
The result overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
The fdim() function may fail if:
Range Error
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), fmax(), fmin()
4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0119 [68,428] and XSH/TC1-2008/0120 [68,428] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/write.html =====
write
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pwrite, write — write on a file
SYNOPSIS
#include
ssize_t pwrite(int fildes, const void *buf, size_t nbyte,
off_t offset);
ssize_t write(int fildes, const void *buf, size_t nbyte);
DESCRIPTION
The write() function shall attempt to write nbyte bytes from the buffer pointed to by buf to the file
associated with the open file descriptor, fildes.
Before any action described below is taken, and if nbyte is zero and the file is a regular file, the write()
function may detect and return errors as described below. In the absence of errors, or if error detection is not performed, the
write() function shall return zero and have no other results. If nbyte is zero and the file is not a regular file,
the results are unspecified.
On a regular file or other file capable of seeking, the actual writing of data shall proceed from the position in the file
indicated by the file offset associated with fildes. Before successful return from write(), the file offset shall be
incremented by the number of bytes actually written. On a regular file, if the position of the last byte written is greater than or
equal to the length of the file, the length of the file shall be set to this position plus one.
On a file not capable of seeking, writing shall always take place starting at the current position. The value of a file offset
associated with such a device is undefined.
If the O_APPEND flag of the file status flags is set, the file offset shall be set to the end of the file prior to each write
and no intervening file modification operation shall occur between changing the file offset and the write operation.
If a write() requests that more bytes be written than there is room for (for example, the file size limit of the process
or the physical end of a medium), only as many bytes as there is room for shall be written. For example, suppose there is space for
20 bytes more in a file before reaching a limit. A write of 512 bytes will return 20. The next write of a non-zero number of bytes
would give a failure return (except as noted below).
If the request would cause the file size to exceed the soft file size limit for the process and there is no room for any bytes
to be written, the request shall fail [XSI]   and the implementation shall generate a SIGXFSZ signal for the thread.
If write() is interrupted by a signal before it writes any data, it shall return -1 with errno set to [EINTR].
If write() is interrupted by a signal after it successfully writes some data, it shall return the number of bytes
written.
If the value of nbyte is greater than {SSIZE_MAX}, the result is implementation-defined.
After a write() to a regular file has successfully returned:
Any successful read() from each byte position in the file that was modified by that
write shall return the data specified by the write() for that position until such byte positions are again modified.
Any subsequent successful write() to the same byte position in the file shall overwrite that file data.
Write requests to a pipe or FIFO shall be handled in the same way as a regular file with the following exceptions:
There is no file offset associated with a pipe or FIFO, hence each write request shall append to the end of the pipe or
FIFO.
Write requests of {PIPE_BUF} bytes or less shall not be interleaved with data from other threads performing write operations on
the same pipe or FIFO. Writes of greater than {PIPE_BUF} bytes may have data interleaved, on arbitrary boundaries, with write
operations by other threads, whether or not the O_NONBLOCK flag of the file status flags is set.
If the O_NONBLOCK flag is clear, a write request may cause the thread to block, but on normal completion it shall return
nbyte.
If the O_NONBLOCK flag is set, write() requests shall be handled differently, in the following ways:
The write() function shall not block the thread.
A write request for {PIPE_BUF} or fewer bytes shall have the following effect: if there is sufficient space available in the
pipe or FIFO, write() shall transfer all the data and return the number of bytes requested. Otherwise, write() shall
transfer no data and return -1 with errno set to [EAGAIN].
A write request for more than {PIPE_BUF} bytes shall cause one of the following:
When at least one byte can be written, transfer what it can and return the number of bytes written. When all data previously
written to the pipe or FIFO is read, it shall transfer at least {PIPE_BUF} bytes.
When no data can be written, transfer no data, and return -1 with errno set to [EAGAIN].
When attempting to write to a file descriptor (other than a pipe or FIFO) that supports non-blocking writes and cannot accept
the data immediately:
If the O_NONBLOCK flag is clear, write() shall block the calling thread until the data can be accepted.
If the O_NONBLOCK flag is set, write() shall not block the thread. If some data can be written without blocking the
thread, write() shall write what it can and return the number of bytes written. Otherwise, it shall return -1 and set
errno to [EAGAIN].
Upon successful completion, where nbyte is greater than 0, write() shall mark for update the last data
modification and last file status change timestamps of the file, and if the file is a regular file, the S_ISUID and S_ISGID bits of
the file mode may be cleared.
For regular files, no data transfer shall occur past the offset maximum established in the open file description associated with
fildes.
If fildes refers to a socket, write() shall be equivalent to send()
with no flags set.
[SIO]
If the O_DSYNC bit has been set, write I/O operations on the file descriptor shall complete as defined by synchronized I/O data
integrity completion.
If the O_SYNC bit has been set, write I/O operations on the file descriptor shall complete as defined by synchronized I/O file
integrity completion.
[SHM]
If fildes refers to a shared memory object, the result of the write() function is unspecified.
[TYM]
If fildes refers to a typed memory object, the result of the write() function is unspecified.
The pwrite() function shall be equivalent to write(), except that it writes into a given position and does not
change the file offset (regardless of whether O_APPEND is set). The first three arguments to pwrite() are the same as
write() with the addition of a fourth argument offset for the desired position inside the file. An attempt to perform
a pwrite() on a file that is incapable of seeking shall result in an error.
RETURN VALUE
Upon successful completion, these functions shall return the number of bytes actually written to the file associated with
fildes. This number shall never be greater than nbyte. Otherwise, -1 shall be returned and errno set to
indicate the error.
ERRORS
These functions shall fail if:
[EAGAIN]
The file is neither a pipe, nor a FIFO, nor a socket, the O_NONBLOCK flag is set for the file descriptor, and the thread would
be delayed in the write() operation.
[EBADF]
The fildes argument is not a valid file descriptor open for writing.
[EFBIG]
An attempt was made to write a file that exceeds the implementation-defined maximum file size and there was no room for any
bytes to be written.
[EFBIG]
An attempt was made to write a file that exceeds the file size limit of the process, and there was no room for any bytes to be
written. [XSI]   A SIGXFSZ signal shall also be generated for the thread.
[EFBIG]
The file is a regular file, nbyte is greater than 0, and the starting position is greater than or equal to the offset
maximum established in the open file description associated with fildes.
[EINTR]
The write operation was terminated due to the receipt of a signal, and no data was transferred.
[EIO]
The process is a member of a background process group attempting to write to its controlling terminal, TOSTOP is set, the
calling thread is not blocking SIGTTOU, the process is not ignoring SIGTTOU, and the process group of the process is orphaned. This
error may also be returned under implementation-defined conditions.
[ENOSPC]
There was no free space remaining on the device containing the file.
The pwrite() function shall fail if:
[EINVAL]
The file is a regular file or block special file, and the offset argument is negative. The file offset shall remain
unchanged.
[ESPIPE]
The file is incapable of seeking.
The write() function shall fail if:
[EAGAIN]
The file is a pipe or FIFO, the O_NONBLOCK flag is set for the file descriptor, and the thread would be delayed in the write
operation.
[EAGAIN] or [EWOULDBLOCK]
The file is a socket, the O_NONBLOCK flag is set for the file descriptor, and the thread would be delayed in the write
operation.
[ECONNRESET]
A write was attempted on a socket that is not connected.
[EPIPE]
An attempt is made to write to a pipe or FIFO that is not open for reading by any process, or that only has one end open. A
SIGPIPE signal shall also be sent to the thread.
[EPIPE]
A write was attempted on a socket that is shut down for writing, or is no longer connected. In the latter case, if the socket
is of type SOCK_STREAM, a SIGPIPE signal shall also be sent to the thread.
These functions may fail if:
[EIO]
A physical I/O error has occurred.
[ENOBUFS]
Insufficient resources were available in the system to perform the operation.
[ENXIO]
A request was made of a nonexistent device, or the request was outside the capabilities of the device.
The write() function may fail if:
[EACCES]
A write was attempted on a socket and the calling process does not have appropriate privileges.
[ENETDOWN]
A write was attempted on a socket and the local network interface used to reach the destination is down.
[ENETUNREACH]
A write was attempted on a socket and no route to the network is present.
The following sections are informative.
EXAMPLES
Writing from a Buffer
The following example writes data from the buffer pointed to by buf to the file associated with the file descriptor
fd.
#include
#include
...
char buf[20];
size_t nbytes;
ssize_t bytes_written;
int fd;
...
strcpy(buf, "This is a test\n");
nbytes = strlen(buf);
bytes_written = write(fd, buf, nbytes);
...
APPLICATION USAGE
None.
RATIONALE
See also the RATIONALE section in read().
An attempt to write to a pipe or FIFO has several major characteristics:
Atomic/non-atomic: A write is atomic if the whole amount written in one operation is not interleaved with data from any
other thread. This is useful when there are multiple writers sending data to a single reader. Applications need to know how large a
write request can be expected to be performed atomically. This maximum is called {PIPE_BUF}. This volume of POSIX.1-2024 does not
say whether write requests for more than {PIPE_BUF} bytes are atomic, but requires that writes of {PIPE_BUF} or fewer bytes shall
be atomic.
Blocking/immediate: Blocking is only possible with O_NONBLOCK clear. If there is enough space for all the data requested
to be written immediately, the implementation should do so. Otherwise, the calling thread may block; that is, pause until enough
space is available for writing. The effective size of a pipe or FIFO (the maximum amount that can be written in one operation
without blocking) may vary dynamically, depending on the implementation, so it is not possible to specify a fixed value for it.
Complete/partial/deferred: A write request:
int fildes;
size_t nbyte;
ssize_t ret;
char *buf;
ret = write(fildes, buf, nbyte);
may return:
Complete
ret=nbyte
Partial
ret{PIPE_BUF}), this volume of
POSIX.1-2024 does not guarantee atomicity, even if ret{PIPE_BUF} and perhaps do later
writes with a smaller value, on the assumption that the effective size of the pipe or FIFO may have decreased.
Partial and deferred writes are only possible with O_NONBLOCK set.
The relations of these properties are shown in the following tables:
Write to a Pipe or FIFO with O_NONBLOCK clear
Immediately Writable:
None
Some
nbyte
nbyte{PIPE_BUF}
Blocking nbyte
Blocking nbyte
Blocking nbyte
If the O_NONBLOCK flag is clear, a write request shall block if the amount writable immediately is less than that
requested. If the flag is set (by fcntl()), a write request shall never block.
Write to a Pipe or FIFO with O_NONBLOCK set
Immediately Writable:
None
Some
nbyte
nbyte{PIPE_BUF}
-1, [EAGAIN]
, ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Realtime Extension and the POSIX Threads Extension.
Large File Summit extensions are added.
The pwrite() function is added.
Issue 6
The DESCRIPTION states that the write() function does not block the thread. Previously this said "process" rather than
"thread".
The DESCRIPTION and ERRORS sections are updated so that references to STREAMS are marked as part of the XSI STREAMS
Option Group.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX
Specification:
The DESCRIPTION now states that if write() is interrupted by a signal after it has successfully written
some data, it returns the number of bytes written. In the POSIX.1-1988 standard, it was optional whether write() returned
the number of bytes written, or whether it returned -1 with errno set to [EINTR]. This is a FIPS requirement.
The following changes are made to support large files:
For regular files, no data transfer occurs past the offset maximum established in the open file description
associated with the fildes.
A second [EFBIG] error condition is added.
The [EIO] error condition is added.
The [EPIPE] error condition is added for when a pipe has only one end open.
The [ENXIO] optional error condition is added.
Text referring to sockets is added to the DESCRIPTION.
The following changes were made to align with the IEEE P1003.1a draft standard:
The effect of reading zero bytes is clarified.
The DESCRIPTION is updated for alignment with IEEE Std 1003.1j-2000 by specifying that write()
results are unspecified for typed memory objects.
The following error conditions are added for operations on sockets: [EAGAIN], [EWOULDBLOCK], [ECONNRESET],
[ENOTCONN], and [EPIPE].
The [EIO] error is made optional.
The [ENOBUFS] error is added for sockets.
The following error conditions are added for operations on sockets: [EACCES], [ENETDOWN], and [ENETUNREACH].
The writev() function is split out into a separate reference
page.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/146 is applied, updating text in the ERRORS section
from "a SIGPIPE signal is generated to the calling process" to "a SIGPIPE signal shall also be sent to the thread".
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/147 is applied, making a correction to the
RATIONALE.
Issue 7
The pwrite() function is moved from the XSI option to the Base.
Functionality relating to the XSI STREAMS option is marked obsolescent.
SD5-XSH-ERN-160 is applied, updating the DESCRIPTION to clarify the requirements for the pwrite() function,
and to change the use of the phrase "file pointer" to "file offset".
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0742 [219], XSH/TC1-2008/0743 [215], XSH/TC1-2008/0744 [79],
and XSH/TC1-2008/0745 [215] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0401 [676,710] and XSH/TC2-2008/0402 [966] are applied.
Issue 8
Austin Group Defect 308 is applied, clarifying the handling of [EFBIG] errors.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
Austin Group Defect 1430 is applied, clarifying that requirements relating to data interleaving on pipes and FIFOs
apply to write operations in other threads, not just other processes, and changing some uses of "pipe" to "pipe or FIFO".
Austin Group Defect 1669 is applied, removing XSI shading from part of the [EFBIG] error relating to the file size
limit for the process.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/aio_suspend.html =====
aio_suspend
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
aio_suspend — wait for an asynchronous I/O request
SYNOPSIS
#include
int aio_suspend(const struct aiocb *const list[], int nent,
const struct timespec *timeout);
DESCRIPTION
The aio_suspend() function shall suspend the calling thread until at least one of the asynchronous I/O operations
referenced by the list argument has completed, until a signal interrupts the function, or, if timeout is not NULL,
until the time interval specified by timeout has passed. If any of the aiocb structures in the list correspond to
completed asynchronous I/O operations (that is, the error status for the operation is not equal to [EINPROGRESS]) at the time of
the call, the function shall return without suspending the calling thread. The list argument is an array of pointers to
asynchronous I/O control blocks. The nent argument indicates the number of elements in the array. Each aiocb
structure pointed to has been used in initiating an asynchronous I/O request via aio_read(), aio_write(), or lio_listio(). This array may contain null pointers, which are ignored. If this array
contains pointers that refer to aiocb structures that have not been used in submitting asynchronous I/O, the effect is
undefined.
If the time interval indicated in the timespec structure pointed to by timeout passes before any of the I/O
operations referenced by list are completed, then aio_suspend() shall return with an error. The clock that is used to
measure this time interval shall be the CLOCK_MONOTONIC clock.
RETURN VALUE
If the aio_suspend() function returns after one or more asynchronous I/O operations have completed, the function shall
return zero. Otherwise, the function shall return a value of -1 and set errno to indicate the error.
The application may determine which asynchronous I/O completed by scanning the associated error and return status using aio_error() and aio_return(),
respectively.
ERRORS
The aio_suspend() function shall fail if:
[EAGAIN]
No asynchronous I/O indicated in the list referenced by list completed in the time interval indicated by
timeout.
[EINTR]
A signal interrupted the aio_suspend() function. Note that, since each asynchronous I/O operation may possibly provoke a
signal when it completes, this error return may be caused by the completion of one (or more) of the very I/O operations being
awaited.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
aio_read(), aio_write(),
lio_listio()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the
Asynchronous Input and Output option.
The APPLICATION USAGE section is added.
The DESCRIPTION is updated for alignment with IEEE Std 1003.1j-2000 by specifying that the CLOCK_MONOTONIC clock, if
supported, is used.
Issue 7
The aio_suspend() function is moved from the Asynchronous Input and Output option to the Base.
Issue 8
Austin Group Defect 1346 is applied, requiring support for Monotonic Clock.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sigwait.html =====
sigwait
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sigwait — wait for queued signals
SYNOPSIS
[CX]  #include
int sigwait(const sigset_t *restrict set, int *restrict sig);
DESCRIPTION
The sigwait() function shall select a pending signal from set, atomically clear it from the system's set of
pending signals, and return that signal number in the location referenced by sig. If prior to the call to sigwait()
there are multiple pending instances of a single signal number, it is implementation-defined whether upon successful return there
are any remaining pending signals for that signal number. If the implementation supports queued signals and there are multiple
signals queued for the signal number selected, the first such queued signal shall cause a return from sigwait() and the
remainder shall remain queued. If no signal in set is pending at the time of the call, the thread shall be suspended until
one or more becomes pending. The signals defined by set shall have been blocked at the time of the call to sigwait();
otherwise, the behavior is undefined. The effect of sigwait() on the signal actions for the signals in set is
unspecified.
If more than one thread is using sigwait() to wait for the same signal, no more than one of these threads shall return
from sigwait() with the signal number. If more than a single thread is blocked in sigwait() for a signal when that
signal is generated for the process, it is unspecified which of the waiting threads returns from sigwait(). If the signal is
generated for a specific thread, as by pthread_kill(), only that thread shall
return.
Should any of the multiple pending signals in the range SIGRTMIN to SIGRTMAX be selected, it shall be the lowest numbered one.
The selection order between realtime and non-realtime signals, or between multiple pending non-realtime signals, is
unspecified.
RETURN VALUE
Upon successful completion, sigwait() shall store the signal number of the received signal at the location referenced by
sig and return zero. Otherwise, an error number shall be returned to indicate the error.
ERRORS
The sigwait() function may fail if:
[EINVAL]
The set argument contains an invalid or unsupported signal number.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
To provide a convenient way for a thread to wait for a signal, this volume of POSIX.1-2024 provides the sigwait()
function. For most cases where a thread has to wait for a signal, the sigwait() function should be quite convenient,
efficient, and adequate.
However, requests were made for a lower-level primitive than sigwait() and for semaphores that could be used by threads.
After some consideration, threads were allowed to use semaphores and sem_post() was
defined to be async-signal-safe.
In summary, when it is necessary for code run in response to an asynchronous signal to notify a thread, sigwait() should
be used to handle the signal. Alternatively, if the implementation provides semaphores, they also can be used, either following
sigwait() or from within a signal handling routine previously registered with sigaction().
FUTURE DIRECTIONS
None.
SEE ALSO
2.4 Signal Concepts, 2.8.1 Realtime Signals, pause(), pthread_sigmask(),
sigaction(), sigpending(),
sigsuspend(), sigtimedwait()
XBD ,
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension and the POSIX Threads Extension.
Issue 6
The restrict keyword is added to the sigwait() prototype for alignment with the ISO/IEC 9899:1999
standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/131 is applied, updating the DESCRIPTION to state that if more
than a single thread is blocked in sigwait(), it is unspecified which of the waiting threads returns, and that if a signal
is generated for a specific thread only that thread shall return.
Issue 7
Functionality relating to the Realtime Signals Extension option is moved to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0584 [76] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcstok.html =====
wcstok
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcstok — split a wide-character string into tokens
SYNOPSIS
#include
wchar_t *wcstok(wchar_t *restrict ws1, const wchar_t *restrict ws2,
wchar_t **restrict ptr);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
A sequence of calls to wcstok() shall break the wide-character string pointed to by ws1 into a sequence of tokens,
each of which shall be delimited by a wide-character code from the wide-character string pointed to by ws2. The ptr
argument points to a caller-provided wchar_t pointer into which the wcstok() function shall store information
necessary for it to continue scanning the same wide-character string.
The first call in the sequence has ws1 as its first argument, and is followed by calls with a null pointer as their first
argument. The separator string pointed to by ws2 may be different from call to call.
The first call in the sequence shall search the wide-character string pointed to by ws1 for the first wide-character code
that is not contained in the current separator string pointed to by ws2. If no such wide-character code is found,
then there are no tokens in the wide-character string pointed to by ws1 and wcstok() shall return a null pointer. If
such a wide-character code is found, it shall be the start of the first token.
The wcstok() function shall then search from there for a wide-character code that is contained in the current
separator string. If no such wide-character code is found, the current token extends to the end of the wide-character string
pointed to by ws1, and subsequent searches for a token shall return a null pointer. If such a wide-character code is found,
it shall be overwritten by a null wide character, which terminates the current token. The wcstok() function shall save a
pointer to the following wide-character code, from which the next search for a token shall start.
Each subsequent call, with a null pointer as the value of the first argument, shall start searching from the saved pointer and
behave as described above.
The implementation shall behave as if no function calls wcstok().
[CX]  The
wcstok() function shall not change the setting of errno on valid input.
RETURN VALUE
Upon successful completion, the wcstok() function shall return a pointer to the first wide-character code of a token.
Otherwise, if there is no token, wcstok() shall return a null pointer.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 4.
Issue 5
Aligned with ISO/IEC 9899:1990/Amendment 1:1995 (E). Specifically, a third argument is added to the definition of
wcstok() in the SYNOPSIS.
Issue 6
The wcstok() prototype is updated for alignment with the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that wcstok() does not change the setting of errno on
valid input.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/log10f.html =====
log10
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
log10, log10f, log10l — base 10 logarithm function
SYNOPSIS
#include
double log10(double x);
float log10f(float x);
long double log10l(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the base 10 logarithm of their argument x, log10(x).
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the base 10 logarithm of x.
If x is ±0, a pole error shall occur and log10(), log10f(), and log10l() shall return -HUGE_VAL,
-HUGE_VALF, and -HUGE_VALL, respectively.
For finite values of x that are less than 0, [MX]   or if x is -Inf,  a domain error shall occur, and [MX]   either a NaN (if supported), or   an implementation-defined value shall be returned.
[MX]  If
x is NaN, a NaN shall be returned.
If x is 1, +0 shall be returned.
If x is +Inf, +Inf shall be returned.
ERRORS
These functions shall fail if: