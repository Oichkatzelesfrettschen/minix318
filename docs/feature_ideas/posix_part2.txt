pthread_cond_wait()
pthread_condattr_destroy()
pthread_condattr_getclock()
pthread_condattr_getpshared()
pthread_condattr_init()
pthread_condattr_setclock()
pthread_condattr_setpshared()
pthread_create()
pthread_detach()
pthread_equal()
pthread_exit()
pthread_getcpuclockid()
pthread_getschedparam()
pthread_getspecific()
pthread_join()
pthread_key_create()
pthread_key_delete()
pthread_kill()
pthread_mutex_clocklock()
pthread_mutex_consistent()
pthread_mutex_destroy()
pthread_mutex_getprioceiling()
pthread_mutex_init()
pthread_mutex_lock()
pthread_mutex_setprioceiling()
pthread_mutex_timedlock()
pthread_mutex_trylock()
pthread_mutex_unlock()
pthread_mutexattr_destroy()
pthread_mutexattr_getprioceiling()
pthread_mutexattr_getprotocol()
pthread_mutexattr_getpshared()
pthread_mutexattr_getrobust()
pthread_mutexattr_gettype()
pthread_mutexattr_init()
pthread_mutexattr_setprioceiling()
pthread_mutexattr_setprotocol()
pthread_mutexattr_setpshared()
pthread_mutexattr_setrobust()
pthread_mutexattr_settype()
pthread_once()
pthread_rwlock_clockrdlock()
pthread_rwlock_clockwrlock()
pthread_rwlock_destroy()
pthread_rwlock_init()
pthread_rwlock_rdlock()
pthread_rwlock_timedrdlock()
pthread_rwlock_timedwrlock()
pthread_rwlock_tryrdlock()
pthread_rwlock_trywrlock()
pthread_rwlock_unlock()
pthread_rwlock_wrlock()
pthread_rwlockattr_destroy()
pthread_rwlockattr_getpshared()
pthread_rwlockattr_init()
pthread_rwlockattr_setpshared()
pthread_self()
pthread_setcancelstate()
pthread_setcanceltype()
pthread_setschedparam()
pthread_setschedprio()
pthread_setspecific()
pthread_sigmask()
pthread_spin_destroy()
pthread_spin_init()
pthread_spin_lock()
pthread_spin_trylock()
pthread_spin_unlock()
pthread_testcancel()
ptsname()
ptsname_r()
putc()
putc_unlocked()
putchar()
putchar_unlocked()
putenv()
puts()
pututxline()
putwc()
putwchar()
pwrite()
qsort()
qsort_r()
quick_exit()
raise()
rand()
random()
read()
readdir()
readdir_r()
readlink()
readlinkat()
readv()
realloc()
reallocarray()
realpath()
recv()
recvfrom()
recvmsg()
regcomp()
regerror()
regexec()
regfree()
remainder()
remainderf()
remainderl()
remove()
remque()
remquo()
remquof()
remquol()
rename()
renameat()
rewind()
rewinddir()
rint()
rintf()
rintl()
rmdir()
round()
roundf()
roundl()
scalbln()
scalblnf()
scalblnl()
scalbn()
scalbnf()
scalbnl()
scandir()
scanf()
sched_get_priority_max()
sched_get_priority_min()
sched_getparam()
sched_getscheduler()
sched_rr_get_interval()
sched_setparam()
sched_setscheduler()
sched_yield()
secure_getenv()
seed48()
seekdir()
select()
sem_clockwait()
sem_close()
sem_destroy()
sem_getvalue()
sem_init()
sem_open()
sem_post()
sem_timedwait()
sem_trywait()
sem_unlink()
sem_wait()
semctl()
semget()
semop()
send()
sendmsg()
sendto()
setbuf()
setegid()
setenv()
seteuid()
setgid()
setgrent()
sethostent()
setjmp()
setkey()
setlocale()
setlogmask()
setnetent()
setpgid()
setpriority()
setprotoent()
setpwent()
setregid()
setresgid()
setresuid()
setreuid()
setrlimit()
setservent()
setsid()
setsockopt()
setstate()
setuid()
setutxent()
setvbuf()
shm_open()
shm_unlink()
shmat()
shmctl()
shmdt()
shmget()
shutdown()
sig2str()
sigaction()
sigaddset()
sigaltstack()
sigdelset()
sigemptyset()
sigfillset()
sigismember()
siglongjmp()
signal()
signbit()
signgam
sigpending()
sigprocmask()
sigqueue()
sigsetjmp()
sigsuspend()
sigtimedwait()
sigwait()
sigwaitinfo()
sin()
sinf()
sinh()
sinhf()
sinhl()
sinl()
sleep()
snprintf()
sockatmark()
socket()
socketpair()
sprintf()
sqrt()
sqrtf()
sqrtl()
srand()
srand48()
srandom()
sscanf()
stat()
statvfs()
stderr
stdin
stdout
stpcpy()
stpncpy()
str2sig()
strcasecmp()
strcasecmp_l()
strcat()
strchr()
strcmp()
strcoll()
strcoll_l()
strcpy()
strcspn()
strdup()
strerror()
strerror_l()
strerror_r()
strfmon()
strfmon_l()
strftime()
strftime_l()
strlcat()
strlcpy()
strlen()
strncasecmp()
strncasecmp_l()
strncat()
strncmp()
strncpy()
strndup()
strnlen()
strpbrk()
strptime()
strrchr()
strsignal()
strspn()
strstr()
strtod()
strtof()
strtoimax()
strtok()
strtok_r()
strtol()
strtold()
strtoll()
strtoul()
strtoull()
strtoumax()
strxfrm()
strxfrm_l()
swab()
swprintf()
swscanf()
symlink()
symlinkat()
sync()
sysconf()
syslog()
system()
tan()
tanf()
tanh()
tanhf()
tanhl()
tanl()
tcdrain()
tcflow()
tcflush()
tcgetattr()
tcgetpgrp()
tcgetsid()
tcgetwinsize()
tcsendbreak()
tcsetattr()
tcsetpgrp()
tcsetwinsize()
tdelete()
telldir()
textdomain()
tfind()
tgamma()
tgammaf()
tgammal()
thrd_create()
thrd_current()
thrd_detach()
thrd_equal()
thrd_exit()
thrd_join()
thrd_sleep()
thrd_yield()
time()
timer_create()
timer_delete()
timer_getoverrun()
timer_gettime()
timer_settime()
times()
timespec_get()
timezone
tmpfile()
tmpnam()
tolower()
tolower_l()
toupper()
toupper_l()
towctrans()
towctrans_l()
towlower()
towlower_l()
towupper()
towupper_l()
trunc()
truncate()
truncf()
truncl()
tsearch()
tss_create()
tss_delete()
tss_get()
tss_set()
ttyname()
ttyname_r()
twalk()
tzname
tzset()
umask()
uname()
ungetc()
ungetwc()
unlink()
unlinkat()
unlockpt()
unsetenv()
uselocale()
utimensat()
utimes()
va_arg()
va_copy()
va_end()
va_start()
vasprintf()
vdprintf()
vfprintf()
vfscanf()
vfwprintf()
vfwscanf()
vprintf()
vscanf()
vsnprintf()
vsprintf()
vsscanf()
vswprintf()
vswscanf()
vwprintf()
vwscanf()
wait()
waitid()
waitpid()
wcpcpy()
wcpncpy()
wcrtomb()
wcscasecmp()
wcscasecmp_l()
wcscat()
wcschr()
wcscmp()
wcscoll()
wcscoll_l()
wcscpy()
wcscspn()
wcsdup()
wcsftime()
wcslcat()
wcslcpy()
wcslen()
wcsncasecmp()
wcsncasecmp_l()
wcsncat()
wcsncmp()
wcsncpy()
wcsnlen()
wcsnrtombs()
wcspbrk()
wcsrchr()
wcsrtombs()
wcsspn()
wcsstr()
wcstod()
wcstof()
wcstoimax()
wcstok()
wcstol()
wcstold()
wcstoll()
wcstombs()
wcstoul()
wcstoull()
wcstoumax()
wcswidth()
wcsxfrm()
wcsxfrm_l()
wctob()
wctomb()
wctrans()
wctrans_l()
wctype()
wctype_l()
wcwidth()
wmemchr()
wmemcmp()
wmemcpy()
wmemmove()
wmemset()
wordexp()
wordfree()
wprintf()
write()
writev()
wscanf()
y0()
y1()
yn()
1243 Interfaces
===== susv5-html/idx/id.html =====
Alphabetical Index - D
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2024 The IEEE and The Open Group, All Rights reserved.
[
A
|
B
|
C
|
D
|
E
|
F
|
G
|
H
|
I
|
J
|
K
|
L
|
M
|
N
|
O
|
P
|
Q
|
R
|
S
|
T
|
U
|
V
|
W
|
X
|
Y
|
Z
| Index  ]
D
date — write the date and time
daylight, timezone, tzname, tzset — set timezone conversion information
dbm_clearerr(), dbm_close, dbm_delete, dbm_error, dbm_fetch, dbm_firstkey, dbm_nextkey, dbm_open, dbm_store — database functions
dbm_close(), dbm_clearerr, dbm_delete, dbm_error, dbm_fetch, dbm_firstkey, dbm_nextkey, dbm_open, dbm_store — database functions
dbm_delete(), dbm_clearerr, dbm_close, dbm_error, dbm_fetch, dbm_firstkey, dbm_nextkey, dbm_open, dbm_store — database functions
dbm_error(), dbm_clearerr, dbm_close, dbm_delete, dbm_fetch, dbm_firstkey, dbm_nextkey, dbm_open, dbm_store — database functions
dbm_fetch(), dbm_clearerr, dbm_close, dbm_delete, dbm_error, dbm_firstkey, dbm_nextkey, dbm_open, dbm_store — database functions
dbm_firstkey(), dbm_clearerr, dbm_close, dbm_delete, dbm_error, dbm_fetch, dbm_nextkey, dbm_open, dbm_store — database functions
dbm_nextkey(), dbm_clearerr, dbm_close, dbm_delete, dbm_error, dbm_fetch, dbm_firstkey, dbm_open, dbm_store — database functions
dbm_open(), dbm_clearerr, dbm_close, dbm_delete, dbm_error, dbm_fetch, dbm_firstkey, dbm_nextkey, dbm_store — database functions
dbm_store(), dbm_clearerr, dbm_close, dbm_delete, dbm_error, dbm_fetch, dbm_firstkey, dbm_nextkey, dbm_open — database functions
dcgettext(), dgettext, dgettext_l, dcgettext_l, gettext, gettext_l, ngettext, ngettext_l, dngettext, dngettext_l, dcngettext, dcngettext_l — message handling functions
dcgettext_l(), dgettext, dgettext_l, dcgettext, gettext, gettext_l, ngettext, ngettext_l, dngettext, dngettext_l, dcngettext, dcngettext_l — message handling functions
dcngettext(), dgettext, dgettext_l, dcgettext, dcgettext_l, gettext, gettext_l, ngettext, ngettext_l, dngettext, dngettext_l, dcngettext_l — message handling functions
dcngettext_l(), dgettext, dgettext_l, dcgettext, dcgettext_l, gettext, gettext_l, ngettext, ngettext_l, dngettext, dngettext_l, dcngettext — message handling functions
dd — convert and copy a file
delta — make a delta (change) to an SCCS file (DEVELOPMENT)
devctl.h — device control
df — report free disk space
dgettext(), dgettext_l, dcgettext, dcgettext_l, gettext, gettext_l, ngettext, ngettext_l, dngettext, dngettext_l, dcngettext, dcngettext_l — message handling functions
dgettext_l(), dgettext, dcgettext, dcgettext_l, gettext, gettext_l, ngettext, ngettext_l, dngettext, dngettext_l, dcngettext, dcngettext_l — message handling functions
diff — compare two files
difftime() — compute the difference between two calendar time values
dirent.h — format of directory entries
dirfd() — extract the file descriptor used by a DIR stream
dirname — return the directory portion of a pathname
dirname() — report the parent directory name of a file pathname
div() — compute the quotient and remainder of an integer division
dladdr() — get information relating to an address
dlclose() — close a symbol table handle
dlerror() — get diagnostic information
dlfcn.h — dynamic linking
dlopen() — open a symbol table handle
dlsym() — get the address of a symbol from a symbol table handle
dngettext(), dgettext, dgettext_l, dcgettext, dcgettext_l, gettext, gettext_l, ngettext, ngettext_l, dngettext_l, dcngettext, dcngettext_l — message handling functions
dngettext_l(), dgettext, dgettext_l, dcgettext, dcgettext_l, gettext, gettext_l, ngettext, ngettext_l, dngettext, dcngettext, dcngettext_l — message handling functions
dot — execute commands in the current environment
dprintf(), asprintf, fprintf, printf, snprintf, sprintf — print formatted output
drand48(), erand48, jrand48, lcong48, lrand48, mrand48, nrand48, seed48, srand48 — generate uniformly distributed pseudo-random numbers
du — estimate file space usage
dup(), dup2, dup3 — duplicate an open file descriptor
dup2(), dup, dup3 — duplicate an open file descriptor
dup3(), dup, dup2 — duplicate an open file descriptor
duplocale() — duplicate a locale object
Topics
3. Definitions
3.96 Datagram
3.97 Data Race
3.98 Data Segment
3.99 Decimal-Point Character
3.100 Declaration Utility
3.101 Device
3.102 Device ID
3.103 Directory
3.104 Directory Entry (or Hard Link)
3.105 Directory Stream
3.106 Disarm (a Timer)
3.107 Display
3.108 Display Line
3.109 Dollar-Sign Character ()
3.110 Dot
3.111 Dot-Dot
3.112 Dot-Po File
3.113 Double-Quote Character
3.114 Downshifting
3.115 Driver
4.3 Default Initialization
4.4 Directory Operations
4.5 Directory Protection
10. Directory Structure and Devices
10.1 Directory Structure and Files
Copyright © 2024 The IEEE and The Open Group, All Rights Reserved
===== susv5-html/idx/xsh.html =====
System Interfaces
System Interfaces
Introduction
General Information
System Interfaces
===== susv5-html/idx/ih.html =====
Alphabetical Index - H
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2024 The IEEE and The Open Group, All Rights reserved.
[
A
|
B
|
C
|
D
|
E
|
F
|
G
|
H
|
I
|
J
|
K
|
L
|
M
|
N
|
O
|
P
|
Q
|
R
|
S
|
T
|
U
|
V
|
W
|
X
|
Y
|
Z
| Index  ]
H
hash — remember or report utility locations
hcreate(), hdestroy, hsearch — manage hash search table
hdestroy(), hcreate, hsearch — manage hash search table
head — copy the first part of files
hsearch(), hcreate, hdestroy — manage hash search table
htobe16(), be16toh, be32toh, be64toh, htobe32, htobe64, htole16, htole32, htole64, le16toh, le32toh, le64toh — convert values between host and specified byte order
htobe32(), be16toh, be32toh, be64toh, htobe16, htobe64, htole16, htole32, htole64, le16toh, le32toh, le64toh — convert values between host and specified byte order
htobe64(), be16toh, be32toh, be64toh, htobe16, htobe32, htole16, htole32, htole64, le16toh, le32toh, le64toh — convert values between host and specified byte order
htole16(), be16toh, be32toh, be64toh, htobe16, htobe32, htobe64, htole32, htole64, le16toh, le32toh, le64toh — convert values between host and specified byte order
htole32(), be16toh, be32toh, be64toh, htobe16, htobe32, htobe64, htole16, htole64, le16toh, le32toh, le64toh — convert values between host and specified byte order
htole64(), be16toh, be32toh, be64toh, htobe16, htobe32, htobe64, htole16, htole32, le16toh, le32toh, le64toh — convert values between host and specified byte order
htonl(), htons, ntohl, ntohs — convert values between host and network byte order
htons(), htonl, ntohl, ntohs — convert values between host and network byte order
hypot(), hypotf, hypotl — Euclidean distance function
hypotf(), hypot, hypotl — Euclidean distance function
hypotl(), hypot, hypotf — Euclidean distance function
Topics
3.167 Hard Limit
3.168 Hard Link
3.169 Hole
3.170 Home Directory
3.171 Host Byte Order
4.13 Host and Network Byte Orders
Copyright © 2024 The IEEE and The Open Group, All Rights Reserved
===== susv5-html/idx/xcu.html =====
Shell & Utilities
Shell & Utilities
1. Introduction
2. Shell Command Language
3. Utilities
===== susv5-html/idx/ftoc.html =====
Full Tables of Contents
Full Tables of Contents by Volume
Base Definitions
Shell & Utilities
System Interfaces
Rationale
===== susv5-html/idx/utilities.html =====
Utilities
Utilities
admin
alias
ar
asa
at
awk
basename
batch
bc
bg
c17
cal
cat
cd
cflow
chgrp
chmod
chown
cksum
cmp
comm
command
compress
cp
crontab
csplit
ctags
cut
cxref
date
dd
delta
df
diff
dirname
du
echo
ed
env
ex
expand
expr
false
fc
fg
file
find
fold
fuser
gencat
get
getconf
getopts
gettext
grep
hash
head
iconv
id
ipcrm
ipcs
jobs
join
kill
lex
link
ln
locale
localedef
logger
logname
lp
ls
m4
mailx
make
man
mesg
mkdir
mkfifo
more
msgfmt
mv
newgrp
ngettext
nice
nl
nm
nohup
od
paste
patch
pathchk
pax
pr
printf
prs
ps
pwd
read
readlink
realpath
renice
rm
rmdel
rmdir
sact
sccs
sed
sh
sleep
sort
split
strings
strip
stty
tabs
tail
talk
tee
test
time
timeout
touch
tput
tr
true
tsort
tty
type
ulimit
umask
unalias
uname
uncompress
unexpand
unget
uniq
unlink
uucp
uudecode
uuencode
uustat
uux
val
vi
wait
wc
what
who
write
xargs
xgettext
yacc
zcat
===== susv5-html/idx/ic.html =====
Alphabetical Index - C
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2024 The IEEE and The Open Group, All Rights reserved.
[
A
|
B
|
C
|
D
|
E
|
F
|
G
|
H
|
I
|
J
|
K
|
L
|
M
|
N
|
O
|
P
|
Q
|
R
|
S
|
T
|
U
|
V
|
W
|
X
|
Y
|
Z
| Index  ]
C
c16rtomb(), c32rtomb — convert a Unicode character code to a character (restartable)
c17 — compile standard C programs
c32rtomb(), c16rtomb — convert a Unicode character code to a character (restartable)
cabs(), cabsf, cabsl — return a complex absolute value
cabsf(), cabs, cabsl — return a complex absolute value
cabsl(), cabs, cabsf — return a complex absolute value
cacos(), cacosf, cacosl — complex arc cosine functions
cacosf(), cacos, cacosl — complex arc cosine functions
cacosh(), cacoshf, cacoshl — complex arc hyperbolic cosine functions
cacoshf(), cacosh, cacoshl — complex arc hyperbolic cosine functions
cacoshl(), cacosh, cacoshf — complex arc hyperbolic cosine functions
cacosl(), cacos, cacosf — complex arc cosine functions
cal — print a calendar
calloc() — a memory allocator
call_once() — dynamic package initialization
carg(), cargf, cargl — complex argument functions
cargf(), carg, cargl — complex argument functions
cargl(), carg, cargf — complex argument functions
casin(), casinf, casinl — complex arc sine functions
casinf(), casin, casinl — complex arc sine functions
casinh(), casinhf, casinhl — complex arc hyperbolic sine functions
casinhf(), casinh, casinhl — complex arc hyperbolic sine functions
casinhl(), casinh, casinhf — complex arc hyperbolic sine functions
casinl(), casin, casinf — complex arc sine functions
cat — concatenate and print files
catan(), catanf, catanl — complex arc tangent functions
catanf(), catan, catanl — complex arc tangent functions
catanh(), catanhf, catanhl — complex arc hyperbolic tangent functions
catanhf(), catanh, catanhl — complex arc hyperbolic tangent functions
catanhl(), catanh, catanhf — complex arc hyperbolic tangent functions
catanl(), catan, catanf — complex arc tangent functions
catclose() — close a message catalog descriptor
catgets() — read a program message
catopen() — open a message catalog
cbrt(), cbrtf, cbrtl — cube root functions
cbrtf(), cbrt, cbrtl — cube root functions
cbrtl(), cbrt, cbrtf — cube root functions
ccos(), ccosf, ccosl — complex cosine functions
ccosf(), ccos, ccosl — complex cosine functions
ccosh(), ccoshf, ccoshl — complex hyperbolic cosine functions
ccoshf(), ccosh, ccoshl — complex hyperbolic cosine functions
ccoshl(), ccosh, ccoshf — complex hyperbolic cosine functions
ccosl(), ccos, ccosf — complex cosine functions
cd — change the working directory
ceil(), ceilf, ceill — ceiling value function
ceilf(), ceil, ceill — ceiling value function
ceill(), ceil, ceilf — ceiling value function
cexp(), cexpf, cexpl — complex exponential functions
cexpf(), cexp, cexpl — complex exponential functions
cexpl(), cexp, cexpf — complex exponential functions
cfgetispeed() — get input baud rate
cfgetospeed() — get output baud rate
cflow — generate a C-language flowgraph (DEVELOPMENT)
cfsetispeed() — set input baud rate
cfsetospeed() — set output baud rate
chdir() — change working directory
chgrp — change the file group ownership
chmod — change the file modes
chmod(), fchmodat — change mode of a file
chown — change the file ownership
chown(), fchownat — change owner and group of a file
cimag(), cimagf, cimagl — complex imaginary functions
cimagf(), cimag, cimagl — complex imaginary functions
cimagl(), cimag, cimagf — complex imaginary functions
cksum — write file checksums and sizes
clearerr() — clear indicators on a stream
clock() — report CPU time used
clock_getcpuclockid() — access a process CPU-time clock (ADVANCED REALTIME)
clock_getres(), clock_gettime, clock_settime — clock and timer functions
clock_gettime(), clock_getres, clock_settime — clock and timer functions
clock_nanosleep() — high resolution sleep with specifiable clock
clock_settime(), clock_getres, clock_gettime — clock and timer functions
clog(), clogf, clogl — complex natural logarithm functions
clogf(), clog, clogl — complex natural logarithm functions
clogl(), clog, clogf — complex natural logarithm functions
close(), posix_close — close a file descriptor
closedir() — close a directory stream
closelog(), openlog, setlogmask, syslog — control system log
cmp — compare two files
CMPLX(), CMPLXF, CMPLXL — make a complex value
CMPLXF(), CMPLX, CMPLXL — make a complex value
CMPLXL(), CMPLX, CMPLXF — make a complex value
cnd_broadcast(), cnd_signal — broadcast or signal a condition
cnd_destroy(), cnd_init — destroy and initialize condition variables
cnd_init(), cnd_destroy — destroy and initialize condition variables
cnd_signal(), cnd_broadcast — broadcast or signal a condition
cnd_timedwait(), cnd_wait — wait on a condition
cnd_wait(), cnd_timedwait — wait on a condition
colon — null utility
comm — select or reject lines common to two files
command — execute a simple command
complex.h — complex arithmetic
compress, uncompress, zcat — compress and decompress data
confstr() — get configurable variables
conj(), conjf, conjl — complex conjugate functions
conjf(), conj, conjl — complex conjugate functions
conjl(), conj, conjf — complex conjugate functions
connect() — connect a socket
continue — continue for, while, or until loop
copysign(), copysignf, copysignl — number manipulation function
copysignf(), copysign, copysignl — number manipulation function
copysignl(), copysign, copysignf — number manipulation function
cos(), cosf, cosl — cosine function
cosf(), cos, cosl — cosine function
cosh(), coshf, coshl — hyperbolic cosine functions
coshf(), cosh, coshl — hyperbolic cosine functions
coshl(), cosh, coshf — hyperbolic cosine functions
cosl(), cos, cosf — cosine function
cp — copy files
cpio.h — cpio archive values
cpow(), cpowf, cpowl — complex power functions
cpowf(), cpow, cpowl — complex power functions
cpowl(), cpow, cpowf — complex power functions
cproj(), cprojf, cprojl — complex projection functions
cprojf(), cproj, cprojl — complex projection functions
cprojl(), cproj, cprojf — complex projection functions
creal(), crealf, creall — complex real functions
crealf(), creal, creall — complex real functions
creall(), creal, crealf — complex real functions
creat() — create a new file or rewrite an existing one
crontab — schedule periodic background work
crypt() — password hashing function (CRYPT)
csin(), csinf, csinl — complex sine functions
csinf(), csin, csinl — complex sine functions
csinh(), csinhf, csinhl — complex hyperbolic sine functions
csinhf(), csinh, csinhl — complex hyperbolic sine functions
csinhl(), csinh, csinhf — complex hyperbolic sine functions
csinl(), csin, csinf — complex sine functions
csplit — split files based on context
csqrt(), csqrtf, csqrtl — complex square root functions
csqrtf(), csqrt, csqrtl — complex square root functions
csqrtl(), csqrt, csqrtf — complex square root functions
ctags — create a tags file (DEVELOPMENT)
ctan(), ctanf, ctanl — complex tangent functions
ctanf(), ctan, ctanl — complex tangent functions
ctanh(), ctanhf, ctanhl — complex hyperbolic tangent functions
ctanhf(), ctanh, ctanhl — complex hyperbolic tangent functions
ctanhl(), ctanh, ctanhf — complex hyperbolic tangent functions
ctanl(), ctan, ctanf — complex tangent functions
ctermid() — generate a pathname for the controlling terminal
ctime() — convert a time value to a date and time string
ctime_r(), ctime — convert a time value to a date and time string
ctype.h — character types
cut — cut out selected fields of each line of a file
cxref — generate a C-language program cross-reference table (DEVELOPMENT)
Topics
2. Conformance
3.57 Carriage-Return Character ()
3.58 Character
3.59 Character Array
3.60 Character Class
3.61 Character Set
3.62 Character Special File
3.63 Character String
3.64 Child Process
3.65 Circumflex Character ()
3.66 Clock
3.67 Clock Jump
3.68 Clock Tick
3.69 Code Block
3.70 Coded Character Set
3.71 Codeset
3.72 Collating Element
3.73 Collation
3.74 Collation Sequence
3.75 Column Position
3.76 Command
3.77 Command Language Interpreter
3.78 Composite Graphic Symbol
3.79 Condition Variable
3.80 Connected Socket
3.81 Connection
3.82 Connection Mode
3.83 Connectionless Mode
3.84 Control Character
3.85 Control Operator
3.86 Controlling Process
3.87 Controlling Terminal
3.88 Conversion Descriptor
3.89 Core Image
3.90 CPU Time (Execution Time)
3.91 CPU-Time Clock
3.92 CPU-Time Timer
3.93 Current Job
3.94 Current Working Directory
3.95 Cursor Position
4.1 Case Insensitive Comparisons
4.2 Concurrent Execution
6. Character Set
6.2 Character Encoding
6.3 C Language Wide-Character Codes
6.4 Character Set Description File
Copyright © 2024 The IEEE and The Open Group, All Rights Reserved
===== susv5-html/idx/iv.html =====
Alphabetical Index - V
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2024 The IEEE and The Open Group, All Rights reserved.
[
A
|
B
|
C
|
D
|
E
|
F
|
G
|
H
|
I
|
J
|
K
|
L
|
M
|
N
|
O
|
P
|
Q
|
R
|
S
|
T
|
U
|
V
|
W
|
X
|
Y
|
Z
| Index  ]
V
val — validate SCCS files (DEVELOPMENT)
vasprintf(), vdprintf, vfprintf, vprintf, vsnprintf, vsprintf — format output of a stdarg argument list
va_arg(), va_copy, va_end, va_start — handle variable argument list
va_copy(), va_arg, va_end, va_start — handle variable argument list
va_end(), va_arg, va_copy, va_start — handle variable argument list
va_start(), va_arg, va_copy, va_end — handle variable argument list
vdprintf(), vasprintf, vfprintf, vprintf, vsnprintf, vsprintf — format output of a stdarg argument list
vfprintf(), vasprintf, vdprintf, vprintf, vsnprintf, vsprintf — format output of a stdarg argument list
vfscanf(), vscanf, vsscanf — format input of a stdarg argument list
vfwprintf(), vswprintf, vwprintf — wide-character formatted output of a stdarg argument list
vfwscanf(), vswscanf, vwscanf — wide-character formatted input of a stdarg argument list
vi — screen-oriented (visual) display editor
vprintf(), vasprintf, vdprintf, vfprintf, vsnprintf, vsprintf — format output of a stdarg argument list
vscanf(), vfscanf, vsscanf — format input of a stdarg argument list
vsnprintf(), vasprintf, vdprintf, vfprintf, vprintf, vsprintf — format output of a stdarg argument list
vsprintf(), vasprintf, vdprintf, vfprintf, vprintf, vsnprintf — format output of a stdarg argument list
vsscanf(), vfscanf, vscanf — format input of a stdarg argument list
vswprintf(), vfwprintf, vwprintf — wide-character formatted output of a stdarg argument list
vswscanf(), vfwscanf, vwscanf — wide-character formatted input of a stdarg argument list
vwprintf(), vfwprintf, vswprintf — wide-character formatted output of a stdarg argument list
vwscanf(), vfwscanf, vswscanf — wide-character formatted input of a stdarg argument list
Topics
3.411 Variable
3.412 Vertical-Tab Character ()
4.26 Variable Assignment
Copyright © 2024 The IEEE and The Open Group, All Rights Reserved
===== susv5-html/idx/xrat.html =====
Rationale
Rationale
Rationale for Base Definitions
Rationale for System Interfaces
Rationale for Shell & Utilities
Portability Considerations (Informative)
Subprofiling Considerations (Informative)
===== susv5-html/idx/io.html =====
Alphabetical Index - O
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2024 The IEEE and The Open Group, All Rights reserved.
[
A
|
B
|
C
|
D
|
E
|
F
|
G
|
H
|
I
|
J
|
K
|
L
|
M
|
N
|
O
|
P
|
Q
|
R
|
S
|
T
|
U
|
V
|
W
|
X
|
Y
|
Z
| Index  ]
O
od — dump files in various formats
open(), openat — open file
openat(), open — open file
opendir(), fdopendir — open directory associated with file descriptor
openlog(), closelog, setlogmask, syslog — control system log
open_memstream(), open_wmemstream — open a dynamic memory buffer stream
open_wmemstream(), open_memstream — open a dynamic memory buffer stream
optarg, getopt, opterr, optind, optopt — command option parsing
opterr, getopt, optarg, optind, optopt — command option parsing
optind, getopt, optarg, opterr, optopt — command option parsing
optopt, getopt, optarg, opterr, optind — command option parsing
Topics
2.4 Other Language-Related Specifications
3.235 Object File
3.236 Octet
3.237 OFD-Owned File Lock
3.238 Offset Maximum
3.239 Opaque Address
3.240 Open File
3.241 Open File Description
3.242 Operand
3.243 Operator
3.244 Option
3.245 Option-Argument
3.246 Orientation
3.247 Orphaned Process Group
8.3 Other Environment Variables
10.2 Output Devices and Terminal Types
Copyright © 2024 The IEEE and The Open Group, All Rights Reserved
===== susv5-html/idx/fidx6.html =====
Frame Index
Interface by  Requirement
Base POSIX
C99
Mandatory UNIX
OBsolescent
OBsolescent XSI
[Main Index]
===== susv5-html/idx/shell.html =====
Shell
Shell Command Language
2.1 Shell Introduction
2.2 Quoting
2.2.1 Escape Character (Backslash)
2.2.2 Single-Quotes
2.2.3 Double-Quotes
2.2.4 Dollar-Single-Quotes
2.3 Token Recognition
2.3.1 Alias Substitution
2.4 Reserved Words
2.5 Parameters and Variables
2.5.1 Positional Parameters
2.5.2 Special Parameters
2.5.3 Shell Variables
2.6 Word Expansions
2.6.1 Tilde Expansion
2.6.2 Parameter Expansion
Examples
2.6.3 Command Substitution
2.6.4 Arithmetic Expansion
Examples
2.6.5 Field Splitting
2.6.6 Pathname Expansion
2.6.7 Quote Removal
2.7 Redirection
2.7.1 Redirecting Input
2.7.2 Redirecting Output
2.7.3 Appending Redirected Output
2.7.4 Here-Document
Examples
2.7.5 Duplicating an Input File Descriptor
2.7.6 Duplicating an Output File Descriptor
2.7.7 Open File Descriptors for Reading and Writing
2.8 Exit Status and Errors
2.8.1 Consequences of Shell Errors
2.8.2 Exit Status for Commands
2.9 Shell Commands
2.9.1 Simple Commands
2.9.2 Pipelines
2.9.3 Lists
2.9.4 Compound Commands
2.9.5 Function Definition Command
2.10 Shell Grammar
2.10.1 Shell Grammar Lexical Conventions
2.10.2 Shell Grammar Rules
2.11 Job Control
2.12 Signals and Error Handling
2.13 Shell Execution Environment
2.14 Pattern Matching Notation
2.14.1 Patterns Matching a Single Character
2.14.2 Patterns Matching Multiple Characters
2.14.3 Patterns Used for Filename Expansion
2.15 Special Built-In Utilities
break
colon
continue
dot
eval
exec
exit
export
readonly
return
set
shift
times
trap
unset
===== susv5-html/idx/iz.html =====
Alphabetical Index - Z
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2024 The IEEE and The Open Group, All Rights reserved.
[
A
|
B
|
C
|
D
|
E
|
F
|
G
|
H
|
I
|
J
|
K
|
L
|
M
|
N
|
O
|
P
|
Q
|
R
|
S
|
T
|
U
|
V
|
W
|
X
|
Y
|
Z
| Index  ]
Z
zcat, compress, uncompress — compress and decompress data
Topics
3.426 Zombie Process
3.427 Zombie Thread
Copyright © 2024 The IEEE and The Open Group, All Rights Reserved
===== susv5-html/idx/headers.html =====
Headers Index
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024 Edition
Copyright © 2024 The IEEE and The Open Group, All Rights reserved.
Headers
aio.h - asynchronous input and output
arpa/inet.h - definitions for internet operations
assert.h - verify program assertion
complex.h - complex arithmetic
cpio.h - cpio archive values
ctype.h - character types
devctl.h - device control
dirent.h - format of directory entries
dlfcn.h - dynamic linking
endian.h - system endianness
errno.h - system error numbers
fcntl.h - file control options
fenv.h - floating-point environment
float.h - floating types
fmtmsg.h - message display structures
fnmatch.h - filename-matching types
ftw.h - file tree traversal
glob.h - pathname pattern-matching types
grp.h - group structure
iconv.h - codeset conversion facility
inttypes.h - fixed size integer types
iso646.h - alternative spellings
langinfo.h - language information constants
libgen.h - definitions for pattern matching functions
libintl.h - international messaging
limits.h - implementation-defined constants
locale.h - category macros
math.h - mathematical declarations
monetary.h - monetary types
mqueue.h - message queues (REALTIME)
ndbm.h - definitions for ndbm database operations
netdb.h - definitions for network database operations
net/if.h - sockets local interfaces
netinet/in.h - Internet address family
netinet/tcp.h - definitions for the Internet Transmission Control Protocol (TCP)
nl_types.h - data types
poll.h - definitions for the poll() function
pthread.h - threads
pwd.h - password structure
regex.h - regular expression matching types
sched.h - execution scheduling
search.h - search tables
semaphore.h - semaphores
setjmp.h - stack environment declarations
signal.h - signals
spawn.h - spawn (ADVANCED REALTIME)
stdalign.h - alignment macros
stdarg.h - handle variable argument list
stdatomic.h - atomics
stdbool.h - boolean type and values
stddef.h - standard type definitions
stdint.h - integer types
stdio.h - standard buffered input/output
stdlib.h - standard library definitions
stdnoreturn.h - noreturn macro
string.h - string operations
strings.h - string operations
sys/ipc.h - XSI interprocess communication access structure
syslog - definitions for system error logging
sys/mman.h - memory management declarations
sys/msg.h - XSI message queue structures
sys/resource.h - definitions for XSI resource operations
sys/select.h - select types
sys/sem.h - XSI semaphore facility
sys/shm.h - XSI shared memory facility
sys/socket.h - main sockets header
sys/stat.h - data returned by the stat() function
sys/statvfs.h - VFS File System information structure
sys/time.h - time types
sys/times.h - file access and modification times structure
sys/types.h - data types
sys/uio.h - definitions for vector I/O operations
sys/un.h - definitions for UNIX domain sockets
sys/utsname.h - system name structure
sys/wait.h - declarations for waiting
tar.h - extended tar definitions
termios.h - define values for termios
tgmath.h - type-generic macros
threads.h - ISO C threads
time.h - time types
uchar.h - Unicode character handling
unistd.h - standard symbolic constants and types
utmpx.h - user accounting database definitions
wchar.h - wide-character handling
wctype.h - wide-character classification and mapping utilities
wordexp.h - word-expansion types
===== susv5-html/idx/fidx7.html =====
Frame Index
Utility by Requirement
Base POSIX
POSIX UPE
Mandatory UNIX
XSI Development
[Main Index]
===== susv5-html/idx/in.html =====
Alphabetical Index - N
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2024 The IEEE and The Open Group, All Rights reserved.
[
A
|
B
|
C
|
D
|
E
|
F
|
G
|
H
|
I
|
J
|
K
|
L
|
M
|
N
|
O
|
P
|
Q
|
R
|
S
|
T
|
U
|
V
|
W
|
X
|
Y
|
Z
| Index  ]
N
nan(), nanf, nanl — return quiet NaN
nanf(), nan, nanl — return quiet NaN
nanl(), nan, nanf — return quiet NaN
nanosleep() — high resolution sleep
ndbm.h — definitions for ndbm database operations
nearbyint(), nearbyintf, nearbyintl — floating-point rounding functions
nearbyintf(), nearbyint, nearbyintl — floating-point rounding functions
nearbyintl(), nearbyint, nearbyintf — floating-point rounding functions
net/if.h — sockets local interfaces
netdb.h — definitions for network database operations
netinet/in.h — Internet address family
netinet/tcp.h — definitions for the Internet Transmission Control Protocol (TCP)
newgrp — change to a new group
newlocale() — create or modify a locale object
nextafter(), nextafterf, nextafterl, nexttoward, nexttowardf, nexttowardl — next representable floating-point number
nextafterf(), nextafter, nextafterl, nexttoward, nexttowardf, nexttowardl — next representable floating-point number
nextafterl(), nextafter, nextafterf, nexttoward, nexttowardf, nexttowardl — next representable floating-point number
nexttoward(), nextafter, nextafterf, nextafterl, nexttowardf, nexttowardl — next representable floating-point number
nexttowardf(), nextafter, nextafterf, nextafterl, nexttoward, nexttowardl — next representable floating-point number
nexttowardl(), nextafter, nextafterf, nextafterl, nexttoward, nexttowardf — next representable floating-point number
nftw() — walk a file tree
ngettext, gettext — retrieve text string from messages object
ngettext(), dgettext, dgettext_l, dcgettext, dcgettext_l, gettext, gettext_l, ngettext_l, dngettext, dngettext_l, dcngettext, dcngettext_l — message handling functions
ngettext_l(), dgettext, dgettext_l, dcgettext, dcgettext_l, gettext, gettext_l, ngettext, dngettext, dngettext_l, dcngettext, dcngettext_l — message handling functions
nice — invoke a utility with an altered nice value
nice() — change the nice value of a process
nl — line numbering filter
nl_langinfo(), nl_langinfo_l — language information
nl_langinfo_l(), nl_langinfo — language information
nl_types.h — data types
nm — write the name list of an object file (DEVELOPMENT)
nohup — invoke a utility immune to hangups
nrand48(), drand48, erand48, jrand48, lcong48, lrand48, mrand48, seed48, srand48 — generate uniformly distributed pseudo-random numbers
ntohl(), htonl, htons, ntohs — convert values between host and network byte order
ntohs(), htonl, htons, ntohl — convert values between host and network byte order
Topics
3.216 Name
3.217 NaN (Not a Number)
3.218 Native Language
3.219 Negative
3.220 Negative Response
3.221 Network
3.222 Network Address
3.223 Network Byte Order
3.224 Newline Character ()
3.225 Nice Value
3.226 Non-Blocking
3.227 Non-Spacing Characters
3.228 NUL
3.229 Null Byte
3.230 Null Pointer
3.231 Null String
3.232 Null Terminator
3.233 Null Wide-Character Code
3.234 Number-Sign Character ()
Copyright © 2024 The IEEE and The Open Group, All Rights Reserved
===== susv5-html/idx/xrat_xsh.html =====
Rationale
Rationale: System Interfaces
B.1 Introduction
B.2 General Information
B.3 System Interfaces
===== susv5-html/idx/iw.html =====
Alphabetical Index - W
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2024 The IEEE and The Open Group, All Rights reserved.
[
A
|
B
|
C
|
D
|
E
|
F
|
G
|
H
|
I
|
J
|
K
|
L
|
M
|
N
|
O
|
P
|
Q
|
R
|
S
|
T
|
U
|
V
|
W
|
X
|
Y
|
Z
| Index  ]
W
wait — await process completion
wait(), waitpid — wait for a child process to stop or terminate
waitid() — wait for a child process to change state
waitpid(), wait — wait for a child process to stop or terminate
wc — word, line, and byte or character count
wchar.h — wide-character handling
wcpcpy(), wcscpy — copy a wide-character string, returning a pointer to its end
wcpncpy(), wcsncpy — copy a fixed-size wide-character string, returning a pointer to its end
wcrtomb() — convert a wide-character code to a character (restartable)
wcscasecmp(), wcscasecmp_l, wcsncasecmp, wcsncasecmp_l — case-insensitive wide-character string comparison
wcscasecmp_l(), wcscasecmp, wcsncasecmp, wcsncasecmp_l — case-insensitive wide-character string comparison
wcscat() — concatenate two wide-character strings
wcschr() — wide-character string scanning operation
wcscmp() — compare two wide-character strings
wcscoll(), wcscoll_l — wide-character string comparison using collating information
wcscoll_l(), wcscoll — wide-character string comparison using collating information
wcscpy(), wcpcpy — copy a wide-character string, returning a pointer to its end
wcscspn() — get the length of a complementary wide substring
wcsdup() — duplicate a wide-character string
wcsftime() — convert date and time to a wide-character string
wcslcat(), wcslcpy — size-bounded wide string concatenation and copying
wcslcpy(), wcslcat — size-bounded wide string concatenation and copying
wcslen(), wcsnlen — get length of a fixed-sized wide-character string
wcsncasecmp(), wcscasecmp, wcscasecmp_l, wcsncasecmp_l — case-insensitive wide-character string comparison
wcsncasecmp_l(), wcscasecmp, wcscasecmp_l, wcsncasecmp — case-insensitive wide-character string comparison
wcsncat() — concatenate a wide-character string with part of another
wcsncmp() — compare part of two wide-character strings
wcsncpy(), wcpncpy — copy a fixed-size wide-character string, returning a pointer to its end
wcsnlen(), wcslen — get length of a fixed-sized wide-character string
wcsnrtombs(), wcsrtombs — convert a wide-character string to a character string (restartable)
wcspbrk() — scan a wide-character string for a wide-character code
wcsrchr() — wide-character string scanning operation
wcsrtombs(), wcsnrtombs — convert a wide-character string to a character string (restartable)
wcsspn() — get the length of a wide substring
wcsstr() — find a wide-character substring
wcstod(), wcstof, wcstold — convert a wide-character string to a double-precision number
wcstof(), wcstod, wcstold — convert a wide-character string to a double-precision number
wcstoimax(), wcstoumax — convert a wide-character string to an integer type
wcstok() — split a wide-character string into tokens
wcstol(), wcstoll — convert a wide-character string to a long integer
wcstold(), wcstod, wcstof — convert a wide-character string to a double-precision number
wcstoll(), wcstol — convert a wide-character string to a long integer
wcstombs() — convert a wide-character string to a character string
wcstoul(), wcstoull — convert a wide-character string to an unsigned long
wcstoull(), wcstoul — convert a wide-character string to an unsigned long
wcstoumax(), wcstoimax — convert a wide-character string to an integer type
wcswidth() — number of column positions of a wide-character string
wcsxfrm(), wcsxfrm_l — wide-character string transformation
wcsxfrm_l(), wcsxfrm — wide-character string transformation
wctob() — wide-character to single-byte conversion
wctomb() — convert a wide-character code to a character
wctrans(), wctrans_l — define character mapping
wctrans_l(), wctrans — define character mapping
wctype(), wctype_l — define character class
wctype.h — wide-character classification and mapping utilities
wctype_l(), wctype — define character class
wcwidth() — number of column positions of a wide-character code
what — identify SCCS files (DEVELOPMENT)
who — display who is on the system
wmemchr() — find a wide character in memory
wmemcmp() — compare wide characters in memory
wmemcpy() — copy wide characters in memory
wmemmove() — copy wide characters in memory with overlapping areas
wmemset() — set wide characters in memory
wordexp(), wordfree — perform word expansions
wordexp.h — word-expansion types
wordfree(), wordexp — perform word expansions
wprintf(), fwprintf, swprintf — print formatted wide-character output
write — write to another user
write(), pwrite — write on a file
writev() — write a vector
wscanf(), fwscanf, swscanf — convert formatted wide-character input
Topics
3.413 White Space
3.414 White-Space Byte
3.415 White-Space Character
3.416 White-Space Wide Character
3.417 Wide-Character Code (C Language)
3.418 Wide-Character Input/Output Functions
3.419 Wide-Character String
3.420 Word
3.421 Working Directory (or Current Working Directory)
3.422 Worldwide Portability Interface
3.423 Write
Copyright © 2024 The IEEE and The Open Group, All Rights Reserved
===== susv5-html/idx/xrat_xcu.html =====
Rationale
Rationale: Shell & Utilities
C.1 Introduction
C.2 Shell Command Language
C.3 Utilities
===== susv5-html/idx/ib.html =====
Alphabetical Index - B
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2024 The IEEE and The Open Group, All Rights reserved.
[
A
|
B
|
C
|
D
|
E
|
F
|
G
|
H
|
I
|
J
|
K
|
L
|
M
|
N
|
O
|
P
|
Q
|
R
|
S
|
T
|
U
|
V
|
W
|
X
|
Y
|
Z
| Index  ]
B
basename — return non-directory portion of a pathname
basename() — return the last component of a pathname
batch — schedule commands to be executed in a batch queue
bc — arbitrary-precision arithmetic language
be16toh(), be32toh, be64toh, htobe16, htobe32, htobe64, htole16, htole32, htole64, le16toh, le32toh, le64toh — convert values between host and specified byte order
be32toh(), be16toh, be64toh, htobe16, htobe32, htobe64, htole16, htole32, htole64, le16toh, le32toh, le64toh — convert values between host and specified byte order
be64toh(), be16toh, be32toh, htobe16, htobe32, htobe64, htole16, htole32, htole64, le16toh, le32toh, le64toh — convert values between host and specified byte order
bg — run jobs in the background
bind() — bind a name to a socket
bindtextdomain(), bind_textdomain_codeset, textdomain — text domain manipulation functions
bind_textdomain_codeset(), bindtextdomain, textdomain — text domain manipulation functions
break — exit from for, while, or until loop
bsearch() — binary search a sorted table
btowc() — single byte to wide character conversion
Topics
3.35 Background Job
3.36 Background Process
3.37 Background Process Group
3.38 Backquote Character
3.39 Backslash Character ()
3.40 Backspace Character ()
3.41 Barrier
3.42 Basename
3.43 Basic Regular Expression (BRE)
3.44 Bind
3.45 Blank Character ()
3.46 Blank Line
3.47 Blocked Process (or Thread)
3.48 Blocking
3.49 Block-Mode Terminal
3.50 Block Special File
3.51 Braces
3.52 Brackets
3.53 Broadcast
3.54 Built-In Utility (or Built-In)
3.55 Byte
3.56 Byte Input/Output Functions
9.3 Basic Regular Expressions
Copyright © 2024 The IEEE and The Open Group, All Rights Reserved
===== susv5-html/idx/it.html =====
Alphabetical Index - T
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2024 The IEEE and The Open Group, All Rights reserved.
[
A
|
B
|
C
|
D
|
E
|
F
|
G
|
H
|
I
|
J
|
K
|
L
|
M
|
N
|
O
|
P
|
Q
|
R
|
S
|
T
|
U
|
V
|
W
|
X
|
Y
|
Z
| Index  ]
T
tabs — set terminal tabs
tail — copy the last part of a file
talk — talk to another user
tan(), tanf, tanl — tangent function
tanf(), tan, tanl — tangent function
tanh(), tanhf, tanhl — hyperbolic tangent functions
tanhf(), tanh, tanhl — hyperbolic tangent functions
tanhl(), tanh, tanhf — hyperbolic tangent functions
tanl(), tan, tanf — tangent function
tar.h — extended tar definitions
tcdrain() — wait for transmission of output
tcflow() — suspend or restart the transmission or reception of data
tcflush() — flush non-transmitted output data, non-read input data, or both
tcgetattr() — get the parameters associated with the terminal
tcgetpgrp() — get the foreground process group ID
tcgetsid() — get the process group ID for the session leader for the controlling terminal
tcgetwinsize() — get the size of a terminal window
tcsendbreak() — send a break for a specific duration
tcsetattr() — set the parameters associated with the terminal
tcsetpgrp() — set the foreground process group ID
tcsetwinsize() — set the size of a terminal window
tdelete(), tfind, tsearch, twalk — manage a binary search tree
tee — duplicate standard input
telldir() — current location of a named directory stream
termios.h — define values for termios
test — evaluate expression
textdomain(), bindtextdomain, bind_textdomain_codeset — text domain manipulation functions
tfind(), tdelete, tsearch, twalk — manage a binary search tree
tgamma(), tgammaf, tgammal — compute gamma() function
tgammaf(), tgamma, tgammal — compute gamma() function
tgammal(), tgamma, tgammaf — compute gamma() function
tgmath.h — type-generic macros
thrd_create() — thread creation
thrd_current() — get the calling thread ID
thrd_detach() — detach a thread
thrd_equal() — compare thread IDs
thrd_exit() — thread termination
thrd_join() — wait for thread termination
thrd_sleep() — suspend execution for an interval
thrd_yield() — yield the processor
threads.h — ISO C threads
time — time a simple command
time() — get time
time.h — time types
timeout — execute a utility with a time limit
timer_create() — create a per-process timer
timer_delete() — delete a per-process timer
timer_getoverrun(), timer_gettime, timer_settime — per-process timers
timer_gettime(), timer_getoverrun, timer_settime — per-process timers
timer_settime(), timer_getoverrun, timer_gettime — per-process timers
times — write process times
times() — get process and waited-for child process times
timespec_get() — get time
timezone, daylight, tzname, tzset — set timezone conversion information
tmpfile() — create a temporary file
tmpnam() — create a name for a temporary file
tolower(), tolower_l — transliterate uppercase characters to lowercase
tolower_l(), tolower — transliterate uppercase characters to lowercase
touch — change file access and modification times
toupper(), toupper_l — transliterate lowercase characters to uppercase
toupper_l(), toupper — transliterate lowercase characters to uppercase
towctrans(), towctrans_l — wide-character transliteration
towctrans_l(), towctrans — wide-character transliteration
towlower(), towlower_l — transliterate uppercase wide-character code to lowercase
towlower_l(), towlower — transliterate uppercase wide-character code to lowercase
towupper(), towupper_l — transliterate lowercase wide-character code to uppercase
towupper_l(), towupper — transliterate lowercase wide-character code to uppercase
tput — change terminal characteristics
tr — translate characters
trap — trap signals
true — return true value
trunc(), truncf, truncl — round to truncated integer value
truncate() — truncate a file to a specified length
truncf(), trunc, truncl — round to truncated integer value
truncl(), trunc, truncf — round to truncated integer value
tsearch(), tdelete, tfind, twalk — manage a binary search tree
tsort — topological sort
tss_create() — thread-specific data key creation
tss_delete() — thread-specific data key deletion
tss_get(), tss_set — thread-specific data management
tss_set(), tss_get — thread-specific data management
tty — return user's terminal name
ttyname(), ttyname_r — find the pathname of a terminal
ttyname_r(), ttyname — find the pathname of a terminal
twalk(), tdelete, tfind, tsearch — manage a binary search tree
type — write a description of command type
tzname, daylight, timezone, tzset — set timezone conversion information
tzset(), daylight, timezone, tzname — set timezone conversion information
Topics
3.383 Tab Character ()
3.384 Terminal (or Terminal Device)
3.385 Text Column
3.386 Text Domain
3.387 Text File
3.388 Thread
3.389 Thread ID
3.390 Thread Lifetime
3.391 Thread List
3.392 Thread Termination
3.393 Thread-Safe
3.394 Thread-Specific Data Key
3.395 Tilde Character ()
3.396 Timeouts
3.397 Timer
3.398 Timer Overrun
3.399 Token
3.400 Typed Memory Name Space
3.401 Typed Memory Object
3.402 Typed Memory Pool
3.403 Typed Memory Port
4.22 Thread-Safety
4.23 Treatment of Error Conditions for Mathematical Functions
4.24 Treatment of NaN Arguments for the Mathematical Functions
Copyright © 2024 The IEEE and The Open Group, All Rights Reserved
===== susv5-html/idx/xsh_chap02.html =====
System Interfaces
System Interfaces: General Information
2.1 Use and Implementation of Interfaces
2.2 The Compilation Environment
2.3 Error Numbers
2.4 Signal Concepts
2.5 Standard I/O Streams
2.6 File Descriptor Allocation
2.7 XSI Interprocess Communication
2.8 Realtime
2.9 Threads
2.10 Sockets
2.11 Data Types
2.12 Status Information
===== susv5-html/idx/threads.html =====
Threads Index
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2024 The IEEE and The Open Group, All Rights reserved.
Threads Index
Threads Overview
Threads Interfaces
pthread.h - threads
pthread_atfork() - register fork handlers
pthread_attr_destroy(), pthread_attr_init - destroy and initialize threads attributes object
pthread_attr_getinheritsched(), pthread_attr_setinheritsched - get and set inheritsched attribute (REALTIME THREADS)
pthread_attr_getschedparam(), pthread_attr_setschedparam - get and set schedparam attribute
pthread_attr_getschedpolicy(), pthread_attr_setschedpolicy - get and set schedpolicy attribute (REALTIME THREADS)
pthread_attr_getscope(), pthread_attr_setscope - get and set contentionscope attribute (REALTIME THREADS)
pthread_attr_getstack(), pthread_attr_setstack - get and set stack attributes
pthread_attr_init() - initialize threads attributes object
pthread_attr_setdetachstate() - set detachstate attribute
pthread_attr_setguardsize() - set thread guardsize attribute
pthread_attr_setinheritsched() - set inheritsched attribute (REALTIME THREADS)
pthread_attr_setschedparam() - set schedparam attribute
pthread_attr_setschedpolicy() - set schedpolicy attribute (REALTIME THREADS)
pthread_attr_setscope() - set contentionscope attribute (REALTIME THREADS)
pthread_attr_setstack() - set stack attribute
pthread_attr_setstacksize() - set stacksize attribute
pthread_barrierattr_destroy(), pthread_barrierattr_init - destroy and initialize barrier attributes object
pthread_barrierattr_getpshared(), pthread_barrierattr_setpshared - get and set process-shared attribute of barrier attributes object
pthread_barrierattr_init() - initialize barrier attributes object
pthread_barrierattr_setpshared() - set process-shared attribute of barrier attributes object
pthread_barrier_destroy(), pthread_barrier_init - destroy and initialize a barrier object
pthread_barrier_init() - initialize a barrier object
pthread_barrier_wait() - synchronize at a barrier
pthread_cancel() - cancel execution of a thread
pthread_cleanup_pop(), pthread_cleanup_push - establish cancelation handlers
pthread_condattr_destroy(), pthread_condattr_init - destroy and initialize condition variable attributes object
pthread_condattr_getclock(), pthread_condattr_setclock - get and set the clock selection condition variable attribute
pthread_condattr_getpshared(), pthread_condattr_setpshared - get and set the process-shared condition variable attributes
pthread_condattr_init() - initialize condition variable attributes object
pthread_condattr_setclock() - set the clock selection condition variable attribute
pthread_condattr_setpshared() - set the process-shared condition variable attributes
pthread_cond_broadcast(), pthread_cond_signal - broadcast or signal a condition
pthread_cond_clockwait() - wait on a condition
pthread_cond_destroy(), pthread_cond_init - destroy and initialize condition variables
pthread_cond_init() - initialize condition variables
pthread_cond_signal() - signal a condition
pthread_cond_timedwait() - wait on a condition
pthread_cond_wait() - wait on a condition
pthread_create() - thread creation
pthread_detach() - detach a thread
pthread_equal() - compare thread IDs
pthread_exit() - thread termination
pthread_getcpuclockid() - access a thread CPU-time clock (ADVANCED REALTIME THREADS)
pthread_getschedparam(), pthread_setschedparam - dynamic thread scheduling parameters access (REALTIME THREADS)
pthread_getspecific(), pthread_setspecific - thread-specific data management
pthread_join() - wait for thread termination
pthread_key_create() - thread-specific data key creation
pthread_key_delete() - thread-specific data key deletion
pthread_kill() - send a signal to a thread
pthread_mutexattr_destroy(), pthread_mutexattr_init - destroy and initialize mutex attributes object
pthread_mutexattr_getprioceiling(), pthread_mutexattr_setprioceiling - get and set prioceiling attribute of mutex attributes object (REALTIME THREADS)
pthread_mutexattr_getprotocol(), pthread_mutexattr_setprotocol - get and set protocol attribute of mutex attributes object (REALTIME THREADS)
pthread_mutexattr_getpshared(), pthread_mutexattr_setpshared - get and set process-shared attribute
pthread_mutexattr_getrobust(), pthread_mutexattr_setrobust - get and set the mutex robust attribute
pthread_mutexattr_gettype(), pthread_mutexattr_settype - get and set a mutex type attribute
pthread_mutexattr_init() - initialize mutex attributes object
pthread_mutexattr_setprioceiling() - set prioceiling attribute of mutex attributes object (REALTIME THREADS)
pthread_mutexattr_setprotocol() - set protocol attribute of mutex attributes object (REALTIME THREADS)
pthread_mutexattr_setpshared() - set process-shared attribute
pthread_mutexattr_setrobust() - set the mutex robust attribute
pthread_mutexattr_settype() - set a mutex type attribute
pthread_mutex_clocklock() - lock a mutex
pthread_mutex_consistent() - mark state protected by robust mutex as consistent
pthread_mutex_destroy(), pthread_mutex_init - destroy and initialize a mutex
pthread_mutex_getprioceiling(), pthread_mutex_setprioceiling - get and set the priority ceiling of a mutex (REALTIME THREADS)
pthread_mutex_init() - initialize a mutex
pthread_mutex_lock(), pthread_mutex_trylock, pthread_mutex_unlock - lock and unlock a mutex
pthread_mutex_setprioceiling() - change the priority ceiling of a mutex (REALTIME THREADS)
pthread_mutex_timedlock() - lock a mutex
pthread_mutex_trylock(), pthread_mutex_unlock - lock and unlock a mutex
pthread_once() - dynamic package initialization
pthread_rwlockattr_destroy(), pthread_rwlockattr_init - destroy and initialize read-write lock attributes object
pthread_rwlockattr_getpshared(), pthread_rwlockattr_setpshared - get and set process-shared attribute of read-write lock attributes object
pthread_rwlockattr_init() - initialize read-write lock attributes object
pthread_rwlockattr_setpshared() - set process-shared attribute of read-write lock attributes object
pthread_rwlock_clockrdlock() - lock a read-write lock for reading
pthread_rwlock_clockwrlock() - lock a read-write lock for writing
pthread_rwlock_destroy(), pthread_rwlock_init - destroy and initialize a read-write lock object
pthread_rwlock_init() - initialize a read-write lock object
pthread_rwlock_rdlock(), pthread_rwlock_tryrdlock - lock a read-write lock object for reading
pthread_rwlock_timedrdlock() - lock a read-write lock for reading
pthread_rwlock_timedwrlock() - lock a read-write lock for writing
pthread_rwlock_tryrdlock() - lock a read-write lock object for reading
pthread_rwlock_trywrlock(), pthread_rwlock_wrlock - lock a read-write lock object for writing
pthread_rwlock_unlock() - unlock a read-write lock object
pthread_rwlock_wrlock() - lock a read-write lock object for writing
pthread_self() - get calling thread's ID
pthread_setcancelstate(), pthread_setcanceltype, pthread_testcancel - set cancelability state
pthread_setschedparam() - dynamic thread scheduling parameters access (REALTIME THREADS)
pthread_setschedprio() - dynamic thread scheduling parameters access (REALTIME THREADS)
pthread_setspecific() - thread-specific data management
pthread_sigmask(), sigprocmask - examine and change blocked signals
pthread_spin_destroy(), pthread_spin_init - destroy or initialize a spin lock object
pthread_spin_init() - initialize a spin lock object
pthread_spin_lock(), pthread_spin_trylock - lock a spin lock object
pthread_spin_trylock() - lock a spin lock object
pthread_spin_unlock() - unlock a spin lock object
pthread_testcancel() - set cancelability state
Threads Rationale
===== susv5-html/idx/ia.html =====
Alphabetical Index - A
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2024 The IEEE and The Open Group, All Rights reserved.
[
A
|
B
|
C
|
D
|
E
|
F
|
G
|
H
|
I
|
J
|
K
|
L
|
M
|
N
|
O
|
P
|
Q
|
R
|
S
|
T
|
U
|
V
|
W
|
X
|
Y
|
Z
| Index  ]
A
a64l(), l64a — convert between a 32-bit integer and a radix-64 ASCII string
abort() — generate an abnormal process abort
abs() — return an integer absolute value
accept(), accept4 — accept a new connection on a socket
accept4(), accept — accept a new connection on a socket
access(), faccessat — determine accessibility of a file descriptor
acos(), acosf, acosl — arc cosine functions
acosf(), acos, acosl — arc cosine functions
acosh(), acoshf, acoshl — inverse hyperbolic cosine functions
acoshf(), acosh, acoshl — inverse hyperbolic cosine functions
acoshl(), acosh, acoshf — inverse hyperbolic cosine functions
acosl(), acos, acosf — arc cosine functions
admin — create and administer SCCS files (DEVELOPMENT)
aio.h — asynchronous input and output
aio_cancel() — cancel an asynchronous I/O request
aio_error() — retrieve errors status for an asynchronous I/O operation
aio_fsync() — asynchronous file synchronization
aio_read() — asynchronous read from a file
aio_return() — retrieve return status of an asynchronous I/O operation
aio_suspend() — wait for an asynchronous I/O request
aio_write() — asynchronous write to a file
alarm() — schedule an alarm signal
alias — define or display aliases
aligned_alloc() — allocate memory with a specified alignment
alphasort(), scandir — scan a directory
ar — create and maintain library archives
arpa/inet.h — definitions for internet operations
asa — interpret carriage-control characters
asctime() — convert date and time to a string
asctime_r(), asctime — convert date and time to a string
asin(), asinf, asinl — arc sine function
asinf(), asin, asinl — arc sine function
asinh(), asinhf, asinhl — inverse hyperbolic sine functions
asinhf(), asinh, asinhl — inverse hyperbolic sine functions
asinhl(), asinh, asinhf — inverse hyperbolic sine functions
asinl(), asin, asinf — arc sine function
asprintf(), dprintf, fprintf, printf, snprintf, sprintf — print formatted output
assert() — insert program diagnostics
assert.h — verify program assertion
at — execute commands at a later time
atan(), atanf, atanl — arc tangent function
atan2(), atan2f, atan2l — arc tangent functions
atan2f(), atan2, atan2l — arc tangent functions
atan2l(), atan2, atan2f — arc tangent functions
atanf(), atan, atanl — arc tangent function
atanh(), atanhf, atanhl — inverse hyperbolic tangent functions
atanhf(), atanh, atanhl — inverse hyperbolic tangent functions
atanhl(), atanh, atanhf — inverse hyperbolic tangent functions
atanl(), atan, atanf — arc tangent function
atexit() — register a function to be called from exit() or after return from main()
atof() — convert a string to a double-precision number
atoi() — convert a string to an integer
atol(), atoll — convert a string to a long integer
atoll(), atol — convert a string to a long integer
atomic_compare_exchange_strong(), atomic_compare_exchange_strong_explicit, atomic_compare_exchange_weak, atomic_compare_exchange_weak_explicit — atomically compare and exchange the values of two objects
atomic_compare_exchange_strong_explicit(), atomic_compare_exchange_strong, atomic_compare_exchange_weak, atomic_compare_exchange_weak_explicit — atomically compare and exchange the values of two objects
atomic_compare_exchange_weak(), atomic_compare_exchange_strong, atomic_compare_exchange_strong_explicit, atomic_compare_exchange_weak_explicit — atomically compare and exchange the values of two objects
atomic_compare_exchange_weak_explicit(), atomic_compare_exchange_strong, atomic_compare_exchange_strong_explicit, atomic_compare_exchange_weak — atomically compare and exchange the values of two objects
atomic_exchange(), atomic_exchange_explicit — atomically exchange the value of an object
atomic_exchange_explicit(), atomic_exchange — atomically exchange the value of an object
atomic_fetch_add(), atomic_fetch_add_explicit, atomic_fetch_and, atomic_fetch_and_explicit, atomic_fetch_or, atomic_fetch_or_explicit, atomic_fetch_sub, atomic_fetch_sub_explicit, atomic_fetch_xor, atomic_fetch_xor_explicit — atomically replace the value of an object with the result of a computation
atomic_fetch_add_explicit(), atomic_fetch_add, atomic_fetch_and, atomic_fetch_and_explicit, atomic_fetch_or, atomic_fetch_or_explicit, atomic_fetch_sub, atomic_fetch_sub_explicit, atomic_fetch_xor, atomic_fetch_xor_explicit — atomically replace the value of an object with the result of a computation
atomic_fetch_and(), atomic_fetch_add, atomic_fetch_add_explicit, atomic_fetch_and_explicit, atomic_fetch_or, atomic_fetch_or_explicit, atomic_fetch_sub, atomic_fetch_sub_explicit, atomic_fetch_xor, atomic_fetch_xor_explicit — atomically replace the value of an object with the result of a computation
atomic_fetch_and_explicit(), atomic_fetch_add, atomic_fetch_add_explicit, atomic_fetch_and, atomic_fetch_or, atomic_fetch_or_explicit, atomic_fetch_sub, atomic_fetch_sub_explicit, atomic_fetch_xor, atomic_fetch_xor_explicit — atomically replace the value of an object with the result of a computation
atomic_fetch_or(), atomic_fetch_add, atomic_fetch_add_explicit, atomic_fetch_and, atomic_fetch_and_explicit, atomic_fetch_or_explicit, atomic_fetch_sub, atomic_fetch_sub_explicit, atomic_fetch_xor, atomic_fetch_xor_explicit — atomically replace the value of an object with the result of a computation
atomic_fetch_or_explicit(), atomic_fetch_add, atomic_fetch_add_explicit, atomic_fetch_and, atomic_fetch_and_explicit, atomic_fetch_or, atomic_fetch_sub, atomic_fetch_sub_explicit, atomic_fetch_xor, atomic_fetch_xor_explicit — atomically replace the value of an object with the result of a computation
atomic_fetch_sub(), atomic_fetch_add, atomic_fetch_add_explicit, atomic_fetch_and, atomic_fetch_and_explicit, atomic_fetch_or, atomic_fetch_or_explicit, atomic_fetch_sub_explicit, atomic_fetch_xor, atomic_fetch_xor_explicit — atomically replace the value of an object with the result of a computation
atomic_fetch_sub_explicit(), atomic_fetch_add, atomic_fetch_add_explicit, atomic_fetch_and, atomic_fetch_and_explicit, atomic_fetch_or, atomic_fetch_or_explicit, atomic_fetch_sub, atomic_fetch_xor, atomic_fetch_xor_explicit — atomically replace the value of an object with the result of a computation
atomic_fetch_xor(), atomic_fetch_add, atomic_fetch_add_explicit, atomic_fetch_and, atomic_fetch_and_explicit, atomic_fetch_or, atomic_fetch_or_explicit, atomic_fetch_sub, atomic_fetch_sub_explicit, atomic_fetch_xor_explicit — atomically replace the value of an object with the result of a computation
atomic_fetch_xor_explicit(), atomic_fetch_add, atomic_fetch_add_explicit, atomic_fetch_and, atomic_fetch_and_explicit, atomic_fetch_or, atomic_fetch_or_explicit, atomic_fetch_sub, atomic_fetch_sub_explicit, atomic_fetch_xor — atomically replace the value of an object with the result of a computation
atomic_flag_clear(), atomic_flag_clear_explicit — clear an atomic flag
atomic_flag_clear_explicit(), atomic_flag_clear — clear an atomic flag
atomic_flag_test_and_set(), atomic_flag_test_and_set_explicit — test and set an atomic flag
atomic_flag_test_and_set_explicit(), atomic_flag_test_and_set — test and set an atomic flag
atomic_init() — initialize an atomic object
atomic_is_lock_free() — indicate whether or not atomic operations are lock-free
atomic_load(), atomic_load_explicit — atomically obtain the value of an object
atomic_load_explicit(), atomic_load — atomically obtain the value of an object
atomic_signal_fence(), atomic_thread_fence — fence operations
atomic_store(), atomic_store_explicit — atomically store a value in an object
atomic_store_explicit(), atomic_store — atomically store a value in an object
atomic_thread_fence(), atomic_signal_fence — fence operations
at_quick_exit() — register a function to to be called from quick_exit()
awk — pattern scanning and processing language
Topics
2.2 Application Conformance
3.1 Abortive Release
3.2 Absolute Pathname
3.3 Access Mode
3.4 Additional File Access Control Mechanism
3.5 Address Space
3.6 Advisory Information
3.7 Affirmative Response
3.8 Alert
3.9 Alert Character ()
3.10 Alias Name
3.11 Alignment
3.12 Alternate File Access Control Mechanism
3.13 Alternate Signal Stack
3.14 Ancillary Data
3.15 Angle Brackets
3.16 Anonymous Memory Object
3.17 Apostrophe Character ()
3.18 Application
3.19 Application Address
3.20 Application Program Interface (API)
3.21 Appropriate Privileges
3.22 Argument
3.23 Arm (a Timer)
3.24 Asterisk Character ()
3.25 Async-Cancel-Safe Function
3.26 Asynchronous Events
3.27 Asynchronous Input and Output
3.28 Async-Signal-Safe Function
3.29 Asynchronously-Generated Signal
3.30 Asynchronous I/O Completion
3.31 Asynchronous I/O Operation
3.32 Atomic Operation
3.33 Authentication
3.34 Authorization
Copyright © 2024 The IEEE and The Open Group, All Rights Reserved
===== susv5-html/idx/ix.html =====
Alphabetical Index - X
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2024 The IEEE and The Open Group, All Rights reserved.
[
A
|
B
|
C
|
D
|
E
|
F
|
G
|
H
|
I
|
J
|
K
|
L
|
M
|
N
|
O
|
P
|
Q
|
R
|
S
|
T
|
U
|
V
|
W
|
X
|
Y
|
Z
| Index  ]
X
xargs — construct argument lists and invoke utility
xgettext — extract gettext call strings from C-language source files (DEVELOPMENT)
Topics
3.424 XSI
3.425 XSI-Conformant
Copyright © 2024 The IEEE and The Open Group, All Rights Reserved
===== susv5-html/idx/fidx4.html =====
Frame Index
Select an option code
ADV
AIO
BAR
CPT
CS
MF
ML
MPR
MR
MSG
PS
SEM
SHM
SIO
SPI
TEF
TCT
THR
TMO
TMR
TPI
TPP
TPS
TRC
TRI
TRL
TSA
TSF
TSH
TSS
TYM
XSI
XSR
[Main Index]
===== susv5-html/idx/im.html =====
Alphabetical Index - M
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2024 The IEEE and The Open Group, All Rights reserved.
[
A
|
B
|
C
|
D
|
E
|
F
|
G
|
H
|
I
|
J
|
K
|
L
|
M
|
N
|
O
|
P
|
Q
|
R
|
S
|
T
|
U
|
V
|
W
|
X
|
Y
|
Z
| Index  ]
M
m4 — macro processor
mailx — process messages
make — maintain, update, and regenerate files (DEVELOPMENT)
malloc() — a memory allocator
man — display system documentation
math.h — mathematical declarations
mblen() — get number of bytes in a character
mbrlen() — get number of bytes in a character (restartable)
mbrtoc16(), mbrtoc32 — convert a character to a Unicode character code (restartable)
mbrtoc32(), mbrtoc16 — convert a character to a Unicode character code (restartable)
mbrtowc() — convert a character to a wide-character code (restartable)
mbsinit() — determine conversion object status
mbsnrtowcs(), mbsrtowcs — convert a character string to a wide-character string (restartable)
mbsrtowcs(), mbsnrtowcs — convert a character string to a wide-character string (restartable)
mbstowcs() — convert a character string to a wide-character string
mbtowc() — convert a character to a wide-character code
memccpy() — copy bytes in memory
memchr() — find byte in memory
memcmp() — compare bytes in memory
memcpy() — copy bytes in memory
memmem() — find a byte subsequence in a byte sequence
memmove() — copy bytes in memory with overlapping areas
memset() — set bytes in memory
mesg — permit or deny messages
mkdir — make directories
mkdir(), mkdirat — make a directory
mkdirat(), mkdir — make a directory
mkdtemp(), mkostemp, mkstemp — create a unique directory or file
mkfifo — make FIFO special files
mkfifo(), mkfifoat — make a FIFO special file
mkfifoat(), mkfifo — make a FIFO special file
mknod(), mknodat — make directory, special file, or regular file
mknodat(), mknod — make directory, special file, or regular file
mkostemp(), mkdtemp, mkstemp — create a unique directory or file
mkstemp(), mkdtemp, mkostemp — create a unique directory or file
mktime() — convert broken-down time into time since the Epoch
mlock(), munlock — lock or unlock a range of process address space (REALTIME)
mlockall(), munlockall — lock/unlock the address space of a process (REALTIME)
mmap() — map pages of memory
modf(), modff, modfl — decompose a floating-point number
modff(), modf, modfl — decompose a floating-point number
modfl(), modf, modff — decompose a floating-point number
monetary.h — monetary types
more — display files on a page-by-page basis
mprotect() — set protection of memory mapping
mqueue.h — message queues (REALTIME)
mq_close() — close a message queue (REALTIME)
mq_getattr() — get message queue attributes (REALTIME)
mq_notify() — notify process that a message is available (REALTIME)
mq_open() — open a message queue (REALTIME)
mq_receive(), mq_timedreceive — receive a message from a message queue (REALTIME)
mq_send(), mq_timedsend — send a message to a message queue (REALTIME)
mq_setattr() — set message queue attributes (REALTIME)
mq_timedreceive(), mq_receive — receive a message from a message queue (REALTIME)
mq_timedsend(), mq_send — send a message to a message queue (REALTIME)
mq_unlink() — remove a message queue (REALTIME)
mrand48(), drand48, erand48, jrand48, lcong48, lrand48, nrand48, seed48, srand48 — generate uniformly distributed pseudo-random numbers
msgctl() — XSI message control operations
msgfmt — create messages objects from portable messages object source files
msgget() — get the XSI message queue identifier
msgrcv() — XSI message receive operation
msgsnd() — XSI message send operation
msync() — synchronize memory with physical storage
mtx_destroy(), mtx_init — destroy and initialize a mutex
mtx_init(), mtx_destroy — destroy and initialize a mutex
mtx_lock(), mtx_timedlock, mtx_trylock, mtx_unlock — lock and unlock a mutex
mtx_timedlock(), mtx_lock, mtx_trylock, mtx_unlock — lock and unlock a mutex
mtx_trylock(), mtx_lock, mtx_timedlock, mtx_unlock — lock and unlock a mutex
mtx_unlock(), mtx_lock, mtx_timedlock, mtx_trylock — lock and unlock a mutex
munlock(), mlock — lock or unlock a range of process address space (REALTIME)
munlockall(), mlockall — lock/unlock the address space of a process (REALTIME)
munmap() — unmap pages of memory
mv — move files
Topics
3.198 Map
3.199 Matched
3.200 Memory Mapped Files
3.201 Memory Object
3.202 Memory-Resident
3.203 Message
3.204 Message Catalog
3.205 Message Catalog Descriptor
3.206 Message Queue
3.207 Messages Object
3.208 Mode
3.209 Monotonic Clock
3.210 Mount Point
3.211 Multi-Character Collating Element
3.212 Multi-Threaded Library
3.213 Multi-Threaded Process
3.214 Multi-Threaded Program
3.215 Mutex
4.14 Measurement of Execution Time
4.15 Memory Ordering and Synchronization
Copyright © 2024 The IEEE and The Open Group, All Rights Reserved
===== susv5-html/idx/il.html =====
Alphabetical Index - L
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2024 The IEEE and The Open Group, All Rights reserved.
[
A
|
B
|
C
|
D
|
E
|
F
|
G
|
H
|
I
|
J
|
K
|
L
|
M
|
N
|
O
|
P
|
Q
|
R
|
S
|
T
|
U
|
V
|
W
|
X
|
Y
|
Z
| Index  ]
L
l64a(), a64l — convert between a 32-bit integer and a radix-64 ASCII string
labs(), llabs — return a long integer absolute value
langinfo.h — language information constants
lchown() — change the owner and group of a symbolic link
lcong48(), drand48, erand48, jrand48, lrand48, mrand48, nrand48, seed48, srand48 — generate uniformly distributed pseudo-random numbers
ldexp(), ldexpf, ldexpl — load exponent of a floating-point number
ldexpf(), ldexp, ldexpl — load exponent of a floating-point number
ldexpl(), ldexp, ldexpf — load exponent of a floating-point number
ldiv(), lldiv — compute quotient and remainder of a long division
le16toh(), be16toh, be32toh, be64toh, htobe16, htobe32, htobe64, htole16, htole32, htole64, le32toh, le64toh — convert values between host and specified byte order
le32toh(), be16toh, be32toh, be64toh, htobe16, htobe32, htobe64, htole16, htole32, htole64, le16toh, le64toh — convert values between host and specified byte order
le64toh(), be16toh, be32toh, be64toh, htobe16, htobe32, htobe64, htole16, htole32, htole64, le16toh, le32toh — convert values between host and specified byte order
lex — generate programs for lexical tasks (DEVELOPMENT)
lfind(), lsearch — linear search and update
lgamma(), lgammaf, lgammal, signgam — log gamma function
lgammaf(), lgamma, lgammal, signgam — log gamma function
lgammal(), lgamma, lgammaf, signgam — log gamma function
libgen.h — definitions for pattern matching functions
libintl.h — international messaging
limits.h — implementation-defined constants
link — call link function
link(), linkat — hard link one file to another file
linkat(), link — hard link one file to another file
lio_listio() — list directed I/O
listen() — listen for socket connections and limit the queue of incoming connections
llabs(), labs — return a long integer absolute value
lldiv(), ldiv — compute quotient and remainder of a long division
llrint(), llrintf, llrintl — round to the nearest integer value using current rounding direction
llrintf(), llrint, llrintl — round to the nearest integer value using current rounding direction
llrintl(), llrint, llrintf — round to the nearest integer value using current rounding direction
llround(), llroundf, llroundl — round to nearest integer value
llroundf(), llround, llroundl — round to nearest integer value
llroundl(), llround, llroundf — round to nearest integer value
ln — link files
locale — get locale-specific information
locale.h — category macros
localeconv() — return locale-specific information
localedef — define locale environment
localtime(), localtime_r — convert a time value to a broken-down local time
localtime_r(), localtime — convert a time value to a broken-down local time
lockf() — record locking on files
log(), logf, logl — natural logarithm function
log10(), log10f, log10l — base 10 logarithm function
log10f(), log10, log10l — base 10 logarithm function
log10l(), log10, log10f — base 10 logarithm function
log1p(), log1pf, log1pl — compute a natural logarithm
log1pf(), log1p, log1pl — compute a natural logarithm
log1pl(), log1p, log1pf — compute a natural logarithm
log2(), log2f, log2l — compute base 2 logarithm functions
log2f(), log2, log2l — compute base 2 logarithm functions
log2l(), log2, log2f — compute base 2 logarithm functions
logb(), logbf, logbl — radix-independent exponent
logbf(), logb, logbl — radix-independent exponent
logbl(), logb, logbf — radix-independent exponent
logf(), log, logl — natural logarithm function
logger — log messages
logl(), log, logf — natural logarithm function
logname — return the user's login name
longjmp() — non-local goto
lp — send files to a printer
lrand48(), drand48, erand48, jrand48, lcong48, mrand48, nrand48, seed48, srand48 — generate uniformly distributed pseudo-random numbers
lrint(), lrintf, lrintl — round to nearest integer value using current rounding direction
lrintf(), lrint, lrintl — round to nearest integer value using current rounding direction
lrintl(), lrint, lrintf — round to nearest integer value using current rounding direction
lround(), lroundf, lroundl — round to nearest integer value
lroundf(), lround, lroundl — round to nearest integer value
lroundl(), lround, lroundf — round to nearest integer value
ls — list directory contents
lsearch(), lfind — linear search and update
lseek() — move the read/write file offset
lstat(), fstatat, stat — get file status
Topics
2.3 Language-Dependent Services for the C Programming Language
3.184 Last Close (of a File)
3.185 Line
3.186 Linger
3.187 Link
3.188 Link Count
3.189 Live Process
3.190 Live Thread
3.191 Local Customs
3.192 Local Interprocess Communication (Local IPC)
3.193 Locale
3.194 Localization
3.195 Lock-Free Operation
3.196 Login
3.197 Login Name
7. Locale
7.3 Locale Definition
7.4 Locale Definition Grammar
Copyright © 2024 The IEEE and The Open Group, All Rights Reserved
===== susv5-html/idx/development.html =====
Development Utilities Index
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024 Edition
Copyright © 2024 The IEEE and The Open Group, All Rights reserved.
Development Utilities
admin - create and administer SCCS files (DEVELOPMENT)
cflow - generate a C-language flowgraph (DEVELOPMENT)
ctags - create a tags file (DEVELOPMENT, FORTRAN)
cxref - generate a C-language program cross-reference table (DEVELOPMENT)
delta - make a delta (change) to an SCCS file (DEVELOPMENT)
get - get a version of an SCCS file (DEVELOPMENT)
lex - generate programs for lexical tasks (DEVELOPMENT)
make - maintain, update, and regenerate groups of programs (DEVELOPMENT)
nm - write the name list of an object file (DEVELOPMENT)
prs - print an SCCS file (DEVELOPMENT)
rmdel - remove a delta from an SCCS file (DEVELOPMENT)
sact - print current SCCS file-editing activity (DEVELOPMENT)
sccs - front end for the SCCS subsystem (DEVELOPMENT)
strip - remove unnecessary information from executable files (DEVELOPMENT)
unget - undo a previous get of an SCCS file (DEVELOPMENT)
val - validate SCCS files (DEVELOPMENT)
what - identify SCCS files (DEVELOPMENT)
yacc - yet another compiler compiler (DEVELOPMENT)
===== susv5-html/idx/fidx5.html =====
Frame Index
Select an option code
BE
CD
FD
FR
SD
UP
XSI
[Main Index]
===== susv5-html/idx/iy.html =====
Alphabetical Index - Y
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2024 The IEEE and The Open Group, All Rights reserved.
[
A
|
B
|
C
|
D
|
E
|
F
|
G
|
H
|
I
|
J
|
K
|
L
|
M
|
N
|
O
|
P
|
Q
|
R
|
S
|
T
|
U
|
V
|
W
|
X
|
Y
|
Z
| Index  ]
Y
y0(), y1, yn — Bessel functions of the second kind
y1(), y0, yn — Bessel functions of the second kind
yacc — yet another compiler compiler (DEVELOPMENT)
yn(), y0, y1 — Bessel functions of the second kind
Topics
Copyright © 2024 The IEEE and The Open Group, All Rights Reserved
===== susv5-html/idx/xrat_xbd.html =====
Rationale
Rationale: Base Definitions
A.1 Introduction
A.2 Conformance
A.3 Definitions
A.4 General Concepts
A.5 File Format Notation
A.6 Character Set
A.7 Locale
A.8 Environment Variables
A.9 Regular Expressions
A.10 Directory Structure and Devices
A.11 General Terminal Interface
A.12 Utility Conventions
A.13 Namespace and Future Directions
A.14 Headers
===== susv5-html/idx/misc.html =====
Frontmatter Index
Frontmatter (Informative)
Preface
Typographical Conventions
Notice to Users
Participants
Trademarks
Acknowledgements
Referenced Documents
===== susv5-html/idx/topic.html =====
Topic Index
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2024 The IEEE and The Open Group, All Rights reserved.
Topics
Development
Headers
Math Interfaces
Networking
Realtime
Threads
Select a volume:
[
XBD
|
XCU
|
XSH
|
XRAT
]
Return to Index
===== susv5-html/idx/head.html =====
Headers
Headers
Format of Entries
===== susv5-html/idx/alphabet.html =====
Frame Index
Alphabetical Index
[ A
|
B
|
C
|
D
|
E
|
F
|
G
|
H
|
I
|
J
|
K
|
L
|
M
|
N
|
O
|
P
|
Q
|
R
|
S
|
T
|
U
|
V
|
W
|
X
|
Y
|
Z ]
===== susv5-html/idx/iu.html =====
Alphabetical Index - U
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2024 The IEEE and The Open Group, All Rights reserved.
[
A
|
B
|
C
|
D
|
E
|
F
|
G
|
H
|
I
|
J
|
K
|
L
|
M
|
N
|
O
|
P
|
Q
|
R
|
S
|
T
|
U
|
V
|
W
|
X
|
Y
|
Z
| Index  ]
U
uchar.h — Unicode character handling
ulimit — report or set resource limits
umask — get or set the file mode creation mask
umask() — set and get the file mode creation mask
unalias — remove alias definitions
uname — return system name
uname() — get the name of the current system
uncompress, compress, zcat — compress and decompress data
unexpand — convert spaces to tabs
unget — undo a previous get of an SCCS file (DEVELOPMENT)
ungetc() — push byte back into input stream
ungetwc() — push wide-character code back into the input stream
uniq — report or filter out repeated lines in a file
unistd.h — standard symbolic constants and types
unlink — call the unlink function
unlink(), unlinkat — remove a directory entry
unlinkat(), unlink — remove a directory entry
unlockpt() — unlock a pseudo-terminal manager/subsidiary pair
unset — unset values and attributes of variables and functions
unsetenv() — remove an environment variable
uselocale() — use locale in current thread
utimensat(), futimens, utimes — set file access and modification times
utimes(), futimens, utimensat — set file access and modification times
utmpx.h — user accounting database definitions
uucp — system-to-system copy
uudecode — decode a binary file
uuencode — encode a binary file
uustat — uucp status enquiry and job control
uux — remote command execution
Topics
3.404 Unbind
3.405 Unit Data
3.406 Upshifting
3.407 User Database
3.408 User ID
3.409 User Name
3.410 Utility
4.25 Utility
12. Utility Conventions
12.1 Utility Argument Syntax
12.2 Utility Syntax Guidelines
Copyright © 2024 The IEEE and The Open Group, All Rights Reserved
===== susv5-html/idx/fidx2.html =====
Frame Index
INDEX
[Alphabetic |
Topic ]
Select a Volume:
[Base Definitions
|
System Interfaces
|
Shell & Utilities
|
Rationale]
[Frontmatter]
[Main Index]
===== susv5-html/idx/ik.html =====
Alphabetical Index - K
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2024 The IEEE and The Open Group, All Rights reserved.
[
A
|
B
|
C
|
D
|
E
|
F
|
G
|
H
|
I
|
J
|
K
|
L
|
M
|
N
|
O
|
P
|
Q
|
R
|
S
|
T
|
U
|
V
|
W
|
X
|
Y
|
Z
| Index  ]
K
kill — terminate or signal processes
kill() — send a signal to a process or a group of processes
killpg() — send a signal to a process group
kill_dependency() — terminate a dependency chain
Topics
Copyright © 2024 The IEEE and The Open Group, All Rights Reserved
===== susv5-html/idx/topicidx.html =====
Alphabetical Index - A
The Open Group Base Specifications, Issue 6
IEEE Std 1003.1, 2004 Edition
Copyright © 2001-2004 The IEEE and The Open Group
TOPICS
Development
Headers
Legacy Interfaces
Math Interfaces
Networking
Realtime
Threads
Select a volume:
[ XBD
|
XCU
|
XSH
|
XRAT ]
Search:
Return to Index
Copyright © 2001-2004 The IEEE and The Open Group, All Rights Reserved
===== susv5-html/idx/ir.html =====
Alphabetical Index - R
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2024 The IEEE and The Open Group, All Rights reserved.
[
A
|
B
|
C
|
D
|
E
|
F
|
G
|
H
|
I
|
J
|
K
|
L
|
M
|
N
|
O
|
P
|
Q
|
R
|
S
|
T
|
U
|
V
|
W
|
X
|
Y
|
Z
| Index  ]
R
raise() — send a signal to the executing process
rand(), srand — pseudo-random number generator
random(), initstate, setstate, srandom — pseudo-random number functions
rand_r(), rand, srand — pseudo-random number generator
read — read from standard input into shell variables
read(), pread — read from a file
readdir(), readdir_r — read a directory
readdir_r(), readdir — read a directory
readlink — display the contents of a symbolic link
readlink(), readlinkat — read the contents of a symbolic link
readlinkat(), readlink — read the contents of a symbolic link
readonly — set the readonly attribute for variables
readv() — read a vector
realloc(), reallocarray — memory reallocators
reallocarray(), realloc — memory reallocators
realpath — resolve a pathname
realpath() — resolve a pathname
recv() — receive a message from a connected socket
recvfrom() — receive a message from a socket
recvmsg() — receive a message from a socket
regcomp(), regerror, regexec, regfree — regular expression matching
regerror(), regcomp, regexec, regfree — regular expression matching
regex.h — regular expression matching types
regexec(), regcomp, regerror, regfree — regular expression matching
regfree(), regcomp, regerror, regexec — regular expression matching
remainder(), remainderf, remainderl — remainder function
remainderf(), remainder, remainderl — remainder function
remainderl(), remainder, remainderf — remainder function
remove() — remove a file
remque(), insque — insert or remove an element in a queue
remquo(), remquof, remquol — remainder functions
remquof(), remquo, remquol — remainder functions
remquol(), remquo, remquof — remainder functions
rename(), renameat — rename file
renameat(), rename — rename file
renice — set nice values of running processes
return — return from a function or dot script
rewind() — reset the file position indicator in a stream
rewinddir() — reset the position of a directory stream to the beginning of a directory
rint(), rintf, rintl — round-to-nearest integral value
rintf(), rint, rintl — round-to-nearest integral value
rintl(), rint, rintf — round-to-nearest integral value
rm — remove directory entries
rmdel — remove a delta from an SCCS file (DEVELOPMENT)
rmdir — remove directories
rmdir() — remove a directory
round(), roundf, roundl — round to the nearest integer value in a floating-point format
roundf(), round, roundl — round to the nearest integer value in a floating-point format
roundl(), round, roundf — round to the nearest integer value in a floating-point format
Topics
3.294 Radix Character (or Decimal-Point Character)
3.295 Read-Only File System
3.296 Read-Write Lock
3.297 Real Group ID
3.298 Real Time
3.299 Realtime Signal Extension
3.300 Real User ID
3.301 Record
3.302 Record Lock
3.303 Redirection
3.304 Redirection Operator
3.305 Referenced Shared Memory Object
3.306 Refresh
3.307 Regular Built-In Utility (or Regular Built-In)
3.308 Regular Expression
3.309 Region
3.310 Regular File
3.311 Relative Pathname
3.312 Relocatable File
3.313 Relocation
3.315 Robust Mutex
3.316 Root Directory
3.317 Runnable Process (or Thread)
3.318 Running Process (or Thread)
9. Regular Expressions
9.1 Regular Expression Definitions
9.2 Regular Expression General Requirements
9.5 Regular Expression Grammar
Copyright © 2024 The IEEE and The Open Group, All Rights Reserved
===== susv5-html/idx/ig.html =====
Alphabetical Index - G
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2024 The IEEE and The Open Group, All Rights reserved.
[
A
|
B
|
C
|
D
|
E
|
F
|
G
|
H
|
I
|
J
|
K
|
L
|
M
|
N
|
O
|
P
|
Q
|
R
|
S
|
T
|
U
|
V
|
W
|
X
|
Y
|
Z
| Index  ]
G
gai_strerror() — address and name information error description
gencat — generate a formatted message catalog
get — get a version of an SCCS file (DEVELOPMENT)
getaddrinfo(), freeaddrinfo — get address information
getc() — get a byte from a stream
getchar() — get a byte from a stdin stream
getchar_unlocked(), getc_unlocked, putc_unlocked, putchar_unlocked — stdio with explicit client locking
getconf — get configuration values
getcwd() — get the pathname of the current working directory
getc_unlocked(), getchar_unlocked, putc_unlocked, putchar_unlocked — stdio with explicit client locking
getdate() — convert user format date and time
getdate_err, getdate — convert user format date and time
getdelim(), getline — read a delimited record from stream
getegid() — get the effective group ID
getentropy() — fill a buffer with random bytes
getenv(), secure_getenv — get value of an environment variable
geteuid() — get the effective user ID
getgid() — get the real group ID
getgrent(), endgrent, setgrent — group database entry functions
getgrgid(), getgrgid_r — get group database entry for a group ID
getgrgid_r(), getgrgid — get group database entry for a group ID
getgrnam(), getgrnam_r — search group database for a name
getgrnam_r(), getgrnam — search group database for a name
getgroups() — get supplementary group IDs
gethostent(), endhostent, sethostent — network host database functions
gethostid() — get an identifier for the current host
gethostname() — get name of current host
getline(), getdelim — read a delimited record from stream
getlocalename_l() — get a locale name from a locale object
getlogin(), getlogin_r — get login name
getlogin_r(), getlogin — get login name
getnameinfo() — get name information
getnetbyaddr(), endnetent, getnetbyname, getnetent, setnetent — network database functions
getnetbyname(), endnetent, getnetbyaddr, getnetent, setnetent — network database functions
getnetent(), endnetent, getnetbyaddr, getnetbyname, setnetent — network database functions
getopt(), optarg, opterr, optind, optopt — command option parsing
getopts — parse utility options
getpeername() — get the name of the peer socket
getpgid() — get the process group ID for a process
getpgrp() — get the process group ID of the calling process
getpid() — get the process ID
getppid() — get the parent process ID
getpriority(), setpriority — get and set the nice value
getprotobyname(), endprotoent, getprotobynumber, getprotoent, setprotoent — network protocol database functions
getprotobynumber(), endprotoent, getprotobyname, getprotoent, setprotoent — network protocol database functions
getprotoent(), endprotoent, getprotobyname, getprotobynumber, setprotoent — network protocol database functions
getpwent(), endpwent, setpwent — user database functions
getpwnam(), getpwnam_r — search user database for a name
getpwnam_r(), getpwnam — search user database for a name
getpwuid(), getpwuid_r — search user database for a user ID
getpwuid_r(), getpwuid — search user database for a user ID
getresgid() — get real group ID, effective group ID, and saved set-group-ID
getresuid() — get real user ID, effective user ID, and saved set-user-ID
getrlimit(), setrlimit — control maximum resource consumption
getrusage() — get information about resource utilization
getservbyname(), endservent, getservbyport, getservent, setservent — network services database functions
getservbyport(), endservent, getservbyname, getservent, setservent — network services database functions
getservent(), endservent, getservbyname, getservbyport, setservent — network services database functions
getsid() — get the process group ID of a session leader
getsockname() — get the socket name
getsockopt() — get the socket options
getsubopt() — parse suboption arguments from a string
gettext, ngettext — retrieve text string from messages object
gettext(), dgettext, dgettext_l, dcgettext, dcgettext_l, gettext_l, ngettext, ngettext_l, dngettext, dngettext_l, dcngettext, dcngettext_l — message handling functions
gettext_l(), dgettext, dgettext_l, dcgettext, dcgettext_l, gettext, ngettext, ngettext_l, dngettext, dngettext_l, dcngettext, dcngettext_l — message handling functions
getuid() — get a real user ID
getutxent(), endutxent, getutxid, getutxline, pututxline, setutxent — user accounting database functions
getutxid(), endutxent, getutxent, getutxline, pututxline, setutxent — user accounting database functions
getutxline(), endutxent, getutxent, getutxid, pututxline, setutxent — user accounting database functions
getwc() — get a wide character from a stream
getwchar() — get a wide character from a stdin stream
glob(), globfree — generate pathnames matching a pattern
glob.h — pathname pattern-matching types
globfree(), glob — generate pathnames matching a pattern
gmtime(), gmtime_r — convert a time value to a broken-down UTC time
gmtime_r(), gmtime — convert a time value to a broken-down UTC time
grantpt() — grant access to the subsidiary pseudo-terminal device
grep — search a file for a pattern
grp.h — group structure
Topics
3.163 Graphic Character
3.164 Group Database
3.165 Group ID
3.166 Group Name
4. General Concepts
7.1 General
11. General Terminal Interface
Copyright © 2024 The IEEE and The Open Group, All Rights Reserved
===== susv5-html/idx/networking.html =====
Networking Services Index
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2024 The IEEE and The Open Group, All Rights reserved.
Networking Services
Sockets Overview
Sockets Interfaces
accept()
accept4()
bind()
close()
connect()
fcntl()
freeaddrinfo()
getaddrinfo()
getnameinfo()
getpeername()
getsockname()
getsockopt()
listen()
poll()
ppoll()
pselect()
read()
recv()
recvfrom()
recvmsg()
select()
send()
sendmsg()
sendto()
setsockopt()
shutdown()
sockatmark()
socket()
socketpair()
write()
Sockets Headers
fcntl.h
netinet/tcp.h
sys/socket.h
sys/stat.h
sys/uio.h
sys/un.h
IP Address Resolution Interfaces
endhostent()
endnetent()
endprotoent()
endservent()
getnetbyaddr()
getprotobynumber()
getservbyport()
htonl()
inet_addr()
inet_ntoa()
inet_ntop()
ntohl()
inet_pton()
sethostent()
setnetent()
setprotoent()
setservent()
IP Address Resolution Headers
arpa/inet.h
netdb.h
netinet/in.h
unistd.h
===== susv5-html/idx/if.html =====
Alphabetical Index - F
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2024 The IEEE and The Open Group, All Rights reserved.
[
A
|
B
|
C
|
D
|
E
|
F
|
G
|
H
|
I
|
J
|
K
|
L
|
M
|
N
|
O
|
P
|
Q
|
R
|
S
|
T
|
U
|
V
|
W
|
X
|
Y
|
Z
| Index  ]
F
_Fork(), fork — create a new process
fabs(), fabsf, fabsl — absolute value function
fabsf(), fabs, fabsl — absolute value function
fabsl(), fabs, fabsf — absolute value function
faccessat(), access — determine accessibility of a file descriptor
false — return false value
fc — process the command history list
fchdir() — change working directory
fchmod() — change mode of a file
fchmodat(), chmod — change mode of a file
fchown() — change owner and group of a file
fchownat(), chown — change owner and group of a file
fclose() — close a stream
fcntl() — file control
fcntl.h — file control options
fdatasync() — synchronize the data of a file (REALTIME)
fdim(), fdimf, fdiml — compute positive difference between two floating-point numbers
fdimf(), fdim, fdiml — compute positive difference between two floating-point numbers
fdiml(), fdim, fdimf — compute positive difference between two floating-point numbers
fdopen() — associate a stream with a file descriptor
fdopendir(), opendir — open directory associated with file descriptor
FD_CLR(), pselect, select — synchronous I/O multiplexing
FD_ISSET(), pselect, select — synchronous I/O multiplexing
FD_SET(), pselect, select — synchronous I/O multiplexing
FD_ZERO(), pselect, select — synchronous I/O multiplexing
feclearexcept() — clear floating-point exception
fegetenv(), fesetenv — get and set current floating-point environment
fegetexceptflag(), fesetexceptflag — get and set floating-point status flags
fegetround(), fesetround — get and set current rounding direction
feholdexcept() — save current floating-point environment
fenv.h — floating-point environment
feof() — test end-of-file indicator on a stream
feraiseexcept() — raise floating-point exception
ferror() — test error indicator on a stream
fesetenv(), fegetenv — get and set current floating-point environment
fesetexceptflag(), fegetexceptflag — get and set floating-point status flags
fesetround(), fegetround — get and set current rounding direction
fetestexcept() — test floating-point exception flags
feupdateenv() — update floating-point environment
fexecve(), environ, execl, execle, execlp, execv, execve, execvp — execute a file
fflush() — flush a stream
ffs(), ffsl, ffsll — find first set bit
ffsl(), ffs, ffsll — find first set bit
ffsll(), ffs, ffsl — find first set bit
fg — run jobs in the foreground
fgetc() — get a byte from a stream
fgetpos() — get current file position information
fgets() — get a string from a stream
fgetwc() — get a wide-character code from a stream
fgetws() — get a wide-character string from a stream
file — determine file type
fileno() — map a stream pointer to a file descriptor
find — find files
float.h — floating types
flockfile(), ftrylockfile, funlockfile — stdio locking functions
floor(), floorf, floorl — floor function
floorf(), floor, floorl — floor function
floorl(), floor, floorf — floor function
fma(), fmaf, fmal — floating-point multiply-add
fmaf(), fma, fmal — floating-point multiply-add
fmal(), fma, fmaf — floating-point multiply-add
fmax(), fmaxf, fmaxl — determine maximum numeric value of two floating-point numbers
fmaxf(), fmax, fmaxl — determine maximum numeric value of two floating-point numbers
fmaxl(), fmax, fmaxf — determine maximum numeric value of two floating-point numbers
fmemopen() — open a memory buffer stream
fmin(), fminf, fminl — determine minimum numeric value of two floating-point numbers
fminf(), fmin, fminl — determine minimum numeric value of two floating-point numbers
fminl(), fmin, fminf — determine minimum numeric value of two floating-point numbers
fmod(), fmodf, fmodl — floating-point remainder value function
fmodf(), fmod, fmodl — floating-point remainder value function
fmodl(), fmod, fmodf — floating-point remainder value function
fmtmsg() — display a message in the specified format on standard error and/or a system console
fmtmsg.h — message display structures
fnmatch() — match a filename string or a pathname
fnmatch.h — filename-matching types
fold — filter for folding lines
fopen() — open a stream
fork() — create a new process
fpathconf(), pathconf — get configurable pathname variables
fpclassify() — classify real floating type
fprintf(), asprintf, dprintf, printf, snprintf, sprintf — print formatted output
fputc() — put a byte on a stream
fputs() — put a string on a stream
fputwc() — put a wide-character code on a stream
fputws() — put a wide-character string on a stream
fread() — binary input
free() — free allocated memory
freeaddrinfo(), getaddrinfo — get address information
freelocale() — free resources allocated for a locale object
freopen() — open a stream
frexp(), frexpf, frexpl — extract significand and exponent from a double precision number
frexpf(), frexp, frexpl — extract significand and exponent from a double precision number
frexpl(), frexp, frexpf — extract significand and exponent from a double precision number
fscanf(), scanf, sscanf — convert formatted input
fseek(), fseeko — reposition a file-position indicator in a stream
fseeko(), fseek — reposition a file-position indicator in a stream
fsetpos() — set current file position
fstat() — get file status
fstatat(), lstat, stat — get file status
fstatvfs(), statvfs — get file system information
fsync() — synchronize changes to a file
ftell(), ftello — return a file offset in a stream
ftello(), ftell — return a file offset in a stream
ftok() — generate an IPC key
ftruncate() — truncate a file to a specified length
ftrylockfile(), flockfile, funlockfile — stdio locking functions
ftw.h — file tree traversal
funlockfile(), flockfile, ftrylockfile — stdio locking functions
fuser — list process IDs of all processes that are using one or more named files
futimens(), utimensat, utimes — set file access and modification times
fwide() — set stream orientation
fwprintf(), swprintf, wprintf — print formatted wide-character output
fwrite() — binary output
fwscanf(), swscanf, wscanf — convert formatted wide-character input
Topics
3.136 Feature Test Macro
3.137 Field
3.138 FIFO Special File (or FIFO)
3.139 File
3.140 File Description
3.141 File Descriptor
3.142 File Group Class
3.143 File Lock
3.144 File Mode
3.145 File Mode Bits
3.146 Filename
3.147 Filename String
3.148 File Offset
3.149 File Other Class
3.150 File Owner Class
3.151 File Permission Bits
3.152 File Serial Number
3.153 File System
3.154 File Type
3.155 Filter
3.156 First Open (of a File)
3.157 Flow Control
3.158 Foreground Job
3.159 Foreground Process
3.160 Foreground Process Group
3.161 Foreground Process Group ID
3.162 Form-Feed Character ()
4.7 File Access Permissions
4.8 File Hierarchy
4.9 Filenames
4.10 Filename Portability
4.11 File System Cache
4.12 File Times Update
5. File Format Notation
Copyright © 2024 The IEEE and The Open Group, All Rights Reserved
===== susv5-html/idx/fidx.html =====
Frame Index
The Open Group Base Specifications, Issue 8
IEEE Std 1003.1-2024 Edition
INDEX
Alphabetical:
[ A
|
B
|
C
|
D
|
E
|
F
|
G
|
H
|
I
|
J
|
K
|
L
|
M
|
N
|
O
|
P
|
Q
|
R
|
S
|
T
|
U
|
V
|
W
|
X
|
Y
|
Z ]
Select a Volume:
[ XBD
|
XCU
|
XSH
|
XRAT ]
Miscellaneous:
[Topic Index]
Search:
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
===== susv5-html/idx/xrat_xsh_chap02.html =====
Rationale
Rationale: System Interfaces General Information
B.2.1 Use and Implementation of Interfaces
B.2.2 The Compilation Environment
B.2.3 Error Numbers
B.2.4 Signal Concepts
B.2.5 Standard I/O Streams
B.2.6 File Descriptor Allocation
B.2.7 XSI Interprocess Communication
B.2.8 Realtime
B.2.9 Threads
B.2.10 Sockets
B.2.11 Data Types
B.2.12 Status Information
===== susv5-html/idx/topic2.html =====
Topical Index
Topics
Development
Full Tables of Contents
Headers
Math Interfaces
Networking
Realtime
Special Built-in Utilities
System Interfaces
Threads
Utilities
===== susv5-html/idx/is.html =====
Alphabetical Index - S
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2024 The IEEE and The Open Group, All Rights reserved.
[
A
|
B
|
C
|
D
|
E
|
F
|
G
|
H
|
I
|
J
|
K
|
L
|
M
|
N
|
O
|
P
|
Q
|
R
|
S
|
T
|
U
|
V
|
W
|
X
|
Y
|
Z
| Index  ]
S
sact — print current SCCS file-editing activity (DEVELOPMENT)
scalbln(), scalblnf, scalblnl, scalbn, scalbnf, scalbnl — compute exponent using FLT_RADIX
scalblnf(), scalbln, scalblnl, scalbn, scalbnf, scalbnl — compute exponent using FLT_RADIX
scalblnl(), scalbln, scalblnf, scalbn, scalbnf, scalbnl — compute exponent using FLT_RADIX
scalbn(), scalbln, scalblnf, scalblnl, scalbnf, scalbnl — compute exponent using FLT_RADIX
scalbnf(), scalbln, scalblnf, scalblnl, scalbn, scalbnl — compute exponent using FLT_RADIX
scalbnl(), scalbln, scalblnf, scalblnl, scalbn, scalbnf — compute exponent using FLT_RADIX
scandir(), alphasort — scan a directory
scanf(), fscanf, sscanf — convert formatted input
sccs — front end for the SCCS subsystem (DEVELOPMENT)
sched.h — execution scheduling
sched_getparam() — get scheduling parameters (REALTIME)
sched_getscheduler() — get scheduling policy (REALTIME)
sched_get_priority_max(), sched_get_priority_min — get priority limits (REALTIME)
sched_get_priority_min(), sched_get_priority_max — get priority limits (REALTIME)
sched_rr_get_interval() — get execution time limits (REALTIME)
sched_setparam() — set scheduling parameters (REALTIME)
sched_setscheduler() — set scheduling policy and parameters (REALTIME)
sched_yield() — yield the processor
search.h — search tables
secure_getenv(), getenv — get value of an environment variable
sed — stream editor
seed48(), drand48, erand48, jrand48, lcong48, lrand48, mrand48, nrand48, srand48 — generate uniformly distributed pseudo-random numbers
seekdir() — set the position of a directory stream
select(), pselect — synchronous I/O multiplexing
semaphore.h — semaphores
semctl() — XSI semaphore control operations
semget() — get set of XSI semaphores
semop() — XSI semaphore operations
sem_clockwait(), sem_timedwait — lock a semaphore
sem_close() — close a named semaphore
sem_destroy() — destroy an unnamed semaphore
sem_getvalue() — get the value of a semaphore
sem_init() — initialize an unnamed semaphore
sem_open() — initialize and open a named semaphore
sem_post() — unlock a semaphore
sem_timedwait(), sem_clockwait — lock a semaphore
sem_trywait(), sem_wait — lock a semaphore
sem_unlink() — remove a named semaphore
sem_wait(), sem_trywait — lock a semaphore
send() — send a message on a socket
sendmsg() — send a message on a socket using a message structure
sendto() — send a message on a socket
set — set or unset options and positional parameters
setbuf() — assign buffering to a stream
setegid() — set the effective group ID
setenv() — add or change environment variable
seteuid() — set effective user ID
setgid() — set-group-ID
setgrent(), endgrent, getgrent — group database entry functions
sethostent(), endhostent, gethostent — network host database functions
setjmp() — set jump point for a non-local goto
setjmp.h — stack environment declarations
setkey() — set encoding key (CRYPT)
setlocale() — set program locale
setlogmask(), closelog, openlog, syslog — control system log
setnetent(), endnetent, getnetbyaddr, getnetbyname, getnetent — network database functions
setpgid() — set process group ID for job control
setpriority(), getpriority — get and set the nice value
setprotoent(), endprotoent, getprotobyname, getprotobynumber, getprotoent — network protocol database functions
setpwent(), endpwent, getpwent — user database functions
setregid() — set real and effective group IDs
setresgid() — set real group ID, effective group ID, and saved set-group-ID
setresuid() — set real user ID, effective user ID, and saved set-user-ID
setreuid() — set real and effective user IDs
setrlimit(), getrlimit — control maximum resource consumption
setservent(), endservent, getservbyname, getservbyport, getservent — network services database functions
setsid() — create session and set process group ID
setsockopt() — set the socket options
setstate(), initstate, random, srandom — pseudo-random number functions
setuid() — set user ID
setutxent(), endutxent, getutxent, getutxid, getutxline, pututxline — user accounting database functions
setvbuf() — assign buffering to a stream
sh — shell, the standard command language interpreter
shift — shift positional parameters
shmat() — XSI shared memory attach operation
shmctl() — XSI shared memory control operations
shmdt() — XSI shared memory detach operation
shmget() — get an XSI shared memory segment
shm_open() — open a shared memory object (REALTIME)
shm_unlink() — remove a shared memory object (REALTIME)
shutdown() — shut down socket send and receive operations
sig2str(), str2sig — translate between signal names and numbers
sigaction() — examine and change a signal action
sigaddset() — add a signal to a signal set
sigaltstack() — set and get signal alternate stack context
sigdelset() — delete a signal from a signal set
sigemptyset() — initialize and empty a signal set
sigfillset() — initialize and fill a signal set
sigismember() — test for a signal in a signal set
siglongjmp() — non-local goto with signal handling
signal() — signal management
signal.h — signals
signbit() — test sign
signgam, lgamma, lgammaf, lgammal — log gamma function
sigpending() — examine pending signals
sigprocmask(), pthread_sigmask — examine and change blocked signals
sigqueue() — queue a signal to a process
sigsetjmp() — set jump point for a non-local goto
sigsuspend() — wait for a signal
sigtimedwait(), sigwaitinfo — wait for queued signals
sigwait() — wait for queued signals
sigwaitinfo(), sigtimedwait — wait for queued signals
sin(), sinf, sinl — sine function
sinf(), sin, sinl — sine function
sinh(), sinhf, sinhl — hyperbolic sine functions
sinhf(), sinh, sinhl — hyperbolic sine functions
sinhl(), sinh, sinhf — hyperbolic sine functions
sinl(), sin, sinf — sine function
sleep — suspend execution for an interval
sleep() — suspend execution for an interval of time
snprintf(), asprintf, dprintf, fprintf, printf, sprintf — print formatted output
sockatmark() — determine whether a socket is at the out-of-band mark
socket() — create an endpoint for communication
socketpair() — create a pair of connected sockets
sort — sort, merge, or sequence check text files
spawn.h — spawn (ADVANCED REALTIME)
split — split a file into pieces
sprintf(), asprintf, dprintf, fprintf, printf, snprintf — print formatted output
sqrt(), sqrtf, sqrtl — square root function
sqrtf(), sqrt, sqrtl — square root function
sqrtl(), sqrt, sqrtf — square root function
srand(), rand — pseudo-random number generator
srand48(), drand48, erand48, jrand48, lcong48, lrand48, mrand48, nrand48, seed48 — generate uniformly distributed pseudo-random numbers
srandom(), initstate, random, setstate — pseudo-random number functions
sscanf(), fscanf, scanf — convert formatted input
stat(), fstatat, lstat — get file status
statvfs(), fstatvfs — get file system information
stdalign.h — alignment macros
stdarg.h — handle variable argument list
stdatomic.h — atomics
stdbool.h — boolean type and values
stddef.h — standard type definitions
stderr, stdin, stdout — standard I/O streams
stdin, stderr, stdout — standard I/O streams
stdint.h — integer types
stdio.h — standard buffered input/output
stdlib.h — standard library definitions
stdnoreturn.h — noreturn macro
stdout, stderr, stdin — standard I/O streams
stpcpy(), strcpy — copy a string
stpncpy(), strncpy — copy fixed length string, returning a pointer to the array end
str2sig(), sig2str — translate between signal names and numbers
strcasecmp(), strcasecmp_l, strncasecmp, strncasecmp_l — case-insensitive string comparisons
strcasecmp_l(), strcasecmp, strncasecmp, strncasecmp_l — case-insensitive string comparisons
strcat() — concatenate two strings
strchr() — string scanning operation
strcmp() — compare two strings
strcoll(), strcoll_l — string comparison using collating information
strcoll_l(), strcoll — string comparison using collating information
strcpy(), stpcpy — copy a string
strcspn() — get the length of a complementary substring
strdup(), strndup — duplicate a specific number of bytes from a string
strerror(), strerror_l, strerror_r — get error message string
strerror_l(), strerror, strerror_r — get error message string
strerror_r(), strerror, strerror_l — get error message string
strfmon(), strfmon_l — convert monetary value to a string
strfmon_l(), strfmon — convert monetary value to a string
strftime(), strftime_l — convert date and time to a string
strftime_l(), strftime — convert date and time to a string
string.h — string operations
strings — find printable strings in files
strings.h — string operations
strip — remove unnecessary information from strippable files (DEVELOPMENT)
strlcat(), strlcpy — size-bounded string concatenation and copying
strlcpy(), strlcat — size-bounded string concatenation and copying
strlen(), strnlen — get length of fixed size string
strncasecmp(), strcasecmp, strcasecmp_l, strncasecmp_l — case-insensitive string comparisons
strncasecmp_l(), strcasecmp, strcasecmp_l, strncasecmp — case-insensitive string comparisons
strncat() — concatenate a string with part of another
strncmp() — compare part of two strings
strncpy(), stpncpy — copy fixed length string, returning a pointer to the array end
strndup(), strdup — duplicate a specific number of bytes from a string
strnlen(), strlen — get length of fixed size string
strpbrk() — scan a string for a byte
strptime() — date and time conversion
strrchr() — string scanning operation
strsignal() — get signal message string
strspn() — get length of a substring
strstr() — find a substring
strtod(), strtof, strtold — convert a string to a double-precision number
strtof(), strtod, strtold — convert a string to a double-precision number
strtoimax(), strtoumax — convert string to integer type
strtok(), strtok_r — split string into tokens
strtok_r(), strtok — split string into tokens
strtol(), strtoll — convert a string to a long integer
strtold(), strtod, strtof — convert a string to a double-precision number
strtoll(), strtol — convert a string to a long integer
strtoul(), strtoull — convert a string to an unsigned long
strtoull(), strtoul — convert a string to an unsigned long
strtoumax(), strtoimax — convert string to integer type
strxfrm(), strxfrm_l — string transformation
strxfrm_l(), strxfrm — string transformation
stty — set the options for a terminal
swab() — swap bytes
swprintf(), fwprintf, wprintf — print formatted wide-character output
swscanf(), fwscanf, wscanf — convert formatted wide-character input
symlink(), symlinkat — make a symbolic link
symlinkat(), symlink — make a symbolic link
sync() — schedule file system updates
sys/ipc.h — XSI interprocess communication access structure
sys/mman.h — memory management declarations
sys/msg.h — XSI message queue structures
sys/resource.h — definitions for resource operations
sys/select.h — select types
sys/sem.h — XSI semaphore facility
sys/shm.h — XSI shared memory facility
sys/socket.h — main sockets header
sys/stat.h — data returned by the stat() function
sys/statvfs.h — VFS File System information structure
sys/time.h — time types
sys/times.h — file access and modification times structure
sys/types.h — data types
sys/uio.h — definitions for vector I/O operations
sys/un.h — definitions for UNIX domain sockets
sys/utsname.h — system name structure
sys/wait.h — declarations for waiting
sysconf() — get configurable system variables
syslog(), closelog, openlog, setlogmask — control system log
syslog.h — definitions for system error logging
system() — issue a command
Topics
3.319 Saved Resource Limits
3.320 Saved Set-Group-ID
3.321 Saved Set-User-ID
3.322 Scheduling
3.323 Scheduling Allocation Domain
3.324 Scheduling Contention Scope
3.325 Scheduling Policy
3.326 Screen
3.327 Scroll
3.328 Semaphore
3.329 Session
3.330 Session Leader
3.331 Session Lifetime
3.332 Shared Memory Object
3.333 Shell
3.334 Shell, the
3.335 Shell Script
3.336 Signal
3.337 Signal Stack
3.338 Single-Quote Character
3.339 Single-Threaded Process
3.340 Single-Threaded Program
3.341 Slash Character ()
3.342 Socket
3.343 Socket Address
3.344 Soft Limit
3.345 Source Code
3.346 Space Character ()
3.347 Sparse File
3.348 Spawn
3.349 Special Built-In Utility (or Special Built-In)
3.350 Special Parameter
3.351 Spin Lock
3.352 Sporadic Server
3.353 Standard Error
3.354 Standard Input
3.355 Standard Output
3.356 Standard Utilities
3.357 Stream
3.358 String
3.359 Subshell
3.360 Successfully Transferred
3.361 Supplementary Group ID
3.362 Suspended Job
3.363 Symbolic Constant
3.364 Symbolic Link
3.365 Synchronization Operation
3.366 Synchronized Input and Output
3.367 Synchronized I/O Completion
3.368 Synchronized I/O Data Integrity Completion
3.369 Synchronized I/O File Integrity Completion
3.370 Synchronized I/O Operation
3.371 Synchronous I/O Operation
3.372 Synchronously-Generated Signal
3.373 System
3.374 System Boot
3.375 System Clock
3.376 System Console
3.377 System Crash
3.378 System Databases
3.379 System Documentation
3.380 System Process
3.381 System Reboot
3.382 System-Wide
4.18 Scheduling Policy
4.19 Seconds Since the Epoch
4.20 Semaphore
4.21 Special Device Drivers
Copyright © 2024 The IEEE and The Open Group, All Rights Reserved
===== susv5-html/idx/ij.html =====
Alphabetical Index - J
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2024 The IEEE and The Open Group, All Rights reserved.
[
A
|
B
|
C
|
D
|
E
|
F
|
G
|
H
|
I
|
J
|
K
|
L
|
M
|
N
|
O
|
P
|
Q
|
R
|
S
|
T
|
U
|
V
|
W
|
X
|
Y
|
Z
| Index  ]
J
j0(), j1, jn — Bessel functions of the first kind
j1(), j0, jn — Bessel functions of the first kind
jn(), j0, j1 — Bessel functions of the first kind
jobs — display status of jobs in the current shell execution environment
join — relational database operator
jrand48(), drand48, erand48, lcong48, lrand48, mrand48, nrand48, seed48, srand48 — generate uniformly distributed pseudo-random numbers
Topics
3.180 Job
3.181 Job Control
3.182 Job ID
3.183 Joinable Thread
Copyright © 2024 The IEEE and The Open Group, All Rights Reserved
===== susv5-html/idx/fidx3.html =====
Frame Index
Search
Enter keyword or keywords using and and or
Substring Matching.
Select a Volume:
All
XSH
XCU
XBD
XRAT
Return to Main Index
===== susv5-html/idx/realtime.html =====
Realtime Services Index
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024 Edition
Copyright © 2024 The IEEE and The Open Group, All Rights reserved.
Realtime Index
Realtime Overview
Realtime Signal Generation and Delivery
Realtime Interfaces
aio_cancel() - cancel an asynchronous I/O request
aio_error() - retrieve errors status for an asynchronous I/O operation
aio_fsync() - asynchronous file synchronization
aio.h - asynchronous input and output
aio_read() - asynchronous read from a file
aio_return() - retrieve return status of an asynchronous I/O operation
aio_suspend() - wait for an asynchronous I/O request
aio_write() - asynchronous write to a file
clock_getcpuclockid() - access a process CPU-time clock (ADVANCED REALTIME)
clock_getres(), clock_gettime, clock_settime - clock and timer functions
clock_nanosleep() - high resolution sleep with specifiable clock (ADVANCED REALTIME)
clock_settime() - clock and timer functions
fdatasync() - synchronize the data of a file (REALTIME)
lio_listio() - list directed I/O
mlockall(), munlockall - lock/unlock the address space of a process (REALTIME)
mlock(), munlock - lock or unlock a range of process address space (REALTIME)
mq_close() - close a message queue (REALTIME)
mq_getattr() - get message queue attributes (REALTIME)
mq_notify() - notify process that a message is available (REALTIME)
mq_open() - open a message queue (REALTIME)
mq_receive(), mq_timedreceive - receive a message from a message queue (REALTIME)
mq_send(), mq_timedsend - send a message to a message queue (REALTIME)
mq_setattr() - set message queue attributes (REALTIME)
mq_timedreceive() - receive a message from a message queue (REALTIME)
mq_timedsend() - send a message to a message queue (REALTIME)
mqueue.h - message queues (REALTIME)
mq_unlink() - remove a message queue (REALTIME)
nanosleep() - high resolution sleep
posix_fadvise() - file advisory information (ADVANCED REALTIME)
posix_fallocate() - file space control (ADVANCED REALTIME)
posix_madvise() - memory advisory information and alignment control (ADVANCED REALTIME)
posix_memalign() - aligned memory allocation (ADVANCED REALTIME)
posix_mem_offset() - find offset and length of a mapped typed memory block (ADVANCED REALTIME)
posix_spawnattr_destroy(), posix_spawnattr_init - destroy and initialize spawn attributes object (ADVANCED REALTIME)
posix_spawnattr_getflags(), posix_spawnattr_setflags - get and set spawn-flags attribute of spawn attributes object (ADVANCED REALTIME)
posix_spawnattr_getpgroup(), posix_spawnattr_setpgroup - get and set spawn-pgroup attribute of spawn attributes object (ADVANCED REALTIME)
posix_spawnattr_getschedparam(), posix_spawnattr_setschedparam - get and set spawn-schedparam attribute of spawn attributes object (ADVANCED REALTIME)
posix_spawnattr_getschedpolicy(), posix_spawnattr_setschedpolicy - get and set spawn-schedpolicy attribute of spawn attributes object (ADVANCED REALTIME)
posix_spawnattr_getsigdefault(), posix_spawnattr_setsigdefault - get and set spawn-sigdefault attribute of spawn attributes object (ADVANCED REALTIME)
posix_spawnattr_getsigmask(), posix_spawnattr_setsigmask - get and set spawn-sigmask attribute of spawn attributes object (ADVANCED REALTIME)
posix_spawnattr_init() - initialize spawn attributes object (ADVANCED REALTIME)
posix_spawnattr_setflags() - set spawn-flags attribute of spawn attributes object (ADVANCED REALTIME)
posix_spawnattr_setpgroup() - set spawn-pgroup attribute of spawn attributes object (ADVANCED REALTIME)
posix_spawnattr_setschedparam() - set spawn-schedparam attribute of spawn attributes object (ADVANCED REALTIME)
posix_spawnattr_setschedpolicy() - set spawn-schedpolicy attribute of spawn attributes object (ADVANCED REALTIME)
posix_spawnattr_setsigdefault() - set spawn-sigdefault attribute of spawn attributes object (ADVANCED REALTIME)
posix_spawnattr_setsigmask() - set spawn-sigmask attribute of spawn attributes object (ADVANCED REALTIME)
posix_spawn_file_actions_addchdir() - add chdir action to spawn file actions object (ADVANCED REALTIME)
posix_spawn_file_actions_addclose() - add close action to spawn file actions object (ADVANCED REALTIME)
posix_spawn_file_actions_adddup2() - add dup2 action to spawn file actions object (ADVANCED REALTIME)
posix_spawn_file_actions_addfchdir() - add fchdir action to spawn file actions object (ADVANCED REALTIME)
posix_spawn_file_actions_addopen() - add open action to spawn file actions object (ADVANCED REALTIME)
posix_spawn_file_actions_destroy(), posix_spawn_file_actions_init - destroy and initialize spawn file actions object (ADVANCED REALTIME)
posix_spawn_file_actions_init() - initialize spawn file actions object (ADVANCED REALTIME)
posix_spawn(), posix_spawnp - spawn a process (ADVANCED REALTIME)
posix_spawnp() - spawn a process (ADVANCED REALTIME)
posix_typed_mem_get_info() - query typed memory information (ADVANCED REALTIME)
posix_typed_mem_open() - open a typed memory object (ADVANCED REALTIME)
pthread_attr_getinheritsched(), pthread_attr_setinheritsched - get and set inheritsched attribute (REALTIME THREADS)
pthread_attr_getschedpolicy(), pthread_attr_setschedpolicy - get and set schedpolicy attribute (REALTIME THREADS)
pthread_attr_getscope(), pthread_attr_setscope - get and set contentionscope attribute (REALTIME THREADS)
pthread_attr_setinheritsched() - set inheritsched attribute (REALTIME THREADS)
pthread_attr_setschedpolicy() - set schedpolicy attribute (REALTIME THREADS)
pthread_attr_setscope() - set contentionscope attribute (REALTIME THREADS)
pthread_getcpuclockid() - access a thread CPU-time clock (ADVANCED REALTIME THREADS)
pthread_getschedparam(), pthread_setschedparam - dynamic thread scheduling parameters access (REALTIME THREADS)
pthread_mutexattr_getprioceiling(), pthread_mutexattr_setprioceiling - get and set prioceiling attribute of mutex attributes object (REALTIME THREADS)
pthread_mutexattr_getprotocol(), pthread_mutexattr_setprotocol - get and set protocol attribute of mutex attributes object (REALTIME THREADS)
pthread_mutexattr_setprioceiling() - set prioceiling attribute of mutex attributes object (REALTIME THREADS)
pthread_mutexattr_setprotocol() - set protocol attribute of mutex attributes object (REALTIME THREADS)
pthread_mutex_getprioceiling(), pthread_mutex_setprioceiling - get and set the priority ceiling of a mutex (REALTIME THREADS)
pthread_mutex_setprioceiling() - change the priority ceiling of a mutex (REALTIME THREADS)
pthread_setschedparam() - dynamic thread scheduling parameters access (REALTIME THREADS)
pthread_setschedprio() - dynamic thread scheduling parameters access (REALTIME THREADS)
sched_getparam() - get scheduling parameters (REALTIME)
sched_get_priority_max(), sched_get_priority_min - get priority limits (REALTIME)
sched_getscheduler() - get scheduling policy (REALTIME)
sched.h - execution scheduling
sched_rr_get_interval() - get execution time limits (REALTIME)
sched_setparam() - set scheduling parameters (REALTIME)
sched_setscheduler() - set scheduling policy and parameters (REALTIME)
semaphore.h - semaphores
sem_close() - close a named semaphore
sem_destroy() - destroy an unnamed semaphore
sem_getvalue() - get the value of a semaphore
sem_init() - initialize an unnamed semaphore
sem_open() - initialize and open a named semaphore
sem_post() - unlock a semaphore
sem_timedwait() - lock a semaphore
sem_trywait(), sem_wait - lock a semaphore
sem_unlink() - remove a named semaphore
sem_wait() - lock a semaphore
shm_open() - open a shared memory object (REALTIME)
shm_unlink() - remove a shared memory object (REALTIME)
sigqueue() - queue a signal to a process
sigtimedwait(), sigwaitinfo - wait for queued signals
sigwaitinfo() - wait for queued signals
spawn.h - spawn (ADVANCED REALTIME)
timer_create() - create a per-process timer
timer_delete() - delete a per-process timer
timer_getoverrun(), timer_gettime, timer_settime - per-process timers
Realtime Rationale
===== susv5-html/idx/xbd.html =====
Base Definitions
Base Definitions
Introduction
Conformance
Definitions
General Concepts
File Format Notation
Character Set
Locale
Environment Variables
Regular Expressions
Directory Structure and Devices
General Terminal Interface
Utility Conventions
Namespace and Future Directions
Headers
===== susv5-html/idx/maths.html =====
Math Interfaces Index
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024 Edition
Copyright © 2024 The IEEE and The Open Group, All Rights reserved.
Math Interfaces
complex.h
math.h
tgmath.h
CMPLX()
CMPLXF()
CMPLXL()
acos()
acosf()
acosh()
acoshf()
acoshl()
acosl()
asin()
asinf()
asinh()
asinhf()
asinhl()
asinl()
atan()
atan2()
atan2f()
atan2l()
atanf()
atanh()
atanhf()
atanhl()
atanl()
cabs()
cabsf()
cabsl()
cacos()
cacosf()
cacosh()
cacoshf()
cacoshl()
cacosl()
carg()
cargf()
cargl()
casin()
casinf()
casinh()
casinhf()
casinhl()
casinl()
catan()
catanf()
catanh()
catanhf()
catanhl()
catanl()
cbrt()
cbrtf()
cbrtl()
ccos()
ccosf()
ccosh()
ccoshf()
ccoshl()
ccosl()
ceil()
ceilf()
ceill()
cexp()
cexpf()
cexpl()
cimag()
cimagf()
cimagl()
clog()
clogf()
clogl()
conj()
conjf()
conjl()
copysign()
copysignf()
copysignl()
cos()
cosf()
cosh()
coshf()
coshl()
cosl()
cpow()
cpowf()
cpowl()
cproj()
cprojf()
cprojl()
creal()
crealf()
creall()
csin()
csinf()
csinh()
csinhf()
csinhl()
csinl()
csqrt()
csqrtf()
csqrtl()
ctan()
ctanf()
ctanh()
ctanhf()
ctanhl()
ctanl()
erf()
erfc()
erfcf()
erfcl()
erff()
erfl()
exp()
exp2()
exp2f()
exp2l()
expf()
expl()
expm1()
expm1f()
expm1l()
fabs()
fabsf()
fabsl()
fdim()
fdimf()
fdiml()
floor()
floorf()
floorl()
fma()
fmaf()
fmal()
fmax()
fmaxf()
fmaxl()
fmin()
fminf()
fminl()
fmod()
fmodf()
fmodl()
fpclassify()
frexp()
frexpf()
frexpl()
hypot()
hypotf()
hypotl()
ilogb()
ilogbf()
ilogbl()
isfinite()
isgreater()
isgreaterequal()
isinf()
isless()
islessequal()
islessgreater()
isnan()
isnormal()
isunordered()
j0()
j1()
jn()
ldexp()
ldexpf()
ldexpl()
lgamma()
lgammaf()
lgammal()
llrint()
llrintf()
llrintl()
llround()
llroundf()
llroundl()
log()
log10()
log10f()
log10l()
log1p()
log1pf()
log1pl()
log2()
log2f()
log2l()
logb()
logbf()
logbl()
logf()
logl()
lrint()
lrintf()
lrintl()
lround()
lroundf()
lroundl()
modf()
modff()
modfl()
nan()
nanf()
nanl()
nearbyint()
nearbyintf()
nearbyintl()
nextafter()
nextafterf()
nextafterl()
nexttoward()
nexttowardf()
nexttowardl()
pow()
powf()
powl()
remainder()
remainderf()
remainderl()
remquo()
remquof()
remquol()
rint()
rintf()
rintl()
round()
roundf()
roundl()
scalbln()
scalblnf()
scalblnl()
scalbn()
scalbnf()
scalbnl()
signbit()
sin()
sinf()
sinh()
sinhf()
sinhl()
sinl()
sqrt()
sqrtf()
sqrtl()
tan()
tanf()
tanh()
tanhf()
tanhl()
tanl()
tgamma()
tgammaf()
tgammal()
trunc()
truncf()
truncl()
y0()
y1()
yn()
===== susv5-html/nframe.html =====
The Open Group Base Specifications Issue 8
Frame Alert
This document is designed to be viewed using the frames feature. If you see this message, you are using a non-frame-capable web
client.
Link toNon-frame version.
===== susv5-html/index.html =====
The Open Group Base Specifications Issue 8
Frame Alert
This document is designed to be viewed using the frames feature. If you see this message, you are using a non-frame-capable web
client.
Link toNon-frame version.
===== susv5-html/xsh.html =====
System Interfaces
This page uses frames, but your browser doesn't support them. Go to ToC
===== susv5-html/copyr.html =====
Copyrights
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
Copyright 2024 by the Institute of Electrical and Electronics Engineers, Inc. and The Open Group
All rights reserved.
Published 14 June 2024 by the IEEE and The Open Group.
No part of this publication may be reproduced in any form, in an electronic retrieval system or otherwise, without the prior
written permission of the publisher. Permission to reproduce all or any part of this standard must be with the consent of both
copyright holders and may be subject to a license fee. Both copyright holders will need to be satisfied that the other has granted
permission. Requests should be sent by email to austin-group-permissions@opengroup.org.
This standard has been prepared by the Austin Group. Feedback relating to the material contained within this standard may be
submitted by using the Austin Group web site at www.opengroup.org/austin/defectform.html.
Copyrights
This document is copyrighted by the IEEE and The Open Group. It is made available for a wide variety of both public and private
uses. These include both use, by reference, in laws and regulations, and use in private self-regulation, standardization, and the
promotion of engineering practices and methods. By making this document available for use and adoption by public authorities and
private users, the IEEE and The Open Group do not waive any rights in copyright to this document.
The Institute of Electrical and Electronics Engineers, Inc.
3 Park Avenue, New York, NY 10016-5997, USA
The Open Group
Apex Plaza, Forbury Road, Reading, Berkshire, RG1 1AX, U.K.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
===== susv5-html/xcu.html =====
Shell and Utilities
This page uses frames, but your browser doesn't support them. Go to ToC
===== susv5-html/frame.html =====
The Open Group Base Specifications, Issue 6
This page uses frames, but your browser doesn't support them. Go to ToC
===== susv5-html/xrat.html =====
Rationale
This page uses frames, but your browser doesn't support them. Go to ToC
===== susv5-html/frontmatter/refdocs.html =====
Referenced Documents
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
Referenced Documents
Normative References
Normative references for POSIX.1-2024 are defined in the Base Definitions volume of POSIX.1-2024.
Informative References
The following documents are referenced in POSIX.1-2024:
1984 /usr/group Standard
/usr/group Standards Committee, Santa Clara, CA, UniForum 1984.
Almasi and Gottlieb
George S. Almasi and Allan Gottlieb, Highly Parallel Computing,
The Benjamin/Cummings Publishing Company, Inc., 1989,
ISBN: 0-8053-0177-1.
ANSI C
American National Standard for Information Systems:
Standard X3.159-1989, Programming Language C.
ANSI X3.226-1994
American National Standard for Information Systems:
Standard X3.226-1994, Programming Language Common LISP.
Brawer
Steven Brawer, Introduction to Parallel Programming,
Academic Press, 1989, ISBN: 0-12-128470-0.
DeRemer and Pennello Article
DeRemer, Frank and Pennello, Thomas J., Efficient Computation
of LALR(1) Look-Ahead Sets, SigPlan Notices, Volume 15, No. 8,
August 1979.
Draft ANSI X3J11.1
IEEE Floating Point draft report of ANSI X3J11.1 (NCEG).
FIPS 151-1
Federal Information Procurement Standard (FIPS) 151-1.
Portable Operating System Interface (POSIX)-Part 1:
System Application Program Interface (API) [C Language].
FIPS 151-2
Federal Information Procurement Standards (FIPS) 151-2,
Portable Operating System Interface (POSIX)- Part 1:
System Application Program Interface (API) [C Language].
HP-UX Manual
Hewlett-Packard HP-UX Release 9.0 Reference Manual, Third Edition,
August 1992.
IEC 60559:1989
IEC 60559:1989, Binary Floating-Point Arithmetic for Microprocessor
Systems (previously designated IEC 559:1989).
IEEE Standards Terms
IEEE 100, The Authoritative Dictionary of IEEE Standards Terms,
Seventh Edition.
IEEE Std 754TM-1985
IEEE Std 754-1985 (Reaff 1990),
IEEE Standard for Binary Floating-Point Arithmetic.
IEEE Std 854TM-1987
IEEE Std 854-1987,
IEEE Standard for Radix-Independent Floating-Point Arithmetic.
IEEE Std 1003.9TM-1992
IEEE Std 1003.9-1992,
IEEE Standard for Information Technology - POSIX FORTRAN 77 Language
Interfaces - Part 1: Binding for System Application Program Interface
API.
IETF RFC 791
Internet Protocol, Version 4 (IPv4), September 1981 (available at:
www.ietf.org/rfc/rfc0791.txt).
IETF RFC 819
The Domain Naming Convention for Internet User Applications,
Z. Su, J. Postel, August 1982 (available at:
www.ietf.org/rfc/rfc0819.txt).
IETF RFC 822
Standard for the Format of ARPA Internet Text Messages,
D.H. Crocker, August 1982 (available at:
www.ietf.org/rfc/rfc0822.txt).
IETF RFC 919
Broadcasting Internet Datagrams,
J. Mogul, October 1984 (available at:
www.ietf.org/rfc/rfc0919.txt).
IETF RFC 920
Domain Requirements,
J. Postel, J. Reynolds, October 1984 (available at:
www.ietf.org/rfc/rfc0920.txt).
IETF RFC 921
Domain Name System Implementation Schedule,
J. Postel, October 1984 (available at:
www.ietf.org/rfc/rfc0921.txt).
IETF RFC 922
Broadcasting Internet Datagrams in the Presence of Subnets,
J. Mogul, October 1984 (available at:
www.ietf.org/rfc/rfc0922.txt).
IETF RFC 1034
Domain Names - Concepts and Facilities,
P. Mockapetris, November 1987 (available at:
www.ietf.org/rfc/rfc1034.txt).
IETF RFC 1035
Domain Names - Implementation and Specification,
P. Mockapetris, November 1987 (available at:
www.ietf.org/rfc/rfc1035.txt).
IETF RFC 1123
Requirements for Internet Hosts - Application and Support,
R. Braden, October 1989 (available at:
www.ietf.org/rfc/rfc1123.txt).
IETF RFC 1886
DNS Extensions to Support Internet Protocol, Version 6 (IPv6),
C. Huitema, S. Thomson, December 1995 (available at:
www.ietf.org/rfc/rfc1886.txt).
IETF RFC 2045
Multipurpose Internet Mail Extensions (MIME), Part 1:
Format of Internet Message Bodies,
N. Freed, N. Borenstein, November 1996 (available at:
www.ietf.org/rfc/rfc2045.txt).
IETF RFC 2181
Clarifications to the DNS Specification,
R. Elz, R. Bush, July 1997 (available at:
www.ietf.org/rfc/rfc2181.txt).
IETF RFC 2373
Internet Protocol, Version 6 (IPv6) Addressing Architecture,
S. Deering, R. Hinden, July 1998 (available at:
www.ietf.org/rfc/rfc2373.txt).
IETF RFC 2460
Internet Protocol, Version 6 (IPv6),
S. Deering, R. Hinden, December 1998 (available at:
www.ietf.org/rfc/rfc2460.txt).
Internationalisation Guide
Guide, July 1993,
Internationalisation Guide, Version 2
(ISBN: 1-859120-02-4, G304), published by The Open Group.
ISO 2375:1985
ISO 2375:1985, Data Processing - Procedure for Registration
of Escape Sequences.
ISO 8652:1987
ISO 8652:1987, Programming Languages - Ada
(technically identical to ANSI standard 1815A-1983).
ISO/IEC 1539:1991
ISO/IEC 1539:1991, Information Technology - Programming
Languages - Fortran
(technically identical to the ANSI X3.9-1978 standard [FORTRAN 77]).
ISO/IEC 4873:1991
ISO/IEC 4873:1991, Information Technology -
ISO 8-bit Code for Information Interchange -
Structure and Rules for Implementation.
ISO/IEC 6429:1992
ISO/IEC 6429:1992, Information Technology - Control Functions for
Coded Character Sets.
ISO/IEC 6937:1994
ISO/IEC 6937:1994, Information Technology - Coded Graphic
Character Set for Text Communication - Latin Alphabet.
ISO/IEC 8802-3:1996
ISO/IEC 8802-3:1996, Information Technology -
Telecommunications and Information Exchange Between Systems -
Local and Metropolitan Area Networks -
Specific Requirements -
Part 3: Carrier Sense Multiple Access with Collision Detection (CSMA/CD)
Access Method and Physical Layer Specifications.
ISO/IEC 8859
ISO/IEC 8859, Information Technology -
8-Bit Single-Byte Coded Graphic Character Sets:
Part 1: Latin Alphabet No. 1
Part 2: Latin Alphabet No. 2
Part 3: Latin Alphabet No. 3
Part 4: Latin Alphabet No. 4
Part 5: Latin/Cyrillic Alphabet
Part 6: Latin/Arabic Alphabet
Part 7: Latin/Greek Alphabet
Part 8: Latin/Hebrew Alphabet
Part 9: Latin Alphabet No. 5
Part 10: Latin Alphabet No. 6
Part 11: Latin/Thai Alphabet
Part 13: Latin Alphabet No. 7
Part 14: Latin Alphabet No. 8 (Celtic)
Part 15: Latin Alphabet No. 9
Part 16: Latin Alphabet No. 10
ISO/IEC 9899:1990
ISO/IEC 9899:1990, Programming Languages - C, including
Amendment 1:1995 (E), C Integrity (Multibyte Support Extensions
(MSE) for ISO C).
ISO POSIX-1:1996
ISO/IEC 9945-1:1996,
Information Technology -
Portable Operating System Interface (POSIX) -
Part 1: System Application Program Interface (API) [C Language]
(identical to ANSI/IEEE Std 1003.1-1996).
Incorporating ANSI/IEEE Stds 1003.1-1990, 1003.1b-1993,
1003.1c-1995, and 1003.1i-1995.
ISO POSIX-2:1993
ISO/IEC 9945-2:1993, Information Technology -
Portable Operating System Interface (POSIX) -
Part 2: Shell and Utilities
(identical to ANSI/IEEE Std 1003.2TM-1992, as amended by
ANSI/IEEE Std 1003.2aTM-1992).
Issue 1
X/Open Portability Guide, July 1985
(ISBN: 0-444-87839-4).
Issue 2
X/Open Portability Guide, January 1987:
Volume 1: XVS Commands and Utilities (ISBN: 0-444-70174-5)
Volume 2: XVS System Calls and Libraries (ISBN: 0-444-70175-3)
Issue 3
X/Open Specification, 1988, 1989, February 1992:
Commands and Utilities, Issue 3 (ISBN: 1-872630-36-7, C211);
this specification was formerly
X/Open Portability Guide, Issue 3, Volume 1, January 1989,
XSI Commands and Utilities
(ISBN: 0-13-685835-X, XO/XPG/89/002)
System Interfaces and Headers, Issue 3 (ISBN: 1-872630-37-5, C212);
this specification was formerly
X/Open Portability Guide, Issue 3, Volume 2, January 1989,
XSI System Interface and Headers
(ISBN: 0-13-685843-0, XO/XPG/89/003)
Curses Interface, Issue 3,
contained in Supplementary Definitions, Issue 3
(ISBN: 1-872630-38-3, C213), Chapters 9 to 14 inclusive;
this specification was formerly
X/Open Portability Guide, Issue 3, Volume 3, January 1989,
XSI Supplementary Definitions
(ISBN: 0-13-685850-3, XO/XPG/89/004)
Headers Interface, Issue 3,
contained in Supplementary Definitions, Issue 3
(ISBN: 1-872630-38-3, C213), Chapter 19, Cpio and Tar Headers;
this specification was formerly
X/Open Portability Guide Issue 3, Volume 3, January 1989,
XSI Supplementary Definitions
(ISBN: 0-13-685850-3, XO/XPG/89/004)
Issue 4
CAE Specification, July 1992, published by The Open Group:
System Interface Definitions (XBD), Issue 4
(ISBN: 1-872630-46-4, C204)
Commands and Utilities (XCU), Issue 4
(ISBN: 1-872630-48-0, C203)
System Interfaces and Headers (XSH), Issue 4
(ISBN: 1-872630-47-2, C202)
Issue 4, Version 2
CAE Specification, August 1994, published by The Open Group:
System Interface Definitions (XBD), Issue 4, Version 2
(ISBN: 1-85912-036-9, C434)
Commands and Utilities (XCU), Issue 4, Version 2
(ISBN: 1-85912-034-2, C436)
System Interfaces and Headers (XSH), Issue 4, Version 2
(ISBN: 1-85912-037-7, C435)
Issue 5
Technical Standard, February 1997, published by The Open Group:
System Interface Definitions (XBD), Issue 5
(ISBN: 1-85912-186-1, C605)
Commands and Utilities (XCU), Issue 5
(ISBN: 1-85912-191-8, C604)
System Interfaces and Headers (XSH), Issue 5
(ISBN: 1-85912-181-0, C606)
Issue 6
Technical Standard, April 2004, published by The Open Group:
Base Definitions (XBD), Issue 6
(ISBN: 1-931624-43-7, C046)
System Interfaces (XSH), Issue 6
(ISBN: 1-931624-44-5, C047)
Shell and Utilities (XCU), Issue 6
(ISBN: 1-931624-45-3, C048)
Knuth Article
Knuth, Donald E., On the Translation of Languages from Left to
Right, Information and Control, Volume 8, No. 6, October 1965.
KornShell
Bolsky, Morris I. and Korn, David G.,
The New KornShell Command and Programming Language,
March 1995, Prentice Hall.
MSE Working Draft
Working draft of ISO/IEC 9899:1990/Add3:Draft, Addendum 3 -
Multibyte Support Extensions (MSE) as documented in the ISO Working Paper
SC22/WG14/N205 dated 31 March 1992.
POSIX.0:1995
IEEE Std 1003.0TM-1995,
IEEE Guide to the POSIX Open System Environment (OSE)
(identical to ISO/IEC TR 14252).
POSIX.1:1988
IEEE Std 1003.1TM-1988,
IEEE Standard for Information Technology - Portable Operating System
Interface (POSIX) - Part 1: System Application Program Interface
(API) [C Language].
POSIX.1:1990
IEEE Std 1003.1TM-1990,
IEEE Standard for Information Technology - Portable Operating System
Interface (POSIX) - Part 1: System Application Program Interface
(API) [C Language].
POSIX.1a
P1003.1a, Standard for Information Technology -
Portable Operating System Interface (POSIX) -
Part 1: System Application Program Interface (API) -
(C Language) Amendment.
POSIX.1d:1999
IEEE Std 1003.1dTM-1999,
IEEE Standard for Information Technology - Portable Operating System
Interface (POSIX) - Part 1: System Application Program Interface
(API) - Amendment 4: Additional Realtime Extensions [C Language].
POSIX.1g:2000
IEEE Std 1003.1gTM-2000,
IEEE Standard for Information Technology - Portable Operating System
Interface (POSIX) - Part 1: System Application Program Interface
(API) - Amendment 6: Protocol-Independent Interfaces (PII).
POSIX.1j:2000
IEEE Std 1003.1jTM-2000,
IEEE Standard for Information Technology - Portable Operating System
Interface (POSIX) - Part 1: System Application Program Interface
(API) - Amendment 5: Advanced Realtime Extensions [C Language].
POSIX.1q:2000
IEEE Std 1003.1qTM-2000,
IEEE Standard for Information Technology - Portable Operating System
Interface (POSIX) - Part 1: System Application Program Interface
(API) - Amendment 7: Tracing [C Language].
POSIX.2b
P1003.2b, Standard for Information Technology -
Portable Operating System Interface (POSIX) -
Part 2: Shell and Utilities - Amendment.
POSIX.2d:1994
IEEE Std 1003.2dTM-1994,
IEEE Standard for Information Technology - Portable Operating System
Interface (POSIX) - Part 2: Shell and Utilities - Amendment 1:
Batch Environment.
POSIX.13:1998
IEEE Std 1003.13TM-1998,
IEEE Standard for Information Technology - Standardized Application
Environment Profile (AEP) - POSIX Realtime Application Support.
Sarwate Article
Sarwate, Dilip V., Computation of Cyclic Redundancy Checks via
Table Lookup, Communications of the ACM, Volume 30, No. 8,
August 1988.
Sprunt, Sha, and Lehoczky
Sprunt, B., Sha, L., and Lehoczky, J.P., Aperiodic Task Scheduling for
Hard Real-Time Systems, The Journal of Real-Time Systems,
Volume 1, 1989, Pages 27-60.
SVID, Issue 1
American Telephone and Telegraph Company,
System V Interface Definition (SVID), Issue 1;
Morristown, NJ, UNIX Press, 1985.
SVID, Issue 2
American Telephone and Telegraph Company,
System V Interface Definition (SVID), Issue 2;
Morristown, NJ, UNIX Press, 1986.
SVID, Issue 3
American Telephone and Telegraph Company,
System V Interface Definition (SVID), Issue 3;
Morristown, NJ, UNIX Press, 1989.
The AWK Programming Language
Aho, Alfred V., Kernighan, Brian W., and Weinberger, Peter J.,
The AWK Programming Language, Reading, MA, Addison-Wesley 1988.
UNIX Programmer's Manual
American Telephone and Telegraph Company, UNIX Time-Sharing System:
UNIX Programmer's Manual, 7th Edition, Murray Hill, NJ, Bell
Telephone Laboratories, January 1979.
XNS, Issue 4
CAE Specification, August 1994,
Networking Services, Issue 4
(ISBN: 1-85912-049-0, C438), published by The Open Group.
XNS, Issue 5
CAE Specification, February 1997,
Networking Services, Issue 5
(ISBN: 1-85912-165-9, C523), published by The Open Group.
XNS, Issue 5.2
Technical Standard, January 2000,
Networking Services (XNS), Issue 5.2
(ISBN: 1-85912-241-8, C808), published by The Open Group.
X/Open Curses, Issue 4, Version 2
CAE Specification, May 1996,
X/Open Curses, Issue 4, Version 2
(ISBN: 1-85912-171-3, C610), published by The Open Group.
Yacc
Yacc: Yet Another Compiler Compiler, Stephen C. Johnson, 1978.
Source Documents
Parts of the following documents were used to create the base documents
for POSIX.1-2024:
AIX 3.2 Manual
AIX Version 3.2 For RISC System/6000, Technical Reference: Base
Operating System and Extensions, 1990, 1992 (Part No. SC23-2382-00).
OSF/1
OSF/1 Programmer's Reference, Release 1.2
(ISBN: 0-13-020579-6).
OSF AES
Application Environment Specification (AES) Operating System
Programming Interfaces Volume, Revision A
(ISBN: 0-13-043522-8).
System V Release 2.0
UNIX System V Release 2.0 Programmer's Reference Manual
(April 1984 - Issue 2).
UNIX System V Release 2.0 Programming Guide
(April 1984 - Issue 2).
System V Release 4.2
Operating System API Reference, UNIX® SVR4.2 (1992)
(ISBN: 0-13-017658-3).
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a registered Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XCU | XSH | XRAT
]
===== susv5-html/frontmatter/participants.html =====
Participants
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright© 2001-2024 The IEEE and The Open Group
Participants
IEEE
Std 1003.1™-2024 was prepared by the Austin Group,
sponsored by the Microprocessor Standards Committee of the IEEE
Computer Society, The Open Group, and ISO/IEC JTC 1/SC 22.
The Austin Group
IEEE
At the time of approval, the membership of the Austin Group was as
follows:
Andrew Josey, Chair
Donald W. Cragun, Organizational Representative, IEEE MSC
Nicholas M. Stoughton, Organizational Representative, ISO/IEC JTC 1/SC 22
Eric Blake, Organizational Representative, The Open Group
Cathy Fox, Geoff Clare, Technical Editors
Austin Group Technical Reviewers
William Ahern
Mohamed Akram
Joe Auricchio
Ori Avtalion
Bogdan Barbu
Steve Bartolomei
Petr Baudis
Fabrice Bauzac
Eric Blake
Mark S. Brown
Erik Cederstrand
Stéphane Chazelas
Scott Cheloha
Alexander Cherepanov
Geoff Clare
Robert Clausecker
Daniel Colascione
Garrett Cooper
Alan Coopersmith
Ralph Corderoy
Ciprian Dorin Craciun
Donald W. Cragun
Mike Crowe
Martijn Dekker
Andrés Delfino
D.J. Delorie
Matthew Dempsky
Antonio Diaz
Ulrich Drepper
Paul Eggert
Robert Elz
Steve Emmerson
Laszlo Ersek
Andras Farkas
Richard Felker
Dirk Fieldhouse
Mike Frysinger
Mark Galeck
Enrique Garcia
Thorsten Glaser
Dmitry Goncharov
Christopher M. Graff
Quinn Grier
Philip Guenther
Bruno Haible
Richard Hansen
Guy Harris
Mark Harris
Gavin Howard
Elliott Hughes
Roland Illig
Jarmo Jaakkola
Andrew Josey
Nickolas Raymond Kaczynski
Nate Karstens
Michael Kerrisk
Alexey Khoroshilov
Elad Lahav
Jeff Layton
Vincent Lefèvre
Mark Lundblad
Roger Marquis
Nikos Mavrogiannopoulos
Davin McCall
Mihail Mihaylov
Todd C. Miller
Christoph Anton Mitterer
Mihai Moldovan
Ed Morton
Joseph S. Myers
Szabolcs Nagy
Jonathan Nieder
Danny Niu
Steffen Nurpmeso
Richard Palethorpe
Daniele Palumbo
Isabella Parakiss
Ben Pfaff
J. William Piggott
Wayne Pollock
Quentin Rameau
Martin Řehák
Torvald Riegel
G. Branden Robinson
Xavier Roche
Bastien Roucaries
Daniel Sabogal
Askar Safin
Jörg Schilling
Ed Schouten
Konrad Schwarz
Ingo Schwarze
Martin Sebor
Olaf 'Rhialto' Seibert
Joel Sherrill
Curtis Smith
Paul Smith
Job Snijders
Oliver Soong
Dimitri Staessens
Nicholas M. Stoughton
Sören Tempel
Jilles Tjoelker
William Toth
Fred J. Tydeman
Stijn van Dronrgelen
Lawrence Velázquez
Evgeny Vereshchagin
Rasmus Villemoes
Dennis Wölfing
Jonathan Wakely
Colin Watson
Nathan Weeks
Florian Weimer
Zack Weinberg
David A. Wheeler
Nicolas Williams
Yousong Zhou
Mark Ziegast
Roman Žilka
Austin Group Working Group Members
Hans Aberg
Eric Ackermann
Godmar Back
Eric Blake
Volodymyr Boyko
Andries E. Brouwer
Mark S. Brown
Jefferson Carpenter
Olivier Certner
Stéphane Chazelas
Tom Cherry
Earl Chew
Geoff Clare
Joshua M. Clulow
Alan Coopersmith
Donald W. Cragun
Mike Crowe
Martijn Dekker
Matthew Dempsky
Drew DeVault
Casper Dik
Deepa Dinamani
Dan Douglas
Niall Douglas
Ulrich Drepper
Lawrence D.K.B. Dwyer
Paul Eggert
Daniel Eischen
Julian Elischer
Robert Elz
Bruce Evans
Richard Felker
Jeffrey K. Fellin
Dirk Fieldhouse
Hal Finkel
Michael Forney
Mike Frysinger
Mark Galeck
Thorsten Glaser
Andreas Grapentin
Michael Greenberg
Philip Guenther
Joseph M. Gwinn
Jan Hafer
Bruno Haible
Richard Hansen
Mark Harris
David Holland
Gavin Howard
Elliott Hughes
Roland Illig
Lennart Jablonka
Chris F.A. Johns
Darrin Johnson
Andrew Josey
Nate Karstens
Dan Kegel
Michael Kerrisk
Anton Khikhlukha
Ukko Koknevics
Bruce Korb
David Korn
Rob Landley
Vincent Lefèvre
Wojtek Lerch
Charlie Lin
Scott Lurndal
Roger Marquis
Davin McCall
Stephen Michell
Per Mildner
Christoph Anton Mitterer
Thomas Mueller
Wilhelm Mueller
Koichi Murase
Joseph S. Myers
Danny Niu
Gian Ntzik
Steffen Nurpmeso
Carlos O'Donell
Andrew Pennebaker
Steven Penny
Colin Percival
J. William Piggott
Wayne Pollock
Quentin Rameau
Chet Ramey
Gabriel Ravier
G. Branden Robinson
Eric Sanchis
Daniel Santos
Jörg Schilling
Ed Schouten
Konrad Schwarz
Ingo Schwarze
John Scott
Simon Ser
Joel Sherrill
Thor Lancelot Simon
Keld Simonsen
Paul Smith
Job Snijders
Gabriel Soldani
Oliver Soong
Dimitri Staessens
Marc J. Stephenson
Nicholas M. Stoughton
Oskar Sveinsen
Alfred M. Szmidt
Tapani Tarvainen
Alexander Terekhov
Donn Terry
Jilles Tjoelker
Fred J. Tydeman
Oğuz Uysal
Harald van Dijk
Lawrence Velázquez
Oleksii Vilchansk
Corinna Vinschen
Jonathan Wakely
L.A. Walsh
David A. Wheeler
Jakub Wilk
Dennis Wölfing
Garrett Wollman
Jörg Wunsch
Ryan Zezeski
Mark Ziegast
Jason Zions
The Open Group
When The Open Group approved the Base
Specifications, Issue 8 on 21 March 2024, the membership of The Open Group Base Working Group was as follows:
Andrew Josey, Chair
Eric Blake, Austin Group Liaison
Cathy Fox, Geoff Clare, Technical Editors
Base Working Group Members
Joe Auricchio
Eric Blake
Geoff Clare
Donald W. Cragun
Andrew Josey
Mark Ziegast
IEEE
At the time this standard was completed the Microprocessor Committee had the following membership:
Ralph Baker Kearfott, Chair
Leonard Tsai, Vice Chair and P754 Chair
Andrew Josey, P1003.1 Chair
Donald W. Cragun, Austin Group Liaison
Joseph M. Gwinn, Ex-officio Emeritus
Richard Bugg, P1722.1 Chair
Kiran Gunnam, P3109 Chair
David Hough, Outgoing P754 Chair
Dave Olsen, P1722 Chair
Nathalie Revol, P1788 Chair
Blaise Vignon, P3109 Chair
The following members of the individual Standards Association
balloting group voted on this standard. Balloters may have voted
for approval, disapproval, or abstention.
Boon Chong Ang
Steven Bezner
Diego Chiozzi
Donald W. Cragun
Andrew Fieldsend
David Fuschi
Jie Guan
Joseph M. Gwinn
Werner Hoelzl
Andrew Josey
Piotr Karocki
Kenneth Lang
Rajesh Murthy
Venkatesha Prasad
Stephen Schwarm
Walter Struppler
Oren Yuen
Janusz Zalewski
IEEE-SA Standards Board
When the IEEE-SA Standards Board approved this
standard on 20 May 2024, it had the following membership:
David J. Law, Chair
Jon Walter Rosdahl, Vice Chair
Gary Hoffman, Past Chair
Alpesh Shah, Secretary
Sara R. Biyabani
Ted Burse
Stephen Dukes
Doug Edwards
J. Travis Griffith
Guido R. Hiertz
Ronald W Hotchkiss
Hao Hu
Yousef Kimiagar
Joseph L. Koepfinger*
Howard Li
Xiaohui Liu
John Haiying Lu
Kevin W. Lu
Hiroshi Mano
Paul Nikolich
Robby Robson
Lei Wang
F. Keith Waters
Sha Wei
Philip B. Winston
Don Wright
* Member Emeritus
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright© 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XCU | XSH | XRAT
]
===== susv5-html/frontmatter/typographics.html =====
Codes
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024 Edition
Copyright © 2001-2024 The IEEE and The Open Group
Typographical Conventions
The following typographical conventions are
used throughout this standard. In the text, this standard is referred to as POSIX.1-2024, which is technically identical to The
Open Group Base Specifications, Issue 8.
The typographical conventions listed here are
for ease of reading only. Editorial inconsistencies in the use of typography are unintentional and have no normative meaning in
POSIX.1-2024.
Reference
Example
Notes
C-Language Data Structure
aiocb
C-Language Data Structure Member
aio_lio_opcode
C-Language Data Type
long
C-Language External Variable
errno
C-Language Function
system()
C-Language Function Argument
arg
C-Language Function Family
exec
C-Language Header
C-Language Keyword
return
C-Language Macro with Argument
assert()
C-Language Macro with No Argument
NET_ADDRSTRLEN
C-Language Preprocessing Directive
#define
Commands within a Utility
a, c
Conversion Specifier, Specifier/Modifier Character
%A, g, E
1
Environment Variable
PATH
Error Number
[EINTR]
Example Output
Hello, World
Filename
/tmp
Literal Character
'c', '\r'
2
Literal String
"abcde"
2
Optional Items in Utility Syntax
[ ]
Parameter
Special Character
3
Symbolic Constant
_POSIX_VDISABLE
Symbolic Limit, Configuration Value
{LINE_MAX}
4
Syntax
#include
User Input and Example Code
echo Hello, World
5
Utility Name
awk
Utility Operand
file_name
Utility Option
-c
Utility Option with Option-Argument
-w width
Note that:
Conversion specifications, specifier characters, and
modifier characters are used primarily in date-related functions and utilities and the fprintf() and fscanf()
formatting functions.
Unless otherwise noted, the quotes shall not be used
as input or output. When used in a list item, the quotes are omitted. The literal characters  (also known as
single-quote) and  are either shown as the C constants '\'' and '\\', respectively, or as the
special characters , single-quote, and  depending on context.
The style selected for some of the special
characters, such as , matches the form of the input given to the localedef utility. Generally, the characters
selected for this special treatment are those that are not visually distinct, such as the control characters  or
.
Names surrounded by braces represent symbolic limits
or configuration values which may be declared in appropriate headers by means of the C #define construct.
Brackets shown in this font, "[ ]", are part of the syntax and do not indicate optional items. In
syntax the '|' symbol is used to separate alternatives, and
ellipses ("...") are used to show that additional arguments
are optional.
Shading is used to identify extensions and
options.
Footnotes and notes within the body of the
normative text are for information only (informative).
Informative sections (such as Rationale, Change
History, Application Usage, and so on) are denoted by continuous shading bars in the margins.
Ranges of values are indicated with parentheses
or brackets as follows:
(a,b) means the range of all values
from a to b, including neither a nor b.
[a,b] means the range of all values
from a to b, including a and b.
[a,b) means the range of all values
from a to b, including a, but not b.
(a,b] means the range of all values
from a to b, including b, but not a.
Note: A symbolic limit beginning with POSIX is treated differently, depending on context. In a C-language header, the
symbol POSIXstring (where string may contain underscores) is represented by the C identifier _POSIXstring,
with a leading underscore required to prevent ISO C standard name space pollution. However, in other contexts, such as languages
other than C, the leading underscore is not used because this requirement does not exist.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XCU | XSH | XRAT
]
===== susv5-html/frontmatter/trademarks.html =====
Trademarks
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
Trademarks
The following information is given for the convenience of users of POSIX.1-2024
and does not constitute an endorsement by the IEEE or The Open Group of
these products. Equivalent products may be used if they can be shown to
lead to the same results.
There may be other products mentioned in the text that might be covered by
trademark protection and readers are advised to verify them independently.
AIX® and IBM® are registered trademarks of IBM Corporation.
ArchiMate®, FACE®, FACE® logo, Future Airborne Capability Environment®, Making Standards Work®, Open Footprint®, Open O® logo, Open O and Check® certification logo, OSDU®, Platform 3.0®, The Open Group®, TOGAF®, UNIX®, UNIXWARE®, and X® logo are registered trademarks and Boundaryless Information Flow™, Build with Integrity Buy with Confidence™, Commercial Aviation Reference Architecture™, Dependability Through Assuredness™, Digital Practitioner Body of Knowledge™, DPBoK™, EMMM™, FHIM Profile Builder™, FHIM logo, FPB™, IT4IT™, IT4IT™ logo, O-AA™, O-DA™, O-DEF™, O-HERA™, O- PAS™, O-TTPS™, Open Agile Architecture™, Open FAIR™, Open Process Automation™, Open Subsurface Data Universe™, Open Trusted Technology Provider™, Sensor Integration Simplified™, Sensor Open Systems Architecture™, SOSA™, and SOSA™ logo are trademarks of The Open Group.
AT&T® is a registered trademark of AT&T in the USA and
other countries.
BSD™ is a trademark of the University of California, Berkeley, USA.
Hewlett-Packard®, HP®, and HP-UX® are registered trademarks
of Hewlett-Packard Company.
IEEE® is a registered trademark, and POSIX™,
754™, 854™, 1003.0™, 1003.1™, 1003.1d™, 1003.1g™,
1003.1j™, 1003.1q™, 1003.2™, 1003.2a™, 1003.2d™,
1003.9™, and 1003.13™
are trademarks of The Institute of Electrical and Electronic
Engineers, Inc.
Linux® is a registered trademark of Linus Torvalds.
Sun® and Sun Microsystems® are registered trademarks of Oracle
America, Inc.
/usr/group® is a registered trademark of UniForum, the International
Network of UNIX System Users.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XCU | XSH | XRAT
]
===== susv5-html/frontmatter/notice.html =====
Participants
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
Notice to Users
Laws and Regulations
Users of IEEE Standards documents should consult all applicable laws and regulations. Compliance with the provisions of any IEEE Standards document does not constitute compliance to any applicable regulatory requirements. Implementers of the standard are responsible for observing or referring to the applicable regulatory requirements. IEEE does not, by the publication of its standards, intend to urge action that is not in compliance with applicable laws, and these documents may not be construed as doing so.
Data Privacy
Users of IEEE Standards documents should evaluate the standards for considerations of data privacy and data ownership in the context of assessing and using the standards in compliance with applicable laws and regulations.
Copyrights
This document is copyrighted by the IEEE and
The Open Group. It is made available for a wide variety of both public and private uses. These include both use, by reference, in
laws and regulations, and use in private self-regulation, standardization, and the promotion of engineering practices and methods.
By making this document available for use and adoption by public authorities and private users, the IEEE and The Open Group do not
waive any rights in copyright to this document.
Updating of IEEE Standards Documents
Users of IEEE Standards documents should be aware that these documents
may be superseded at any time by the issuance of new editions or
may be amended from time to time through the issuance of amendments,
corrigenda, or errata. An official IEEE document at any point in
time consists of the current edition of the document together with
any amendments, corrigenda, or errata then in effect.
Every IEEE standard is subjected to review at least every 10 years. When a document is more than 10 years old and has not undergone a revision process, it is reasonable to conclude that its contents, although still of some value, do not wholly reflect the present state of the art. Users are cautioned to check to determine that they have the latest edition of any IEEE standard.
In order to determine whether a given document is the current edition
and whether it has been amended through the issuance of amendments,
corrigenda, or errata, visit IEEE Xplore or contact IEEE. For more
information about the IEEE SA or IEEE’s standards development
process, visit the IEEE SA Website.
Errata
Errata, if any, for all IEEE standards can be accessed on the
IEEE
SA Website. Search for standard number and year of approval to
access the web page of the published standard. Errata links are
located under the Additional Resources Details section. Errata are
also available in IEEE Xplore. Users are encouraged to periodically
check for errata.
Patents
Attention is called to the possibility that
implementation of this standard may require use of subject matter covered by patent rights. By publication of this standard, no
position is taken with respect to the existence or validity of any patent rights in connection therewith. If a patent holder or patent
applicant has filed a statement of assurance via an Accepted Letter of Assurance, then the statement is listed on the IEEE-SA
website at
http://standards.ieee.org/about/sasb/patcom/patents.html.
Letters of Assurance may indicate whether the Submitter is willing or
unwilling to grant licenses under patent rights without compenstation
or under reasonable rates, with reasonable terms and conditions that are demonstrably free of any unfair discrimination to applicants
desiring to obtain such licenses.
Essential Patent Claims may exist for which a
Letter of Assurance has not been received.
The IEEE and The Open Group are not responsible for identifying Essential Patent Claims for which a license may be required, for
conducting inquiries into the legal validity or scope of Patents Claims, or determining whether any licensing terms or conditions
are reasonable or non-discriminatory. Users of this standard are expressly advised that determination of the validity of any patent
rights, and the risk of infringement of such rights, is entirely their own responsibility. Further information may be obtained from the IEEE Standards Association and The Open
Group.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XCU | XSH | XRAT
]
===== susv5-html/frontmatter/preface.html =====
The Base Specifications Issue 8
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
POSIX.1-2024 is
simultaneously IEEE Std 1003.1™-2024 and The Open Group Standard Base Specifications,
Issue 8.
Introduction
This introduction is not part of IEEE Std 1003.1-2024, IEEE Standard for Information Technology —
Portable Operating System Interface (POSIX™) — Base Specifications, Issue 8.
This standard was
developed, and is maintained, by a joint working group of members of the IEEE Microprocessor Standards Committee, members of
The Open Group, and members of ISO/IEC Joint Technical Committee 1. This joint working group is known as the Austin
Group.1
The Austin Group arose out of discussions
amongst the parties which started in early 1998, leading to an initial meeting and formation of the group in September 1998. The
purpose of the Austin Group is to develop and maintain the core open systems interfaces that are the POSIX® 1003.1
(and former 1003.2) standards, ISO/IEC 9945, and the core of the Single UNIX® Specification.
The approach to specification development has
been one of “write once, adopt everywhere”, with the deliverables being a set of specifications that carry the IEEE
POSIX designation, The Open Group Standard designation, and an ISO/IEC designation.
This unique development has combined both the
industry-led efforts and the formal standardization activities into a single initiative, and included a wide spectrum of
participants. The Austin Group continues as the maintenance body for this document.
Anyone wishing to participate in the Austin
Group should contact the chair with their request. There are no fees for participation or membership. You may participate as an
observer or as a contributor. You do not have to attend face-to-face meetings to participate; electronic participation is most
welcome. For more information on the Austin Group and how to participate, see
www.opengroup.org/austin.
Background
The developers of POSIX.1-2024 represent a
cross-section of hardware manufacturers, vendors of operating systems and other software development tools, software designers,
consultants, academics, authors, applications programmers, and others.
Conceptually, POSIX.1-2024 describes a set of
fundamental services needed for the efficient construction of application programs. Access to these services has been provided by
defining an interface, using the C programming language, a command interpreter, and common utility programs that establish standard
semantics and syntax. Since this interface enables application developers to write portable applications – it was developed
with that goal in mind – it has been designated POSIX1, an acronym for Portable Operating System Interface.
Although originated to refer to the original
IEEE Std 1003.1-1988, the name POSIX more correctly refers to a family of related standards: IEEE Std 1003.n and the
parts of ISO/IEC 9945. In earlier editions of the IEEE standard, the term POSIX was used as a synonym for IEEE Std 1003.1-1988. A
preferred term, POSIX.1, emerged. This maintained the advantages of readability of the symbol “POSIX” without being
ambiguous with the POSIX family of standards.
Audience
The intended audience for POSIX.1-2024 is all
persons concerned with an industry-wide standard operating system based on the UNIX system. This includes at least four groups of
people:
Persons buying hardware and software
systems
Persons managing companies that are deciding on
future corporate computing directions
Persons implementing operating systems, and
especially
Persons developing applications where portability is
an objective
Purpose
Several principles guided the development of
POSIX.1-2024:
Application-Oriented – The basic goal was to
promote portability of application programs across UNIX system environments by developing a clear, consistent, and unambiguous
standard for the interface specification of a portable operating system based on the UNIX system documentation. POSIX.1-2024
codifies the common, existing definition of the UNIX system.
Interface, Not Implementation – POSIX.1-2024
defines an interface, not an implementation. No distinction is made between library functions and system calls; both are referred
to as functions. No details of the implementation of any function are given (although historical practice is sometimes indicated in
the RATIONALE section). Symbolic names are given for constants (such as signals and error numbers) rather than numbers.
Source, Not Object, Portability – POSIX.1-2024
has been written so that a program written and translated for execution on one conforming implementation may also be translated for
execution on another conforming implementation. POSIX.1-2024 does not guarantee that executable (object or binary) code will
execute under a different conforming implementation than that for which it was translated, even if the underlying hardware is
identical.
The C Language – The system interfaces and
header definitions are written in terms of the standard C language as specified in the ISO C standard.
No Superuser, No System Administration – There
was no intention to specify all aspects of an operating system. System administration facilities and functions are excluded from
this standard, and functions usable only by the superuser have not been included. Still, an implementation of the standard
interface may also implement features not in POSIX.1-2024. POSIX.1-2024 is also not concerned with hardware constraints or system
maintenance.
Minimal Interface, Minimally Defined – In
keeping with the historical design principles of the UNIX system, the mandatory core facilities of POSIX.1-2024 have been kept as
minimal as possible. Additional capabilities have been added as optional extensions.
Broadly Implementable – The developers of
POSIX.1-2024 endeavored to make all specified functions implementable across a wide range of existing and potential systems,
including:
All of the current major systems that are ultimately
derived from the original UNIX system code (Version 7 or later)
Compatible systems that are not derived from the
original UNIX system code
Emulations hosted on entirely different operating
systems
Networked systems
Distributed systems
Systems running on a broad range of
hardware
No direct references to this
goal appear in POSIX.1-2024, but some results of it are mentioned in the Rationale (Informative) volume.
Minimal Changes to Historical Implementations –
When the original version – IEEE Std 1003.1-1988 – was published, there were no known historical implementations that
did not have to change. However, there was a broad consensus on a set of functions, types, definitions, and concepts that formed an
interface that was common to most historical implementations.
The adoption of the 1988 and
1990 IEEE system interface standards, the 1992 IEEE shell and utilities standard, the various The Open Group (formerly X/Open)
specifications, and IEEE Std 1003.1-2001 and its technical corrigenda have consolidated this consensus, and this version reflects
the significantly increased level of consensus arrived at since the original versions. The authors of the original versions tried,
as much as possible, to follow the principles below when creating new specifications:
By standardizing an interface like one in an
historical implementation; for example, directories
By specifying an interface that is readily
implementable in terms of, and backwards-compatible with, historical implementations, such as the extended tar format
defined in the pax utility
By specifying an interface that, when added to an
historical implementation, will not conflict with it; for example, the sigaction() function
POSIX.1-2024 is specifically not
a codification of a particular vendor's product.
It should be noted that
implementations will have different kinds of extensions. Some will reflect “historical usage” and will be preserved for
execution of pre-existing applications. These functions should be considered “obsolescent” and the standard functions
used for new applications. Some extensions will represent functions beyond the scope of POSIX.1-2024. These need to be used with
careful management to be able to adapt to future extensions of POSIX.1-2024 and/or port to implementations that provide these
services in a different manner.
Minimal Changes to Existing Application Code –
A goal of POSIX.1-2024 was to minimize additional work for application developers. However, because every known historical
implementation will have to change at least slightly to conform, some applications will have to change.
POSIX.1-2024
POSIX.1-2024 defines the Portable Operating
System Interface (POSIX) requirements and consists of the following topics arranged as a series of volumes within the
standard:
Base Definitions
System Interfaces
Shell and Utilities
Rationale (Informative)
Base Definitions
The Base Definitions volume provides common
definitions for this standard, therefore readers should be familiar with it before using the other volumes.
This volume is structured as
follows:
Chapter 1 is an introduction.
Chapter 2 defines the conformance
requirements.
Chapter 3 defines general terms used.
Chapter 4 describes general concepts used.
Chapter 5 describes the notation used to specify file
input and output formats in this volume and the Shell and Utilities volume.
Chapter 6 describes the portable character set and
the process of character set definition.
Chapter 7 describes the syntax for defining
internationalization locales as well as the POSIX locale provided on all systems.
Chapter 8 describes the use of environment variables
for internationalization and other purposes.
Chapter 9 describes the syntax of pattern matching
using regular expressions employed by many utilities and matched by the regcomp() and regexec() functions.
Chapter 10 describes files and devices found on all
systems.
Chapter 11 describes the asynchronous terminal
interface for many of the functions in the System Interfaces volume and the stty utility in the Shell and Utilities
volume.
Chapter 12 describes the policies for command line
argument construction and parsing.
Chapter 13 describes namespace reservation.
Chapter 14 defines the contents of headers which
declare the functions and global variables, and define types, constants, macros, and data structures that are needed by programs
using the services provided by the System Interfaces volume.
Comprehensive references are available in the
Index.
System Interfaces
The System Interfaces volume describes the
interfaces offered to application programs by POSIX-conformant systems. Readers are expected to be experienced C language
programmers, and to be familiar with the Base Definitions volume.
This volume is structured as
follows:
Chapter 1 explains the status of this volume and its
relationship to other formal standards.
Chapter 2 contains important concepts, terms, and
caveats relating to the rest of this volume.
Chapter 3 defines the functional interfaces to the
POSIX-conformant system.
Comprehensive references are available in the
Index.
Shell and Utilities
The Shell and Utilities volume describes the
commands and utilities offered to application programs on POSIX-conformant systems. Readers are expected to be familiar with the
Base Definitions volume.
This volume is structured as
follows:
Chapter 1 explains the status of this volume and its
relationship to other formal standards. It also describes the defaults used by the utility descriptions.
Chapter 2 describes the command language used in
POSIX-conformant systems, and special built-in utilities.
Chapter 3 consists of reference pages for all
utilities, other than the special built-in utilities described in Chapter 2, available on POSIX-conformant systems.
Comprehensive references are available in the
Index.
Rationale (Informative)
The Rationale volume is published to assist in
the process of review. It contains historical information concerning the contents of this standard and why features were included
or discarded by the standard developers. It also contains notes of interest to application programmers on recommended programming
practices, emphasizing the consequences of some aspects of POSIX.1-2024 that may not be immediately apparent.
This volume is organized in parallel to the
normative volumes of this standard, with a separate part for each of the three normative volumes.
Within this volume, the following terms are
used:
Base standard – The portions of POSIX.1-2024
that are not optional, equivalent to the definitions of classic POSIX.1 and POSIX.2.
POSIX.0 – Although this term is not used in the
normative text of POSIX.1-2024, it is used in this volume to refer to IEEE Std 1003.0™-1995.
POSIX.1b – Although this term is not used in
the normative text of POSIX.1-2024, it is used in this volume to refer to the elements of the POSIX Realtime Extension amendment.
(This was earlier referred to as POSIX.4 during the standard development process.)
POSIX.1c – Although this term is not used in
the normative text of POSIX.1-2024, it is used in this volume to refer to the POSIX Threads Extension amendment. (This was earlier
referred to as POSIX.4a during the standard development process.)
Standard developers – The individuals and
companies in the development organizations responsible for POSIX.1-2024: the IEEE P1003.1 working groups, The Open Group Base
working group, advised by the hundreds of individual technical experts who balloted the draft standards within the Austin Group,
and the member bodies and technical experts of ISO/IEC JTC 1/SC 22.
XSI option – The portions of POSIX.1-2024
addressing the extension added for support of the Single UNIX Specification.
1 The Austin Group is named after the location of the inaugural meeting held at the IBM facility
in Austin, Texas in September 1998.
2 The Name POSIX was suggested by Richard Stallman.
It is expected to be pronounced pahz-icks, as in positive,
not poh-six, or other variations. The pronunciation has been published in an attempt to promulgate a
standardized way of referring to a standard operating system interface.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a registered Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XCU | XSH | XRAT
]
===== susv5-html/frontmatter/acknowl.html =====
Acknowledgements
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
Acknowledgements
The contributions of the following organizations to the development of
POSIX.1-2024 are gratefully acknowledged:
AT&T for permission to reproduce portions of its copyrighted
System V Interface Definition (SVID)
and material from the UNIX System V Release 2.0 documentation
Hewlett-Packard Company, International Business Machines Corporation,
Novell Inc., The Open Software Foundation, and
Sun Microsystems Inc. for permission to reproduce portions of their
copyrighted documentation
ISO/IEC JTC 1/SC 22/WG 14 C Language Committee
Red Hat Inc. for permission to reproduce portions of its copyrighted
documentation
POSIX.1-2024 was prepared by the Austin Group, a joint working group
of the IEEE, The Open Group, and ISO/IEC JTC 1/SC 22.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a registered Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XCU | XSH | XRAT
]
===== susv5-html/xrat/V4_xbd_chap01.html =====
Rationale for Base Definitions
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
A. Rationale for Base Definitions
A.1 Introduction
A.1.1 Scope
POSIX.1-2024 is one of a family of standards known as POSIX. The family of standards extends to many topics; POSIX.1 consists of
both operating system interfaces and shell and utilities. POSIX.1-2024 is technically identical to The Open Group Base
Specifications, Issue 8.
Scope of POSIX.1-2024
The (paraphrased) goals of this development were to revise the single document that is ISO/IEC 9945:2009 Parts 1 through 4 as
amended by ISO/IEC 9945:2009/Cor.1:2013 and ISO/IEC 9945:2009/Cor.2:2017, IEEE Std 1003.1-2017, and the appropriate parts of The
Open Group Single UNIX Specification, Version 5. This work has been undertaken by the Austin Group, a joint working group of IEEE,
The Open Group, and ISO/IEC JTC 1/SC 22.
The following are the base documents in this version:
IEEE Std 1003.1-2017
IEEE Std 1003.26-2003
ISO/IEC 9899:2018, Programming Languages — C
This version has addressed the following areas:
Issues raised by Austin Group defect reports, IEEE Interpretations against IEEE Std 1003.1, and ISO/IEC defect reports against
ISO/IEC 9945
The repository of interpretations can be accessed at www.opengroup.org/austin/interps.
Issues raised in corrigenda for The Open Group Standards and working group resolutions from The Open Group
Changes to make the text self-consistent with the additional material merged
A list of the new interfaces is included in B.1.1 Change History
.
Features, marked obsolescent in the base documents, have been considered for removal in this version
See B.1.1 Change History and C.1.1 Change History.
Alignment with the ISO/IEC 9899:2018 standard
The following were requirements on POSIX.1-2024:
Backward-compatibility
For interfaces carried forward, it was agreed that there should be no breakage of functionality in the existing base documents.
All strictly conforming applications will be conforming but not necessarily strictly conforming to the revised standard. The goal
is for system implementations to be able to support the existing and revised standards simultaneously.
Architecture and n-bit-neutral
The common standard should not make any implicit assumptions about the system architecture or size of data types; for example,
previously some 32-bit implicit assumptions had crept into the standards.
Extensibility
It should be possible to extend the common standard without breaking backwards-compatibility; for example, the name space should
be reserved and structured to avoid duplication of names between the standard and extensions to it.
POSIX.1 and the ISO C Standard
The standard developers believed it essential for a programmer to have a single complete reference place, but recognized that
deference to the formal standard has to be addressed for the duplicate interface definitions between the ISO C standard and
POSIX.1-2024.
Where an interface has a version in the ISO C standard, the DESCRIPTION section describes the relationship to the
ISO C standard and markings are included as appropriate to show where the ISO C standard has been extended in the
text.
A block of text is included at the start of each affected reference page stating whether the page is aligned with the ISO C
standard or extended. Each page has been parsed for additions beyond the ISO C standard (that is, including both POSIX and
UNIX extensions), and these extensions are marked as CX extensions (for C extensions).
FIPS Requirements
The Federal Information Processing Standards (FIPS) are a series of US government procurement standards managed and maintained
on behalf of the US Department of Commerce by the National Institute of Standards and Technology (NIST).
The following restrictions were integrated into IEEE Std 1003.1-2001. They originally came from FIPS 151-2 which was
withdrawn by NIST on February 25 2000.
The implementation supports _POSIX_CHOWN_RESTRICTED.
The limit {NGROUPS_MAX} is greater than or equal to 8.
The implementation supports the setting of the group ID of a file (when it is created) to that of the parent directory.
The implementation supports _POSIX_SAVED_IDS.
The implementation supports _POSIX_VDISABLE.
The implementation supports _POSIX_JOB_CONTROL.
The implementation supports _POSIX_NO_TRUNC.
The read() function returns the number of bytes read when interrupted by a signal
and does not return -1.
The write() function returns the number of bytes written when interrupted by a
signal and does not return -1.
In the environment for the login shell, the environment variables LOGNAME and HOME are defined and have the
properties described in POSIX.1-2024.
The value of {CHILD_MAX} is greater than or equal to 25.
The value of {OPEN_MAX} is greater than or equal to 20.
The implementation supports the functionality associated with the symbols CS7, CS8, CSTOPB, PARODD, and PARENB defined in
.
A.1.2 Word Usage
The content of this section is mandated by IEEE and consequently it cannot be combined with the "Terminology" section.
Note that where the footnotes state that "must" is used only to describe unavoidable situations and "will" is only used in
statements of fact, they are referring to uses of these words in normative text. In informative text, they are used in other ways
with their usual dictionary meanings.
A.1.3 Conformance
See A.2 Conformance.
A.1.4 Normative References
There is no additional rationale provided for this section.
A.1.5 Change History
For Issue 7 onwards, in references to Technical Corrigenda, the original Austin Group defect report numbers that gave rise to
the change are included in square brackets after the change number from the Technical Corrigendum. For more information on Austin
Group defect reports see www.opengroup.org/austin/defectform.html.
A.1.6 Terminology
The meanings specified in POSIX.1-2024 for the words shall, should, and may are mandated by ISO/IEC
directives.
In the Rationale (Informative) volume of POSIX.1-2024, the words shall, should, and may are sometimes used
to illustrate similar usages in POSIX.1-2024. However, the rationale itself does not specify anything regarding implementations or
applications.
conformance document
As a practical matter, the conformance document is effectively part of the system documentation. Conformance documents are
distinguished by POSIX.1-2024 so that they can be referred to distinctly.
implementation-defined
This definition is analogous to that of the ISO C standard and, together with "undefined" and "unspecified", provides a
range of specification of freedom allowed to the interface implementor.
may
The use of may has been limited as much as possible, due both to confusion stemming from its ordinary English meaning and
to objections regarding the desirability of having as few options as possible and those as clearly specified as possible.
The usage of can and may were selected to contrast optional application behavior (can) against optional
implementation behavior (may).
shall
Declarative sentences are sometimes used in POSIX.1-2024 as if they included the word shall, and facilities thus
specified are no less required. For example, the two statements:
The foo() function shall return zero.
The foo() function returns zero.
are meant to be exactly equivalent.
should
In POSIX.1-2024, the word should does not usually apply to the implementation, but rather to the application. Thus, the
important words regarding implementations are shall, which indicates requirements, and may, which indicates
options.
obsolescent
The term "obsolescent" means "do not use this feature in new applications". A feature noted as obsolescent is supported by
all implementations, but may be removed in a future version; new applications should not use these features. The obsolescence
concept is not an ideal solution, but was used as a method of increasing consensus: many more objections would be heard from the
user community if some of these historical features were suddenly removed without the grace period obsolescence implies. The phrase
"may be removed in a future version" implies that the result of that consideration might in fact keep those features indefinitely
if the predominance of applications do not migrate away from them quickly.
legacy
The term "legacy" was included in earlier versions of this standard but is no longer used in the current version.
system documentation
The system documentation should normally describe the whole of the implementation, including any extensions provided by the
implementation. Such documents normally contain information at least as detailed as the specifications in POSIX.1-2024. Few
requirements are made on the system documentation, but the term is needed to avoid a dangling pointer where the conformance
document is permitted to point to the system documentation.
undefined
See implementation-defined.
unspecified
See implementation-defined.
The definitions for "unspecified" and "undefined" appear nearly identical at first examination, but are not. The term
"unspecified" means that a conforming application may deal with the unspecified behavior, and it should not care what the outcome
is. The term "undefined" says that a conforming application should not do it because no definition is provided for what it does
(and implicitly it would care what the outcome was if it tried it). It is important to remember, however, that if the syntax
permits the statement at all, it must have some outcome in a real implementation.
Thus, the terms "undefined" and "unspecified" apply to the way the application should think about the feature. In terms of
the implementation, it is always "defined"—there is always some result, even if it is an error. The implementation is free to
choose the behavior it prefers.
This also implies that an implementation, or another standard, could specify or define the result in a useful fashion. The terms
apply to POSIX.1-2024 specifically.
The term "implementation-defined" implies requirements for documentation that are not required for "undefined" (or
"unspecified"). Where there is no need for a conforming program to know the definition, the term "undefined" is used, even
though "implementation-defined" could also have been used in this context. There could be a fourth term, specifying "this
standard does not say what this does; it is acceptable to define it in an implementation, but it does not need to be documented",
and undefined would then be used very rarely for the few things for which any definition is not useful. In particular,
implementation-defined is used where it is believed that certain classes of application will need to know such details to determine
whether the application can be successfully ported to the implementation. Such applications are not always strictly portable, but
nevertheless are common and useful; often the requirements met by the application cannot be met without dealing with the issues
implied by "implementation-defined". In some places the text refers to facilities supplied by the implementation that are outside
the standard as implementation-supplied or implementation-provided. This is not intended to imply a requirement for documentation.
If it were, the term "implementation-defined" would have been used.
In many places POSIX.1-2024 is silent about the behavior of some possible construct. For example, a variable may be defined for
a specified range of values and behaviors are described for those values; nothing is said about what happens if the variable has
any other value. That kind of silence can imply an error in the standard, but it may also imply that the standard was intentionally
silent and that any behavior is permitted. There is a natural tendency to infer that if the standard is silent, a behavior is
prohibited. That is not the intent. Silence is intended to be equivalent to the term "unspecified".
Three terms used within POSIX.1-2024 overlap in meaning: "macro", "symbolic name", and "symbolic constant".
macro
This usually describes a C preprocessor symbol, the result of the #define operator, with or without an argument. It may
also be used to describe similar mechanisms in editors and text processors.
symbolic name
In earlier versions of this standard this was also sometimes used to refer to a C preprocessor symbol (without arguments), but
the intention is for all such uses to have been removed. It is now mainly used to refer to the names for characters in character
sets, but is sometimes used to refer to host names and even filenames.
symbolic constant
This also refers to a C preprocessor symbol, with specific associated requirements. See the definition in 3.363 Symbolic Constant.
A.1.7 Definitions and Concepts
There is no additional rationale provided for this section.
A.1.8 Portability
To aid the identification of options within POSIX.1-2024, a notation consisting of margin codes and shading is used. This is
based on the notation used in earlier versions of The Open Group Base specifications.
The benefit of this approach is a reduction in the number of if statements within the running text, that makes the text
easier to read, and also an identification to the programmer that they need to ensure that their target platforms support the
underlying options. For example, if functionality is marked with RPP in the margin, it will be available on all systems supporting
the Robust Mutex Priority Protection option, but may not be available on some others.
A.1.8.1 Codes
This section includes codes for options defined in XBD 2.1.6
Options, and the following additional codes for other purposes:
CX
This margin code is used to denote extensions beyond and, in exceptional cases, deviations from the ISO C standard. For
interfaces that are duplicated between POSIX.1-2024 and the ISO C standard, a CX introduction block describes the nature of
the duplication, with any extensions or deviations appropriately CX marked and shaded. Where deviations exist, the reasons for them
are explained in the RATIONALE section of the affected interface. Deviations have become necessary because there is no longer any
formal way for ISO to acknowledge defects in the ISO C standard. For the original C90 standard and the C99 revision, defect
reports (DRs) were issued, but there is no equivalent mechanism for the current revision. Even if the defect is corrected in a
later revision, without stating deviations POSIX.1-2024 would continue to require the incorrect behavior described in the version
of the ISO C standard that it references.
Where an interface is added to an ISO C standard header, within the header the interface has an appropriate margin marker
and shading (for example, CX, XSI, TSF, and so on) and the same marking appears on the reference page in the SYNOPSIS section. This
enables a programmer to easily identify that the interface is extending an ISO C standard header.
Austin Group Defect 1755 is applied, changing the CX code description to include intentional conflicts (deviations).
MX and MXX
These two margin codes both relate to the IEC 60559 Floating-Point option. The MX code denotes functionality that is mandated by
the ISO C standard for IEC 60559 implementations; the MXX code denotes IEC 60559 functionality that is an extension to the
ISO C standard.
MXC
This margin code is used to denote functionality related to the IEC 60559 Complex Floating-Point option.
OB
This margin code is used to denote obsolescent behavior and thus flag a possible future applications portability warning.
OH
The Single UNIX Specification has historically tried to reduce the number of headers an application has had to include when
using a particular interface. Sometimes this was fewer than the base standard, and hence a notation is used to flag which headers
are optional if you are using a system supporting the XSI option.
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0001 [591] is applied.
A.1.8.2 Margin Code Notation
Since some features may depend on one or more options, or require more than one option, a notation is used. Where a feature
requires support of a single option, a single margin code will occur in the margin. If it depends on two options and both are
required, then the codes will appear with a  separator. If either of two options are required, then a logical OR is
denoted using the '|' symbol. If more than two codes are used, a special notation is used.
A.2 Conformance
The terms "profile" and "profiling" are used throughout this section.
A profile of a standard or standards is a codified set of option selections, such that by being conformant to a profile,
particular classes of users are specifically supported.
A.2.1 Implementation Conformance
These definitions allow application developers to know what to depend on in an implementation.
There is no definition of a "strictly conforming implementation"; that would be an implementation that provides only
those facilities specified by POSIX.1 with no extensions whatsoever. This is because no actual operating system implementation can
exist without system administration and initialization facilities that are beyond the scope of POSIX.1.
A.2.1.1 Requirements
The word "support" is used in certain instances, rather than "provide", in order to allow an implementation that has no
resident software development facilities, but that supports the execution of a Strictly Conforming POSIX.1 Application, to
be a conforming implementation.
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0002 [810] is applied.
A.2.1.2 Documentation
The conformance documentation is required to use the same numbering scheme as POSIX.1 for purposes of cross-referencing. All
options that an implementation chooses are reflected in  and
.
Note that the use of "may" in terms of where conformance documents record where implementations may vary, implies that it is
not required to describe those features identified as undefined or unspecified.
Other aspects of systems must be evaluated by purchasers for suitability. Many systems incorporate buffering facilities,
maintaining updated data in volatile storage and transferring such updates to non-volatile storage asynchronously. Various
exception conditions, such as a power failure or a system crash, can cause this data to be lost. The data may be associated with a
file that is still open, with one that has been closed, with a directory, or with any other internal system data structures
associated with permanent storage. This data can be lost, in whole or part, so that only careful inspection of file contents could
determine that an update did not occur.
Also, interrelated file activities, where multiple files and/or directories are updated, or where space is allocated or released
in the file system structures, can leave inconsistencies in the relationship between data in the various files and directories, or
in the file system itself. Such inconsistencies can break applications that expect updates to occur in a specific sequence, so that
updates in one place correspond with related updates in another place.
For example, if a user creates a file, places information in the file, and then records this action in another file, a system or
power failure at this point followed by restart may result in a state in which the record of the action is permanently recorded,
but the file created (or some of its information) has been lost. The consequences of this to the user may be undesirable. For a
user on such a system, the only safe action may be to require the system administrator to have a policy that requires, after any
system or power failure, that the entire file system must be restored from the most recent backup copy (causing all intervening
work to be lost).
The characteristics of each implementation will vary in this respect and may or may not meet the requirements of a given
application or user. Enforcement of such requirements is beyond the scope of POSIX.1. It is up to the purchaser to determine what
facilities are provided in an implementation that affect the exposure to possible data or sequence loss, and also what underlying
implementation techniques and/or facilities are provided that reduce or limit such loss or its consequences.
A.2.1.3 POSIX Conformance
This really means conformance to the base standard; however, since this document includes the core material of the Single UNIX
Specification, the standard developers decided that it was appropriate to segment the conformance requirements into two, the former
for the base standard, and the latter for the Single UNIX Specification (denoted XSI Conformance).
Within POSIX.1 there are some symbolic constants that, if defined to a certain value or range of values, indicate that a certain
option is enabled. Other symbolic constants exist in POSIX.1 for other reasons.
In this version, some features that were previously optional have been made mandatory. For backwards compatibility, the symbolic
constants associated with the option are still required now with fixed allowable ranges or values. The following options from
previous versions of this standard are now mandatory:
_POSIX_ASYNCHRONOUS_IO
_POSIX_BARRIERS
_POSIX_CLOCK_SELECTION
_POSIX_MAPPED_FILES
_POSIX_MEMORY_PROTECTION
_POSIX_MONOTONIC_CLOCK
_POSIX_READER_WRITER_LOCKS
_POSIX_REALTIME_SIGNALS
_POSIX_SEMAPHORES
_POSIX_SPIN_LOCKS
_POSIX_THREAD_SAFE_FUNCTIONS
_POSIX_THREADS
_POSIX_TIMEOUTS
_POSIX_TIMERS
A POSIX-conformant system may support the XSI option required by the Single UNIX Specification. This was intentional since the
standard developers intend them to be upwards-compatible, so that a system conforming to the Single UNIX Specification can also
conform to the base standard at the same time.
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0003 [637] is applied.
Austin Group Defect 729 is applied, adding _POSIX_DEVICE_CONTROL.
Austin Group Defect 1346 is applied, requiring support for Monotonic Clock.
A.2.1.4 XSI Conformance
This section is included to describe the conformance requirements for the base volumes of the Single UNIX Specification.
XSI conformance can be thought of as a profile, selecting certain options from POSIX.1-2024.
A.2.1.5 Option Groups
The concept of "Option Groups" is included to allow collections of related functions or options to be grouped together. This
has been used as follows: the "XSI Option Groups" have been created to allow super-options, collections of underlying options and
related functions, to be collectively supported by XSI-conforming systems.
The standard developers considered the matter of subprofiling and decided it was better to include an enabling mechanism rather
than detailed normative requirements. A set of subprofiling options was developed and included later in this volume of POSIX.1-2024
as an informative illustration.
Subprofiling Considerations
The goal of not simultaneously fixing maximums and minimums was to allow implementations of the base standard or standards to
support multiple profiles without conflict.
The following summarizes the rules for the limit types:
Limit Type
Fixed Value
Minimum Acceptable Value
Maximum Acceptable Value
Standard
Xs
Ys
Zs
Profile
Xp == Xs
Yp >= Ys
Zp  include ANSI, BSI, and AFNOR.
A.2.2.3 Conforming POSIX Application Using Extensions
Due to possible requirements for configuration or implementation characteristics in excess of the specifications in
or related to the hardware (such as array size or file space), not
every Conforming POSIX Application Using Extensions will run on every conforming implementation.
A.2.2.4 Strictly Conforming XSI Application
This is intended to be upwards-compatible with the definition of a Strictly Conforming POSIX Application, with the
addition of the facilities and functionality included in the XSI option.
A.2.2.5 Conforming XSI Application Using Extensions
Such applications may use extensions beyond the facilities defined by POSIX.1-2024 including the XSI option, but
need to document the additional requirements.
A.2.3 Language-Dependent Services for the C Programming Language
POSIX.1 is, for historical reasons, both a specification of an operating system interface, shell and utilities, and
a C binding for that specification. Efforts had been previously undertaken to generate a language-independent specification;
however, that had failed, and the fact that the ISO C standard is the de facto primary language on POSIX and the UNIX
system makes this a necessary and workable situation.
A.2.4 Other Language-Related Specifications
There is no additional rationale provided for this section.
A.3 Definitions
The definitions in this section are stated so that they can be used as exact substitutes for the terms in text.
They should not contain requirements or cross-references to sections within POSIX.1-2024; that is accomplished by using an
informative note. In addition, the term should not be included in its own definition. Where requirements or descriptions need to be
addressed but cannot be included in the definitions, due to not meeting the above criteria, these occur in the General Concepts
chapter.
In this version, the definitions have been reworked extensively to meet style requirements and to include terms
from the base documents (see the Scope).
Many of these definitions are necessarily circular, and some of the terms (such as "process") are variants of
basic computing science terms that are inherently hard to define. Where some definitions are more conceptual and contain
requirements, these appear in the General Concepts chapter. Those listed in this section appear in an alphabetical glossary format
of terms.
Some definitions must allow extension to cover terms or facilities that are not explicitly mentioned in
POSIX.1-2024. For example, the definition of "Extended Security Controls" permits implementations beyond those defined in
POSIX.1-2024.
Some terms in the following list of notes do not appear in POSIX.1-2024; these are marked suffixed with an asterisk
(*). Many of them have been specifically excluded from POSIX.1-2024 because they concern system administration, implementation, or
other issues that are not specific to the programming interface. Those are marked with a reason, such as
"implementation-defined".
Alias Name
Austin Group Defect 1050 is applied, adding '-' to the characters that can be used in an alias name.
Anonymous Memory Object
Austin Group Defect 850 is applied, adding anonymous memory objects.
Application
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0004 [937] is applied.
Appropriate Privileges
One of the fundamental security problems with many historical UNIX systems has been that the privilege mechanism is
monolithic—a user has either no privileges or all privileges. Thus, a successful "trojan horse" attack on a privileged
process defeats all security provisions. Therefore, POSIX.1 allows more granular privilege mechanisms to be defined. For many
historical implementations of the UNIX system, the presence of the term "appropriate privileges" in POSIX.1 may be understood as
a synonym for "superuser" (UID 0). However, other systems have emerged where this is not the case and each discrete controllable
action has appropriate privileges associated with it. Because this mechanism is implementation-defined, it must be described
in the conformance document. Although that description affects several parts of POSIX.1 where the term "appropriate privilege" is
used, because the term "implementation-defined" only appears here, the description of the entire mechanism and its effects on
these other sections belongs in this equivalent section of the conformance document. This is especially convenient for
implementations with a single mechanism that applies in all areas, since it only needs to be described once.
Async-Signal-Safe Function
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0005 [516] is applied.
Background Job
Austin Group Defect 1254 is applied, changing this definition.
Base Character*
The term "Base Character" has been removed, as it was felt that the use of this term within POSIX.1-2024 was
common usage English.
Basename
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0006 [653] is applied.
Built-In Utility
Austin Group Defect 854 is applied, changing text relating to regular built-in utilities.
Byte
The restriction that a byte is now exactly eight bits was a conscious decision by the standard developers. It came
about due to a combination of factors, primarily the use of the type int8_t within the networking functions and the
alignment with the ISO/IEC 9899:1999 standard, where the intN_t types were first defined.
According to the ISO/IEC 9899:1999 standard:
The [u]intN_t types must be two's complement with no padding bits and no illegal values.
All types (apart from bit fields, which are not relevant here) must occupy an integral number of bytes.
If a type with width W occupies B bytes with C bits per byte (C is the value of
{CHAR_BIT}), then it has P padding bits where P+W=B*C.
Therefore, for int8_t P=0, W=8. Since B>=1, C>=8, the only solution is
B=1, C=8.
The standard developers also felt that this was not an undue restriction for the current state-of-the-art for this
version of the standard, but recognize that if industry trends continue, a wider character type may be required in the future.
Character
The term "character" is used to mean a sequence of one or more bytes representing a member of a character set.
The deviation in the exact text of the ISO C standard definition for "byte" meets the intent of the rationale of the
ISO C standard also clears up the ambiguity raised by the term "basic execution character set". The octet-minimum
requirement is a reflection of the {CHAR_BIT} value.
Austin Group Defect 1356 is applied, changing the definition of "character" to match the definition of the term
"multi-byte character" in the ISO C standard.
Child Process
IEEE Std 1003.1-2001/Cor 2-2004, item XBD/TC2/D6/3 is applied, adding the vfork() function to
those listed.
Clock Tick
The ISO C standard defines a similar interval for use by the clock() function. There is no requirement that these intervals be the same. In historical
implementations these intervals are different.
Code Block
Austin Group Defect 613 is applied, adding this definition.
Command
The terms "command" and "utility" are related but have distinct meanings. Command is defined as "a directive
to a shell to perform a specific task". The directive can be in the form of a single utility name (for example, ls), or the directive can take the form of a compound command (for example, "ls | grep name |
pr"). A utility is a program that can be called by name from a shell. Issuing only the name of the utility to a shell is the
equivalent of a one-word command. A utility may be invoked as a separate program that executes in a different process than the
command language interpreter, or it may be implemented as a part of the command language interpreter. For example, the echo command (the directive to perform a specific task) may be implemented such that the
echo utility (the logic that performs the task of echoing) is in a separate program;
therefore, it is executed in a process that is different from the command language interpreter. Conversely, the logic that performs
the echo utility could be built into the command language interpreter; therefore, it
could execute in the same process as the command language interpreter.
The terms "tool" and "application" can be thought of as being synonymous with "utility" from the perspective
of the operating system kernel. Tools, applications, and utilities historically have run, typically, in processes above the kernel
level. Tools and utilities historically have been a part of the operating system non-kernel code and have performed system-related
functions, such as listing directory contents, checking file systems, repairing file systems, or extracting system status
information. Applications have not generally been a part of the operating system, and they perform non-system-related functions,
such as word processing, architectural design, mechanical design, workstation publishing, or financial analysis. Utilities have
most frequently been provided by the operating system distributor, applications by third-party software distributors, or by the
users themselves. Nevertheless, POSIX.1-2024 does not differentiate between tools, utilities, and applications when it comes to
receiving services from the system, a shell, or the standard utilities. (For example, the xargs utility invokes another utility; it would be of fairly limited usefulness if the users
could not run their own applications in place of the standard utilities.) Utilities are not applications in the sense that they are
not themselves subject to the restrictions of POSIX.1-2024 or any other standard—there is no requirement for grep, stty, or any of the utilities defined here to
be any of the classes of conforming applications.
Column Positions
In most 1-byte character sets, such as ASCII, the concept of column positions is identical to character positions
and to bytes. Therefore, it has been historically acceptable for some implementations to describe line folding or tab stops or
table column alignment in terms of bytes or character positions. Other character sets pose complications, as they can have internal
representations longer than one octet and they can have display characters that have different widths on the terminal screen or
printer.
In POSIX.1-2024 the term "column positions" has been defined to mean character—not byte—positions in input files.
Output files describe the column position in terms of the display width of the narrowest printable character in the character set,
adjusted to fit the characteristics of the output device. It is very possible that n column positions will not be able to
hold n characters in some character sets, unless all of those characters are of the narrowest width. It is assumed that the
implementation is aware of the width of the various characters, deriving this information from the value of LC_CTYPE , and
thus can determine how many column positions to allot for each character in those utilities where it is important.
The term "column position" was used instead of the more natural "column" because the latter is frequently used
in the different contexts of columns of figures, columns of table values, and so on. Wherever confusion might result, these latter
types of columns are referred to as "text columns".
Condition Variable
Austin Group Defect 1302 is applied, aligning this section with the ISO/IEC 9899:2018 standard.
Control Operator
Austin Group Defect 449 is applied, adding ;& to the list of control operators.
Controlling Terminal
The question of which of possibly several special files referring to the terminal is meant is not addressed in
POSIX.1. The pathname /dev/tty is a synonym for the controlling terminal associated with a process.
Core Image
Austin Group Defect 1141 is applied, replacing the core file definition with a core image definition.
CPU Time (Execution Time)
Austin Group Defect 1116 is applied, removing a reference to the Threads option that existed in earlier versions of
this standard.
Decimal-Point Character
Austin Group Defect 1449 is applied, adding this definition.
Declaration Utility
Austin Group Defect 351 is applied, adding this definition.
Device Number*
The concept is handled in stat() as ID of device.
Direct I/O
Historically, direct I/O refers to the system bypassing intermediate buffering, but may be extended to cover
implementation-defined optimizations.
Directory
The format of the directory file is implementation-defined and differs radically between System V and 4.3 BSD.
However, routines (derived from 4.3 BSD) for accessing directories and certain constraints on the format of the information
returned by those routines are described in the  header.
Directory Entry (or Hard Link)
Austin Group Defect 1380 is applied, changing "link" to "hard link".
Display
The Shell and Utilities volume of POSIX.1-2024 assigns precise requirements for the terms "display" and
"write". Some historical systems have chosen to implement certain utilities without using the traditional file descriptor model.
For example, the vi editor might employ direct screen memory updates on a personal
computer, rather than a write() system call. An instance of user prompting might
appear in a dialog box, rather than with standard error. When the Shell and Utilities volume of POSIX.1-2024 uses the term
"display", the method of outputting to the terminal is unspecified; many historical implementations use termcap or
terminfo, but this is not a requirement. The term "write" is used when the Shell and Utilities volume of POSIX.1-2024
mandates that a file descriptor be used and that the output can be redirected. However, it is assumed that when the writing is
directly to the terminal (it has not been redirected elsewhere), there is no practical way for a user or test suite to determine
whether a file descriptor is being used. Therefore, the use of a file descriptor is mandated only for the redirection case and the
implementation is free to use any method when the output is not redirected. The verb write is used almost exclusively, with
the very few exceptions of those utilities where output redirection need not be supported: tabs, talk, tput, and vi.
Dot
The symbolic name dot is carefully used in POSIX.1 to distinguish the working directory filename from a
period or a decimal point.
Dot-Dot
Historical implementations permit the use of these filenames without their special meanings. Such use precludes any
meaningful use of these filenames by a Conforming POSIX.1 Application. Therefore, such use is considered an extension, the use of
which makes an implementation non-conforming; see also A.4.16 Pathname Resolution.
Dot-Po File
Austin Group Defect 1122 is applied, adding this definition.
Empty Directory
Austin Group Defect 1380 is applied, changing "link" to "hard link".
Epoch
Historically, the origin of UNIX system time was referred to as "00:00:00 GMT, January 1, 1970". Greenwich Mean
Time is actually not a term acknowledged by the international standards community; therefore, this term, "Epoch", is used to
abbreviate the reference to the actual standard, Coordinated Universal Time.
FIFO Special File
See Pipe.
File
It is permissible for an implementation-defined file type to be non-readable or non-writable.
File Classes
These classes correspond to the historical sets of permission bits. The classes are general to allow
implementations flexibility in expanding the access mechanism for more stringent security environments. Note that a process is in
one and only one class, so there is no ambiguity.
File Descriptor
Austin Group Defect 1493 is applied, moving some information from XCU 2.7 Redirection to this definition.
File Lock
Austin Group Defect 768 is applied, changing this definition.
File Mode
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0007 [834] is applied.
Filename
Filenames are sequences of bytes, not sequences of characters. The only bytes that this standard says cannot appear
in any filename are the slash byte and the null byte. This is a side-effect of the fact that no conforming implementations of the
standard currently provide a way to pass information specifying the locale associated with strings passed between user-level
applications and the kernel. This decision could be revisited if implementations develop a way to associate a locale with the
strings passed between kernel space and user space.
Implementations may add other restrictions to the byte sequences allowed in filenames except that any filename
consisting of no more than {NAME_MAX} bytes from the set of characters in the portable filename character set must be allowed.
See Pathname.
File System
Historically, the meaning of this term has been overloaded with two meanings: that of the complete file hierarchy,
and that of a mountable subset of that hierarchy; that is, a mounted file system. POSIX.1 uses the term "file system" in the
second sense, except that it is limited to the scope of a process (and root directory of a process). This usage also clarifies the
domain in which a file serial number is unique.
Foreground Job
Austin Group Defect 1254 is applied, changing this definition.
Graphic Character
This definition is made available for those definitions (in particular, TZ ) which must exclude control
characters.
Group Database
IEEE Std 1003.1-2001/Cor 2-2004, item XBD/TC2/D6/4 is applied, removing the words "of
implementation-defined format". See User Database.
Group File*
Implementation-defined; see User Database.
Group ID
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0008 [511] is applied.
Group Name
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0009 [584] is applied.
Hard Link
Austin Group Defect 1380 is applied, changing this definition.
Historical Implementations*
This refers to previously existing implementations of programming interfaces and operating systems that are related
to the interface specified by POSIX.1.
Hole
Austin Group Defect 415 is applied, adding this definition.
Hosted Implementation*
This refers to a POSIX.1 implementation that is accomplished through interfaces from the POSIX.1 services to some
alternate form of operating system kernel services. Note that the line between a hosted implementation and a native implementation
is blurred, since most implementations will provide some services directly from the kernel and others through some indirect path.
(For example, fopen() might use open(); or
mkfifo() might use mknod().) There is no
necessary relationship between the type of implementation and its correctness, performance, and/or reliability.
Implementation*
This term is generally used instead of its synonym, "system", to emphasize the consequences of decisions to be
made by system implementors. Perhaps if no options or extensions to POSIX.1 were allowed, this usage would not have occurred.
The term "specific implementation" is sometimes used as a synonym for "implementation". This should not be
interpreted too narrowly; both terms can represent a relatively broad group of systems. For example, a hardware vendor could market
a very wide selection of systems that all used the same instruction set, with some systems desktop models and others large
multi-user minicomputers. This wide range would probably share a common POSIX.1 operating system, allowing an application compiled
for one to be used on any of the others; this is a [specific] implementation. However, such a wide range of machines
probably has some differences between the models. Some may have different clock rates, different file systems, different resource
limits, different network connections, and so on, depending on their sizes or intended usages. Even on two identical machines, the
system administrators may configure them differently. Each of these different systems is known by the term "a specific instance of
a specific implementation". This term is only used in the portions of POSIX.1 dealing with runtime queries: sysconf() and pathconf().
Incomplete Pathname*
Absolute pathname has been adequately defined.
Interactive Device
Austin Group Defect 1347 is applied, adding a definition of interactive device.
Intrinsic Utility
Austin Group Defect 854 is applied, adding intrinsic utilities.
Job
Austin Group Defect 1254 is applied, changing this definition.
Job Control
In order to understand the job control facilities in POSIX.1 it is useful to understand how they are used by a job
control-cognizant shell to create the user interface effect of job control.
While the job control facilities supplied by POSIX.1 can, in theory, support different types of interactive job
control interfaces supplied by different types of shells, there was historically one particular interface that was most common when
the standard was originally developed (provided by BSD C Shell).
This discussion describes that interface as a means of illustrating how the POSIX.1 job control facilities can be
used.
Job control allows users to selectively stop (suspend) the execution of processes and continue (resume) their
execution at a later point. The user typically employs this facility via the interactive interface jointly supplied by the terminal
I/O driver and a command interpreter (shell).
The user can launch jobs (command pipelines) in either the foreground or background. When launched in the
foreground, the shell waits for the job to complete before prompting for additional commands. When launched in the background, the
shell does not wait, but immediately prompts for new commands.
If the user launches a job in the foreground and subsequently regrets this, the user can type the suspend character
(typically set to -Z), which causes the foreground process group to stop, and the shell to convert the corresponding
foreground job to a suspended job and begin prompting for new commands. The suspended job can be continued by the user (via special
shell commands) either as a foreground job or as a background job. Background jobs can also be moved into the foreground via shell
commands.
If a background process group attempts to access the login terminal (controlling terminal), it is stopped by the
terminal driver and the shell detects this and, in turn, suspends the corresponding background job and notifies the user. (Terminal
access includes read() and certain terminal control functions, and conditionally
includes write().) The user can continue the suspended job in the foreground, thus
allowing the terminal access to succeed in an orderly fashion. After the terminal access succeeds, the user can optionally move the
job into the background via the suspend character and shell commands.
Implementing Job Control Shells
The job control features of the POSIX shell (described in 2.11
Job Control) and of other shells can be implemented using the job control facilities of the System Interfaces volume of
POSIX.1-2024 in the following way.
The key feature necessary to provide job control is a way to group processes into jobs. This grouping is necessary
in order to direct signals to a single job and also to identify which job is in the foreground. (There is at most one job that is
in the foreground on any controlling terminal at a time.)
The concept of process groups is used to provide this grouping. The shell places the process(es) it creates for
each job in a separate process group via the setpgid() function. To do this, the
setpgid() function is invoked by the shell for each process in the job. It is
actually useful to invoke setpgid() twice for each process: once in the child
process, after calling fork() to create the process, but before calling one of the
exec family of functions to begin execution of the program, and once in the parent shell process, after calling fork() to create the child. The redundant invocation avoids a race condition by ensuring that
the child process is placed into the new process group before either the parent or the child relies on this being the case. The
process group ID for the job is selected by the shell to be equal to the process ID of one of the processes in the job. Some shells
choose to make one process in the job be the parent of the other processes in the job (if any). Other shells (for example, the
C Shell) choose to make themselves the parent of all processes in the job. In order to support this latter case, the setpgid() function accepts a process group ID parameter since the correct process group ID
cannot be inherited from the shell.
The shell also controls which job is currently in the foreground. A foreground and background job differ in two
ways: the shell waits for a foreground command to complete (or stop) before continuing to read new commands, and the terminal I/O
driver inhibits terminal access by background jobs (causing the processes to stop). Thus, the shell must work cooperatively with
the terminal I/O driver and have a common understanding of which job is currently in the foreground. It is the user who decides
which command should be currently in the foreground, and the user informs the shell via shell commands. The shell, in turn, informs
the terminal I/O driver via the tcsetpgrp() function. This indicates to the
terminal I/O driver the process group ID of the foreground process group. When the current foreground job is either suspended or
terminated, the shell places its own process group in the foreground via tcsetpgrp() before prompting for additional commands. Note that when a job is created the
new process group begins as a background process group. It requires an explicit act of the shell via tcsetpgrp() to move a process group into the foreground.
When a process in a job stops or terminates, its parent (for example, the shell) receives synchronous notification
by calling the waitpid() function with the WUNTRACED flag set. Asynchronous
notification is also provided when the parent establishes a signal handler for SIGCHLD and does not specify the SA_NOCLDSTOP flag.
Usually all processes in a job stop as a unit since the terminal I/O driver always sends job control stop signals to all processes
in the process group.
To continue a suspended job, the shell sends a SIGCONT signal to the corresponding process group. In addition, if
the job is being continued in the foreground, the shell invokes tcsetpgrp() to
place the process group in the foreground before sending SIGCONT. Otherwise, the shell leaves itself in the foreground and reads
additional commands.
There is additional flexibility in the POSIX.1 job control facilities that allows deviations from the typical
interface. Clearing the TOSTOP terminal flag allows background jobs to perform write()
functions without stopping. The same effect can be achieved on a per-process basis by having a process set the signal action for
SIGTTOU to SIG_IGN.
A login session that is not using the job control facilities can be thought of as a large collection of processes
that are all in the same job. Such a login session may have a partial distinction between foreground and background processes; that
is, the shell waits for some processes before continuing to read new commands and does not wait for other processes. However, the
terminal I/O driver considers all these processes to be in the foreground since they are all members of the same process group.
In addition to the basic job control operations already mentioned, a job control-cognizant shell needs to perform
the following actions.
When a foreground (not background) job is suspended, the shell needs to sample and remember the current terminal
settings so that it can restore them later when it continues the suspended job in the foreground (via the tcgetattr() and tcsetattr()
functions).
Because a shell itself can be spawned from a shell, it must take special action to ensure that child shells
interact well with their parent shells. A child shell can be spawned to perform an interactive function (prompting the terminal for
commands) or a non-interactive function (reading commands from a file). When operating non-interactively, the job control shell
will by default refrain from performing the job control-specific actions described above. It will behave as a shell that does not
support job control. For example, all jobs will be left in the same process group as the shell, which itself remains in the process
group established for it by its parent. This allows the shell and its children to be treated as a single job by a parent shell, and
they can be affected as a unit by terminal keyboard signals.
An interactive child shell can be spawned from another job control-cognizant shell in either the foreground or
background. (For example, the user can execute an interactive shell in the background by means of the command "sh &".)
Before the child shell activates job control by calling setpgid() to place itself in
its own process group and tcsetpgrp() to place its new process group in the
foreground, it needs to ensure that it has already been placed in the foreground by its parent. (Otherwise, there could be multiple
job control shells that simultaneously attempt to control mediation of the terminal.) To determine this, the shell retrieves its
own process group via getpgrp() and the process group of the current foreground job
via tcgetpgrp(). If these are not equal, the shell sends SIGTTIN to its own
process group, causing itself to stop. When continued later by its parent, the shell repeats the process group check. When the
process groups finally match, the shell is in the foreground and it can proceed to take control. After this point, the shell
ignores all the job control stop signals so that it does not inadvertently stop itself.
Implementing Job Control Applications
Most applications do not need to be aware of job control signals and operations; the intuitively correct behavior
happens by default. However, sometimes an application can inadvertently interfere with normal job control processing, or an
application may choose to overtly effect job control in cooperation with normal shell procedures.
An application can inadvertently subvert job control processing by "blindly" altering the handling of signals. A
common application error is to learn how many signals the system supports and to ignore or catch them all. Such an application
makes the assumption that it does not know what this signal is, but knows the right handling action for it. The system may
initialize the handling of job control stop signals so that they are being ignored. This allows shells that do not support job
control to inherit and propagate these settings and hence to be immune to stop signals. A job control shell will set the handling
to the default action and propagate this, allowing processes to stop. In doing so, the job control shell is taking responsibility
for restarting the stopped applications. If an application wishes to catch the stop signals itself, it should first determine their
inherited handling states. If a stop signal is being ignored, the application should continue to ignore it. This is directly
analogous to the recommended handling of SIGINT described in the referenced UNIX Programmer&rsquo;s Manual.
If an application is reading the terminal and has disabled the interpretation of special characters (by clearing
the ISIG flag), the terminal I/O driver will not send SIGTSTP when the suspend character is typed. Such an application can simulate
the effect of the suspend character by recognizing it and sending SIGTSTP to its process group as the terminal driver would have
done. Note that the signal is sent to the process group, not just to the application itself; this ensures that other processes in
the job also stop. (Note also that other processes in the job could be children, siblings, or even ancestors.) Applications should
not assume that the suspend character is -Z (or any particular value); they should retrieve the current setting at
startup.
Implementing Job Control Systems
The intent in adding 4.2 BSD-style job control functionality was to adopt the necessary 4.2 BSD programmatic
interface with only minimal changes to resolve syntactic or semantic conflicts with System V or to close recognized security
holes. The goal was to maximize the ease of providing both conforming implementations and Conforming POSIX.1 Applications.
It is only useful for a process to be affected by job control signals if it is the descendant of a job control
shell. Otherwise, there will be nothing that continues the stopped process.
POSIX.1 does not specify how controlling terminal access is affected by a user logging out (that is, by a
controlling process terminating). 4.2 BSD uses the vhangup() function to prevent any access to the controlling terminal
through file descriptors opened prior to logout. System V does not prevent controlling terminal access through file
descriptors opened prior to logout (except for the case of the special file, /dev/tty). Some implementations choose to make
processes immune from job control after logout (that is, such processes are always treated as if in the foreground); other
implementations continue to enforce foreground/background checks after logout. Therefore, a Conforming POSIX.1 Application should
not attempt to access the controlling terminal after logout since such access is unreliable. If an implementation chooses to deny
access to a controlling terminal after its controlling process exits, POSIX.1 requires a certain type of behavior (see Controlling Terminal).
Austin Group Defect 1254 is applied, changing this definition.
Job ID
Austin Group Defect 1254 is applied, changing "job control job ID" to "job ID".
Joinable Thread
Austin Group Defect 792 is applied, adding this definition.
Kernel*
See System Call*.
Library Routine*
See System Call*.
Link
Austin Group Defect 1380 is applied, changing this definition.
Live Process
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0010 [690] is applied.
Live Thread
Austin Group Defect 792 is applied, adding this definition.
Logical Device*
Implementation-defined.
Map
The definition of map is included to clarify the usage of mapped pages in the description of the behavior of
process memory locking.
Memory-Resident
The term "memory-resident" is historically understood to mean that the so-called resident pages are actually
present in the physical memory of the computer system and are immune from swapping, paging, copy-on-write faults, and so on. This
is the actual intent of POSIX.1-2024 in the process memory locking section for implementations where this is logical. But for some
implementations—primarily mainframes—actually locking pages into primary storage is not advantageous to other system objectives,
such as maximizing throughput. For such implementations, memory locking is a "hint" to the implementation that the application
wishes to avoid situations that would cause long latencies in accessing memory. Furthermore, there are other implementation-defined
issues with minimizing memory access latencies that "memory residency" does not address—such as MMU reload faults. The definition
attempts to accommodate various implementations while allowing conforming applications to specify to the implementation that they
want or need the best memory access times that the implementation can provide.
Memory Object*
The term "memory object" usually implies shared memory. If the object is the same as a filename in the file
system name space of the implementation, it is expected that the data written into the memory object be preserved on disk. A memory
object may also apply to a physical device on an implementation. In this case, writes to the memory object are sent to the
controller for the device and reads result in control registers being returned.
Messages Object
Austin Group Defect 1122 is applied, adding this definition.
Mounted File System*
See File System.
Multi-Threaded Library
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0011 [625] is applied.
Multi-Threaded Process
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0011 [625] is applied.
Multi-Threaded Program
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0011 [625] is applied.
Austin Group Defect 1302 is applied, aligning this section with the ISO/IEC 9899:2018 standard.
Mutex
Austin Group Defect 1302 is applied, aligning this section with the ISO/IEC 9899:2018 standard.
Name
There are no explicit limits in POSIX.1-2024 on the sizes of names, words (see the definition of word in the Base
Definitions volume of POSIX.1-2024), lines, or other objects. However, other implicit limits do apply: shell script lines produced
by many of the standard utilities cannot exceed {LINE_MAX} and the sum of exported variables comes under the {ARG_MAX} limit.
Historical shells dynamically allocate memory for names and words and parse incoming lines a character at a time. Lines cannot have
an arbitrary {LINE_MAX} limit because of historical practice, such as makefiles, where make removes the  characters associated with the commands for a target and
presents the shell with one very long line. The text on INPUT FILES in XCU 1.4
Utility Description Defaults does allow a shell to run out of memory, but it cannot have arbitrary programming limits.
Native Implementation*
This refers to an implementation of POSIX.1 that interfaces directly to an operating system kernel; see also
hosted implementation. A similar concept is a native UNIX system, which would be a kernel derived from one of the original
UNIX system products.
Negative
Austin Group Defect 1428 is applied, adding this definition.
Nice Value
This definition is not intended to suggest that all processes in a system have priorities that are comparable.
Scheduling policy extensions, such as adding realtime priorities, make the notion of a single underlying priority for all
scheduling policies problematic. Some implementations may implement the features related to nice to affect all processes on the system, others to affect just the general time-sharing
activities implied by POSIX.1-2024, and others may have no effect at all. Because of the use of "implementation-defined" in
nice and renice, a wide range of
implementation strategies is possible.
Null Pointer
Austin Group Defect 940 is applied, adding a statement that any pointer object whose representation has all bits
set to zero will be interpreted as a null pointer.
Null Terminator
Austin Group Defect 1621 is applied, adding this definition.
OFD-Owned File Lock
Austin Group Defect 768 is applied, adding this definition.
Open File Description
An "open file description", as it is currently named, describes how a file is being accessed. What is currently
called a "file descriptor" is actually just an identifier or "handle"; it does not actually describe anything.
The following alternate names were discussed:
For "open file description":
"open instance", "file access description", "open file information", and "file access information".
For "file descriptor":
"file handle", "file number" (cf., fileno()). Some historical implementations use
the term "file table entry".
Option-Argument
Austin Group Defect 1784 is applied, changing this definition.
Orphaned Process Group
Historical implementations have a concept of an orphaned process, which is a process whose parent process has
exited. When job control is in use, it is necessary to prevent processes from being stopped in response to interactions with the
terminal after they no longer are controlled by a job control-cognizant program. Because signals generated by the terminal are sent
to a process group and not to individual processes, and because a signal may be provoked by a process that is not orphaned, but
sent to another process that is orphaned, it is necessary to define an orphaned process group. The definition assumes that a
process group will be manipulated as a group and that the job control-cognizant process controlling the group is outside of the
group and is the parent of at least one process in the group (so that state changes may be reported via waitpid()). Therefore, a group is considered to be controlled as long as at least one
process in the group has a parent that is outside of the process group, but within the session.
This definition of orphaned process groups ensures that a session leader's process group is always considered to be
orphaned, and thus it is prevented from stopping in response to terminal signals.
Page
The term "page" is defined to support the description of the behavior of memory mapping for shared memory and
memory mapped files, and the description of the behavior of process memory locking. It is not intended to imply that shared
memory/file mapping and memory locking are applicable only to "paged" architectures. For the purposes of POSIX.1-2024, whatever
the granularity on which an architecture supports mapping or locking, this is considered to be a "page" . If an architecture
cannot support the memory mapping or locking functions specified by POSIX.1-2024 on any granularity, then these options will not be
implemented on the architecture.
Pathname
Pathnames historically allowed all bytes except for the  and  characters. For compatibility
with existing file systems, this usage is maintained throughout the standard by noting that a pathname need not be a valid
character string in all locales. However, the properties of the portable filename character set are such that a pathname using only
those characters and the  is portable in all locales as a character string.
Austin Group Defect 1073 is applied, making it implementation-defined whether the case of exactly two leading
characters is treated specially.
Passwd File*
Implementation-defined; see User Database.
Parent Directory
There may be more than one directory entry pointing to a given directory in some implementations. The wording here
identifies that exactly one of those is the parent directory. In pathname resolution, dot-dot is identified as the way that the
unique directory is identified. (That is, the parent directory is the one to which dot-dot points.) In the case of a remote file
system, if the same file system is mounted several times, it would appear as if they were distinct file systems (with interesting
synchronization properties).
Pattern
Austin Group Defect 1443 is applied, changing this definition to be inclusive of all uses of shell pattern matching
notation.
Pipe
It proved convenient to define a pipe as a special case of a FIFO, even though historically the latter was not
introduced until System III and does not exist at all in 4.3 BSD.
Portable Filename
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0012 [584] is applied.
Portable Filename Character Set
The encoding of this character set is not specified—specifically, ASCII is not required. But the implementation
must provide a unique character code for each of the printable graphics specified by POSIX.1; see also A.4.9 Filenames.
Situations where characters beyond the portable filename character set (or historically ASCII or the
ISO/IEC 646:1991 standard) would be used (in a context where the portable filename character set or the ISO/IEC 646:1991
standard is required by POSIX.1) are expected to be common. Although such a situation renders the use technically non-compliant,
mutual agreement among the users of an extended character set will make such use portable between those users. Such a mutual
agreement could be formalized as an optional extension to POSIX.1. (Making it required would eliminate too many possible systems,
as even those systems using the ISO/IEC 646:1991 standard as a base character set extend their character sets for Western
Europe and the rest of the world in different ways.)
Nothing in POSIX.1 is intended to preclude the use of extended characters where interchange is not required or
where mutual agreement is obtained. It has been suggested that in several places "should" be used instead of "shall". Because
(in the worst case) use of any character beyond the portable filename character set would render the program or data not portable
to all possible systems, no extensions are permitted in this context.
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0013 [584] is applied.
Portable Messages Object Source File (or Dot-Po File)
Austin Group Defect 1122 is applied, adding this definition.
Positional Parameter
Austin Group Defect 1514 is applied, changing this definition in line with earlier changes to the cross-reference
to which it refers.
Positive
Austin Group Defect 1428 is applied, adding this definition.
Process
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0014 [690] is applied.
Process Lifetime
IEEE Std 1003.1-2001/Cor 2-2004, item XBD/TC2/D6/5 is applied, adding fork(), posix_spawn(), posix_spawnp(), and vfork() to the list of functions.
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0014 [690] is applied.
Process Termination
IEEE Std 1003.1-2001/Cor 2-2004, item XBD/TC2/D6/6 is applied, rewording the definition to address
the "passive exit" on termination of the last thread or the _Exit() function.
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0014 [690] is applied.
Austin Group Defect 1302 is applied, aligning this section with the ISO/IEC 9899:2018 standard.
Process-Owned File Lock
Austin Group Defect 768 is applied, adding this definition.
Pseudo-Terminal
Austin Group Defect 1466 is applied, changing the terminology used for pseudo-terminal devices.
Radix Character (or Decimal-Point Character)
Austin Group Defect 1449 is applied, adding "(or Decimal-Point Character)".
Record Lock
Austin Group Defect 768 is applied, adding this definition.
Regular Built-In Utility (or Regular Built-In)
Austin Group Defect 850 is applied, adding this entry as a pointer to the Built-In Utility definition.
Regular File
POSIX.1 does not intend to preclude the addition of structuring data (for example, record lengths) in the file, as
long as such data is not visible to an application that uses the features described in POSIX.1.
Root Directory
This definition permits the operation of chroot(), even though that function is not in POSIX.1; see also
A.4.8 File Hierarchy.
Root File System*
Implementation-defined.
Root of a File System*
Commonly used to refer to a mount point; this standard uses the latter.
Signal
The definition implies a double meaning for the term. Although a signal is an event, common usage implies that a
signal is an identifier of the class of event.
Single-Threaded Process
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0011 [625] is applied.
Single-Threaded Program
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0011 [625] is applied.
Austin Group Defect 1302 is applied, aligning this section with the ISO/IEC 9899:2018 standard.
Source Code
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0015 [896] is applied.
Sparse File
Austin Group Defect 415 is applied, adding this definition.
Special Built-In Utility (or Special Built-In)
Austin Group Defect 1583 is applied, clarifying that "special built-in utility" and "special built-in" are
equivalent terms.
Standard Error
Austin Group Defect 1493 is applied, expanding this definition to cover uses of the term outside the XSH
volume.
Standard Input
Austin Group Defect 1493 is applied, expanding this definition to cover uses of the term outside the XSH
volume.
Standard Output
Austin Group Defect 1493 is applied, expanding this definition to cover uses of the term outside the XSH
volume.
Stream
Austin Group Defect 1371 is applied, updating the stream definition so that it applies to the shell command
language as well as the C language.
Superuser*
This concept, with great historical significance to UNIX system users, has been replaced with the notion of
appropriate privileges.
Supplementary Group ID
The POSIX.1-1990 standard is inconsistent in its treatment of supplementary groups. The definition of supplementary
group ID explicitly permits the effective group ID to be included in the set, but wording in the description of the setuid() and setgid() functions states: "Any
supplementary group IDs of the calling process remain unchanged by these function calls". In the case of setgid() this contradicts that definition. In addition, some felt that the unspecified
behavior in the definition of supplementary group IDs adds unnecessary portability problems. The standard developers considered
several solutions to this problem:
Reword the description of setgid() to permit it to change the
supplementary group IDs to reflect the new effective group ID. A problem with this is that it adds more "may"s to the wording and
does not address the portability problems of this optional behavior.
Mandate the inclusion of the effective group ID in the supplementary set (giving {NGROUPS_MAX} a minimum value of
1). This is the behavior of 4.4 BSD. In that system, the effective group ID is the first element of the array of supplementary
group IDs (there is no separate copy stored, and changes to the effective group ID are made only in the supplementary group set).
By convention, the initial value of the effective group ID is duplicated elsewhere in the array so that the initial value is not
lost when executing a set-group-ID program.
Change the definition of supplementary group ID to exclude the effective group ID and specify that the effective
group ID does not change the set of supplementary group IDs. This is the behavior of 4.2 BSD, 4.3 BSD, and System V Release
4.
Change the definition of supplementary group ID to exclude the effective group ID, and require that getgroups() return the union of the effective group ID and the supplementary group
IDs.
Change the definition of {NGROUPS_MAX} to be one more than the number of supplementary group IDs, so it continues
to be the number of values returned by getgroups() and existing applications
continue to work. This alternative is effectively the same as the second (and might actually have the same implementation).
The standard developers decided to permit either 2 or 3. The effective group ID is orthogonal to the set of
supplementary group IDs, and it is implementation-defined whether getgroups()
returns this. If the effective group ID is returned with the set of supplementary group IDs, then all changes to the effective
group ID affect the supplementary group set returned by getgroups(). It is
permissible to eliminate duplicates from the list returned by getgroups().
However, if a group ID is contained in the set of supplementary group IDs, setting the group ID to that value and then to a
different value should not remove that value from the supplementary group IDs.
The definition of supplementary group IDs has been changed to not include the effective group ID. This simplifies
permanent rationale and makes the relevant functions easier to understand. The getgroups() function has been modified so that it can, on an implementation-defined basis,
return the effective group ID. By making this change, functions that modify the effective group ID do not need to discuss adding to
the supplementary group list; the only view into the supplementary group list that the application developer has is through the
getgroups() function.
Suspended Job
Austin Group Defect 1254 is applied, changing this definition.
Symbolic Constant
Earlier versions of this standard used a variety of terms other than "macro" for many of the constants defined in
headers, and it was not clear in which of these cases they were required to be macros or not, or to be pre-processor constants
(i.e., usable in #if) or not. In cases where the symbols had a reserved prefix or suffix, there was often inconsistency
between whether the prefix/suffix was reserved only for macros or for any use, and whether the term "macro" or a different term
was used in the descriptions of the symbols. There were also some unintentional differences from the ISO C standard.
One of the most commonly used terms was "symbolic constant". This has now been designated as the default term to
be used wherever appropriate, and a formal definition of the term has been added giving the exact requirements for symbols that are
described as symbolic constants.
The standard developers have performed a major rationalization of the header descriptions of symbols with constant
values according to the following policy:
Where symbols are from the ISO C standard, the wording from the ISO C standard (or equivalent, in cases
where the exact wording is not appropriate) is used to describe them.
For all other constants, the first choice is to use "symbolic constant" when the requirements for the symbol are
a reasonably close fit with those of the term.
The description of the symbol can override individual requirements for symbolic constants; e.g., to specify a
non-integer type, or to add a requirement that the symbol is usable in #if preprocessor directives.
When neither of the above apply, the exact requirements are stated in the description. (Note that macros are not
required to be usable in #if, or even to expand to constant expressions, unless explicitly stated.)
In cases where there is a reserved prefix or suffix, if the symbol(s) with that prefix/suffix are from the
ISO C standard and are required to be macros, or if the symbol is required to be usable in #if, then the prefix/suffix
is reserved for use only as macros. If the symbol(s) are "symbolic constants" and not required to be usable in #if, the
prefix/suffix is reserved for any use except in a few special cases.
Where a constant is required to be a macro but is also allowed to be another type of constant such as an
enumeration constant, on implementations which do define it as another type of constant the macro is typically defined as
follows:
#define macro_name macro_name
This allows applications to use #ifdef, etc. to determine whether the macro is defined, but the macro is not
usable in #if preprocessor directives because the preprocessor will treat the unexpanded word macro_name as having
the value zero.
Symbolic Link
Earlier versions of this standard did not require symbolic links to have attributes such as ownership and a file
serial number. This was because the 4.4 BSD implementation did not have them, and it was expected that other implementations may
wish to do the same. However, experience with 4.4 BSD has shown that symbolic links implemented in this way cause problems for
users and application developers, and later BSD systems have reverted to using inodes to implement symbolic links. Allowing
no-inode symbolic links also caused problems in the standard. For example, leaving the st_ino value for symbolic
links unspecified meant that the common technique of comparing the st_dev and st_ino values for two pathnames to see
if they refer to the same file could only be used with stat() in conforming
applications and not with lstat(). The standard now requires symbolic links to have
meaningful values for the same struct stat fields as regular files, except for the file mode bits in st_mode.
Historically, the file mode bits were unused (the contents of a symbolic link could always be read), but implementations differed
as to whether the file mode bits (as returned in st_mode or reported by ls
-l) were set according to the umask or just to a fixed value such as 0777.
Accordingly, the standard requires the file mode bits to be ignored by readlink()
and when a symbolic link is followed during pathname resolution, but leaves the corresponding part of the value returned in
st_mode unspecified.
Historical implementations were followed when determining which interfaces should apply to symbolic links.
Interfaces that historically followed symbolic links include chmod(), stat(), and utime(). Interfaces that historically did not follow symbolic links include
lstat(), rename(), remove(), rmdir(), and unlink(). For chown() and link(), historical implementations differed. POSIX.1-2024 inherited the lchown() function from the Single UNIX Specification, Version 2, and therefore requires
chown() to follow symbolic links. Earlier versions of this standard required link() to follow symbolic links, but with the addition of the linkat() function (which has a flag to indicate whether to follow symbolic links), both
behaviors are now allowed for link().
When the final component of a pathname is a symbolic link, the standard requires that a trailing
causes the link to be followed. This is the behavior of historical implementations. For example, for /a/b and /a/b/,
if /a/b is a symbolic link to a directory, then /a/b refers to the symbolic link, and /a/b/ refers to the
directory to which the symbolic link points.
Because a symbolic link and its referenced object coexist in the file system name space, confusion can arise in
distinguishing between the link itself and the referenced object. Historically, utilities and system calls have adopted their own
link following conventions in a somewhat ad hoc fashion. Rules for a uniform approach are outlined here, although historical
practice has been adhered to as much as was possible. To promote consistent system use, user-written utilities are encouraged to
follow these same rules.
Symbolic links are handled either by operating on the link itself, or by operating on the object referenced by the
link. In the latter case, an application or system call is said to "follow" the link. Symbolic links may reference other symbolic
links, in which case links are dereferenced until an object that is not a symbolic link is found, a symbolic link that references a
file that does not exist is found, or a loop is detected. (Current implementations do not detect loops, but have a limit on the
number of symbolic links that they will dereference before declaring it an error.)
There are four domains for which default symbolic link policy is established in a system. In almost all cases,
there are utility options that override this default behavior. The four domains are as follows:
Symbolic links specified to system calls that take pathname arguments
Symbolic links specified as command line pathname arguments to utilities that are not performing a traversal of a
file hierarchy
Symbolic links referencing files not of type directory, specified to utilities that are performing a traversal of
a file hierarchy
Symbolic links referencing files of type directory, specified to utilities that are performing a traversal of a
file hierarchy
First Domain
The first domain is considered in earlier rationale.
Second Domain
The reason this category is restricted to utilities that are not traversing the file hierarchy is that some
standard utilities take an option that specifies a hierarchical traversal, but by default operate on the arguments themselves.
Generally, users specifying the option for a file hierarchy traversal wish to operate on a single, physical hierarchy, and
therefore symbolic links, which may reference files outside of the hierarchy, are ignored. For example, chown owner file is a different operation from the same command with the -R
option specified. In this example, the behavior of the command chown owner file
is described here, while the behavior of the command chown -R owner file
is described in the third and fourth domains.
The general rule is that the utilities in this category follow symbolic links named as arguments.
Exceptions in the second domain are:
The mv and rm utilities do not
follow symbolic links named as arguments, but respectively attempt to rename or delete them.
The ls utility is also an exception to this rule. For compatibility with
historical systems, when the -R option is not specified, the ls utility follows
symbolic links named as arguments if the -L option is specified or if the -F, -d, or -l options are not
specified. (If the -L option is specified, ls always follows symbolic links; it is
the only utility where the -L option affects its behavior even though a tree walk is not being performed.)
All other standard utilities, when not traversing a file hierarchy, always follow symbolic links named as
arguments.
Historical practice is that the -h option is specified if standard utilities are to act upon symbolic links
instead of upon their targets. Examples of commands that have historically had a -h option for this purpose are the chgrp, chown, file, and test utilities.
Third Domain
The third domain is symbolic links, referencing files not of type directory, specified to utilities that are
performing a traversal of a file hierarchy. (This includes symbolic links specified as command line pathname arguments or
encountered during the traversal.)
The intention of the Shell and Utilities volume of POSIX.1-2024 is that the operation that the utility is
performing is applied to the symbolic link itself, if that operation is applicable to symbolic links. If the operation is not
applicable to symbolic links, the symbolic link should be ignored. Specifically, by default, no change should be made to the file
referenced by the symbolic link.
Fourth Domain
The fourth domain is symbolic links referencing files of type directory, specified to utilities that are performing
a traversal of a file hierarchy. (This includes symbolic links specified as command line pathname arguments or encountered during
the traversal.)
Most standard utilities do not, by default, indirect into the file hierarchy referenced by the symbolic link. (The
Shell and Utilities volume of POSIX.1-2024 uses the informal term "physical walk" to describe this case. The case where the
utility does indirect through the symbolic link is termed a "logical walk".)
There are three reasons for the default to be a physical walk:
With very few exceptions, a physical walk has been the historical default on UNIX systems supporting symbolic
links. Because some utilities (that is, rm) must default to a physical walk, regardless,
changing historical practice in this regard would be confusing to users and needlessly incompatible.
For systems where symbolic links have the historical file attributes (that is, owner, group,
mode), defaulting to a logical traversal would require the addition of a new option to the commands to modify the attributes
of the link itself. This is painful and more complex than the alternatives.
There is a security issue with defaulting to a logical walk. Historically, the command chown -R user file has been safe for the superuser because setuid and
setgid bits were lost when the ownership of the file was changed. If the walk were logical, changing ownership would no
longer be safe because a user might have inserted a symbolic link pointing to any file in the tree. Again, this would necessitate
the addition of an option to the commands doing hierarchy traversal to not indirect through the symbolic links, and historical
scripts doing recursive walks would instantly become security problems. While this is mostly an issue for system administrators, it
is preferable to not have different defaults for different classes of users.
However, the standard developers agreed to leave it unspecified to achieve consensus.
As consistently as possible, users may cause standard utilities performing a file hierarchy traversal to follow any
symbolic links named on the command line, regardless of the type of file they reference, by specifying the -H (for half
logical) option. This option is intended to make the command line name space look like the logical name space.
As consistently as possible, users may cause standard utilities performing a file hierarchy traversal to follow any
symbolic links named on the command line as well as any symbolic links encountered during the traversal, regardless of the type of
file they reference, by specifying the -L (for logical) option. This option is intended to make the entire name space look
like the logical name space.
For consistency, implementors are encouraged to use the -P (for "physical") flag to specify the physical
walk in utilities that do logical walks by default for whatever reason.
When one or more of the -H, -L, and -P flags can be specified, the last one specified
determines the behavior of the utility. This permits users to alias commands so that the default behavior is a logical walk and
then override that behavior on the command line.
Exceptions in the Third and Fourth Domains
The ls and rm utilities are
exceptions to these rules. The rm utility never follows symbolic links and does not
support the -H, -L, or -P options. Some historical versions of ls
always followed symbolic links given on the command line whether the -L option was specified or not. Historical versions of
ls did not support the -H option. In POSIX.1-2024, unless one of the -H or
-L options is specified, the ls utility only follows symbolic links to directories
that are given as operands. The ls utility does not support the -P option.
The Shell and Utilities volume of POSIX.1-2024 requires that the standard utilities ls, find, and pax detect infinite loops when doing logical walks; that is, a directory, or more commonly a
symbolic link, that refers to an ancestor in the current file hierarchy. If the file system itself is corrupted, causing the
infinite loop, it may be impossible to recover. Because find and ls are often used in system administration and security applications, they should attempt to
recover and continue as best as they can. The pax utility should terminate because the
archive it was creating is by definition corrupted. Other, less vital, utilities should probably simply terminate as well.
Implementations are strongly encouraged to detect infinite loops in all utilities.
Historical practice is shown in Historical Practice for Symbolic Links. The heading
SVID3 stands for the Third Edition of the System V Interface Definition.
Historically, several shells have had built-in versions of the pwd
utility. In some of these shells, pwd reported the physical path, and in others, the
logical path. Implementations of the shell corresponding to POSIX.1-2024 must report the logical path by default.
The cd command is required, by default, to treat the filename dot-dot
logically. Implementors are required to support the -P flag in cd so that users
can have their current environment handled physically. In 4.3 BSD, chgrp during tree
traversal changed the group of the symbolic link, not the target. Symbolic links in 4.4 BSD did not have owner,
group, mode, or other standard UNIX system file attributes.
Table: Historical Practice for Symbolic Links
Utility
SVID3
4.3 BSD
4.4 BSD
POSIX
Comments
cd
-L
Treat ".." logically.
cd
-P
Treat ".." physically.
chgrp
-H
-H
Follow command line symlinks.
chgrp
-h
-L
Follow symlinks.
chgrp
-h
-h
Affect the symlink.
chmod
Affect the symlink.
chmod
-H
Follow command line symlinks.
chmod
-h
Follow symlinks.
chown
-H
-H
Follow command line symlinks.
chown
-h
-L
Follow symlinks.
chown
-h
-h
Affect the symlink.
cp
-H
-H
Follow command line symlinks.
cp
-h
-L
Follow symlinks.
cpio
-L
-L
Follow symlinks.
du
-H
-H
Follow command line symlinks.
du
-h
-L
Follow symlinks.
file
-h
-h
Affect the symlink.
find
-H
-H
Follow command line symlinks.
find
-h
-L
Follow symlinks.
find
-follow
-follow
Follow symlinks.
ln
-s
-s
-s
-s
Create a symbolic link.
ls
-L
-L
-L
-L
Follow symlinks.
ls
-H
Follow command line symlinks.
mv
Operates on the symlink.
pax
-H
-H
Follow command line symlinks.
pax
-h
-L
Follow symlinks.
pwd
-L
Printed path may contain symlinks.
pwd
-P
Printed path will not contain symlinks.
rm
Operates on the symlink.
tar
-H
Follow command line symlinks.
tar
-h
-h
Follow symlinks.
test
-h
-h
-h
Affect the symlink.
Synchronized I/O Data Integrity Completion
Austin Group Defect 672 is applied, clarifying how this definition applies to directories, and that it does not
apply to symbolic links.
Synchronously-Generated Signal
Those signals that may be generated synchronously include SIGABRT, SIGBUS, SIGILL, SIGFPE, SIGPIPE, and
SIGSEGV.
Any signal sent via the raise() function or a kill() function targeting the current process is also considered synchronous.
System Call*
The distinction between a "system call" and a "library routine" is an implementation detail that may differ
between implementations and has thus been excluded from POSIX.1.
See "Interface, Not Implementation" in the Preface.
System Console
IEEE Std 1003.1-2001/Cor 2-2004, item XBD/TC2/D6/7 is applied, changing from "An
implementation-defined device" to "A device".
System Databases
IEEE Std 1003.1-2001/Cor 2-2004, item XBD/TC2/D6/9 is applied, rewording the definition to reference
the existing definitions for "group database" and "user database".
System Process
IEEE Std 1003.1-2001/Cor 2-2004, item XBD/TC2/D6/8 is applied, rewording the definition to remove
the requirement for an implementation to define the object.
System Reboot
A "system reboot" is an event initiated by an unspecified circumstance that causes all processes (other than
special system processes) to be terminated in an implementation-defined manner, after which any changes to the state and contents
of files created or written to by a Conforming POSIX.1 Application prior to the event are implementation-defined.
IEEE Std 1003.1-2001/Cor 2-2004, item XBD/TC2/D6/10 is applied, changing "An implementation-defined
sequence of events" to "An unspecified sequence of events".
Synchronized I/O Data (and File) Integrity Completion
These terms specify that for synchronized read operations, pending writes must be successfully completed before the
read operation can complete. This is motivated by two circumstances. Firstly, when synchronizing processes can access the same
file, but not share common buffers (such as for a remote file system), this requirement permits the reading process to guarantee
that it can read data written remotely. Secondly, having data written synchronously is insufficient to guarantee the order with
respect to a subsequent write by a reading process, and thus this extra read semantic is necessary.
Text Domain
Austin Group Defect 1122 is applied, adding this definition.
Text File
The term "text file" does not prevent the inclusion of control or other non-printable characters (other than
NUL). Therefore, standard utilities that list text files as inputs or outputs are either able to process the special characters or
they explicitly describe their limitations within their individual descriptions. The definition of "text file" has caused
controversy. The only difference between text and binary files is that text files have lines of less than {LINE_MAX} bytes, with no
NUL characters, each terminated by a . The definition allows a file with a single , or a totally
empty file, to be called a text file. If a file ends with an incomplete line it is not strictly a text file by this definition. The
referred to in POSIX.1-2024 is not some generic line separator, but a single character; files created on systems
where they use multiple characters for ends of lines are not portable to all conforming systems without some translation process
unspecified by POSIX.1-2024.
Thread
POSIX.1-2024 defines a live thread to be a flow of control within a process. Each thread has a minimal amount of
private state; most of the state associated with a process is shared among all of the threads in the process. While most
multi-thread extensions to POSIX have taken this approach, others have made different decisions.
Note:
The choice to put threads within a process does not constrain implementations to implement threads in that manner. However, all
functions have to behave as though threads share the indicated state information with the process from which they were
created.
Threads need to share resources in order to cooperate. Memory has to be widely shared between threads in order for
the threads to cooperate at a fine level of granularity. Threads keep data structures and the locks protecting those data
structures in shared memory. For a data structure to be usefully shared between threads, such structures should not refer to any
data that can only be interpreted meaningfully by a single thread. Thus, any system resources that might be referred to in data
structures need to be shared between all threads. File descriptors, pathnames, and pointers to stack variables are all things that
programmers want to share between their threads. Thus, the file descriptor table, the root directory, the current working
directory, and the address space have to be shared.
Library implementations are possible as long as the effective behavior is as if system services invoked by one
thread do not suspend other threads. This may be difficult for some library implementations on systems that do not provide
asynchronous facilities.
See B.2.9 Threads for additional rationale.
Austin Group Defect 792 is applied, changing this definition.
Thread ID
See B.2.9.2 Thread IDs for additional
rationale.
Austin Group Defect 1302 is applied, aligning this section with the ISO/IEC 9899:2018 standard.
Thread Lifetime
Austin Group Defect 792 is applied, adding this definition.
Thread Termination
Austin Group Defect 792 is applied, adding this definition.
Thread-Safe
All functions required by POSIX.1-2024 need to be thread-safe; see A.4.22 Thread-Safety
and B.2.9.1 Thread-Safety for additional rationale.
Austin Group Defect 1302 is applied, aligning this section with the ISO/IEC 9899:2018 standard.
Thread-Specific Data Key
Austin Group Defect 1302 is applied, aligning this section with the ISO/IEC 9899:2018 standard.
User Database
There are no references in POSIX.1-2024 to a "passwd file" or a "group file", and there is no requirement that
the group or passwd databases be kept in files containing editable text. Many large timesharing systems use
passwd databases that are hashed for speed. Certain security classifications prohibit certain information in the
passwd database from being publicly readable.
The term "encoded" is used instead of "encrypted" in order to avoid the implementation connotations (such as
reversibility or use of a particular algorithm) of the latter term.
The getgrent(), setgrent(), endgrent(), getpwent(), setpwent(), and endpwent() functions are not included as part of the base standard because they provide a
linear database search capability that is not generally useful (the getpwuid(),
getpwnam(), getgrgid(), and
getgrnam() functions are provided for keyed lookup) and because in certain
distributed systems, especially those with different authentication domains, it may not be possible or desirable to provide an
application with the ability to browse the system databases indiscriminately. They are provided on XSI-conformant systems due to
their historical usage by many existing applications.
A change from historical implementations is that the structures used by these functions have fields of the types
gid_t and uid_t, which are required to be defined in the  header. POSIX.1-2024 requires implementations to ensure that these
types are defined by inclusion of  and , respectively, without imposing any name space pollution or errors from
redefinition of types.
POSIX.1-2024 is silent about the content of the strings containing user or group names. These could be digit
strings. POSIX.1-2024 is also silent as to whether such digit strings bear any relationship to the corresponding (numeric) user or
group ID.
Database Access
The thread-safe versions of the user and group database access functions return values in user-supplied buffers
instead of possibly using static data areas that may be overwritten by each call.
IEEE Std 1003.1-2001/Cor 2-2004, item XBD/TC2/D6/11 is applied, removing the words "of
implementation-defined format".
User ID
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0016 [511] is applied.
User Name
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0017 [584] is applied.
Virtual Processor*
The term "virtual processor" was chosen as a neutral term describing all kernel-level schedulable entities, such
as processes, Mach tasks, or lightweight processes. Implementing threads using multiple processes as virtual processors, or
implementing multiplexed threads above a virtual processor layer, should be possible, provided some mechanism has also been
implemented for sharing state between processes or virtual processors. Many systems may also wish to provide implementations of
threads on systems providing "shared processes" or "variable-weight processes". It was felt that exposing such implementation
details would severely limit the type of systems upon which the threads interface could be supported and prevent certain types of
valid implementations. It was also determined that a virtual processor interface was out of the scope of the Rationale
(Informative) volume of POSIX.1-2024.
White Space
Austin Group Defect 1163 is applied, clarifying the definition of white space and adding definitions of white-space
byte, white-space character, and white-space wide character.
XSI
This is included to allow POSIX.1-2024 to be adopted as an IEEE standard and a standard of The Open Group, serving
both POSIX and the Single UNIX Specification in a core set of volumes.
When POSIX.1 and the Single UNIX Specification were merged, the term "XSI" had been used for over 10 years in
connection with the XPG series and the first and second versions of the base volumes of the Single UNIX Specification. The XSI
margin code was introduced to denote the extended or more restrictive semantics beyond POSIX that are applicable to UNIX
systems.
Zombie Process
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0018 [690] is applied.
Zombie Thread
Austin Group Defect 792 is applied, adding this definition.
A.4 General Concepts
The general concepts are similar in nature to the definitions section, with the exception that a term defined in
general concepts can contain normative requirements.
A.4.1 Case Insensitive Comparisons
Case-insensitive matching is defined in this standard in terms of a simple algorithm whereby, for each character in
the string to be matched, if the character is uppercase then the lowercase equivalent (if any) is also checked for a match, and if
the character is lowercase then the uppercase equivalent (if any) is also checked for a match. It is described this way to make the
expected behavior easier to understand; however, implementations may internally use more sophisticated algorithms to improve
efficiency, provided that the result is the same as the simple algorithm would produce.
Austin Group Defect 1031 is applied, adding case insensitive comparisons.
A.4.2 Concurrent Execution
There is no additional rationale provided for this section.
A.4.3 Default Initialization
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0019 [934] is applied.
Austin Group Defect 940 is applied, removing text that was conditional on the all-zero bit pattern of a pointer
object being a null pointer, as this is now mandated.
A.4.4 Directory Operations
Earlier versions of this standard did not make clear that directory modifications are performed atomically and
serially, although that is the historical behavior and was always intended.
Austin Group Defect 672 is applied, adding this subsection.
A.4.5 Directory Protection
There is no additional rationale provided for this section.
A.4.6 Extended Security Controls
Allowing an implementation to define extended security controls enables the use of POSIX.1-2024 in environments
that require different or more rigorous security than that provided in POSIX.1. Extensions are allowed in two areas: privilege and
file access permissions. The semantics of these areas have been defined to permit extensions with reasonable, but not exact,
compatibility with all existing practices. For example, the elimination of the superuser definition precludes identifying a process
as privileged or not by virtue of its effective user ID.
A.4.7 File Access Permissions
A process should not try to anticipate the result of an attempt to access data by a priori use of these
rules. Rather, it should make the attempt to access data and examine the return value (and possibly errno as well), or use
access(). An implementation may include other security mechanisms in addition to
those specified in POSIX.1, and an access attempt may fail because of those additional mechanisms, even though it would succeed
according to the rules given in this section. (For example, the user's security level might be lower than that of the object of the
access attempt.) The supplementary group IDs provide another reason for a process to not attempt to anticipate the result of an
access attempt.
Since the current standard does not specify a method for opening a directory for searching, it is unspecified
whether search permission on the fd argument to openat() and related functions
is based on whether the directory was opened with search mode or on the current permissions allowed by the directory at the time a
search is performed. When there is existing practice that supports opening directories for searching, it is expected that these
functions will be modified to specify that the search permissions will be granted based on the file access modes of the directory's
file descriptor identified by fd, and not on the mode of the directory at the time the directory is searched.
A.4.8 File Hierarchy
Though the file hierarchy is commonly regarded to be a tree, POSIX.1 does not define it as such for three
reasons:
Links may join branches.
In some network implementations, there may be no single absolute root directory; see pathname
resolution.
With symbolic links, the file system need not be a tree or even a directed acyclic graph.
A.4.9 Filenames
Historically, certain filenames and pathnames have been reserved. This list includes core,
/etc/passwd, and so on. Conforming applications should avoid these.
Most historical implementations prohibit case folding in filenames; that is, treating uppercase and lowercase
alphabetic characters as identical. However, some consider case folding desirable:
For user convenience
For ease-of-implementation of the POSIX.1 interface as a hosted system on some popular operating systems
Variants, such as maintaining case distinctions in filenames, but ignoring them in comparisons, have been
suggested. Methods of allowing escaped characters of the case opposite the default have been proposed.
Many reasons have been expressed for not allowing case folding, including:
No solid evidence has been produced as to whether case-sensitivity or case-insensitivity is more convenient for
users.
Making case-insensitivity a POSIX.1 implementation option would be worse than either having it or not having it,
because:
More confusion would be caused among users.
Application developers would have to account for both cases in their code.
POSIX.1 implementors would still have other problems with native file systems, such as short or otherwise
constrained filenames or pathnames, and the lack of hierarchical directory structure.
Case folding is not easily defined in many European languages, both because many of them use characters outside
the US ASCII alphabetic set, and because:
In Spanish, the digraph "ll" is considered to be a single letter, the capitalized form of which may be
either "Ll" or "LL", depending on context.
In French, the capitalized form of a letter with an accent may or may not retain the accent, depending on the
country in which it is written.
In German, the sharp ess may be represented as a single character resembling a Greek beta (ß) in lowercase, but as
the digraph "SS" in uppercase.
In Greek, there are several lowercase forms of some letters; the one to use depends on its position in the word.
Arabic has similar rules.
Many East Asian languages, including Japanese, Chinese, and Korean, do not distinguish case and are sometimes
encoded in character sets that use more than one byte per character.
Multiple character codes may be used on the same machine simultaneously. There are several ISO character sets for
European alphabets. In Japan, several Japanese character codes are commonly used together, sometimes even in filenames; this is
evidently also the case in China. To handle case insensitivity, the kernel would have to at least be able to distinguish for which
character sets the concept made sense.
The file system implementation historically deals only with bytes, not with characters. Limitations on valid
encodings ensure that the byte sequences for the  character,  character, and  character will
not be confused with any other character in any locale. However, there exist common single-shift encodings where other single-byte
characters from the portable filename character set can also occur as a subset of a multi-byte character, making case folding of
portable filename bytes dependent on the context of whether a shift-state is active.
The purpose of POSIX.1 is to standardize the common, existing definition, not to change it. Mandating
case-insensitivity would make all historical implementations non-standard.
Not only the interface, but also application programs would need to change, counter to the purpose of having
minimal changes to existing application code.
At least one of the original developers of the UNIX system has expressed objection in the strongest terms to
either requiring case-insensitivity or making it an option, mostly on the basis that POSIX.1 should not hinder portability of
application programs across related implementations in order to allow compatibility with unrelated operating systems.
Two proposals were entertained regarding case folding in filenames:
Remove all wording that previously permitted case folding.
Rationale
Case folding is inconsistent with the portable filename character set and filename definitions (all bytes except
and null). No known implementations allowing all bytes except  and null also do case folding.
Change "though this practice is not recommended:" to "although this practice is strongly discouraged."
Rationale
If case folding must be included in POSIX.1, the wording should be stronger to discourage the practice.
The consensus selected the first proposal. Otherwise, a conforming application would have to assume that case
folding would occur when it was not wanted, but that it would not occur when it was wanted.
A.4.10 Filename Portability
Filenames should be constructed from the portable filename character set because the use of other characters can be
confusing or ambiguous in certain contexts. (For example, the use of a  (':') in a pathname could cause
ambiguity if that pathname were included in a PATH definition.)
The constraint on use of the  character as the first character of a portable filename is a
constraint on application behavior and not on implementations, since applications might not work as expected when such a filename
is passed as a command line argument.
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0020 [584] is applied.
A.4.11 File System Cache
Earlier versions of this standard did not specify the behavior of aio_fsync(), fdatasync(), or fsync() on directories, nor did they specify constraints on the underlying storage in the
absence of calls to aio_fsync(), fdatasync(), or fsync().
Although directory operations are atomic and serializable, they are not necessarily durable. An application that
requires a directory modification to be durable should use fdatasync() or fsync() (or aio_fsync()) on the directory.
However, the intention of the requirements for directory modifications is that most applications should not need to do this. For
example, a common method of updating a file is to create a new temporary file, call fdatasync() or fsync() to synchronize the new
file, and then use rename() to replace the old file with the new file. If a crash
occurs after the rename(), then the file being updated will have either its old
contents or its new contents on the storage device when the system is rebooted. An application needs to synchronize the directory
only if it wants to be sure the updated file will have its new contents on the storage device.
Some operations, such as rename(), can affect more than one
directory, whereas synchronization calls such as fsync() can affect at most one
directory at a time. Two calls to fsync() may be needed after a rename() to ensure its durability.
If the file system is inconsistent after a crash it is usually automatically checked and repaired when the system
is rebooted, or can be repaired manually using a utility such as fsck.
If an unrecoverable I/O error occurs when cache is transferred to storage, this standard provides no way for
applications to discover the error reliably. Implementations are encouraged to report such errors on subsequent reads of the
storage.
Austin Group Defect 672 is applied, adding this subsection.
A.4.12 File Times Update
This section reflects the actions of historical implementations. The times are not updated immediately, but are
only marked for update by the functions. An implementation may update these times immediately.
The accuracy of the time update values is intentionally left unspecified so that systems can control the bandwidth
of a possible covert channel.
The wording was carefully chosen to make it clear that there is no requirement that the conformance document
contain information that might incidentally affect file timestamps. Any function that performs pathname resolution might update
several last data access timestamps. Functions such as getpwnam() and getgrnam() might update the last data access timestamp of some specific file or files. It
is intended that these are not required to be documented in the conformance document, but they should appear in the system
documentation.
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0021 [626] is applied.
A.4.13 Host and Network Byte Order
There is no additional rationale provided for this section.
A.4.14 Measurement of Execution Time
The methods used to measure the execution time of processes and threads, and the precision of these measurements,
may vary considerably depending on the software architecture of the implementation, and on the underlying hardware. Implementations
can also make tradeoffs between the scheduling overhead and the precision of the execution time measurements. POSIX.1-2024 does not
impose any requirement on the accuracy of the execution time; it instead specifies that the measurement mechanism and its precision
are implementation-defined.
A.4.15 Memory Ordering and Synchronization
Austin Group Defect 1302 is applied, adding the Memory Ordering subsection, adapted from the
ISO/IEC 9899:2018 standard.
A.4.15.1 Memory Ordering
There is no additional rationale provided for this section.
A.4.15.2 Memory Synchronization
In older multi-processors, access to memory by the processors was strictly multiplexed. This meant that a processor
executing program code interrogates or modifies memory in the order specified by the code and that all the memory operation of all
the processors in the system appear to happen in some global order, though the operation histories of different processors are
interleaved arbitrarily. The memory operations of such machines are said to be sequentially consistent. In this environment,
threads can synchronize using ordinary memory operations. For example, a producer thread and a consumer thread can synchronize
access to a circular data buffer as follows:
int rdptr = 0;
int wrptr = 0;
data_t buf[BUFSIZE];
Thread 1:
while (work_to_do) {
int next;
buf[wrptr] = produce();
next = (wrptr + 1) % BUFSIZE;
while (rdptr == next)
;
wrptr = next;
}
Thread 2:
while (work_to_do) {
while (rdptr == wrptr)
;
consume(buf[rdptr]);
rdptr = (rdptr + 1) % BUFSIZE;
}
In modern multi-processors, these conditions are relaxed to achieve greater performance. If one processor stores
values in location A and then location B, then other processors loading data from location B and then location A may see the new
value of B but the old value of A. The memory operations of such machines are said to be weakly ordered. On these machines, the
circular buffer technique shown in the example will fail because the consumer may see the new value of wrptr but the old
value of the data in the buffer. In such machines, synchronization can only be achieved through the use of special instructions
that enforce an order on memory operations. Most high-level language compilers only generate ordinary memory operations to take
advantage of the increased performance. They usually cannot determine when memory operation order is important and generate the
special ordering instructions. Instead, they rely on the programmer to use synchronization primitives correctly to ensure that
modifications to a location in memory are ordered with respect to modifications and/or access to the same location in other
threads. Access to read-only data need not be synchronized. The resulting program is said to be data race-free.
Synchronization is still important even when accessing a single primitive variable (for example, an integer). On
machines where the integer may not be aligned to the bus data width or be larger than the data width, a single memory load may
require multiple memory cycles. This means that it may be possible for some parts of the integer to have an old value while other
parts have a newer value. On some processor architectures this cannot happen, but portable programs cannot rely on this.
In summary, a portable multi-threaded program, or a multi-process program that shares writable memory between
processes, has to use the synchronization primitives to synchronize data access. It cannot rely on modifications to memory being
observed by other threads in the order written in the application or even on modification of a single variable being seen
atomically.
Conforming applications may only use the functions listed to synchronize threads of control with respect to memory
access. There are many other candidates for functions that might also be used. Examples are: signal sending and reception, or pipe
writing and reading. In general, any function that allows one thread of control to wait for an action caused by another thread of
control is a candidate. POSIX.1-2024 does not require these additional functions to synchronize memory access since this would
imply the following:
All these functions would have to be recognized by advanced compilation systems so that memory operations and
calls to these functions are not reordered by optimization.
All these functions would potentially have to have memory synchronization instructions added, depending on the
particular machine.
The additional functions complicate the model of how memory is synchronized and make automatic data race detection
techniques impractical.
Formal definitions of the memory model were rejected as unreadable by the vast majority of programmers. In
addition, most of the formal work in the literature has concentrated on the memory as provided by the hardware as opposed to the
application programmer through the compiler and runtime system. It was believed that a simple statement intuitive to most
programmers would be most effective. POSIX.1-2024 defines functions that can be used to synchronize access to memory, but it leaves
open exactly how one relates those functions to the semantics of each function as specified elsewhere in POSIX.1-2024. POSIX.1-2024
also does not make a formal specification of the partial ordering in time that the functions can impose, as that is implied in the
description of the semantics of each function. It simply states that the programmer has to ensure that modifications do not occur
"simultaneously" with other access to a memory location.
IEEE Std 1003.1-2001/Cor 1-2002, item XBD/TC1/D6/4 is applied, adding a new paragraph beneath the
table of functions: "The pthread_once() function shall synchronize memory for
the first call in each thread for a given pthread_once_t object.".
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0022 [863] is applied.
Austin Group Defect 1216 is applied, adding pthread_cond_clockwait(), pthread_mutex_clocklock(), pthread_rwlock_clockrdlock(), pthread_rwlock_clockwrlock(), and sem_clockwait() to the list of functions that synchronize memory.
Austin Group Defect 1302 is applied, aligning this section with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1426 is applied, clarifying under what conditions the functions named in this section are
required to synchronize memory, and adding pthread_mutex_setprioceiling() to the named functions.
Austin Group Defect 1625 is applied, adding waitid() to the list of
functions that synchronize memory with respect to other threads on all successful calls.
A.4.16 Pathname Resolution
It is necessary to differentiate between the definition of pathname and the concept of pathname resolution with
respect to the handling of trailing  characters. By specifying the behavior here, it is not possible to provide an
implementation that is conforming but extends all interfaces that handle pathnames to also handle strings that are not legal
pathnames (because they have trailing  characters).
Pathnames that end with one or more trailing  characters must refer to directory paths. Earlier
versions of this standard were not specific about the distinction between trailing  characters on files and
directories, and both were permitted.
Two types of implementation have been prevalent; those that ignored trailing  characters on all
pathnames regardless, and those that permitted them only on existing directories.
An earlier version of this standard required that a pathname with a trailing  character be treated as
if it had a trailing "/." everywhere. This specification was ambiguous. In situations where the intent was that the
application wanted to require the implementation to accept the pathname only if it named a directory (existing or to be created as
a result of the call performing pathname resolution), literally adding a '.' after the trailing  could be
interpreted to require use of that pathname to fail. Some of the uses that created ambiguous requirements included
mkdir("newdir/") and rmdir("existing-dir/"). POSIX.1-2024 requires that a pathname with a trailing
be rejected unless it refers to a file that is a directory or to a file that is to be created as a directory. The
rename() function and the mv utility
further specify that a trailing  cannot be used on a pathname naming a file that does not exist when used as the last
argument to rename() or renameat(),
or as the last operand to mv.
Note that this change does not break any conforming applications; since there were two different types of
implementation, no application could have portably depended on either behavior. This change does however require some
implementations to be altered to remain compliant. Substantial discussion over a three-year period has shown that the benefits to
application developers outweighs the disadvantages for some vendors.
On a historical note, some early applications automatically appended a '/' to every path. Rather than fix
the applications, the system implementation was modified to accept this behavior by ignoring any trailing .
Each directory has exactly one parent directory which is represented by the name dot-dot in the first
directory. No other directory, regardless of linkages established by symbolic links, is considered the parent directory by
POSIX.1-2024.
There are two general categories of interfaces involving pathname resolution: those that follow the symbolic link,
and those that do not. There are several exceptions to this rule; for example, open(path,O_CREAT|O_EXCL) will fail
when path names a symbolic link. However, in all other situations, the open()
function will follow the link.
What the filename dot-dot refers to relative to the root directory is implementation-defined. In
Version 7 it refers to the root directory itself; this is the behavior mentioned in POSIX.1-2024. In some networked systems
the construction /../hostname/ is used to refer to the root directory of another host, and POSIX.1 permits this
behavior.
Other networked systems use the construct //hostname for the same purpose; that is, a double initial
is used. There is a potential problem with existing applications that create full pathnames by taking a trunk and a
relative pathname and making them into a single string separated by '/', because they can accidentally create networked
pathnames when the trunk is '/'. This practice is not prohibited because such applications can be made to conform by
simply changing to use "//" as a separator instead of '/':
If the trunk is '/', the full pathname will begin with "///" (the initial '/' and the
separator "//"). This is the same as '/', which is what is desired. (This is the general case of making a
relative pathname into an absolute one by prefixing with "///" instead of '/'.)
If the trunk is "/A", the result is "/A//..."; since non-leading sequences of two or more
characters are treated as a single , this is equivalent to the desired "/A/...".
If the trunk is "//A", the implementation-defined semantics will apply. (The multiple  rule
would apply.)
Application developers should avoid generating pathnames that start with "//". Implementations are
strongly encouraged to avoid using this special interpretation since a number of applications currently do not follow this practice
and may inadvertently generate "//...".
The term "root directory" is only defined in POSIX.1 relative to the process. In some implementations, there may
be no absolute root directory. The initialization of the root directory of a process is implementation-defined.
When the standard says: "Pathname resolution for a given pathname shall yield the same results when used by any
interface in POSIX.1-2024 as long as there are no changes to any files evaluated during pathname resolution for the given pathname
between resolutions", this applies to absolute pathnames or to relative pathnames from the same current working directory. Using
the same relative pathname from two different working directories may yield different results.
Earlier versions of this standard were unclear as to whether a pathname was required to be a character string or
just a string. This standard is now clear that filenames are just strings, and that pathname processing is locale-independent.
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0023 [541,649,825] and XBD/TC2-2008/0024 [825] are applied.
Austin Group Defect 1603 is applied, making a wording improvement related to symbolic links to directories.
A.4.17 Process ID Reuse
There is no additional rationale provided for this section.
A.4.18 Scheduling Policy
There is no additional rationale provided for this section.
A.4.19 Seconds Since the Epoch
Coordinated Universal Time (UTC) includes leap seconds. However, in POSIX time (seconds since the Epoch), leap
seconds are ignored (not applied) to provide an easy and compatible method of computing time differences. Broken-down POSIX time is
therefore not necessarily UTC, despite its appearance.
As of December 2007, 23 leap seconds had been added to UTC since the Epoch, 1 January, 1970. Historically, one leap
second is added every 15 months on average, so this offset can be expected to grow with time.
Most systems' notion of "time" is that of a continuously increasing value, so this value should increase even
during leap seconds. However, not only do most systems not keep track of leap seconds, but most systems are probably not
synchronized to any standard time reference. Therefore, it is inappropriate to require that a time represented as seconds since the
Epoch precisely represent the number of seconds between the referenced time and the Epoch.
It is sufficient to require that applications be allowed to treat this time as if it represented the number of
seconds between the referenced time and the Epoch. It is the responsibility of the vendor of the system, and the administrator of
the system, to ensure that this value represents the number of seconds between the referenced time and the Epoch as closely as
necessary for the application being run on that system.
It is important that the interpretation of time names and seconds since the Epoch values be consistent across
conforming systems; that is, it is important that all conforming systems interpret "536457599 seconds since the Epoch" as 59
seconds, 59 minutes, 23 hours 31 December 1986, regardless of the accuracy of the system's idea of the current time. The expression
is given to ensure a consistent interpretation, not to attempt to specify the calendar. The relationship between tm_yday and
the day of week, day of month, and month is in accordance with the Gregorian calendar, and so is not specified in POSIX.1.
Consistent interpretation of seconds since the Epoch can be critical to certain types of distributed applications
that rely on such timestamps to synchronize events. The accrual of leap seconds in a time standard is not predictable. The number
of leap seconds since the Epoch will likely increase. POSIX.1 is more concerned about the synchronization of time between
applications of astronomically short duration.
Note that tm_yday is zero-based, not one-based, so the day number in the example above is 364. Note also
that the division is an integer division (discarding remainder) as in the C language.
Note also that the meaning of gmtime(), localtime(), and mktime() is specified in
terms of this expression. However, the ISO C standard computes tm_yday from tm_mday, tm_mon, and
tm_year in mktime(). Because it is stated as a (bidirectional) relationship,
not a function, and because the conversion between month-day-year and day-of-year dates is presumed well known and is also a
relationship, this is not a problem.
The number of seconds since the epoch overflows a signed 32-bit integer in 2038. This standard requires that
time_t is an integer type with a width of at least 64 bits (in conforming programming environments). The requirement that
time_t is an integer type is an additional constraint beyond the ISO C standard, which allows a real-floating
time_t. Implementation practice has shown that much existing code is unprepared to deal with a floating-point time_t,
and that use of struct timespec is a more uniform way to provide sub-second time manipulation within applications.
See also Epoch.
The topic of whether seconds since the Epoch should account for leap seconds has been debated on a number of
occasions, and each time consensus was reached (with acknowledged dissent each time) that the majority of users are best served by
treating all days identically. (That is, the majority of applications were judged to assume a single length—as measured in seconds
since the Epoch—for all days. Thus, leap seconds are not applied to seconds since the Epoch.) Those applications which do care
about leap seconds can determine how to handle them in whatever way those applications feel is best. This was particularly
emphasized because there was disagreement about what the best way of handling leap seconds might be. It is a practical
impossibility to mandate that a conforming implementation must have a fixed relationship to any particular official clock (consider
isolated systems, or systems performing "reruns" by setting the clock to some arbitrary time).
Note that as a practical consequence of this, the length of a second as measured by some external standard is not
specified. This unspecified second is nominally equal to an International System (SI) second in duration. Applications must be
matched to a system that provides the particular handling of external time in the way required by the application.
IEEE Std 1003.1-2001/Cor 2-2004, item XBD/TC2/D6/12 is applied, making an editorial correction to
the paragraph commencing "How any changes to the value of seconds ...".
Austin Group Defect 1627 is applied, clarifying that the relationship between the actual date and time in
Coordinated Universal Time, as determined by the International Earth Rotation Service, and the system's current value for seconds
since the Epoch is unspecified.
A.4.20 Semaphore
Austin Group Defect 502 is applied, clarifying the range of values that an XSI semaphore can have.
Austin Group Defect 1116 is applied, removing a reference to the Semaphores option that existed in earlier versions
of this standard.
A.4.21 Special Device Drivers
POSIX systems interact with their physical environment using a variety of devices (such as analog-digital
converters, digital-analog converters, counters, and video graphic equipment), which provide a set of services that cannot be fully
utilized in terms of read and/or write semantics. Traditional practice uses a single function, called ioctl(), to
encapsulate all the control operations on the different devices connected to the system, both special or common devices. The
POSIX.1-1988 standard developers decided not to standardize this interface because it was not type safe, it had a variable number
of parameters, and it had behaviors that could not be specified by the standard because they were driver-dependent. Instead, the
POSIX.1-1988 standard defined a device-specific application program interface (API) for a common class of drivers, Terminals.
Later, The Single UNIX Specification, Version 1 included the ioctl() function, but restricted it to control of STREAMS
devices.
Although the POSIX.1-1988 standard's solution for common classes of devices is the best from the point of view of
application portability, there is still a need for a way to interact with special, or even common devices, for which developing a
full standard API is not practical. The device control option standardized in POSIX.26 and now included in this standard is a
general method for interfacing to the widest possible range of devices, through a new service to pass control information and
commands between the application and the device drivers.
A driver for a special device will normally not be portable between POSIX implementations, but an application that
uses such a driver can be made portable if all functions calling the driver are well defined and standardized. Users and
integrators of realtime systems often add drivers for special devices, and a standardized function format for interfacing with
these devices greatly simplifies this process.
Austin Group Defect 729 is applied, adding this subsection.
A.4.22 Thread-Safety
Where the interface of a function required by POSIX.1-2024 precludes thread-safety, an alternate thread-safe form
is provided. The names of these thread-safe forms are the same as the non-thread-safe forms with the addition of the suffix "_r".
The suffix "_r" is historical, where the 'r' stood for "reentrant".
In some cases, thread-safety is provided by restricting the arguments to an existing function.
See also B.2.9.1 Thread-Safety.
A.4.23 Treatment of Error Conditions for Mathematical Functions
It is intended that undeserved underflow and inexact floating-point exceptions are raised only if avoiding them
would be too costly.
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0025 [543] is applied.
Austin Group Defect 1302 is applied, aligning this section with the ISO/IEC 9899:2018 standard.
A.4.24 Treatment of NaN Arguments for Mathematical Functions
There is no additional rationale provided for this section.
A.4.25 Utility
There is no additional rationale provided for this section.
A.4.26 Variable Assignment
Austin Group Defect 351 is applied, adding a requirement relating to declaration utilities.
A.5 File Format Notation
The notation for spaces allows some flexibility for application output. Note that an empty character position in
format represents one or more  characters on the output (not white space, which can include
characters). Therefore, another utility that reads that output as its input must be prepared to parse the data
using scanf(), awk, and so on. The
'Δ' character is used when exactly one  is output.
The treatment of integers and spaces is different from the printf()
function in that they can be surrounded with  characters. This was done so that, given a format such as:
"%d\n",
the implementation could use a printf() call such as:
printf("%6d\n", foo);
and still conform. This notation is thus somewhat like scanf() in
addition to printf().
The printf() function was chosen as a model because most of the
standard developers were familiar with it. One difference from the C function printf() is that the l and h conversion specifier characters are not used.
As expressed by the Shell and Utilities volume of POSIX.1-2024, there is no differentiation between decimal values for type
int, type long, or type short. The conversion specifications %d or %i should be interpreted
as an arbitrary length sequence of digits. Also, no distinction is made between single precision and double precision numbers
(float or double in C). These are simply referred to as floating-point numbers.
Many of the output descriptions in the Shell and Utilities volume of POSIX.1-2024 use the term "line", such
as:
"%s",
Since the definition of line includes the trailing  already, there is no need to include a
'\n' in the format; a double  would otherwise result.
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0026 [584] is applied.
Austin Group Defect 1205 is applied, changing the description of the % conversion specifier.
Austin Group Defect 1687 is applied, clarifying the references to  characters to specify they are from
the portable character set.
A.6 Character Set
A.6.1 Portable Character Set
The portable character set is listed in full so there is no dependency on the ISO/IEC 646:1991 standard (or
historically ASCII) encoded character set, although the set is identical to the characters defined in the International Reference
version of the ISO/IEC 646:1991 standard.
POSIX.1-2024 poses no requirement that multiple character sets or codesets be supported, leaving this as a
marketing differentiation for implementors. Although multiple charmap files are supported, it is the responsibility of the
implementation to provide the file(s); if only one is provided, only that one will be accessible using the localedef -f option.
The statement about invariance in codesets for the portable character set is worded to avoid precluding
implementations where multiple incompatible codesets are available (for instance, ASCII and EBCDIC). The standard utilities cannot
be expected to produce predictable results if they access portable characters that vary on the same implementation.
Not all character sets need include the portable character set, but each locale must include it. For example, a
Japanese-based locale might be supported by a mixture of character sets: JIS X 0201 Roman (a Japanese version of the
ISO/IEC 646:1991 standard), JIS X 0208, and JIS X 0201 Katakana. Not all of these character sets include
the portable characters, but at least one does (JIS X 0201 Roman).
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0027 [584,967] and XBD/TC2-2008/0028 [745] are applied.
A.6.2 Character Encoding
Encoding mechanisms based on single shifts, such as the EUC encoding used in some Asian and other countries, can be
supported via the current charmap mechanism. With single-shift encoding, each character is preceded by a shift code (SS2 or SS3). A
complete EUC code, consisting of the portable character set (G0) and up to three additional character sets (G1, G2, G3), can be
described using the current charmap mechanism; the encoding for each character in additional character sets G2 and G3 must then
include their single-shift code. Other mechanisms to support locales based on encoding mechanisms such as locking shift are not
addressed by this volume of POSIX.1-2024.
The encodings for  and  are required to be the same across all locales, in part because
pathname resolution requires recognition of these bytes. It is a fortunate accident that all common shift-based encodings did not
use either  or  as a valid second byte in a multi-byte character.
The encodings for  and  are required to be the same across all locales since
they are special to the general terminal interface and cannot be changed (see XBD 11.1.9 Special Characters).
Earlier versions of this standard did not state the requirement that the POSIX locale contains 256 single-byte
characters. This was an oversight; the intention was always that the POSIX locale should have an 8-bit-clean single-byte
encoding.
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0029 [663,967] and XBD/TC2-2008/0030 [745] are applied.
A.6.3 C Language Wide-Character Codes
The standard does not specify how wide characters are encoded or provide a method for defining wide characters in a
charmap. It specifies ways of translating between wide characters and multi-byte characters. The standard does not prevent an
extension from providing a method to define wide characters.
IEEE Std 1003.1-2001/Cor 2-2004, item XBD/TC2/D6/13 is applied, adding a statement that the standard
has no means of defining a wide-character codeset.
Austin Group Defect 1302 is applied, aligning this section with the ISO/IEC 9899:2018 standard.
A.6.4 Character Set Description File
IEEE PASC Interpretation 1003.2 #196 is applied, removing three lines of text dealing with ranges of symbolic names
using position constant values which had been erroneously included in the final IEEE P1003.2b draft standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XBD/TC2/D6/14 is applied, correcting the example and adding a
statement that the standard provides no means of defining a wide-character codeset.
IEEE Std 1003.1-2001/Cor 2-2004, item XBD/TC2/D6/15 is applied, allowing the value zero for the
width value of WIDTH and WIDTH_DEFAULT. This is required to cover some existing locales.
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0031 [967] is applied.
A.6.4.1 State-Dependent Character Encodings
A requirement was considered that would force utilities to eliminate any redundant locking shifts, but this was
left as a quality of implementation issue.
This change satisfies the following requirement from the ISO POSIX-2:1993 standard, Annex H.1:
The support of state-dependent (shift encoding) character sets should be addressed fully. See descriptions of these
in XBD 6.2 Character Encoding. If such character encodings are
supported, it is expected that this will impact XBD 6.2 Character
Encoding, 7. Locale, 9. Regular Expressions, and the comm,
cut, diff, grep, head, join, paste, and tail utilities.
The character set description file provides:
The capability to describe character set attributes (such as collation order or character classes) independent of
character set encoding, and using only the characters in the portable character set. This makes it possible to create generic
localedef source files for all codesets that share the portable character set
(such as the ISO 8859 family or IBM Extended ASCII).
Standardized symbolic names for all characters in the portable character set, making it possible to refer to any
such character regardless of encoding.
Implementations are free to choose their own symbolic names, as long as the names identified by the Base
Definitions volume of POSIX.1-2024 are also defined; this provides support for already existing "character names".
The names selected for the members of the portable character set follow the ISO/IEC 8859-1:1998 standard and
the ISO/IEC 10646-1:2020 standard. However, several commonly used UNIX system names occur as synonyms in the list:
The historical UNIX system names are used for control characters.
The word "slash" is given in addition to "solidus".
The word "backslash" is given in addition to "reverse-solidus".
The word "hyphen" is given in addition to "hyphen-minus".
The word "period" is given in addition to "full-stop".
For digits, the word "digit" is eliminated.
For letters, the words "Latin Capital Letter" and "Latin Small Letter" are eliminated.
The words "left brace" and "right brace" are given in addition to "left-curly-bracket" and
"right-curly-bracket".
The names of the digits are preferred over the numbers to avoid possible confusion between '0' and
'O', and between '1' and 'l' (one and the letter ell).
The names for the control characters in XBD 6. Character Set
were taken from the ISO/IEC 4873:1991 standard.
The charmap file was introduced to resolve problems with the portability of, especially, localedef sources. POSIX.1-2024 assumes that the portable character set is constant across
all locales, but does not prohibit implementations from supporting two incompatible codings, such as both ASCII and EBCDIC. Such
dual-support implementations should have all charmaps and localedef sources
encoded using one portable character set, in effect cross-compiling for the other environment. Naturally, charmaps (and localedef sources) are only portable without transformation between systems using the same
encodings for the portable character set. They can, however, be transformed between two sets using only a subset of the actual
characters (the portable character set). However, the particular coded character set used for an application or an implementation
does not necessarily imply different characteristics or collation; on the contrary, these attributes should in many cases be
identical, regardless of codeset. The charmap provides the capability to define a common locale definition for multiple codesets
(the same localedef source can be used for codesets with different extended
characters; the ability in the charmap to define empty names allows for characters missing in certain codesets).
The  declaration was added at the request of the international community to ease the
creation of portable charmap files on terminals not implementing the default -escape. The
declaration was added at the request of the international community to eliminate the potential
confusion between the  and the hash sign.
The octal number notation with no leading zero required was selected to match those of awk and tr and is consistent with that used by
localedef. To avoid confusion between an octal constant and the back-references
used in localedef source, the octal, hexadecimal, and decimal constants must
contain at least two digits. As single-digit constants are relatively rare, this should not impose any significant hardship.
Provision is made for more digits to account for systems in which the byte size is larger than 8 bits. For example, a Unicode
(ISO/IEC 10646-1:2020 standard) system that has defined 16-bit bytes may require six octal, four hexadecimal, and five decimal
digits.
The decimal notation is supported because some newer international standards define character values in decimal,
rather than in the old column/row notation.
The charmap identifies the coded character sets supported by an implementation. At least one charmap must be
provided, but no implementation is required to provide more than one. Likewise, implementations can allow users to generate new
charmaps (for instance, for a new version of the ISO 8859 family of coded character sets), but does not have to do so. If
users are allowed to create new charmaps, the system documentation describes the rules that apply (for instance, "only coded
character sets that are supersets of the ISO/IEC 646:1991 standard IRV, no multi-byte characters").
This addition of the WIDTH specification satisfies the following requirement from the ISO POSIX-2:1993
standard, Annex H.1:
(9)
The definition of column position relies on the implementation's knowledge of the integral width of the characters. The
charmap or LC_CTYPE locale definitions should be enhanced to allow application specification of these widths.
The character "width" information was first considered for inclusion under LC_CTYPE but was moved because
it is more closely associated with the information in the charmap than information in the locale source (cultural conventions
information). Concerns were raised that formalizing this type of information is moving the locale source definition from the
codeset-independent entity that it was designed to be to a repository of codeset-specific information. A similar issue occurred
with the , , and  information, which was resolved to
reside in the charmap definition.
The width definition was added to the IEEE P1003.2b draft standard with the intent that the wcswidth() and/or wcwidth() functions
(currently specified in the System Interfaces volume of POSIX.1-2024) be the mechanism to retrieve the character width
information.
A.7 Locale
A.7.1 General
The description of locales is based on work performed in the UniForum Technical Committee, Subcommittee on
Internationalization. Wherever appropriate, keywords are taken from the ISO C standard or the X/Open Portability Guide.
The value used to specify a locale with environment variables is the name specified as the name operand to
the localedef utility when the locale was created. This provides a verifiable
method to create and invoke a locale.
The "object" definitions need not be portable, as long as "source" definitions are. Strictly speaking, source
definitions are portable only between implementations using the same character set(s). Such source definitions, if they use
symbolic names only, easily can be ported between systems using different codesets, as long as the characters in the portable
character set (see XBD 6.1 Portable Character Set) have common values
between the codesets; this is frequently the case in historical implementations. Of source, this requires that the symbolic names
used for characters outside the portable character set be identical between character sets. The definition of symbolic names for
characters is outside the scope of POSIX.1-2024, but is certainly within the scope of other standards organizations.
Applications can select the desired locale by invoking the setlocale() function (or equivalent) with the appropriate value. If the function is
invoked with an empty string, the value of the corresponding environment variable is used. If the environment variable is not set
or is set to the empty string, the implementation sets the appropriate environment as defined in XBD 8. Environment Variables.
The locale settings of individual categories cannot be truly independent and still guarantee correct results. For
example, when collating two strings, characters must first be extracted from each string (governed by LC_CTYPE ) before
being mapped to collating elements (governed by LC_COLLATE ) for comparison. That is, if LC_CTYPE is causing parsing
according to the rules of a large, multi-byte code set (potentially returning 20000 or more distinct character codeset values), but
LC_COLLATE is set to handle only an 8-bit codeset with 256 distinct characters, meaningful results are obviously
impossible.
Earlier versions of this standard stated that if different character sets are used by the locale categories, the
results achieved by an application utilizing these categories are undefined. This was felt to be overly restrictive. For example,
when setting:
LANG=en_US.utf8
LC_TIME=POSIX
on a system where the codeset for the POSIX locale is ASCII and the codeset for en_US.utf8 is UTF-8, all of the characters used in
the LC_TIME locale data exist, with the same encoding, in the codeset used for LC_CTYPE (via LANG ), so there
is no reason for the behavior to be undefined in this case. This standard now has more precise requirements in this area.
Austin Group Defect 1122 is applied, adding item 3 to the list of ways to select the locale to be used by some
C-language functions.
Austin Group Defect 1477 is applied, clarifying the behavior when locale categories have different character
sets.
A.7.2 POSIX Locale
On POSIX.1 implementations the POSIX locale is equal to the C locale, even though the requirements for the POSIX
locale are more extensive than the ISO C standard requirements for the C locale. To avoid being classified as a C-language
function, the name has been changed to the POSIX locale; the environment variable value can be either "POSIX" or, for
historical reasons, "C".
The POSIX definitions mirror the historical UNIX system behavior.
The use of symbolic names for characters in the tables does not imply that the POSIX locale must be described using
symbolic character names, but merely that it may be advantageous to do so.
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0032 [796] and XBD/TC2-2008/0033 [663] are applied.
A.7.3 Locale Definition
The decision to separate the file format from the localedef
utility description was only partially editorial. Implementations may provide other interfaces than localedef. Requirements on "the utility", mostly concerning error messages, are
described in this way because they are meant to affect the other interfaces implementations may provide as well as localedef.
The text about POSIX2_LOCALEDEF does not mean that internationalization is optional; only that the functionality of
the localedef utility is. REs, for instance, must still be able to recognize, for
example, character class expressions such as "[[:alpha:]]". A possible analogy is with an applications development
environment; while all conforming implementations must be capable of executing applications, not all need to have the development
environment installed. The assumption is that the capability to modify the behavior of utilities (and applications) via locale
settings must be supported. If the localedef utility is not present, then the only
choice is to select an existing (presumably implementation-documented) locale. An implementation could, for example, choose to
support only the POSIX locale, which would in effect limit the amount of changes from historical implementations quite drastically.
The localedef utility is still required, but would always terminate with an exit
code indicating that no locale could be created. Supported locales must be documented using the syntax defined in this chapter.
(This ensures that users can accurately determine what capabilities are provided. If the implementation decides to provide
additional capabilities to the ones in this chapter, that is already provided for.)
If the option is present (that is, locales can be created), then the localedef utility must be capable of creating locales based on the syntax and rules
defined in this chapter. This does not mean that the implementation cannot also provide alternate means for creating locales.
The octal, decimal, and hexadecimal notations are the same employed by the charmap facility (see XBD 6.4 Character Set Description File). To avoid confusion between an octal
constant and a back-reference, the octal, hexadecimal, and decimal constants must contain at least two digits. As single-digit
constants are relatively rare, this should not impose any significant hardship. Provision is made for more digits to account for
systems in which the byte size is larger than 8 bits. For example, a Unicode (see the ISO/IEC 10646-1:2020 standard) system
that has defined 16-bit bytes may require six octal, four hexadecimal, and five decimal digits. As with the charmap file,
multi-byte characters are described in the locale definition file using "big-endian" notation for reasons of portability. There
is no requirement that the internal representation in the computer memory be in this same order.
One of the guidelines used for the development of this volume of POSIX.1-2024 is that characters outside the
invariant part of the ISO/IEC 646:1991 standard should not be used in portable specifications. The  character
is not in the invariant part; the  is, but with multiple representations: as a , and as a
hash sign. As far as general usage of these symbols, they are covered by the "grandfather clause", but for newly defined
interfaces, the WG15 POSIX working group has requested that POSIX provide alternate representations. Consequently, while the
default escape character remains the  and the default comment character is the ,
implementations are required to recognize alternative representations, identified in the applicable source file via the
and  keywords.
A.7.3.1 LC_CTYPE
The LC_CTYPE category is primarily used to define the encoding-independent aspects of a character set, such
as character classification. In addition, certain encoding-dependent characteristics are also defined for an application via the
LC_CTYPE category. POSIX.1-2024 does not mandate that the encoding used in the locale is the same as the one used by the
application because an implementation may decide that it is advantageous to define locales in a system-wide encoding rather than
having multiple, logically identical locales in different encodings, and to convert from the application encoding to the
system-wide encoding on usage. Other implementations could require encoding-dependent locales.
In either case, the LC_CTYPE attributes that are directly dependent on the encoding, such as
and the display width of characters, are not user-specifiable in a locale source and are consequently not
defined as keywords.
Implementations may define additional keywords or extend the LC_CTYPE mechanism to allow application-defined
keywords.
The text "The ellipsis specification shall only be valid within a single encoded character set" is present
because it is possible to have a locale supported by multiple character encodings, as explained in the rationale for XBD 6.1 Portable Character Set. An example given there is of a possible
Japanese-based locale supported by a mixture of the character sets JIS X 0201 Roman, JIS X 0208, and
JIS X 0201 Katakana. Attempting to express a range of characters across these sets is not logical and the implementation
is free to reject such attempts.
As the LC_CTYPE character classes are based on the ISO C standard character class definition, the
category does not support multi-character elements. For instance, the German character  is traditionally classified
as a lowercase letter. There is no corresponding uppercase letter; in proper capitalization of German text, the
will be replaced by "SS"; that is, by two characters. This kind of conversion is outside the scope of the toupper
and tolower keywords.
Where POSIX.1-2024 specifies that only certain characters can be specified, as for the keywords digit and
xdigit, the specified characters must be from the portable character set, as shown. As an example, only the Arabic digits 0
through 9 are acceptable as digits.
The character classes digit, xdigit, lower, upper, and space have a set of
automatically included characters. These only need to be specified if the character values (that is, encoding) differs from the
implementation default values. It is not possible to define a locale without these automatically included characters unless some
implementation extension is used to prevent their inclusion. Such a definition would not be a proper superset of the C locale, and
thus, it might not be possible for the standard utilities to be implemented as programs conforming to the ISO C standard.
The definition of character class digit requires that only ten characters—the ones defining digits—can be
specified; alternate digits (for example, Hindi or Kanji) cannot be specified here. However, the encoding may vary if an
implementation supports more than one encoding.
The definition of character class xdigit requires that the characters included in character class
digit are included here also and allows for different symbols for the hexadecimal digits 10 through 15.
The inclusion of the charclass keyword satisfies the following requirement from the ISO POSIX-2:1993
standard, Annex H.1:
(3)
The LC_CTYPE (2.5.2.1) locale definition should be enhanced to allow user-specified additional character classes, similar in
concept to the ISO C standard Multibyte Support Extension (MSE) iswctype()
function.
This keyword was previously included in The Open Group specifications and is now mandated in the Shell and
Utilities volume of POSIX.1-2024.
The symbolic constant {CHARCLASS_NAME_MAX} was also adopted from The Open Group specifications. Applications
portability is enhanced by the use of symbolic constants.
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0033 [663], XBD/TC2-2008/0034 [663], XBD/TC2-2008/0035 [584],
and XBD/TC2-2008/0036 [584] are applied.
Austin Group Defect 1078 is applied, clarifying that only the specified set of characters can be included in the
digit and xdigit classes in all locales, not just the POSIX locale.
Austin Group Defect 1589 is applied, disallowing some characters from being included in the blank class.
A.7.3.2 LC_COLLATE
The rules governing collation depend to some extent on the use. At least five different levels of increasingly
complex collation rules can be distinguished:
Byte/machine code order: This is the historical collation order in the UNIX system and many proprietary
operating systems. Collation is here performed character by character, without any regard to context. The primary virtue is that it
usually is quite fast and also completely deterministic; it works well when the native machine collation sequence matches the user
expectations.
Character order: On this level, collation is also performed character by character, without regard to
context. The order between characters is, however, not determined by the code values, but on the expectations by the user of the
"correct" order between characters. In addition, such a (simple) collation order can specify that certain characters collate
equally (for example, uppercase and lowercase letters).
String ordering: On this level, entire strings are compared based on relatively straightforward rules.
Several "passes" may be required to determine the order between two strings. Characters may be ignored in some passes, but not in
others; the strings may be compared in different directions; and simple string substitutions may be performed before strings are
compared. This level is best described as "dictionary" ordering; it is based on the spelling, not the pronunciation, or meaning,
of the words.
Text search ordering: This is a further refinement of the previous level, best described as "telephone
book ordering"; some common homonyms (words spelled differently but with the same pronunciation) are collated together; numbers
are collated as if they were spelled out, and so on.
Semantic-level ordering: Words and strings are collated based on their meaning; entire words (such as
"the") are eliminated; the ordering is not deterministic. This usually requires special software and is highly dependent on the
intended use.
While the historical collation order formally is at level 1, for the English language it corresponds roughly to
elements at level 2. The user expects to see the output from the ls utility sorted very
much as it would be in a dictionary. While telephone book ordering would be an optimal goal for standard collation, this was ruled
out as the order would be language-dependent. Furthermore, a requirement was that the order must be determined solely from the text
string and the collation rules; no external information (for example, "pronunciation dictionaries") could be required.
As a result, the goal for the collation support is at level 3. This also matches the requirements for the Canadian
collation order, as well as other, known collation requirements for alphabetic scripts. It specifically rules out collation based
on pronunciation rules or based on semantic analysis of the text.
The syntax for the LC_COLLATE category source meets the requirements for level 3 and has been verified to
produce the correct result with examples based on French, Canadian, and Danish collation order. Because it supports multi-character
collating elements, it is also capable of supporting collation in codesets where a character is expressed using non-spacing
characters followed by the base character (such as the ISO/IEC 6937:2001 standard).
The directives that can be specified in an operand to the order_start keyword are based on the requirements
specified in several proposed standards and in customary use. The following is a rephrasing of rules defined for "lexical ordering
in English and French" by the Canadian Standards Association (the text in square brackets is rephrased):
Once special characters [punctuation] have been removed from original strings, the ordering is determined by
scanning forwards (left to right) [disregarding case and diacriticals].
In case of equivalence, special characters are once again removed from original strings and the ordering is
determined by scanning backwards (starting from the rightmost character of the string and back), character by character
[disregarding case but considering diacriticals].
In case of repeated equivalence, special characters are removed again from original strings and the ordering is
determined by scanning forwards, character by character [considering both case and diacriticals].
If there is still an ordering equivalence after the first three rules have been applied, then only special
characters and the position they occupy in the string are considered to determine ordering. The string that has a special character
in the lowest position comes first. If two strings have a special character in the same position, the character [with the lowest
collation value] comes first. In case of equality, the other special characters are considered until there is a difference or until
all special characters have been exhausted.
It is estimated that this part of POSIX.1-2024 covers the requirements for all European languages, and no
particular problems are anticipated with Slavic or Middle East character sets.
The Far East (particularly Japanese/Chinese) collations are often based on contextual information and pronunciation
rules (the same ideogram can have different meanings and different pronunciations). Such collation, in general, falls outside the
desired goal of POSIX.1-2024. There are, however, several other collation rules (stroke/radical or "most common pronunciation")
that can be supported with the mechanism described here.
The character order is defined by the order in which characters and elements are specified between the
order_start and order_end keywords. Weights assigned to the characters and elements define the collation sequence; in
the absence of weights, the character order is also the collation sequence.
The position keyword provides the capability to consider, in a compare, the relative position of characters
not subject to IGNORE. As an example, consider the two strings "o-ring" and "or-ing". Assuming the
is subject to IGNORE on the first pass, the two strings compare equal, and the position of the
is immaterial. On second pass, all characters except the  are subject to IGNORE,
and in the normal case the two strings would again compare equal. By taking position into account, the first collates before the
second.
This standard requires that all implementation-provided locales define a collation sequence that has a total
ordering of all characters unless the locale name has an '@' modifier indicating that it has a special collation sequence.
Defining locales in this way eliminates unexpected behavior when non-identical strings can collate equally (for example, sort
-u and sort | uniq are not equivalent). The exception for locales with a suitable '@' modifier in the name
allows implementations to supply locales which do not have a total ordering of all characters provided that they draw attention to
it in the modifier name. For example, @icase could indicate that each upper and lowercase character pair collates equally.
Even with an '@' modifier, total ordering is preferred when possible; for example, characters that are "ignored" in
dictionary order need not be completely ignored (by using IGNORE for all collation weights), but can instead be given a
unique weight after one or more IGNORE weights.
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0037 [938], XBD/TC2-2008/0038 [663], and XBD/TC2-2008/0039
[584] are applied.
Austin Group Defect 948 is applied, requiring that all implementation-provided locales define a collation sequence
that has a total ordering of all characters unless the locale name has an '@' modifier indicating that it has a special
collation sequence.
Austin Group Defect 1740 is applied, noting that it is the responsibility of the locale writer to ensure
has the lowest primary weight in a collation ordering.
A.7.3.3 LC_MONETARY
The currency symbol does not appear in LC_MONETARY because it is not defined in the C locale of the
ISO C standard.
The ISO C standard limits the size of decimal points and thousands delimiters to single-byte values. In
locales based on multi-byte coded character sets, this cannot be enforced; POSIX.1-2024 does not prohibit such characters, but
makes the behavior unspecified (in the text "In contexts where other standards ...").
The grouping specification is based on, but not identical to, the ISO C standard. The -1 indicates that no
further grouping is performed; the equivalent of {CHAR_MAX} in the ISO C standard.
The text "the value is not available in the locale" is taken from the ISO C standard and is used instead of
the "unspecified" text in early proposals. There is no implication that omitting these keywords or assigning them values of
"" or -1 produces unspecified results; such omissions or assignments eliminate the effects described for the keyword or
produce zero-length strings, as appropriate.
The locale definition is an extension of the ISO C standard localeconv() specification. In particular, rules on how currency_symbol is treated
are extended to also cover int_curr_symbol, and p_set_by_space and n_sep_by_space have been augmented with the
value 2, which places a  between the sign and the symbol. This has been updated to match the ISO/IEC 9899:1999
standard requirements and is an incompatible change from UNIX 98 and the ISO POSIX-2 standard and the ISO POSIX-1:1996
standard requirements. The following table shows the result of various combinations:
p_sep_by_space
2
1
0
p_cs_precedes = 1
p_sign_posn = 0
($1.25)
($ 1.25)
($1.25)
p_sign_posn = 1
+ $1.25
+$ 1.25
+$1.25
p_sign_posn = 2
$1.25 +
$ 1.25+
$1.25+
p_sign_posn = 3
+ $1.25
+$ 1.25
+$1.25
p_sign_posn = 4
$ +1.25
$+ 1.25
$+1.25
p_cs_precedes = 0
p_sign_posn = 0
(1.25 $)
(1.25 $)
(1.25$)
p_sign_posn = 1
+1.25 $
+1.25 $
+1.25$
p_sign_posn = 2
1.25$ +
1.25 $+
1.25$+
p_sign_posn = 3
1.25+ $
1.25 +$
1.25+$
p_sign_posn = 4
1.25$ +
1.25 $+
1.25$+
The following is an example of the interpretation of the mon_grouping keyword. Assuming that the value to be
formatted is 123456789 and the mon_thousands_sep is , then the following table shows the result. The third
column shows the equivalent string in the ISO C standard that would be used by the localeconv() function to accommodate this grouping.
mon_grouping
Formatted Value
ISO C String
3;-1
123456'789
"\3\177"
3
123'456'789
"\3"
3;2;-1
1234'56'789
"\3\2\177"
3;2
12'34'56'789
"\3\2"
-1
123456789
"\177"
In these examples, the octal value of {CHAR_MAX} is 177.
IEEE Std 1003.1-2001/Cor 1-2002, item XBD/TC1/D6/6 adds a correction that permits the Euro currency
symbol and addresses extensibility. The correction is stated using the term "should" intentionally, in order to make this a
recommendation rather than a restriction on implementations. This allows for flexibility in implementations on how they handle
future currency symbol additions.
IEEE Std 1003.1-2001/Cor 1-2002, tem XBD/TC1/D6/5 is applied, adding the int_[np]_* values to
the POSIX locale definition of LC_MONETARY .
IEEE Std 1003.1-2001/Cor 2-2004, item XBD/TC2/D6/16 is applied, updating the descriptions of
p_sep_by_space, n_sep_by_space, int_p_sep_by_space, and int_n_sep_by_space to match the description of
these keywords in the ISO C standard and the System Interfaces volume of POSIX.1-2024, localeconv().
Austin Group Defect 1199 is applied, adding a requirement that localedef does not accept certain combinations of *_sign_posn,
positive_sign, and negative_sign values.
Austin Group Defect 1241 is applied, clarifying the meaning of empty string values.
A.7.3.4 LC_NUMERIC
See the rationale for LC_MONETARY for a description of the behavior of grouping.
Austin Group Defect 1241 is applied, clarifying the meaning of empty string values.
A.7.3.5 LC_TIME
Although certain of the conversion specifications in the POSIX locale (such as the name of the month) are shown
with initial capital letters, this need not be the case in other locales. Programs using these conversion specifications may need
to adjust the capitalization if the output is going to be used at the beginning of a sentence.
The LC_TIME descriptions of abday, day, mon, and abmon imply a Gregorian style
calendar (7-day weeks, 12-month years, leap years, and so on). Formatting time strings for other types of calendars is outside the
scope of POSIX.1-2024.
While the ISO 8601:2019 standard numbers the weekdays starting with Monday, historical practice is to use the
Sunday as the first day. Rather than change the order and introduce potential confusion, the days must be specified beginning with
Sunday; previous references to "first day" have been removed. Note also that the Shell and Utilities volume of POSIX.1-2024
date utility supports numbering compliant with the ISO 8601:2019 standard.
As specified under date in the Shell and Utilities volume of
POSIX.1-2024 and strftime() in the System Interfaces volume of POSIX.1-2024, the
conversion specifications corresponding to the optional keywords consist of a modifier followed by a traditional conversion
specification (for instance, %Ex). If the optional keywords are not supported by the implementation or are unspecified for
the current locale, these modified conversion specifications are treated as the traditional conversion specifications. For example,
assume the following keywords:
alt_digits   "0th";"1st";"2nd";"3rd";"4th";"5th";\
"6th";"7th";"8th";"9th";"10th"
d_fmt        "The %Od day of %B in %Y"
On July 4th 1776, the %x conversion specifications would result in "The 4th day of July in 1776",
while on July 14th 1789 it would result in "The 14 day of July in 1789". It can be noted that the above example is for
illustrative purposes only; the %O modifier is primarily intended to provide for Kanji or Hindi digits in date formats.
The following is an example for Japan that supports the current plus last three Emperors and reverts to Western
style numbering for years prior to the Meiji era. The example also allows for the custom of using a special name for the first year
of an era instead of using 1. (The examples substitute romaji where kanji should be used.)
era_d_fmt "%EY%mgatsu%dnichi (%a)"
era    "+:2:1990/01/01:+*:Heisei:%EC%Eynen";\
"+:1:1989/01/08:1989/12/31:Heisei:%ECgannen";\
"+:2:1927/01/01:1989/01/07:Shouwa:%EC%Eynen";\
"+:1:1926/12/25:1926/12/31:Shouwa:%ECgannen";\
"+:2:1913/01/01:1926/12/24:Taishou:%EC%Eynen";\
"+:1:1912/07/30:1912/12/31:Taishou:%ECgannen";\
"+:2:1869/01/01:1912/07/29:Meiji:%EC%Eynen";\
"+:1:1868/09/08:1868/12/31:Meiji:%ECgannen";\
"-:1868:1868/09/07:-*::%Ey"
Assuming that the current date is September 21, 1991, a request to date
or strftime() would yield the following results:
%Ec - Heisei3nen9gatsu21nichi (Sat) 14:39:26
%EC - Heisei
%Ex - Heisei3nen9gatsu21nichi (Sat)
%Ey - 3
%EY - Heisei3nen
Example era definitions for the Republic of China:
era    "+:2:1913/01/01:+*:ChungHwaMingGuo:%EC%EyNen";\
"+:1:1912/1/1:1912/12/31:ChungHwaMingGuo:%ECYuenNen";\
"+:1:1911/12/31:-*:MingChien:%EC%EyNen"
Example definitions for the Christian Era:
era    "+:1:0001/01/01:+*:AD:%EC %Ey";\
"+:1:-0001/12/31:-*:BC:%Ey %EC"
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0040 [912] is applied.
Austin Group Defects 258 and 1166 are applied, adding the alt_mon and ab_alt_mon locale keywords.
Austin Group Defect 1307 is applied, changing the am_pm and t_fmt_ampm keywords and the AM_STR,
PM_STR, and T_FMT_AMPM constants in relation to locales that do not support the 12-hour clock format.
A.7.3.6 LC_MESSAGES
The yesstr and nostr locale keywords and the YESSTR and NOSTR langinfo items were formerly
used to match user affirmative and negative responses. In POSIX.1-2024, the yesexpr, noexpr, YESEXPR, and NOEXPR
extended regular expressions have replaced them. Applications should use the general locale-based messaging facilities to issue
prompting messages which include sample desired responses.
Affirmative responses like:
y
Yes
Yes!
and negative responses like:
N
No
Never
No way!
should all be recognized as affirmative and negative responses, respectively, by the EREs identified by the
yesexpr and noexpr keywords for English language-based locales. There is no requirement that multi-line responses nor
ambiguous responses like:
no or yes
yes or no
maybe
be correctly classified by either of these EREs. Application writers are encouraged to include locale-specific
suggestions for affirmative and negative responses in prompts.
A.7.4 Locale Definition Grammar
There is no additional rationale provided for this section.
A.7.4.1 Locale Lexical Conventions
There is no additional rationale provided for this section.
A.7.4.2 Locale Grammar
Austin Group Defects 258 and 1166 are applied, adding the alt_mon and ab_alt_mon locale keywords.
A.7.5 Locale Definition Example
The following is an example of a locale definition file that could be used as input to the localedef utility. It assumes that the utility is executed with the -f option,
naming a charmap file with (at least) the following content:
CHARMAP
\x20
\x24
\101
\141
\346
\365
\300
\366
\142
\103
\143
\347
\x64
\110
\150
\xb7
\x73
\x7a
END CHARMAP
It should not be taken as complete or to represent any actual locale, but only to illustrate the syntax.
#
LC_CTYPE
lower   ;;;;;...;
upper   A;B;C;Ç;...;Z
space   \x20;\x09;\x0a;\x0b;\x0c;\x0d
blank   \040;\011
toupper (,);(b,B);(c,C);(ç,Ç);(d,D);(z,Z)
END LC_CTYPE
#
LC_COLLATE
#
# The following example of collation is based on
# Canadian standard Z243.4.1-1998, "Canadian Alphanumeric
# Ordering Standard for Character Sets of CSA Z234.4 Standard".
# (Other parts of this example locale definition file do not
# purport to relate to Canada, or to any other real culture.)
# The proposed standard defines a 4-weight collation, such that
# in the first pass, characters are compared without regard to
# case or accents; in the second pass, backwards-compare without
# regard to case; in the third pass, forwards-compare without
# regard to diacriticals. In the 3 first passes, non-alphabetic
# characters are ignored; in the fourth pass, only special
# characters are considered, such that "The string that has a
# special character in the lowest position comes first. If two
# strings have a special character in the same position, the
# collation value of the special character determines ordering.
#
# Only a subset of the character set is used here; mostly to
# illustrate the set-up.
#
collating-symbol
collating-symbol
collating-symbol
collating-symbol
collating-symbol
collating-symbol
collating-symbol
collating-symbol
collating-symbol
collating-symbol
collating-symbol
# Further collating-symbols follow.
#
# Properly, the standard does not include any multi-character
# collating elements; the one below is added for completeness.
#
collating_element  from ""
collating_element  from ""
collating_element  from ""
#
order_start forward;backward;forward;forward,position
#
# Collating symbols are specified first in the sequence to allocate
# basic collation values to them, lower than that of any character.
# Further collating symbols are given a basic collating value here.
#
# Here follow special characters.
IGNORE;IGNORE;IGNORE;
# Other special characters follow here.
#
# Here follow the regular characters.
;;;IGNORE
;;;IGNORE
;;;IGNORE
;;;IGNORE
;;;IGNORE
;;;IGNORE
"";"";\
"";IGNORE
"";"";\
"";IGNORE
;;;IGNORE
;;;IGNORE
;;;IGNORE
;;;IGNORE
;;;IGNORE
;;;IGNORE
;;;IGNORE
#
# As an example, the strings "Bach" and "bach" could be encoded (for
# compare purposes) as:
# "Bach"  ;;;;;;\
#         ;;;;\
#         ;
# "bach"  ;;;;;;\
#         ;;;;\
#         ;
#
# The two strings are equal in pass 1 and 2, but differ in pass 3.
#
# Further characters follow.
#
UNDEFINED    IGNORE;IGNORE;IGNORE;IGNORE
#
order_end
#
END LC_COLLATE
#
LC_MONETARY
int_curr_symbol    "USD "
currency_symbol    "$"
mon_decimal_point  "."
mon_grouping       3;0
positive_sign      ""
negative_sign      "-"
p_cs_precedes      1
n_sign_posn        0
END LC_MONETARY
#
LC_NUMERIC
copy "US_en.ASCII"
END LC_NUMERIC
#
LC_TIME
abday   "Sun";"Mon";"Tue";"Wed";"Thu";"Fri";"Sat"
#
day     "Sunday";"Monday";"Tuesday";"Wednesday";\
"Thursday";"Friday";"Saturday"
#
abmon   "Jan";"Feb";"Mar";"Apr";"May";"Jun";\
"Jul";"Aug";"Sep";"Oct";"Nov";"Dec"
#
mon     "January";"February";"March";"April";\
"May";"June";"July";"August";"September";\
"October";"November";"December"
#
d_t_fmt "%a %b %d %T %Z %Y\n"
END LC_TIME
#
LC_MESSAGES
yesexpr "^([yY][[:alpha:]]*)|(OK)"
#
noexpr  "^[nN][[:alpha:]]*"
END LC_MESSAGES
A.8 Environment Variables
A.8.1 Environment Variable Definition
The variable environ is not intended to be declared in any header, but rather to be declared by the user for
accessing the array of strings that is the environment. This is the traditional usage of the symbol. Putting it into a header could
break some programs that use the symbol for their own purposes.
The decision to restrict conforming systems to the use of digits, uppercase letters, and underscores for
environment variable names allows applications to use lowercase letters in their environment variable names without conflicting
with any conforming system.
In addition to the obvious conflict with the shell syntax for positional parameter substitution, some historical
applications (including some shells) exclude names with leading digits from the environment.
Some historical implementations removed certain environment variables during program startup when security criteria
were not met, instead of just ignoring them at the point of use. The standard developers decided not to allow this behavior because
if a process drops all privileges and sets its effective user and group IDs to be the same as its real user and group IDs before
executing a program or utility, the behavior should be the same as if the process had originally met the security criteria.
Austin Group Defect 367 is applied, adding requirements relating to the use of readonly on environment variables that are manipulated by shell built-in utilities.
Austin Group Defect 922 is applied, allowing implementations to ignore some environment variables at the point of
use for security reasons.
Austin Group Defect 1561 is applied, clarifying that environment variable values can contain byte sequences that do
not form valid characters.
A.8.2 Internationalization Variables
Utilities conforming to the Shell and Utilities volume of POSIX.1-2024 and written in standard C can access the
locale variables by issuing the following call:
setlocale(LC_ALL, "")
If this were omitted, the ISO C standard specifies that the C (or POSIX) locale would be used.
The DESCRIPTION of setlocale() requires that when setting all
categories of a locale, if the value of any of the environment variable searches yields a locale that is not supported (and
non-null), the setlocale() function returns a null pointer and the global locale
is unchanged.
For the standard utilities, if any of the environment variables are invalid, it makes sense to default to an
implementation-defined, consistent locale environment. It is more confusing for a user to have partial settings occur in case of a
mistake. All utilities would then behave in one language/cultural environment. Furthermore, it provides a way of forcing the whole
environment to be the implementation-defined default. Disastrous results could occur if a pipeline of utilities partially uses the
environment variables in different ways. In this case, it would be appropriate for utilities that use LANG and related
variables to exit with an error if any of the variables are invalid. For example, users typing individual commands at a terminal
might want date to work if LC_MONETARY is invalid as long as LC_TIME is
valid. Since these are conflicting reasonable alternatives, POSIX.1-2024 leaves the results unspecified if the locale environment
variables would not produce a complete locale matching the specification of the user.
The LC_MESSAGES variable affects the language of messages generated by the standard utilities.
The description of the environment variable names starting with the characters "LC_" acknowledges the fact that
the interfaces presented may be extended as new international functionality is required. In the ISO C standard, names preceded
by "LC_" are reserved in the name space for future categories.
To avoid name clashes, new categories and environment variables are divided into two classifications:
"implementation-independent" and "implementation-defined".
Implementation-independent names will have the following format:
LC_NAME
where NAME is the name of the new category and environment variable. Capital letters must be used for
implementation-independent names.
Implementation-defined names must be in lowercase letters, as below:
LC_name
Austin Group Defect 1122 is applied, adding the LANGUAGE , TEXTDOMAIN , and TEXTDOMAINDIR
environment variables and updating NLSPATH with requirements relating to the gettext family of functions and the
gettext and ngettext utilities.
Austin Group Defect 1477 is applied, moving a paragraph of rationale about incompatible locale categories to
A.7.1 General.
Austin Group Defect 1571 is applied, simplifying the final item in the precedence order for internationalization
environment variables.
A.8.3 Other Environment Variables
COLUMNS, LINES
The default values for the number of column positions when COLUMNS is unset or null, and screen height when
LINES is unset or null, are unspecified if the terminal window size cannot be obtained (from tcgetwinsize()) because historical implementations use different methods to determine
the values. Users should not need to set these variables in the environment unless there is a specific reason to override the
default behavior of the implementation, such as to display data in an area arbitrarily smaller than the terminal or window. Values
for these variables that are not decimal integers greater than zero are implicitly undefined values; it is unnecessary to enumerate
all of the possible values outside of the acceptable set.
Austin Group Defect 1185 is applied, changing the descriptions of the COLUMNS and LINES environment
variables.
LOGNAME
In most implementations, the value of such a variable is easily forged, so security-critical applications should
rely on other means of determining user identity. LOGNAME is required to be constructed from the portable filename character
set for reasons of interchange. No diagnostic condition is specified for violating this rule, and no requirement for enforcement
exists. The intent of the requirement is that if extended characters are used, the "guarantee" of portability implied by a
standard is void.
PATH
Many historical implementations of the Bourne shell do not interpret a trailing  to represent the
current working directory and are thus non-conforming. The C Shell and the KornShell conform to POSIX.1-2024 on this point. The
usual name of dot may also be used to refer to the current working directory.
Many implementations historically have used a default value of /bin and /usr/bin for the PATH
variable. POSIX.1-2024 does not mandate this default path be identical to that retrieved from getconf PATH because it
is likely that the standardized utilities may be provided in another directory separate from the directories used by some
historical applications.
The standard specifies that (when no  character is included in a command pathname) special built-in
utilities and intrinsic utilities are not subject to a search using PATH . All other standard utilities, even if implemented
as shell built-ins, are required to be found by searching PATH . This means that if a shell includes a built-in for a
standard utility that is not intrinsic, a user can write a utility that will override that built-in. The standard also requires
that all standard utilities can be executed by commands like:
find . -type d -exec printf 'Found directory: %s\n' '{}' +
So, other than differences caused by using different shell execution environments, a standard utility that is
implemented as a built-in and the non-built-in version of that standard utility are both required to behave as the standard
specifies. But, if a non-standard utility is found in PATH before the standard utility's location in PATH , the
non-standard utility must be invoked rather than the built-in. For instance, if the shell includes a built-in printf utility (which most shells do), PATH is initialized using:
PATH="$HOME/bin:$(command -p getconf PATH)"
and $HOME/bin/printf is an executable file containing:
command -p printf 'In %s with args:\n' "${0##*/}" >&2
command -p printf '     %s\n' "$@" >&2
command -V printf >&2
command -Vp printf >&2
command -p printf "$@"
then the command:
printf '%s %s\n' HOME "$HOME" PATH "$PATH"
should produce output similar to:
In printf with args:
%s %s\n
HOME
/Users/dwc
PATH
/Users/dwc/bin:/usr/bin:/bin:/usr/sbin:/sbin
printf is a tracked alias for /Users/dwc/bin/printf
printf is a shell builtin
HOME /Users/dwc
PATH /Users/dwc/bin:/usr/bin:/bin:/usr/sbin:/sbin
The current version of the Korn shell installs built-ins into the shell using a builtin utility that allows
the built-in to be associated with the pathname of the non-built-in version of that utility. (Unfortunately, some implementations
that use ksh93 as their standard sh utility do not make use of this feature and
install built-ins for standard utilities that are not associated with a PATH search. And, most other shells incorrectly
always use a built-in utility if one is installed, even when it should be overridden by a PATH search that should find the
non-standard version of a utility with the name of that built-in.) Some other shells use a  character in a
directory pathname in PATH to indicate one or more directories that should be used when processing PATH to determine
when non-intrinsic standard utilities should be found. The POSIX.1-2024 revision of the standard allows either of these methods to
be used to install built-ins that meet the requirements stated in XCU 2.9.1.4 Command Search and Execution by making the behavior of the
built-in path search implementation-defined when a  character is found in PATH .
Austin Group Defect 854 is applied, changing how PATH searching applies to built-in utilities.
Austin Group Defect 1340 is applied, clarifying the description of PATH .
SHELL
The SHELL variable names the preferred shell of the user; it is a guide to applications. There is no direct
requirement that that shell conform to POSIX.1-2024; that decision should rest with the user. It is the intention of the standard
developers that alternative shells be permitted, if the user chooses to develop or acquire one. An operating system that builds its
shell into the "kernel" in such a manner that alternative shells would be impossible does not conform to the spirit of
POSIX.1-2024.
TZ
The quoted form of the timezone variable allows timezone names of the form UTC+1 (or any name that contains the
('+'), the  ('-'), or digits), which may be appropriate for countries that
do not have an official timezone name. It would be coded as +1, which would cause std to have a
value of UTC+1 and dst a value of UTC+2, each with a length of 5 characters. This does not appear to conflict with any
existing usage. The characters '' were chosen for quoting because they are easier to parse
visually than a quoting character that does not provide some sense of bracketing (and in a string like this, such bracketing is
helpful). They were also chosen because they do not need special treatment when assigning to the TZ variable. Users are
often confused by embedding quotes in a string. Because '' are meaningful to the shell, the whole
string would have to be quoted, but that is easily explained. (Parentheses would have presented the same problems.) Although the
'>' symbol could have been permitted in the string by either escaping it or doubling it, it seemed of little value to
require that. This could be provided as an extension if there was a need. Timezone names of this new form lead to a requirement
that the value of {_POSIX_TZNAME_MAX} change from 3 to 6.
Since the TZ environment variable is usually inherited by all applications started by a user after the value
of the TZ environment variable is changed and since many applications run using the C or POSIX locale, using characters that
are not in the portable character set in the std and dst fields could cause unexpected results.
Implementations are encouraged to incorporate the IANA timezone database into the timezone database used for
TZ values specifying geographical and special timezones, and to provide a method to allow it to be updated in accordance
with RFC 6557.
The TZ format beginning with  was originally introduced as a way for implementations to support
geographical timezones in the form :Area/Location as an extension, but implementations started to support
them without the leading  (as well as with it) and their use without the  became the de-facto standard.
Consequently when geographical timezones were added to this standard, it was without the .
The format of the TZ environment variable is changed in Issue 6 to allow for the quoted form, as defined in
earlier versions of the ISO POSIX-1 standard.
IEEE Std 1003.1-2001/Cor 1-2002, item XBD/TC1/D6/7 is applied, adding the ctime_r() and
localtime_r() functions to the list of functions that use the TZ
environment variable.
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0041 [584] is applied.
Austin Group Defect 1030 is applied, making it implementation-defined when the changes to and from Daylight Saving
Time occur if the dst field is specified in TZ and the rule field is not.
Austin Group Defect 1252 is applied, changing the time field to allow the hour to range from zero to 167 and
allowing a leading sign.
Austin Group Defect 1253 is applied, changing "alternative time" to "Daylight Saving Time".
Austin Group Defect 1410 is applied, removing the ctime_r() function.
Austin Group Defect 1619 is applied, adding support for a third TZ format with values specifying
geographical and special timezones.
Austin Group Defects 1638 and 1639 are applied, clarifying the length limits for the std and dst
fields of TZ .
A.9 Regular Expressions
Rather than repeating the description of REs for each utility supporting REs, the standard developers preferred a
common, comprehensive description of regular expressions in one place. The most common behavior is described here, and exceptions
or extensions to this are documented for the respective utilities, as appropriate.
The BRE corresponds to the ed or historical grep type, and the ERE corresponds to the historical egrep type (now grep -E).
The text is based on the ed description and substantially modified,
primarily to aid developers and others in the understanding of the capabilities and limitations of REs. Much of this was influenced
by internationalization requirements.
It should be noted that the definitions in this section do not cover the tr utility; the tr syntax does not employ REs.
The specification of REs is particularly important to internationalization because pattern matching operations are
very basic operations in business and other operations. The syntax and rules of REs are intended to be as intuitive as possible to
make them easy to understand and use. The historical rules and behavior do not provide that capability to non-English language
users, and do not provide the necessary support for commonly used characters and language constructs. It was necessary to provide
extensions to the historical RE syntax and rules to accommodate other languages.
As they are limited to bracket expressions, the rationale for these modifications is in XBD 9.3.5 RE Bracket Expression.
A.9.1 Regular Expression Definitions
It is possible to determine what strings correspond to subexpressions by recursively applying the leftmost longest
rule to each subexpression, but only with the proviso that the overall match is leftmost longest. For example, matching
"\(ac*\)c*d[ac]*\1" against acdacaaa matches acdacaaa (with \1=a); simply matching the longest match
for "\(ac*\)" would yield \1=ac, but the overall match would be smaller (acdac). Conceptually, the
implementation must examine every possible match and among those that yield the leftmost longest total matches, pick the one that
does the longest match for the leftmost subexpression, and so on. Note that this means that matching by subexpressions is
context-dependent: a subexpression within a larger RE may match a different string from the one it would match as an independent
RE, and two instances of the same subexpression within the same larger RE may match different lengths even in similar sequences of
characters. For example, in the ERE "(a.*b)(a.*b)", the two identical subexpressions would match four and six characters,
respectively, of accbaccccb.
The definition of single character has been expanded to include also collating elements consisting of two or more
characters; this expansion is applicable only when a bracket expression is included in the BRE or ERE. An example of such a
collating element may be the Dutch ij, which collates as a 'y'. In some encodings, a ligature "i with j" exists
as a character and would represent a single-character collating element. In another encoding, no such ligature exists, and the
two-character sequence ij is defined as a multi-character collating element. Outside brackets, the ij is treated as a
two-character RE and matches the same characters in a string. Historically, a bracket expression only matched a single character.
The ISO POSIX-2:1993 standard required bracket expressions like "[^[:lower:]]" to match multi-character collating
elements such as "ij". However, this requirement led to behavior that many users did not expect and that could not
feasibly be mimicked in user code, and it was rarely if ever implemented correctly. The current standard leaves it unspecified
whether a bracket expression matches a multi-character collating element, allowing both historical and ISO POSIX-2:1993
standard implementations to conform.
Also, in the current standard, it is unspecified whether character class expressions like "[:lower:]" can
include multi-character collating elements like "ij"; hence "[[:lower:]]" can match "ij", and
"[^[:lower:]]" can fail to match "ij". Common practice is for a character class expression to match a collating
element if it matches the collating element's first character.
Austin Group Defect 1329 is applied, adding a definition of "leftmost" and updating the definition of "matched"
to include an example ERE using the repetition modifier '?'.
Austin Group Defect 1546 is applied, adding a definition of "escape sequence".
A.9.2 Regular Expression General Requirements
The definition of which sequence is matched when several are possible is based on the leftmost-longest rule
historically used by deterministic recognizers. This rule is easier to define and describe, and arguably more useful, than the
first-match rule historically used by non-deterministic recognizers. It is thought that dependencies on the choice of rule are
rare; carefully contrived examples are needed to demonstrate the difference.
A formal expression of the leftmost-longest rule is:
The search is performed as if all possible suffixes of the string were tested for a prefix matching the pattern; the
longest suffix containing a matching prefix is chosen, and the longest possible matching prefix of the chosen suffix is identified
as the matching sequence.
EREs can optionally use a leftmost-shortest rule for repetitions (enabled via the REG_MINIMAL flag or the
'?' repetition modifier), in which case the shortest possible matching prefix is instead identified as the matching
sequence for the affected repetition(s).
Historically, most RE implementations only match lines, not strings. However, that is more an effect of the usage
than of an inherent feature of REs themselves. Consequently, POSIX.1-2024 does not regard  characters as special;
they are ordinary characters, and both a  and a non-matching list can match them. Those utilities (like grep) that do not allow  characters to match are responsible for eliminating any
from strings before matching against the RE. The regcomp() function,
however, can provide support for such processing without violating the rules of this section.
Some implementations of egrep have had very limited flexibility in handling complex EREs. POSIX.1-2024 does
not attempt to define the complexity of a BRE or ERE, but does place a lower limit on it—any RE must be handled, as long as it can
be expressed in 256 bytes or less. (Of course, this does not place an upper limit on the implementation.) There are historical
programs using a non-deterministic-recognizer implementation that should have no difficulty with this limit. It is possible that a
good approach would be to attempt to use the faster, but more limited, deterministic recognizer for simple expressions and to fall
back on the non-deterministic recognizer for those expressions requiring it. Non-deterministic implementations must be careful to
observe the rules on which match is chosen; the longest match, not the first match, starting at a given character is used.
The term "invalid" highlights a difference between this section and some others: POSIX.1-2024 frequently avoids
mandating of errors for syntax violations because they can be used by implementors to trigger extensions. However, the authors of
the internationalization features of REs wanted to mandate errors for certain conditions to identify usage problems or non-portable
constructs. These are identified within this rationale as appropriate. The remaining syntax violations have been left implicitly or
explicitly undefined. For example, the BRE construct "\{1,2,3\}" does not comply with the grammar. A conforming
application cannot rely on it producing an error nor matching the literal characters "\{1,2,3\}".
The term "undefined" was used in favor of "unspecified" because many of the situations are considered errors on
some implementations, and the standard developers considered that consistency throughout the section was preferable to mixing
undefined and unspecified.
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0042 [554] is applied.
Austin Group Defect 1031 is applied, replacing text relating to case insensitive comparisons with a reference to
XBD 4.1 Case Insensitive Comparisons.
A.9.3 Basic Regular Expressions
Austin Group Defect 1139 is applied, making minor editorial changes to several subsections of this section and
changing them to require that, when not inside a bracket expression, "\]" matches ']'.
A.9.3.1 BREs Matching a Single Character or Collating
Element
There is no additional rationale provided for this section.
A.9.3.2 BRE Ordinary Characters
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0043 [554] is applied.
Austin Group Defect 1546 is applied, adding optional support for "\?", "\+", and
"\|".
A.9.3.3 BRE Special Characters
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0043 [554] is applied.
Austin Group Defect 1546 is applied, adding optional support for "\?", "\+", and
"\|".
A.9.3.4 Periods in BREs
There is no additional rationale provided for this section.
A.9.3.5 RE Bracket Expression
Range expressions are, historically, an integral part of REs. However, the requirements of "natural language
behavior" and portability do conflict. In the POSIX locale, ranges must be treated according to the collating sequence and include
such characters that fall within the range based on that collating sequence, regardless of character values. In other locales,
ranges have unspecified behavior.
Some historical implementations allow range expressions where the ending range point of one range is also the
starting point of the next (for instance, "[a-m-o]"). This behavior should not be permitted, but to avoid breaking
historical implementations, it is now undefined whether it is a valid expression and how it should be interpreted.
Current practice in awk and lex is to accept escape sequences in bracket expressions as per XBD Escape Sequences and Associated Actions, while the normal ERE behavior is to
regard such a sequence as consisting of two characters. Allowing the awk/lex behavior in EREs would change the normal behavior in an unacceptable way; it is expected
that awk and lex will decode escape sequences
in EREs before passing them to regcomp() or comparable routines. Each utility
describes the escape sequences it accepts as an exception to the rules in this section; the list is not the same, for historical
reasons.
As noted previously, the new syntax and rules have been added to accommodate other languages than English. The
remainder of this section describes the rationale for these modifications.
In the POSIX locale, a regular expression that starts with a range expression matches a set of strings that are
contiguously sorted, but this is not necessarily true in other locales. For example, a French locale might have the following
behavior:
$ ls
alpha   Alpha   estimé   ESTIMÉ   été   eurêka
$ ls [a-e]*
alpha   Alpha   estimé  eurêka
Such disagreements between matching and contiguous sorting are unavoidable because POSIX sorting cannot be
implemented in terms of a deterministic finite-state automaton (DFA), but range expressions by design are implementable in terms of
DFAs.
Historical implementations used native character order to interpret range expressions. The ISO POSIX-2:1993
standard instead required collating element order (CEO): the order that collating elements were specified between the
order_start and order_end keywords in the LC_COLLATE category of the current locale. CEO had some advantages
in portability over the native character order, but it also had some disadvantages:
CEO could not feasibly be mimicked in user code, leading to inconsistencies between POSIX matchers and matchers in
popular user programs like Emacs, ksh, and Perl.
CEO caused range expressions to match accented and capitalized letters contrary to many users' expectations. For
example, "[a-e]" typically matched both 'E' and 'á' but neither 'A' nor 'é'.
CEO was not consistent across implementations. In practice, CEO was often less portable than native character
order. For example, it was common for the CEOs of two implementation-supplied locales to disagree, even if both locales were named
"da_DK".
Because of these problems, some implementations of regular expressions continued to use native character order.
Others used the collation sequence, which is more consistent with sorting than either CEO or native order, but which departs
further from the traditional POSIX semantics because it generally requires "[a-e]" to match either 'A' or
'E' but not both. As a result of this kind of implementation variation, programmers who wanted to write portable regular
expressions could not rely on the ISO POSIX-2:1993 standard guarantees in practice.
While revising the standard, lengthy consideration was given to proposals to attack this problem by adding an API
for querying the CEO to allow user-mode matchers, but none of these proposals had implementation experience and none achieved
consensus. Leaving the standard alone was also considered, but rejected due to the problems described above.
The current standard leaves unspecified the behavior of a range expression outside the POSIX locale. This makes it
clearer that conforming applications should avoid range expressions outside the POSIX locale, and it allows implementations and
compatible user-mode matchers to interpret range expressions using native order, CEO, collation sequence, or other, more advanced
techniques. The concerns which led to this change were raised in IEEE PASC interpretation 1003.2 #43 and others, and related to
ambiguities in the specification of how multi-character collating elements should be handled in range expressions. These
ambiguities had led to multiple interpretations of the specification, in conflicting ways, which led to varying implementations. As
noted above, efforts were made to resolve the differences, but no solution has been found that would be specific enough to allow
for portable software while not invalidating existing implementations.
The standard developers recognize that collating elements are important, such elements being common in several
European languages; for example, 'ch' or 'll' in traditional Spanish; 'aa' in several Scandinavian
languages. Existing internationalized implementations have processed, and continue to process, these elements in range expressions.
Efforts are expected to continue in the future to find a way to define the behavior of these elements precisely and portably.
The ISO POSIX-2:1993 standard required "[b-a]" to be an invalid expression in the POSIX locale, but
this requirement has been relaxed in this version of the standard so that "[b-a]" can instead be treated as a valid
expression that does not match any string.
The standard specifies three possible behaviors for regular expressions such as "[:alpha:]". One behavior
is the traditional implementation, which behaves like "[:ahlp]". Another, for alignment with the tr utility, is to treat it like "[[:alpha:]]". And finally, the standard allows
rejecting the regular expression as invalid, as a means of alerting a user to the non-portable aspect of that regular expression.
The set of regular expressions with this undefined behavior is limited solely to the expressions where the outer '[' and
']' of the bracket expression can be confused with the missing bracket pair '[' and ']' necessary to
form a collating symbol, equivalence class, or character class; thus "[_:alpha:]" or "[::]" do not trigger the
unspecified behavior.
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0044 [938], XBD/TC2-2008/0045 [872], XBD/TC2-2008/0046 [938],
XBD/TC2-2008/0047 [584], and XBD/TC2-2008/0048 [584] are applied.
Austin Group Defect 948 is applied, requiring that an ordinary character in a matching list only matches that
character.
Austin Group Defect 1190 is applied, clarifying which characters lose their special meaning inside a bracket
expression.
Austin Group Defect 1288 is applied, changing "rejected as an error" to "treated as an invalid bracket
expression".
A.9.3.6 BREs Matching Multiple Characters
The limit of nine back-references to subexpressions in the RE is based on the use of a single-digit identifier;
increasing this to multiple digits would break historical applications. This does not imply that only nine subexpressions are
allowed in REs. The following is a valid BRE with ten subexpressions:
\(\(\(ab\)*c\)*d\)\(ef\)*\(gh\)\{2\}\(ij\)*\(kl\)*\(mn\)*\(op\)*\(qr\)*
The standard developers regarded the common historical behavior, which supported "\n*", but not
"\n\{min,max\}", "\(...\)*", or "\(...\)\{min,max\}", as a non-intentional result of a specific
implementation, and they supported both duplication and interval expressions following subexpressions and back-references.
The changes to the processing of the back-reference expression remove an unspecified or ambiguous behavior in the
Shell and Utilities volume of POSIX.1-2024, aligning it with the requirements specified for the regcomp() expression, and is the result of PASC Interpretation 1003.2-92 #43 submitted for
the ISO POSIX-2:1993 standard.
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0049 [595] is applied.
A.9.3.7 BRE Precedence
There is no additional rationale provided for this section.
A.9.3.8 BRE Expression Anchoring
Often, the  is viewed as matching the ending  in text files. This is not strictly
true; the  is typically eliminated from the strings to be matched, and the  matches the
terminating null character.
The ability of '^', '$', and '*' to be non-special in certain circumstances may be
confusing to some programmers, but this situation was changed only in a minor way from historical practice to avoid breaking many
historical scripts. Some consideration was given to making the use of the anchoring characters undefined if not escaped and not at
the beginning or end of strings. This would cause a number of historical BREs, such as "2^10", "$HOME", and
"$1.35", that relied on the characters being treated literally, to become invalid.
However, one relatively uncommon case was changed to allow an extension used on some implementations. Historically,
the BREs "^foo" and "\(^foo\)" did not match the same string, despite the general rule that subexpressions and
entire BREs match the same strings. To increase consensus, POSIX.1-2024 has allowed an extension on some implementations to treat
these two cases in the same way by declaring that anchoring may occur at the beginning or end of a subexpression. Therefore,
portable BREs that require a literal  at the beginning or a  at the end of a subexpression
must escape them. Note that a BRE such as "a\(^bc\)" will either match "a^bc" or nothing on different systems
under the rules.
ERE anchoring has been different from BRE anchoring in all historical systems. An unescaped anchor character has
never matched its literal counterpart outside a bracket expression. Some implementations treated "foo$bar" as a valid
expression that never matched anything; others treated it as invalid. POSIX.1-2024 mandates the former, valid unmatched
behavior.
Some implementations have extended the BRE syntax to add alternation. For example, the subexpression
"\(foo$\|bar\)" would match either "foo" at the end of the string or "bar" anywhere. The extension is
triggered by the use of the undefined "\|" sequence. Because the BRE is undefined for portable scripts, the extending
system is free to make other assumptions, such that the '$' represents the end-of-line anchor in the middle of a
subexpression. If it were not for the extension, the '$' would match a literal  under the rules.
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0049 [595] is applied.
Austin Group Defect 1546 is applied, adding optional support for "\?", "\+", and
"\|".
Austin Group Defect 1579 is applied, eliminating an inconsistency between the list items relating to
and .
A.9.4 Extended Regular Expressions
As with BREs, the standard developers decided to make the interpretation of escaped ordinary characters
undefined.
The  is not listed as an ERE special character because it is only special in the context
of a preceding . If found without a preceding , the  has
no special meaning.
The interval expression, "{m,n}", has been added to EREs. Historically, the interval expression has only
been supported in some ERE implementations. The standard developers estimated that the addition of interval expressions to EREs
would not decrease consensus and would also make BREs more of a subset of EREs than in many historical implementations.
It was suggested that, in addition to interval expressions, back-references ('\n') should also be added to
EREs. This was rejected by the standard developers as likely to decrease consensus.
In historical implementations, multiple duplication symbols are usually interpreted from left to right and treated
as additive. As an example, "a+*b" matches zero or more instances of 'a' followed by a 'b'. In
POSIX.1-2024, multiple duplication symbols are undefined; that is, they cannot be relied upon for conforming applications. One
reason for this is to provide some scope for future enhancements.
The precedence of operations differs between EREs and those in lex; in
lex, for historical reasons, interval expressions have a lower precedence than
concatenation.
Austin Group Defect 1139 is applied, making minor editorial changes to several subsections of this section and
changing them to require that, when not inside a bracket expression, "\]" matches ']' and "\}" matches
'}'.
A.9.4.1 EREs Matching a Single Character or Collating
Element
There is no additional rationale provided for this section.
A.9.4.2 ERE Ordinary Characters
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0050 [554] is applied.
A.9.4.3 ERE Special Characters
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0050 [554] is applied.
A.9.4.4 Periods in EREs
There is no additional rationale provided for this section.
A.9.4.5 ERE Bracket Expression
There is no additional rationale provided for this section.
A.9.4.6 EREs Matching Multiple Characters
Austin Group Defects 793 and 1329 are applied, adding the repetition modifier '?' and the REG_MINIMAL
flag.
A.9.4.7 ERE Alternation
There is no additional rationale provided for this section.
A.9.4.8 ERE Precedence
There is no additional rationale provided for this section.
A.9.4.9 ERE Expression Anchoring
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0051 [595] is applied.
A.9.5 Regular Expression Grammar
The grammars are intended to represent the range of acceptable syntaxes available to conforming applications. There
are instances in the text where undefined constructs are described; as explained previously, these allow implementation extensions.
There is no intended requirement that an implementation extension must somehow fit into the grammars shown here.
The BRE grammar does not permit L_ANCHOR or R_ANCHOR inside "\(" and "\)" (which implies that
'^' and '$' are ordinary characters). This reflects the semantic limits on the application, as noted in XBD
9.3.8 BRE Expression Anchoring. Implementations are permitted to
extend the language to interpret '^' and '$' as anchors in these locations, and as such, conforming applications
cannot use unescaped '^' and '$' in positions inside "\(" and "\)" that might be interpreted as
anchors.
The ERE grammar does not permit several constructs that XBD 9.4.2 ERE Ordinary Characters and 9.4.3 ERE Special Characters specify as having undefined results:
ORD_CHAR preceded by
ERE_dupl_symbol(s) appearing first in an ERE, or immediately following '|', '^', or
'('
'{' not part of a valid ERE_dupl_symbol
'|' appearing first or last in an ERE, or immediately following '|' or '(', or
immediately preceding ')'
Implementations are permitted to extend the language to allow these. Conforming applications cannot use such
constructs.
A.9.5.1 BRE/ERE Grammar Lexical Conventions
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0052 [554] is applied.
Austin Group Defect 1139 is applied, updating QUOTED_CHAR to add \] to the BRE list and add
\] and \} to the ERE list, and changing "outside bracket expressions" to "except inside bracket
expressions".
Austin Group Defect 1546 is applied, adding optional support for \?, \+, and \| in
BREs.
A.9.5.2 RE and Bracket Expression Grammar
The removal of the Back_open_paren Back_close_paren option from the nondupl_RE specification
is the result of PASC Interpretation 1003.2-92 #43 submitted for the ISO POSIX-2:1993 standard. Although the grammar required
support for null subexpressions, this section does not describe the meaning of, and historical practice did not support, this
construct.
Austin Group Defect 1546 is applied, adding optional support for \?, \+, and \| in
BREs.
A.9.5.3 ERE Grammar
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0052 [554] and XBD/TC2-2008/0053 [916] are applied.
A.10 Directory Structure and Devices
A.10.1 Directory Structure and Files
A description of the historical /usr/tmp was omitted, removing any concept of differences in emphasis
between the / and /usr directories. The descriptions of /bin, /usr/bin, /lib, and
/usr/lib were omitted because they are not useful for applications. In an early draft, a distinction was made between system
and application directory usage, but this was not found to be useful.
The directories / and /dev are included because the notion of a hierarchical directory structure is
key to other information presented elsewhere in POSIX.1-2024. In early drafts, it was argued that special devices and temporary
files could conceivably be handled without a directory structure on some implementations. For example, the system could treat the
characters "/tmp" as a special token that would store files using some non-POSIX file system structure. This notion was
rejected by the standard developers, who required that all the files in this section be implemented via POSIX file systems.
The /tmp directory is retained in POSIX.1-2024 to accommodate historical applications that assume its
availability. Implementations are encouraged to provide suitable directory names in the environment variable TMPDIR and
applications are encouraged to use the contents of TMPDIR for creating temporary files.
The standard files /dev/null and /dev/tty are required to be both readable and writable to allow
applications to have the intended historical access to these files.
The standard file /dev/console has been added for alignment with the Single UNIX Specification.
A.10.2 Output Devices and Terminal Types
IEEE Std 1003.1-2001/Cor 2-2004, item XBD/TC2/D6/17 is applied, making it clear that the
requirements for documenting terminal support are in the system documentation.
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0054 [967] is applied.
A.11 General Terminal Interface
If the implementation does not support this interface on any device types, it should behave as if it were being
used on a device that is not a terminal device (in most cases errno will be set to [ENOTTY] on return from functions defined
by this interface). This is based on the fact that many applications are written to run both interactively and in some
non-interactive mode, and they adapt themselves at runtime. Requiring that they all be modified to test an environment variable to
determine whether they should try to adapt is unnecessary. On a system that provides no general terminal interface, providing all
the entry points as stubs that return [ENOTTY] (or an equivalent, as appropriate) has the same effect and requires no changes to
the application.
Although the needs of both interface implementors and application developers were addressed throughout
POSIX.1-2024, this section pays more attention to the needs of the latter. This is because, while many aspects of the programming
interface can be hidden from the user by the application developer, the terminal interface is usually a large part of the user
interface. Although to some extent the application developer can build missing features or work around inappropriate ones, the
difficulties of doing that are greater in the terminal interface than elsewhere. For example, efficiency prohibits the average
program from interpreting every character passing through it in order to simulate character erase, line kill, and so on. These
functions should usually be done by the operating system, possibly at the interrupt level.
The tc*() functions were introduced as a way of avoiding the problems inherent in the traditional
ioctl() function and in variants of it that were proposed. For example, tcsetattr() is specified in place of the use of the TCSETA ioctl() command
function. This allows specification of all the arguments in a manner consistent with the ISO C standard unlike the varying
third argument of ioctl(), which is sometimes a pointer (to any of many different types) and sometimes an int.
The advantages of this new method include:
It allows strict type checking.
The direction of transfer of control data is explicit.
Portable capabilities are clearly identified.
The need for a general interface routine is avoided.
Size of the argument is well-defined (there is only one type).
The disadvantages include:
No historical implementation used the new method.
There are many small routines instead of one general-purpose one.
The historical parallel with fcntl() is broken.
The issue of modem control was excluded from POSIX.1-2024 on the grounds that:
It was concerned with setting and control of hardware timers.
The appropriate timers and settings vary widely internationally.
Feedback from European computer manufacturers indicated that this facility was not consistent with European needs
and that specification of such a facility was not a requirement for portability.
A.11.1 Interface Characteristics
A.11.1.1 Opening a Terminal Device File
The O_TTY_INIT flag for open() has been added to POSIX.1-2024 to solve
a problem encountered by applications written for earlier versions of this standard which need to open a modem or similar device
and initialize all of the parameter settings. Using the tcgetattr()-modify-tcsetattr() method
mandated by the standard could result in non-conforming behavior if the device had previously been used with non-conforming
parameter settings, on implementations which do not reset the parameter settings in between the last close of the device by one
application and the first open by another application. To avoid this problem, some application developers were resorting to using
memset() to zero the termios structure before setting all of the standard
parameters, but this risks non-conforming behavior on systems where some non-standard parameter needs a non-zero value in order for
the terminal to behave in a conforming manner.
On systems which do reset the parameter settings to defaults between uses of a terminal device, it is expected that
either O_TTY_INIT will have the value zero or open(ttypath, O_RDWR|O_TTY_INIT) will do nothing additional.
The standard developers considered an alternative solution of a special fildes argument for the tcgetattr() call to obtain default parameters. However, this would not be adequate if a
system supports several different types of terminal device and the default settings need to differ between the different types.
With the O_TTY_INIT open flag, the implementor can determine which device type is being opened.
The standard developers also considered a special POSIX_TTY_INIT value for the termios structure used in
tcsetattr(), which would reset the values if used immediately after an open() call. However, it was felt that this would lead to confusion amongst application
developers who wanted to reset the parameters at other points, and implementations might diverge.
Austin Group Defect 1466 is applied, changing the terminology used for pseudo-terminal devices.
A.11.1.2 Process Groups
There is a potential race when the members of the foreground process group on a terminal leave that process group,
either by exit or by changing process groups. After the last process exits the process group, but before the foreground process
group ID of the terminal is changed (usually by a job control shell), it would be possible for a new process to be created with its
process ID equal to the terminal's foreground process group ID. That process might then become the process group leader and
accidentally be placed into the foreground on a terminal that was not necessarily its controlling terminal. As a result of this
problem, the controlling terminal is defined to not have a foreground process group during this time.
The cases where a controlling terminal has no foreground process group occur when all processes in the foreground
process group either terminate and are waited for or join other process groups via setpgid() or setsid(). If the process group
leader terminates, this is the first case described; if it leaves the process group via setpgid(), this is the second case described (a process group leader cannot successfully
call setsid()). When one of those cases causes a controlling terminal to have no
foreground process group, it has two visible effects on applications. The first is the value returned by tcgetpgrp(). The second (which occurs only in the case where the process group leader
terminates) is the sending of signals in response to special input characters. The intent of POSIX.1-2024 is that no process group
be wrongly identified as the foreground process group by tcgetpgrp() or
unintentionally receive signals because of placement into the foreground.
In 4.3 BSD, the old process group ID continues to be used to identify the foreground process group and is returned
by the function equivalent to tcgetpgrp(). In that implementation it is possible
for a newly created process to be assigned the same value as a process ID and then form a new process group with the same value as
a process group ID. The result is that the new process group would receive signals from this terminal for no apparent reason, and
POSIX.1-2024 precludes this by forbidding a process group from entering the foreground in this way. It would be more direct to
place part of the requirement made by the last sentence under fork(), but there is no
convenient way for that section to refer to the value that tcgetpgrp() returns,
since in this case there is no process group and thus no process group ID.
One possibility for a conforming implementation is to behave similarly to 4.3 BSD, but to prevent this reuse of the
ID, probably in the implementation of fork(), as long as it is in use by the
terminal.
Another possibility is to recognize when the last process stops using the terminal's foreground process group ID,
which is when the process group lifetime ends, and to change the terminal's foreground process group ID to a reserved value that is
never used as a process ID or process group ID. (See the definition of process group lifetime in the definitions section.)
The process ID can then be reserved until the terminal has another foreground process group.
The 4.3 BSD implementation permits the leader (and only member) of the foreground process group to leave the
process group by calling the equivalent of setpgid() and to later return, expecting
to return to the foreground. There are no known application needs for this behavior, and POSIX.1-2024 neither requires nor forbids
it (except that it is forbidden for session leaders) by leaving it unspecified.
A.11.1.3 The Controlling Terminal
POSIX.1-2024 does not specify a mechanism by which to allocate a controlling terminal. This is normally done by a
system utility (such as getty) and is considered an administrative feature outside the scope of POSIX.1-2024.
Historical implementations allocate controlling terminals on certain open() calls. Since open() is part of POSIX.1, its
behavior had to be dealt with. The traditional behavior is not required because it is not very straightforward or flexible for
either implementations or applications. However, because of its prevalence, it was not practical to disallow this behavior either.
Thus, a mechanism was standardized to ensure portable, predictable behavior in open().
Some historical implementations deallocate a controlling terminal on the last system-wide close. This behavior in
neither required nor prohibited. Even on implementations that do provide this behavior, applications generally cannot depend on it
due to its system-wide nature.
A.11.1.4 Terminal Access Control
The access controls described in this section apply only to a process that is accessing its controlling terminal. A
process accessing a terminal that is not its controlling terminal is effectively treated the same as a member of the foreground
process group. While this may seem unintuitive, note that these controls are for the purpose of job control, not security, and job
control relates only to the controlling terminal of a process. Normal file access permissions handle security.
If the process calling read() or write() is in a background process group that is orphaned, it is not desirable to stop the
process group, as it is no longer under the control of a job control shell that could put it into the foreground again.
Accordingly, calls to read() or write()
functions by such processes receive an immediate error return. This is different from 4.2 BSD, which kills orphaned processes that
receive terminal stop signals.
The foreground/background/orphaned process group check performed by the terminal driver must be repeatedly
performed until the calling process moves into the foreground or until the process group of the calling process becomes orphaned.
That is, when the terminal driver determines that the calling process is in the background and should receive a job control signal,
it sends the appropriate signal (SIGTTIN or SIGTTOU) to every process in the process group of the calling process and then it
allows the calling process to immediately receive the signal. The latter is typically performed by blocking the process so that the
signal is immediately noticed. Note, however, that after the process finishes receiving the signal and control is returned to the
driver, the terminal driver must re-execute the foreground/background/orphaned process group check. The process may still be in the
background, either because it was continued in the background by a job control shell, or because it caught the signal and did
nothing.
The terminal driver repeatedly performs the foreground/background/orphaned process group checks whenever a process
is about to access the terminal. In the case of write() or the control tc*()
functions, the check is performed at the entry of the function. In the case of read(),
the check is performed not only at the entry of the function, but also after blocking the process to wait for input characters (if
necessary). That is, once the driver has determined that the process calling the read()
function is in the foreground, it attempts to retrieve characters from the input queue. If the queue is empty, it blocks the
process waiting for characters. When characters are available and control is returned to the driver, the terminal driver must
return to the repeated foreground/background/orphaned process group check again. The process may have moved from the foreground to
the background while it was blocked waiting for input characters.
Austin Group Defect 1151 is applied, adding tcsetwinsize().
A.11.1.5 Input Processing and Reading Data
There is no additional rationale provided for this section.
A.11.1.6 Canonical Mode Input Processing
The term "character" is intended here. ERASE should erase the last character, not the last byte. In the case of
multi-byte characters, these two may be different.
4.3 BSD has a WERASE character that erases the last "word" typed (but not any preceding  or
characters). A word is defined as a sequence of non- characters, with  characters counted as
characters. Like ERASE, WERASE does not erase beyond the beginning of the line. This WERASE feature has not been
specified in POSIX.1 because it is difficult to define in the international environment. It is only useful for languages where
words are delimited by  characters. In some ideographic languages, such as Japanese and Chinese, words are not
delimited at all. The WERASE character should presumably go back to the beginning of a sentence in those cases; practically, this
means it would not be used much for those languages.
It should be noted that there is a possible inherent deadlock if the application and implementation conflict on the
value of {MAX_CANON}. With ICANON set (if IXOFF is enabled) and more than {MAX_CANON} characters transmitted without a
, transmission will be stopped, the  (or  when ICRLF is set) will never
arrive, and the read() will never be satisfied.
An application should not set IXOFF if it is using canonical mode unless it knows that (even in the face of a
transmission error) the conditions described previously cannot be met or unless it is prepared to deal with the possible deadlock
in some other way, such as timeouts.
It should also be noted that this can be made to happen in non-canonical mode if the trigger value for sending
IXOFF is less than VMIN and VTIME is zero.
A.11.1.7 Non-Canonical Mode Input Processing
Some points to note about MIN and TIME:
The interactions of MIN and TIME are not symmetric. For example, when MIN>0 and TIME=0, TIME has no effect.
However, in the opposite case where MIN=0 and TIME>0, both MIN and TIME play a role in that MIN is satisfied with the receipt of
a single character.
Also note that in case A (MIN>0, TIME>0), TIME represents an inter-character timer, while in case C (MIN=0,
TIME>0), TIME represents a read timer.
These two points highlight the dual purpose of the MIN/TIME feature. Cases A and B, where MIN>0, exist to handle
burst-mode activity (for example, file transfer programs) where a program would like to process at least MIN characters at a time.
In case A, the inter-character timer is activated by a user as a safety measure; in case B, it is turned off.
Cases C and D exist to handle single-character timed transfers. These cases are readily adaptable to screen-based
applications that need to know if a character is present in the input queue before refreshing the screen. In case C, the read is
timed; in case D, it is not.
Another important note is that MIN is always just a minimum. It does not denote a record length. That is, if a
program does a read of 20 bytes, MIN is 10, and 25 characters are present, 20 characters are returned to the user. In the special
case of MIN=0, this still applies: if more than one character is available, they all will be returned immediately.
A.11.1.8 Writing Data and Output Processing
There is no additional rationale provided for this section.
A.11.1.9 Special Characters
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0055 [745] is applied.
A.11.1.10 Modem Disconnect
There is no additional rationale provided for this section.
A.11.1.11 Closing a Terminal Device File
POSIX.1-2024 does not specify that a close() on a terminal device file
include the equivalent of a call to tcflow(fd,TCOON).
An implementation that discards output at the time close() is called
after reporting the return value to the write() call that data was written does not
conform with POSIX.1-2024. An application has functions such as tcdrain(), tcflush(), and tcflow() available to obtain
the detailed behavior it requires with respect to flushing of output.
At the time of the last close on a terminal device, an application relinquishes any ability to exert flow control
via tcflow().
A.11.2 Parameters that Can be Set
A.11.2.1 The termios Structure
This structure is part of an interface that, in general, retains the historic grouping of flags. Although a more
optimal structure for implementations may be possible, the degree of change to applications would be significantly larger.
A.11.2.2 Input Modes
Some historical implementations treated a long break as multiple events, as many as one per character time. The
wording in POSIX.1 explicitly prohibits this.
Although the ISTRIP flag is normally superfluous with today's terminal hardware and software, it is historically
supported. Therefore, applications may be using ISTRIP, and there is no technical problem with supporting this flag. Also,
applications may wish to receive only 7-bit input bytes and may not be connected directly to the hardware terminal device (for
example, when a connection traverses a network).
Also, there is no requirement in general that the terminal device ensures that high-order bits beyond the specified
character size are cleared. ISTRIP provides this function for 7-bit characters, which are common.
In dealing with multi-byte characters, the consequences of a parity error in such a character, or in an escape
sequence affecting the current character set, are beyond the scope of POSIX.1 and are best dealt with by the application processing
the multi-byte characters.
A.11.2.3 Output Modes
POSIX.1 does not describe post-processing of output to a terminal or detailed control of that from a conforming
application. (That is, translation of  to  followed by  or
processing.) There is nothing that a conforming application should do to its output for a terminal because that would require
knowledge of the operation of the terminal. It is the responsibility of the operating system to provide post-processing appropriate
to the output device, whether it is a terminal or some other type of device.
Extensions to POSIX.1 to control the type of post-processing already exist and are expected to continue into the
future. The control of these features is primarily to adjust the interface between the system and the terminal device so the output
appears on the display correctly. This should be set up before use by any application.
In general, both the input and output modes should not be set absolutely, but rather modified from the inherited
state.
A.11.2.4 Control Modes
This section could be misread that the symbol "CSIZE" is a title in the termios c_cflag field.
Although it does serve that function, it is also a required symbol, as a literal reading of POSIX.1 (and the caveats about
typography) would indicate.
A.11.2.5 Local Modes
Non-canonical mode is provided to allow fast bursts of input to be read efficiently while still allowing
single-character input.
The ECHONL function historically has been in many implementations. Since there seems to be no technical problem
with supporting ECHONL, it is included in POSIX.1 to increase consensus.
The alternate behavior possible when ECHOK or ECHOE are specified with ICANON is permitted as a compromise
depending on what the actual terminal hardware can do. Erasing characters and lines is preferred, but is not always possible.
A.11.2.6 Special Control Characters
Permitting VMIN and VTIME to overlap with VEOF and VEOL was a compromise for historical implementations. Only when
backwards-compatibility of object code is a serious concern to an implementor should an implementation continue this practice.
Correct applications that work with the overlap (at the source level) should also work if it is not present, but not the
reverse.
A.12 Utility Conventions
A.12.1 Utility Argument Syntax
The standard developers considered that recent trends toward diluting the SYNOPSIS sections of historical reference
pages to the equivalent of:
command [options][operands]
were a disservice to the reader. Therefore, considerable effort was placed into rigorous definitions of all the
command line arguments and their interrelationships. The relationships depicted in the synopses are normative parts of
POSIX.1-2024; this information is sometimes repeated in textual form, but that is only for clarity within context.
The use of "undefined" for conflicting argument usage and for repeated usage of the same option is meant to
prevent conforming applications from using conflicting arguments or repeated options unless specifically allowed (as is the case
with ls, which allows simultaneous, repeated use of the -C, -l, and
-1 options). Many historical implementations will tolerate this usage, choosing either the first or the last applicable
argument. This tolerance can continue, but conforming applications cannot rely upon it. (Other implementations may choose to print
usage messages instead.)
The use of "undefined" for conflicting argument usage also allows an implementation to make reasonable extensions
to utilities where the implementor considers mutually-exclusive options according to POSIX.1-2024 to have a sensible meaning and
result.
POSIX.1-2024 does not define the result of a command when an option-argument or operand is not followed by ellipses
and the application specifies more than one of that option-argument or operand. This allows an implementation to define valid
(although non-standard) behavior for the utility when more than one such option or operand is specified.
The requirements for option-arguments are summarized as follows:
SYNOPSIS Shows:
-a arg
-c[arg]
Conforming application uses:
-a arg
-carg or -c
System supports:
-a arg and -aarg
-carg and -c
Non-conforming applications may use:
-aarg
N/A
Earlier versions of this standard included obsolescent syntax which showed some options with (mandatory) adjacent
option-arguments in the SYNOPSIS for some utilities. These have since been removed. For all options with mandatory
option-arguments, the SYNOPSIS now shows  characters between the option and the option-argument; however, historical
usage has not been consistent in this area; therefore,  characters are required to be used by conforming applications
and to be handled by all implementations, but implementations are also required to handle an adjacent option-argument in order to
preserve backwards-compatibility for old scripts. One of the justifications for selecting the multiple-argument method was that the
single-argument case is inherently ambiguous when the option-argument can legitimately be a null string.
POSIX.1-2024 explicitly states that digits are permitted as operands and option-arguments. The lower and upper
bounds for the values of the numbers used for operands and option-arguments were derived from the ISO C standard values for
{LONG_MIN} and {LONG_MAX}. The requirement on the standard utilities is that numbers in the specified range do not cause a syntax
error, although the specification of a number need not be semantically correct for a particular operand or option-argument of a
utility. For example, the specification of:
dd obs=3000000000
would yield undefined behavior for the application and could be a syntax error because the number 3000000000 is
outside of the range -2147483647 to +2147483647. On the other hand:
dd obs=2000000000
may cause some error, such as "blocksize too large", rather than a syntax error.
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0056 [584] and XBD/TC2-2008/0057 [813] are applied.
Austin Group Defect 1062 is applied, correcting the spacing in some example SYNOPSIS lines.
A.12.2 Utility Syntax Guidelines
This section is based on the rules listed in the SVID. It was included for two reasons:
The individual utility descriptions in XCU 3. Utilities
needed a set of common (although not universal) actions on which they could anchor their descriptions of option and operand syntax.
Most of the standard utilities actually do use these guidelines, and many of their historical implementations use the getopt() function for their parsing. Therefore, it was simpler to cite the rules and merely
identify exceptions.
Developers of conforming applications need suggested guidelines if the POSIX community is to avoid the chaos of
historical UNIX system command syntax.
It is recommended that all future utilities and applications use these guidelines to enhance "user
portability". The fact that some historical utilities could not be changed (to avoid breaking historical applications) should not
deter this future goal.
The voluntary nature of the guidelines is highlighted by repeated uses of the word should throughout. This
usage should not be misinterpreted to imply that utilities that claim conformance in their OPTIONS sections do not always
conform.
Guidelines 1 and 2 encourage utility writers to use only characters from the portable character set because use of
locale-specific characters may make the utility inaccessible from other locales. Use of uppercase letters is discouraged due to
problems associated with porting utilities to systems that do not distinguish between uppercase and lowercase characters in
filenames. Use of non-alphanumeric characters is discouraged due to the number of utilities that treat non-alphanumeric characters
in "special" ways depending on context (such as the shell using white-space characters to delimit arguments, various quote
characters for quoting, the  to introduce variable expansion, etc.).
In XCU 2.9.1 Simple Commands, it is further stated
that a command used in the Shell Command Language cannot be named with a trailing .
Guideline 3 was changed to allow alphanumeric characters (letters and digits) from the character set to allow
compatibility with historical usage. Historical practice allows the use of digits wherever practical, and there are no portability
issues that would prohibit the use of digits. In fact, from an internationalization viewpoint, digits (being
non-language-dependent) are preferable over letters (a -2 is intuitively self-explanatory to any user, while in the
-f filename the letter 'f' is a mnemonic aid only to speakers of Latin-based languages where "filename"
happens to translate to a word that begins with 'f'. Since Guideline 3 still retains the word "single", multi-digit
options are not allowed. Instances of historical utilities that used them have been marked obsolescent, with the numbers being
changed from option names to option-arguments.
It was difficult to achieve a satisfactory solution to the problem of name space in option characters. When the
standard developers desired to extend the historical cc utility to accept ISO C standard programs, they found that all
of the portable alphabet was already in use by various vendors. Thus, they had to devise a new name, c89 (subsequently
superseded by c99 and now by c17), rather than something like cc
-X. There were suggestions that implementors be restricted to providing extensions through various means (such as using a
as the option delimiter or using option characters outside the alphanumeric set) that would reserve all of the
remaining alphanumeric characters for future POSIX standards. These approaches were resisted because they lacked the historical
style of UNIX systems. Furthermore, if a vendor-provided option should become commonly used in the industry, it would be a
candidate for standardization. It would be desirable to standardize such a feature using historical practice for the syntax (the
semantics can be standardized with any syntax). This would not be possible if the syntax was one reserved for the vendor. However,
since the standardization process may lead to minor changes in the semantics, it may prove to be better for a vendor to use a
syntax that will not be affected by standardization.
Guideline 8 includes the concept of -separated lists in a single argument. It is up to the utility to
parse such a list itself because getopt() just returns the single string. This
situation was retained so that certain historical utilities would not violate the guidelines. Applications preparing for
international use should be aware of an occasional problem with -separated lists: in some locales, the
is used as the radix character. Thus, if an application is preparing operands for a utility that expects a -separated
list, it should avoid generating non-integer values through one of the means that is influenced by setting the LC_NUMERIC
variable (such as awk, bc, printf, or printf()).
Unless explicitly stated otherwise in the utility description, Guideline 9 requires applications to put options
before operands, and requires utilities to accept any such usage without misinterpreting operands as options. For example, if an
implementation of the printf utility supports a -e option as an extension, the
command:
printf %s -e
must output the string "-e" without interpreting the -e as an option. Similarly, the command:
ls myfile -l
must interpret the -l argument as a second file operand, not as a -l option.
Applications calling any utility with a first operand starting with '-' should usually specify --,
as indicated by Guideline 10, to mark the end of the options. This is true even if the SYNOPSIS in the Shell and Utilities volume
of POSIX.1-2024 does not specify any options; implementations may provide options as extensions to the Shell and Utilities volume
of POSIX.1-2024. The standard utilities that do not support Guideline 10 indicate that fact in the OPTIONS section of the utility
description.
Guideline 7 allows any string to be an option-argument; an option-argument can begin with any character, can be
- or --, and can be an empty string. For example, the commands pr -h
-, pr -h --, pr -h -d,
pr -h +2, and pr -h " contain
the option-arguments -, --, -d, +2, and an empty string, respectively. Conversely, the command pr -h -- -d treats -d as an option, not as an argument, because the -- is an
option-argument here, not a delimiter.
Guideline 11 was modified to clarify that the order of different options should not matter relative to one another.
However, the order of repeated options that also have option-arguments may be significant; therefore, such options are required to
be interpreted in the order that they are specified. The make utility is an instance of
a historical utility that uses repeated options in which the order is significant. Multiple files are specified by giving multiple
instances of the -f option; for example:
make -f common_header -f specific_rules target
Guideline 13 does not imply that all of the standard utilities automatically accept the operand '-' to
mean standard input or output, nor does it specify the actions of the utility upon encountering multiple '-' operands. It
simply says that, by default, '-' operands are not used for other purposes in the file reading or writing (but not when
using stat(), unlink(), touch, and so on) utilities. In earlier versions of this standard, all information concerning
actual treatment of the '-' operand is found in the individual utility sections. Many implementations, however, treated
'-' as standard input or output and many applications depended on this behavior even though it was not standard. This
behavior is now implementation-defined. Portable applications should not use '-' to mean standard input or output unless
it is explicitly stated to do so in the utility description and they should always use './-' if they intend to refer to a
file named - in the current working directory.
Guideline 14 is intended to prohibit implementations that would treat the command ls -l -d as if it were ls -- -l -d or
ls -l -- -d.
The standard permits implementations to have extensions that violate the Utility Syntax Guidelines so long as when
the utility is used in line with the forms defined by the standard it follows the Utility Syntax Guidelines. Thus, CONVERSION ERROR
(.Cm) head -42 file and ls--help are permitted extensions. The intent is to allow
extensions so long as the standard form is accepted and follows the guidelines.
An area of concern was that as implementations mature, implementation-defined utilities and implementation-defined
utility options will result. The idea was expressed that there needed to be a standard way, say an environment variable or some
such mechanism, to identify implementation-defined utilities separately from standard utilities that may have the same name. It was
decided that there already exist several ways of dealing with this situation and that it is outside of the scope to attempt to
standardize in the area of non-standard items. A method that exists on some historical implementations is the use of the so-called
/local/bin or /usr/local/bin directory to separate local or additional copies or versions of utilities. Another
method that is also used is to isolate utilities into completely separate domains. Still another method to ensure that the desired
utility is being used is to request the utility by its full pathname. There are many approaches to this situation; the examples
given above serve to illustrate that there is more than one.
A.13 Namespace and Future Directions
Austin Group Defect 1071 is applied, adding this chapter.
A.14 Headers
A.14.1 Format of Entries
Each header reference page has a common layout of sections describing the interface. This layout is similar to the
manual page or "man" page format shipped with most UNIX systems, and each header has sections describing the SYNOPSIS and
DESCRIPTION. These are the two sections that relate to conformance.
Additional sections are informative, and add considerable information for the application developer. APPLICATION
USAGE sections provide additional caveats, issues, and recommendations to the developer. RATIONALE sections give additional
information on the decisions made in defining the interface.
FUTURE DIRECTIONS sections act as pointers to related work that may impact the interface in the future, and often
cautions the developer to architect the code to account for a change in this area. Note that a future directions statement should
not be taken as a commitment to adopt a feature or interface in the future.
The CHANGE HISTORY section describes when the interface was introduced, and how it has changed.
Option labels and margin markings in the page can be useful in guiding the application developer.
A.14.2 Removed Headers in Issue 8
The headers removed in Issue 8 (from the Issue 7 base document) are as follows:
Removed Headers in Issue 8
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/xrat/V4_port.html =====
Portability Considerations (Informative)
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
D. Portability Considerations (Informative)
This section contains information to satisfy various international requirements:
D.1 User Requirements describes perceived user requirements.
D.2 Portability Capabilities indicates how the facilities of POSIX.1-2024 satisfy those
requirements.
D.3 Profiling Considerations offers guidance to writers of profiles on how the configurable options,
limits, and optional behavior of POSIX.1-2024 should be cited in profiles.
D.1 User Requirements
This section describes the user requirements that were perceived by the standard developers. The primary source for these
requirements was an analysis of historical practice in widespread use, as typified by the base documents for the
ISO POSIX-1:1996 standard.
POSIX.1-2024 addresses the needs of users requiring open systems solutions for source code portability of applications. It
currently addresses users requiring open systems solutions for source-code portability of applications involving multi-programming
and process management (creating processes, signaling, and so on); access to files and directories in a hierarchy of file systems
(opening, reading, writing, deleting files, and so on); access to asynchronous communications ports and other special devices;
access to information about other users of the system; facilities supporting applications requiring bounded (realtime)
response.
The following users are identified for POSIX.1-2024:
Those employing applications written in high-level languages, such as C, Ada, or FORTRAN.
Users who desire conforming applications that do not necessarily require the characteristics of high-level languages (for
example, the speed of execution of compiled languages or the relative security of source code intellectual property inherent in the
compilation process).
Users who desire conforming applications that can be developed quickly and can be modified readily without the use of compilers
and other system components that may be unavailable on small systems or those without special application development
capabilities.
Users who interact with a system to achieve general-purpose time-sharing capabilities common to most business or government
offices or academic environments: editing, filing, inter-user communications, printing, and so on.
Users who develop applications for POSIX-conformant systems.
Users who develop applications for UNIX systems.
An acknowledged restriction on applicable users is that they are limited to the group of individuals who are familiar with the
style of interaction characteristic of historically-derived systems based on one of the UNIX operating systems (as opposed to other
historical systems with different models, such as MS/DOS, Macintosh, VMS, MVS, and so on). Typical users would include program
developers, engineers, or general-purpose time-sharing users.
The requirements of users of POSIX.1-2024 can be summarized as a single goal: application source portability. The
requirements of the user are stated in terms of the requirements of portability of applications. This in turn becomes a requirement
for a standardized set of syntax and semantics for operations commonly found on many operating systems.
The following sections list the perceived requirements for application portability.
D.1.1 Configuration Interrogation
An application must be able to determine whether and how certain optional features are provided and to identify the system upon
which it is running, so that it may appropriately adapt to its environment.
Applications must have sufficient information to adapt to varying behaviors of the system.
D.1.2 Process Management
An application must be able to manage itself, either as a single process or as multiple processes. Applications must be able to
manage other processes when appropriate.
Applications must be able to identify, control, create, and delete processes, and there must be communication of information
between processes and to and from the system.
Applications must be able to use multiple flows of control with a process (threads) and synchronize operations between these
flows of control.
D.1.3 Access to Data
Applications must be able to operate on the data stored on the system, access it, and transmit it to other applications.
Information must have protection from unauthorized or accidental access or modification.
D.1.4 Access to the Environment
Applications must be able to access the external environment to communicate their input and results.
D.1.5 Access to Determinism and Performance Enhancements
Applications must have sufficient control of resource allocation to ensure the timeliness of interactions with external
objects.
D.1.6 Operating System-Dependent Profile
The capabilities of the operating system may make certain optional characteristics of the base language in effect no longer
optional, and this should be specified.
D.1.7 I/O Interaction
The interaction between the C language I/O subsystem (stdio) and the I/O subsystem of POSIX.1-2024 must be specified.
D.1.8 Internationalization Interaction
The effects of the environment of POSIX.1-2024 on the internationalization facilities of the C language must be specified.
D.1.9 C-Language Extensions
Certain functions in the C language must be extended to support the additional capabilities provided by POSIX.1-2024.
D.1.10 Command Language
Users should be able to define procedures that combine simple tools and/or applications into higher-level components that
perform to the specific needs of the user. The user should be able to store, recall, use, and modify these procedures. These
procedures should employ a powerful command language that is used for recurring tasks in conforming applications (scripts) in the
same way that it is used interactively to accomplish one-time tasks. The language and the utilities that it uses must be consistent
between systems to reduce errors and retraining.
D.1.11 Interactive Facilities
Use the system to accomplish individual tasks at an interactive terminal. The interface should be consistent, intuitive, and
offer usability enhancements to increase the productivity of terminal users, reduce errors, and minimize retraining costs. Online
documentation or usage assistance should be available.
D.1.12 Accomplish Multiple Tasks Simultaneously
Access applications and interactive facilities from a single terminal without requiring serial execution: switch between
multiple interactive tasks; schedule one-time or periodic background work; display the status of all work in progress or scheduled;
influence the priority scheduling of work, when authorized.
D.1.13 Complex Data Manipulation
Manipulate data in files in complex ways: sort, merge, compare, translate, edit, format, pattern match, select subsets (strings,
columns, fields, rows, and so on). These facilities should be available to both conforming applications and interactive users.
D.1.14 File Hierarchy Manipulation
Create, delete, move/rename, copy, backup/archive, and display files and directories. These facilities should be available to
both conforming applications and interactive users.
D.1.15 Locale Configuration
Customize applications and interactive sessions for the cultural and language conventions of the user. Employ a wide variety of
standard character encodings. These facilities should be available to both conforming applications and interactive users.
D.1.16 Inter-User Communication
Send messages or transfer files to other users on the same system or other systems on a network. These facilities should be
available to both conforming applications and interactive users.
D.1.17 System Environment
Display information about the status of the system (activities of users and their interactive and background work, file system
utilization, system time, configuration, and presence of optional facilities) and the environment of the user (terminal
characteristics, and so on). Inform the system operator/administrator of problems. Control access to user files and other
resources.
D.1.18 Printing
Output files on a variety of output device classes, accessing devices on local or network-connected systems. Control (or
influence) the formatting, priority scheduling, and output distribution of work. These facilities should be available to both
conforming applications and interactive users.
D.1.19 Software Development
Develop (create and manage source files, compile/interpret, debug) portable open systems applications and package them for
distribution to, and updating of, other systems.
D.2 Portability Capabilities
This section describes the significant portability capabilities of POSIX.1-2024 and indicates how the user requirements listed
in D.1 User Requirements are addressed. The capabilities are listed in the same format as the preceding
user requirements; they are summarized below:
Configuration Interrogation
Process Management
Access to Data
Access to the Environment
Access to Determinism and Performance Enhancements
Operating System-Dependent Profile
I/O Interaction
Internationalization Interaction
C-Language Extensions
Command Language
Interactive Facilities
Accomplish Multiple Tasks Simultaneously
Complex Data Manipulation
File Hierarchy Manipulation
Locale Configuration
Inter-User Communication
System Environment
Printing
Software Development
D.2.1 Configuration Interrogation
The uname() operation provides basic identification of the system. The sysconf(), pathconf(), and fpathconf() functions and the getconf
utility provide means to interrogate the implementation to determine how to adapt to the environment in which it is running. These
values can be either static (indicating that all instances of the implementation have the same value) or dynamic (indicating that
different instances of the implementation have the different values, or that the value may vary for other reasons, such as
reconfiguration).
Unsatisfied Requirements
None directly. However, as new areas are added, there will be a need for additional capability in this area.
D.2.2 Process Management
The fork(), exec family, posix_spawn(), and posix_spawnp()
functions provide for the creation of new processes or the insertion of new applications into existing processes. The _Exit(), _exit(), exit(), and abort() functions allow for the
termination of a process by itself. The wait(), waitid(), and waitpid() functions allow one
process to deal with the termination of another.
The times() function allows for basic measurement of times used by a process.
Various functions, including fstat(), getegid(), geteuid(), getgid(), getgrgid(), getgrnam(), getlogin(), getpid(), getppid(), getpwnam(), getpwuid(), getuid(), lstat(), and stat(), provide for access to the identifiers of processes and the identifiers and names of
owners of processes (and files).
The various functions operating on environment variables provide for communication of information (primarily user-configurable
defaults) from a parent to child processes.
The operations on the current working directory control and interrogate the directory from which relative pathname searches
start. The umask() function controls the default protections applied to files created
by the process.
The alarm(), pause(), sleep(), ualarm(), and usleep() operations allow the process to suspend until a
timer has expired or to be notified when a period of time has elapsed. The time()
operation interrogates the current time and date.
The signal mechanism provides for communication of events either from other processes or from the environment to the
application, and the means for the application to control the effect of these events. The mechanism provides for external
termination of a process and for a process to suspend until an event occurs. The mechanism also provides for a value to be
associated with an event.
Job control provides a means to group processes and control them as groups, and to control their access to the function between
the user and the system (the "controlling terminal"). It also provides the means to suspend and resume processes.
The Process Scheduling option provides control of the scheduling and priority of a process.
The Message Passing option provides a means for interprocess communication involving small amounts of data.
The Memory Management facilities provide control of memory resources and for the sharing of memory. This functionality is
mandatory on POSIX-conforming systems.
The Threads facilities provide multiple flows of control with a process (threads), synchronization between threads (including
mutexes, barriers, and spin locks), association of data with threads, and controlled cancellation of threads.
The XSI interprocess communications functionality provide an alternate set of facilities to manipulate semaphores, message
queues, and shared memory. These are provided on XSI-conformant systems to support conforming applications developed to run on UNIX
systems.
D.2.3 Access to Data
The open(), close(), fclose(), fopen(), freopen(), pipe(), and pipe2() functions provide for access to files and data. Such files may be regular files,
interprocess data channels (pipes), or devices. Additional types of objects in the file system are permitted and are being
contemplated for standardization.
The access(), chmod(), chown(), dup(), dup2(), dup3(), fchmod(), fcntl(), fstat(), ftruncate(), futimens(), lstat(), readlink(), realpath(), stat(), and utimensat() functions allow for
control and interrogation of file and file-related objects (including symbolic links), and their ownership, protections, and
timestamps.
The fgetc(), fputc(), fread(), fseek(), fsetpos(), fwrite(), getc(), getchar(), lseek(), putchar(), putc(), read(), and write() functions provide for data transfer from the application to files (in all their
forms).
The closedir(), link(), mkdir(), opendir(), readdir(), rename(), rmdir(), rewinddir(), and unlink() functions provide for a complete set of operations on directories. Directories can
arbitrarily contain other directories, and a single file can be mentioned in more than one directory.
The faccessat(), openat(),
fchmodat(), fchownat(), fstatat(), linkat() renameat(), readlinkat(), symlinkat(), and unlinkat() functions
allow for race-free and thread-safe file access. The motivation for the introduction of these functions was as follows:
Interfaces taking a pathname may be limited by the maximum length of a pathname ({PATH_MAX}). The absolute path of files can far
exceed this length. The alternative solution of changing the working directory and using relative pathnames is not thread-safe.
A second motivation is that files accessed outside the current working directory are subject to attacks caused by the race
condition created by changing any of the elements of the pathnames used.
A third motivation is to allow application code which makes use of a virtual current working directory for each individual
thread. In the alternative model there is only one current working directory for all threads.
The file-locking mechanisms provide for advisory locking (protection during transactions) of ranges of bytes (in effect,
records) in a file.
The confstr(), fpathconf(),
pathconf(), and sysconf() functions
provide for enquiry as to the behavior of the system where variability is permitted.
The asynchronous input and output functions aio_cancel(), aio_error(), aio_fsync(), aio_read(), aio_return(), aio_suspend(), aio_write(), and
lio_listio() provide for initiation and control of asynchronous data
transfers.
The Synchronized Input and Output option provides for assured commitment of data to media.
D.2.4 Access to the Environment
The operations and types in XBD are provided for access to asynchronous serial devices. The primary intended use for these is
the controlling terminal for the application (the interaction point between the user and the system). They are general enough to be
used to control any asynchronous serial device. The functions are also general enough to be used with many other device types as a
user interface when some emulation is provided.
Less detailed access is provided for other device types, but in many instances an application need not know whether an object in
the file system is a device or a regular file to operate correctly.
Unsatisfied Requirements
Detailed control of common device classes, specifically magnetic tape, is not provided.
D.2.5 Bounded (Realtime) Response
The realtime signal functions sigqueue(), sigtimedwait(), and sigwaitinfo()
provide queued signals and the prioritization of the handling of signals.
The SCHED_FIFO, SCHED_SPORADIC, and SCHED_RR scheduling policies provide control over processor allocation.
The semaphore functions sem_clockwait(), sem_close(), sem_destroy(), sem_getvalue(), sem_init(), sem_open(), sem_post(), sem_timedwait(), sem_trywait(),
sem_unlink(), and sem_wait()
provide high-performance synchronization.
The memory management functions provide memory locking for control of memory allocation, file mapping for high performance, and
shared memory for high-performance interprocess communication. The Message Passing option provides for interprocess communication
without being dependent on shared memory.
The timers functions clock_getres(), clock_gettime(), clock_settime(),
nanosleep(), timer_create(),
timer_delete(), timer_getoverrun(), timer_gettime(), and timer_settime() provide functionality to manipulate clocks and timers and include a
high resolution function called nanosleep() with a finer resolution than the
sleep() function.
The timeout functions — pthread_mutex_clocklock(), pthread_mutex_timedlock(), pthread_rwlock_clockrdlock(), pthread_rwlock_clockwrlock(), pthread_rwlock_timedrdlock(), pthread_rwlock_timedwrlock(), sem_clockwait(), and sem_timedwait() — the Typed Memory Objects option and the Monotonic Clock facility
provide further facilities for applications to use to obtain predictable bounded response.
D.2.6 Operating System-Dependent Profile
POSIX.1-2024 makes no distinction between text and binary files. The values of EXIT_SUCCESS and EXIT_FAILURE are further
defined.
Unsatisfied Requirements
None known, but the ISO C standard may contain some additional options that could be specified.
D.2.7 I/O Interaction
POSIX.1-2024 defines how each of the ISO C standard stdio functions interact with the POSIX.1 operations, typically
specifying the behavior in terms of POSIX.1 operations.
Unsatisfied Requirements
None.
D.2.8 Internationalization Interaction
The POSIX.1-2024 environment operations provide a means to define the environment for setlocale() and time functions such as ctime(). The tzset() function is provided to set
time conversion information.
The nl_langinfo() function is provided to query locale-specific cultural
settings.
The multiple concurrent locale functions duplocale(), freelocale(), is*_l(), newlocale(), strcasecmp_l(), strcoll_l(), strfmon_l(), strncasecmp_l(), strxfrm_l(),
tolower_l(), toupper_l(),
towctrans_l(), towlower(),
towupper(), uselocale(), wcscasecmp_l(), wcscoll_l(), wcsncasecmp_l(), wcsxfrm_l(),
wctrans_l(), and wctype_l() are
provide to support per-thread locale information.
Unsatisfied Requirements
None.
D.2.9 C-Language Extensions
The setjmp() and longjmp()
functions are not defined to be cognizant of the signal masks defined for POSIX.1. The sigsetjmp() and siglongjmp() functions
are provided to fill this gap.
Unsatisfied Requirements
None.
D.2.10 Command Language
The shell command language, as described in XCU 2. Shell Command
Language, is a common language useful in batch scripts, through an API to high-level languages (for the C-Language Binding
option, system() and popen()) and
through an interactive terminal (see the sh utility). The shell language has many of the
characteristics of a high-level language, but it has been designed to be more suitable for user terminal entry and includes
interactive debugging facilities. Through the use of pipelining, many complex commands can be constructed from combinations of data
filters and other common components. Shell scripts can be created, stored, recalled, and modified by the user with simple
editors.
In addition to the basic shell language, the following utilities offer features that simplify and enhance programmatic access to
the utilities and provide features normally found only in high-level languages: basename, bc, command, dirname, echo, env, expr, false, printf, read, sleep, tee, test, time*,1 true, wait, xargs, and all of the special built-in
utilities in XCU 2.15 Special Built-In Utilities.
Unsatisfied Requirements
None.
D.2.11 Interactive Facilities
The utilities offer a common style of command-line interface through conformance to the Utility Syntax Guidelines (see XBD
12.2 Utility Syntax Guidelines) and the common utility defaults (see XCU
1.4 Utility Description Defaults). The sh utility offers an interactive command-line history and editing facility.
The following utilities can be used interactively as well as by scripts; alias,
fc, mailx, unalias, and write.
The following utilities in the User Portability Utilities option provide for interactive use: ex, more, and vi; the man utility offers online access to system
documentation.
Unsatisfied Requirements
The command line interface to individual utilities is as intuitive and consistent as historical practice allows. Work underway
based on graphical user interfaces may be more suitable for novice or occasional users of the system.
D.2.12 Accomplish Multiple Tasks Simultaneously
The shell command language offers background processing through the asynchronous list command form; see XCU 2.9 Shell Commands.
The nohup utility makes background processing more robust and usable.
The kill utility can terminate background jobs.
The following utilities support periodic job scheduling, control, and display: at,
batch, crontab, nice, ps, and renice.
When the User Portability Utilities option is supported, the following utilities allow manipulation of jobs: bg, fg, and jobs.
Unsatisfied Requirements
Terminals with multiple windows may be more suitable for some multi-tasking interactive uses than the job control approach in
POSIX.1-2024. See the comments on graphical user interfaces in D.2.11 Interactive Facilities. The
nice and renice utilities do not
necessarily take advantage of complex system scheduling algorithms that are supported by the realtime options within
POSIX.1-2024.
D.2.13 Complex Data Manipulation
The following utilities address user requirements in this area: asa, awk, bc, cmp, comm, csplit, cut, dd, diff, ed, ex*, expand, expr, find, fold, grep, head, join, od, paste, pr, printf, sed, sort, split, tabs, tail, tr, unexpand, uniq, uudecode, uuencode, and wc.
Unsatisfied Requirements
Sophisticated text formatting utilities, such as troff or TeX, are not included. Standards work in the area of
SGML may satisfy this.
D.2.14 File Hierarchy Manipulation
The following utilities address user requirements in this area: basename,
cd, chgrp, chmod, chown, cksum, cp, dd, df, diff, dirname, du, find, ls, ln, mkdir, mkfifo, mv, patch, pathchk, pax, pwd, rm, rmdir, test, and touch.
Unsatisfied Requirements
Some graphical user interfaces offer more intuitive file manager components that allow file manipulation through the use of
icons for novice users.
D.2.15 Locale Configuration
The standard utilities are affected by the various LC_ variables to achieve locale-dependent operation: character
classification, collation sequences, regular expressions and shell pattern matching, date and time formats, numeric formatting, and
monetary formatting. When the POSIX2_LOCALEDEF option is supported, applications can provide their own locale definition files.
The following utilities address user requirements in this area: date, ed, ex*, find, grep, locale, localedef, more*, sed, sh, sort, tr, uniq, and vi*.
The iconv(), iconv_close(), and
iconv_open() functions are available to allow an application to convert character
data between supported character sets.
The gencat utility and the catopen(), catclose(), and catgets() functions provide for message catalog manipulation.
Unsatisfied Requirements
Some aspects of multi-byte character and state-encoded character encodings have not yet been addressed. The C-language
functions, such as getopt(), are generally limited to single-byte characters. The
effect of the LC_MESSAGES variable on message formats is only suggested at this time.
D.2.16 Inter-User Communication
The following utilities address user requirements in this area: cksum, mailx, mesg, patch, pax, talk, uudecode, uuencode, who, and write.
The historical UUCP utilities are included as a separate UUCP Utilities option.
Unsatisfied Requirements
None.
D.2.17 System Environment
The following utilities address user requirements in this area: chgrp, chmod, chown, df, du, env,
getconf, id, logger, logname, mesg, newgrp, ps, stty, tput, tty, umask, uname, and who.
The closelog(), openlog(),
setlogmask(), and syslog()
functions provide system logging facilities on XSI-conformant systems; these are analogous to the logger utility.
Unsatisfied Requirements
None.
D.2.18 Printing
The following utilities address user requirements in this area: pr and lp.
Unsatisfied Requirements
There are no features to control the formatting or scheduling of the print jobs.
D.2.19 Software Development
The following utilities address user requirements in this area: ar, asa, awk, c17, ctags, getconf, getopts, lex, localedef, make, nm, od, patch, pax, strings, strip, time, and yacc.
The system(), popen(), pclose(), regcomp(), regexec(), regerror(), regfree(), fnmatch(), getopt(), glob(), globfree(), wordexp(), and wordfree() functions allow C-language programmers to access some of the interfaces used by
the utilities, such as argument processing, regular expressions, and pattern matching.
The SCCS source-code control system utilities are available on systems supporting the XSI Development option.
Unsatisfied Requirements
There are no language-specific development tools related to languages other than C. There is no data dictionary or other
CASE-like development tools.
D.2.20 Future Growth
It is arguable whether or not all functionality to support applications is potentially within the scope of POSIX.1-2024. As a
simple matter of practicality, it cannot be. Areas such as graphics, application domain-specific functionality, windowing, and so
on, should be in unique standards. As such, they are properly "Unsatisfied Requirements" in terms of providing fully conforming
applications, but ones which are outside the scope of POSIX.1-2024.
However, as the standards evolve, certain functionality once considered "exotic" enough to be part of a separate standard
become common enough to be included in a core standard such as this. Realtime and networking, for example, have both moved from
separate standards (with much difficult cross-referencing) into this standard over time, and although no specific areas have been
identified for inclusion in a future version, such inclusions seem likely.
D.3 Profiling Considerations
This section offers guidance to writers of profiles on how the configurable options, limits, and optional behavior of
POSIX.1-2024 should be cited in profiles. Profile writers should consult the general guidance in POSIX.0 when writing POSIX
Standardized Profiles.
The information in this section is an inclusive list of features that should be considered by profile writers. Subsetting of
POSIX.1-2024 should follow XBD 2.1.5.1 Subprofiling Considerations
. A set of profiling options is described in E. Subprofiling Considerations
(Informative).
D.3.1 Configuration Options
There are two set of options suggested by POSIX.1-2024: those for POSIX-conforming systems and those for X/Open System Interface
(XSI) conformance. The requirements for XSI conformance are documented in the Base Definitions volume of POSIX.1-2024 and not
discussed further here, as they superset the POSIX conformance requirements.
D.3.2 Configuration Options (Shell and Utilities)
There are three broad optional configurations for the Shell and Utilities volume of POSIX.1-2024: basic execution system,
development system, and user portability interactive system. The options to support these, and other minor configuration options,
are listed in XBD 2. Conformance. Profile writers should consult the
following list and the comments concerning user requirements addressed by various components in D.2
Portability Capabilities.
POSIX2_UPE
The system supports the User Portability Utilities option.
This option is a requirement for a user portability interactive system. It is required frequently except for those systems, such
as embedded realtime or dedicated application systems, that support little or no interactive time-sharing work by users or
operators. XSI-conformant systems support this option.
POSIX2_SW_DEV
The system supports the Software Development Utilities option.
This option is required by many systems, even those in which actual software development does not occur. The make utility, in particular, is required by many application software packages as they are
installed onto the system. If POSIX2_C_DEV is supported, POSIX2_SW_DEV is almost a mandatory requirement because of ar and make.
POSIX2_C_BIND
The system supports the C-Language Bindings option.
This option is required on some implementations developing complex C applications or on any system installing C applications in
source form that require the functions in this option. The system() and popen() functions, in particular, are widely used by applications; the others are rather more
specialized.
POSIX2_C_DEV
The system supports the C-Language Development Utilities option.
This option is required by many systems, even those in which actual C-language software development does not occur. The c17 utility, in particular, is required by many application software packages as they are
installed onto the system. The lex and yacc
utilities are used less frequently.
POSIX2_FORT_RUN
The system supports the FORTRAN Runtime Utilities option.
This option is required for some FORTRAN applications that need the asa utility to
convert Hollerith printing statement output. It is unknown how frequently this occurs.
POSIX2_LOCALEDEF
The system supports the creation of locales.
This option is needed if applications require their own customized locale definitions to operate. It is presently unknown
whether many applications are dependent on this. However, the option is virtually mandatory for systems in which internationalized
applications are developed.
XSI-conformant systems support this option.
POSIX2_CHAR_TERM
The system supports at least one terminal type capable of all operations described in POSIX.1-2024.
On systems with POSIX2_UPE, this option is almost always required. It was developed solely to allow certain specialized vendors
and user applications to bypass the requirement for general-purpose asynchronous terminal support. For example, an application and
system that was suitable for block-mode terminals would not need this option.
XSI-conformant systems support this option.
D.3.3 Configurable Limits
Very few of the limits need to be increased for profiles. No profile can cite lower values.
{POSIX2_BC_BASE_MAX}
{POSIX2_BC_DIM_MAX}
{POSIX2_BC_SCALE_MAX}
{POSIX2_BC_STRING_MAX}
No increase is anticipated for any of these bc values, except for very specialized
applications involving huge numbers.
{POSIX2_COLL_WEIGHTS_MAX}
Some natural languages with complex collation requirements require an increase from the default 2 to 4; no higher numbers are
anticipated.
{POSIX2_EXPR_NEST_MAX}
No increase is anticipated.
{POSIX2_LINE_MAX}
This number is much larger than most historical applications have been able to use. At some future time, applications may be
rewritten to take advantage of even larger values.
{POSIX2_RE_DUP_MAX}
No increase is anticipated.
{POSIX2_VERSION}
This is actually not a limit, but a standard version stamp. Generally, a profile should specify XCU 2. Shell Command Language by name in the normative references section, not this
value.
D.3.4 Configuration Options (System Interfaces)
{NGROUPS_MAX}
A non-zero value indicates that the implementation supports supplementary groups.
This option is needed where there is a large amount of shared use of files, but where a certain amount of protection is needed.
Many profiles2 are known to require this option; it should only be required if
needed, but it should never be prohibited.
_POSIX_ADVISORY_INFO
The system provides advisory information for file management.
This option allows the application to specify advisory information that can be used to achieve better or even deterministic
response time in file manager or input and output operations.
_POSIX_ASYNCHRONOUS_IO
Support for asynchronous input and output is mandatory in POSIX.1-2024.
_POSIX_BARRIERS
Support for barrier synchronization is mandatory in POSIX.1-2024.
This facility allows efficient synchronization of multiple parallel threads in multi-processor systems in which the operation is
supported in part by the hardware architecture.
_POSIX_CHOWN_RESTRICTED
The system restricts the right to "give away" files to other users. It is mandatory that an implementation be able to support
this facility in POSIX.1-2024; however, it is recognized that implementations need not enable the functionality by default.
Some applications expect that they can change the ownership of files in this way. It is provided where either security or system
account requirements cause this ability to be a problem. It is also known to be specified in many profiles.
_POSIX_CLOCK_SELECTION
Support for clock selection is mandatory in POSIX.1-2024.
This facility allows applications to request a high resolution sleep in order to suspend a thread during a relative time
interval, or until an absolute time value, using the desired clock. It also allows the application to select the clock used in a
pthread_cond_timedwait() function call.
_POSIX_CPUTIME
The system supports the Process CPU-Time Clocks option.
This option allows applications to use a new clock that measures the execution times of processes or threads, and the
possibility to create timers based upon these clocks, for runtime detection (and treatment) of execution time overruns.
_POSIX_FSYNC
The system supports file synchronization requests.
This option was created to support historical systems that did not provide the feature. Applications that are expecting
guaranteed completion of their input and output operations should require the _POSIX_SYNC_IO option. This option should never be
prohibited.
XSI-conformant systems support this option.
_POSIX_IPV6
The system supports facilities related to Internet Protocol Version 6 (IPv6).
This option was created to allow systems to transition to IPv6.
_POSIX_JOB_CONTROL
Support for job control is mandatory in POSIX.1-2024.
Most applications that use it can run when it is not present, although with a degraded level of user convenience.
_POSIX_MAPPED_FILES
Support for memory mapped files is mandatory in POSIX.1-2024.
This facility provides for the mapping of regular files into the process address space.
Both this facility and the Shared Memory Objects option provide shared access to memory objects in the process address space.
The mmap() and munmap() functions provide
the functionality of existing practice for mapping regular files. This functionality was deemed unnecessary, if not inappropriate,
for embedded systems applications and is expected to be optional in subprofiles.
_POSIX_MEMLOCK
The system supports the locking of the address space.
This option was created to support historical systems that did not provide the feature. It should only be required if needed,
but it should never be prohibited.
_POSIX_MEMLOCK_RANGE
The system supports the locking of specific ranges of the address space.
For applications that have well-defined sections that need to be locked and others that do not, POSIX.1-2024 supports an
optional set of functions to lock or unlock a range of process addresses. The following are two reasons for having a means to lock
down a specific range:
An asynchronous event handler function that must respond to external events in a deterministic manner such that page faults
cannot be tolerated
An input/output "buffer" area that is the target for direct-to-process I/O, and the overhead of implicit locking and unlocking
for each I/O call cannot be tolerated
It should only be required if needed, but it should never be prohibited.
_POSIX_MEMORY_PROTECTION
Support for memory protection is mandatory in POSIX.1-2024.
The provision of this facility typically imposes additional hardware requirements.
_POSIX_PRIORITIZED_IO
The system provides prioritization for input and output operations.
The use of this option may interfere with the ability of the system to optimize input and output throughput. It should only be
required if needed, but it should never be prohibited.
_POSIX_MESSAGE_PASSING
The system supports the passing of messages between processes.
This option was created to support historical systems that did not provide the feature. The functionality adds a
high-performance XSI interprocess communication facility for local communication. It should only be required if needed, but it
should never be prohibited.
_POSIX_MONOTONIC_CLOCK
Support for a monotonic clock is mandatory in POSIX.1-2024.
This facility allows realtime applications to rely on a monotonically increasing clock that does not jump backwards, and whose
value does not change except for the regular ticking of the clock.
_POSIX_PRIORITY_SCHEDULING
The system provides priority-based process scheduling.
Support of this option provides predictable scheduling behavior, allowing applications to determine the order in which processes
that are ready to run are granted access to a processor. It should only be required if needed, but it should never be
prohibited.
_POSIX_REALTIME_SIGNALS
Support for realtime signals is mandatory in POSIX.1-2024.
This facility provides prioritized, queued signals with associated data values.
_POSIX_REGEXP
Support for regular expression facilities is mandatory in POSIX.1-2024.
_POSIX_SAVED_IDS
Support for this feature is mandatory in POSIX.1-2024.
Certain classes of applications rely on it for proper operation, and there is no alternative short of giving the application
root privileges on most implementations that did not provide _POSIX_SAVED_IDS.
_POSIX_SEMAPHORES
Support for counting semaphores is mandatory in POSIX.1-2024.
_POSIX_SHARED_MEMORY_OBJECTS
The system supports the mapping of shared memory objects into the process address space.
Both this option and the Memory Mapped Files option provide shared access to memory objects in the process address space. The
functions defined under this option provide the functionality of existing practice for shared memory objects. This functionality
was deemed appropriate for embedded systems applications and, hence, is provided under this option. It should only be required if
needed, but it should never be prohibited.
_POSIX_SHELL
Support for the sh utility command line interpreter is mandatory in POSIX.1-2024.
_POSIX_SPAWN
The system supports the spawn option.
This option provides applications with an efficient mechanism to spawn execution of a new process.
_POSIX_SPINLOCKS
Support for spin locks is mandatory in POSIX.1-2024.
This facility provides a simple and efficient synchronization mechanism for threads executing in multi-processor systems.
_POSIX_SPORADIC_SERVER
The system supports the sporadic server scheduling policy.
This option provides applications with a new scheduling policy for scheduling aperiodic processes or threads in hard realtime
applications.
_POSIX_SYNCHRONIZED_IO
The system supports guaranteed file synchronization.
This option was created to support historical systems that did not provide the feature. Applications that are expecting
guaranteed completion of their input and output operations should require this option, rather than the File Synchronization option.
It should only be required if needed, but it should never be prohibited.
_POSIX_THREADS
Support for multiple threads of control within a single process is mandatory in POSIX.1-2024.
_POSIX_THREAD_ATTR_STACKADDR
The system supports specification of the stack address for a created thread.
Applications may take advantage of support of this option for performance benefits, but dependence on this feature should be
minimized. This option should never be prohibited.
XSI-conformant systems support this option.
_POSIX_THREAD_ATTR_STACKSIZE
The system supports specification of the stack size for a created thread.
Applications may require this option in order to ensure proper execution, but such usage limits portability and dependence on
this feature should be minimized. It should only be required if needed, but it should never be prohibited.
XSI-conformant systems support this option.
_POSIX_THREAD_PRIORITY_SCHEDULING
The system provides priority-based thread scheduling.
Support of this option provides predictable scheduling behavior, allowing applications to determine the order in which threads
that are ready to run are granted access to a processor. It should only be required if needed, but it should never be
prohibited.
_POSIX_THREAD_PRIO_INHERIT
The system provides mutual-exclusion operations with priority inheritance.
Support of this option provides predictable scheduling behavior, allowing applications to determine the order in which threads
that are ready to run are granted access to a processor. It should only be required if needed, but it should never be
prohibited.
_POSIX_THREAD_PRIO_PROTECT
The system supports a priority ceiling emulation protocol for mutual-exclusion operations.
Support of this option provides predictable scheduling behavior, allowing applications to determine the order in which threads
that are ready to run are granted access to a processor. It should only be required if needed, but it should never be
prohibited.
_POSIX_THREAD_PROCESS_SHARED
The system provides shared access among multiple processes to synchronization objects.
This option was created to support historical systems that did not provide the feature. It should only be required if needed,
but it should never be prohibited.
XSI-conformant systems support this option.
_POSIX_THREAD_SAFE_FUNCTIONS
Support for thread-safe functions is mandatory in POSIX.1-2024.
_POSIX_THREAD_SPORADIC_SERVER
The system supports the thread sporadic server scheduling policy.
Support for this option provides applications with a new scheduling policy for scheduling aperiodic threads in hard realtime
applications.
_POSIX_TIMEOUTS
Support for timeouts for some blocking services is mandatory in POSIX.1-2024.
_POSIX_TIMERS
Support for higher resolution clocks with multiple timers per process is mandatory in POSIX.1-2024.
This facility is appropriate for applications requiring higher resolution timestamps or needing to control the timing of
multiple activities.
_POSIX_TYPED_MEMORY_OBJECTS
The system supports the Typed Memory Objects option.
This option was created to allow realtime applications to access different kinds of physical memory, and allow processes in
these applications to share portions of this memory.
D.3.5 Configurable Limits
In general, the configurable limits in the  header defined in the
Base Definitions volume of POSIX.1-2024 have been set to minimal values; many applications or implementations may require larger
values. No profile can cite lower values.
{AIO_LISTIO_MAX}
The current minimum is likely to be inadequate for most applications. It is expected that this value will be increased by profiles
requiring support for list input and output operations.
{AIO_MAX}
The current minimum is likely to be inadequate for most applications. It is expected that this value will be increased by profiles
requiring support for asynchronous input and output operations.
{AIO_PRIO_DELTA_MAX}
The functionality associated with this limit is needed only by sophisticated applications. It is not expected that this limit would
need to be increased under a general-purpose profile.
{ARG_MAX}
The current minimum is likely to need to be increased for profiles, particularly as larger amounts of information are passed
through the environment. Many implementations are believed to support larger values.
{CHILD_MAX}
The current minimum is suitable only for systems where a single user is not running applications in parallel. It is significantly
too low for any system also requiring windows, and if _POSIX_JOB_CONTROL is specified, it should be raised.
{CLOCKRES_MIN}
It is expected that profiles will require a finer granularity clock, perhaps as fine as 1 µs, represented by a value of 1000 for
this limit.
{DELAYTIMER_MAX}
It is believed that most implementations will provide larger values.
{LINK_MAX}
For most applications and usage, the current minimum is adequate. Many implementations have a much larger value, but this should
not be used as a basis for raising the value unless the applications to be used require it.
{LOGIN_NAME_MAX}
This is not actually a limit, but an implementation parameter. No profile should impose a requirement on this value.
{MAX_CANON}
For most purposes, the current minimum is adequate. Unless high-speed burst serial devices are used, it should be left as is.
{MAX_INPUT}
See {MAX_CANON}.
{MQ_OPEN_MAX}
The current minimum should be adequate for most profiles.
{MQ_PRIO_MAX}
The current minimum corresponds to the required number of process scheduling priorities. Many realtime practitioners believe that
the number of message priority levels ought to be the same as the number of execution scheduling priorities.
{NAME_MAX}
Many implementations now support larger values, and many applications and users assume that larger names can be used. Many existing
profiles also specify a larger value. Specifying this value will reduce the number of conforming implementations, although this
might not be a significant consideration over time. Values greater than 255 should not be required.
{NGROUPS_MAX}
The value selected will typically be 8 or larger.
{OPEN_MAX}
The historically common value for this has been 20. Many implementations support larger values. If applications that use larger
values are anticipated, an appropriate value should be specified.
{PAGESIZE}
This is not actually a limit, but an implementation parameter. No profile should impose a requirement on this value.
{PATH_MAX}
Historically, the minimum has been either 1024 or indefinite, depending on the implementation. Few applications actually require
values larger than 256, but some users may create file hierarchies that must be accessed with longer paths. This value should only
be changed if there is a clear requirement.
{PIPE_BUF}
The current minimum is adequate for most applications. Historically, it has been larger. If applications that write single
transactions larger than this are anticipated, it should be increased. Applications that write lines of text larger than this
probably do not need it increased, as the text line is delimited by a .
{POSIX_VERSION}
This is actually not a limit, but a standard version stamp. Generally, a profile should specify POSIX.1-2024 by a name in the
normative references section, not this value.
{PTHREAD_DESTRUCTOR_ITERATIONS}
It is unlikely that applications will need larger values to avoid loss of memory resources.
{PTHREAD_KEYS_MAX}
The current value should be adequate for most profiles.
{PTHREAD_STACK_MIN}
This should not be treated as an actual limit, but as an implementation parameter. No profile should impose a requirement on this
value.
{PTHREAD_THREADS_MAX}
It is believed that most implementations will provide larger values.
{RTSIG_MAX}
The current limit was chosen so that the set of POSIX.1 signal numbers can fit within a 32-bit field. It is recognized that most
existing implementations define many more signals than are specified in POSIX.1 and, in fact, many implementations have already
exceeded 32 signals (including the "null signal"). Support of {_POSIX_RTSIG_MAX} additional signals may push some implementations
over the single 32-bit word line, but is unlikely to push any implementations that are already over that line beyond the 64 signal
line.
{SEM_NSEMS_MAX}
The current value should be adequate for most profiles.
{SEM_VALUE_MAX}
The current value should be adequate for most profiles.
{SSIZE_MAX}
This limit reflects fundamental hardware characteristics (the size of an integer), and should not be specified unless it is clearly
required. Extreme care should be taken to assure that any value that might be specified does not unnecessarily eliminate
implementations because of accidents of hardware design.
{STREAM_MAX}
This limit is very closely related to {OPEN_MAX}. It should never be larger than {OPEN_MAX}, but could reasonably be smaller for
application areas where most files are not accessed through stdio. Some implementations may limit {STREAM_MAX} to 20 but
allow {OPEN_MAX} to be considerably larger. Such implementations should be allowed for if the applications permit.
{TIMER_MAX}
The current limit should be adequate for most profiles, but it may need to be larger for applications with a large number of
asynchronous operations.
{TTY_NAME_MAX}
This is not actually a limit, but an implementation parameter. No profile should impose a requirement on this value.
{TZNAME_MAX}
The minimum has been historically adequate, but if longer timezone names are anticipated (particularly such values as UTC-1), this
should be increased.
D.3.6 Optional Behavior
In POSIX.1-2024, there are no instances of the terms unspecified, undefined, implementation-defined, or with the verbs "may"
or "need not", that the standard developers anticipate or sanction as suitable for profile or test method citation. All of these
are merely warnings to conforming applications to avoid certain areas that can vary from system to system, and even over time on
the same system. In many cases, these terms are used explicitly to support extensions, but profiles should not anticipate and
require such extensions; future versions of this standard may do so.
Footnotes
1. The utilities listed with an asterisk here and later in this section are present
only on systems which support the User Portability Utilities option. There may be further restrictions on the utilities offered
with various configuration option combinations; see the individual utility descriptions.
2. There are no formally approved profiles of POSIX.1-2024 at the time of publication;
the reference here is to various profiles generated by private bodies or governments.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/xrat/V4_subprofiles.html =====
Subprofiling Considerations (Informative)
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
B. Rationale for System Interfaces
B.1 Introduction
B.1.1 Change History
The change history is provided as an informative section, to track changes from earlier versions of this standard.
The following sections describe changes made to the System Interfaces volume of POSIX.1-2024 since Issue 7 of the base document.
The CHANGE HISTORY section for each entry details the technical changes that have been made in Issue 5 and later. Changes made
before Issue 5 are not included.
Changes from Issue 7 to Issue 8 (POSIX.1-2024)
The following list summarizes the major changes that were made in the System Interfaces volume of POSIX.1-2024 from Issue 7 to
Issue 8:
The Open Group Standard, 2021, Additional APIs for the Base Specifications Issue 8, Part 1 is incorporated.
The Open Group Standard, 2022, Additional APIs for the Base Specifications Issue 8, Part 2 is incorporated.
IEEE Std 1003.26-2003 is incorporated.
Existing functionality is aligned with the ISO/IEC 9899:2018 standard.
New functionality from the ISO/IEC 9899:2018 standard is incorporated.
Austin Group defect reports and IEEE Interpretations against IEEE Std 1003.1 are applied.
The Open Group corrigenda and resolutions are applied.
Features, marked obsolescent in the base document, have been considered for removal in this version.
The Device Control option is added.
The IEC 60559 Complex Floating-Point option is added.
New Features in Issue 8
The functions first introduced in Issue 8 (over the Issue 7 base document) are as follows:
New Functions in Issue 8
_Fork()
aligned_alloc()
at_quick_exit()
atomic_compare_exchange_strong()
atomic_compare_exchange_strong_explicit()
atomic_compare_exchange_weak()
atomic_compare_exchange_weak_explicit()
atomic_exchange()
atomic_exchange_explicit()
atomic_fetch_add()
atomic_fetch_add_explicit()
atomic_fetch_and()
atomic_fetch_and_explicit()
atomic_fetch_or()
atomic_fetch_or_explicit()
atomic_fetch_sub()
atomic_fetch_sub_explicit()
atomic_fetch_xor()
atomic_fetch_xor_explicit()
atomic_flag_clear()
atomic_flag_clear_explicit()
atomic_flag_test_and_set()
atomic_flag_test_and_set_explicit()
atomic_init()
atomic_is_lock_free()
atomic_load()
atomic_load_explicit()
atomic_signal_fence()
atomic_store()
atomic_store_explicit()
atomic_thread_fence()
bind_textdomain_codeset()
bindtextdomain()
c16rtomb()
c32rtomb()
call_once()
cnd_broadcast()
cnd_destroy()
cnd_init()
cnd_signal()
cnd_timedwait()
cnd_wait()
dcgettext()
dcgettext_l()
dcngettext()
dcngettext_l()
dgettext()
dgettext_l()
dladdr()
dngettext()
dngettext_l()
getentropy()
getlocalename_l()
getresgid()
getresuid()
gettext()
gettext_l()
mbrtoc16()
mbrtoc32()
memmem()
mtx_destroy()
mtx_init()
mtx_lock()
mtx_timedlock()
mtx_trylock()
mtx_unlock()
ngettext()
ngettext_l()
posix_close()
posix_devctl()
posix_getdents()
ppoll()
pthread_cond_clockwait()
pthread_mutex_clocklock()
pthread_rwlock_clockrdlock()
pthread_rwlock_clockwrlock()
qsort_r()
quick_exit()
reallocarray()
sem_clockwait()
setresgid()
setresuid()
sig2str()
str2sig()
strlcat()
strlcpy()
textdomain()
thrd_create()
thrd_current()
thrd_detach()
thrd_equal()
thrd_exit()
thrd_join()
thrd_sleep()
thrd_yield()
timespec_get()
tss_create()
tss_delete()
tss_get()
tss_set()
wcslcat()
wcslcpy()
The following new headers are introduced in Issue 8:
New Headers in Issue 8
Obsolescent Functions in Issue 8
The base functions moved to obsolescent status in Issue 8 (from the Issue 7 base document) are as follows:
Obsolescent Base Functions in Issue 8
inet_addr()
inet_ntoa()
The XSI functions moved to obsolescent status in Issue 8 (from the Issue 7 base document) are as follows:
Obsolescent XSI Functions in Issue 8
encrypt()
setkey()
Removed Functions in Issue 8
The functions removed in Issue 8 (from the Issue 7 base document) are as follows:
Removed Functions in Issue 8
_longjmp()
_setjmp()
_tolower()
_toupper()
fattach()
fdetach()
ftw()
getitimer()
getmsg()
getpmsg()
gets()
gettimeofday()
ioctl()
isascii()
isastream()
posix_trace_attr_destroy()
posix_trace_attr_getclockres()
posix_trace_attr_getcreatetime()
posix_trace_attr_getgenversion()
posix_trace_attr_getinherited()
posix_trace_attr_getlogfullpolicy()
posix_trace_attr_getlogsize()
posix_trace_attr_getmaxdatasize()
posix_trace_attr_getmaxsystemeventsize()
posix_trace_attr_getmaxusereventsize()
posix_trace_attr_getname()
posix_trace_attr_getstreamfullpolicy()
posix_trace_attr_getstreamsize()
posix_trace_attr_init()
posix_trace_attr_setinherited()
posix_trace_attr_setlogfullpolicy()
posix_trace_attr_setlogsize()
posix_trace_attr_setmaxdatasize()
posix_trace_attr_setname()
posix_trace_attr_setstreamfullpolicy()
posix_trace_attr_setstreamsize()
posix_trace_clear()
posix_trace_close()
posix_trace_create()
posix_trace_create_withlog()
posix_trace_event()
posix_trace_eventid_equal()
posix_trace_eventid_get_name()
posix_trace_eventid_open()
posix_trace_eventset_add()
posix_trace_eventset_del()
posix_trace_eventset_empty()
posix_trace_eventset_fill()
posix_trace_eventset_ismember()
posix_trace_eventtypelist_getnext_id()
posix_trace_eventtypelist_rewind()
posix_trace_flush()
posix_trace_get_attr()
posix_trace_get_filter()
posix_trace_get_status()
posix_trace_getnext_event()
posix_trace_open()
posix_trace_rewind()
posix_trace_set_filter()
posix_trace_shutdown()
posix_trace_start()
posix_trace_stop()
posix_trace_timedgetnext_event()
posix_trace_trid_eventid_open()
posix_trace_trygetnext_event()
pthread_getconcurrency()
pthread_setconcurrency()
putmsg()
putpmsg()
rand_r()
setitimer()
setpgrp()
sighold()
sigignore()
siginterrupt()
sigpause()
sigrelse()
sigset()
tempnam()
toascii()
ulimit()
utime()
B.1.2 Relationship to Other Formal Standards
There is no additional rationale provided for this section.
B.1.3 Format of Entries
Each system interface reference page has a common layout of sections describing the interface. This layout is
similar to the manual page or "man" page format shipped with most UNIX systems, and each header has sections describing the
SYNOPSIS, DESCRIPTION, RETURN VALUE, and ERRORS. These are the four sections that relate to conformance.
Additional sections are informative, and add considerable information for the application developer. EXAMPLES
sections provide example usage. APPLICATION USAGE sections provide additional caveats, issues, and recommendations to the
developer. RATIONALE sections give additional information on the decisions made in defining the interface.
FUTURE DIRECTIONS sections act as pointers to related work that may impact the interface in the future, and often
cautions the developer to architect the code to account for a change in this area. Note that a future directions statement should
not be taken as a commitment to adopt a feature or interface in the future.
The CHANGE HISTORY section describes when the interface was introduced, and how it has changed.
Option labels and margin markings in the page can be useful in guiding the application developer.
B.2 General Information
B.2.1 Use and Implementation of Interfaces
B.2.1.1 Use and Implementation of Functions
The information concerning the use of functions was adapted from a description in the ISO C standard. Here is
an example of how an application program can protect itself from functions that may or may not be macros, rather than true
functions:
The atoi() function may be used in any of several ways:
By use of its associated header (possibly generating a macro expansion):
#include
/* ... */
i = atoi(str);
By use of its associated header (assuredly generating a true function call):
#include
#undef atoi
/* ... */
i = atoi(str);
or:
#include
/* ... */
i = (atoi) (str);
By explicit declaration:
extern int atoi (const char *);
/* ... */
i = atoi(str);
By implicit declaration:
/* ... */
i = atoi(str);
(Assuming no function prototype is in scope. This is not allowed by the ISO C standard for functions with
variable arguments; furthermore, parameter type conversion "widening" is subject to different rules in this case.)
Note that the ISO C standard reserves names starting with '_' for the compiler. Therefore, the
compiler could, for example, implement an intrinsic, built-in function _asm_builtin_atoi(), which it recognized and expanded
into inline assembly code. Then, in , there could be the
following:
#define atoi(X) _asm_builtin_atoi(X)
The user's "normal" call to atoi() would then be expanded inline, but
the implementor would also be required to provide a callable function named atoi() for
use when the application requires it; for example, if its address is to be stored in a function pointer variable.
Implementors should note that since applications can #undef a macro in order to ensure that the function is
used, this means that it is not safe for implementations to use the names of any standard functions in macro values, since the
application could use #undef to ensure that no macro exists and then use the same name for an identifier with local scope.
For example, historically it was common for a getchar() macro to be defined in
as:
#define getchar() getc(stdin)
This definition does not conform, because an application is allowed to use the identifier getc with local
scope, and the expansion of the getchar() macro would then pick up the local
getc. The following is conforming code, but would not compile with the above definition of getchar():
#include
#undef getc
int main(void)
{
int getc;
getc = getchar();
return getc;
}
This does not only affect function-like macros. For example, the following definition does not conform because
there could be a local sysconf variable in scope when SIGRTMIN is expanded:
#define SIGRTMIN ((int)sysconf(_SC_SIGRT_MIN))
Implementors can avoid the problem by using aliases for standard functions instead of the actual function, with
names that conforming applications cannot use for local variables. For example:
#define SIGRTMIN ((int)__sysconf(_SC_SIGRT_MIN))
Austin Group Defect 655 is applied, making the requirement relating to explicit function declarations apply only to
functions from the ISO C standard.
Austin Group Defect 1302 is applied, aligning this section with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1404 is applied, adding to the examples of invalid values for function arguments.
B.2.1.2 Use and Implementation of Macros
There is no additional rationale provided for this section.
B.2.2 The Compilation Environment
B.2.2.1 POSIX.1 Symbols
This and the following section address the issue of "name space pollution". The ISO C standard requires that
the name space beyond what it reserves not be altered except by explicit action of the application developer. This section defines
the actions to add the POSIX.1 symbols for those headers where both the ISO C standard and POSIX.1 need to define symbols, and
also where the XSI option extends the base standard.
When headers are used to provide symbols, there is a potential for introducing symbols that the application
developer cannot predict. Ideally, each header should only contain one set of symbols, but this is not practical for historical
reasons. Thus, the concept of feature test macros is included. Two feature test macros are explicitly defined by POSIX.1-2024; it
is expected that future versions may add to this.
Note:
Feature test macros allow an application to announce to the implementation its desire to have certain symbols and prototypes
exposed. They should not be confused with the version test macros and constants for options in  which are the implementation's way of announcing functionality to the
application.
It is further intended that these feature test macros apply only to the headers specified by POSIX.1-2024.
Implementations are expressly permitted to make visible symbols not specified by POSIX.1-2024, within both POSIX.1 and other
headers, under the control of feature test macros that are not defined by POSIX.1-2024.
The _POSIX_C_SOURCE Feature Test Macro
The POSIX.1-1990 standard specified a macro called _POSIX_SOURCE. This has been superseded by _POSIX_C_SOURCE. This
symbol will allow implementations to support various versions of this standard simultaneously. For instance, when _POSIX_C_SOURCE
is defined as 202405L, the system should make visible the same name space as permitted and required by the POSIX.1-2024 standard. A
special case is the one where the implementation wishes to make available support for the 1990 version of the POSIX standard, in
which instance when either _POSIX_SOURCE is defined or _POSIX_C_SOURCE is defined as 1, the system should make visible the same
name space as permitted and required by the POSIX.1-1990 standard.
It is expected that C bindings to future POSIX standards will define new values for _POSIX_C_SOURCE, with each new
value reserving the name space for that new standard.
The _XOPEN_SOURCE Feature Test Macro
The feature test macro _XOPEN_SOURCE is provided as the announcement mechanism for the application that it requires
functionality from the Single UNIX Specification. _XOPEN_SOURCE must be defined to the value 800 before the inclusion of any header
to enable the functionality in the Single UNIX Specification Version 5. Its definition subsumes the use of _POSIX_C_SOURCE.
An extract of code from a conforming application, that appears before any #include statements, is given
below:
#define _XOPEN_SOURCE 800 /* Single UNIX Specification, Version 5 */
#include ...
Note that the definition of _XOPEN_SOURCE with the value 800 makes the definition of _POSIX_C_SOURCE redundant and
it can safely be omitted.
The __STDC_WANT_LIB_EXT1__ Feature Test Macro
The ISO C standard specifies the feature test macro __STDC_WANT_LIB_EXT1__ as the announcement mechanism for
the application that it requires functionality from Annex K. It specifies that the symbols specified in Annex K (if supported) are
made visible when __STDC_WANT_LIB_EXT1__ is 1 and are not made visible when it is 0, but leaves it unspecified whether they are
made visible when __STDC_WANT_LIB_EXT1__ is undefined. POSIX.1 requires that they are not made visible when the macro is undefined
(except for those symbols that are already explicitly allowed to be visible through the definition of _POSIX_C_SOURCE or
_XOPEN_SOURCE, or both).
POSIX.1 does not include the interfaces specified in Annex K of the ISO C standard, but allows the symbols to
be made visible in headers when requested by the application in order that applications can use symbols from Annex K and symbols
from POSIX.1 in the same translation unit.
Austin Group Defect 1302 is applied, adding this subsection.
B.2.2.2 The Name Space
The reservation of identifiers is paraphrased from the ISO C standard. The text is included because it needs
to be part of POSIX.1-2024, regardless of possible changes in future versions of the ISO C standard.
These identifiers may be used by implementations, particularly for feature test macros. Implementations should not
use feature test macro names that might be reasonably used by a standard.
Including headers more than once is a reasonably common practice, and it should be carried forward from the
ISO C standard. More significantly, having definitions in more than one header is explicitly permitted. Where the potential
declaration is "benign" (the same definition twice) the declaration can be repeated, if that is permitted by the compiler. (This
is usually true of macros, for example.) In those situations where a repetition is not benign (for example, typedefs),
conditional compilation must be used. The situation actually occurs both within the ISO C standard and within POSIX.1:
time_t should be in , and the ISO C standard
mandates that it be in .
The area of name space pollution versus additions to structures is difficult because of the macro structure
of C. The following discussion summarizes all the various problems with and objections to the issue.
Note the phrase "user-defined macro". Users are not permitted to define macro names (or any other name) beginning
with "_[A-Z_]". Thus, the conflict cannot occur for symbols reserved to the vendor's name space, and the permission to add
fields automatically applies, without qualification, to those symbols.
Data structures (and unions) need to be defined in headers by implementations to meet certain requirements of
POSIX.1 and the ISO C standard.
The structures defined by POSIX.1 are typically minimal, and any practical implementation would wish to add fields
to these structures either to hold additional related information or for backwards-compatibility (or both). Future standards (and
de facto standards) would also wish to add to these structures. Issues of field alignment make it impractical (at least in
the general case) to simply omit fields when they are not defined by the particular standard involved.
The dirent structure is an example of such a minimal structure (although one could argue about whether the
other fields need visible names). The st_rdev field of most implementations' stat structure is a common example where
extension is needed and where a conflict could occur.
Fields in structures are in an independent name space, so the addition of such fields presents no problem to the C
language itself in that such names cannot interact with identically named user symbols because access is qualified by the specific
structure name.
There is an exception to this: macro processing is done at a lexical level. Thus, symbols added to a structure
might be recognized as user-provided macro names at the location where the structure is declared. This only can occur if the
user-provided name is declared as a macro before the header declaring the structure is included. The user's use of the name after
the declaration cannot interfere with the structure because the symbol is hidden and only accessible through access to the
structure. Presumably, the user would not declare such a macro if there was an intention to use that field name.
Macros from the same or a related header might use the additional fields in the structure, and those field names
might also collide with user macros. Although this is a less frequent occurrence, since macros are expanded at the point of use, no
constraint on the order of use of names can apply.
An "obvious" solution of using names in the reserved name space and then redefining them as macros when they
should be visible does not work because this has the effect of exporting the symbol into the general name space. For example, given
a (hypothetical) system-provided header , and two parts of a C program in a.c and b.c, in header
:
struct foo {
int __i;
}
#ifdef _FEATURE_TEST
#define i __i;
#endif
In file a.c:
#include h.h
extern int i;
...
In file b.c:
extern int i;
...
The symbol that the user thinks of as i in both files has an external name of __i in a.c; the
same symbol i in b.c has an external name i (ignoring any hidden manipulations the compiler might perform on
the names). This would cause a mysterious name resolution problem when a.o and b.o are linked.
Simply avoiding definition then causes alignment problems in the structure.
A structure of the form:
struct foo {
union {
int __i;
#ifdef _FEATURE_TEST
int i;
#endif
} __ii;
}
does not work because the name of the logical field i is __ii.i, and introduction of a macro to
restore the logical name immediately reintroduces the problem discussed previously (although its manifestation might be more
immediate because a syntax error would result if a recursive macro did not cause it to fail first).
A more workable solution would be to declare the structure:
struct foo {
#ifdef _FEATURE_TEST
int i;
#else
int __i;
#endif
}
However, if a macro (particularly one required by a standard) is to be defined that uses this field, two must be
defined: one that uses i, the other that uses __i. If more than one additional field is used in a macro and they are
conditional on distinct combinations of features, the complexity goes up as 2n.
All this leaves a difficult situation: vendors must provide very complex headers to deal with what is conceptually
simple and safe—adding a field to a structure. It is the possibility of user-provided macros with the same name that makes this
difficult.
Several alternatives were proposed that involved constraining the user's access to part of the name space available
to the user (as specified by the ISO C standard). In some cases, this was only until all the headers had been included. There
were two proposals discussed that failed to achieve consensus:
Limiting it for the whole program.
Restricting the use of identifiers containing only uppercase letters until after all system headers had been
included. It was also pointed out that because macros might wish to access fields of a structure (and macro expansion occurs
totally at point of use) restricting names in this way would not protect the macro expansion, and thus the solution was
inadequate.
It was finally decided that reservation of symbols would occur, but as constrained.
The current wording also allows the addition of fields to a structure, but requires that user macros of the same
name not interfere. This allows vendors to do one of the following:
Not create the situation (do not extend the structures with user-accessible names or use the solution in (7)
above)
Extend their compilers to allow some way of adding names to structures and macros safely
There are at least two ways that the compiler might be extended: add new preprocessor directives that turn off and
on macro expansion for certain symbols (without changing the value of the macro) and a function or lexical operation that
suppresses expansion of a word. The latter seems more flexible, particularly because it addresses the problem in macros as well as
in declarations.
The following seems to be a possible implementation extension to the C language that will do this: any token that
during macro expansion is found to be preceded by three '#' symbols shall not be further expanded in exactly the same way
as described for macros that expand to their own name as in Section 6.10.3.4 of the ISO C standard. A vendor may also wish to
implement this as an operation that is lexically a function, which might be implemented as:
#define __safe_name(x) ###x
Using a function notation would insulate vendors from changes in standards until such a functionality is
standardized (if ever). Standardization of such a function would be valuable because it would then permit third parties to take
advantage of it portably in software they may supply.
The symbols that are "explicitly permitted, but not required by POSIX.1-2024" include those classified below.
(That is, the symbols classified below might, but are not required to, be present when _POSIX_C_SOURCE is defined to have the value
202405L.)
Symbols in  and  that are defined to indicate support for options or limits that are
constant at compile-time
Symbols in the name space reserved for the implementation by the ISO C standard
Symbols in a name space reserved for a particular type of extension (for example, type names ending with _t
in )
Additional members of structures or unions whose names do not reduce the name space reserved for applications
Since both implementations and future versions of this standard and other POSIX standards may use symbols in the
reserved spaces described in these tables, there is a potential for name space clashes. To avoid future name space clashes when
adding symbols, implementations should not use the posix_, POSIX_, or _POSIX_ prefixes.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/2 is applied, deleting the entries POSIX_, _POSIX_,
and posix_ from the column of allowed name space prefixes for use by an implementation in the first table. The presence of these
prefixes was contradicting later text which states that: "The prefixes posix_, POSIX_, and _POSIX are reserved for use by XCU
2. Shell Command Language and other POSIX standards. Implementations may
add symbols to the headers shown in the following table, provided the identifiers ... do not use the reserved prefixes posix_,
POSIX_, or _POSIX.".
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/3 is applied, correcting the reserved macro prefix
from: "PRI[a-z], SCN[a-z]" to: "PRI[Xa-z], SCN[Xa-z]" in the second table. The change was needed since the ISO C standard
allows implementations to define macros of the form PRI or SCN followed by any lowercase letter or 'X' in . (The ISO/IEC 9899:1999 standard, Subclause 7.26.4.)
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/4 is applied, adding a new section listing reserved
names for the  header. This change is for alignment with the
ISO C standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/2 is applied, making it clear that implementations
are permitted to have symbols with the prefix _POSIX_ visible in any header.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/3 is applied, updating the table of allowed macro
prefixes to include the prefix FP_[A-Z] for . This text is added for
consistency with the  reference page in the Base Definitions volume of
POSIX.1-2024 which permits additional implementation-defined floating-point classifications.
Austin Group Interpretation 1003.1-2001 #048 is applied, reserving SEEK_ in the name space.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0001 [801], XSH/TC2-2008/0002 [780], XSH/TC2-2008/0003 [790],
XSH/TC2-2008/0004 [780], XSH/TC2-2008/0005 [790], XSH/TC2-2008/0006 [782], XSH/TC2-2008/0007 [790], and XSH/TC2-2008/0008 [790] are
applied.
Austin Group Defect 162 is applied, adding the
header.
Austin Group Defect 697 is applied, reserving DT_ in the name space.
Austin Group Defect 845 is applied, reserving in6addr_ in the name space.
Austin Group Defect 993 is applied, reserving dli_ in the name space.
Austin Group Defect 1003 is applied, correcting a mismatch with the ISO C standard regarding reservation of
each identifier with file scope described in the header section.
Austin Group Defect 1122 is applied, adding .
Austin Group Defect 1151 is applied, adding ws_ as a reserved prefix for .
Austin Group Defect 1302 is applied, aligning this section with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1456 is applied, clarifying the reservation of symbolic constants with the prefix _CS_, _PC_,
and _SC_ for .
B.2.3 Error Numbers
It was the consensus of the standard developers that to allow the conformance document to state that an error
occurs and under what conditions, but to disallow a statement that it never occurs, does not make sense. It could be implied by the
current wording that this is allowed, but to reduce the possibility of future interpretation requests, it is better to make an
explicit statement.
The original ISO C standard just required that errno be a modifiable lvalue. Since the introduction of
threads in 2011, the ISO C standard has instead required that errno be a macro which expands to a modifiable lvalue
that has thread local storage duration.
Checking the value of errno alone is not sufficient to determine the existence or type of an error, since it
is not required that a successful function call clear errno. The variable errno should only be examined when the
return value of a function indicates that the value of errno is meaningful. In that case, the function is required to set
the variable to something other than zero.
The variable errno is never set to zero by any function call; to do so would contradict the ISO C
standard.
POSIX.1 requires (in the ERRORS sections of function descriptions) certain error values to be set in certain
conditions because many existing applications depend on them. Some error numbers, such as [EFAULT], are entirely
implementation-defined and are noted as such in their description in the ERRORS section. This section otherwise allows wide
latitude to the implementation in handling error reporting.
Some of the ERRORS sections in POSIX.1-2024 have two subsections. The first:
"The function shall fail if:"
could be called the "mandatory" section.
The second:
"The function may fail if:"
could be informally known as the "optional" section.
Attempting to infer the quality of an implementation based on whether it detects optional error conditions is not
useful.
Following each one-word symbolic name for an error, there is a description of the error. The rationale for some of
the symbolic names follows:
[ECANCELED]
This spelling was chosen as being more common.
[EFAULT]
Most historical implementations do not catch an error and set errno when an invalid address is given to the functions
wait(), time(), or times(). Some implementations cannot reliably detect an invalid address. And most systems that
detect invalid addresses will do so only for a system call, not for a library routine.
[EFTYPE]
This error code was proposed in earlier proposals as "Inappropriate operation for file type", meaning that the operation
requested is not appropriate for the file specified in the function call. This code was proposed, although the same idea was
covered by [ENOTTY], because the connotations of the name would be misleading. It was pointed out that the fcntl() function uses the error code [EINVAL] for this notion, and hence all instances of
[EFTYPE] were changed to this code.
[EINTR]
POSIX.1 prohibits conforming implementations from restarting interrupted system calls of conforming applications unless the
SA_RESTART flag is in effect for the signal. However, it does not require that [EINTR] be returned when another legitimate value
may be substituted; for example, a partial transfer count when read() or write() are interrupted. This is only given when the signal-catching function returns normally
as opposed to returns by mechanisms like longjmp() or siglongjmp().
[ELOOP]
In specifying conditions under which implementations would generate this error, the following goals were considered:
To ensure that actual loops are detected, including loops that result from symbolic links across distributed file
systems.
To ensure that during pathname resolution an application can rely on the ability to follow at least {SYMLOOP_MAX}
symbolic links in the absence of a loop.
To allow implementations to provide the capability of traversing more than {SYMLOOP_MAX} symbolic links in the
absence of a loop.
To allow implementations to detect loops and generate the error prior to encountering {SYMLOOP_MAX} symbolic
links.
[ENAMETOOLONG]
When a symbolic link is encountered during pathname resolution, the contents of that symbolic link are used to create a new
pathname. The standard developers intended to allow, but not require, that implementations enforce the restriction of {PATH_MAX} on
the result of this pathname substitution.
Implementations are allowed, but not required, to treat a pathname longer than {PATH_MAX} passed into the system as
an error. Implementations are required to return a pathname (even if it is longer than {PATH_MAX}) when the user supplies a buffer
with an interface that specifies the buffer size, as long as the user-supplied buffer is large enough to hold the entire pathname
(see XSH getcwd() for an example of this type of interface). Implementations are
required to treat a request to pass a pathname longer than {PATH_MAX} from the system to a user-supplied buffer of an unspecified
size (usually assumed to be of size {PATH_MAX}) as an error (see XSH realpath()
for an example of this type of interface).
[ENOMEM]
The term "main memory" is not used in POSIX.1 because it is implementation-defined.
[ENOTSUP]
This error code is to be used when an implementation chooses to implement the required functionality of POSIX.1-2024 but does
not support optional facilities defined by POSIX.1-2024. In some earlier versions of this standard, the difference between
[ENOTSUP] and [ENOSYS] was that [ENOSYS] indicated that the function was not supported at all. This is no longer the case as
[ENOSYS] can also be used to indicate non-support of optional functionality for a function that has some required functionality.
(See XSH encrypt().)
[ENOTTY]
The symbolic name for this error is derived from a time when device control was done by ioctl() and that operation was
only permitted on a terminal interface. The term "TTY" is derived from "teletypewriter", the devices to which this error
originally applied.
[EOVERFLOW]
Most of the uses of this error code are related to large file support. Typically, these cases occur on systems which support
multiple programming environments with different sizes for off_t, but they may also occur in connection with remote file
systems.
In addition, when different programming environments have different widths for types such as int and
uid_t, several functions may encounter a condition where a value in a particular environment is too wide to be represented.
In that case, this error should be raised. For example, suppose the currently running process has 64-bit int, and file
descriptor 9223372036854775807 is open and does not have the close-on-exec flag set. If the process then uses execl() to exec a file compiled in a programming environment with 32-bit int,
the call to execl() can fail with errno set to [EOVERFLOW]. A similar failure
can occur with execl() if any of the user IDs or any of the group IDs to be assigned
to the new process image are out of range for the executed file's programming environment.
Note, however, that this condition cannot occur for functions that are explicitly described as always being
successful, such as getpid().
[EPIPE]
This condition normally generates the signal SIGPIPE; the error is returned if the generation of the signal is suppressed or
the signal does not terminate the process.
[EROFS]
In historical implementations, attempting to unlink() or rmdir() a mount point would generate an [EBUSY] error. An implementation could be envisioned
where such an operation could be performed without error. In this case, if either the directory entry or the actual data
structures reside on a read-only file system, [EROFS] is the appropriate error to generate. (For example, changing the link count
of a file on a read-only file system could not be done, as is required by unlink(),
and thus an error should be reported.)
Three error numbers, [EDOM], [EILSEQ], and [ERANGE], were added to this section primarily for consistency with the
ISO C standard.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0009 [496] and XSH/TC2-2008/0010 [681] are applied.
Austin Group Defect 1067 is applied, adding [ESOCKTNOSUPPORT].
Austin Group Defect 1380 is applied, changing the descriptions of [EMLINK] and [EXDEV].
Austin Group Defect 1669 is applied, changing the description of [EFBIG].
Alternative Solutions for Per-Thread errno
The historical implementation of errno as a single global variable does not work in a multi-threaded
environment. In such an environment, a thread may make a POSIX.1 call and get a -1 error return, but before that thread can check
the value of errno, another thread might have made a second POSIX.1 call that also set errno. This behavior is
unacceptable in robust programs. There were a number of alternatives that were considered for handling the errno
problem:
Implement errno as a per-thread integer variable.
Implement errno as a service that can access the per-thread error number.
Change all POSIX.1 calls to accept an extra status argument and avoid setting errno.
Change all POSIX.1 calls to raise a language exception.
The first option offers the highest level of compatibility with existing practice but requires special support in
the linker, compiler, and/or virtual memory system to support the new concept of thread private variables. When compared with
current practice, the third and fourth options are much cleaner, more efficient, and encourage a more robust programming style, but
they require new versions of all of the POSIX.1 functions that might detect an error. The second option offers compatibility with
existing code that uses the  header to define the symbol errno.
In this option, errno may be a macro defined:
#define errno  (*__errno())
extern int      *__errno();
This option may be implemented as a per-thread variable whereby an errno field is allocated in the user
space object representing a thread, and whereby the function __errno() makes a system call to determine the location of its
user space object and returns the address of the errno field of that object. Another implementation, one that avoids calling
the kernel, involves allocating stacks in chunks. The stack allocator keeps a side table indexed by chunk number containing a
pointer to the thread object that uses that chunk. The __errno() function then looks at the stack pointer, determines the
chunk number, and uses that as an index into the chunk table to find its thread object and thus its private value of errno.
On most architectures, this can be done in four to five instructions. Some compilers may wish to implement __errno() inline
to improve performance.
Disallowing Return of the [EINTR] Error Code
Many blocking interfaces defined by POSIX.1-2024 may return [EINTR] if interrupted during their execution by a
signal handler. Blocking interfaces introduced under the threads functionality do not have this property. Instead, they require
that the interface appear to be atomic with respect to interruption. In particular, applications calling blocking interfaces need
not handle any possible [EINTR] return as a special case since it will never occur. In the case of threads functions in , the requirement is stated in terms of the call not being affected if the
calling thread executes a signal handler during the call, since these functions return errors in a different way and cannot
distinguish an [EINTR] condition from other error conditions. If it is necessary to restart operations or complete incomplete
operations following the execution of a signal handler, this is handled by the implementation, rather than by the application.
Requiring applications to handle [EINTR] errors on blocking interfaces has been shown to be a frequent source of
often unreproducible bugs, and it adds no compelling value to the available functionality. Thus, blocking interfaces introduced for
use by multi-threaded programs do not use this paradigm. In particular, in none of the functions flockfile(), pthread_cond_timedwait(), pthread_cond_wait(), pthread_join(), pthread_mutex_lock(), and sigwait() did providing [EINTR] returns add value, or even particularly make sense. Thus,
these functions do not provide for an [EINTR] return, even when interrupted by a signal handler. The same arguments can be applied
to sem_wait(), sem_trywait(),
sigwaitinfo(), and sigtimedwait(), but implementations are permitted to return [EINTR] error codes for
these functions for compatibility with earlier versions of this standard. Applications cannot rely on calls to these functions
returning [EINTR] error codes when signals are delivered to the calling thread, but they should allow for the possibility.
Austin Group Interpretation 1003.1-2001 #050 is applied, allowing [ENOTSUP] and [EOPNOTSUPP] to be the same
values.
B.2.3.1 Additional Error Numbers
The ISO C standard defines the name space for implementations to add additional error numbers.
B.2.4 Signal Concepts
Historical implementations of signals, using the signal() function,
have shortcomings that make them unreliable for many application uses. Because of this, a new signal mechanism, based very closely
on the one of 4.2 BSD and 4.3 BSD, was added to POSIX.1.
Signal Names
The restriction on the actual type used for sigset_t is intended to guarantee that these objects can always
be assigned, have their address taken, and be passed as parameters by value. It is not intended that this type be a structure
including pointers to other data structures, as that could impact the portability of applications performing such operations. A
reasonable implementation could be a structure containing an array of some integer type.
The signals described in POSIX.1-2024 must have unique values so that they may be named as parameters of
case statements in the body of a C-language switch clause. However, implementation-defined signals may have values
that overlap with each other or with signals specified in POSIX.1-2024. An example of this is SIGABRT, which traditionally overlaps
some other signal, such as SIGIOT.
SIGKILL, SIGTERM, SIGUSR1, and SIGUSR2 are ordinarily generated only through the explicit use of the kill() function, although some implementations generate SIGKILL under extraordinary
circumstances. SIGTERM is traditionally the default signal sent by the kill
command.
The signals SIGBUS, SIGEMT, SIGIOT, SIGTRAP, and SIGSYS were omitted from POSIX.1 because their behavior is
implementation-defined and could not be adequately categorized. Conforming implementations may deliver these signals, but must
document the circumstances under which they are delivered and note any restrictions concerning their delivery. The signals SIGFPE,
SIGILL, and SIGSEGV are similar in that they also generally result only from programming errors. They were included in POSIX.1
because they do indicate three relatively well-categorized conditions. They are all defined by the ISO C standard and thus
would have to be defined by any system with an ISO C standard binding, even if not explicitly included in POSIX.1.
There is very little that a Conforming POSIX.1 Application can do by catching, ignoring, or masking any of the
signals SIGILL, SIGTRAP, SIGIOT, SIGEMT, SIGBUS, SIGSEGV, SIGSYS, or SIGFPE. They will generally be generated by the system only in
cases of programming errors. While it may be desirable for some robust code (for example, a library routine) to be able to detect
and recover from programming errors in other code, these signals are not nearly sufficient for that purpose. One portable use that
does exist for these signals is that a command interpreter can recognize them as the cause of termination of a process (with
wait()) and print an appropriate message. The mnemonic tags for these signals are
derived from their PDP-11 origin.
The signals SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU, and SIGCONT are provided for job control and are unchanged from 4.2
BSD. The signal SIGCHLD is also typically used by job control shells to detect children that have terminated or, as in 4.2 BSD,
stopped.
Some implementations, including System V, have a signal named SIGCLD, which is similar to SIGCHLD in 4.2 BSD.
POSIX.1 permits implementations to have a single signal with both names. POSIX.1 carefully specifies ways in which conforming
applications can avoid the semantic differences between the two different implementations. The name SIGCHLD was chosen for POSIX.1
because most current application usages of it can remain unchanged in conforming applications. SIGCLD in System V has more
cases of semantics that POSIX.1 does not specify, and thus applications using it are more likely to require changes in addition to
the name change.
The signals SIGUSR1 and SIGUSR2 are commonly used by applications for notification of exceptional behavior and are
described as "reserved as application-defined" so that such use is not prohibited. Implementations should not generate SIGUSR1 or
SIGUSR2, except when explicitly requested by kill(). It is recommended that libraries
not use these two signals, as such use in libraries could interfere with their use by applications calling the libraries. If such
use is unavoidable, it should be documented. It is prudent for non-portable libraries to use non-standard signals to avoid
conflicts with use of standard signals by portable libraries.
There is no portable way for an application to catch or ignore non-standard signals. Some implementations define
the range of signal numbers, so applications can install signal-catching functions for all of them. Unfortunately,
implementation-defined signals often cause problems when caught or ignored by applications that do not understand the reason for
the signal. While the desire exists for an application to be more robust by handling all possible signals (even those only
generated by kill()), no existing mechanism was found to be sufficiently portable to
include in POSIX.1. The value of such a mechanism, if included, would be diminished given that SIGKILL would still not be
catchable.
A number of new signal numbers are reserved for applications because the two user signals defined by POSIX.1 are
insufficient for many realtime applications. A range of signal numbers is specified, rather than an enumeration of additional
reserved signal names, because different applications and application profiles will require a different number of application
signals. It is not desirable to burden all application domains and therefore all implementations with the maximum number of signals
required by all possible applications. Note that in this context, signal numbers are essentially different signal priorities.
The relatively small number of required additional signals, {_POSIX_RTSIG_MAX}, was chosen so as not to require an
unreasonably large signal mask/set. While this number of signals defined in POSIX.1 will fit in a single 32-bit word signal mask,
it is recognized that most existing implementations define many more signals than are specified in POSIX.1 and, in fact, many
implementations have already exceeded 32 signals (including the "null signal"). Support of {_POSIX_RTSIG_MAX} additional signals
may push some implementation over the single 32-bit word line, but is unlikely to push any implementations that are already over
that line beyond the 64-signal line.
B.2.4.1 Signal Generation and Delivery
The terms defined in this section are not used consistently in documentation of historical systems. Each signal can
be considered to have a lifetime beginning with generation and ending with delivery or acceptance. The POSIX.1 definition of
"delivery" does not exclude ignored signals; this is considered a more consistent definition. This revised text in several parts
of POSIX.1-2024 clarifies the distinct semantics of asynchronous signal delivery and synchronous signal acceptance. The previous
wording attempted to categorize both under the term "delivery", which led to conflicts over whether the effects of asynchronous
signal delivery applied to synchronous signal acceptance.
Signals generated for a process are delivered to only one thread. Thus, if more than one thread is eligible to
receive a signal, one has to be chosen. The choice of threads is left entirely up to the implementation both to allow the widest
possible range of conforming implementations and to give implementations the freedom to deliver the signal to the "easiest
possible" thread should there be differences in ease of delivery between different threads.
Note that should multiple delivery among cooperating threads be required by an application, this can be trivially
constructed out of the provided single-delivery semantics. The construction of a sigwait_multiple() function that
accomplishes this goal is presented with the rationale for sigwaitinfo().
Implementations should deliver unblocked signals as soon after they are generated as possible. However, it is
difficult for POSIX.1 to make specific requirements about this, beyond those in kill()
and sigprocmask(). Even on systems with prompt delivery, scheduling of higher
priority processes is always likely to cause delays.
In general, the interval between the generation and delivery of unblocked signals cannot be detected by an
application. Thus, references to pending signals generally apply to blocked, pending signals. An implementation registers a signal
as pending on the process when no thread has the signal unblocked and there are no threads blocked in a sigwait() function for that signal. Thereafter, the implementation delivers the signal to
the first thread that unblocks the signal or calls a sigwait() function on a signal
set containing this signal rather than choosing the recipient thread at the time the signal is sent.
In the 4.3 BSD system, signals that are blocked and set to SIG_IGN are discarded immediately upon generation. For a
signal that is ignored as its default action, if the action is SIG_DFL and the signal is blocked, a generated signal remains
pending. In the 4.1 BSD system and in System V Release 3 (two other implementations that support a somewhat similar signal
mechanism), all ignored blocked signals remain pending if generated. Because it is not normally useful for an application to
simultaneously ignore and block the same signal, it was unnecessary for POSIX.1 to specify behavior that would invalidate any of
the historical implementations.
There is one case in some historical implementations where an unblocked, pending signal does not remain pending
until it is delivered. In the System V implementation of signal(), pending
signals are discarded when the action is set to SIG_DFL or a signal-catching routine (as well as to SIG_IGN). Except in the case of
setting SIGCHLD to SIG_DFL, implementations that do this do not conform completely to POSIX.1. Some earlier proposals for POSIX.1
explicitly stated this, but these statements were redundant due to the requirement that functions defined by POSIX.1 not change
attributes of processes defined by POSIX.1 except as explicitly stated.
POSIX.1 specifically states that the order in which multiple, simultaneously pending signals are delivered is
unspecified. This order has not been explicitly specified in historical implementations, but has remained quite consistent and been
known to those familiar with the implementations. Thus, there have been cases where applications (usually system utilities) have
been written with explicit or implicit dependencies on this order. Implementors and others porting existing applications may need
to be aware of such dependencies.
When there are multiple pending signals that are not blocked, implementations should arrange for the delivery of
all signals at once, if possible. Some implementations stack calls to all pending signal-catching routines, making it appear that
each signal-catcher was interrupted by the next signal. In this case, the implementation should ensure that this stacking of
signals does not violate the semantics of the signal masks established by sigaction(). Other implementations process at most one signal when the operating system is
entered, with remaining signals saved for later delivery. Although this practice is widespread, this behavior is neither
standardized nor endorsed. In either case, implementations should attempt to deliver signals associated with the current state of
the process (for example, SIGFPE) before other signals, if possible.
In 4.2 BSD and 4.3 BSD, it is not permissible to ignore or explicitly block SIGCONT, because if blocking or
ignoring this signal prevented it from continuing a stopped process, such a process could never be continued (only killed by
SIGKILL). However, 4.2 BSD and 4.3 BSD do block SIGCONT during execution of its signal-catching function when it is caught,
creating exactly this problem. A proposal was considered to disallow catching SIGCONT in addition to ignoring and blocking it, but
this limitation led to objections. The consensus was to require that SIGCONT always continue a stopped process when generated. This
removed the need to disallow ignoring or explicit blocking of the signal; note that SIG_IGN and SIG_DFL are equivalent for
SIGCONT.
B.2.4.2 Realtime Signal Generation and Delivery
The realtime signals functionality is required in this version of the standard for the following reasons:
The sigevent structure is used by other POSIX.1 functions that result in asynchronous event notifications
to specify the notification mechanism to use and other information needed by the notification mechanism. POSIX.1-2024 defines only
three symbolic values for the notification mechanism:
SIGEV_NONE is used to indicate that no notification is required when the event occurs. This is useful for
applications that use asynchronous I/O with polling for completion.
SIGEV_SIGNAL indicates that a signal is generated when the event occurs.
SIGEV_THREAD provides for "callback functions" for asynchronous notifications done by a function call within the
context of a new thread. This provides a multi-threaded process with a more natural means of notification than signals.
The primary difficulty with previous notification approaches has been to specify the environment of the
notification routine.
One approach is to limit the notification routine to call only functions permitted in a signal handler. While the
list of permissible functions is clearly stated, this is overly restrictive.
A second approach is to define a new list of functions or classes of functions that are explicitly permitted or
not permitted. This would give a programmer more lists to deal with, which would be awkward.
The third approach is to define completely the environment for execution of the notification function. A clear
definition of an execution environment for notification is provided by executing the notification function in the environment of a
newly created thread.
Implementations may support additional notification mechanisms by defining new values for sigev_notify.
For a notification type of SIGEV_SIGNAL, the other members of the sigevent structure defined by POSIX.1-2024
specify the realtime signal—that is, the signal number and application-defined value that differentiates between occurrences of
signals with the same number—that will be generated when the event occurs. The structure is defined in , even though the structure is not directly used by any of the signal
functions, because it is part of the signals interface used by the POSIX.1b "client functions". When the client functions include
to define the signal names, the sigevent structure will also
be defined.
An application-defined value passed to the signal handler is used to differentiate between different "events"
instead of requiring that the application use different signal numbers for several reasons:
Realtime applications potentially handle a very large number of different events. Requiring that implementations
support a correspondingly large number of distinct signal numbers will adversely impact the performance of signal delivery because
the signal masks to be manipulated on entry and exit to the handlers will become large.
Event notifications are prioritized by signal number (the rationale for this is explained in the following
paragraphs) and the use of different signal numbers to differentiate between the different event notifications overloads the signal
number more than has already been done. It also requires that the application developer make arbitrary assignments of priority to
events that are logically of equal priority.
A union is defined for the application-defined value so that either an integer constant or a pointer can be
portably passed to the signal-catching function. On some architectures a pointer cannot be cast to an int and vice
versa.
Use of a structure here with an explicit notification type discriminant rather than explicit parameters to realtime
functions, or embedded in other realtime structures, provides for future extensions to POSIX.1-2024. Additional, perhaps more
efficient, notification mechanisms can be supported for existing realtime function interfaces, such as timers and asynchronous I/O,
by extending the sigevent structure appropriately. The existing realtime function interfaces will not have to be modified to
use any such new notification mechanism. The revised text concerning the SIGEV_SIGNAL value makes consistent the semantics of the
members of the sigevent structure, particularly in the definitions of lio_listio() and aio_fsync(). For
uniformity, other revisions cause this specification to be referred to rather than inaccurately duplicated in the descriptions of
functions and structures using the sigevent structure. The revised wording does not relax the requirement that the signal
number be in the range SIGRTMIN to SIGRTMAX to guarantee queuing and passing of the application value, since that requirement is
still implied by the signal names.
POSIX.1-2024 is intentionally vague on whether "non-realtime" signal-generating mechanisms can result in a
siginfo_t being supplied to the handler on delivery. In one existing implementation, a siginfo_t is posted on signal
generation, even though the implementation does not support queuing of multiple occurrences of a signal. It is not the intent of
POSIX.1-2024 to preclude this, independent of the mandate to define signals that do support queuing. Any interpretation that
appears to preclude this is a mistake in the reading or writing of the standard.
Signals handled by realtime signal handlers might be generated by functions or conditions that do not allow the
specification of an application-defined value and do not queue. POSIX.1-2024 specifies the si_code member of the
siginfo_t structure used in existing practice and defines additional codes so that applications can detect whether an
application-defined value is present or not. The code SI_USER for kill()- generated
signals is adopted from existing practice.
The sigaction() sa_flags value SA_SIGINFO tells the
implementation that the signal-catching function expects two additional arguments. When the flag is not set, a single argument, the
signal number, is passed as specified by POSIX.1-2024. Although POSIX.1-2024 does not explicitly allow the info argument to
the handler function to be NULL, this is existing practice. This provides for compatibility with programs whose signal-catching
functions are not prepared to accept the additional arguments. POSIX.1-2024 is explicitly unspecified as to whether signals
actually queue when SA_SIGINFO is not set for a signal, as there appear to be no benefits to applications in specifying one
behavior or another. One existing implementation queues a siginfo_t on each signal generation, unless the signal is already
pending, in which case the implementation discards the new siginfo_t; that is, the queue length is never greater than one.
This implementation only examines SA_SIGINFO on signal delivery, discarding the queued siginfo_t if its delivery was not
requested.
The third argument to the signal-catching function, context, is left undefined by POSIX.1-2024, but is
specified in the interface because it matches existing practice for the SA_SIGINFO flag. It was considered undesirable to require a
separate implementation for SA_SIGINFO for POSIX conformance on implementations that already support the two additional
parameters.
The requirement to deliver lower numbered signals in the range SIGRTMIN to SIGRTMAX first, when multiple unblocked
signals are pending, results from several considerations:
A method is required to prioritize event notifications. The signal number was chosen instead of, for instance,
associating a separate priority with each request, because an implementation has to check pending signals at various points and
select one for delivery when more than one is pending. Specifying a selection order is the minimal additional semantic that will
achieve prioritized delivery. If a separate priority were to be associated with queued signals, it would be necessary for an
implementation to search all non-empty, non-blocked signal queues and select from among them the pending signal with the highest
priority. This would significantly increase the cost of and decrease the determinism of signal delivery.
Given the specified selection of the lowest numeric unblocked pending signal, preemptive priority signal delivery
can be achieved using signal numbers and signal masks by ensuring that the sa_mask for each signal number blocks all signals
with a higher numeric value.
For realtime applications that want to use only the newly defined realtime signal numbers without interference from
the standard signals, this can be achieved by blocking all of the standard signals in the thread signal mask and in the
sa_mask installed by the signal action for the realtime signal handlers.
POSIX.1-2024 explicitly leaves unspecified the ordering of signals outside of the range of realtime signals and the
ordering of signals within this range with respect to those outside the range. It was believed that this would unduly constrain
implementations or standards in the future definition of new signals.
Austin Group Defect 633 is applied, reducing to two the allowed behaviors for the signal mask of the thread that is
created to handle a SIGEV_THREAD notification.
Austin Group Defect 1116 is applied, removing a reference to the Realtime Signals Extension option that existed in
earlier versions of this standard.
B.2.4.3 Signal Actions
Early proposals mentioned SIGCONT as a second exception to the rule that signals are not delivered to stopped
processes until continued. Because POSIX.1-2024 now specifies that SIGCONT causes the stopped process to continue when it is
generated, delivery of SIGCONT is not prevented because a process is stopped, even without an explicit exception to this rule.
Ignoring a signal by setting the action to SIG_IGN (or SIG_DFL for signals whose default action is to ignore) is
not the same as installing a signal-catching function that simply returns. Invoking such a function will interrupt certain system
functions that block processes (for example, wait(), sigsuspend(), pause(), read(), write()) while ignoring a signal has no
such effect on the process.
Historical implementations discard pending signals when the action is set to SIG_IGN. However, they do not always
do the same when the action is set to SIG_DFL and the default action is to ignore the signal. POSIX.1-2024 requires this for the
sake of consistency and also for completeness, since the only signal this applies to is SIGCHLD, and POSIX.1-2024 disallows setting
its action to SIG_IGN.
Some implementations (System V, for example) assign different semantics for SIGCLD depending on whether the
action is set to SIG_IGN or SIG_DFL. Since POSIX.1 requires that the default action for SIGCHLD be to ignore the signal,
applications should always set the action to SIG_DFL in order to avoid SIGCHLD.
Whether or not an implementation allows SIG_IGN as a SIGCHLD disposition to be inherited across a call to one of
the exec family of functions or posix_spawn() is explicitly left as
unspecified. This change was made as a result of IEEE PASC Interpretation 1003.1 #132, and permits the implementation to decide
between the following alternatives:
Unconditionally leave SIGCHLD set to SIG_IGN, in which case the implementation would not allow applications that
assume inheritance of SIG_DFL to conform to POSIX.1-2024 without change. The implementation would, however, retain an ability to
control applications that create child processes but never call on the wait family of functions, potentially filling up the
process table.
Unconditionally reset SIGCHLD to SIG_DFL, in which case the implementation would allow applications that assume
inheritance of SIG_DFL to conform. The implementation would, however, lose an ability to control applications that spawn child
processes but never reap them.
Provide some mechanism, not specified in POSIX.1-2024, to control inherited SIGCHLD dispositions.
Some implementations (System V, for example) will deliver a SIGCLD signal immediately when a process
establishes a signal-catching function for SIGCLD when that process has a child that has already terminated. Other implementations,
such as 4.3 BSD, do not generate a new SIGCHLD signal in this way. In general, a process should not attempt to alter the signal
action for the SIGCHLD signal while it has any outstanding children. However, it is not always possible for a process to avoid
this; for example, shells sometimes start up processes in pipelines with other processes from the pipeline as children. Processes
that cannot ensure that they have no children when altering the signal action for SIGCHLD thus need to be prepared for, but not
depend on, generation of an immediate SIGCHLD signal.
The default action of the stop signals (SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU) is to stop a process that is executing.
If a stop signal is delivered to a process that is already stopped, it has no effect. In fact, if a stop signal is generated for a
stopped process whose signal mask blocks the signal, the signal will never be delivered to the process since the process must
receive a SIGCONT, which discards all pending stop signals, in order to continue executing.
The SIGCONT signal continues a stopped process even if SIGCONT is blocked (or ignored). However, if a
signal-catching routine has been established for SIGCONT, it will not be entered until SIGCONT is unblocked.
If a process in an orphaned process group stops, it is no longer under the control of a job control shell and hence
would not normally ever be continued. Because of this, orphaned processes that receive terminal-related stop signals (SIGTSTP,
SIGTTIN, SIGTTOU, but not SIGSTOP) must not be allowed to stop. The goal is to prevent stopped processes from languishing forever.
(As SIGSTOP is sent only via kill(), it is assumed that the process or user sending a
SIGSTOP can send a SIGCONT when desired.) Instead, the system must discard the stop signal. As an extension, it may also deliver
another signal in its place. 4.3 BSD sends a SIGKILL, which is overly effective because SIGKILL is not catchable. Another possible
choice is SIGHUP. 4.3 BSD also does this for orphaned processes (processes whose parent has terminated) rather than for members of
orphaned process groups; this is less desirable because job control shells manage process groups. POSIX.1 also prevents SIGTTIN and
SIGTTOU signals from being generated for processes in orphaned process groups as a direct result of activity on a terminal,
preventing infinite loops when read() and write() calls generate signals that are discarded; see A.11.1.4 Terminal Access Control. A similar restriction on the generation
of SIGTSTP was considered, but that would be unnecessary and more difficult to implement due to its asynchronous nature.
Although POSIX.1 requires that signal-catching functions be called with only one argument, there is nothing to
prevent conforming implementations from extending POSIX.1 to pass additional arguments, as long as Strictly Conforming POSIX.1
Applications continue to compile and execute correctly. Most historical implementations do, in fact, pass additional,
signal-specific arguments to certain signal-catching routines.
There was a proposal to change the declared type of the signal handler to:
void func (int sig, ...);
The usage of ellipses ("...") is ISO C standard syntax to indicate a variable number of arguments.
Its use was intended to allow the implementation to pass additional information to the signal handler in a standard manner.
Unfortunately, this construct would require all signal handlers to be defined with this syntax because the
ISO C standard allows implementations to use a different parameter passing mechanism for variable parameter lists than for
non-variable parameter lists. Thus, all existing signal handlers in all existing applications would have to be changed to use the
variable syntax in order to be standard and portable. This is in conflict with the goal of Minimal Changes to Existing Application
Code.
When terminating a process from a signal-catching function, processes should be aware of any interpretation that
their parent may make of the status returned by wait(), waitid(), or waitpid(). In particular, a
signal-catching function should not call exit(0) or _exit(0) unless it wants to indicate successful termination. A
non-zero argument to exit() or _exit() can
be used to indicate unsuccessful termination. Alternatively, the process can use kill()
to send itself a fatal signal (first ensuring that the signal is set to the default action and not blocked). See also the RATIONALE
section of the _exit() function.
The behavior of unsafe functions, as defined by this section, is undefined when they are called from (or
after a longjmp() or siglongjmp()
out of) signal-catching functions in certain circumstances. The behavior of async-signal-safe functions, as defined by this
section, is as specified by POSIX.1, regardless of invocation from a signal-catching function. This is the only intended meaning of
the statement that async-signal-safe functions may be used in signal-catching functions without restriction. Applications must
still consider all effects of such functions on such things as data structures, files, and process state. In particular,
application developers need to consider the restrictions on interactions when interrupting sleep() (see sleep()) and interactions among
multiple handles for a file description. The fact that any specific function is listed as async-signal-safe does not necessarily
mean that invocation of that function from a signal-catching function is recommended.
In order to prevent errors arising from interrupting non-async-signal-safe function calls, applications should
protect calls to these functions either by blocking the appropriate signals or through the use of some programmatic semaphore.
POSIX.1 does not address the more general problem of synchronizing access to shared data structures. Note in particular that even
the "safe" functions may modify the global variable errno; the signal-catching function may want to save and restore its
value. The same principles apply to the async-signal-safety of application routines and asynchronous data access.
Note that although longjmp() and siglongjmp() are in the list of async-signal-safe functions, there are restrictions on
subsequent behavior after the function is called from a signal-catching function. This is because the code executing after longjmp() or siglongjmp() can call any
unsafe functions with the same danger as calling those unsafe functions directly from the signal handler. Applications that use
longjmp() or siglongjmp() out of
signal handlers require rigorous protection in order to be portable. Many of the other functions that are excluded from the list
are traditionally implemented using either the C language malloc() or free() functions or the ISO C standard I/O library, both of which traditionally use data
structures in a non-async-signal-safe manner. Because any combination of different functions using a common data structure can
cause async-signal-safety problems, POSIX.1 does not define the behavior when any unsafe function is called in (or after a longjmp() or siglongjmp() out of) a signal
handler that interrupts any unsafe function or the non-async-signal-safe processing equivalent to exit() that is performed after return from the initial call to main().
The only realtime extension to signal actions is the addition of the additional parameters to the signal-catching
function. This extension has been explained and motivated in the previous section. In making this extension, though, developers of
POSIX.1b ran into issues relating to function prototypes. In response to input from the POSIX.1 standard developers, members were
added to the sigaction structure to specify function prototypes for the newer signal-catching function specified by
POSIX.1b. These members follow changes that are being made to POSIX.1. Note that POSIX.1-2024 explicitly states that these fields
may overlap so that a union can be defined. This enabled existing implementations of POSIX.1 to maintain binary-compatibility when
these extensions were added.
The siginfo_t structure was adopted for passing the application-defined value to match existing practice,
but the existing practice has no provision for an application-defined value, so this was added. Note that POSIX normally reserves
the "_t" type designation for opaque types. The siginfo_t structure breaks with this convention to follow existing
practice and thus promote portability.
POSIX.1-2024 specifies several values for the si_code member of the siginfo_t structure. Some were
introduced in POSIX.1b; others were XSI functionality in the Single UNIX Specification, Version 2 and Version 3, that has now
become Base functionality. Historically, an si_code value of less than or equal to zero indicated that the signal was
generated by a process via the kill() function, and values of si_code that
provided additional information for implementation-generated signals, such as SIGFPE or SIGSEGV, were all positive. This
functionality is partially specified for XSI systems in that if si_code is less than or equal to zero, the signal was
generated by a process. However, since POSIX.1b did not specify that SI_USER (or SI_QUEUE) had a value less than or equal to zero,
it is not true that when the signal is generated by a process, the value of si_code will always be less than or equal to
zero. XSI applications should check whether si_code is SI_USER or SI_QUEUE in addition to checking whether it is less than
or equal to zero. Applications on systems that do not support the XSI option should just check for SI_USER and SI_QUEUE.
If an implementation chooses to define additional values for si_code, these values have to be different from
the values of the non-signal-specific symbols specified by POSIX.1-2024. This will allow conforming applications to differentiate
between signals generated by standard events and those generated by other implementation events in a manner compatible with
existing practice.
The unique values of si_code for the POSIX.1b asynchronous events have implications for implementations of,
for example, asynchronous I/O or message passing in user space library code. Such an implementation will be required to provide a
hidden interface to the signal generation mechanism that allows the library to specify the standard values of si_code.
POSIX.1-2024 also specifies additional members of siginfo_t, beyond those that were in POSIX.1b. Like the
si_code values mentioned above, these were XSI functionality in the Single UNIX Specification, Version 2 and Version 3, that
has now become Base functionality. They provide additional information when si_code has one of the values that moved from
XSI to Base.
Although it is not explicitly visible to applications, there are additional semantics for signal actions implied by
queued signals and their interaction with other POSIX.1b realtime functions. Specifically:
It is not necessary to queue signals whose action is SIG_IGN.
For implementations that support POSIX.1b timers, some interaction with the timer functions at signal delivery is
implied to manage the timer overrun count.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/5 is applied, reordering the RTS shaded text under
the third and fourth paragraphs of the SIG_DFL description. This corrects an earlier editorial error in this section.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/6 is applied, adding the abort() function to the list of async-signal-safe functions.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/4 is applied, adding the sockatmark() function to the list of async-signal-safe functions.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0011 [690], XSH/TC2-2008/0012 [516], XSH/TC2-2008/0013 [692],
XSH/TC2-2008/0014 [615], XSH/TC2-2008/0015 [516], and XSH/TC2-2008/0016 [807] are applied.
Austin Group Defect 62 is applied, adding the _Fork() function to, and
removing the fork() function from, the list of async-signal-safe functions.
Austin Group Defect 162 is applied, adding functions from the  header to the list of async-signal-safe functions.
Austin Group Defect 411 is applied, adding accept4(), dup3(), and pipe2() to the list of
async-signal-safe functions.
Austin Group Defect 614 is applied, adding posix_close() to the
list of async-signal-safe functions.
Austin Group Defect 699 is applied, adding setegid(), seteuid(), setregid(), and setreuid() to the list of async-signal-safe functions.
Austin Group Defect 711 is applied, adding va_arg(), va_copy(), va_end(), and va_start() to the list of async-signal-safe functions and updating related text to apply to
function-like macros.
Austin Group Defect 728 is applied, reducing the set of circumstances in which undefined behavior results when a
signal handler refers to an object with static or thread storage duration.
Austin Group Defect 841 is applied, adding pthread_setcancelstate() to the list of async-signal-safe functions and
making it implementation-defined which additional interfaces are also async-signal-safe.
Austin Group Defect 986 is applied, adding strlcat(), strlcpy(), wcslcat(), and wcslcpy() to the list of async-signal-safe functions.
Austin Group Defect 1138 is applied, adding the sig2str() function
to the list of async-signal-safe functions.
Austin Group Defect 1141 is applied, changing "core file" to "core image".
Austin Group Defects 1142, 1455, and 1625 are applied, adding the pread(), pwrite(), readv(), waitid(), and writev() functions to the list of async-signal-safe functions.
Austin Group Defect 1151 is applied, adding the tcgetwinsize()
and tcsetwinsize() functions to the list of async-signal-safe functions.
Austin Group Defect 1215 is applied, removing XSI shading from text relating to abnormal process termination with
additional actions.
Austin Group Defect 1263 is applied, adding the ppoll() function to
the list of async-signal-safe functions.
Austin Group Defect 1302 is applied, aligning this section with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1667 is applied, adding getresgid(), getresuid(), setresgid(), and setresuid() to the list of async-signal-safe functions.
Austin Group Defect 1744 is applied, adding killpg() to the list of
async-signal-safe functions.
B.2.4.4 Signal Effects on Other Functions
The most common behavior of an interrupted function after a signal-catching function returns is for the interrupted
function to give an [EINTR] error unless the SA_RESTART flag is in effect for the signal. However, there are a number of specific
exceptions, including sleep() and certain situations with read() and write().
The historical implementations of many functions defined by POSIX.1-2024 are not interruptible, but delay delivery
of signals generated during their execution until after they complete. This is never a problem for functions that are guaranteed to
complete in a short (imperceptible to a human) period of time. It is normally those functions that can suspend a process
indefinitely or for long periods of time (for example, wait(), pause(), sigsuspend(), sleep(), or read()/write() on a slow device like a terminal) that are interruptible. This permits applications to
respond to interactive signals or to set timeouts on calls to most such functions with alarm(). Therefore, implementations should generally make such functions (including ones
defined as extensions) interruptible.
Functions not mentioned explicitly as interruptible may be so on some implementations, possibly as an extension
where the function gives an [EINTR] error. There are several functions (for example, getpid(), getuid()) that are specified as never
returning an error, which can thus never be extended in this way.
If a signal-catching function returns while the SA_RESTART flag is in effect, an interrupted function is restarted
at the point it was interrupted. Conforming applications cannot make assumptions about the internal behavior of interrupted
functions, even if the functions are async-signal-safe. For example, suppose the read()
function is interrupted with SA_RESTART in effect, the signal-catching function closes the file descriptor being read from and
returns, and the read() function is then restarted; in this case the application cannot
assume that the read() function will give an [EBADF] error, since read() might have checked the file descriptor for validity before being interrupted.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0017 [807] is applied.
B.2.5 Standard I/O Streams
Although the ISO C standard guarantees that, at program start-up, stdin is open for reading and
stdout and stderr are open for writing, this guarantee is contingent (as are all guarantees made by the ISO C
and POSIX standards) on the program being executed in a conforming environment. Programs executed with file descriptor 0 not open
for reading or with file descriptor 1 or 2 not open for writing are executed in a non-conforming environment. Application writers
are warned (in exec, posix_spawn(), and C.2.7
Redirection) not to execute a standard utility or a conforming application with file descriptor 0 not open for reading or
with file descriptor 1 or 2 not open for writing.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0018 [608] is applied.
Austin Group Defect 689 is applied, clarifying the handling of deadlock situations when locking a stream.
Austin Group Defect 1144 is applied, clarifying the effect of setvbuf() on memory streams.
Austin Group Defect 1153 is applied, clarifying that the behavior is undefined if a memory buffer associated with a
standard I/O stream overlaps with the destination buffer of a call that reads from the stream or with the source buffer of a call
that writes to the stream.
Austin Group Defect 1302 is applied, aligning this section with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1347 is applied, clarifying the requirements for how stderr, stdin, and
stdout are opened at program start-up.
B.2.5.1 Interaction of File Descriptors and Standard I/O
Streams
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0019 [480] is applied.
Austin Group Defect 1183 is applied, changing "non-full" to "non-null".
Austin Group Defect 1318 is applied, changing the list of functions that close file descriptors.
B.2.5.2 Stream Orientation and Encoding Rules
Austin Group Defect 1040 is applied, clarifying that conversion to or from (possibly multi-byte) characters is not
performed by wide character I/O functions when the stream was opened using open_wmemstream().
B.2.6 File Descriptor Allocation
Functions such as pipe() and socketpair() which allocate two file descriptors are permitted to perform the two
allocations independently. This means that other threads or signal handlers may perform operations on file descriptors in between
the two allocations and this can result in the two file descriptors not having adjacent values or in the second allocation
producing a lower value than the first.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0032 [835] is applied.
B.2.7 XSI Interprocess Communication
There are two forms of IPC supported as options in POSIX.1-2024. The traditional System V IPC routines derived
from the SVID—that is, the msg*(), sem*(), and shm*() interfaces—are mandatory on XSI-conformant systems.
Thus, all XSI-conformant systems provide the same mechanisms for manipulating messages, shared memory, and semaphores.
In addition, the POSIX Realtime Extension provides an alternate set of routines for those systems supporting the
appropriate options.
The application developer is presented with a choice: the System V interfaces or the POSIX interfaces (loosely
derived from the Berkeley interfaces). The XSI profile prefers the System V interfaces, but the POSIX interfaces may be more
suitable for realtime or other performance-sensitive applications.
B.2.7.1 IPC General Description
General information that is shared by all three mechanisms is described in this section. The common permissions
mechanism is briefly introduced, describing the mode bits, and how they are used to determine whether or not a process has access
to read or write/alter the appropriate instance of one of the IPC mechanisms. All other relevant information is contained in the
reference pages themselves.
The semaphore type of IPC allows processes to communicate through the exchange of semaphore values. A semaphore is
a positive integer. Since many applications require the use of more than one semaphore, XSI-conformant systems have the ability to
create sets or arrays of semaphores.
Calls to support semaphores include:
semctl(), semget(),
semop()
Semaphore sets are created by using the semget() function.
The message type of IPC allows processes to communicate through the exchange of data stored in buffers. This data
is transmitted between processes in discrete portions known as messages.
Calls to support message queues include:
msgctl(), msgget(),
msgrcv(), msgsnd()
The shared memory type of IPC allows two or more processes to share memory and consequently the data contained
therein. This is done by allowing processes to set up access to a common memory address space. This sharing of memory provides a
fast means of exchange of data between processes.
Calls to support shared memory include:
shmctl(), shmdt(), shmget()
The ftok() interface is also provided.
Austin Group Defect 377 is applied, changing the table giving the values for the mode member of the
ipc_perm structure.
B.2.8 Realtime
Advisory Information
POSIX.1b contains an Informative Annex with proposed interfaces for "realtime files". These interfaces could
determine groups of the exact parameters required to do "direct I/O" or "extents". These interfaces were objected to by a
significant portion of the balloting group as too complex. A conforming application had little chance of correctly navigating the
large parameter space to match its desires to the system. In addition, they only applied to a new type of file (realtime files) and
they told the implementation exactly what to do as opposed to advising the implementation on application behavior and letting it
optimize for the system the (portable) application was running on. For example, it was not clear how a system that had a disk array
should set its parameters.
There seemed to be several overall goals:
Optimizing sequential access
Optimizing caching behavior
Optimizing I/O data transfer
Preallocation
The advisory interfaces, posix_fadvise() and posix_madvise(), satisfy the first two goals. The POSIX_FADV_SEQUENTIAL and
POSIX_MADV_SEQUENTIAL advice tells the implementation to expect serial access. Typically the system will prefetch the next several
serial accesses in order to overlap I/O. It may also free previously accessed serial data if memory is tight. If the application is
not doing serial access it can use POSIX_FADV_WILLNEED and POSIX_MADV_WILLNEED to accomplish I/O overlap, as required. When the
application advises POSIX_FADV_RANDOM or POSIX_MADV_RANDOM behavior, the implementation usually tries to fetch a minimum amount of
data with each request and it does not expect much locality. POSIX_FADV_DONTNEED and POSIX_MADV_DONTNEED allow the system to free
up caching resources as the data will not be required in the near future.
POSIX_FADV_NOREUSE tells the system that caching the specified data is not optimal. For file I/O, the transfer
should go directly to the user buffer instead of being cached internally by the implementation. To portably perform direct disk I/O
on all systems, the application must perform its I/O transfers according to the following rules:
The user buffer should be aligned according to the {POSIX_REC_XFER_ALIGN} pathconf() variable.
The number of bytes transferred in an I/O operation should be a multiple of the {POSIX_ALLOC_SIZE_MIN} pathconf() variable.
The offset into the file at the start of an I/O operation should be a multiple of the {POSIX_ALLOC_SIZE_MIN}
pathconf() variable.
The application should ensure that all threads which open a given file specify POSIX_FADV_NOREUSE to be sure that
there is no unexpected interaction between threads using buffered I/O and threads using direct I/O to the same file.
In some cases, a user buffer must be properly aligned in order to be transferred directly to/from the device. The
{POSIX_REC_XFER_ALIGN} pathconf() variable tells the application the proper
alignment.
The preallocation goal is met by the space control function, posix_fallocate(). The application can use posix_fallocate() to guarantee no [ENOSPC] errors and to improve performance by
prepaying any overhead required for block allocation.
Implementations may use information conveyed by a previous posix_fadvise() call to influence the manner in which allocation is performed. For
example, if an application did the following calls:
fd = open("file");
posix_fadvise(fd, offset, len, POSIX_FADV_SEQUENTIAL);
posix_fallocate(fd, len, size);
an implementation might allocate the file contiguously on disk.
Finally, the pathconf() variables {POSIX_REC_MIN_XFER_SIZE},
{POSIX_REC_MAX_XFER_SIZE}, and {POSIX_REC_INCR_XFER_SIZE} tell the application a range of transfer sizes that are recommended for
best I/O performance.
Where bounded response time is required, the vendor can supply the appropriate settings of the advisories to
achieve a guaranteed performance level.
The interfaces meet the goals while allowing applications using regular files to take advantage of performance
optimizations. The interfaces tell the implementation expected application behavior which the implementation can use to optimize
performance on a particular system with a particular dynamic load.
The posix_memalign() function was added to allow for the
allocation of specifically aligned buffers; for example, for {POSIX_REC_XFER_ALIGN}.
The working group also considered the alternative of adding a function which would return an aligned pointer to
memory within a user-supplied buffer. This was not considered to be the best method, because it potentially wastes large amounts of
memory when buffers need to be aligned on large alignment boundaries.
Message Passing
This section provides the rationale for the definition of the message passing interface in POSIX.1-2024. This is
presented in terms of the objectives, models, and requirements imposed upon this interface.
Objectives
Many applications, including both realtime and database applications, require a means of passing arbitrary amounts
of data between cooperating processes comprising the overall application on one or more processors. Many conventional interfaces
for interprocess communication are insufficient for realtime applications in that efficient and deterministic data passing methods
cannot be implemented. This has prompted the definition of message passing interfaces providing these facilities:
Open a message queue.
Send a message to a message queue.
Receive a message from a queue, either synchronously or asynchronously.
Alter message queue attributes for flow and resource control.
It is assumed that an application may consist of multiple cooperating processes and that these processes may wish
to communicate and coordinate their activities. The message passing facility described in POSIX.1-2024 allows processes to
communicate through system-wide queues. These message queues are accessed through names that may be pathnames. A message queue can
be opened for use by multiple sending and/or multiple receiving processes.
Background on Embedded Applications
Interprocess communication utilizing message passing is a key facility for the construction of deterministic,
high-performance realtime applications. The facility is present in all realtime systems and is the framework upon which the
application is constructed. The performance of the facility is usually a direct indication of the performance of the resulting
application.
Realtime applications, especially for embedded systems, are typically designed around the performance constraints
imposed by the message passing mechanisms. Applications for embedded systems are typically very tightly constrained. Application
developers expect to design and control the entire system. In order to minimize system costs, the writer will attempt to use all
resources to their utmost and minimize the requirement to add additional memory or processors.
The embedded applications usually share address spaces and only a simple message passing mechanism is required. The
application can readily access common data incurring only mutual-exclusion overheads. The models desired are the simplest possible
with the application building higher-level facilities only when needed.
Requirements
The following requirements determined the features of the message passing facilities defined in POSIX.1-2024:
Naming of Message Queues
The mechanism for gaining access to a message queue is a pathname evaluated in a context that is allowed to be a
file system name space, or it can be independent of any file system. This is a specific attempt to allow implementations based on
either method in order to address both embedded systems and to also allow implementation in larger systems.
The interface of mq_open() is defined to allow but not require the
access control and name conflicts resulting from utilizing a file system for name resolution. All required behavior is specified
for the access control case. Yet a conforming implementation, such as an embedded system kernel, may define that there are no
distinctions between users and may define that all processes have all access privileges.
Embedded System Naming
Embedded systems need to be able to utilize independent name spaces for accessing the various system objects. They
typically do not have a file system, precluding its utilization as a common name resolution mechanism. The modularity of an
embedded system limits the connections between separate mechanisms that can be allowed.
Embedded systems typically do not have any access protection. Since the system does not support the mixing of
applications from different areas, and usually does not even have the concept of an authorization entity, access control is not
useful.
Large System Naming
On systems with more functionality, the name resolution must support the ability to use the file system as the name
resolution mechanism/object storage medium and to have control over access to the objects. Utilizing the pathname space can result
in further errors when the names conflict with other objects.
Fixed Size of Messages
The interfaces impose a fixed upper bound on the size of messages that can be sent to a specific message queue. The
size is set on an individual queue basis and cannot be changed dynamically.
The purpose of the fixed size is to increase the ability of the system to optimize the implementation of mq_send() and mq_receive(). With fixed
sizes of messages and fixed numbers of messages, specific message blocks can be pre-allocated. This eliminates a significant amount
of checking for errors and boundary conditions. Additionally, an implementation can optimize data copying to maximize performance.
Finally, with a restricted range of message sizes, an implementation is better able to provide deterministic operations.
Prioritization of Messages
Message prioritization allows the application to determine the order in which messages are received. Prioritization
of messages is a key facility that is provided by most realtime kernels and is heavily utilized by the applications. The major
purpose of having priorities in message queues is to avoid priority inversions in the message system, where a high-priority message
is delayed behind one or more lower-priority messages. This allows the applications to be designed so that they do not need to be
interrupted in order to change the flow of control when exceptional conditions occur. The prioritization does add additional
overhead to the message operations, in those cases it is actually used, but a clever implementation can optimize for the FIFO case
to make that more efficient.
Asynchronous Notification
The interface supports the ability to have a task asynchronously notified of the availability of a message on the
queue. The purpose of this facility is to allow the task to perform other functions and yet still be notified that a message has
become available on the queue.
To understand the requirement for this function, it is useful to understand two models of application design: a
single task performing multiple functions and multiple tasks performing a single function. Each of these models has advantages.
Asynchronous notification is required to build the model of a single task performing multiple operations. This
model typically results from either the expectation that interruption is less expensive than utilizing a separate task or from the
growth of the application to include additional functions.
Semaphores
Semaphores are a high-performance process synchronization mechanism. Semaphores are named by null-terminated
strings of characters.
A semaphore is created using the sem_init() function or the
sem_open() function with the O_CREAT flag set in oflag.
To use a semaphore, a process has to first initialize the semaphore or inherit an open descriptor for the semaphore
via fork().
A semaphore preserves its state when the last reference is closed. For example, if a semaphore has a value of 13
when the last reference is closed, it will have a value of 13 when it is next opened.
When a semaphore is created, an initial state for the semaphore has to be provided. This value is a non-negative
integer. Negative values are not possible since they indicate the presence of blocked processes. The persistence of any of these
objects across a system crash or a system reboot is undefined. Conforming applications must not depend on any sort of persistence
across a system reboot or a system crash.
Models and Requirements
A realtime system requires synchronization and communication between the processes comprising the overall
application. An efficient and reliable synchronization mechanism has to be provided in a realtime system that will allow more than
one schedulable process mutually-exclusive access to the same resource. This synchronization mechanism has to allow for the optimal
implementation of synchronization or systems implementors will define other, more cost-effective methods.
At issue are the methods whereby multiple processes (tasks) can be designed and implemented to work together in
order to perform a single function. This requires interprocess communication and synchronization. A semaphore mechanism is the
lowest level of synchronization that can be provided by an operating system.
A semaphore is defined as an object that has an integral value and a set of blocked processes associated with it.
If the value is positive or zero, then the set of blocked processes is empty; otherwise, the size of the set is equal to the
absolute value of the semaphore value. The value of the semaphore can be incremented or decremented by any process with access to
the semaphore and must be done as an indivisible operation. When a semaphore value is less than or equal to zero, any process that
attempts to lock it again will block or be informed that it is not possible to perform the operation.
A semaphore may be used to guard access to any resource accessible by more than one schedulable task in the system.
It is a global entity and not associated with any particular process. As such, a method of obtaining access to the semaphore has to
be provided by the operating system. A process that wants access to a critical resource (section) has to wait on the semaphore that
guards that resource. When the semaphore is locked on behalf of a process, it knows that it can utilize the resource without
interference by any other cooperating process in the system. When the process finishes its operation on the resource, leaving it in
a well-defined state, it posts the semaphore, indicating that some other process may now obtain the resource associated with that
semaphore.
In this section, mutexes and condition variables are specified as the synchronization mechanisms between
threads.
These primitives are typically used for synchronizing threads that share memory in a single process. However, this
section provides an option allowing the use of these synchronization interfaces and objects between processes that share memory,
regardless of the method for sharing memory.
Much experience with semaphores shows that there are two distinct uses of synchronization: locking, which is
typically of short duration; and waiting, which is typically of long or unbounded duration. These distinct usages map directly onto
mutexes and condition variables, respectively.
Semaphores are provided in POSIX.1-2024 primarily to provide a means of synchronization for processes; these
processes may or may not share memory. Mutexes and condition variables are specified as synchronization mechanisms between threads;
these threads always share (some) memory. Both are synchronization paradigms that have been in widespread use for a number of
years. Each set of primitives is particularly well matched to certain problems.
With respect to binary semaphores, experience has shown that condition variables and mutexes are easier to use for
many synchronization problems than binary semaphores. The primary reason for this is the explicit appearance of a Boolean predicate
that specifies when the condition wait is satisfied. This Boolean predicate terminates a loop, including the call to pthread_cond_wait(). As a result, extra wakeups are benign since the predicate
governs whether the thread will actually proceed past the condition wait. With stateful primitives, such as binary semaphores, the
wakeup in itself typically means that the wait is satisfied. The burden of ensuring correctness for such waits is thus placed on
all signalers of the semaphore rather than on an explicitly coded Boolean predicate located at the condition wait.
Experience has shown that the latter creates a major improvement in safety and ease-of-use.
Counting semaphores are well matched to dealing with producer/consumer problems, including those that might exist
between threads of different processes, or between a signal handler and a thread. In the former case, there may be little or no
memory shared by the processes; in the latter case, one is not communicating between co-equal threads, but between a thread and an
interrupt-like entity. It is for these reasons that POSIX.1-2024 allows semaphores to be used by threads.
Mutexes and condition variables have been effectively used with and without priority inheritance, priority ceiling,
and other attributes to synchronize threads that share memory. The efficiency of their implementation is comparable to or better
than that of other synchronization primitives that are sometimes harder to use (for example, binary semaphores). Furthermore, there
is at least one known implementation of Ada tasking that uses these primitives. Mutexes and condition variables together constitute
an appropriate, sufficient, and complete set of inter-thread synchronization primitives.
Efficient multi-threaded applications require high-performance synchronization primitives. Considerations of
efficiency and generality require a small set of primitives upon which more sophisticated synchronization functions can be
built.
Standardization Issues
It is possible to implement very high-performance semaphores using test-and-set instructions on shared memory
locations. The library routines that implement such a high-performance interface have to properly ensure that a sem_wait() or sem_trywait() operation
that cannot be performed will issue a blocking semaphore system call or properly report the condition to the application. The same
interface to the application program would be provided by a high-performance implementation.
B.2.8.1 Realtime Signals
Realtime Signals Extension
This portion of the rationale presents models, requirements, and standardization issues relevant to the Realtime
Signals Extension. This extension provides the capability required to support reliable, deterministic, asynchronous notification of
events. While a new mechanism, unencumbered by the historical usage and semantics of POSIX.1 signals, might allow for a more
efficient implementation, the application requirements for event notification can be met with a small number of extensions to
signals. Therefore, a minimal set of extensions to signals to support the application requirements is specified.
The realtime signal extensions specified in this section are used by other realtime functions requiring
asynchronous notification:
Models
The model supported is one of multiple cooperating processes, each of which handles multiple asynchronous external
events. Events represent occurrences that are generated as the result of some activity in the system. Examples of occurrences that
can constitute an event include:
Completion of an asynchronous I/O request
Expiration of a POSIX.1b timer
Arrival of an interprocess message
Generation of a user-defined event
Processing of these events may occur synchronously via polling for event notifications or asynchronously via a
software interrupt mechanism. Existing practice for this model is well established for traditional proprietary realtime operating
systems, realtime executives, and realtime extended POSIX-like systems.
A contrasting model is that of "cooperating sequential processes" where each process handles a single priority of
events via polling. Each process blocks while waiting for events, and each process depends on the preemptive, priority-based
process scheduling mechanism to arbitrate between events of different priority that need to be processed concurrently. Existing
practice for this model is also well established for small realtime executives that typically execute in an unprotected physical
address space, but it is just emerging in the context of a fuller function operating system with multiple virtual address
spaces.
It could be argued that the cooperating sequential process model, and the facilities supported by the POSIX Threads
Extension obviate a software interrupt model. But, even with the cooperating sequential process model, the need has been recognized
for a software interrupt model to handle exceptional conditions and process aborting, so the mechanism must be supported in any
case. Furthermore, it is not the purview of POSIX.1-2024 to attempt to convince realtime practitioners that their current
application models based on software interrupts are "broken" and should be replaced by the cooperating sequential process model.
Rather, it is the charter of POSIX.1-2024 to provide standard extensions to mechanisms that support existing realtime practice.
Requirements
This section discusses the following realtime application requirements for asynchronous event notification:
Reliable delivery of asynchronous event notification
The events notification mechanism guarantees delivery of an event notification. Asynchronous operations (such as
asynchronous I/O and timers) that complete significantly after they are invoked have to guarantee that delivery of the event
notification can occur at the time of completion.
Prioritized handling of asynchronous event notifications
The events notification mechanism supports the assigning of a user function as an event notification handler.
Furthermore, the mechanism supports the preemption of an event handler function by a higher priority event notification and
supports the selection of the highest priority pending event notification when multiple notifications (of different priority) are
pending simultaneously.
The model here is based on hardware interrupts. Asynchronous event handling allows the application to ensure that
time-critical events are immediately processed when delivered, without the indeterminism of being at a random location within a
polling loop. Use of handler priority allows the specification of how handlers are interrupted by other higher priority
handlers.
Differentiation between multiple occurrences of event notifications of the same type
The events notification mechanism passes an application-defined value to the event handler function. This value can
be used for a variety of purposes, such as enabling the application to identify which of several possible events of the same type
(for example, timer expirations) has occurred.
Polled reception of asynchronous event notifications
The events notification mechanism supports blocking and non-blocking polls for asynchronous event notification.
The polled mode of operation is often preferred over the interrupt mode by those practitioners accustomed to this
model. Providing support for this model facilitates the porting of applications based on this model to POSIX.1b conforming
systems.
Deterministic response to asynchronous event notifications
The events notification mechanism does not preclude implementations that provide deterministic event dispatch
latency and minimizes the number of system calls needed to use the event facilities during realtime processing.
Rationale for Extension
POSIX.1 signals have many of the characteristics necessary to support the asynchronous handling of event
notifications, and the Realtime Signals Extension addresses the following deficiencies in the POSIX.1 signal mechanism:
Signals do not support reliable delivery of event notification. Subsequent occurrences of a pending signal are not
guaranteed to be delivered.
Signals do not support prioritized delivery of event notifications. The order of signal delivery when multiple
unblocked signals are pending is undefined.
Signals do not support the differentiation between multiple signals of the same type.
B.2.8.2 Asynchronous I/O
Many applications need to interact with the I/O subsystem in an asynchronous manner. The asynchronous I/O mechanism
provides the ability to overlap application processing and I/O operations initiated by the application. The asynchronous I/O
mechanism allows a single process to perform I/O simultaneously to a single file multiple times or to multiple files multiple
times.
Overview
Asynchronous I/O operations proceed in logical parallel with the processing done by the application after the
asynchronous I/O has been initiated. Other than this difference, asynchronous I/O behaves similarly to normal I/O using read(), write(), lseek(), and fsync(). The effect of issuing an
asynchronous I/O request is as if a separate thread of execution were to perform atomically the implied lseek() operation, if any, and then the requested I/O operation (either read(), write(), or fsync()). There is no seek implied with a call to aio_fsync(). Concurrent asynchronous operations and synchronous operations applied to the
same file update the file as if the I/O operations had proceeded serially.
When asynchronous I/O completes, a signal can be delivered to the application to indicate the completion of the
I/O. This signal can be used to indicate that buffers and control blocks used for asynchronous I/O can be reused. Signal delivery
is not required for an asynchronous operation and may be turned off on a per-operation basis by the application. Signals may also
be synchronously polled using aio_suspend(), sigtimedwait(), or sigwaitinfo().
Normal I/O has a return value and an error status associated with it. Asynchronous I/O returns a value and an error
status when the operation is first submitted, but that only relates to whether the operation was successfully queued up for
servicing. The I/O operation itself also has a return status and an error value. To allow the application to retrieve the return
status and the error value, functions are provided that, given the address of an asynchronous I/O control block, yield the return
and error status associated with the operation. Until an asynchronous I/O operation is done, its error status is [EINPROGRESS].
Thus, an application can poll for completion of an asynchronous I/O operation by waiting for the error status to become equal to a
value other than [EINPROGRESS]. The return status of an asynchronous I/O operation is undefined so long as the error status is
equal to [EINPROGRESS].
Storage for asynchronous operation return and error status may be limited. Submission of asynchronous I/O
operations may fail if this storage is exceeded. When an application retrieves the return status of a given asynchronous operation,
therefore, any system-maintained storage used for this status and the error status may be reclaimed for use by other asynchronous
operations.
Asynchronous I/O can be performed on file descriptors that have been enabled for POSIX.1b synchronized I/O. In this
case, the I/O operation still occurs asynchronously, as defined herein; however, the asynchronous operation I/O in this case is not
completed until the I/O has reached either the state of synchronized I/O data integrity completion or synchronized I/O file
integrity completion, depending on the sort of synchronized I/O that is enabled on the file descriptor.
Models
Three models illustrate the use of asynchronous I/O: a journalization model, a data acquisition model, and a model
of the use of asynchronous I/O in supercomputing applications.
Journalization Model
Many realtime applications perform low-priority journalizing functions. Journalizing requires that logging records
be queued for output without blocking the initiating process.
Data Acquisition Model
A data acquisition process may also serve as a model. The process has two or more channels delivering intermittent
data that must be read within a certain time. The process issues one asynchronous read on each channel. When one of the channels
needs data collection, the process reads the data and posts it through an asynchronous write to secondary memory for future
processing.
Supercomputing Model
The supercomputing community has used asynchronous I/O much like that specified in POSIX.1 for many years. This
community requires the ability to perform multiple I/O operations to multiple devices with a minimal number of entries to "the
system"; each entry to "the system" provokes a major delay in operations when compared to the normal progress made by the
application. This existing practice motivated the use of combined lseek() and read() or write() calls, as well as the lio_listio() call. Another common practice is to disable signal notification for I/O
completion, and simply poll for I/O completion at some interval by which the I/O should be completed. Likewise, interfaces like
aio_cancel() have been in successful commercial use for many years. Note also
that an underlying implementation of asynchronous I/O will require the ability, at least internally, to cancel outstanding
asynchronous I/O, at least when the process exits. (Consider an asynchronous read from a terminal, when the process intends to exit
immediately.)
Requirements
Asynchronous input and output for realtime implementations have these requirements:
The ability to queue multiple asynchronous read and write operations to a single open instance. Both sequential
and random access should be supported.
The ability to queue asynchronous read and write operations to multiple open instances.
The ability to obtain completion status information by polling and/or asynchronous event notification.
Asynchronous event notification on asynchronous I/O completion is optional.
It has to be possible for the application to associate the event with the aiocbp for the operation that
generated the event.
The ability to cancel queued requests.
The ability to wait upon asynchronous I/O completion in conjunction with other types of events.
The ability to accept an aio_read() and an aio_cancel() for a device that accepts a read(), and the ability to accept an aio_write() and an aio_cancel() for a
device that accepts a write(). This does not imply that the operation is
asynchronous.
Standardization Issues
The following issues are addressed by the standardization of asynchronous I/O:
Rationale for New Interface
Non-blocking I/O does not satisfy the needs of either realtime or high-performance computing models; these models
require that a process overlap program execution and I/O processing. Realtime applications will often make use of direct I/O to or
from the address space of the process, or require synchronized (unbuffered) I/O; they also require the ability to overlap this I/O
with other computation. In addition, asynchronous I/O allows an application to keep a device busy at all times, possibly achieving
greater throughput. Supercomputing and database architectures will often have specialized hardware that can provide true asynchrony
underlying the logical asynchrony provided by this interface. In addition, asynchronous I/O should be supported by all types of
files and devices in the same manner.
Effect of Buffering
If asynchronous I/O is performed on a file that is buffered prior to being actually written to the device, it is
possible that asynchronous I/O will offer no performance advantage over normal I/O; the cycles stolen to perform the
asynchronous I/O will be taken away from the running process and the I/O will occur at interrupt time. This potential lack of gain
in performance in no way obviates the need for asynchronous I/O by realtime applications, which very often will use specialized
hardware support, multiple processors, and/or unbuffered, synchronized I/O.
B.2.8.3 Memory Management
All memory management and shared memory definitions are located in the  header. This is for alignment with historical practice.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/7 is applied, correcting the shading and margin
markers in the introduction to Section 2.8.3.1.
Memory Locking Functions
This portion of the rationale presents models, requirements, and standardization issues relevant to process memory
locking.
Models
Realtime systems that conform to POSIX.1-2024 are expected (and desired) to be supported on systems with
demand-paged virtual memory management, non-paged swapping memory management, and physical memory systems with no memory management
hardware. The general case, however, is the demand-paged, virtual memory system with each POSIX process running in a virtual
address space. Note that this includes architectures where each process resides in its own virtual address space and architectures
where the address space of each process is only a portion of a larger global virtual address space.
The concept of memory locking is introduced to eliminate the indeterminacy introduced by paging and swapping, and
to support an upper bound on the time required to access the memory mapped into the address space of a process. Ideally, this upper
bound will be the same as the time required for the processor to access "main memory", including any address translation and
cache miss overheads. But some implementations—primarily on mainframes—will not actually force locked pages to be loaded and held
resident in main memory. Rather, they will handle locked pages so that accesses to these pages will meet the performance metrics
for locked process memory in the implementation. Also, although it is not, for example, the intention that this interface, as
specified, be used to lock process memory into "cache", it is conceivable that an implementation could support a large static RAM
memory and define this as "main memory" and use a large[r] dynamic RAM as "backing store". These interfaces could then be
interpreted as supporting the locking of process memory into the static RAM. Support for multiple levels of backing store would
require extensions to these interfaces.
Implementations may also use memory locking to guarantee a fixed translation between virtual and physical addresses
where such is beneficial to improving determinacy for direct-to/from-process input/output. POSIX.1-2024 does not guarantee to the
application that the virtual-to-physical address translations, if such exist, are fixed, because such behavior would not be
implementable on all architectures on which implementations of POSIX.1-2024 are expected. But POSIX.1-2024 does mandate that an
implementation define, for the benefit of potential users, whether or not locking guarantees fixed translations.
Memory locking is defined with respect to the address space of a process. Only the pages mapped into the address
space of a process may be locked by the process, and when the pages are no longer mapped into the address space—for whatever
reason—the locks established with respect to that address space are removed. Shared memory areas warrant special mention, as they
may be mapped into more than one address space or mapped more than once into the address space of a process; locks may be
established on pages within these areas with respect to several of these mappings. In such a case, the lock state of the underlying
physical pages is the logical OR of the lock state with respect to each of the mappings. Only when all such locks have been removed
are the shared pages considered unlocked.
In recognition of the page granularity of Memory Management Units (MMU), and in order to support locking of ranges
of address space, memory locking is defined in terms of "page" granularity. That is, for the interfaces that support an address
and size specification for the region to be locked, the address must be on a page boundary, and all pages mapped by the specified
range are locked, if valid. This means that the length is implicitly rounded up to a multiple of the page size. The page size is
implementation-defined and is available to applications as a compile-time symbolic constant or at runtime via sysconf().
A "real memory" POSIX.1b implementation that has no MMU could elect not to support these interfaces, returning
[ENOSYS]. But an application could easily interpret this as meaning that the implementation would unconditionally page or swap the
application when such is not the case. It is the intention of POSIX.1-2024 that such a system could define these interfaces as
"NO-OPs", returning success without actually performing any function except for mandated argument checking.
Requirements
For realtime applications, memory locking is generally considered to be required as part of application
initialization. This locking is performed after an application has been loaded (that is, exec'd) and the program remains
locked for its entire lifetime. But to support applications that undergo major mode changes where, in one mode, locking is
required, but in another it is not, the specified interfaces allow repeated locking and unlocking of memory within the lifetime of
a process.
When a realtime application locks its address space, it should not be necessary for the application to then
"touch" all of the pages in the address space to guarantee that they are resident or else suffer potential paging delays the
first time the page is referenced. Thus, POSIX.1-2024 requires that the pages locked by the specified interfaces be resident when
the locking functions return successfully.
Many architectures support system-managed stacks that grow automatically when the current extent of the stack is
exceeded. A realtime application has a requirement to be able to "preallocate" sufficient stack space and lock it down so that it
will not suffer page faults to grow the stack during critical realtime operation. There was no consensus on a portable way to
specify how much stack space is needed, so POSIX.1-2024 supports no specific interface for preallocating stack space. But an
application can portably lock down a specific amount of stack space by specifying MCL_FUTURE in a call to mlockall() and then calling a dummy function that declares an automatic array of the
desired size.
Memory locking for realtime applications is also generally considered to be an "all or nothing" proposition. That
is, the entire process, or none, is locked down. But, for applications that have well-defined sections that need to be locked and
others that do not, POSIX.1-2024 supports an optional set of interfaces to lock or unlock a range of process addresses. Reasons for
locking down a specific range include:
An asynchronous event handler function that must respond to external events in a deterministic manner such that
page faults cannot be tolerated
An input/output "buffer" area that is the target for direct-to-process I/O, and the overhead of implicit locking
and unlocking for each I/O call cannot be tolerated
Finally, locking is generally viewed as an "application-wide" function. That is, the application is globally
aware of which regions are locked and which are not over time. This is in contrast to a function that is used temporarily within a
"third party" library routine whose function is unknown to the application, and therefore must have no "side-effects". The
specified interfaces, therefore, do not support "lock stacking" or "lock nesting" within a process. But, for pages that are
shared between processes or mapped more than once into a process address space, "lock stacking" is essentially mandated by the
requirement that unlocking of pages that are mapped by more that one process or more than once by the same process does not affect
locks established on the other mappings.
There was some support for "lock stacking" so that locking could be transparently used in functions or opaque
modules. But the consensus was not to burden all implementations with lock stacking (and reference counting), and an implementation
option was proposed. There were strong objections to the option because applications would have to support both options in order to
remain portable. The consensus was to eliminate lock stacking altogether, primarily through overwhelming support for the
System V "m[un]lock[all]" interface on which POSIX.1-2024 is now based.
Locks are not inherited across fork()s because some implementations
implement fork() by creating new address spaces for the child. In such an
implementation, requiring locks to be inherited would lead to new situations in which a fork would fail due to the inability of the
system to lock sufficient memory to lock both the parent and the child. The consensus was that there was no benefit to such
inheritance. Note that this does not mean that locks are removed when, for instance, a thread is created in the same address
space.
Similarly, locks are not inherited across exec because some implementations implement exec by
unmapping all of the pages in the address space (which, by definition, removes the locks on these pages), and maps in pages of the
exec'd image. In such an implementation, requiring locks to be inherited would lead to new situations in which exec
would fail. Reporting this failure would be very cumbersome to detect in time to report to the calling process, and no appropriate
mechanism exists for informing the exec'd process of its status.
It was determined that, if the newly loaded application required locking, it was the responsibility of that
application to establish the locks. This is also in keeping with the general view that it is the responsibility of the application
to be aware of all locks that are established.
There was one request to allow (not mandate) locks to be inherited across fork(), and a request for a flag, MCL_INHERIT, that would specify inheritance of memory locks
across execs. Given the difficulties raised by this and the general lack of support for the feature in POSIX.1-2024, it was
not added. POSIX.1-2024 does not preclude an implementation from providing this feature for administrative purposes, such as a
"run" command that will lock down and execute a specified application. Additionally, the rationale for the objection equated
fork() with creating a thread in the address space. POSIX.1-2024 does not mandate
releasing locks when creating additional threads in an existing process.
Standardization Issues
One goal of POSIX.1-2024 is to define a set of primitives that provide the necessary functionality for realtime
applications, with consideration for the needs of other application domains where such were identified, which is based to the
extent possible on existing industry practice.
The Memory Locking option is required by many realtime applications to tune performance. Such a facility is
accomplished by placing constraints on the virtual memory system to limit paging of time of the process or of critical sections of
the process. This facility should not be used by most non-realtime applications.
Optional features provided in POSIX.1-2024 allow applications to lock selected address ranges with the caveat that
the process is responsible for being aware of the page granularity of locking and the unnested nature of the locks.
Mapped Files Functions
The memory mapped files functionality provides a mechanism that allows a process to access files by directly
incorporating file data into its address space. Once a file is "mapped" into a process address space, the data can be manipulated
by instructions as memory. The use of mapped files can significantly reduce I/O data movement since file data does not have to be
copied into process data buffers as in read() and write(). If more than one process maps a file, its contents are shared among them. This
provides a low overhead mechanism by which processes can synchronize and communicate.
Historical Perspective
Realtime applications have historically been implemented using a collection of cooperating processes or tasks. In
early systems, these processes ran on bare hardware (that is, without an operating system) with no memory relocation or protection.
The application paradigms that arose from this environment involve the sharing of data between the processes.
When realtime systems were implemented on top of vendor-supplied operating systems, the paradigm or performance
benefits of direct access to data by multiple processes was still deemed necessary. As a result, operating systems that claim to
support realtime applications must support the shared memory paradigm.
Additionally, a number of realtime systems provide the ability to map specific sections of the physical address
space into the address space of a process. This ability is required if an application is to obtain direct access to memory
locations that have specific properties (for example, refresh buffers or display devices, dual ported memory locations, DMA target
locations). The use of this ability is common enough to warrant some degree of standardization of its interface. This ability
overlaps the general paradigm of shared memory in that, in both instances, common global objects are made addressable by individual
processes or tasks.
Finally, a number of systems also provide the ability to map process addresses to files. This provides both a
general means of sharing persistent objects, and using files in a manner that optimizes memory and swapping space usage.
Simple shared memory is clearly a special case of the more general file mapping capability. In addition, there is
relatively widespread agreement and implementation of the file mapping interface. In these systems, many different types of objects
can be mapped (for example, files, memory, devices, and so on) using the same mapping interfaces. This approach both minimizes
interface proliferation and maximizes the generality of programs using the mapping interfaces.
Memory Mapped Files Usage
A memory object can be concurrently mapped into the address space of one or more processes. The mmap() and munmap() functions allow a process to
manipulate their address space by mapping portions of memory objects into it and removing them from it. When multiple processes map
the same memory object, they can share access to the underlying data. Implementations may restrict the size and alignment of
mappings to be on page-size boundaries. The page size, in bytes, is the value of the system-configurable variable
{PAGESIZE}, typically accessed by calling sysconf() with a name argument of
_SC_PAGESIZE. If an implementation has no restrictions on size or alignment, it may specify a 1-byte page size.
To map memory, a process first opens a memory object. The ftruncate() function can be used to contract or extend the size of the memory object even
when the object is currently mapped. If the memory object is extended, the contents of the extended areas are zeros.
After opening a memory object, the application maps the object into its address space using the mmap() function call. Once a mapping has been established, it remains mapped until unmapped
with munmap(), even if the memory object is closed. The mprotect() function can be used to change the memory protections initially established by
mmap().
A close() of the file descriptor, while invalidating the file
descriptor itself, does not unmap any mappings established for the memory object. The address space, including all mapped regions,
is inherited on fork(). The entire address space is unmapped on process termination or
by successful calls to any of the exec family of functions.
The msync() function is used to force mapped file data to permanent
storage.
Effects on Other Functions
With memory mapped files, the operation of the open(), creat(), and unlink() functions are a natural
result of using the file system name space to map the global names for memory objects.
The ftruncate() function can be used to set the length of a
sharable memory object.
The meaning of stat() fields other than the size and protection
information is undefined on implementations where memory objects are not implemented using regular files. When regular files are
used, the times reflect when the implementation updated the file image of the data, not when a process updated the data in
memory.
The operations of fdopen(), write(), read(), and lseek() were made unspecified for objects opened with shm_open(), so that implementations that did not implement memory objects as regular files
would not have to support the operation of these functions on shared memory objects.
The behavior of memory objects with respect to close(), dup(), dup2(), dup3(), open(), close(), fork(), _exit(), and the exec family of functions is the same as the behavior of the existing
practice of the mmap() function.
A memory object can still be referenced after a close. That is, any mappings made to the file are still in effect,
and reads and writes that are made to those mappings are still valid and are shared with other processes that have the same
mapping. Likewise, the memory object can still be used if any references remain after its name(s) have been deleted. Any references
that remain after a close must not appear to the application as file descriptors.
This is existing practice for mmap() and close(). In addition, there are already mappings present (text, data, stack) that do not have
open file descriptors. The text mapping in particular is considered a reference to the file containing the text. The desire was to
treat all mappings by the process uniformly. Also, many modern implementations use mmap() to implement shared libraries, and it would not be desirable to keep file descriptors
for each of the many libraries an application can use. It was felt there were many other existing programs that used this behavior
to free a file descriptor, and thus POSIX.1-2024 could not forbid it and still claim to be using existing practice.
For implementations that implement memory objects using memory only, memory objects will retain the memory
allocated to the file after the last close and will use that same memory on the next open. Note that closing the memory object is
not the same as deleting the name, since the memory object is still defined in the memory object name space.
The locks of fcntl() do not block any read or write operation,
including read or write access to shared memory or mapped files. In addition, implementations that only support shared memory
objects should not be required to implement record locks. The reference to fcntl() is
added to make this point explicitly. The other fcntl() commands are useful with shared
memory objects.
The size of pages that mapping hardware may be able to support may be a configurable value, or it may change based
on hardware implementations. The addition of the _SC_PAGESIZE parameter to the sysconf() function is provided for determining the mapping page size at runtime.
Shared Memory Functions
Implementations may support the Shared Memory Objects option independently of memory mapped files. Shared memory
objects are named regions of storage that may be independent of the file system and can be mapped into the address space of one or
more processes to allow them to share the associated memory.
Requirements
Shared memory is used to share data among several processes, each potentially running at different priority levels,
responding to different inputs, or performing separate tasks. Shared memory is not just simply providing common access to data, it
is providing the fastest possible communication between the processes. With one memory write operation, a process can pass
information to as many processes as have the memory region mapped.
As a result, shared memory provides a mechanism that can be used for all other interprocess communication
facilities. It may also be used by an application for implementing more sophisticated mechanisms than semaphores and message
queues.
The need for a shared memory interface is obvious for virtual memory systems, where the operating system is
directly preventing processes from accessing each other's data. However, in unprotected systems, such as those found in some
embedded controllers, a shared memory interface is needed to provide a portable mechanism to allocate a region of memory to be
shared and then to communicate the address of that region to other processes.
This, then, provides the minimum functionality that a shared memory interface must have in order to support
realtime applications: to allocate and name an object to be mapped into memory for potential sharing (open() or shm_open()), and to make the memory
object available within the address space of a process (mmap()). To complete the
interface, a mechanism to release the claim of a process on a shared memory object (munmap()) is also needed, as well as a mechanism for deleting the name of a sharable object
that was previously created (unlink() or shm_unlink()).
After a mapping has been established, an implementation should not have to provide services to maintain that
mapping. All memory writes into that area will appear immediately in the memory mapping of that region by any other processes.
Thus, requirements include:
Support creation of sharable memory objects and the mapping of these objects into the address space of a
process.
Sharable memory objects should be accessed by global names accessible from all processes.
Support the mapping of specific sections of physical address space (such as a memory mapped device) into the
address space of a process. This should not be done by the process specifying the actual address, but again by an
implementation-defined global name (such as a special device name) dedicated to this purpose.
Support the mapping of discrete portions of these memory objects.
Support for minimum hardware configurations that contain no physical media on which to store shared memory
contents permanently.
The ability to preallocate the entire shared memory region so that minimum hardware configurations without virtual
memory support can guarantee contiguous space.
The maximizing of performance by not requiring functionality that would require implementation interaction above
creating the shared memory area and returning the mapping.
Note that the above requirements do not preclude:
The sharable memory object from being implemented using actual files on an actual file system.
The global name that is accessible from all processes being restricted to a file system area that is dedicated to
handling shared memory.
An implementation not providing implementation-defined global names for the purpose of physical address
mapping.
Shared Memory Objects Usage
If the Shared Memory Objects option is supported, a shared memory object may be created, or opened if it already
exists, with the shm_open() function. If the shared memory object is created, it
has a length of zero. The ftruncate() function can be used to set the size of the
shared memory object after creation. The shm_unlink() function removes the name
for a shared memory object created by shm_open().
Shared Memory Overview
The shared memory facility defined by POSIX.1-2024 usually results in memory locations being added to the address
space of the process. The implementation returns the address of the new space to the application by means of a pointer. This works
well in languages like C. However, in languages without pointer types it will not work. In the bindings for such a language, either
a special COMMON section will need to be defined (which is unlikely), or the binding will have to allow existing structures to be
mapped. The implementation will likely have to place restrictions on the size and alignment of such structures or will have to map
a suitable region of the address space of the process into the memory object, and thus into other processes. These are issues for
that particular language binding. For POSIX.1-2024, however, the practice will not be forbidden, merely undefined.
Two potentially different name spaces are used for naming objects that may be mapped into process address spaces.
When using memory mapped files, files may be accessed via open(). When the Shared
Memory Objects option is supported, sharable memory objects that might not be files may be accessed via the shm_open() function. These operations are not mutually-exclusive.
Some implementations supporting the Shared Memory Objects option may choose to implement the shared memory object
name space as part of the file system name space. There are several reasons for this:
It allows applications to prevent name conflicts by use of the directory structure.
It uses an existing mechanism for accessing global objects and prevents the creation of a new mechanism for naming
global objects.
In such implementations, memory objects can be implemented using regular files, if that is what the implementation
chooses. The shm_open() function can be implemented as an open() call in a fixed directory with the O_CLOEXEC flag set. The shm_unlink() function can be implemented as an unlink() call.
On the other hand, it is also expected that small embedded systems that support the Shared Memory Objects option
may wish to implement shared memory without having any file systems present. In this case, the implementations may choose to use a
simple string valued name space for shared memory regions. The shm_open() function
permits either type of implementation.
Some implementations have hardware that supports protection of mapped data from certain classes of access and some
do not. Systems that supply this functionality support the memory protection functionality.
Some implementations restrict size, alignment, and protections to be on page-size boundaries. If an
implementation has no restrictions on size or alignment, it may specify a 1-byte page size. Applications on implementations that do
support larger pages must be cognizant of the page size since this is the alignment and protection boundary.
Simple embedded implementations may have a 1-byte page size and only support the Shared Memory Objects option. This
provides simple shared memory between processes without requiring mapping hardware.
POSIX.1-2024 specifically allows a memory object to remain referenced after a close because that is existing
practice for the mmap() function.
Typed Memory Functions
Implementations may support the Typed Memory Objects option without supporting either the Shared Memory option or
memory mapped files. Types memory objects are pools of specialized storage, different from the main memory resource normally used
by a processor to hold code and data, that can be mapped into the address space of one or more processes.
Model
Realtime systems conforming to one of the POSIX.13 realtime profiles are expected (and desired) to be supported on
systems with more than one type or pool of memory (for example, SRAM, DRAM, ROM, EPROM, EEPROM), where each type or pool of memory
may be accessible by one or more processors via one or more buses (ports). Memory mapped files, shared memory objects, and the
language-specific storage allocation operators (malloc() for the ISO C standard,
new for ISO Ada) fail to provide application program interfaces versatile enough to allow applications to control their
utilization of such diverse memory resources. The typed memory interfaces posix_typed_mem_open(), posix_mem_offset(), posix_typed_mem_get_info(), mmap(), and munmap() defined herein support the
model of typed memory described below.
For purposes of this model, a system comprises several processors (for example, P1 and
P2), several physical memory pools (for example, M1,
M2, M2a, M2b, M3,
M4, and M5), and several buses or "ports" (for example,
B1, B2, B3, and B4)
interconnecting the various processors and memory pools in some system-specific way. Notice that some memory pools may be contained
in others (for example, M2a and M2b are contained in
M2).
Example of a System with Typed Memory shows an example of such a model. In a system like
this, an application should be able to perform the following operations:
Figure: Example of a System with Typed Memory
Typed Memory Allocation
An application should be able to allocate memory dynamically from the desired pool using the desired bus, and map
it into the address space of a process. For example, processor P1 can allocate some portion of memory
pool M1 through port B1, treating all unmapped subareas of
M1 as a heap-storage resource from which memory may be allocated. This portion of memory is mapped into
address space of the process, and subsequently deallocated when unmapped from all processes.
Using the Same Storage Region from Different Buses
An application process with a mapped region of storage that is accessed from one bus should be able to map that
same storage area at another address (subject to page size restrictions detailed in mmap()), to allow it to be accessed from another bus. For example, processor
P1 may wish to access the same region of memory pool M2b both through ports
B1 and B2.
Sharing Typed Memory Regions
Several application processes running on the same or different processors may wish to share a particular region of
a typed memory pool. Each process or processor may wish to access this region through different buses. For example, processor
P1 may want to share a region of memory pool M4 with processor
P2, and they may be required to use buses B2 and B3,
respectively, to minimize bus contention. A problem arises here when a process allocates and maps a portion of fragmented memory
and then wants to share this region of memory with another process, either in the same processor or different processors. The
solution adopted is to allow the first process to find out the memory map (offsets and lengths) of all the different fragments of
memory that were mapped into its address space, by repeatedly calling posix_mem_offset(). Then, this process can pass the offsets and lengths obtained to
the second process, which can then map the same memory fragments into its address space.
Contiguous Allocation
The problem of finding the memory map of the different fragments of the memory pool that were mapped into logically
contiguous addresses of a given process can be solved by requesting contiguous allocation. For example, a process in
P1 can allocate 10 Kbytes of physically contiguous memory from
M3-B1, and obtain the offset (within pool M3) of this
block of memory. Then, it can pass this offset (and the length) to a process in P2 using some
interprocess communication mechanism. The second process can map the same block of memory by using the offset transferred and
specifying M3-B2.
Unallocated Mapping
Any subarea of a memory pool that is mapped to a process, either as the result of an allocation request or an
explicit mapping, is normally unavailable for allocation. Special processes such as debuggers, however, may need to map large areas
of a typed memory pool, yet leave those areas available for allocation.
Typed memory allocation and mapping has to coexist with storage allocation operators like malloc(), but systems are free to choose how to implement this coexistence. For example, it
may be system configuration-dependent if all available system memory is made part of one of the typed memory pools or if some part
will be restricted to conventional allocation operators. Equally system configuration-dependent may be the availability of
operators like malloc() to allocate storage from certain typed memory pools. It is
not excluded to configure a system such that a given named pool, P1, is in turn split into
non-overlapping named subpools. For example, M1-B1,
M2-B1, and M3-B1 could also
be accessed as one common pool M123-B1. A call to malloc() on P1 could work on such a larger pool while full
optimization of memory usage by P1 would require typed memory allocation at the subpool level.
Existing Practice
OS-9 provides for the naming (numbering) and prioritization of memory types by a system administrator. It then
provides APIs to request memory allocation of typed (colored) memory by number, and to generate a bus address from a mapped memory
address (translate). When requesting colored memory, the user can specify type 0 to signify allocation from the first available
type in priority order.
HP-RT presents interfaces to map different kinds of storage regions that are visible through a VME bus, although it
does not provide allocation operations. It also provides functions to perform address translation between VME addresses and virtual
addresses. It represents a VME-bus unique solution to the general problem.
The PSOS approach is similar (that is, based on a pre-established mapping of bus address ranges to specific
memories) with a concept of segments and regions (regions dynamically allocated from a heap which is a special segment). Therefore,
PSOS does not fully address the general allocation problem either. PSOS does not have a "process"-based model, but more of a
"thread"-only-based model of multi-tasking. So mapping to a process address space is not an issue.
QNX uses the System V approach of opening specially named devices (shared memory segments) and using mmap() to then gain access from the process. They do not address allocation directly, but once
typed shared memory can be mapped, an "allocation manager" process could be written to handle requests for allocation.
The System V approach also included allocation, implemented by opening yet other special "devices" which
allocate, rather than appearing as a whole memory object.
The Orkid realtime kernel interface definition has operations to manage memory "regions" and "pools", which are
areas of memory that may reflect the differing physical nature of the memory. Operations to allocate memory from these regions and
pools are also provided.
Requirements
Existing practice in SVID-derived UNIX systems relies on functionality similar to mmap() and its related interfaces to achieve mapping and allocation of typed memory. However,
the issue of sharing typed memory (allocated or mapped) and the complication of multiple ports are not addressed in any consistent
way by existing UNIX system practice. Part of this functionality is existing practice in specialized realtime operating systems. In
order to solidify the capabilities implied by the model above, the following requirements are imposed on the interface:
Identification of Typed Memory Pools and Ports
All processes (running in all processors) in the system are able to identify a particular (system configured) typed
memory pool accessed through a particular (system configured) port by a name. That name is a member of a name space common to all
these processes, but need not be the same name space as that containing ordinary pathnames. The association between memory
pools/ports and corresponding names is typically established when the system is configured. The "open" operation for typed memory
objects should be distinct from the open() function, for consistency with other similar
services, but implementable on top of open(). This implies that the handle for a typed
memory object will be a file descriptor.
Allocation and Mapping of Typed Memory
Once a typed memory object has been identified by a process, it is possible to both map user-selected subareas of
that object into process address space and to map system-selected (that is, dynamically allocated) subareas of that object, with
user-specified length, into process address space. It is also possible to determine the maximum length of memory allocation that
may be requested from a given typed memory object.
Sharing Typed Memory
Two or more processes are able to share portions of typed memory, either user-selected or dynamically allocated.
This requirement applies also to dynamically allocated regions of memory that are composed of several non-contiguous pieces.
Contiguous Allocation
For dynamic allocation, it is the user's option whether the system is required to allocate a contiguous subarea
within the typed memory object, or whether it is permitted to allocate discontiguous fragments which appear contiguous in the
process mapping. Contiguous allocation simplifies the process of sharing allocated typed memory, while discontiguous allocation
allows for potentially better recovery of deallocated typed memory.
Accessing Typed Memory Through Different Ports
Once a subarea of a typed memory object has been mapped, it is possible to determine the location and length
corresponding to a user-selected portion of that object within the memory pool. This location and length can then be used to remap
that portion of memory for access from another port. If the referenced portion of typed memory was allocated discontiguously, the
length thus determined may be shorter than anticipated, and the user code must adapt to the value returned.
Deallocation
When a previously mapped subarea of typed memory is no longer mapped by any process in the system—as a result of a
call or calls to munmap()— that subarea becomes potentially reusable for dynamic
allocation; actual reuse of the subarea is a function of the dynamic typed memory allocation policy.
Unallocated Mapping
It must be possible to map user-selected subareas of a typed memory object without marking that subarea as
unavailable for allocation. This option is not the default behavior, and requires appropriate privileges.
Scenario
The following scenario will serve to clarify the use of the typed memory interfaces.
Process A running on P1 (see Example of a System with Typed
Memory) wants to allocate some memory from memory pool M2, and it wants to share this portion of
memory with process B running on P2. Since P2 only has access to the lower part
of M2, both processes will use the memory pool named M2b which is the part of
M2 that is accessible both from P1 and P2. The
operations that both processes need to perform are shown below:
Allocating Typed Memory
Process A calls posix_typed_mem_open() with the name
/typed.m2b-b1 and a tflag of POSIX_TYPED_MEM_ALLOCATE to get a file descriptor usable for allocating from pool
M2b accessed through port B1. It then calls mmap() with this file descriptor requesting a length of 4096 bytes. The system allocates two
discontiguous blocks of sizes 1024 and 3072 bytes within M2b. The mmap() function returns a pointer to a 4096-byte array in process A's logical address space,
mapping the allocated blocks contiguously. Process A can then utilize the array, and store data in it.
Determining the Location of the Allocated Blocks
Process A can determine the lengths and offsets (relative to M2b) of the two blocks
allocated, by using the following procedure: First, process A calls posix_mem_offset() with the address of the first element of the array and length
4096. Upon return, the offset and length (1024 bytes) of the first block are returned. A second call to posix_mem_offset() is then made using the address of the first element of the array
plus 1024 (the length of the first block), and a new length of 4096-1024. If there were more fragments allocated, this procedure
could have been continued within a loop until the offsets and lengths of all the blocks were obtained. Notice that this relatively
complex procedure can be avoided if contiguous allocation is requested (by opening the typed memory object with the tflag
POSIX_TYPED_MEM_ALLOCATE_CONTIG).
Sharing Data Across Processes
Process A passes the two offset values and lengths obtained from the posix_mem_offset() calls to process B running on P2, via
some form of interprocess communication. Process B can gain access to process A's data by calling posix_typed_mem_open() with the name /typed.m2b-b2 and a tflag of
zero, then using two mmap() calls on the resulting file descriptor to map the two
subareas of that typed memory object to its own address space.
Rationale for no mem_alloc() and mem_free()
The standard developers had originally proposed a pair of new flags to mmap() which, when applied to a typed memory object descriptor, would cause mmap() to allocate dynamically from an unallocated and unmapped area of the typed memory
object. Deallocation was similarly accomplished through the use of munmap(). This was
rejected by the ballot group because it excessively complicated the (already rather complex) mmap() interface and introduced semantics useful only for typed memory, to a function which
must also map shared memory and files. They felt that a memory allocator should be built on top of mmap() instead of being incorporated within the same interface, much as the ISO C standard
libraries build malloc() on top of the virtual memory mapping functions brk()
and sbrk(). This would eliminate the complicated semantics involved with unmapping only part of an allocated block of typed
memory.
To attempt to achieve ballot group consensus, typed memory allocation and deallocation was first migrated from
mmap() and munmap() to a pair of
complementary functions modeled on the ISO C standard malloc() and free(). The mem_alloc() function specified explicitly the typed memory object (typed
memory pool/access port) from which allocation takes place, unlike malloc() where the
memory pool and port are unspecified. The mem_free() function handled deallocation. These new semantics still met all of the
requirements detailed above without modifying the behavior of mmap() except to allow it
to map specified areas of typed memory objects. An implementation would have been free to implement mem_alloc() and
mem_free() over mmap(), through mmap(), or independently but cooperating with mmap().
The ballot group was queried to see if this was an acceptable alternative, and while there was some agreement that
it achieved the goal of removing the complicated semantics of allocation from the mmap() interface, several balloters realized that it just created two additional functions that
behaved, in great part, like mmap(). These balloters proposed an alternative which has
been implemented here in place of a separate mem_alloc() and mem_free(). This alternative is based on four specific
suggestions:
The posix_typed_mem_open() function should provide a
flag which specifies "allocate on mmap()" (otherwise, mmap() just maps the underlying object). This allows things roughly similar to /dev/zero
versus /dev/swap. Two such flags have been implemented, one of which forces contiguous allocation.
The posix_mem_offset() function is acceptable because it
can be applied usefully to mapped objects in general. It should return the file descriptor of the underlying object.
The mem_get_info() function in an earlier draft should be renamed posix_typed_mem_get_info() because it is not generally applicable to memory
objects. It should probably return the file descriptor's allocation attribute. The renaming of the function has been implemented,
but having it return a piece of information which is readily known by an application without this function has been rejected. Its
whole purpose is to query the typed memory object for attributes that are not user-specified, but determined by the
implementation.
There should be no separate mem_alloc() or mem_free() functions. Instead, using mmap() on a typed memory object opened with an "allocate on mmap()" flag should be used to force allocation. These are precisely the semantics defined in
the current draft.
Rationale for no Typed Memory Access Management
The working group had originally defined an additional interface (and an additional kind of object: typed memory
manager) to establish and dissolve mappings to typed memory on behalf of devices or processors which were independent of the
operating system and had no inherent capability to directly establish mappings on their own. This was to have provided
functionality similar to device driver interfaces such as physio() and their underlying bus-specific interfaces (for
example, mballoc()) which serve to set up and break down DMA pathways, and derive mapped addresses for use by hardware
devices and processor cards.
The ballot group felt that this was beyond the scope of POSIX.1 and its amendments. Furthermore, the removal of
interrupt handling interfaces from a preceding amendment (the IEEE Std 1003.1d-1999) during its balloting process renders
these typed memory access management interfaces an incomplete solution to portable device management from a user process; it would
be possible to initiate a device transfer to/from typed memory, but impossible to handle the transfer-complete interrupt in a
portable way.
To achieve ballot group consensus, all references to typed memory access management capabilities were removed. The
concept of portable interfaces from a device driver to both operating system and hardware is being addressed by the Uniform Driver
Interface (UDI) industry forum, with formal standardization deferred until proof of concept and industry-wide acceptance and
implementation.
B.2.8.4 Process Scheduling
IEEE PASC Interpretation 1003.1 #96 has been applied, adding the pthread_setschedprio() function. This was added since previously there was no
way for a thread to lower its own priority without going to the tail of the threads list for its new priority. This capability is
necessary to bound the duration of priority inversion encountered by a thread.
The following portion of the rationale presents models, requirements, and standardization issues relevant to
process and thread scheduling; see B.2.9.4 Thread Scheduling for additional rationale relevant to
thread scheduling.
In an operating system supporting multiple concurrent processes or threads, the system determines the order in
which processes or threads execute to meet implementation-defined goals. For time-sharing systems, the goal is to enhance system
throughput and promote fairness; the application is provided with little or no control over this sequencing function. While this is
acceptable and desirable behavior in a time-sharing system, it is inappropriate in a realtime system; realtime applications must
specifically control the execution sequence of their concurrent processes or threads in order to meet externally defined response
requirements.
In POSIX.1-2024, the control over process and thread sequencing is provided using a concept of scheduling policies.
These policies, described in detail in this section, define the behavior of the system whenever processor resources are to be
allocated to competing processes or threads. Only the behavior of the policy is defined; conforming implementations are free to use
any mechanism desired to achieve the described behavior.
Models
In an operating system supporting multiple concurrent processes or threads, the system determines the order in
which threads (including those that are the only thread in a single-threaded process) execute and might force long-running threads
to yield to other threads at certain intervals. Typically, the scheduling code is executed whenever an event occurs that might
alter the thread to be executed next.
The simplest scheduling strategy is a "first-in, first-out" (FIFO) dispatcher. Whenever a thread becomes
runnable, it is placed on the end of a ready list. When processing resources become available, the thread at the front of the ready
list starts or resumes execution and is removed from the list. This thread is executed until it exits or becomes blocked, at which
point the processing resources used to execute it become available to execute another runnable thread. This scheduling technique is
also known as "run-to-completion" or "run-to-block".
A natural extension to this scheduling technique is the assignment of a "non-migrating priority" to each thread.
This policy differs from strict FIFO scheduling in only one respect: whenever a thread becomes runnable, it is placed at the end of
the list of threads runnable at that priority level. When selecting a thread to run, the system always selects the first thread
from the highest priority queue with a runnable thread. Thus, when a thread becomes unblocked, it will preempt a running thread of
lower priority without otherwise altering the ready list. Further, if a running or runnable thread's priority is altered, it is
removed from the ready list for its old priority (if present in the list; that is, not running) and is inserted into the ready list
for its new priority, according to the policy above, except that threads executing at a temporarily elevated priority as a
consequence of owning a mutex initialized with the PTHREAD_PRIO_INHERIT or PTHREAD_PRIO_PROTECT protocol are exempted from this in
order to ensure that a thread can lock and unlock such as mutex without the implicit yield that any resulting priority changes
would normally cause.
While the above policy might be considered unfriendly in a time-sharing environment in which multiple users require
more balanced resource allocation, it could be ideal in a realtime environment for several reasons. The most important of these is
that it is deterministic: the highest-priority thread is always run and, among threads of equal priority, the thread that has been
runnable for the longest time is executed first. Because of this determinism, cooperating threads can implement more complex
scheduling simply by altering their priority. For instance, if threads at a single priority were to reschedule themselves at fixed
time intervals, a time-slice policy would result.
In a dedicated operating system in which all threads belong to well-behaved realtime applications, non-migrating
priority scheduling is sufficient. However, many existing implementations provide for more complex scheduling policies.
For process scheduling, POSIX.1-2024 specifies a linear scheduling model. In this model, every process in the
system has a priority. The system scheduler always dispatches a process that has the highest (generally the most time-critical)
priority among all runnable processes in the system. As long as there is only one such process, the dispatching policy is trivial.
When multiple processes of equal priority are eligible to run, they are ordered according to a strict run-to-completion (FIFO)
policy. Thread scheduling is similar, except that the scheduling policy can be applied just to the threads within one process
(PTHREAD_SCOPE_PROCESS scheduling contention scope) or to all threads system-wide (PTHREAD_SCOPE_SYSTEM scheduling contention
scope). This and other considerations specific to thread scheduling are the subject of B.2.9.4 Thread
Scheduling; the remainder of this section is described in terms of process scheduling but is also relevant to thread
scheduling when read in conjunction with B.2.9.4 Thread Scheduling.
The priority is represented as a positive integer and is inherited from the parent process. For processes running
under a fixed priority scheduling policy, the priority is never altered except by an explicit function call.
It was determined arbitrarily that larger integers correspond to "higher priorities".
Certain implementations might impose restrictions on the priority ranges to which processes can be assigned. There
also can be restrictions on the set of policies to which processes can be set.
Requirements
Realtime processes require that scheduling be fast and deterministic, and that it guarantees to preempt lower
priority processes.
Thus, given the linear scheduling model, realtime processes require that they be run at a priority that is higher
than other processes. Within this framework, realtime processes are free to yield execution resources to each other in a completely
portable and implementation-defined manner.
As there is a generally perceived requirement for processes at the same priority level to share processor resources
more equitably, provisions are made by providing a scheduling policy (that is, SCHED_RR) intended to provide a timeslice-like
facility.
Note:
The following topics assume that low numeric priority implies low scheduling criticality and vice versa.
Rationale for New Interface
Realtime applications need to be able to determine when processes will run in relation to each other. It must be
possible to guarantee that a critical process will run whenever it is runnable; that is, whenever it wants to for as long as it
needs. SCHED_FIFO satisfies this requirement. Additionally, SCHED_RR was defined to meet a realtime requirement for a well-defined
time-sharing policy for processes at the same priority.
It would be possible to use the BSD setpriority() and getpriority() functions by redefining the meaning of the "nice" parameter according to
the scheduling policy currently in use by the process. The System V nice()
interface was felt to be undesirable for realtime because it specifies an adjustment to the "nice" value, rather than setting it
to an explicit value. Realtime applications will usually want to set priority to an explicit value. Also, System V nice() does not allow for changing the priority of another process.
With the POSIX.1b interfaces, the traditional "nice" value does not affect the SCHED_FIFO or SCHED_RR scheduling
policies. If a "nice" value is supported, it is implementation-defined whether it affects the SCHED_OTHER policy.
An important aspect of POSIX.1-2024 is the explicit description of the queuing and preemption rules. It is
critical, to achieve deterministic scheduling, that such rules be stated clearly in POSIX.1-2024.
POSIX.1-2024 does not address the interaction between priority and swapping. The issues involved with swapping and
virtual memory paging are extremely implementation-defined and would be nearly impossible to standardize at this point. The
proposed scheduling paradigm, however, fully describes the scheduling behavior of runnable processes, of which one criterion is
that the working set be resident in memory. Assuming the existence of a portable interface for locking portions of a process in
memory, paging behavior need not affect the scheduling of realtime processes.
POSIX.1-2024 also does not address the priorities of "system" processes. In general, these processes should
always execute in low-priority ranges to avoid conflict with other realtime processes. Implementations should document the priority
ranges in which system processes run.
The default scheduling policy is not defined. The effect of I/O interrupts and other system processing activities
is not defined. The temporary lending of priority from one process to another (such as for the purposes of affecting freeing
resources) by the system is not addressed. Preemption of resources is not addressed. Restrictions on the ability of a process to
affect other processes beyond a certain level (influence levels) is not addressed.
The rationale used to justify the simple time-quantum scheduler is that it is common practice to depend upon this
type of scheduling to ensure "fair" distribution of processor resources among portions of the application that must interoperate
in a serial fashion. Note that POSIX.1-2024 is silent with respect to the setting of this time quantum, or whether it is a
system-wide value or a per-process value, although it appears that the prevailing realtime practice is for it to be a system-wide
value.
In a system with N processes at a given priority, all processor-bound, in which the time quantum is equal
for all processes at a specific priority level, the following assumptions are made of such a scheduling policy:
A time quantum Q exists and the current process will own control of the processor for at least a duration
of Q and will have the processor for a duration of Q.
The Nth process at that priority will control a processor within a duration of (N-1) ×
Q.
These assumptions are necessary to provide equal access to the processor and bounded response from the
application.
The assumptions hold for the described scheduling policy only if no system overhead, such as interrupt servicing,
is present. If the interrupt servicing load is non-zero, then one of the two assumptions becomes fallacious, based upon how
Q is measured by the system.
If Q is measured by clock time, then the assumption that the process obtains a duration Q processor
time is false if interrupt overhead exists. Indeed, a scenario can be constructed with N processes in which a single process
undergoes complete processor starvation if a peripheral device, such as an analog-to-digital converter, generates significant
interrupt activity periodically with a period of N × Q.
If Q is measured as actual processor time, then the assumption that the Nth process runs in within
the duration (N-1) × Q is false.
It should be noted that SCHED_FIFO suffers from interrupt-based delay as well. However, for SCHED_FIFO, the implied
response of the system is "as soon as possible", so that the interrupt load for this case is a vendor selection and not a
compliance issue.
With this in mind, it is necessary either to complete the definition by including bounds on the interrupt load, or
to modify the assumptions that can be made about the scheduling policy.
Since the motivation of inclusion of the policy is common usage, and since current applications do not enjoy the
luxury of bounded interrupt load, item (2) above is sufficient to express existing application needs and is less restrictive in the
standard definition. No difference in interface is necessary.
In an implementation in which the time quantum is equal for all processes at a specific priority, our assumptions
can then be restated as:
A time quantum Q exists, and a processor-bound process will be rescheduled after a duration of, at most,
Q. Time quantum Q may be defined in either wall clock time or execution time.
In general, the Nth process of a priority level should wait no longer than (N-1) × Q time to
execute, assuming no processes exist at higher priority levels.
No process should wait indefinitely.
For implementations supporting per-process time quanta, these assumptions can be readily extended.
Austin Group Defect 1302 is applied, making requirements on sched_yield() also apply to thrd_yield().
Austin Group Defect 1610 is applied, clarifying the effects of PTHREAD_PRIO_INHERIT and PTHREAD_PRIO_PROTECT on
scheduling queues.
Sporadic Server Scheduling Policy
The sporadic server is a mechanism defined for scheduling aperiodic activities in time-critical realtime systems.
This mechanism reserves a certain bounded amount of execution capacity for processing aperiodic events at a high priority level.
Any aperiodic events that cannot be processed within the bounded amount of execution capacity are executed in the background at a
low priority level. Thus, a certain amount of execution capacity can be guaranteed to be available for processing periodic tasks,
even under burst conditions in the arrival of aperiodic processing requests (that is, a large number of requests in a short time
interval). The sporadic server also simplifies the schedulability analysis of the realtime system, because it allows aperiodic
processes or threads to be treated as if they were periodic. The sporadic server was first described by Sprunt, et al.
The key concept of the sporadic server is to provide and limit a certain amount of computation capacity for
processing aperiodic events at their assigned normal priority, during a time interval called the "replenishment period". Once the
entity controlled by the sporadic server mechanism is initialized with its period and execution-time budget attributes, it
preserves its execution capacity until an aperiodic request arrives. The request will be serviced (if there are no higher priority
activities pending) as long as there is execution capacity left. If the request is completed, the actual execution time used to
service it is subtracted from the capacity, and a replenishment of this amount of execution time is scheduled to happen one
replenishment period after the arrival of the aperiodic request. If the request is not completed, because there is no execution
capacity left, then the aperiodic process or thread is assigned a lower background priority. For each portion of consumed execution
capacity the execution time used is replenished after one replenishment period. At the time of replenishment, if the sporadic
server was executing at a background priority level, its priority is elevated to the normal level. Other similar replenishment
policies have been defined, but the one presented here represents a compromise between efficiency and implementation
complexity.
The interface that appears in this section defines a new scheduling policy for threads and processes that behaves
according to the rules of the sporadic server mechanism. Scheduling attributes are defined and functions are provided to allow the
user to set and get the parameters that control the scheduling behavior of this mechanism, namely the normal and low priority, the
replenishment period, the maximum number of pending replenishment operations, and the initial execution-time budget.
Scheduling Aperiodic Activities
Virtually all realtime applications are required to process aperiodic activities. In many cases, there are tight
timing constraints that the response to the aperiodic events must meet. Usual timing requirements imposed on the response to these
events are:
The effects of an aperiodic activity on the response time of lower priority activities must be controllable and
predictable.
The system must provide the fastest possible response time to aperiodic events.
It must be possible to take advantage of all the available processing bandwidth not needed by time-critical
activities to enhance average-case response times to aperiodic events.
Traditional methods for scheduling aperiodic activities are background processing, polling tasks, and direct event
execution:
Background processing consists of assigning a very low priority to the processing of aperiodic events. It utilizes
all the available bandwidth in the system that has not been consumed by higher priority threads. However, it is very difficult, or
impossible, to meet requirements on average-case response time, because the aperiodic entity has to wait for the execution of all
other entities which have higher priority.
Polling consists of creating a periodic process or thread for servicing aperiodic requests. At regular intervals,
the polling entity is started and its services accumulated pending aperiodic requests. If no aperiodic requests are pending, the
polling entity suspends itself until its next period. Polling allows the aperiodic requests to be processed at a higher priority
level. However, worst and average-case response times of polling entities are a direct function of the polling period, and there is
execution overhead for each polling period, even if no event has arrived. If the deadline of the aperiodic activity is short
compared to the inter-arrival time, the polling frequency must be increased to guarantee meeting the deadline. For this case, the
increase in frequency can dramatically reduce the efficiency of the system and, therefore, its capacity to meet all deadlines. Yet,
polling represents a good way to handle a large class of practical problems because it preserves system predictability, and because
the amortized overhead drops as load increases.
Direct event execution consists of executing the aperiodic events at a high fixed-priority level. Typically, the
aperiodic event is processed by an interrupt service routine as soon as it arrives. This technique provides predictable response
times for aperiodic events, but makes the response times of all lower priority activities completely unpredictable under burst
arrival conditions. Therefore, if the density of aperiodic event arrivals is unbounded, it may be a dangerous technique for
time-critical systems. Yet, for those cases in which the physics of the system imposes a bound on the event arrival rate, it is
probably the most efficient technique.
The sporadic server scheduling algorithm combines the predictability of the polling approach with the short
response times of the direct event execution. Thus, it allows systems to meet an important class of application requirements that
cannot be met by using the traditional approaches. Multiple sporadic servers with different attributes can be applied to the
scheduling of multiple classes of aperiodic events, each with different kinds of timing requirements, such as individual deadlines,
average response times, and so on. It also has many other interesting applications for realtime, such as scheduling
producer/consumer tasks in time-critical systems, limiting the effects of faults on the estimation of task execution-time
requirements, and so on.
Existing Practice
The sporadic server has been used in different kinds of applications, including military avionics, robot control
systems, industrial automation systems, and so on. There are examples of many systems that cannot be successfully scheduled using
the classic approaches, such as direct event execution, or polling, and are schedulable using a sporadic server scheduler. The
sporadic server algorithm itself can successfully schedule all systems scheduled with direct event execution or polling.
The sporadic server scheduling policy has been implemented as a commercial product in the run-time system of the
Verdix Ada compiler. There are also many applications that have used a much less efficient application-level sporadic server. These
realtime applications would benefit from a sporadic server scheduler implemented at the scheduler level.
Library-Level versus Kernel-Level Implementation
The sporadic server interface described in this section requires the sporadic server policy to be implemented at
the same level as the scheduler. This means that the process sporadic server must be implemented at the kernel level and the thread
sporadic server policy implemented at the same level as the thread scheduler; that is, kernel or library level.
In an earlier interface for the sporadic server, this mechanism was implementable at a different level than the
scheduler. This feature allowed the implementor to choose between an efficient scheduler-level implementation, or a simpler user or
library-level implementation. However, the working group considered that this interface made the use of sporadic servers more
complex, and that library-level implementations would lack some of the important functionality of the sporadic server, namely the
limitation of the actual execution time of aperiodic activities. The working group also felt that the interface described in this
chapter does not preclude library-level implementations of threads intended to provide efficient low-overhead scheduling for those
threads that are not scheduled under the sporadic server policy.
Range of Scheduling Priorities
Each of the scheduling policies supported in POSIX.1-2024 has an associated range of priorities. The priority
ranges for each policy might or might not overlap with the priority ranges of other policies. For time-critical realtime
applications it is usual for periodic and aperiodic activities to be scheduled together in the same processor. Periodic activities
will usually be scheduled using the SCHED_FIFO scheduling policy, while aperiodic activities may be scheduled using SCHED_SPORADIC.
Since the application developer will require complete control over the relative priorities of these activities in order to meet his
timing requirements, it would be desirable for the priority ranges of SCHED_FIFO and SCHED_SPORADIC to overlap completely.
Therefore, although POSIX.1-2024 does not require any particular relationship between the different priority ranges, it is
recommended that these two ranges should coincide.
Dynamically Setting the Sporadic Server Policy
Several members of the working group requested that implementations should not be required to support dynamically
setting the sporadic server scheduling policy for a thread. The reason is that this policy may have a high overhead for
library-level implementations of threads, and if threads are allowed to dynamically set this policy, this overhead can be
experienced even if the thread does not use that policy. By disallowing the dynamic setting of the sporadic server scheduling
policy, these implementations can accomplish efficient scheduling for threads using other policies. If a strictly conforming
application needs to use the sporadic server policy, and is therefore willing to pay the overhead, it must set this policy at the
time of thread creation.
Limitation of the Number of Pending Replenishments
The number of simultaneously pending replenishment operations must be limited for each sporadic server for two
reasons: an unlimited number of replenishment operations would need an unlimited number of system resources to store all the
pending replenishment operations; on the other hand, in some implementations each replenishment operation will represent a source
of priority inversion (just for the duration of the replenishment operation) and thus, the maximum amount of replenishments must be
bounded to guarantee bounded response times. The way in which the number of replenishments is bounded is by lowering the priority
of the sporadic server to sched_ss_low_priority when the number of pending replenishments has reached its limit. In this
way, no new replenishments are scheduled until the number of pending replenishments decreases.
In the sporadic server scheduling policy defined in POSIX.1-2024, the application can specify the maximum number of
pending replenishment operations for a single sporadic server, by setting the value of the sched_ss_max_repl scheduling
parameter. This value must be between one and {SS_REPL_MAX}, which is a maximum limit imposed by the implementation. The limit
{SS_REPL_MAX} must be greater than or equal to {_POSIX_SS_REPL_MAX}, which is defined to be four in POSIX.1-2024. The minimum limit
of four was chosen so that an application can at least guarantee that four different aperiodic events can be processed during each
interval of length equal to the replenishment period.
B.2.8.5 Clocks and Timers
Clocks
POSIX.1-2024 and the ISO C standard both define functions for obtaining system time. Implicit behind these
functions is a mechanism for measuring passage of time. This specification makes this mechanism explicit and calls it a clock. The
CLOCK_REALTIME clock required by POSIX.1-2024 is a higher resolution version of the clock that maintains POSIX.1 system time. This
is a "system-wide" clock, in that it is visible to all processes and, were it possible for multiple processes to all read the
clock at the same time, they would see the same value.
An extensible interface was defined, with the ability for implementations to define additional clocks. This was
done because of the observation that many realtime platforms support multiple clocks, and it was desired to fit this model within
the standard interface. But implementation-defined clocks need not represent actual hardware devices, nor are they necessarily
system-wide.
Timers
Two timer types are required for a system to support realtime applications:
One-shot
A one-shot timer is a timer that is armed with an initial expiration time, either relative to the current time or
at an absolute time (based on some timing base, such as time in seconds and nanoseconds since the Epoch). The timer expires once
and then is disarmed. With the specified facilities, this is accomplished by setting the it_value member of the value
argument to the desired expiration time and the it_interval member to zero.
Periodic
A periodic timer is a timer that is armed with an initial expiration time, again either relative or absolute, and a
repetition interval. When the initial expiration occurs, the timer is reloaded with the repetition interval and continues counting.
With the specified facilities, this is accomplished by setting the it_value member of the value argument to the
desired initial expiration time and the it_interval member to the desired repetition interval.
For both of these types of timers, the time of the initial timer expiration can be specified in two ways:
Relative (to the current time)
Absolute
Examples of Using Realtime Timers
In the diagrams below, S indicates a program schedule, R shows a schedule method request, and
E suggests an internal operating system event.
Periodic Timer: Data Logging
During an experiment, it might be necessary to log realtime data periodically to an internal buffer or to a mass
storage device. With a periodic scheduling method, a logging module can be started automatically at fixed time intervals to log the
data.
Program schedule is requested every 10 seconds.
R         S         S         S         S         S
----+----+----+----+----+----+----+----+----+----+----+--->
5   10   15   20   25   30   35   40   45   50   55
[Time (in Seconds)]
To achieve this type of scheduling using the specified facilities, one would allocate a per-process timer based on
clock ID CLOCK_REALTIME. Then the timer would be armed via a call to timer_settime() with the TIMER_ABSTIME flag reset, and with an initial expiration
value and a repetition interval of 10 seconds.
One-shot Timer (Relative Time): Device Initialization
In an emission test environment, large sample bags are used to capture the exhaust from a vehicle. The exhaust is
purged from these bags before each and every test. With a one-shot timer, a module could initiate the purge function and then
suspend itself for a predetermined period of time while the sample bags are prepared.
Program schedule requested 20 seconds after call is issued.
R                   S
----+----+----+----+----+----+----+----+----+----+----+--->
5   10   15   20   25   30   35   40   45   50   55
[Time (in Seconds)]
To achieve this type of scheduling using the specified facilities, one would allocate a per-process timer based on
clock ID CLOCK_REALTIME. Then the timer would be armed via a call to timer_settime() with the TIMER_ABSTIME flag reset, and with an initial expiration
value of 20 seconds and a repetition interval of zero.
Note that if the program wishes merely to suspend itself for the specified interval, it could more easily use
nanosleep().
One-shot Timer (Absolute Time): Data Transmission
The results from an experiment are often moved to a different system within a network for post-processing or
archiving. With an absolute one-shot timer, a module that moves data from a test-cell computer to a host computer can be
automatically scheduled on a daily basis.
Program schedule requested for 2:30 a.m.
R                                     S
-----+-----+-----+-----+-----+-----+-----+-----+-----+----->
23:00 23:30 24:00 00:30 01:00 01:30 02:00 02:30 03:00
[Time of Day]
To achieve this type of scheduling using the specified facilities, a per-process timer would be allocated based on
clock ID CLOCK_REALTIME. Then the timer would be armed via a call to timer_settime() with the TIMER_ABSTIME flag set, and an initial expiration value equal
to 2:30 a.m. of the next day.
Periodic Timer (Relative Time): Signal Stabilization
Some measurement devices, such as emission analyzers, do not respond instantaneously to an introduced sample. With
a periodic timer with a relative initial expiration time, a module that introduces a sample and records the average response could
suspend itself for a predetermined period of time while the signal is stabilized and then sample at a fixed rate.
Program schedule requested 15 seconds after call is issued and every 2 seconds thereafter.
R              S S S S S S S S S S S S S S S S S S S S
----+----+----+----+----+----+----+----+----+----+----+--->
5   10   15   20   25   30   35   40   45   50   55
[Time (in Seconds)]
To achieve this type of scheduling using the specified facilities, one would allocate a per-process timer based on
clock ID CLOCK_REALTIME. Then the timer would be armed via a call to timer_settime() with TIMER_ABSTIME flag reset, and with an initial expiration value of
15 seconds and a repetition interval of 2 seconds.
Periodic Timer (Absolute Time): Work Shift-related Processing
Resource utilization data is useful when time to perform experiments is being scheduled at a facility. With a
periodic timer with an absolute initial expiration time, a module can be scheduled at the beginning of a work shift to gather
resource utilization data throughout the shift. This data can be used to allocate resources effectively to minimize bottlenecks and
delays and maximize facility throughput.
Program schedule requested for 2:00 a.m. and every 15 minutes thereafter.
R                               S  S  S  S  S  S
-----+-----+-----+-----+-----+-----+-----+-----+-----+----->
23:00 23:30 24:00 00:30 01:00 01:30 02:00 02:30 03:00
[Time of Day]
To achieve this type of scheduling using the specified facilities, one would allocate a per-process timer based on
clock ID CLOCK_REALTIME. Then the timer would be armed via a call to timer_settime() with TIMER_ABSTIME flag set, and with an initial expiration value
equal to 2:00 a.m. and a repetition interval equal to 15 minutes.
Relationship of Timers to Clocks
The relationship between clocks and timers armed with an absolute time is straightforward: a timer expiration
signal is requested when the associated clock reaches or exceeds the specified time. The relationship between clocks and timers
armed with a relative time (an interval) is less obvious, but not unintuitive. In this case, a timer expiration signal is requested
when the specified interval, as measured by the associated clock, has passed. For the required CLOCK_REALTIME clock, this
allows timer expiration signals to be requested at specified "wall clock" times (absolute), or when a specified interval of
"realtime" has passed (relative). For an implementation-defined clock—say, a process virtual time clock—timer expirations could
be requested when the process has used a specified total amount of virtual time (absolute), or when it has used a specified
additional amount of virtual time (relative).
The interfaces also allow flexibility in the implementation of the functions. For example, an implementation could
convert all absolute times to intervals by subtracting the clock value at the time of the call from the requested expiration time
and "counting down" at the supported resolution. Or it could convert all relative times to absolute expiration time by adding in
the clock value at the time of the call and comparing the clock value to the expiration time at the supported resolution. Or it
might even choose to maintain absolute times as absolute and compare them to the clock value at the supported resolution for
absolute timers, and maintain relative times as intervals and count them down at the resolution supported for relative timers. The
choice will be driven by efficiency considerations and the underlying hardware or software clock implementation.
Data Definitions for Clocks and Timers
POSIX.1-2024 uses a time representation capable of supporting nanosecond resolution timers for the following
reasons:
To enable POSIX.1-2024 to represent those computer systems already using nanosecond or submicrosecond resolution
clocks.
To accommodate those per-process timers that might need nanoseconds to specify an absolute value of system-wide
clocks, even though the resolution of the per-process timer may only be milliseconds, or vice versa.
Because the number of nanoseconds in a second can be represented in 32 bits.
Time values are represented in the timespec structure. The tv_sec member is of type time_t so
that this member is compatible with time values used by POSIX.1 functions and the ISO C standard. The tv_nsec member is
a signed long in order to simplify and clarify code that decrements or finds differences of time values. Note that because 1
billion (number of nanoseconds per second) is less than half of the value representable by a signed 32-bit value, it is always
possible to add two valid fractional seconds represented as integral nanoseconds without overflowing the signed 32-bit value.
A maximum allowable resolution for the CLOCK_REALTIME clock of 20 ms (1/50 seconds) was chosen to allow line
frequency clocks in European countries to be conforming. 60 Hz clocks in the US will also be conforming, as will finer granularity
clocks, although a Strictly Conforming Application cannot assume a granularity of less than 20 ms (1/50 seconds).
The minimum allowable maximum time allowed for the CLOCK_REALTIME clock and the function nanosleep(), and timers created with clock_id=CLOCK_REALTIME, is determined by the
fact that the tv_sec member is of type time_t.
POSIX.1-2024 specifies that timer expirations must not be delivered early, and nanosleep() must not return early due to quantization error. POSIX.1-2024 discusses the
various implementations of alarm() in the rationale and states that implementations
that do not allow alarm signals to occur early are the most appropriate, but refrained from mandating this behavior. Because of the
importance of predictability to realtime applications, POSIX.1-2024 takes a stronger stance.
The standard developers considered using a time representation that differs from POSIX.1b in the second 32 bit of
the 64-bit value. Whereas POSIX.1b defines this field as a fractional second in nanoseconds, the other methodology defines this as
a binary fraction of one second, with the radix point assumed before the most significant bit.
POSIX.1b is a software, source-level standard and most of the benefits of the alternate representation are enjoyed
by hardware implementations of clocks and algorithms. It was felt that mandating this format for POSIX.1b clocks and timers would
unnecessarily burden the application developer with writing, possibly non-portable, multiple precision arithmetic packages to
perform conversion between binary fractions and integral units such as nanoseconds, milliseconds, and so on.
Rationale for the Monotonic Clock
For those applications that use time services to achieve realtime behavior, changing the value of the clock on
which these services rely may cause erroneous timing behavior. For these applications, it is necessary to have a monotonic clock
which cannot run backwards, and which has a maximum clock jump that is required to be documented by the implementation.
Additionally, it is desirable (but not required by POSIX.1-2024) that the monotonic clock increases its value uniformly. This clock
should not be affected by changes to the system time; for example, to synchronize the clock with an external source or to account
for leap seconds. Such changes would cause errors in the measurement of time intervals for those time services that use the
absolute value of the clock.
One could argue that by defining the behavior of time services when the value of a clock is changed, deterministic
realtime behavior can be achieved. For example, one could specify that relative time services should be unaffected by changes in
the value of a clock. However, there are time services that are based upon an absolute time, but that are essentially intended as
relative time services. For example, pthread_cond_timedwait() uses an
absolute time to allow it to wake up after the required interval despite spurious wakeups. Although sometimes the pthread_cond_timedwait() timeouts are absolute in nature, there are many
occasions in which they are relative, and their absolute value is determined from the current time plus a relative time interval.
In this latter case, if the clock changes while the thread is waiting, the wait interval will not be the expected length. If a
pthread_cond_timedwait() function were created that would take a
relative time, it would not solve the problem because to retain the intended "deadline" a thread would need to compensate for
latency due to the spurious wakeup, and preemption between wakeup and the next wait.
The solution is to create a new monotonic clock, whose value does not change except for the regular ticking of the
clock, and use this clock for implementing the various relative timeouts that appear in the different POSIX interfaces, as well as
allow pthread_cond_timedwait() to choose this new clock for its
timeout. A new clock_nanosleep() function is created to allow an application
to take advantage of this newly defined clock. Notice that the monotonic clock may be implemented using the same hardware clock as
the system clock.
Relative timeouts for sigtimedwait() and aio_suspend() have been redefined to use the monotonic clock, if present. The alarm() function has not been redefined, because the same effect but with better resolution
can be achieved by creating a timer (for which the appropriate clock may be chosen).
The pthread_cond_timedwait() function has been
treated in a different way, compared to other functions with absolute timeouts, because it is used to wait for an event, and thus
it may have a deadline, while the other timeouts are generally used as an error recovery mechanism, and for them the use of the
monotonic clock is not so important. Since the desired timeout for the pthread_cond_timedwait() function may either be a relative interval or an
absolute time of day deadline, a new initialization attribute has been created for condition variables to specify the clock that is
used for measuring the timeout in a call to pthread_cond_timedwait().
In this way, if a relative timeout is desired, the monotonic clock will be used; if an absolute deadline is required instead, the
CLOCK_REALTIME or another appropriate clock may be used. For condition variables, this capability is also available by passing
CLOCK_MONOTONIC to the pthread_cond_clockwait() function. Similarly,
CLOCK_MONOTONIC can be specified when calling pthread_mutex_clocklock(), pthread_rwlock_clockrdlock(), pthread_rwlock_clockwrlock(), and sem_clockwait().
It was later found necessary to add variants of almost all interfaces that accept absolute timeouts that allow the
clock to be specified. This is because, despite the claim in the previous paragraph, it is not possible to safely use a
CLOCK_REALTIME absolute timeout even to prevent errors when the system clock is warped by a potentially large amount. A "safety
timeout" of a minute on a call to pthread_mutex_timedlock() could
actually mean that the call would return ETIMEDOUT early without acquiring the lock if the system clock is warped forwards
immediately prior to or during the call. On the other hand, a short timeout could end up being arbitrarily long if the system clock
is warped backwards immediately prior to or during the call. These problems are solved by the new clockwait and
clocklock variants of the existing timedwait and timedlock functions. These variants accept an extra
clockid_t parameter to indicate the clock to be used for the wait. The clock ID is passed rather than using attributes as
previously for pthread_cond_timedwait() in order to allow the
ISO/IEC 14882:2011 standard (C++11) and later to be implemented correctly. C++ requires that the clock to use for the wait is
not known until the time of the wait call, so it cannot be supplied during creation. The new functions are pthread_cond_clockwait(), pthread_mutex_clocklock(), pthread_rwlock_clockrdlock(), pthread_rwlock_clockwrlock(), and sem_clockwait(). It is expected that mq_clockreceive() and
mq_clocksend() functions will be added in a future version of this standard.
The nanosleep() function has not been modified with the
introduction of the monotonic clock. Instead, a new clock_nanosleep()
function has been created, in which the desired clock may be specified in the function call.
History of Resolution Issues
Due to the shift from relative to absolute timeouts in IEEE Std 1003.1d-1999, the amendments to the
sem_timedwait(), pthread_mutex_timedlock(), mq_timedreceive(), and mq_timedsend() functions of that standard have been removed. Those amendments specified
that CLOCK_MONOTONIC would be used for the (relative) timeouts if the (optional at the time) Monotonic Clock was supported.
Having these functions continue to be tied solely to CLOCK_MONOTONIC would not work. Since the absolute value of a
time value obtained from CLOCK_MONOTONIC is unspecified, under the absolute timeouts interface, applications would behave
differently depending on whether the Monotonic Clock was supported or not (because the absolute value of the clock would have
different meanings in either case).
Two options were considered:
Leave the current behavior unchanged, which specifies the CLOCK_REALTIME clock for these (absolute) timeouts, to
allow portability of applications between implementations supporting or not the Monotonic Clock.
Modify these functions in the way that pthread_cond_timedwait() was modified to allow a choice of clock, so that an
application could use CLOCK_REALTIME when it is trying to achieve an absolute timeout and CLOCK_MONOTONIC when it is trying to
achieve a relative timeout.
It was decided that the features of CLOCK_MONOTONIC are not as critical to these functions as they are to pthread_cond_timedwait(). The pthread_cond_timedwait() function is given an absolute timeout; the timeout
may represent a deadline for an event. When other functions are given relative timeouts, the timeouts are typically for error
recovery purposes and need not be so precise.
Therefore, it was decided that these functions should be tied to CLOCK_REALTIME and not complicated by being given
a choice of clock.
Austin Group Defect 1346 is applied, requiring support for Monotonic Clock.
Execution Time Monitoring
Introduction
The main goals of the execution time monitoring facilities defined in this chapter are to measure the execution
time of processes and threads and to allow an application to establish CPU time limits for these entities.
The analysis phase of time-critical realtime systems often relies on the measurement of execution times of
individual threads or processes to determine whether the timing requirements will be met. Also, performance analysis techniques for
soft deadline realtime systems rely heavily on the determination of these execution times. The execution time monitoring functions
provide application developers with the ability to measure these execution times online and open the possibility of dynamic
execution-time analysis and system reconfiguration, if required.
The second goal of allowing an application to establish execution time limits for individual processes or threads
and detecting when they overrun allows program robustness to be increased by enabling online checking of the execution times.
If errors are detected—possibly because of erroneous program constructs, the existence of errors in the analysis
phase, or a burst of event arrivals—online detection and recovery is possible in a portable way. This feature can be extremely
important for many time-critical applications. Other applications require trapping CPU-time errors as a normal way to exit an
algorithm; for instance, some realtime artificial intelligence applications trigger a number of independent inference processes of
varying accuracy and speed, limit how long they can run, and pick the best answer available when time runs out. In many periodic
systems, overrun processes are simply restarted in the next resource period, after necessary end-of-period actions have been taken.
This allows algorithms that are inherently data-dependent to be made predictable.
The interface that appears in this chapter defines a new type of clock, the CPU-time clock, which measures
execution time. Each process or thread can invoke the clock and timer functions defined in POSIX.1 to use them. Functions are also
provided to access the CPU-time clock of other processes or threads to enable remote monitoring of these clocks. Monitoring of
threads of other processes is not supported, since these threads are not visible from outside of their own process with the
interfaces defined in POSIX.1.
Execution Time Monitoring Interface
The clock and timer interface defined in POSIX.1 historically only defined one clock, which measures wall-clock
time. The requirements for measuring execution time of processes and threads, and setting limits to their execution time by
detecting when they overrun, can be accomplished with that interface if a new kind of clock is defined. These new clocks measure
execution time, and one is associated with each process and with each thread. The clock functions currently defined in POSIX.1 can
be used to read and set these CPU-time clocks, and timers can be created using these clocks as their timing base. These timers can
then be used to send a signal when some specified execution time has been exceeded. The CPU-time clocks of each process or thread
can be accessed by using the symbols CLOCK_PROCESS_CPUTIME_ID or CLOCK_THREAD_CPUTIME_ID.
The clock and timer interface defined in POSIX.1 and extended with the new kind of CPU-time clock would only allow
processes or threads to access their own CPU-time clocks. However, many realtime systems require the possibility of monitoring the
execution time of processes or threads from independent monitoring entities. In order to allow applications to construct
independent monitoring entities that do not require cooperation from or modification of the monitored entities, two functions have
been added: clock_getcpuclockid(), for accessing CPU-time clocks of
other processes, and pthread_getcpuclockid(), for accessing CPU-time
clocks of other threads. These functions return the clock identifier associated with the process or thread specified in the call.
These clock IDs can then be used in the rest of the clock function calls.
The clocks accessed through these functions could also be used as a timing base for the creation of timers, thereby
allowing independent monitoring entities to limit the CPU time consumed by other entities. However, this possibility would imply
additional complexity and overhead because of the need to maintain a timer queue for each process or thread, to store the different
expiration times associated with timers created by different processes or threads. The working group decided this additional
overhead was not justified by application requirements. Therefore, creation of timers attached to the CPU-time clocks of other
processes or threads has been specified as implementation-defined.
Overhead Considerations
The measurement of execution time may introduce additional overhead in the thread scheduling, because of the need
to keep track of the time consumed by each of these entities. In library-level implementations of threads, the efficiency of
scheduling could be somehow compromised because of the need to make a kernel call, at each context switch, to read the process
CPU-time clock. Consequently, a thread creation attribute called cpu-clock-requirement was defined, to allow threads to
disconnect their respective CPU-time clocks. However, the Ballot Group considered that this attribute itself introduced some
overhead, and that in current implementations it was not worth the effort. Therefore, the attribute was deleted, and thus thread
CPU-time clocks are required for all threads if the Thread CPU-Time Clocks option is supported.
Accuracy of CPU-Time Clocks
The mechanism used to measure the execution time of processes and threads is specified in POSIX.1-2024 as
implementation-defined. The reason for this is that both the underlying hardware and the implementation architecture have a very
strong influence on the accuracy achievable for measuring CPU time. For some implementations, the specification of strict accuracy
requirements would represent very large overheads, or even the impossibility of being implemented.
Since the mechanism for measuring execution time is implementation-defined, realtime applications will be able to
take advantage of accurate implementations using a portable interface. Of course, strictly conforming applications cannot rely on
any particular degree of accuracy, in the same way as they cannot rely on a very accurate measurement of wall clock time. There
will always exist applications whose accuracy or efficiency requirements on the implementation are more rigid than the values
defined in POSIX.1-2024 or any other standard.
In any case, there is a minimum set of characteristics that realtime applications would expect from most
implementations. One such characteristic is that the sum of all the execution times of all the threads in a process equals the
process execution time, when no CPU-time clocks are disabled. This need not always be the case because implementations may differ
in how they account for time during context switches. Another characteristic is that the sum of the execution times of all
processes in a system equals the number of processors, multiplied by the elapsed time, assuming that no processor is idle during
that elapsed time. However, in some implementations it might not be possible to relate CPU time to elapsed time. For example, in a
heterogeneous multi-processor system in which each processor runs at a different speed, an implementation may choose to define each
"second" of CPU time to be a certain number of "cycles" that a CPU has executed.
Existing Practice
Measuring and limiting the execution time of each concurrent activity are common features of most industrial
implementations of realtime systems. Almost all critical realtime systems are currently built upon a cyclic executive. With this
approach, a regular timer interrupt kicks off the next sequence of computations. It also checks that the current sequence has
completed. If it has not, then some error recovery action can be undertaken (or at least an overrun is avoided). Current software
engineering principles and the increasing complexity of software are driving application developers to implement these systems on
multi-threaded or multi-process operating systems. Therefore, if a POSIX operating system is to be used for this type of
application, then it must offer the same level of protection.
Execution time clocks are also common in most UNIX implementations, although these clocks usually have requirements
different from those of realtime applications. The POSIX.1 times() function supports
the measurement of the execution time of the calling process, and its terminated child processes. This execution time is measured
in clock ticks and is supplied as two different values with the user and system execution times, respectively. BSD supports the
function getrusage(), which allows the calling process to get information about
the resources used by itself and/or all of its terminated child processes. The resource usage includes user and system CPU time.
Some UNIX systems have options to specify high resolution (up to one microsecond) CPU-time clocks using the times() or the getrusage() functions.
The times() and getrusage() interfaces do not meet important realtime requirements, such as the
possibility of monitoring execution time from a different process or thread, or the possibility of detecting an execution time
overrun. The latter requirement is supported in some UNIX implementations that are able to send a signal when the execution time of
a process has exceeded some specified value. For example, BSD defines the functions getitimer() and setitimer(),
which can operate either on a realtime clock (wall-clock), or on virtual-time or profile-time clocks which measure CPU time in two
different ways. These functions do not support access to the execution time of other processes.
At least one operating system supports per-process and per-thread execution time clocks, and also supports limiting
the execution time of a given process.
Given all this existing practice, the working group considered that the POSIX.1 clocks and timers interface was
appropriate to meet most of the requirements that realtime applications have for execution time clocks. Functions were added to get
the CPU time clock IDs, and to allow/disallow the thread CPU-time clocks (in order to preserve the efficiency of some
implementations of threads).
Clock Constants
The definition of the manifest constants CLOCK_PROCESS_CPUTIME_ID and CLOCK_THREAD_CPUTIME_ID allows processes or
threads, respectively, to access their own execution-time clocks. However, given a process or thread, access to its own
execution-time clock is also possible if the clock ID of this clock is obtained through a call to clock_getcpuclockid() or pthread_getcpuclockid(). Therefore, these constants are not necessary and
could be deleted to make the interface simpler. Their existence saves one system call in the first access to the CPU-time clock of
each process or thread. The working group considered this issue and decided to leave the constants in POSIX.1-2024 because they are
closer to the POSIX.1b use of clock identifiers.
Library Implementations of Threads
In library implementations of threads, kernel entities and library threads can coexist. In this case, if the
CPU-time clocks are supported, most of the clock and timer functions will need to have two implementations: one in the thread
library, and one in the system calls library. The main difference between these two implementations is that the thread library
implementation will have to deal with clocks and timers that reside in the thread space, while the kernel implementation will
operate on timers and clocks that reside in kernel space. In the library implementation, if the clock ID refers to a clock that
resides in the kernel, a kernel call will have to be made. The correct version of the function can be chosen by specifying the
appropriate order for the libraries during the link process.
History of Resolution Issues: Deletion of the enable Attribute
In early proposals, consideration was given to inclusion of an attribute called enable for CPU-time clocks.
This would allow implementations to avoid the overhead of measuring execution time for those processes or threads for which this
measurement was not required. However, this is unnecessary since processes are already required to measure execution time by the
POSIX.1 times() function. Consequently, the enable attribute is not
present.
Rationale Relating to Timeouts
Requirements for Timeouts
Realtime systems which must operate reliably over extended periods without human intervention are characteristic in
embedded applications such as avionics, machine control, and space exploration, as well as more mundane applications such as cable
TV, security systems, and plant automation. A multi-tasking paradigm, in which many independent and/or cooperating software
functions relinquish the processor(s) while waiting for a specific stimulus, resource, condition, or operation completion, is very
useful in producing well engineered programs for such systems. For such systems to be robust and fault-tolerant, expected
occurrences that are unduly delayed or that never occur must be detected so that appropriate recovery actions may be taken. This is
difficult if there is no way for a task to regain control of a processor once it has relinquished control (blocked) awaiting an
occurrence which, perhaps because of corrupted code, hardware malfunction, or latent software bugs, will not happen when expected.
Therefore, the common practice in realtime operating systems is to provide a capability to time out such blocking services.
Although there are several methods to achieve this already defined by POSIX, none are as reliable or efficient as initiating a
timeout simultaneously with initiating a blocking service. This is especially critical in hard-realtime embedded systems because
the processors typically have little time reserve, and allowed fault recovery times are measured in milliseconds rather than
seconds.
The working group largely agreed that such timeouts were necessary and ought to become part of POSIX.1-2024,
particularly vendors of realtime operating systems whose customers had already expressed a strong need for timeouts. There was some
resistance to inclusion of timeouts in POSIX.1-2024 because the desired effect, fault tolerance, could, in theory, be achieved
using existing facilities and alternative software designs, but there was no compelling evidence that realtime system designers
would embrace such designs at the sacrifice of performance and/or simplicity.
Which Services should be Timed Out?
Originally, the working group considered the prospect of providing timeouts on all blocking services, including
those currently existing in POSIX.1, POSIX.1b, and POSIX.1c, and future interfaces to be defined by other working groups, as sort
of a general policy. This was rather quickly rejected because of the scope of such a change, and the fact that many of those
services would not normally be used in a realtime context. More traditional timesharing solutions to timeout would suffice for most
of the POSIX.1 interfaces, while others had asynchronous alternatives which, while more complex to utilize, would be adequate for
some realtime and all non-realtime applications.
The list of potential candidates for timeouts was narrowed to the following for further consideration:
POSIX.1b
sem_wait()
mq_receive()
mq_send()
lio_listio()
aio_suspend()
sigwait() (timeout already implemented by sigtimedwait())
POSIX.1c
pthread_mutex_lock()
pthread_join()
pthread_cond_wait()
(timeout already implemented by pthread_cond_timedwait())
POSIX.1
read()
write()
After further review by the working group, the lio_listio(),
read(), and write() functions (all forms
of blocking synchronous I/O) were eliminated from the list because of the following:
Asynchronous alternatives exist
Timeouts can be implemented, albeit non-portably, in device drivers
A strong desire not to introduce modifications to POSIX.1 interfaces
The working group ultimately rejected pthread_join() since both
that interface and a timed variant of that interface are non-minimal and may be implemented as a function. See below for a library
implementation of pthread_join().
Thus, there was a consensus among the working group members to add timeouts to 4 of the remaining 5 functions (the
timeout for aio_suspend() was ultimately added directly to POSIX.1b, while the
others were added by POSIX.1d). However, pthread_mutex_lock() remained
contentious.
Many feel that pthread_mutex_lock() falls into the same
class as the other functions; that is, it is desirable to time out a mutex lock because a mutex may fail to be unlocked due to
errant or corrupted code in a critical section (looping or branching outside of the unlock code), and therefore is equally in need
of a reliable, simple, and efficient timeout. In fact, since mutexes are intended to guard small critical sections, most pthread_mutex_lock() calls would be expected to obtain the lock without blocking
nor utilizing any kernel service, even in implementations of threads with global contention scope; the timeout alternative need
only be considered after it is determined that the thread must block.
Those opposed to timing out mutexes feel that the very simplicity of the mutex is compromised by adding a timeout
semantic, and that to do so is senseless. They claim that if a timed mutex is really deemed useful by a particular application,
then it can be constructed from the facilities already in POSIX.1b and POSIX.1c. The following two C-language library
implementations of mutex locking with timeout represent the solutions offered (in both implementations, the timeout parameter is
specified as absolute time, not relative time as in the proposed POSIX.1c interfaces).
Spinlock Implementation
#include
#include
#include
int pthread_mutex_timedlock(pthread_mutex_t *mutex,
const struct timespec *timeout)
{
struct timespec timenow;
while (pthread_mutex_trylock(mutex) == EBUSY)
{
clock_gettime(CLOCK_REALTIME, &timenow);
if (timespec_cmp(&timenow,timeout) >= 0)
{
return ETIMEDOUT;
}
sched_yield();
}
return 0;
}
The Spinlock implementation is generally unsuitable for any application using priority-based thread scheduling
policies such as SCHED_FIFO or SCHED_RR, since the mutex could currently be held by a thread of lower priority within the same
allocation domain, but since the waiting thread never blocks, only threads of equal or higher priority will ever run, and the mutex
cannot be unlocked. Setting priority inheritance or priority ceiling protocol on the mutex does not solve this problem, since the
priority of a mutex owning thread is only boosted if higher priority threads are blocked waiting for the mutex; clearly not the
case for this spinlock.
Condition Wait Implementation
#include
#include
#include
struct timed_mutex {
int locked;
pthread_mutex_t mutex;
pthread_cond_t cond;
};
typedef struct timed_mutex timed_mutex_t;
int timed_mutex_lock(timed_mutex_t *tm,
const struct timespec *timeout)
{
int timedout=FALSE;
int error_status;
pthread_mutex_lock(&tm->mutex);
while (tm->locked && !timedout)
{
if ((error_status=pthread_cond_timedwait(&tm->cond,
&tm->mutex, timeout))!=0)
{
if (error_status==ETIMEDOUT) timedout = TRUE;
}
}
if(timedout)
{
pthread_mutex_unlock(&tm->mutex);
return ETIMEDOUT;
}
else
{
tm->locked = TRUE;
pthread_mutex_unlock(&tm->mutex);
return 0;
}
}
void timed_mutex_unlock(timed_mutex_t *tm)
{
pthread_mutex_lock(&tm->mutex); / for case assignment not atomic /
tm->locked = FALSE;
pthread_mutex_unlock(&tm->mutex);
pthread_cond_signal(&tm->cond);
}
The Condition Wait implementation effectively substitutes the pthread_cond_timedwait() function (which is currently timed out) for the
desired pthread_mutex_timedlock(). Since waits on condition
variables currently do not include protocols which avoid priority inversion, this method is generally unsuitable for realtime
applications because it does not provide the same priority inversion protection as the untimed pthread_mutex_lock(). Also, for any given implementations of the current mutex
and condition variable primitives, this library implementation has a performance cost at least 2.5 times that of the untimed
pthread_mutex_lock() even in the case where the timed mutex is readily
locked without blocking (the interfaces required for this case are shown in bold). Even in uniprocessors or where assignment is
atomic, at least an additional pthread_cond_signal() is required.
pthread_mutex_timedlock() could be implemented at effectively no
performance penalty in this case because the timeout parameters need only be considered after it is determined that the mutex
cannot be locked immediately.
Thus it has not yet been shown that the full semantics of mutex locking with timeout can be efficiently and
reliably achieved using existing interfaces. Even if the existence of an acceptable library implementation were proven, it is
difficult to justify why the interface itself should not be made portable, especially considering approval for the other four
timeouts.
Rationale for Library Implementation of pthread_timedjoin()
Library implementation of pthread_timedjoin():
/*
* Construct a thread variety entirely from existing functions
* with which a join can be done, allowing the join to time out.
*/
#include
#include
struct timed_thread {
pthread_t t;
pthread_mutex_t m;
int exiting;
pthread_cond_t exit_c;
void *(*start_routine)(void *arg);
void *arg;
void *status;
};
typedef struct timed_thread *timed_thread_t;
static pthread_key_t timed_thread_key;
static pthread_once_t timed_thread_once = PTHREAD_ONCE_INIT;
static void timed_thread_init()
{
pthread_key_create(&timed_thread_key, NULL);
}
static void *timed_thread_start_routine(void *args)
/*
* Routine to establish thread-specific data value and run the actual
* thread start routine which was supplied to timed_thread_create().
*/
{
timed_thread_t tt = (timed_thread_t) args;
pthread_once(&timed_thread_once, timed_thread_init);
pthread_setspecific(timed_thread_key, (void *)tt);
timed_thread_exit((tt->start_routine)(tt->arg));
}
int timed_thread_create(timed_thread_t ttp, const pthread_attr_t *attr,
void *(*start_routine)(void *), void *arg)
/*
* Allocate a thread which can be used with timed_thread_join().
*/
{
timed_thread_t tt;
int result;
tt = (timed_thread_t) malloc(sizeof(struct timed_thread));
pthread_mutex_init(&tt->m,NULL);
tt->exiting = FALSE;
pthread_cond_init(&tt->exit_c,NULL);
tt->start_routine = start_routine;
tt->arg = arg;
tt->status = NULL;
if ((result = pthread_create(&tt->t, attr,
timed_thread_start_routine, (void *)tt)) != 0) {
free(tt);
return result;
}
pthread_detach(tt->t);
ttp = tt;
return 0;
}
int timed_thread_join(timed_thread_t tt,
struct timespec *timeout,
void **status)
{
int result;
pthread_mutex_lock(&tt->m);
result = 0;
/*
* Wait until the thread announces that it is exiting,
* or until timeout.
*/
while (result == 0 && ! tt->exiting) {
result = pthread_cond_timedwait(&tt->exit_c, &tt->m, timeout);
}
pthread_mutex_unlock(&tt->m);
if (result == 0 && tt->exiting) {
*status = tt->status;
free((void *)tt);
return result;
}
return result;
}
void timed_thread_exit(void *status)
{
timed_thread_t tt;
void *specific;
if ((specific=pthread_getspecific(timed_thread_key)) == NULL){
/*
* Handle cases which will not happen with correct usage.
*/
pthread_exit( NULL);
}
tt = (timed_thread_t) specific;
pthread_mutex_lock(&tt->m);
/*
* Tell a joiner that we are exiting.
*/
tt->status = status;
tt->exiting = TRUE;
pthread_cond_signal(&tt->exit_c);
pthread_mutex_unlock(&tt->m);
/*
* Call pthread exit() to call destructors and really
* exit the thread.
*/
pthread_exit(NULL);
}
The pthread_join() C-language example shown above demonstrates
that it is possible, using existing pthread facilities, to construct a variety of thread which allows for joining such a thread,
but which allows the join operation to time out. It does this by using a pthread_cond_timedwait() to wait for the thread to exit. A
timed_thread_t descriptor structure is used to pass parameters from the creating thread to the created thread, and from the
exiting thread to the joining thread. This implementation is roughly equivalent to what a normal pthread_join() implementation would do, with the single change being that pthread_cond_timedwait() is used in place of a simple pthread_cond_wait().
Since it is possible to implement such a facility entirely from existing pthread interfaces, and with roughly equal
efficiency and complexity to an implementation which would be provided directly by a pthreads implementation, it was the consensus
of the working group members that any pthread_timedjoin() facility would be unnecessary, and should not be provided.
Form of the Timeout Interfaces
The working group considered a number of alternative ways to add timeouts to blocking services. At first, a system
interface which would specify a one-shot or persistent timeout to be applied to subsequent blocking services invoked by the calling
process or thread was considered because it allowed all blocking services to be timed out in a uniform manner with a single
additional interface; this was rather quickly rejected because it could easily result in the wrong services being timed out.
It was suggested that a timeout value might be specified as an attribute of the object (semaphore, mutex, message
queue, and so on), but there was no consensus on this, either on a case-by-case basis or for all timeouts.
Looking at the two existing timeouts for blocking services indicates that the working group members favor a
separate interface for the timed version of a function. However, pthread_cond_timedwait() utilizes an absolute timeout value while sigtimedwait() uses a relative timeout value. The working group members agreed that
relative timeout values are appropriate where the timeout mechanism's primary use was to deal with an unexpected or error
situation, but they are inappropriate when the timeout must expire at a particular time, or before a specific deadline. For the
timeouts being introduced in POSIX.1-2024, the working group considered allowing both relative and absolute timeouts as is done
with POSIX.1b timers, but ultimately favored the simpler absolute timeout form.
An absolute time measure can be easily implemented on top of an interface that specifies relative time, by reading
the clock, calculating the difference between the current time and the desired wakeup time, and issuing a relative timeout call.
But there is a race condition with this approach because the thread could be preempted after reading the clock, but before making
the timed-out call; in this case, the thread would be awakened later than it should and, thus, if the wakeup time represented a
deadline, it would miss it.
There is also a race condition when trying to build a relative timeout on top of an interface that specifies
absolute timeouts. In this case, the clock would have to be read to calculate the absolute wakeup time as the sum of the current
time plus the relative timeout interval. In this case, if the thread is preempted after reading the clock but before making the
timed-out call, the thread would be awakened earlier than desired.
But the race condition with the absolute timeouts interface is not as bad as the one that happens with the relative
timeout interface, because there are simple workarounds. For the absolute timeouts interface, if the timing requirement is a
deadline, the deadline can still be met because the thread woke up earlier than the deadline. If the timeout is just used as an
error recovery mechanism, the precision of timing is not really important. If the timing requirement is that between actions A and
B a minimum interval of time must elapse, the absolute timeout interface can be safely used by reading the clock after action A has
been started. It could be argued that, since the call with the absolute timeout is atomic from the application point of view, it is
not possible to read the clock after action A, if this action is part of the timed-out call. But looking at the nature of the calls
for which timeouts are specified (locking a mutex, waiting for a semaphore, waiting for a message, or waiting until there is space
in a message queue), the timeouts that an application would build on these actions would not be triggered by these actions
themselves, but by some other external action. For example, if waiting for a message to arrive to a message queue, and waiting for
at least 20 milliseconds, this time interval would start to be counted from some event that would trigger both the action that
produces the message, as well as the action that waits for the message to arrive, and not by the wait-for-message operation itself.
In this case, the workaround proposed above could be used.
For these reasons, the absolute timeout is preferred over the relative timeout interface.
B.2.9 Threads
Threads will normally be more expensive than subroutines (or functions, routines, and so on) if specialized
hardware support is not provided. Nevertheless, threads should be sufficiently efficient to encourage their use as a medium to
fine-grained structuring mechanism for parallelism in an application. Structuring an application using threads then allows it to
take immediate advantage of any underlying parallelism available in the host environment. This means implementors are encouraged to
optimize for fast execution at the possible expense of efficient utilization of storage. For example, a common thread creation
technique is to cache appropriate thread data structures. That is, rather than releasing system resources, the implementation
retains these resources and reuses them when the program next asks to create a new thread. If this reuse of thread resources is to
be possible, there has to be very little unique state associated with each thread, because any such state has to be reset when the
thread is reused.
Thread Creation Attributes
Attributes objects are provided for threads, mutexes, and condition variables as a mechanism to support probable
future standardization in these areas without requiring that the interface itself be changed.
Attributes objects provide clean isolation of the configurable aspects of threads. For example, "stack size" is
an important attribute of a thread, but it cannot be expressed portably. When porting a threaded program, stack sizes often need to
be adjusted. The use of attributes objects can help by allowing the changes to be isolated in a single place, rather than being
spread across every instance of thread creation.
Attributes objects can be used to set up classes of threads with similar attributes; for example, "threads
with large stacks and high priority" or "threads with minimal stacks". These classes can be defined in a single place and then
referenced wherever threads need to be created. Changes to "class" decisions become straightforward, and detailed analysis of
each pthread_create() call is not required.
The attributes objects are defined as opaque types as an aid to extensibility. If these objects had been specified
as structures, adding new attributes would force recompilation of all multi-threaded programs when the attributes objects are
extended; this might not be possible if different program components were supplied by different vendors.
Additionally, opaque attributes objects present opportunities for improving performance. Argument validity can be
checked once when attributes are set, rather than each time a thread is created. Implementations will often need to cache kernel
objects that are expensive to create. Opaque attributes objects provide an efficient mechanism to detect when cached objects become
invalid due to attribute changes.
Because assignment is not necessarily defined on a given opaque type, implementation-defined default values cannot
be defined in a portable way. The solution to this problem is to allow attribute objects to be initialized dynamically by
attributes object initialization functions, so that default values can be supplied automatically by the implementation.
The following proposal was provided as a suggested alternative to the supplied attributes:
Maintain the style of passing a parameter formed by the bitwise-inclusive OR of flags to the initialization
routines (pthread_create(), pthread_mutex_init(), pthread_cond_init()). The parameter containing the flags should be an opaque type
for extensibility. If no flags are set in the parameter, then the objects are created with default characteristics. An
implementation may specify implementation-defined flag values and associated behavior.
If further specialization of mutexes and condition variables is necessary, implementations may specify additional
procedures that operate on the pthread_mutex_t and pthread_cond_t objects (instead of on attributes objects).
The difficulties with this solution are:
A bitmask is not opaque if bits have to be set into bit-vector attributes objects using explicitly-coded
bitwise-inclusive OR operations. If the set of options exceeds an int, application programmers need to know the location of
each bit. If bits are set or read by encapsulation (that is, get*() or set*() functions), then the bitmask is merely
an implementation of attributes objects as currently defined and should not be exposed to the programmer.
Many attributes are not Boolean or very small integral values. For example, scheduling policy may be placed in 3
bits or 4 bits, but priority requires 5 bits or more, thereby taking up at least 8 bits out of a possible 16 bits on machines with
16-bit integers. Because of this, the bitmask can only reasonably control whether particular attributes are set or not, and it
cannot serve as the repository of the value itself. The value needs to be specified as a function parameter (which is
non-extensible), or by setting a structure field (which is non-opaque), or by get*() and set*() functions (making the
bitmask a redundant addition to the attributes objects).
Stack size is defined as an optional attribute because the very notion of a stack is inherently machine-dependent.
Some implementations may not be able to change the size of the stack, for example, and others may not need to because stack pages
may be discontiguous and can be allocated and released on demand.
The attribute mechanism has been designed in large measure for extensibility. Future extensions to the attribute
mechanism or to any attributes object defined in POSIX.1-2024 have to be done with care so as not to affect
binary-compatibility.
Attribute objects, even if allocated by means of dynamic allocation functions such as malloc(), may have their size fixed at compile time. This means, for example, a pthread_create() in an implementation with extensions to the pthread_attr_t
cannot look beyond the area that the binary application assumes is valid. This suggests that implementations should maintain a size
field in the attributes object, as well as possibly version information, if extensions in different directions (possibly by
different vendors) are to be accommodated.
Thread Implementation Models
There are various thread implementation models. At one end of the spectrum is the "library-thread model". In such
a model, the threads of a process are not visible to the operating system kernel, and the threads are not kernel-scheduled
entities. The process is the only kernel-scheduled entity. The process is scheduled onto the processor by the kernel according to
the scheduling attributes of the process. The threads are scheduled onto the single kernel-scheduled entity (the process) by the
runtime library according to the scheduling attributes of the threads. A problem with this model is that it constrains concurrency.
Since there is only one kernel-scheduled entity (namely, the process), only one thread per process can execute at a time. If the
thread that is executing blocks on I/O, then the whole process blocks.
At the other end of the spectrum is the "kernel-thread model". In this model, all threads are visible to the
operating system kernel. Thus, all threads are kernel-scheduled entities, and all threads can concurrently execute. The threads are
scheduled onto processors by the kernel according to the scheduling attributes of the threads. The drawback to this model is that
the creation and management of the threads entails operating system calls, as opposed to subroutine calls, which makes kernel
threads heavier weight than library threads.
Hybrids of these two models are common. A hybrid model offers the speed of library threads and the concurrency of
kernel threads. In hybrid models, a process has some (relatively small) number of kernel scheduled entities associated with it. It
also has a potentially much larger number of library threads associated with it. Some library threads may be bound to
kernel-scheduled entities, while the other library threads are multiplexed onto the remaining kernel-scheduled entities. There are
two levels of thread scheduling:
The runtime library manages the scheduling of (unbound) library threads onto kernel-scheduled entities.
The kernel manages the scheduling of kernel-scheduled entities onto processors.
For this reason, a hybrid model is referred to as a two-level threads scheduling model. In this model, the process
can have multiple concurrently executing threads; specifically, it can have as many concurrently executing threads as it has
kernel-scheduled entities.
Thread-Specific Data
Many applications require that a certain amount of context be maintained on a per-thread basis across procedure
calls. A common example is a multi-threaded library routine that allocates resources from a common pool and maintains an active
resource list for each thread. The thread-specific data interface provided to meet these needs may be viewed as a two-dimensional
array of values with keys serving as the row index and thread IDs as the column index (although the implementation need not work
this way).
Models
Three possible thread-specific data models were considered:
No Explicit Support
A standard thread-specific data interface is not strictly necessary to support applications that require per-thread
context. One could, for example, provide a hash function that converted a pthread_t into an integer value that could then be
used to index into a global array of per-thread data pointers. This hash function, in conjunction with pthread_self(), would be all the interface required to support a mechanism of this
sort. Unfortunately, this technique is cumbersome. It can lead to duplicated code as each set of cooperating modules implements
their own per-thread data management schemes. This technique would also require that pthread_t not be an opaque type.
Single (void *) Pointer
Another technique would be to provide a single word of per-thread storage and a pair of functions to fetch and
store the value of this word. The word could then hold a pointer to a block of per-thread memory. The allocation, partitioning, and
general use of this memory would be entirely up to the application. Although this method is not as problematic as technique 1, it
suffers from interoperability problems. For example, all modules using the per-thread pointer would have to agree on a common usage
protocol.
Key/Value Mechanism
This method associates an opaque key (for example, stored in a variable of type pthread_key_t) with each
per-thread datum. These keys play the role of identifiers for per-thread data. This technique is the most generic and avoids the
problems noted above, albeit at the cost of some complexity.
The primary advantage of the third model is its information hiding properties. Modules using this model are free to
create and use their own key(s) independent of all other such usage, whereas the other models require that all modules that use
thread-specific context explicitly cooperate with all other such modules. The data-independence provided by the third model is
worth the additional interface. Therefore, the third model was chosen.
Requirements
It is important that it be possible to implement the thread-specific data interface without the use of thread
private memory. To do otherwise would increase the weight of each thread, thereby limiting the range of applications for which the
threads interfaces provided by POSIX.1-2024 is appropriate.
The values that one binds to the key via pthread_setspecific() may, in fact, be pointers to shared storage locations
available to all threads. It is only the key/value bindings that are maintained on a per-thread basis, and these can be kept in any
portion of the address space that is reserved for use by the calling thread (for example, on the stack). Thus, no per-thread MMU
state is required to implement the interface. On the other hand, there is nothing in the interface specification to preclude the
use of a per-thread MMU state if it is available (for example, the key values returned by pthread_key_create() could be thread private memory addresses).
Standardization Issues
Thread-specific data is a requirement for a usable thread interface. The binding described in this section provides
a portable thread-specific data mechanism for languages that do not directly support a thread-specific storage class. A binding to
POSIX.1-2024 for a language that does include such a storage class need not provide this specific interface.
If a language were to include the notion of thread-specific storage, it would be desirable (but not
required) to provide an implementation of the pthreads thread-specific data interface based on the language feature. For example,
assume that a compiler for a C-like language supports a private storage class that provides thread-specific storage.
Something similar to the following macros might be used to effect a compatible implementation:
#define pthread_key_t                   private void *
#define pthread_key_create(key)         /* no-op */
#define pthread_setspecific(key,value)  (key)=(value)
#define pthread_getspecific(key)        (key)
Note:
For the sake of clarity, this example ignores destructor functions. A correct implementation would have to support them.
Barriers
Background
Barriers are typically used in parallel DO/FOR loops to ensure that all threads have reached a particular stage in
a parallel computation before allowing any to proceed to the next stage. Highly efficient implementation is possible on machines
which support a "Fetch and Add" operation as described in the referenced Almasi and Gottlieb (1989).
The use of return value PTHREAD_BARRIER_SERIAL_THREAD is shown in the following example:
if ( (status=pthread_barrier_wait(&barrier)) ==
PTHREAD_BARRIER_SERIAL_THREAD) {
...serial section
}
else if (status != 0) {
...error processing
}
status=pthread_barrier_wait(&barrier);
...
This behavior allows a serial section of code to be executed by one thread as soon as all threads reach the first
barrier. The second barrier prevents the other threads from proceeding until the serial section being executed by the one thread
has completed.
Although barriers can be implemented with mutexes and condition variables, the referenced Almasi and Gottlieb
(1989) provides ample illustration that such implementations are significantly less efficient than is possible. While the relative
efficiency of barriers may well vary by implementation, it is important that they be recognized in the POSIX.1-2024 to facilitate
applications portability while providing the necessary freedom to implementors.
Lack of Timeout Feature
Alternate versions of most blocking routines have been provided to support watchdog timeouts. No alternate
interface of this sort has been provided for barrier waits for the following reasons:
Multiple threads may use different timeout values, some of which may be indefinite. It is not clear which threads
should break through the barrier with a timeout error if and when these timeouts expire.
The barrier may become unusable once a thread breaks out of a pthread_barrier_wait() with a timeout error. There is, in general, no way to
guarantee the consistency of a barrier's internal data structures once a thread has timed out of a pthread_barrier_wait(). Even the inclusion of a special barrier
reinitialization function would not help much since it is not clear how this function would affect the behavior of threads that
reach the barrier between the original timeout and the call to the reinitialization function.
Spin Locks
Background
Spin locks represent an extremely low-level synchronization mechanism suitable primarily for use on shared memory
multi-processors. It is typically an atomically modified Boolean value that is set to one when the lock is held and to zero when
the lock is freed.
When a caller requests a spin lock that is already held, it typically spins in a loop testing whether the lock has
become available. Such spinning wastes processor cycles so the lock should only be held for short durations and not across
sleep/block operations. Callers should unlock spin locks before calling sleep operations.
Spin locks are available on a variety of systems. The functions included in POSIX.1-2024 are an attempt to
standardize that existing practice.
Lack of Timeout Feature
Alternate versions of most blocking routines have been provided to support watchdog timeouts. No alternate
interface of this sort has been provided for spin locks for the following reasons:
It is impossible to determine appropriate timeout intervals for spin locks in a portable manner. The amount of
time one can expect to spend spin-waiting is inversely proportional to the degree of parallelism provided by the system.
It can vary from a few cycles when each competing thread is running on its own processor, to an indefinite amount
of time when all threads are multiplexed on a single processor (which is why spin locking is not advisable on uniprocessors).
When used properly, the amount of time the calling thread spends waiting on a spin lock should be considerably
less than the time required to set up a corresponding watchdog timer. Since the primary purpose of spin locks is to provide a
low-overhead synchronization mechanism for multi-processors, the overhead of a timeout mechanism was deemed unacceptable.
It was also suggested that an additional count argument be provided (on the pthread_spin_lock() call) in lieu of a true timeout so that a spin lock
call could fail gracefully if it was unable to apply the lock after count attempts. This idea was rejected because it is not
existing practice. Furthermore, the same effect can be obtained with pthread_spin_trylock(), as illustrated below:
int n = MAX_SPIN;
while ( --n >= 0 )
{
if ( !pthread_spin_try_lock(...) )
break;
}
if ( n >= 0 )
{
/* Successfully acquired the lock */
}
else
{
/* Unable to acquire the lock */
}
process-shared Attribute
The initialization functions associated with most POSIX synchronization objects (for example, mutexes, barriers,
and read-write locks) take an attributes object with a process-shared attribute that specifies whether or not the object is
to be shared across processes. In the draft corresponding to the first balloting round, two separate initialization functions are
provided for spin locks, however: one for spin locks that were to be shared across processes (spin_init()), and one for
locks that were only used by multiple threads within a single process (pthread_spin_init()). This was done so as to keep the overhead associated with
spin waiting to an absolute minimum. However, the balloting group requested that, since the overhead associated to a bit check was
small, spin locks should be consistent with the rest of the synchronization primitives, and thus the process-shared
attribute was introduced for spin locks.
Spin Locks versus Mutexes
It has been suggested that mutexes are an adequate synchronization mechanism and spin locks are not necessary.
Locking mechanisms typically must trade off the processor resources consumed while setting up to block the thread and the processor
resources consumed by the thread while it is blocked. Spin locks require very little resources to set up the blocking of a thread.
Existing practice is to simply loop, repeating the atomic locking operation until the lock is available. While the resources
consumed to set up blocking of the thread are low, the thread continues to consume processor resources while it is waiting.
On the other hand, mutexes may be implemented such that the processor resources consumed to block the thread are
large relative to a spin lock. After detecting that the mutex lock is not available, the thread must alter its scheduling state,
add itself to a set of waiting threads, and, when the lock becomes available again, undo all of this before taking over ownership
of the mutex. However, while a thread is blocked by a mutex, no processor resources are consumed.
Therefore, spin locks and mutexes may be implemented to have different characteristics. Spin locks may have lower
overall overhead for very short-term blocking, and mutexes may have lower overall overhead when a thread will be blocked for longer
periods of time. The presence of both interfaces allows implementations with these two different characteristics, both of which may
be useful to a particular application.
It has also been suggested that applications can build their own spin locks from the pthread_mutex_trylock() function:
while (pthread_mutex_trylock(&mutex));
The apparent simplicity of this construct is somewhat deceiving, however. While the actual wait is quite efficient,
various guarantees on the integrity of mutex objects (for example, priority inheritance rules) may add overhead to the successful
path of the trylock operation that is not required of spin locks. One could, of course, add an attribute to the mutex to bypass
such overhead, but the very act of finding and testing this attribute represents more overhead than is found in the typical spin
lock.
The need to hold spin lock overhead to an absolute minimum also makes it impossible to provide guarantees against
starvation similar to those provided for mutexes or read-write locks. The overhead required to implement such guarantees (for
example, disabling preemption before spinning) may well exceed the overhead of the spin wait itself by many orders of magnitude. If
a "safe" spin wait seems desirable, it can always be provided (albeit at some performance cost) via appropriate mutex
attributes.
Robust Mutexes
Robust mutexes are intended to protect applications that use mutexes to protect data shared between different
processes. If a process is terminated by a signal while a thread is holding a mutex, there is no chance for the process to clean up
after it. Waiters for the locked mutex might wait indefinitely.
With robust mutexes the problem can be solved: whenever a fatal signal terminates a process, current or future
waiters of the mutex are notified about this fact. The locking function provides notification of this condition through the error
condition [EOWNERDEAD]. A thread then has the chance to clean up the state protected by the mutex and mark the state as consistent
again by a call to pthread_mutex_consistent().
Pre-existing implementations have used the semantics of robust mutexes for a variety of situations, some of them
not defined in the standard. Where a normally terminated process (i.e., when one thread calls exit()) causes notification of other waiters of robust mutexes if the mutex is locked by any
thread in the process. This behavior is defined in the standard and makes sense because no thread other than the thread calling
exit() has the chance to clean up its data.
If a thread is terminated by cancellation or if it calls pthread_exit(), the situation is different. In both these situations the thread has the
chance to clean up after itself by registering appropriate cleanup handlers. There is no real reason to demand that other waiters
for a robust mutex the terminating thread owns are notified. The committee felt that this is actively encouraging bad practice
because programmers are tempted to rely on the robust mutex semantics instead of correctly cleaning up after themselves.
Therefore, the standard does not require notification of other waiters at the time a thread is terminated while the
process continues to run. The mutex is still recognized as being locked by the process (with the thread gone it makes no sense to
refer to the thread owning the mutex). Therefore, a terminating process will cause notifications about the dead owner to be sent to
all waiters. This delay in the notification is not required, but programmers cannot rely on prompt notification after a thread is
terminated.
For the same reason is it not required that an implementation supports robust mutexes that are not shared between
processes. If a robust mutex is used only within one process, all the cleanup can be performed by the threads themselves by
registering appropriate cleanup handlers. Fatal signals are of no importance in this case because after the signal is delivered
there is no thread remaining to use the mutex.
Some implementations might choose to support intra-process robust mutexes and they might also send notification of
a dead owner right after the previous owner died. But applications must not rely on this. Applications should only use robust
mutexes for the purpose of handling fatal signals in situations where inter-process mutexes are in use.
Supported Threads Functions
On POSIX-conforming systems, the following symbolic constants are always conforming:
_POSIX_READER_WRITER_LOCKS
_POSIX_THREADS
Therefore, the following threads functions are always supported:
pthread_atfork()
pthread_attr_destroy()
pthread_attr_getdetachstate()
pthread_attr_getguardsize()
pthread_attr_getschedparam()
pthread_attr_init()
pthread_attr_setdetachstate()
pthread_attr_setguardsize()
pthread_attr_setschedparam()
pthread_cancel()
pthread_cleanup_pop()
pthread_cleanup_push()
pthread_cond_broadcast()
pthread_cond_clockwait()
pthread_cond_destroy()
pthread_cond_init()
pthread_cond_signal()
pthread_cond_timedwait()
pthread_cond_wait()
pthread_condattr_destroy()
pthread_condattr_getpshared()
pthread_condattr_init()
pthread_condattr_setpshared()
pthread_create()
pthread_detach()
pthread_equal()
pthread_exit()
pthread_getspecific()
pthread_join()
pthread_key_create()
pthread_key_delete()
pthread_kill()
pthread_mutex_destroy()
pthread_mutex_init()
pthread_mutex_lock()
pthread_mutex_trylock()
pthread_mutex_unlock()
pthread_mutexattr_destroy()
pthread_mutexattr_getpshared()
pthread_mutexattr_gettype()
pthread_mutexattr_init()
pthread_mutexattr_setpshared()
pthread_mutexattr_settype()
pthread_once()
pthread_rwlock_destroy()
pthread_rwlock_init()
pthread_rwlock_rdlock()
pthread_rwlock_tryrdlock()
pthread_rwlock_trywrlock()
pthread_rwlock_unlock()
pthread_rwlock_wrlock()
pthread_rwlockattr_destroy()
pthread_rwlockattr_getpshared()
pthread_rwlockattr_init()
pthread_rwlockattr_setpshared()
pthread_self()
pthread_setcancelstate()
pthread_setcanceltype()
pthread_setspecific()
pthread_sigmask()
pthread_testcancel()
sigwait()
On POSIX-conforming systems, the symbolic constant _POSIX_THREAD_SAFE_FUNCTIONS is always defined. Therefore, the
following functions are always supported:
flockfile()
ftrylockfile()
funlockfile()
getc_unlocked()
getchar_unlocked()
getgrgid_r()
getgrnam_r()
getpwnam_r()
getpwuid_r()
gmtime_r()
localtime_r()
putc_unlocked()
putchar_unlocked()
readdir_r()
strerror_r()
strtok_r()
Threads Extensions
The following extensions to the IEEE P1003.1c draft standard are now supported in POSIX.1-2024 as part of the
alignment with the Single UNIX Specification:
Extended mutex attribute types
Read-write locks and attributes (also introduced by the IEEE Std 1003.1j-2000 amendment)
Thread concurrency level
Thread stack guard size
Parallel I/O
Robust mutexes
These extensions carefully follow the threads programming model specified in POSIX.1c. As with POSIX.1c, all the
new functions return zero if successful; otherwise, an error number is returned to indicate the error.
The concept of attribute objects was introduced in POSIX.1c to allow implementations to extend POSIX.1-2024 without
changing the existing interfaces. Attribute objects were defined for threads, mutexes, and condition variables. Attributes objects
are defined as implementation-defined opaque types to aid extensibility, and functions are defined to allow attributes to be set or
retrieved. This model has been followed when adding the new type attribute of pthread_mutexattr_t or the new read-write lock
attributes object pthread_rwlockattr_t.
Extended Mutex Attributes
POSIX.1c defines a mutex attributes object as an implementation-defined opaque object of type
pthread_mutexattr_t, and specifies a number of attributes which this object must have and a number of functions which
manipulate these attributes. These attributes include detachstate, inheritsched, schedparm,
schedpolicy, contentionscope, stackaddr, and stacksize.
The System Interfaces volume of POSIX.1-2024 specifies another mutex attribute called type. The type
attribute allows applications to specify the behavior of mutex locking operations in situations where POSIX.1c behavior is
undefined. The OSF DCE threads implementation, based on Draft 4 of POSIX.1c, specified a similar attribute. Note that the names of
the attributes have changed somewhat from the OSF DCE threads implementation.
The System Interfaces volume of POSIX.1-2024 also extends the specification of the following POSIX.1c functions
which manipulate mutexes:
pthread_mutex_lock()
pthread_mutex_trylock()
pthread_mutex_unlock()
to take account of the new mutex attribute type and to specify behavior which was declared as undefined in
POSIX.1c. How a calling thread acquires or releases a mutex now depends upon the mutex type attribute.
The type attribute can have the following values:
PTHREAD_MUTEX_NORMAL
Basic mutex with no specific error checking built in. Does not report a deadlock error.
PTHREAD_MUTEX_RECURSIVE
Allows any thread to recursively lock a mutex. The mutex must be unlocked an equal number of times to release the mutex.
PTHREAD_MUTEX_ERRORCHECK
Detects and reports simple usage errors; that is, an attempt to unlock a mutex that is not locked by the calling thread or that is
not locked at all, or an attempt to relock a mutex the thread already owns.
PTHREAD_MUTEX_DEFAULT
The default mutex type. May be mapped to any of the above mutex types or may be an implementation-defined type.
Normal mutexes do not detect deadlock conditions; for example, a thread will hang if it tries to relock a
normal mutex that it already owns. Attempting to unlock a mutex locked by another thread, or unlocking an unlocked mutex, results
in undefined behavior. Normal mutexes will usually be the fastest type of mutex available on a platform but provide the least error
checking.
Recursive mutexes are useful for converting old code where it is difficult to establish clear boundaries of
synchronization. A thread can relock a recursive mutex without first unlocking it. The relocking deadlock which can occur with
normal mutexes cannot occur with this type of mutex. However, multiple locks of a recursive mutex require the same number of
unlocks to release the mutex before another thread can acquire the mutex. Furthermore, this type of mutex maintains the concept of
an owner. Thus, a thread attempting to unlock a recursive mutex which another thread has locked returns with an error. A thread
attempting to unlock a recursive mutex that is not locked returns with an error. Never use a recursive mutex with condition
variables because the implicit unlock performed by pthread_cond_clockwait(), pthread_cond_timedwait(), or pthread_cond_wait() will not actually release the mutex if it had been locked
multiple times.
Errorcheck mutexes provide error checking and are useful primarily as a debugging aid. A thread attempting
to relock an errorcheck mutex without first unlocking it returns with an error. Again, this type of mutex maintains the concept of
an owner. Thus, a thread attempting to unlock an errorcheck mutex which another thread has locked returns with an error. A thread
attempting to unlock an errorcheck mutex that is not locked also returns with an error. It should be noted that errorcheck mutexes
will almost always be much slower than normal mutexes due to the extra state checks performed.
The default mutex type provides implementation-defined error checking. The default mutex may be mapped to one of
the other defined types or may be something entirely different. This enables each vendor to provide the mutex semantics which the
vendor feels will be most useful to their target users. Most vendors will probably choose to make normal mutexes the default so as
to give applications the benefit of the fastest type of mutexes available on their platform. Check your implementation's
documentation.
An application developer can use any of the mutex types almost interchangeably as long as the application does not
depend upon the implementation detecting (or failing to detect) any particular errors. Note that a recursive mutex can be used with
condition variable waits as long as the application never recursively locks the mutex.
Two functions are provided for manipulating the type attribute of a mutex attributes object. This attribute
is set or returned in the type parameter of these functions. The pthread_mutexattr_settype() function is used to set a specific type value
while pthread_mutexattr_gettype() is used to return the type of
the mutex. Setting the type attribute of a mutex attributes object affects only mutexes initialized using that mutex
attributes object. Changing the type attribute does not affect mutexes previously initialized using that mutex attributes
object.
Read-Write Locks and Attributes
The read-write locks introduced have been harmonized with those in IEEE Std 1003.1j-2000; see also
B.2.9.6 Thread Read-Write Locks.
Read-write locks (also known as reader-writer locks) allow a thread to exclusively lock some shared data while
updating that data, or allow any number of threads to have simultaneous read-only access to the data.
Unlike a mutex, a read-write lock distinguishes between reading data and writing data. A mutex excludes all other
threads. A read-write lock allows other threads access to the data, providing no thread is modifying the data. Thus, a read-write
lock is less primitive than either a mutex-condition variable pair or a semaphore.
Application developers should consider using a read-write lock rather than a mutex to protect data that is
frequently referenced but seldom modified. Most threads (readers) will be able to read the data without waiting and will only have
to block when some other thread (a writer) is in the process of modifying the data. Conversely a thread that wants to change the
data is forced to wait until there are no readers. This type of lock is often used to facilitate parallel access to data on
multi-processor platforms or to avoid context switches on single processor platforms where multiple threads access the same
data.
If a read-write lock becomes unlocked and there are multiple threads waiting to acquire the write lock, the
implementation's scheduling policy determines which thread acquires the read-write lock for writing. If there are multiple threads
blocked on a read-write lock for both read locks and write locks, it is unspecified whether the readers or a writer acquire the
lock first. However, for performance reasons, implementations often favor writers over readers to avoid potential writer
starvation.
A read-write lock object is an implementation-defined opaque object of type pthread_rwlock_t as defined in
. There are two different sorts of locks associated with a
read-write lock: a read lock and a write lock.
The pthread_rwlockattr_init() function initializes a
read-write lock attributes object with the default value for all the attributes defined in the implementation. After a read-write
lock attributes object has been used to initialize one or more read-write locks, changes to the read-write lock attributes object,
including destruction, do not affect previously initialized read-write locks.
Implementations must provide at least the read-write lock attribute process-shared. This attribute can have
the following values:
PTHREAD_PROCESS_SHARED
Any thread of any process that has access to the memory where the read-write lock resides can manipulate the read-write lock.
PTHREAD_PROCESS_PRIVATE
Only threads created within the same process as the thread that initialized the read-write lock can manipulate the read-write lock.
This is the default value.
The pthread_rwlockattr_setpshared() function
is used to set the process-shared attribute of an initialized read-write lock attributes object while the function pthread_rwlockattr_getpshared() obtains the current value of the
process-shared attribute.
A read-write lock attributes object is destroyed using the pthread_rwlockattr_destroy() function. The effect of subsequent use of
the read-write lock attributes object is undefined.
A thread creates a read-write lock using the pthread_rwlock_init() function. The attributes of the read-write lock can be
specified by the application developer; otherwise, the default implementation-defined read-write lock attributes are used if the
pointer to the read-write lock attributes object is NULL. In cases where the default attributes are appropriate, the
PTHREAD_RWLOCK_INITIALIZER macro can be used to initialize read-write locks.
A thread which wants to apply a read lock to the read-write lock can use either pthread_rwlock_rdlock() or pthread_rwlock_tryrdlock(). If pthread_rwlock_rdlock() is used, the thread acquires a read lock if a writer
does not hold the write lock and there are no writers blocked on the write lock. If a read lock is not acquired, the calling thread
blocks until it can acquire a lock. However, if pthread_rwlock_tryrdlock() is used, the function returns immediately with
the error [EBUSY] if any thread holds a write lock or there are blocked writers waiting for the write lock.
A thread which wants to apply a write lock to the read-write lock can use either of two functions: pthread_rwlock_wrlock() or pthread_rwlock_trywrlock(). If pthread_rwlock_wrlock() is used, the thread acquires the write lock if no
other reader or writer threads hold the read-write lock. If the write lock is not acquired, the thread blocks until it can acquire
the write lock. However, if pthread_rwlock_trywrlock() is used, the
function returns immediately with the error [EBUSY] if any thread is holding either a read or a write lock.
The pthread_rwlock_unlock() function is used to unlock
a read-write lock object held by the calling thread. Results are undefined if the read-write lock is not held by the calling
thread. If there are other read locks currently held on the read-write lock object, the read-write lock object remains in the read
locked state but without the current thread as one of its owners. If this function releases the last read lock for this read-write
lock object, the read-write lock object is put in the unlocked read state. If this function is called to release a write lock for
this read-write lock object, the read-write lock object is put in the unlocked state.
Thread Concurrency Level
On threads implementations that multiplex user threads onto a smaller set of kernel execution entities, the system
attempts to create a reasonable number of kernel execution entities for the application upon application startup.
On some implementations, these kernel entities are retained by user threads that block in the kernel. Other
implementations do not timeslice user threads so that multiple compute-bound user threads can share a kernel thread. On such
implementations, some applications may use up all the available kernel execution entities before their user-space threads are used
up. The process may be left with user threads capable of doing work for the application but with no way to schedule them.
Thread Stack Guard Size
DCE threads introduced the concept of a "thread stack guard size". Most thread implementations add a region of
protected memory to a thread's stack, commonly known as a "guard region", as a safety measure to prevent stack pointer overflow
in one thread from corrupting the contents of another thread's stack. The default size of the guard regions attribute is {PAGESIZE}
bytes and is implementation-defined.
Some application developers may wish to change the stack guard size. When an application creates a large number of
threads, the extra page allocated for each stack may strain system resources. In addition to the extra page of memory, the kernel's
memory manager has to keep track of the different protections on adjoining pages. When this is a problem, the application developer
may request a guard size of 0 bytes to conserve system resources by eliminating stack overflow protection.
Conversely an application that allocates large data structures such as arrays on the stack may wish to increase the
default guard size in order to detect stack overflow. If a thread allocates two pages for a data array, a single guard page
provides little protection against thread stack overflows since the thread can corrupt adjoining memory beyond the guard page.
The System Interfaces volume of POSIX.1-2024 defines a new attribute of a thread attributes object; that is, the
guardsize attribute which allows applications to specify the size of the guard region of a thread's stack.
Two functions are provided for manipulating a thread's stack guard size. The pthread_attr_setguardsize() function sets the thread guardsize
attribute, and the pthread_attr_getguardsize() function retrieves
the current value.
An implementation may round up the requested guard size to a multiple of the configurable system variable
{PAGESIZE}. In this case, pthread_attr_getguardsize() returns the
guard size specified by the previous pthread_attr_setguardsize()
function call and not the rounded up value.
If an application is managing its own thread stacks using the stackaddr attribute, the guardsize
attribute is ignored and no stack overflow protection is provided. In this case, it is the responsibility of the application to
manage stack overflow along with stack allocation.
Parallel I/O
Suppose two or more threads independently issue read requests on the same file. To read specific data from a file,
a thread must first call lseek() to seek to the proper offset in the file, and then
call read() to retrieve the required data. If more than one thread does this at the
same time, the first thread may complete its seek call, but before it gets a chance to issue its read call a second thread may
complete its seek call, resulting in the first thread accessing incorrect data when it issues its read call. One workaround is to
lock the file descriptor while seeking and reading or writing, but this reduces parallelism and adds overhead.
Instead, the System Interfaces volume of POSIX.1-2024 provides two functions to make seek/read and seek/write
operations atomic. The file descriptor's current offset is unchanged, thus allowing multiple read and write operations to proceed
in parallel. This improves the I/O performance of threaded applications. The pread()
function is used to do an atomic read of data from a file into a buffer. Conversely, the pwrite() function does an atomic write of data from a buffer to a file.
B.2.9.1 Thread-Safety
All functions required by POSIX.1-2024 need to be thread-safe. Implementations have to provide internal
synchronization when necessary in order to achieve this goal. In certain cases—for example, most floating-point
implementations—context switch code may have to manage the writable shared state.
While a read from a pipe of {PIPE_BUF}*2 bytes may not generate a single atomic and thread-safe stream of bytes, it
should generate "several" (individually atomic) thread-safe streams of bytes. Similarly, while reading from a terminal device may
not generate a single atomic and thread-safe stream of bytes, it should generate some finite number of (individually atomic) and
thread-safe streams of bytes. That is, concurrent calls to read for a pipe, FIFO, or terminal device are not allowed to result in
corrupting the stream of bytes or other internal data. However, read(), in these cases,
is not required to return a single contiguous and atomic stream of bytes.
It is not required that all functions provided by POSIX.1-2024 be either async-cancel-safe or
async-signal-safe.
As it turns out, some functions are inherently not thread-safe; that is, their interface specifications preclude
thread-safety. For example, some functions (such as asctime()) return a pointer to a
result stored in memory space allocated by the function on a per-process basis. Such a function is not thread-safe, because its
result can be overwritten by successive invocations. Other functions, while not inherently non-thread-safe, may be implemented in
ways that lead to them not being thread-safe. For example, some functions (such as rand()) store state information (such as a seed value, which survives multiple function
invocations) in memory space allocated by the function on a per-process basis. The implementation of such a function is not
thread-safe if the implementation fails to synchronize invocations of the function and thus fails to protect the state information.
The problem is that when the state information is not protected, concurrent invocations can interfere with one another (for
example, applications using rand() may see the same seed value).
Thread-Safety and Locking of Existing Functions
Originally, POSIX.1 was not designed to work in a multi-threaded environment, and some implementations of some
existing functions will not work properly when executed concurrently. To provide routines that will work correctly in an
environment with threads ("thread-safe"), two problems need to be solved:
Routines that maintain or return pointers to static areas internal to the routine (which may now be shared) need
to be modified. The routines ttyname() and localtime() are examples.
Routines that access data space shared by more than one thread need to be modified. The malloc() function and the stdio family routines are examples.
There are a variety of constraints on these changes. The first is compatibility with the existing versions of these
functions—non-thread-safe functions will continue to be in use for some time, as the original interfaces are used by existing code.
Another is that the new thread-safe versions of these functions represent as small a change as possible over the familiar
interfaces provided by the existing non-thread-safe versions. The new interfaces should be independent of any particular threads
implementation. In particular, they should be thread-safe without depending on explicit thread-specific memory. Finally, there
should be minimal performance penalty due to the changes made to the functions.
It is intended that the list of functions from POSIX.1 that cannot be made thread-safe and for which corrected
versions are provided be complete.
Thread-Safety and Locking Solutions
Many of the POSIX.1 functions were thread-safe and did not change at all. However, some functions (for example, the
math functions typically found in libm) are not thread-safe because of writable shared global state. For instance, in
IEEE Std 754-1985 floating-point implementations, the computation modes and flags are global and shared.
Some functions are not thread-safe because a particular implementation is not reentrant, typically because of a
non-essential use of static storage. These require only a new implementation.
Thread-safe libraries are useful in a wide range of parallel (and asynchronous) programming environments, not just
within pthreads. In order to be used outside the context of pthreads, however, such libraries still have to use some
synchronization method. These could either be independent of the pthread synchronization operations, or they could be a subset of
the pthread interfaces. Either method results in thread-safe library implementations that can be used without the rest of
pthreads.
Some functions, such as the stdio family interface and dynamic memory allocation functions such as malloc(), are inter-dependent routines that share resources (for example, buffers) across
related calls. These require synchronization to work correctly, but they do not require any change to their external (user-visible)
interfaces.
In some cases, such as getc() and putc(), adding synchronization is likely to create an unacceptable performance impact. In this
case, slower thread-safe synchronized functions are to be provided, but the original, faster (but unsafe) functions (which may be
implemented as macros) are retained under new names. Some additional special-purpose synchronization facilities are necessary for
these macros to be usable in multi-threaded programs. This also requires changes in .
The other common reason that functions are unsafe is that they return a pointer to static storage, making the
functions non-thread-safe. This has to be changed, and there are three natural choices:
Return a pointer to thread-specific storage
This could incur a severe performance penalty on those architectures with a costly implementation of the
thread-specific data interface.
A variation on this technique is to use malloc() to allocate storage
for the function output and return a pointer to this storage. This technique may also have an undesirable performance impact,
however, and a simplistic implementation requires that the user program explicitly free the storage object when it is no longer
needed. This technique is used by some existing POSIX.1 functions. With careful implementation for infrequently used functions,
there may be little or no performance or storage penalty, and the maintenance of already-standardized interfaces is a significant
benefit.
Return the actual value computed by the function
This technique can only be used with functions that return pointers to structures—routines that return character
strings would have to wrap their output in an enclosing structure in order to return the output on the stack. There is also a
negative performance impact inherent in this solution in that the output value has to be copied twice before it can be used by the
calling function: once from the called routine's local buffers to the top of the stack, then from the top of the stack to the
assignment target. Finally, many older compilers cannot support this technique due to a historical tendency to use internal static
buffers to deliver the results of structure-valued functions.
Have the caller pass the address of a buffer to contain the computed value
The only disadvantage of this approach is that extra arguments have to be provided by the calling program. It
represents the most efficient solution to the problem, however, and, unlike the malloc() technique, it is semantically clear.
There are some routines (often groups of related routines) whose interfaces are inherently non-thread-safe because
they communicate across multiple function invocations by means of static memory locations. The solution is to redesign the calls so
that they are thread-safe, typically by passing the needed data as extra parameters. Unfortunately, this may require major changes
to the interface as well.
A floating-point implementation using IEEE Std 754-1985 is a case in point. A less problematic example is
the rand48 family of pseudo-random number generators. The functions getgrgid(), getgrnam(), getpwnam(), and getpwuid() are another such
case.
The problems with errno are discussed in Alternative Solutions for Per-Thread
errno.
Some functions can be thread-safe or not, depending on their arguments. These include the tmpnam() and ctermid() functions. These
functions have pointers to character strings as arguments. If the pointers are not NULL, the functions store their results in the
character string; however, if the pointers are NULL, the functions store their results in an area that may be static and thus
subject to overwriting by successive calls. These should only be called by multi-thread applications when their arguments are
non-NULL.
Asynchronous Safety and Thread-Safety
A floating-point implementation has many modes that effect rounding and other aspects of computation. Functions in
some math library implementations may change the computation modes for the duration of a function call. If such a function call is
interrupted by a signal or cancellation, the floating-point state is not required to be protected.
There is a significant cost to make floating-point operations async-cancel-safe or async-signal-safe; accordingly,
neither form of async safety is required.
Functions Returning Pointers to Static Storage
For those functions that are not thread-safe because they return values in fixed size statically allocated
structures, alternate "_r" forms are provided that pass a pointer to an explicit result structure. Those that return pointers
into library-allocated buffers have forms provided with explicit buffer and length parameters.
For functions that return pointers to library-allocated buffers, it makes sense to provide "_r" versions that
allow the application control over allocation of the storage in which results are returned. This allows the state used by these
functions to be managed on an application-specific basis, supporting per-thread, per-process, or other application-specific sharing
relationships.
Early proposals had provided "_r" versions for functions that returned pointers to variable-size buffers without
providing a means for determining the required buffer size. This would have made using such functions exceedingly clumsy,
potentially requiring iteratively calling them with increasingly larger guesses for the amount of storage required. Hence, sysconf() variables have been provided for such functions that return the maximum required
buffer size.
Thus, the rule that has been followed by POSIX.1-2024 when adapting single-threaded non-thread-safe functions is as
follows: all functions returning pointers to library-allocated storage should have "_r" versions provided, allowing the
application control over the storage allocation. Those with variable-sized return values accept both a buffer address and a length
parameter. The sysconf() variables are provided to supply the appropriate buffer
sizes when required. Implementors are encouraged to apply the same rule when adapting their own existing functions to a pthreads
environment.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0020 [631], XSH/TC2-2008/0021 [826], and XSH/TC2-2008/0022
[631] are applied.
Austin Group Defect 188 is applied, removing getenv() from the list
of functions that need not be thread-safe.
Austin Group Defect 696 is applied, requiring readdir() to be
thread-safe except when concurrent calls are made for the same directory stream.
Austin Group Defect 922 is applied, adding the secure_getenv()
function.
Austin Group Defect 1064 is applied, removing basename() and
dirname() from the list of functions that need not be thread-safe.
Austin Group Defect 1302 is applied, aligning this section with the ISO/IEC 9899:2018 standard.
B.2.9.2 Thread IDs
Separate applications should communicate through well-defined interfaces and should not depend on each other's
implementation. For example, if a programmer decides to rewrite the sort utility using
multiple threads, it should be easy to do this so that the interface to the sort
utility does not change. Consider that if the user causes SIGINT to be generated while the sort utility is running, keeping the same interface means that the entire sort utility is killed, not just one of its threads. As another example, consider a realtime
application that manages a reactor. Such an application may wish to allow other applications to control the priority at which it
watches the control rods. One technique to accomplish this is to write the ID of the thread watching the control rods into a file
and allow other programs to change the priority of that thread as they see fit. A simpler technique is to have the reactor process
accept IPCs (Interprocess Communication messages) from other processes, telling it at a semantic level what priority the program
should assign to watching the control rods. This allows the programmer greater flexibility in the implementation. For example, the
programmer can change the implementation from having one thread per rod to having one thread watching all of the rods without
changing the interface. Having threads live inside the process means that the implementation of a process is invisible to outside
processes (excepting debuggers and system management tools).
Threads do not provide a protection boundary. Every thread model allows threads to share memory with other threads
and encourages this sharing to be widespread. This means that one thread can wipe out memory that is needed for the correct
functioning of other threads that are sharing its memory. Consequently, providing each thread with its own user and/or group IDs
would not provide a protection boundary between threads sharing memory.
Some applications make the assumption that the implementation can always detect invalid uses of thread IDs of type
pthread_t. This is an invalid assumption. Specifically, if pthread_t is defined as a pointer type, no access check
needs to be performed before using the ID.
As with other interfaces that take pointer parameters, the outcome of passing an invalid parameter can result in an
invalid memory reference or an attempt to access an undefined portion of a memory object, cause signals to be sent (SIGSEGV or
SIGBUS) and possible termination of the process. This is a similar case to passing an invalid buffer pointer to read(). Some implementations might implement read()
as a system call and set an [EFAULT] error condition. Other implementations might contain parts of read() at user level and the first attempt to access data at an invalid reference will cause a
signal to be sent instead.
If an implementation detects use of a thread ID after the end of its lifetime, it is recommended that the function
should fail and report an [ESRCH] error. This does not imply that implementations are required to return in this case. It is
legitimate behavior to send an "invalid memory reference" signal (SIGSEGV or SIGBUS). It is the application's responsibility to
use only valid thread IDs and to keep track of the lifetime of the underlying threads.
Austin Group Defect 792 is applied, clarifying thread lifetime.
Austin Group Defect 1302 is applied, aligning this section with the ISO/IEC 9899:2018 standard.
B.2.9.3 Thread Mutexes
Austin Group Defect 1216 is applied, adding pthread_cond_clockwait() and pthread_mutex_clocklock().
Austin Group Defect 1302 is applied, aligning this section with the ISO/IEC 9899:2018 standard.
B.2.9.4 Thread Scheduling
Scheduling Implementation Models
The following scheduling implementation models are presented in terms of threads and "kernel entities". This is
to simplify exposition of the models, and it does not imply that an implementation actually has an identifiable "kernel
entity".
A kernel entity is not defined beyond the fact that it has scheduling attributes that are used to resolve
contention with other kernel entities for execution resources. A kernel entity may be thought of as an envelope that holds a thread
or a separate kernel thread. It is not a conventional process, although it shares with the process the attribute that it has a
single thread of control; it does not necessarily imply an address space, open files, and so on. It is better thought of as a
primitive facility upon which conventional processes and threads may be constructed.
System Thread Scheduling Model
This model consists of one thread per kernel entity. The kernel entity is solely responsible for scheduling thread
execution on one or more processors. This model schedules all threads against all other threads in the system using the scheduling
attributes of the thread.
Process Scheduling Model
A generalized process scheduling model consists of two levels of scheduling. A threads library creates a pool of
kernel entities, as required, and schedules threads to run on them using the scheduling attributes of the threads. Typically, the
size of the pool is a function of the simultaneously runnable threads, not the total number of threads. The kernel then schedules
the kernel entities onto processors according to their scheduling attributes, which are managed by the threads library. This set
model potentially allows a wide range of mappings between threads and kernel entities.
System and Process Scheduling Model Performance
There are a number of important implications on the performance of applications using these scheduling models. The
process scheduling model potentially provides lower overhead for making scheduling decisions, since there is no need to access
kernel-level information or functions and the set of schedulable entities is smaller (only the threads within the process).
On the other hand, since the kernel is also making scheduling decisions regarding the system resources under its
control (for example, CPU(s), I/O devices, memory), decisions that do not take thread scheduling parameters into account can result
in unspecified delays for realtime application threads, causing them to miss maximum response time limits.
Rate Monotonic Scheduling
Rate monotonic scheduling was considered, but rejected for standardization in the context of pthreads. A sporadic
server policy is included.
Scheduling Options
In POSIX.1-2024, the basic thread scheduling functions are defined under the threads functionality, so that they
are required of all threads implementations. However, there are no specific scheduling policies required by this functionality to
allow for conforming thread implementations that are not targeted to realtime applications.
Specific standard scheduling policies are defined to be under the Thread Execution Scheduling option, and they are
specifically designed to support realtime applications by providing predictable resource-sharing sequences. The name of this option
was chosen to emphasize that this functionality is defined as appropriate for realtime applications that require simple
priority-based scheduling.
It is recognized that these policies are not necessarily satisfactory for some multi-processor implementations, and
work is ongoing to address a wider range of scheduling behaviors. The interfaces have been chosen to create abundant opportunity
for future scheduling policies to be implemented and standardized based on this interface. In order to standardize a new scheduling
policy, all that is required (from the standpoint of thread scheduling attributes) is to define a new policy name, new members of
the thread attributes object, and functions to set these members when the scheduling policy is equal to the new value.
Scheduling Contention Scope
In order to accommodate the requirement for realtime response, each thread has a scheduling contention scope
attribute. Threads with a system scheduling contention scope have to be scheduled with respect to all other threads in the system.
These threads are usually bound to a single kernel entity that reflects their scheduling attributes and are directly scheduled by
the kernel.
Threads with a process scheduling contention scope need be scheduled only with respect to the other threads in the
process. These threads may be scheduled within the process onto a pool of kernel entities. The implementation is also free to bind
these threads directly to kernel entities and let them be scheduled by the kernel. Process scheduling contention scope allows the
implementation the most flexibility and is the default if both contention scopes are supported and none is specified.
Thus, the choice by implementors to provide one or the other (or both) of these scheduling models is driven by the
need of their supported application domains for worst-case (that is, realtime) response, or average-case (non-realtime)
response.
Scheduling Allocation Domain
The SCHED_FIFO and SCHED_RR scheduling policies take on different characteristics on a multi-processor. Other
scheduling policies are also subject to changed behavior when executed on a multi-processor. The concept of scheduling allocation
domain determines the set of processors on which the threads of an application may run. By considering the application's processor
scheduling allocation domain for its threads, scheduling policies can be defined in terms of their behavior for varying processor
scheduling allocation domain values. It is conceivable that not all scheduling allocation domain sizes make sense for all
scheduling policies on all implementations. The concept of scheduling allocation domain, however, is a useful tool for the
description of multi-processor scheduling policies.
The "process control" approach to scheduling obtains significant performance advantages from dynamic scheduling
allocation domain sizes when it is applicable.
Non-Uniform Memory Access (NUMA) multi-processors may use a system scheduling structure that involves reassignment
of threads among scheduling allocation domains. In NUMA machines, a natural model of scheduling is to match scheduling allocation
domains to clusters of processors. Load balancing in such an environment requires changing the scheduling allocation domain to
which a thread is assigned.
Scheduling Documentation
Implementation-provided scheduling policies need to be completely documented in order to be useful. This
documentation includes a description of the attributes required for the policy, the scheduling interaction of threads running under
this policy and all other supported policies, and the effects of all possible values for processor scheduling allocation domain.
Note that for the implementor wishing to be minimally-compliant, it is (minimally) acceptable to define the behavior as
undefined.
Scheduling Contention Scope Attribute
The scheduling contention scope defines how threads compete for resources. Within POSIX.1-2024, scheduling
contention scope is used to describe only how threads are scheduled in relation to one another in the system. That is, either they
are scheduled against all other threads in the system ("system scope") or only against those threads in the process ("process
scope"). In fact, scheduling contention scope may apply to additional resources, including virtual timers and profiling, which are
not currently considered by POSIX.1-2024.
Mixed Scopes
If only one scheduling contention scope is supported, the scheduling decision is straightforward. To perform the
processor scheduling decision in a mixed scope environment, it is necessary to map the scheduling attributes of the thread with
process-wide contention scope to the same attribute space as the thread with system-wide contention scope.
Since a conforming implementation has to support one and may support both scopes, it is useful to discuss the
effects of such choices with respect to example applications. If an implementation supports both scopes, mixing scopes provides a
means of better managing system-level (that is, kernel-level) and library-level resources. In general, threads with system scope
will require the resources of a separate kernel entity in order to guarantee the scheduling semantics. On the other hand, threads
with process scope can share the resources of a kernel entity while maintaining the scheduling semantics.
The application is free to create threads with dedicated kernel resources, and other threads that multiplex kernel
resources. Consider the example of a window server. The server allocates two threads per widget: one thread manages the widget user
interface (including drawing), while the other thread takes any required application action. This allows the widget to be
"active" while the application is computing. A screen image may be built from thousands of widgets. If each of these threads had
been created with system scope, then most of the kernel-level resources might be wasted, since only a few widgets are active at any
one time. In addition, mixed scope is particularly useful in a window server where one thread with high priority and system scope
handles the mouse so that it tracks well. As another example, consider a database server. For each of the hundreds or thousands of
clients supported by a large server, an equivalent number of threads will have to be created. If each of these threads were system
scope, the consequences would be the same as for the window server example above. However, the server could be constructed so that
actual retrieval of data is done by several dedicated threads. Dedicated threads that do work for all clients frequently justify
the added expense of system scope. If it were not permissible to mix system and process threads in the same process, this type of
solution would not be possible.
Dynamic Thread Scheduling Parameters Access
In many time-constrained applications, there is no need to change the scheduling attributes dynamically during
thread or process execution, since the general use of these attributes is to reflect directly the time constraints of the
application. Since these time constraints are generally imposed to meet higher-level system requirements, such as accuracy or
availability, they frequently should remain unchanged during application execution.
However, there are important situations in which the scheduling attributes should be changed. Generally, this will
occur when external environmental conditions exist in which the time constraints change. Consider, for example, a space vehicle
major mode change, such as the change from ascent to descent mode, or the change from the space environment to the atmospheric
environment. In such cases, the frequency with which many of the sensors or actuators need to be read or written will change, which
will necessitate a priority change. In other cases, even the existence of a time constraint might be temporary, necessitating not
just a priority change, but also a policy change for ongoing threads or processes. For this reason, it is critical that the
interface should provide functions to change the scheduling parameters dynamically, but, as with many of the other realtime
functions, it is important that applications use them properly to avoid the possibility of unnecessarily degrading performance.
In providing functions for dynamically changing the scheduling behavior of threads, there were two options: provide
functions to get and set the individual scheduling parameters of threads, or provide a single interface to get and set all the
scheduling parameters for a given thread simultaneously. Both approaches have merit. Access functions for individual parameters
allow simpler control of thread scheduling for simple thread scheduling parameters. However, a single function for setting all the
parameters for a given scheduling policy is required when first setting that scheduling policy. Since the single all-encompassing
functions are required, it was decided to leave the interface as minimal as possible. Note that simpler functions (such as
pthread_setprio() for threads running under the priority-based schedulers) can be easily defined in terms of the
all-encompassing functions.
If the pthread_setschedparam() function executes
successfully, it will have set all of the scheduling parameter values indicated in param; otherwise, none of the scheduling
parameters will have been modified. This is necessary to ensure that the scheduling of this and all other threads continues to be
consistent in the presence of an erroneous scheduling parameter.
The [EPERM] error value is included in the list of possible pthread_setschedparam() error returns as a reflection of the fact that the
ability to change scheduling parameters increases risks to the implementation and application performance if the scheduling
parameters are changed improperly. For this reason, and based on some existing practice, it was felt that some implementations
would probably choose to define specific permissions for changing either a thread's own or another thread's scheduling parameters.
POSIX.1-2024 does not include portable methods for setting or retrieving permissions, so any such use of permissions is completely
unspecified.
Mutex Initialization Scheduling Attributes
In a priority-driven environment, a direct use of traditional primitives like mutexes and condition variables can
lead to unbounded priority inversion, where a higher priority thread can be blocked by a lower priority thread, or set of threads,
for an unbounded duration of time. As a result, it becomes impossible to guarantee thread deadlines. Priority inversion can be
bounded and minimized by the use of priority inheritance protocols. This allows thread deadlines to be guaranteed even in the
presence of synchronization requirements.
Two useful but simple members of the family of priority inheritance protocols are the basic priority inheritance
protocol and the priority ceiling protocol emulation. Under the Basic Priority Inheritance protocol (governed by the Non-Robust
Mutex Priority Inheritance option), a thread that is blocking higher priority threads executes at the priority of the highest
priority thread that it blocks. This simple mechanism allows priority inversion to be bounded by the duration of critical sections
and makes timing analysis possible.
Under the Priority Ceiling Protocol Emulation protocol (governed by the Thread Priority Protection option), each
mutex has a priority ceiling, usually defined as the priority of the highest priority thread that can lock the mutex. When a thread
is executing inside critical sections, its priority is unconditionally increased to the highest of the priority ceilings of all the
mutexes owned by the thread. This protocol has two very desirable properties in uni-processor systems. First, a thread can be
blocked by a lower priority thread for at most the duration of one single critical section. Furthermore, when the protocol is
correctly used in a single processor, and if threads do not become blocked while owning mutexes, mutual deadlocks are
prevented.
The priority ceiling emulation can be extended to multiple processor environments, in which case the values of the
priority ceilings will be assigned depending on the kind of mutex that is being used: local to only one processor, or global,
shared by several processors. Local priority ceilings will be assigned the usual way, equal to the priority of the highest priority
thread that may lock that mutex. Global priority ceilings will usually be assigned a priority level higher than all the priorities
assigned to any of the threads that reside in the involved processors to avoid the effect called remote blocking.
Change the Priority Ceiling of a Mutex
In order for the priority protect protocol to exhibit its desired properties of bounding priority inversion and
avoidance of deadlock, it is critical that the ceiling priority of a mutex be the same as the priority of the highest thread that
can ever hold it, or higher. Thus, if the priorities of the threads using such mutexes never change dynamically, there is no need
ever to change the priority ceiling of a mutex.
However, if a major system mode change results in an altered response time requirement for one or more application
threads, their priority has to change to reflect it. It will occasionally be the case that the priority ceilings of mutexes held
also need to change. While changing priority ceilings should generally be avoided, it is important that POSIX.1-2024 provide these
interfaces for those cases in which it is necessary.
B.2.9.5 Thread Cancellation
Many existing threads packages have facilities for canceling an operation or canceling a thread. These facilities
are used for implementing user requests (such as the CANCEL button in a window-based application), for implementing OR parallelism
(for example, telling the other threads to stop working once one thread has found a forced mate in a parallel chess program), or
for implementing the ABORT mechanism in Ada.
POSIX programs traditionally have used the signal mechanism combined with either longjmp() or polling to cancel operations. Many POSIX programmers have trouble using these
facilities to solve their problems efficiently in a single-threaded process. With the introduction of threads, these solutions
become even more difficult to use.
The main issues with implementing a cancellation facility are specifying the operation to be canceled, cleanly
releasing any resources allocated to that operation, controlling when the target notices that it has been canceled, and defining
the interaction between asynchronous signals and cancellation.
Specifying the Operation to Cancel
Consider a thread that calls through five distinct levels of program abstraction and then, inside the lowest-level
abstraction, calls a function that suspends the thread. (An abstraction boundary is a layer at which the client of the abstraction
sees only the service being provided and can remain ignorant of the implementation. Abstractions are often layered, each level of
abstraction being a client of the lower-level abstraction and implementing a higher-level abstraction.) Depending on the semantics
of each abstraction, one could imagine wanting to cancel only the call that causes suspension, only the bottom two levels, or the
operation being done by the entire thread. Canceling operations at a finer grain than the entire thread is difficult because
threads are active and they may be run in parallel on a multi-processor. By the time one thread can make a request to cancel an
operation, the thread performing the operation may have completed that operation and gone on to start another operation whose
cancellation is not desired. Thread IDs are not reused until the thread has exited, and either it was created with the Attr
detachstate attribute set to PTHREAD_CREATE_DETACHED or the pthread_join()
or pthread_detach() function has been called for that thread. Consequently, a
thread cancellation will never be misdirected when the thread terminates. For these reasons, the canceling of operations is done at
the granularity of the thread. Threads are designed to be inexpensive enough so that a separate thread may be created to perform
each separately cancelable operation; for example, each possibly long running user request.
For cancellation to be used in existing code, cancellation scopes and handlers will have to be established for code
that needs to release resources upon cancellation, so that it follows the programming discipline described in the text.
A Special Signal Versus a Special Interface
Two different mechanisms were considered for providing the cancellation interfaces. The first was to provide an
interface to direct signals at a thread and then to define a special signal that had the required semantics. The other alternative
was to use a special interface that delivered the correct semantics to the target thread.
The solution using signals produced a number of problems. It required the implementation to provide cancellation in
terms of signals whereas a perfectly valid (and possibly more efficient) implementation could have both layered on a low-level set
of primitives. There were so many exceptions to the special signal (it cannot be used with kill(), no POSIX.1 interfaces can be used with it) that it was clearly not a valid signal. Its
semantics on delivery were also completely different from any existing POSIX.1 signal. As such, a special interface that did not
mandate the implementation and did not confuse the semantics of signals and cancellation was felt to be the better solution.
Races Between Cancellation and Resuming Execution
Due to the nature of cancellation, there is generally no synchronization between the thread requesting the
cancellation of a blocked thread and events that may cause that thread to resume execution. For this reason, and because excess
serialization hurts performance, when both an event that a thread is waiting for has occurred and a cancellation request has been
made and cancellation is enabled, POSIX.1-2024 explicitly allows the implementation to choose between returning from the blocking
call or acting on the cancellation request.
Interaction of Cancellation with Asynchronous Signals
A typical use of cancellation is to acquire a lock on some resource and to establish a cancellation cleanup handler
for releasing the resource when and if the thread is canceled.
A correct and complete implementation of cancellation in the presence of asynchronous signals requires considerable
care. An implementation has to push a cancellation cleanup handler on the cancellation cleanup stack while maintaining the
integrity of the stack data structure. If an asynchronously-generated signal is posted to the thread during a stack operation, the
signal handler cannot manipulate the cancellation cleanup stack. As a consequence, asynchronous signal handlers may not cancel
threads or otherwise manipulate the cancellation state of a thread. Threads may, of course, be canceled by another thread that used
a sigwait() function to wait synchronously for an asynchronous signal.
In order for cancellation to function correctly, it is required that asynchronous signal handlers not change the
cancellation state. This requires that some elements of existing practice, such as using longjmp() to exit from an asynchronous signal handler implicitly, be prohibited in cases
where the integrity of the cancellation state of the interrupt thread cannot be ensured.
Thread Cancellation Overview
Cancelability States
The three possible cancelability states (disabled, deferred, and asynchronous) are encoded into two separate bits
((disable, enable) and (deferred, asynchronous)) to allow them to be changed and restored independently. For instance, short code
sequences that will not block sometimes disable cancelability on entry and restore the previous state upon exit. Likewise, long or
unbounded code sequences containing no convenient explicit cancellation points will sometimes set the cancelability type to
asynchronous on entry and restore the previous value upon exit.
Cancellation Points
Cancellation points are points inside of certain functions where a thread has to act on any pending cancellation
request when cancelability is enabled. For functions in the "shall occur" list, a cancellation check must be performed on every
call regardless of whether, absent the cancellation, the call would have blocked. For functions in the "may occur" list, a
cancellation check may be performed on some calls but not others; i.e., whether or not a cancellation point occurs when one of
these functions is being executed can depend on current conditions.
The idea was considered of allowing implementations to define whether blocking calls such as read() should be cancellation points. It was decided that it would adversely affect the design
of conforming applications if blocking calls were not cancellation points because threads could be left blocked in an uncancelable
state.
There are several important blocking routines that are specifically not made cancellation points:
pthread_mutex_lock()
If pthread_mutex_lock() were a cancellation point, every
routine that called it would also become a cancellation point (that is, any routine that touched shared state would automatically
become a cancellation point). For example, malloc(), free(), and rand() would become cancellation points
under this scheme. Having too many cancellation points makes programming very difficult, leading to either much disabling and
restoring of cancelability or much difficulty in trying to arrange for reliable cleanup at every possible place.
Since pthread_mutex_lock() is not a cancellation point,
threads could result in being blocked uninterruptibly for long periods of time if mutexes were used as a general synchronization
mechanism. As this is normally not acceptable, mutexes should only be used to protect resources that are held for small fixed
lengths of time where not being able to be canceled will not be a problem. Resources that need to be held exclusively for long
periods of time should be protected with condition variables.
pthread_barrier_wait()
Canceling a barrier wait will render a barrier unusable. Similar to a barrier timeout (which the standard
developers rejected), there is no way to guarantee the consistency of a barrier's internal data structures if a barrier wait is
canceled.
pthread_spin_lock()
As with mutexes, spin locks should only be used to protect resources that are held for small fixed lengths of time
where not being cancelable will not be a problem.
Every library routine should specify whether or not it includes any cancellation points. Typically, only those
routines that may block or compute indefinitely need to include cancellation points.
Correctly coded routines only reach cancellation points after having set up a cancellation cleanup handler to
restore invariants if the thread is canceled at that point. Being cancelable only at specified cancellation points allows
programmers to keep track of actions needed in a cancellation cleanup handler more easily. A thread should only be made
asynchronously cancelable when it is not in the process of acquiring or releasing resources or otherwise in a state from which it
would be difficult or impossible to recover.
Thread Cancellation Cleanup Handlers
The cancellation cleanup handlers provide a portable mechanism, easy to implement, for releasing resources and
restoring invariants. They are easier to use than signal handlers because they provide a stack of cancellation cleanup handlers
rather than a single handler, and because they have an argument that can be used to pass context information to the handler.
The alternative to providing these simple cancellation cleanup handlers (whose only use is for cleaning up when a
thread is canceled) is to define a general exception package that could be used for handling and cleaning up after hardware traps
and software-detected errors. This was too far removed from the charter of providing threads to handle asynchrony. However, it is
an explicit goal of POSIX.1-2024 to be compatible with existing exception facilities and languages having exceptions.
The interaction of this facility and other procedure-based or language-level exception facilities is unspecified in
this version of POSIX.1-2024. However, it is intended that it be possible for an implementation to define the relationship between
these cancellation cleanup handlers and Ada, C++, or other language-level exception handling facilities.
It was suggested that the cancellation cleanup handlers should also be called when the process exits or calls the
exec function. This was rejected partly due to the performance problem caused by having to call the cancellation cleanup
handlers of every thread before the operation could continue. The other reason was that the only state expected to be cleaned up by
the cancellation cleanup handlers would be the intraprocess state. Any handlers that are to clean up the interprocess state would
be registered with atexit(). There is the orthogonal problem that the exec
functions do not honor the atexit() handlers, but resolving this is beyond the scope
of POSIX.1-2024.
Async-Cancel Safety
A function is said to be async-cancel-safe if it is written in such a way that entering the function with
asynchronous cancelability enabled will not cause any invariants to be violated, even if a cancellation request is delivered at any
arbitrary instruction. Functions that are async-cancel-safe are often written in such a way that they need to acquire no resources
for their operation and the visible variables that they may write are strictly limited.
Any routine that gets a resource as a side-effect cannot be made async-cancel-safe (for example, malloc()). If such a routine were called with asynchronous cancelability enabled, it might
acquire the resource successfully, but as it was returning to the client, it could act on a cancellation request. In such a case,
the application would have no way of knowing whether the resource was acquired or not.
Indeed, because many interesting routines cannot be made async-cancel-safe, most library routines in general are
not async-cancel-safe. Every library routine should specify whether or not it is async-cancel safe so that programmers know which
routines can be called from code that is asynchronously cancelable.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/8 is applied, adding the pselect() function to the list of functions with cancellation points.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/5 is applied, adding the fdatasync() function into the table of functions that shall have cancellation points.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/6 is applied, adding the numerous functions into
the table of functions that may have cancellation points.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/7 is applied, clarifying the requirements in Thread
Cancellation Cleanup Handlers.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0023 [627], XSH/TC2-2008/0024 [627,632], XSH/TC2-2008/0025
[627], XSH/TC2-2008/0026 [632], and XSH/TC2-2008/0027 [622] are applied.
Austin Group Defect 411 is applied, adding accept4() to the table of
functions that shall have cancellation points.
Austin Group Defect 508 is applied, adding ptsname() and ptsname_r() to the table of functions that may have cancellation points.
Austin Group Defect 614 is applied, adding posix_close() to the
table of functions that shall have cancellation points.
Austin Group Defect 697 is applied, adding posix_getdents()
to the table of functions that may have cancellation points.
Austin Group Defect 729 is applied, adding posix_devctl() to
the table of functions that may have cancellation points.
Austin Group Defect 841 is applied, allowing pthread_setcancelstate() to be used to disable cancellation in a signal
catching function in order to avoid undefined behavior when the signal is delivered during execution of a function that is not
async-cancel-safe.
Austin Group Defect 1076 is applied, moving sem_wait() and sem_timedwait() from the table of functions that are required to have cancellation
points to the table of functions that may have cancellation points.
Austin Group Defect 1122 is applied, adding bindtextdomain()
and the gettext family of functions to the table of functions that may have cancellation points.
Austin Group Defect 1143 is applied, clarifying the conditions under which it is unspecified whether the
cancellation request is acted upon or whether the cancellation request remains pending.
Austin Group Defect 1216 is applied, adding pthread_cond_clockwait() to the table of functions that are required to have
cancellation points, and adding pthread_rwlock_clockwrlock(),
pthread_rwlock_clockrdlock(), and sem_clockwait() to the table of functions that may have cancellation points.
Austin Group Defect 1263 is applied, adding ppoll() to the table of
functions that are required to have cancellation points.
Austin Group Defect 1302 is applied, aligning this section with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1410 is applied, removing the asctime_r() and ctime_r() functions.
B.2.9.6 Thread Read-Write Locks
Background
Read-write locks are often used to allow parallel access to data on multi-processors, to avoid context switches on
uni-processors when multiple threads access the same data, and to protect data structures that are frequently accessed (that is,
read) but rarely updated (that is, written). The in-core representation of a file system directory is a good example of such a data
structure. One would like to achieve as much concurrency as possible when searching directories, but limit concurrent access when
adding or deleting files.
Although read-write locks can be implemented with mutexes and condition variables, such implementations are
significantly less efficient than is possible. Therefore, this synchronization primitive is included in POSIX.1-2024 for the
purpose of allowing more efficient implementations in multi-processor systems.
Queuing of Waiting Threads
The pthread_rwlock_unlock() function description
states that one writer or one or more readers must acquire the lock if it is no longer held by any thread as a result of the call.
However, the function does not specify which thread(s) acquire the lock, unless the Thread Execution Scheduling option is
supported.
The standard developers considered the issue of scheduling with respect to the queuing of threads blocked on a
read-write lock. The question turned out to be whether POSIX.1-2024 should require priority scheduling of read-write locks for
threads whose execution scheduling policy is priority-based (for example, SCHED_FIFO or SCHED_RR). There are tradeoffs between
priority scheduling, the amount of concurrency achievable among readers, and the prevention of writer and/or reader starvation.
For example, suppose one or more readers hold a read-write lock and the following threads request the lock in the
listed order:
pthread_rwlock_wrlock() - Low priority thread writer_a
pthread_rwlock_rdlock() - High priority thread reader_a
pthread_rwlock_rdlock() - High priority thread reader_b
pthread_rwlock_rdlock() - High priority thread reader_c
When the lock becomes available, should writer_a block the high priority readers? Or, suppose a read-write
lock becomes available and the following are queued:
pthread_rwlock_rdlock() - Low priority thread reader_a
pthread_rwlock_rdlock() - Low priority thread reader_b
pthread_rwlock_rdlock() - Low priority thread reader_c
pthread_rwlock_wrlock() - Medium priority thread writer_a
pthread_rwlock_rdlock() - High priority thread reader_d
If priority scheduling is applied then reader_d would acquire the lock and writer_a would block the
remaining readers. But should the remaining readers also acquire the lock to increase concurrency? The solution adopted takes into
account that when the Thread Execution Scheduling option is supported, high priority threads may in fact starve low priority
threads (the application developer is responsible in this case for designing the system in such a way that this starvation is
avoided). Therefore, POSIX.1-2024 specifies that high priority readers take precedence over lower priority writers. However, to
prevent writer starvation from threads of the same or lower priority, writers take precedence over readers of the same or lower
priority.
Priority inheritance mechanisms are non-trivial in the context of read-write locks. When a high priority writer is
forced to wait for multiple readers, for example, it is not clear which subset of the readers should inherit the writer's priority.
Furthermore, the internal data structures that record the inheritance must be accessible to all readers, and this implies some sort
of serialization that could negate any gain in parallelism achieved through the use of multiple readers in the first place.
Finally, existing practice does not support the use of priority inheritance for read-write locks. Therefore, no specification of
priority inheritance or priority ceiling is attempted. If reliable priority-scheduled synchronization is absolutely required, it
can always be obtained through the use of mutexes.
Comparison to fcntl() Locks
The read-write locks and the fcntl() locks in POSIX.1-2024 share a
common goal: increasing concurrency among readers, thus increasing throughput and decreasing delay.
However, the read-write locks have two features not present in the fcntl() locks. First, under priority scheduling, read-write locks are granted in priority
order. Second, also under priority scheduling, writer starvation is prevented by giving writers preference over readers of equal or
lower priority.
Also, read-write locks can be used in systems lacking a file system, such as those conforming to the minimal
realtime system profile of IEEE Std 1003.13-1998.
History of Resolution Issues
Based upon some balloting objections, early drafts specified the behavior of threads waiting on a read-write lock
during the execution of a signal handler, as if the thread had not called the lock operation. However, this specified behavior
would require implementations to establish internal signal handlers even though this situation would be rare, or never happen for
many programs. This would introduce an unacceptable performance hit in comparison to the little additional functionality gained.
Therefore, the behavior of read-write locks and signals was reverted back to its previous mutex-like specification.
B.2.9.7 Thread Interactions with File Operations
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0028 [498] is applied.
Austin Group Defect 411 is applied, adding dup3().
Austin Group Defect 695 is applied, extending the requirements in this section to non-regular files.
B.2.9.8 Use of Application-Managed Thread Stacks
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/8 is applied, adding this new section. It was added
to make it clear that the current standard does not allow an application to determine when a stack can be reclaimed. This may be
addressed in a future version.
B.2.9.9 Synchronization Object Copies and Alternative
Mappings
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0029 [972] is applied.
Austin Group Defect 1302 is applied, aligning this section with the ISO/IEC 9899:2018 standard.
B.2.10 Sockets
The base document for the sockets interfaces in POSIX.1-2024 is the XNS, Issue 5.2 specification. This was
primarily chosen as it aligns with IPv6. Additional material has been added from IEEE Std 1003.1g-2000, notably socket
concepts, raw sockets, the pselect() function, the sockatmark() function, and the  header.
B.2.10.1 Address Families
There is no additional rationale provided for this section.
B.2.10.2 Addressing
There is no additional rationale provided for this section.
B.2.10.3 Protocols
There is no additional rationale provided for this section.
B.2.10.4 Routing
There is no additional rationale provided for this section.
B.2.10.5 Interfaces
There is no additional rationale provided for this section.
B.2.10.6 Socket Types
The type socklen_t was invented to cover the range of implementations seen in the field. The intent of
socklen_t is to be the type for all lengths that are naturally bounded in size; that is, that they are the length of a
buffer which cannot sensibly become of massive size: network addresses, host names, string representations of these, ancillary
data, control messages, and socket options are examples. Truly boundless sizes are represented by size_t as in read(), write(), and so on.
All socklen_t types were originally (in BSD UNIX) of type int. During the development of
POSIX.1-2024, it was decided to change all buffer lengths to size_t, which appears at face value to make sense. When dual
mode 32/64-bit systems came along, this choice unnecessarily complicated system interfaces because size_t (with long)
was a different size under ILP32 and LP64 models. Reverting to int would have happened except that some implementations had
already shipped 64-bit-only interfaces. The compromise was a type which could be defined to be any size by the implementation:
socklen_t.
B.2.10.7 Socket I/O Mode
There is no additional rationale provided for this section.
B.2.10.8 Socket Owner
There is no additional rationale provided for this section.
B.2.10.9 Socket Queue Limits
There is no additional rationale provided for this section.
B.2.10.10 Pending Error
There is no additional rationale provided for this section.
B.2.10.11 Socket Receive Queue
There is no additional rationale provided for this section.
B.2.10.12 Socket Out-of-Band Data State
There is no additional rationale provided for this section.
B.2.10.13 Connection Indication Queue
There is no additional rationale provided for this section.
B.2.10.14 Signals
There is no additional rationale provided for this section.
B.2.10.15 Asynchronous Errors
Austin Group Defect 1010 is applied, removing [EHOSTDOWN] from the list of asynchronous errors.
B.2.10.16 Use of Options
Austin Group Defect 840 is applied, adding SO_DOMAIN and SO_PROTOCOL.
Austin Group Defect 1337 is applied, clarifying socket option default values.
B.2.10.17 Use of Sockets for Local UNIX Connections
There is no additional rationale provided for this section.
B.2.10.18 Use of Sockets over Internet Protocols
A raw socket allows privileged users direct access to a protocol; for example, raw access to the IP and ICMP
protocols is possible through raw sockets. Raw sockets are intended for knowledgeable applications that wish to take advantage of
some protocol feature not directly accessible through the other sockets interfaces.
B.2.10.19 Use of Sockets over Internet Protocols Based on
IPv4
There is no additional rationale provided for this section.
B.2.10.20 Use of Sockets over Internet Protocols Based on
IPv6
The Open Group Base Resolution bwg2001-012 is applied, clarifying that IPv6 implementations are required to support
use of AF_INET6 sockets over IPv4.
Austin Group Defect 411 is applied, adding accept4().
B.2.11 Data Types
B.2.11.1 Defined Types
The requirement that additional types defined in this section end in "_t" was prompted by the problem of name
space pollution. It is difficult to define a type (where that type is not one defined by POSIX.1-2024) in one header file and use
it in another without adding symbols to the name space of the program. To allow implementors to provide their own types, all
conforming applications are required to avoid symbols ending in "_t", which permits the implementor to provide additional types.
Because a major use of types is in the definition of structure members, which can (and in many cases must) be added to the
structures defined in POSIX.1-2024, the need for additional types is compelling.
The types, such as ushort and ulong, which are in common usage, are not defined in POSIX.1-2024
(although ushort_t would be permitted as an extension). They can be added to  using a feature test macro (see B.2.2.1
POSIX.1 Symbols). A suggested symbol for these is _SYSIII. Similarly, the types like u_short would probably be best
controlled by _BSD.
Some of these symbols may appear in other headers; see B.2.2.2 The Name Space.
dev_t
This type may be made large enough to accommodate host-locality considerations of networked systems.
This type must be arithmetic. Earlier proposals allowed this to be non-arithmetic (such as a structure) and
provided a samefile() function for comparison.
gid_t
Some implementations had separated gid_t from uid_t before POSIX.1 was completed. It would be difficult for them
to coalesce them when it was unnecessary. Additionally, it is quite possible that user IDs might be different from group IDs
because the user ID might wish to span a heterogeneous network, where the group ID might not.
For current implementations, the cost of having a separate gid_t will be only lexical.
mode_t
This type was chosen so that implementations could choose the appropriate integer type, and for compatibility with the
ISO C standard. 4.3 BSD uses unsigned short and the SVID uses ushort, which is the same. Historically, only the
low-order sixteen bits are significant.
nlink_t
This type was introduced in place of short for st_nlink (see the  header) in response to an objection that short was too
small.
off_t
This type is used to represent a file offset or file size. On systems supporting large files, off_t is larger than 32
bits in at least one programming environment. Other programming environments may use different sizes for off_t, for
compatibility or other reasons.
pid_t
The inclusion of this symbol was controversial because it is tied to the issue of the representation of a process ID as a
number. From the point of view of a conforming application, process IDs should be "magic cookies"1 that are produced by calls such as fork(), used by calls such as waitpid() or
kill(), and not otherwise analyzed (except that the sign is used as a flag for certain
operations).
The concept of a {PID_MAX} value interacted with this in early proposals. Treating process IDs as an opaque type
both removes the requirement for {PID_MAX} and allows systems to be more flexible in providing process IDs that span a large range
of values, or a small one.
Since the values in uid_t, gid_t, and pid_t will be numbers generally, and potentially both
large in magnitude and sparse, applications that are based on arrays of objects of this type are unlikely to be fully portable in
any case. Solutions that treat them as magic cookies will be portable.
{CHILD_MAX} precludes the possibility of a "toy implementation", where there would only be one process.
ssize_t
This is intended to be a signed analog of size_t. The wording is such that an implementation may either choose to use a
longer type or simply to use the signed version of the type that underlies size_t. All functions that return ssize_t
(read() and write()) describe as
"implementation-defined" the result of an input exceeding {SSIZE_MAX}. It is recognized that some implementations might have
ints that are smaller than size_t. A conforming application would be constrained not to perform I/O in pieces larger
than {SSIZE_MAX}, but a conforming application using extensions would be able to use the full range if the implementation provided
an extended range, while still having a single type-compatible interface.
The symbols size_t and ssize_t are also required in  to minimize the changes needed for calls to read() and write(). Implementors are reminded that
it must be possible to include both  and  in the same program (in either order) without error.
uid_t
Before the addition of this type, the data types used to represent these values varied throughout early proposals. The  header defined these values as type short, the
file (now  and ) used an int, and getuid()
returned an int. In response to a strong objection to the inconsistent definitions, all the types were switched to
uid_t.
In practice, those historical implementations that use varying types of this sort can typedef uid_t to
short with no serious consequences.
The problem associated with this change concerns object compatibility after structure size changes. Since most
implementations will define uid_t as a short, the only substantive change will be a reduction in the size of the
passwd structure. Consequently, implementations with an overriding concern for object compatibility can pad the structure
back to its current size. For that reason, this problem was not considered critical enough to warrant the addition of a separate
type to POSIX.1.
The types uid_t and gid_t are magic cookies. There is no {UID_MAX} defined by POSIX.1, and no
structure imposed on uid_t and gid_t other than that they be positive arithmetic types. (In fact, they could be
unsigned char.) There is no maximum or minimum specified for the number of distinct user or group IDs.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0030 [733] is applied.
Austin Group Defect 697 is applied, adding reclen_t.
Austin Group Defect 1302 is applied, aligning this section with the ISO/IEC 9899:2018 standard.
B.2.11.2 The char Type
POSIX.1-2024 explicitly requires that a char type is exactly one byte (8 bits).
B.2.12 Status Information
POSIX.1-2024 does not require all matching WNOWAIT threads (threads in a matching call to waitid() with the WNOWAIT flag set) to obtain a child's status information because the status
information might be discarded (consumed or replaced) before one of the matching WNOWAIT threads is scheduled. If the status
information is not discarded, it will remain available, so all of the matching WNOWAIT threads will (eventually) obtain the status
information.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0031 [690] is applied.
B.3 System Interfaces
See the RATIONALE sections on the individual reference pages.
B.3.1 System Interfaces Removed in this Version
This section contains a list of options and interfaces removed in POSIX.1-2024, together with advice for
application developers on the alternative interfaces that should be used.
B.3.1.1 STREAMS Option
Applications are recommended to use UNIX domain sockets as an alternative for much of the functionality provided by
this option. For example, file descriptor passing can be performed using sendmsg()
and recvmsg() with SCM_RIGHTS on a UNIX domain socket instead of using
ioctl() with I_SENDFD and I_RECVFD on a STREAM.
B.3.1.2 Tracing Option
Applications are recommended to use implementation-provided extension interfaces instead of the functionality
provided by this option. (Such interfaces were in widespread use before the Tracing option was added to POSIX.1 and continued to be
used in preference to the Tracing option interfaces.)
B.3.1.3 _longjmp() and _setjmp()
Applications are recommended to use siglongjmp() and sigsetjmp() instead of these functions.
B.3.1.4 _tolower() and _toupper()
Applications are recommended to use tolower() and toupper() instead of these functions.
B.3.1.5 ftw()
Applications are recommended to use nftw() instead of this
function.
B.3.1.6 getitimer() and setitimer()
Applications are recommended to use timer_gettime() and
timer_settime() instead of these functions.
B.3.1.7 gets()
Applications are recommended to use fgets() instead of this
function.
B.3.1.8 gettimeofday()
Applications are recommended to use clock_gettime() instead of
this function.
B.3.1.9 isascii() and toascii()
Applications are recommended to use macros equivalent to the following instead of these functions:
#define isascii(c) (((c) & ~0177) == 0)
#define toascii(c) ((c) & 0177)
An alternative replacement for isascii(), depending on the intended outcome if the code is ported to
implementations with different character encodings, might be:
#define isascii(c) (isprint((c)) || iscntrl((c)))
(In the C or POSIX locale, this determines whether c is a character in the portable character set.)
B.3.1.10 pthread_getconcurrency() and
pthread_setconcurrency()
Applications are recommended to use thread scheduling (on implementations that support the Thread Execution
Scheduling option) instead of these functions; see XSH 2.9.4 Thread
Scheduling.
B.3.1.11 rand_r()
Applications are recommended to use nrand48() or random() instead of this function.
B.3.1.12 setpgrp()
Applications are recommended to use setpgid() or setsid() instead of this function.
B.3.1.13 sighold(), sigpause(), and sigrelse()
Applications are recommended to use pthread_sigmask() or
sigprocmask() instead of these functions.
B.3.1.14 sigignore(), siginterrupt(), and sigset()
Applications are recommended to use sigaction() instead of these
functions.
B.3.1.15 tempnam()
Applications are recommended to use mkdtemp(), mkstemp(), or tmpfile() instead of this
function.
B.3.1.16 ulimit()
Applications are recommended to use getrlimit() or setrlimit() instead of this function.
B.3.1.17 utime()
Applications are recommended to use futimens() if a file descriptor
for the file is open, otherwise utimensat(), instead of this function.
B.3.2 System Interfaces Removed in the Previous Version
The functions and symbols removed in Issue 7 (from the Issue 6 base document) were as follows:
Removed Functions and Symbols in Issue 7
bcmp()
bcopy()
bsd_signal()
bzero()
ecvt()
fcvt()
ftime()
gcvt()
getcontext()
gethostbyaddr()
gethostbyname()
getwd()
h_errno
index()
makecontext()
mktemp()
pthread_attr_getstackaddr()
pthread_attr_setstackaddr()
rindex()
scalb()
setcontext()
swapcontext()
ualarm()
usleep()
vfork()
wcswcs()
B.3.3 Examples for Spawn
The following long examples are provided in the Rationale (Informative) volume of POSIX.1-2024 as a supplement to
the reference page for posix_spawn().
Example Library Implementation of Spawn
The posix_spawn() or posix_spawnp() functions provide the following:
Simply start a process executing a process image. This is the simplest application for process creation, and it
may cover most executions of fork().
Support I/O redirection, including pipes.
Run the child under a user and group ID in the domain of the parent.
Run the child at any priority in the domain of the parent.
The posix_spawn() or posix_spawnp() functions do not cover every possible use of the fork() function, but they do span the common applications: typical use by a shell and a login
utility.
The price for an application is that before it calls posix_spawn() or posix_spawnp(), the
parent must adjust to a state that posix_spawn() or posix_spawnp() can map to the desired state for the child. Environment changes require
the parent to save some of its state and restore it afterwards. The example below demonstrates an initial approach to implementing
posix_spawn() using other POSIX operations, although an actual implementation
will need to be more robust at handling all possible filenames.
#include
#include
#include
#include
#include
#include
#include
#include
#include
#include
/* #include  */
/*******************************************/
/* Things that could be defined in spawn.h */
/*******************************************/
typedef struct
{
short posix_attr_flags;
#define POSIX_SPAWN_SETPGROUP       0x1
#define POSIX_SPAWN_SETSIGMASK      0x2
#define POSIX_SPAWN_SETSIGDEF       0x4
#define POSIX_SPAWN_SETSCHEDULER    0x8
#define POSIX_SPAWN_SETSCHEDPARAM   0x10
#define POSIX_SPAWN_RESETIDS        0x20
#define POSIX_SPAWN_SETSID          0x40
pid_t posix_attr_pgroup;
sigset_t posix_attr_sigmask;
sigset_t posix_attr_sigdefault;
int posix_attr_schedpolicy;
struct sched_param posix_attr_schedparam;
}   posix_spawnattr_t;
typedef char *posix_spawn_file_actions_t;
int posix_spawn_file_actions_init(
posix_spawn_file_actions_t *file_actions);
int posix_spawn_file_actions_destroy(
posix_spawn_file_actions_t *file_actions);
int posix_spawn_file_actions_addchdir(
posix_spawn_file_actions_t *restrict file_actions,
const char *restrict path);
int posix_spawn_file_actions_addclose(
posix_spawn_file_actions_t *file_actions, int fildes);
int posix_spawn_file_actions_adddup2(
posix_spawn_file_actions_t *file_actions, int fildes,
int newfildes);
int posix_spawn_file_actions_addfchdir(
posix_spawn_file_actions_t *file_actions, int fildes);
int posix_spawn_file_actions_addopen(
posix_spawn_file_actions_t *file_actions, int fildes,
const char *path, int oflag, mode_t mode);
int posix_spawnattr_init(posix_spawnattr_t *attr);
int posix_spawnattr_destroy(posix_spawnattr_t *attr);
int posix_spawnattr_getflags(const posix_spawnattr_t *attr,
short *lags);
int posix_spawnattr_setflags(posix_spawnattr_t *attr, short flags);
int posix_spawnattr_getpgroup(const posix_spawnattr_t *attr,
pid_t *pgroup);
int posix_spawnattr_setpgroup(posix_spawnattr_t *attr, pid_t pgroup);
int posix_spawnattr_getschedpolicy(const posix_spawnattr_t *attr,
int *schedpolicy);
int posix_spawnattr_setschedpolicy(posix_spawnattr_t *attr,
int schedpolicy);
int posix_spawnattr_getschedparam(const posix_spawnattr_t *attr,
struct sched_param *schedparam);
int posix_spawnattr_setschedparam(posix_spawnattr_t *attr,
const struct sched_param *schedparam);
int posix_spawnattr_getsigmask(const posix_spawnattr_t *attr,
sigset_t *sigmask);
int posix_spawnattr_setsigmask(posix_spawnattr_t *attr,
const sigset_t *sigmask);
int posix_spawnattr_getdefault(const posix_spawnattr_t *attr,
sigset_t *sigdefault);
int posix_spawnattr_setsigdefault(posix_spawnattr_t *attr,
const sigset_t *sigdefault);
int posix_spawn(pid_t *pid, const char *path,
const posix_spawn_file_actions_t *file_actions,
const posix_spawnattr_t *attrp, char *const argv[],
char *const envp[]);
int posix_spawnp(pid_t *pid, const char *file,
const posix_spawn_file_actions_t *file_actions,
const posix_spawnattr_t *attrp, char *const argv[],
char *const envp[]);
/*****************************************/
/* Example posix_spawn() library routine */
/*****************************************/
int posix_spawn(pid_t *pid,
const char *path,
const posix_spawn_file_actions_t *file_actions,
const posix_spawnattr_t *attrp,
char *const argv[],
char *const envp[])
{
/* Create process */
if ((*pid = fork()) == (pid_t) 0)
{
/* This is the child process */
/* Handle creating a new session */
if (attrp->posix_attr_flags & POSIX_SPAWN_SETSID)
{
/* Create a new session */
if (setsid() == -1)
{
/* Failed */
_exit(127);
}
}
/* Handle process group */
if (attrp->posix_attr_flags & POSIX_SPAWN_SETPGROUP)
{
/* Override inherited process group */
if (setpgid(0, attrp->posix_attr_pgroup) != 0)
{
/* Failed */
_exit(127);
}
}
/* Handle thread signal mask */
if (attrp->posix_attr_flags & POSIX_SPAWN_SETSIGMASK)
{
/* Set the signal mask (cannot fail) */
sigprocmask(SIG_SETMASK, &attrp->posix_attr_sigmask, NULL);
}
/* Handle resetting effective user and group IDs */
if (attrp->posix_attr_flags & POSIX_SPAWN_RESETIDS)
{
/* None of these can fail for this case. */
setuid(getuid());
setgid(getgid());
}
/* Handle defaulted signals */
if (attrp->posix_attr_flags & POSIX_SPAWN_SETSIGDEF)
{
struct sigaction deflt;
sigset_t all_signals;
int s;
/* Construct default signal action */
deflt.sa_handler = SIG_DFL;
deflt.sa_flags = 0;
/* Construct the set of all signals */
sigfillset(&all_signals);
/* Loop for all signals */
for (s = 0; sigismember(&all_signals, s); s++)
{
/* Signal to be defaulted? */
if (sigismember(&attrp->posix_attr_sigdefault, s))
{
/* Yes; default this signal */
if (sigaction(s, &deflt, NULL) == -1)
{
/* Failed */
_exit(127);
}
}
}
}
/* Handle the fds if they are to be mapped */
if (file_actions != NULL)
{
/* Loop for all actions in object file_actions */
/* (implementation dives beneath abstraction) */
char *p = *file_actions;
while (*p != '\0')
{
if (strncmp(p, "close(", 6) == 0)
{
int fd;
if (sscanf(p + 6, "%d)", &fd) != 1)
{
_exit(127);
}
if (close(fd) == -1 && errno != EBADF)
_exit(127);
}
else if (strncmp(p, "dup2(", 5) == 0)
{
int fd, newfd;
if (sscanf(p + 5, "%d,%d)", &fd, &newfd) != 2)
{
_exit(127);
}
if (fd == newfd)
{
int flags = fcntl(fd, F_GETFD);
if (flags == -1)
_exit(127);
flags &= ~FD_CLOEXEC;
if (fcntl(fd, F_SETFD, flags) == -1)
_exit(127);
}
else if (dup2(fd, newfd) == -1)
_exit(127);
}
else if (strncmp(p, "open(", 5) == 0)
{
int fd, oflag;
mode_t mode;
int tempfd;
char path[1000];    /* Should be dynamic */
char *q;
if (sscanf(p + 5, "%d,", &fd) != 1)
{
_exit(127);
}
p = strchr(p, ',') + 1;
q = strchr(p, '*');
if (q == NULL)
_exit(127);
strncpy(path, p, q - p);
path[q - p] = '\0';
if (sscanf(q + 1, "%o,%o)", &oflag, &mode) != 2)
{
_exit(127);
}
if (close(fd) == -1)
{
if (errno != EBADF)
_exit(127);
}
tempfd = open(path, oflag, mode);
if (tempfd == -1)
_exit(127);
if (tempfd != fd)
{
if (dup2(tempfd, fd) == -1)
{
_exit(127);
}
if (close(tempfd) == -1)
{
_exit(127);
}
}
}
else if (strncmp(p, "chdir(", 6) == 0)
{
char path[1000]; /* Should be dynamic */
char *q;
p += 6
q = strchr(p, '*');
if (q == NULL)
_exit(127);
strncpy(path, p, q - p);
path[q - p] = '\0';
if (chdir(path) == -1)
_exit(127);
}
else if (strncmp(p, "fchdir(", 7) == 0)
{
int fd;
if (sscanf(p + 7, "%d)", &fd) != 1)
_exit(127);
if (fchdir(fd) == -1)
_exit(127);
}
else
{
_exit(127);
}
p = strchr(p, ')') + 1;
}
}
/* Handle setting new scheduling policy and parameters */
if (attrp->posix_attr_flags & POSIX_SPAWN_SETSCHEDULER)
{
if (sched_setscheduler(0, attrp->posix_attr_schedpolicy,
&attrp->posix_attr_schedparam) == -1)
{
_exit(127);
}
}
/* Handle setting only new scheduling parameters */
if (attrp->posix_attr_flags & POSIX_SPAWN_SETSCHEDPARAM)
{
if (sched_setparam(0, &attrp->posix_attr_schedparam) == -1)
{
_exit(127);
}
}
/* Now execute the program at path */
/* Any fd that still has FD_CLOEXEC set will be closed */
execve(path, argv, envp);
_exit(127);              /* exec failed */
}
else
{
/* This is the parent (calling) process */
if (*pid == (pid_t) - 1)
return errno;
return 0;
}
}
/*******************************************************/
/* Here is a crude but effective implementation of the */
/* file action object operators which store actions as */
/* concatenated token-separated strings.               */
/*******************************************************/
/* Create object with no actions. */
int posix_spawn_file_actions_init(
posix_spawn_file_actions_t *file_actions)
{
*file_actions = malloc(sizeof(char));
if (*file_actions == NULL)
return ENOMEM;
strcpy(*file_actions, "");
return 0;
}
/* Free object storage and make invalid. */
int posix_spawn_file_actions_destroy(
posix_spawn_file_actions_t *file_actions)
{
free(*file_actions);
*file_actions = NULL;
return 0;
}
/* Add a new action string to object. */
static int add_to_file_actions(
posix_spawn_file_actions_t *file_actions, char *new_action)
{
*file_actions = realloc
(*file_actions, strlen(*file_actions) + strlen(new_action) + 1);
if (*file_actions == NULL)
return ENOMEM;
strcat(*file_actions, new_action);
return 0;
}
/* Add a chdir action to object. */
int posix_spawn_file_actions_addchdir(
posix_spawn_file_actions_t *restrict file_actions,
const char *restrict path)
{
char temp[100];
sprintf(temp, "chdir(%s*)", path);
return add_to_file_actions(file_actions, temp);
}
/* Add a close action to object. */
int posix_spawn_file_actions_addclose(
posix_spawn_file_actions_t *file_actions, int fildes)
{
char temp[100];
sprintf(temp, "close(%d)", fildes);
return add_to_file_actions(file_actions, temp);
}
/* Add a dup2 action to object. */
int posix_spawn_file_actions_adddup2(
posix_spawn_file_actions_t *file_actions, int fildes,
int newfildes)
{
char temp[100];
sprintf(temp, "dup2(%d,%d)", fildes, newfildes);
return add_to_file_actions(file_actions, temp);
}
/* Add a fchdir action to object. */
int posix_spawn_file_actions_addfchdir(
posix_spawn_file_actions_t *file_actions, int fildes)
{
char temp[100];
sprintf(temp, "fchdir(%d)", fildes);
return add_to_file_actions(file_actions, temp);
}
/* Add an open action to object. */
int posix_spawn_file_actions_addopen(
posix_spawn_file_actions_t *file_actions, int fildes,
const char *path, int oflag, mode_t mode)
{
char temp[100];
sprintf(temp, "open(%d,%s*%o,%o)", fildes, path, oflag, mode);
return add_to_file_actions(file_actions, temp);
}
/*******************************************************/
/* Here is a crude but effective implementation of the */
/* spawn attributes object functions which manipulate  */
/* the individual attributes.                          */
/*******************************************************/
/* Initialize object with default values. */
int posix_spawnattr_init(posix_spawnattr_t *attr)
{
attr->posix_attr_flags = 0;
attr->posix_attr_pgroup = 0;
/* Default value of signal mask is the parent's signal mask; */
/* other values are also allowed */
sigprocmask(0, NULL, &attr->posix_attr_sigmask);
sigemptyset(&attr->posix_attr_sigdefault);
/* Default values of scheduling attr inherited from the parent; */
/* other values are also allowed */
attr->posix_attr_schedpolicy = sched_getscheduler(0);
sched_getparam(0, &attr->posix_attr_schedparam);
return 0;
}
int posix_spawnattr_destroy(posix_spawnattr_t *attr)
{
/* No action needed */
return 0;
}
int posix_spawnattr_getflags(const posix_spawnattr_t *attr,
short *flags)
{
*flags = attr->posix_attr_flags;
return 0;
}
int posix_spawnattr_setflags(posix_spawnattr_t *attr, short flags)
{
attr->posix_attr_flags = flags;
return 0;
}
int posix_spawnattr_getpgroup(const posix_spawnattr_t *attr,
pid_t *pgroup)
{
*pgroup = attr->posix_attr_pgroup;
return 0;
}
int posix_spawnattr_setpgroup(posix_spawnattr_t *attr, pid_t pgroup)
{
attr->posix_attr_pgroup = pgroup;
return 0;
}
int posix_spawnattr_getschedpolicy(const posix_spawnattr_t *attr,
int *schedpolicy)
{
*schedpolicy = attr->posix_attr_schedpolicy;
return 0;
}
int posix_spawnattr_setschedpolicy(posix_spawnattr_t *attr,
int schedpolicy)
{
attr->posix_attr_schedpolicy = schedpolicy;
return 0;
}
int posix_spawnattr_getschedparam(const posix_spawnattr_t *attr,
struct sched_param *schedparam)
{
*schedparam = attr->posix_attr_schedparam;
return 0;
}
int posix_spawnattr_setschedparam(posix_spawnattr_t *attr,
const struct sched_param *schedparam)
{
attr->posix_attr_schedparam = *schedparam;
return 0;
}
int posix_spawnattr_getsigmask(const posix_spawnattr_t *attr,
sigset_t *sigmask)
{
*sigmask = attr->posix_attr_sigmask;
return 0;
}
int posix_spawnattr_setsigmask(posix_spawnattr_t *attr,
const sigset_t *sigmask)
{
attr->posix_attr_sigmask = *sigmask;
return 0;
}
int posix_spawnattr_getsigdefault(const posix_spawnattr_t *attr,
sigset_t *sigdefault)
{
*sigdefault = attr->posix_attr_sigdefault;
return 0;
}
int posix_spawnattr_setsigdefault(posix_spawnattr_t *attr,
const sigset_t *sigdefault)
{
attr->posix_attr_sigdefault = *sigdefault;
return 0;
}
I/O Redirection with Spawn
I/O redirection with posix_spawn() or posix_spawnp() is accomplished by crafting a file_actions argument to effect the
desired redirection. Such a redirection follows the general outline of the following example:
/* To redirect new standard output (fd 1) to a file, */
/* and redirect new standard input (fd 0) from my fd socket_pair[1], */
/* and close my fd socket_pair[0] in the new process. */
posix_spawn_file_actions_t file_actions;
posix_spawn_file_actions_init(&file_actions);
posix_spawn_file_actions_addopen(&file_actions, 1, "newout", ...);
posix_spawn_file_actions_dup2(&file_actions, socket_pair[1], 0);
posix_spawn_file_actions_close(&file_actions, socket_pair[0]);
posix_spawn_file_actions_close(&file_actions, socket_pair[1]);
posix_spawn(..., &file_actions, ...);
posix_spawn_file_actions_destroy(&file_actions);
Spawning a Process Under a New User ID
Spawning a process under a new user ID follows the outline shown in the following example:
Save = getuid();
setuid(newid);
posix_spawn(...);
setuid(Save);
Footnotes
1. An historical term meaning: "An opaque object, or token, of determinate size, whose
significance is known only to the entity which created it. An entity receiving such a token from the generating entity may only
make such use of the `cookie' as is defined and permitted by the supplying entity."
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/xrat/V4_xcu_chap01.html =====
Rationale for Shell and Utilities
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
C. Rationale for Shell and Utilities
C.1 Introduction
C.1.1 Change History
The change history is provided as an informative section, to track changes from earlier versions of this standard.
The following sections describe changes made to the Shell and Utilities volume of POSIX.1-2024 since Issue 7 of the base
document. The CHANGE HISTORY section for each utility describes technical changes made to that utility in Issue 5 and later.
Changes made before Issue 5 are not included.
Changes from Issue 7 to Issue 8 (POSIX.1-2024)
The following list summarizes the major changes that were made in the Shell and Utilities volume of POSIX.1-2024 from Issue 7 to
Issue 8:
The Open Group Standard, 2022, Additional APIs for the Base Specifications Issue 8, Part 2 is incorporated.
Austin Group defect reports and IEEE Interpretations against IEEE Std 1003.1 are applied.
The Open Group corrigenda and resolutions are applied.
Features, marked obsolescent in the base document, have been considered for removal in this version.
New Features in Issue 8
The utilities first introduced in Issue 8 (over the Issue 7 base document) are as follows:
New Utilities in Issue 8
gettext
msgfmt
ngettext
readlink
realpath
timeout
xgettext
Removed Utilities in Issue 8
The utilities removed in Issue 8 (from the Issue 7 base document) are as follows:
Removed Utilities in Issue 8
fort77
qalter
qdel
qhold
qmove
qmsg
qrerun
qrls
qselect
qsig
qstat
qsub
C.1.2 Relationship to Other Documents
C.1.2.1 System Interfaces
It has been pointed out that the Shell and Utilities volume of POSIX.1-2024 assumes that a great deal of
functionality from the System Interfaces volume of POSIX.1-2024 is present, but never states exactly how much (and strictly does
not need to since both are mandated on a conforming system). This section is an attempt to clarify the assumptions.
File Read, Write, and Creation
IEEE Std 1003.1-2001/Cor 2-2004, item XCU/TC2/D6/2 is applied, updating Table 1-1.
File Removal
This is intended to be a summary of the unlink() and rmdir() requirements. Note that it is possible using the unlink() function for item 4. to occur.
C.1.2.2 Concepts Derived from the ISO C Standard
This section was introduced to address the issue that there was insufficient detail presented by such utilities as
awk or sh about their procedural control
statements and their methods of performing arithmetic functions.
The ISO C standard was selected as a model because most historical implementations of the standard utilities
were written in C. Thus, it was more likely that they would act in the desired manner without modification.
Using the ISO C standard is primarily a notational convenience so that the many procedural languages in the
Shell and Utilities volume of POSIX.1-2024 would not have to be rigorously described in every aspect. Its selection does not
require that the standard utilities be written in Standard C; they could be written in Common Usage C, Ada, Pascal, assembler
language, or anything else.
The sizes of the various numeric values refer to C-language data types that are allowed to be different sizes by
the ISO C standard. Thus, like a C-language application, a shell application cannot rely on their exact size. However, it can
rely on their minimum sizes expressed in the ISO C standard, such as {LONG_MAX} for a long type.
The behavior on overflow is undefined for ISO C standard arithmetic. Therefore, the standard utilities can use
"bignum" representation for integers so that there is no fixed maximum unless otherwise stated in the utility description.
Similarly, standard utilities can use infinite-precision representations for floating-point arithmetic, as long as these
representations exceed the ISO C standard requirements.
This section addresses only the issue of semantics; it is not intended to specify syntax. For example, the
ISO C standard requires that 0L be recognized as an integer constant equal to zero, but utilities such as awk and sh are not required to recognize 0L (though
they are allowed to, as an extension).
The ISO C standard requires that a C compiler must issue a diagnostic for constants that are too large to
represent. Most standard utilities are not required to issue these diagnostics; for example, the command:
diff -C 2147483648 file1 file2
has undefined behavior, and the diff utility is not required to issue a
diagnostic even if the number 2147483648 cannot be represented.
Austin Group Defect 1128 is applied, adding a note about the comma operator.
C.1.3 Utility Limits
This section grew out of an idea that originated with the original POSIX.1, in the tables of system limits for the
sysconf() and pathconf() functions.
The idea being that a conforming application can be written to use the most restrictive values that a minimal system can provide,
but it should not have to. The values provided represent compromises so that some vendors can use historically limited versions of
UNIX system utilities. They are the highest values that a strictly conforming application can assume, given no other
information.
However, by using the getconf utility or the sysconf() function, the elegant application can be tailored to more liberal values on some
of the specific instances of specific implementations.
There is no explicitly stated requirement that an implementation provide finite limits for any of these numeric
values; the implementation is free to provide essentially unbounded capabilities (where it makes sense), stopping only at
reasonable points such as {ULONG_MAX} (from the ISO C standard). Therefore, applications desiring to tailor themselves to the
values on a particular implementation need to be ready for possibly huge values; it may not be a good idea to allocate blindly a
buffer for an input line based on the value of {LINE_MAX}, for instance. However, unlike the System Interfaces volume of
POSIX.1-2024, there is no set of limits that return a special indication meaning "unbounded". The implementation should always
return an actual number, even if the number is very large.
The statement:
"It is not guaranteed that the application ..."
is an indication that many of these limits are designed to ensure that implementors design their utilities without
arbitrary constraints related to unimaginative programming. There are certainly conditions under which combinations of options can
cause failures that would not render an implementation non-conforming. For example, {EXPR_NEST_MAX} and {ARG_MAX} could collide
when expressions are large; combinations of {BC_SCALE_MAX} and {BC_DIM_MAX} could exceed virtual memory.
In the Shell and Utilities volume of POSIX.1-2024, the notion of a limit being guaranteed for the process lifetime,
as it is in the System Interfaces volume of POSIX.1-2024, is not as useful to a shell script. The getconf utility is probably a process itself, so the guarantee would be without value.
Therefore, the Shell and Utilities volume of POSIX.1-2024 requires the guarantee to be for the session lifetime. This will mean
that many vendors will either return very conservative values or possibly implement getconf as a built-in.
It may seem confusing to have limits that apply only to a single utility grouped into one global section. However,
the alternative, which would be to disperse them out into their utility description sections, would cause great difficulty when
sysconf() and getconf were described.
Therefore, the standard developers chose the global approach.
Each language binding could provide symbol names that are slightly different from those shown here. For example,
the C-Language Binding option adds a leading  to the symbols as a prefix.
The following comments describe selection criteria for the symbols and their values:
{ARG_MAX}
This is defined by the System Interfaces volume of POSIX.1-2024. Unfortunately, it is very difficult for a conforming application
to deal with this value, as it does not know how much of its argument space is being consumed by the environment variables of the
user.
{BC_BASE_MAX}
{BC_DIM_MAX}
{BC_SCALE_MAX}
These were originally one value, {BC_SCALE_MAX}, but it was unreasonable to link all three concepts into one limit.
{CHILD_MAX}
This is defined by the System Interfaces volume of POSIX.1-2024.
{COLL_WEIGHTS_MAX}
The weights assigned to order can be considered as "passes" through the collation algorithm.
{EXPR_NEST_MAX}
The value for expression nesting was borrowed from the ISO C standard.
{LINE_MAX}
This is a global limit that affects all utilities, unless otherwise noted. The {MAX_CANON} value from the System Interfaces volume
of POSIX.1-2024 may further limit input lines from terminals. The {LINE_MAX} value was the subject of much debate and is a
compromise between those who wished to have unlimited lines and those who understood that many historical utilities were written
with fixed buffers. Frequently, utility writers selected the UNIX system constant BUFSIZ to allocate these buffers; therefore, some
utilities were limited to 512 bytes for I/O lines, while others achieved 4096 bytes or greater.
It should be noted that {LINE_MAX} applies only to input line length; there is no requirement in POSIX.1-2024 that
limits the length of output lines. Utilities such as awk, sed, and paste could theoretically construct lines
longer than any of the input lines they received, depending on the options used or the instructions from the application. They are
not required to truncate their output to {LINE_MAX}. It is the responsibility of the application to deal with this. If the output
of one of those utilities is to be piped into another of the standard utilities, line length restrictions will have to be
considered; the fold utility, among others, could be used to ensure that only
reasonable line lengths reach utilities or applications.
{LINK_MAX}
This is defined by the System Interfaces volume of POSIX.1-2024.
{MAX_CANON}
{MAX_INPUT}
{NAME_MAX}
{NGROUPS_MAX}
{OPEN_MAX}
{PATH_MAX}
{PIPE_BUF}
These limits are defined by the System Interfaces volume of POSIX.1-2024. Note that the byte lengths described by some of these
values continue to represent bytes, even if the applicable character set uses a multi-byte encoding.
{RE_DUP_MAX}
The value selected is consistent with historical practice. Although the name implies that it applies to all REs, only BREs use the
interval notation \{m,n\} addressed by this limit.
{POSIX2_SYMLINKS}
The {POSIX2_SYMLINKS} variable indicates that the underlying operating system supports the creation of symbolic links in specific
directories. Many of the utilities defined in POSIX.1-2024 that deal with symbolic links do not depend on this value. For example,
a utility that follows symbolic links (or does not, as the case may be) will only be affected by a symbolic link if it encounters
one. Presumably, a file system that does not support symbolic links will not contain any. This variable does affect such utilities
as ln -s and pax that attempt to create
symbolic links.
There are different limits associated with command lines and input to utilities, depending on the method of
invocation. In the case of a C program exec-ing a utility, {ARG_MAX} is the underlying limit. In the case of the shell
reading a script and exec-ing a utility, {LINE_MAX} limits the length of lines the shell is required to process, and
{ARG_MAX} will still be a limit. If a user is entering a command on a terminal to the shell, requesting that it invoke the utility,
{MAX_INPUT} may restrict the length of the line that can be given to the shell to a value below {LINE_MAX}.
When an option is supported, getconf returns a value of 1. For
example, when C development is supported:
if [ "$(getconf POSIX2_C_DEV)" -eq 1 ]; then
echo C supported
fi
The sysconf() function in the C-Language Binding option would return
1.
The following comments describe selection criteria for the symbols and their values:
POSIX2_C_BIND
POSIX2_C_DEV
POSIX2_FORT_RUN
POSIX2_SW_DEV
POSIX2_UPE
It is possible for some (usually privileged) operations to remove utilities that support these options or otherwise to render these
options unsupported. The header files, the sysconf() function, or the getconf utility will not necessarily detect such actions, in which case they should not be
considered as rendering the implementation non-conforming. A test suite should not attempt tests such as:
rm /usr/bin/c17
getconf POSIX2_C_DEV
POSIX2_LOCALEDEF
This symbol was introduced to allow implementations to restrict supported locales to only those supplied by the
implementation.
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/2 is applied, deleting the entry for
{POSIX2_VERSION} since it is not a utility limit minimum value.
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/3 is applied, changing the text in Utility Limits
from: "utility (see getconf) through the sysconf() function defined in the System Interfaces volume of POSIX.1-2024. The literal
names shown in Table 1-3 apply only to the getconf utility; the high-level language
binding describes the exact form of each name to be used by the interfaces in that binding." to: "utility (see getconf).".
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0001 [666] is applied.
C.1.4 Grammar Conventions
There is no additional rationale provided for this section.
C.1.5 Utility Description Defaults
This section is arranged with headings in the same order as all the utility descriptions. It is a collection of
related and unrelated information concerning:
The default actions of utilities
The meanings of notations used in POSIX.1-2024 that are specific to individual utility sections
Although this material may seem out of place here, it is important that this information appear before any of the
utilities to be described later.
NAME
There is no additional rationale provided for this section.
SYNOPSIS
There is no additional rationale provided for this section.
DESCRIPTION
Austin Group Defect 351 is applied, adding a requirement relating to declaration utilities.
OPTIONS
Although it has not always been possible, the standard developers tried to avoid repeating information to reduce
the risk that duplicate explanations could each be modified differently.
The need to recognize -- is required because conforming applications need to shield their operands from any
arbitrary options that the implementation may provide as an extension. For example, if the standard utility foo is listed as
taking no options, and the application needed to give it a pathname with a leading , it could safely do it
as:
foo -- -myfile
and avoid any problems with -m used as an extension.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0002 [584] is applied.
OPERANDS
The usage of - is never shown in the SYNOPSIS. Similarly, the usage of -- is never shown.
The requirement for processing operands in command-line order is to avoid a "WeirdNIX" utility that might choose
to sort the input files alphabetically, by size, or by directory order. Although this might be acceptable for some utilities, in
general the programmer has a right to know exactly what order will be chosen.
Some of the standard utilities take multiple file operands and act as if they were processing the
concatenation of those files. For example:
asa file1 file2
and:
cat file1 file2 | asa
have similar results when questions of file access, errors, and performance are ignored. Other utilities such as
grep or wc have completely different results
in these two cases. This latter type of utility is always identified in its DESCRIPTION or OPERANDS sections, whereas the former is
not. Although it might be possible to create a general assertion about the former case, the following points must be addressed:
Access times for the files might be different in the operand case versus the cat case.
The utility may have error messages that are cognizant of the input filename, and this added value should not be
suppressed. (As an example, awk sets a variable with the filename at each file
boundary.)
STDIN
There is no additional rationale provided for this section.
INPUT FILES
A conforming application cannot assume the following three commands are equivalent:
tail -n +2 file
(sed -n 1q; cat)  characters can legitimately be included in some of the fields described by the standard
utilities, particularly in locales other than the POSIX locale, this intent is not always realized.
ENVIRONMENT VARIABLES
There is no additional rationale provided for this section.
ASYNCHRONOUS EVENTS
Because there is no language prohibiting it, a utility is permitted to catch a signal, perform some additional
processing (such as deleting temporary files), restore the default signal action, and resignal itself.
Austin Group Defects 1648 and 1772 are applied, clarifying the default behavior for signal handling.
STDOUT
The format description is intended to be sufficiently rigorous to allow post-processing of output by other
programs, particularly by an awk or lex
parser.
STDERR
This section does not describe error messages that refer to incorrect operation of the utility. Consider a utility
that processes program source code as its input. This section is used to describe messages produced by a correctly operating
utility that encounters an error in the program source code on which it is processing. However, a message indicating that the
utility had insufficient memory in which to operate would not be described.
Some utilities have traditionally produced warning messages without returning a non-zero exit status; these are
specifically noted in their sections. Other utilities shall not write to standard error if they complete successfully, unless the
implementation provides some sort of extension to increase the verbosity or debugging level.
The format descriptions are intended to be sufficiently rigorous to allow post-processing of output by other
programs.
OUTPUT FILES
The format description is intended to be sufficiently rigorous to allow post-processing of output by other
programs, particularly by an awk or lex
parser.
Receipt of the SIGQUIT signal should generally cause termination (unless in some debugging mode) that would bypass
any attempted recovery actions.
EXTENDED DESCRIPTION
There is no additional rationale provided for this section.
EXIT STATUS
Note the additional discussion of exit values in Exit Status for Commands in the sh utility. It describes requirements for returning exit values greater than 125.
A utility may list zero as a successful return, 1 as a failure for a specific reason, and greater than 1 as "an
error occurred". In this case, unspecified conditions may cause a 2 or 3, or other value, to be returned. A strictly conforming
application should be written so that it tests for successful exit status values (zero in this case), rather than relying upon the
single specific error value listed in POSIX.1-2024. In that way, it will have maximum portability, even on implementations with
extensions.
The standard developers are aware that the general non-enumeration of errors makes it difficult to write test
suites that test the incorrect operation of utilities. There are some historical implementations that have expended effort
to provide detailed status messages and a helpful environment to bypass or explain errors, such as prompting, retrying, or ignoring
unimportant syntax errors; other implementations have not. Since there is no realistic way to mandate system behavior in cases of
undefined application actions or system problems—in a manner acceptable to all cultures and environments—attention has been limited
to the correct operation of utilities by the conforming application. Furthermore, the conforming application does not need detailed
information concerning errors that it caused through incorrect usage or that it cannot correct.
Austin Group Defect 1492 is applied, adding the Default Behavior paragraph.
CONSEQUENCES OF ERRORS
Several actions are possible when a utility encounters an error condition, depending on the severity of the error
and the state of the utility. Included in the possible actions of various utilities are: deletion of temporary or intermediate work
files; deletion of incomplete files; and validity checking of the file system or directory.
The text about recursive traversing is meant to ensure that utilities such as find process as many files in the hierarchy as they can. They should not abandon all of the
hierarchy at the first error and resume with the next command-line operand, but should attempt to keep going.
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0001 [150] is applied.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0003 [913] is applied.
Austin Group Defect 251 is applied, adding a note about the treatment of pathnames containing any bytes that have
the encoded value of a  character.
Austin Group Defect 1499 is applied, requiring utilities to exit with an exit status that indicates an error
occurred, instead of any non-zero exit status.
APPLICATION USAGE
This section provides additional caveats, issues, and recommendations to the developer.
EXAMPLES
This section provides sample usage.
RATIONALE
There is no additional rationale provided for this section.
FUTURE DIRECTIONS
FUTURE DIRECTIONS sections act as pointers to related work that may impact the interface in the future, and often
cautions the developer to architect the code to account for a change in this area. Note that a future directions statement should
not be taken as a commitment to adopt a feature or interface in the future.
SEE ALSO
There is no additional rationale provided for this section.
CHANGE HISTORY
There is no additional rationale provided for this section.
C.1.6 Considerations for Utilities in Support of Files of Arbitrary Size
This section is intended to clarify the requirements for utilities in support of large files.
The utilities listed in this section are utilities which are used to perform administrative tasks such as to
create, move, copy, remove, change the permissions, or measure the resources of a file. They are useful both as end-user tools and
as utilities invoked by applications during software installation and operation.
The chgrp, chmod,
chown, ln, and rm utilities probably require use of large file-capable versions of stat(), lstat(), nftw(), and the stat structure.
The cat, cksum, cmp, cp, dd,
mv, and touch utilities probably require use
of large file-capable versions of creat(), open(), and fopen().
The cat, cksum, cmp, dd, df,
du, and ls utilities may require writing large
integer values. For example:
The cat utility might have a -n option which counts
characters.
The cksum and ls utilities
report file sizes.
The cmp utility reports the line number at which the first difference
occurs, and also has a -l option which reports file offsets.
The dd, df, du, and ls utilities report block counts.
The dd, find, and test utilities may need to interpret command arguments that contain 64-bit values. For dd, the arguments include skip=n, seek=n, and count=n.
For find, the arguments include -sizen. For test, the arguments are those associated with algebraic comparisons.
The df utility might need to access large file systems with statvfs().
The ulimit utility will need to use large file-capable versions of
getrlimit() and setrlimit() and
be able to read and write large integer values.
Austin Group Defect 1568 is applied, removing references to the sum utility.
C.1.7 Built-In Utilities
Other than the special built-in utilities, there is no requirement to build utilities into the shell itself.
However, many shells implement certain utilities as regular built-ins for the following reasons:
To improve performance, especially for frequently used lightweight utilities (such as test, true, and false).
To eliminate the need for some sort of interprocess communication between the shell and those utilities that read
or modify the shell's execution environment (such as cd).
To make it easier to satisfy the command search and execution requirements in XCU 2.9.1.4 Command Search and Execution for intrinsic utilities. Intrinsic
utilities must be found prior to the PATH search. The shell could satisfy this requirement by keeping a list of the
intrinsic utility pathnames and directly accessing the file-system versions regardless of PATH , but these utilities usually
need to read or modify the shell's execution environment anyway.
With the exception of the intrinsic utilities, all regular built-in utilities are subject to the PATH search
and can be overridden by a specially crafted PATH environment variable.
Earlier versions of this standard required that all of the regular built-in utilities, including intrinsic
utilities, could be exec-ed. This was always a contentious requirement, and with the introduction of intrinsic utilities the
standard developers decided to exempt the utilities that this standard requires to be intrinsic, with the exception of kill. The kill utility is still genuinely useful
when exec-ed, only lacking support for the % job ID notation, whereas examples given of uses for the other
utilities that are now exempted were considered contrived (such as using cd to test
accessibility of a directory, which can be done using test -x). If an
application needs exec-able versions of some of the exempted intrinsic utilities, it can easily provide them itself, on
systems that support the (non-standard but ubiquitous) "#!" mechanism to make scripts executable by the exec family
of functions, as links to a two-line shell script:
#! /path/to/sh
${0##*/} "$@"
Austin Group Defect 854 is applied, replacing the table of Regular Built-In Utilities with a reference to the new
Intrinsic Utilities section.
Austin Group Defect 1600 is applied, exempting the intrinsic utilities other than kill from the requirement that they can be exec-ed.
C.1.8 Intrinsic Utilities
There were varying reasons for including utilities in the table of intrinsic utilities:
alias, fc, unalias
The functionality of these utilities is performed more simply within the shell itself and that is the model most historical
implementations have used.
bg, fg, jobs
All of the job control-related utilities are eligible for built-in status because that is the model most historical implementations
have used.
cd, getopts, hash, read, type, ulimit, umask, wait
The functionality of these utilities is performed more simply within the context of the current process. An example can be taken
from the usage of the cd utility. The purpose of the cd utility is to change the working directory for subsequent operations. The actions of cd affect the process in which cd is executed and all
subsequent child processes of that process. Based on the POSIX standard process model, changes in the process environment of a
child process have no effect on the parent process. If the cd utility were executed from
a child process, the working directory change would be effective only in the child process. Child processes initiated subsequent to
the child process that executed the cd utility would not have a changed working directory
relative to the parent process.
command
This utility was placed in the table primarily to protect scripts that are concerned about their PATH being manipulated. The
"secure" shell script example in the command utility in the Shell and Utilities
volume of POSIX.1-2024 would not be possible if a PATH change retrieved an alien version of command. (An alternative would have been to implement getconf as a built-in, but the standard developers considered that it carried too many
changing configuration strings to require in the shell.)
kill
Since kill provides optional job control functionality using shell notation
(%1, %2, and so on), some implementations would find it extremely difficult to provide this outside the
shell.
The following utilities are frequently implemented as intrinsic (and built-in) utilities. Future versions of this
standard might not allow these utilities, or any other standard utility not in Intrinsic Utilities, to be intrinsic; implementations are encouraged to
implement these as non-intrinsic utilities instead (but still built-in if they were previously built-in).
[, echo, false, newgrp, printf, pwd, test, true
All utilities, including those in the table, are accessible via the system() and popen() functions in the System
Interfaces volume of POSIX.1-2024. There are situations where the return functionality of system() and popen() is not desirable.
Applications that require the exit status of the invoked utility will not be able to use system() or popen(), since the exit status
returned is that of the command language interpreter rather than that of the invoked utility. The alternative for such applications
is the use of the exec family.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0004 [705] is applied.
Austin Group Defect 854 is applied, adding intrinsic utilities.
C.2 Shell Command Language
C.2.1 Shell Introduction
The System V shell was selected as the starting point for the Shell and Utilities volume of POSIX.1-2024. The
BSD C shell was excluded from consideration for the following reasons:
Most historically portable shell scripts assume the Version 7 Bourne shell, from which the System V shell is
derived.
The majority of tutorial materials on shell programming assume the System V shell.
The construct "#!" is reserved for implementations wishing to provide that extension. If it were not
reserved, the Shell and Utilities volume of POSIX.1-2024 would disallow it by forcing it to be a comment. As it stands, a strictly
conforming application must not use "#!" as the first two characters of the file.
Austin Group Defect 249 is applied, adding the dollar-single-quotes quoting mechanism.
Austin Group Defect 1514 is applied, correcting a misuse of the term "positional parameter".
C.2.2 Quoting
Although this section contains a note indicating that a future version of this standard may extend the conditions
under which some characters are special, there are no plans to do so. The note is there to encourage application writers to
future-proof their shell code. In some cases existing widespread use of the characters unquoted would preclude them being given a
special meaning in those use cases. For example, commas are in widespread use in filenames (notably by RCS and CVS) and it is
common to pass the token "{}" as an argument to find and xargs unquoted.
Austin Group Defect 249 is applied, adding the dollar-single-quotes quoting mechanism.
Austin Group Defects 1191 and 1193 are applied, adding:
]  ^  -  !  {  ,  }
to the list of characters that might need to be quoted under certain circumstances.
C.2.2.1 Escape Character (Backslash)
Austin Group Defect 500 is applied, changing "follows" to "immediately follows".
C.2.2.2 Single-Quotes
A  cannot be used to escape a single-quote in a single-quoted string. An embedded quote can be
created by writing, for example: "'a'\''b'", which yields "a'b". (See XCU 2.6.5 Field Splitting for a better understanding of how portions of words are
either split into fields or remain concatenated.) A single token can be made up of concatenated partial strings containing all
three kinds of quoting or escaping, thus permitting any combination of characters.
C.2.2.3 Double-Quotes
The escaped  used for line continuation is removed entirely from the input and is not replaced by
any white space. Therefore, it cannot serve as a token separator.
In double-quoting, if a  is immediately followed by a character that would be interpreted as
having a special meaning, the  is deleted and the subsequent character is taken literally. If a
does not precede a character that would have a special meaning, it is left in place unmodified and the character immediately
following it is also left unmodified. Thus, for example:
"\$"  ->  $
"\a"  ->  \a
It would be desirable to include the statement "The characters from an enclosed "${" to the matching
'}' shall not be affected by the double-quotes", similar to the one for "$()". However, historical practice in
the System V shell prevents this.
Shell implementations differ widely in their handling of unescaped double-quote characters inside "${...}"
(except for the four substring-processing variants). Hence this standard leaves the behavior unspecified. Single-quotes are
ordinary characters in this context, and so cannot be used to quote a '}' within "${...}". However,
can be used to escape a '}'. For example, the value of foo assigned by the following commands is
'}':
unset bar
foo="${bar-\}}"
When  is used in this way it is a special character and is therefore removed during quote removal,
even though it would not be removed in:
foo="\}"
Differences in processing the "${...}" form led to inconsistencies between the historical System V
shell, BSD, and KornShells, and the text in the Shell and Utilities volume of POSIX.1-2024 is an attempt to converge them without
breaking too many applications. The only alternative to this compromise between shells would be to make the behavior unspecified
not just for unescaped double-quote but also for unescaped single-quote, '{', or '}'. The chosen requirements
provide the maximum consistency between normal double-quote behavior and parameter expansion within double-quotes; the only real
difference being the ability to escape a '}' with .
Some implementations have allowed the end of the word to terminate the backquoted command substitution, such as
in:
"`echo hello"
This usage is undefined; the matching backquote is required by the Shell and Utilities volume of POSIX.1-2024. The
other undefined usage can be illustrated by the example:
sh -c '` echo "foo`'
The description of the recursive actions involving command substitution can be illustrated with an example. Upon
recognizing the introduction of command substitution, the shell parses input (in a new context), gathering the source for the
command substitution until an unbalanced ')' or '`' is located. For example, in the following:
echo "$(date; echo "
one" )"
the double-quote following the echo does not terminate the first
double-quote; it is part of the command substitution script. Similarly, in:
echo "$(echo *)"
the  is not quoted since it is inside command substitution; however:
echo "$(echo "*")"
is quoted (and represents the  character itself).
The $'...' construct does not retain its special meaning inside double quotes. This was discussed by the
standard developers and rejected. Note that $'...' is a quoting mechanism and not an expansion. Losing the special meaning
inside double-quotes is consistent with other quoting mechanisms losing their special meaning when quoted.
Austin Group Defect 221 is applied, clarifying the behavior of double-quotes within the string of characters from
"${" to the matching '}' in parameter expansions using that form.
Austin Group Defect 249 is applied, adding the dollar-single-quotes quoting mechanism.
Austin Group Defect 500 is applied, clarifying the behavior of  within double-quotes.
Austin Group Defect 1268 is applied, clarifying the effect of double-quotes on the results of parameter expansion,
command substitution, or arithmetic expansion.
Austin Group Defect 1342 is applied, clarifying the requirements for alias substitutions inside command
substitutions.
C.2.2.4 Dollar-Single-Quotes
The $'...' quoting construct has been implemented in several recent shells. It is similar to character
string literals ("...") in the ISO C standard with the following exceptions:
The \x escape sequence in C can be followed by an arbitrary number of hexadecimal digits. The
ksh93 implementation of $'...' also consumes an arbitrary number of hexadecimal digits; bash consumes at
most two hexadecimal digits in this case. This standard leaves the result unspecified if more than two hexadecimal digits follow
\x. (Note that a hexadecimal escape followed by a literal hexadecimal character can always be represented as
$'\xXX'X.)
The \c escape sequence is not included in the ISO C standard. There was also some disagreement in
shells that historically supported \c escape sequences in $'...'. These include:
Whether \cA through \cZ produced the byte values 1 through 26, respectively or supported the
codeset independent control character as specified by the stty utility. This standard
requires codeset independence.
Whether \c[, \c\\, \c], \c^, \c_, and \c? could be used to
yield the , , , , , and  control characters, respectively. This
standard requires support for all of the control characters except NULL (matching what is done in the stty utility).
Whether \c\\ or \c\ was used to represent . This standard requires \c\\ to
make -escape processing consistent.
The implementors of the most common shells that implement $'\cX' agreed to convert to the
behavior specified in this standard.
Some shells also allow \c to act as an inverse function to
\cX (that is, \cm and \cM yield  and \c yields m or
M. This standard leaves this behavior implementation-defined.
The \e escape sequence is not included in the ISO C standard, but was provided by all historical
shells that supported $'...'. Some also supported \E as a synonym. One member of the group objected to adding
\e because the  control character is not required to be in the portable character set. The \e sequence
is included because many historical users of $'...' expect it to be there. The \E sequence is not included in
this standard because -escape sequences that start with  followed by an uppercase letter (except
\U) are reserved by the ISO C standard for implementation use.
The \ddd octal escape sequence and the \xXX hexadecimal escape sequence can be
used to insert a null byte into a C character string literal and into a $'...' quoted word in this standard. In C, any
characters specified after that null byte (including escape sequences) continue to be processed and added to the character string
literal. In $'...' in the shell this standard allows the equivalent behavior but also allows the null byte and all
remaining characters up to the terminating unescaped single-quote to be evaluated and discarded. The latter (which was historic
practice in bash, but not in ksh93) allows an escape sequence producing a null byte to terminate the
dollar-single-quoted expansion, but not terminate the token in which it appears if there are characters remaining in the token. For
example:
printf a$'b\0c\''d
is required by this standard to produce:
abd
while historic versions of ksh93 produced:
ab
The ISO C standard specifies \uXXXX and \UXXXXXXXX escape sequences. These
need not be supported by $'...' in the shell. They were omitted because current shell implementations that support them
differ in behavior. In particular, some shells always convert them to the UTF-8 encoding for the named character, even if the
current locale's character set does not have UTF-8 encoding.
The double-quote character can be used literally, while the single-quote character must be represented as an
escape sequence. In C, single-quote can be used literally, while double-quote requires an escape sequence.
A  immediately followed by a  has unspecified behavior. In C, this sequence is
used for line continuations, where both the  and  are deleted and a diagnostic is required if a
closing quote is not encountered before a  that is not preceded by . In current shell
implementations, three different behaviors have been observed.
The use of -escape sequences not described in this standard results in unspecified behavior. In
C, the result is not a token and a diagnostic is required. This allows shells to recognize other -escape sequences
in other ways as extensions to this standard. Furthermore, existing implementations already had different behaviors for some
-escape sequences when $'...' processing was added to this standard.
This standard makes the results implementation-defined if \e or \cX specifies a character
that is not present in the current locale. Application authors should note that implementations are permitted to have a wide range
of behaviors when encountering an unsupported character. For example:
The shell might produce an error, possibly causing the shell to terminate.
The unsupported character might be silently discarded.
The unsupported character might be replaced with another character of a different character class.
The unsupported character might be replaced with a shell-special character (e.g., '?').
The unsupported character might be replaced with multiple characters, shell-special or regular (e.g. if
is not supported, $'\e' may be replaced by "???", "XXX", or "").
However, implementations must document their behavior, and they are prohibited from replacing an unsupported
character with bytes that do not form valid characters in the current locale's character set (e.g., encoding in UTF-8 when the
locale has a 7-bit character set). This standard does not specify a way for script authors to determine beforehand whether a
particular \cX sequence specifies a character that exists in the current locale. At the time this feature was
standardized, no known implementations provided such a capability.
Note that the escape sequences recognized by $'...', file format notation (see Escape Sequences and Associated Actions), XSI-conforming implementations of the
echo utility (see the utility's OPERANDS section in echo), and the printf utility's format
operand (see the utility's EXTENDED DESCRIPTION in printf) are not the
same. Some escape sequences are not recognized by all of the above, the \c escape sequence in echo is not at all like the \c escape sequence in $'...', octal escape
sequences in some of the above accept one to four octal digits and require a leading zero while others accept one to three octal
digits and do not require a leading zero.
Austin Group Defect 249 is applied, adding the dollar-single-quotes quoting mechanism.
C.2.3 Token Recognition
The "((" and "))" symbols are control operators in the KornShell, used for an alternative syntax
of an arithmetic expression command. A conforming application cannot use "((" as a single token (with the exception of the
"$((" form for shell arithmetic).
On some implementations, the symbol "((" is a control operator; its use produces unspecified results.
Applications that wish to have nested subshells, such as:
((echo Hello);(echo World))
must separate the "((" characters into two tokens by including white space between them. Some systems may
treat these as invalid arithmetic expressions instead of subshells.
Certain combinations of characters are invalid in portable scripts, as shown in the grammar. Implementations may
use these combinations (such as "|&") as valid control operators. Portable scripts cannot rely on receiving errors in
all cases where this volume of POSIX.1-2024 indicates that a syntax is invalid.
The (3) rule about combining characters to form operators is not meant to preclude systems from extending the shell
language when characters are combined in otherwise invalid ways. Conforming applications cannot use invalid combinations, and test
suites should not penalize systems that take advantage of this fact. For example, the unquoted combination "|&" is not
valid in a POSIX script, but has a specific KornShell meaning.
The (10) rule about '#' as the current character is the first in the sequence in which a new token is
being assembled. The '#' starts a comment only when it is at the beginning of a token. This rule is also written to
indicate that the search for the end-of-comment does not consider escaped  specially, so that a comment cannot be
continued to the next line.
Because a complete_command encountered during a program is executed before the next
complete_command is tokenized and parsed, syntax errors are not discovered by the shell until just before the code would be
executed. While in some cases it might be desirable to detect and react to syntax errors before anything is executed (possible with
sh -n), deferring the discovery of syntax errors has several benefits:
It makes it possible for script authors to test for the availability of a nonstandard extension and react
appropriately before the use of the extension would trigger a syntax error.
It makes it possible to create self-extracting tarballs (a shell script concatenated with a payload archive that
extracts the archive when executed).
The shell does not have to read and parse the complete script before execution, which reduces memory usage when
executing extremely long scripts.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0005 [718], XCU/TC2-2008/0006 [647], XCU/TC2-2008/0007 [568],
and XCU/TC2-2008/0008 [648] are applied.
Austin Group Defect 249 is applied, adding the dollar-single-quotes quoting mechanism.
Austin Group Defect 1036 is applied, clarifying how here-documents are parsed.
Austin Group Defect 1055 is applied, clarifying how much of a program is parsed before the parsed commands
are executed.
Austin Group Defect 1083 is applied, changing "the next character" to "each character in turn".
Austin Group Defect 1085 is applied, clarifying requirements for the start and end of tokens.
C.2.3.1 Alias Substitution
The alias capability was added because it is widely used in historical implementations by interactive users.
The definition of "alias name" precludes an alias name containing a  character. Since the text
applies to the command words of simple commands, reserved words (in their proper places) cannot be confused with aliases.
The placement of alias substitution in token recognition makes it clear that it precedes all of the word expansion
steps.
An example concerning trailing  characters and reserved words follows. If the user types:
$ alias foo="/bin/ls "
$ alias while="/"
The effect of executing:
$ while true
> do
> echo "Hello, World"
> done
is a never-ending sequence of "Hello, World" strings to the screen. However, if the user types:
$ foo while
the result is an ls listing of /. Since the alias substitution for
foo ends in a , the next word is checked for alias substitution. The next word, while, has also been
aliased, so it is substituted as well. Since it is not in the proper position as a command word, it is not recognized as a reserved
word.
If the user types:
$ foo; while
while retains its normal reserved-word properties.
Some implementations add a  after the alias value when performing alias substitution in order to
prevent the last character of the alias value and the first character after the alias name in the input from combining to form an
operator. However, the extra  can have side-effects in other situations, such as if the alias value ends with an
unquoted . Implementations which do this are encouraged to change to an alternative method of delimiting a partial
operator token at the end of an alias value.
Some, but not all, shell implementations do not process changes to alias definitions until the current
compound_list (see XCU 2.10 Shell Grammar) has completed. In
these shells, alias changes do not take effect until the end of the dot script, eval
command, function invocation, if statement, case statement, for statement, while statement, or
until statement containing the alias change.
Many shell implementations execute the contents of a file, typically ~/.profile, when invoked as a login
shell. The standard developers are unaware of any such implementations that process the contents of ~/.profile (and similar
startup files) as a single compound_list, so alias changes in ~/.profile typically do take effect before the end of
~/.profile.
Austin Group Defects 953 and 1630 are applied, providing additional detail on how alias substitution is
performed.
C.2.4 Reserved Words
All reserved words are recognized syntactically as such in the contexts described. However, note that in is
the only meaningful reserved word after a case or for; similarly, in is not meaningful as the first word of a
simple command.
Reserved words are recognized only when they are delimited (that is, meet the definition of XBD 3.420 Word), whereas operators are themselves delimiters. For instance,
'(' and ')' are control operators, so that no  is needed in (list). However, '{' and
'}' are reserved words in { list;}, so that in this case the leading  and  are
required.
The list of unspecified reserved words is from the KornShell, so conforming applications cannot use them in places
a reserved word would be recognized. Earlier versions of this standard omitted time from this list, so that the time utility could be included without requiring applications to quote all or part of its name
(or use other measures) in order to avoid it being treated as a reserved word. However, although the intent was to allow the
reserved word implementation (as evidenced by use of time in pipelines being
unspecified, and explicit mention in the rationale of the time utility), the conditions
under which the behavior was unspecified were insufficient to allow this. In particular, redirection in KornShell does not work in
the normal way when time is a reserved word:
time utility 2> time.out
only writes the standard error from utility to time.out; the timing information is written to the
shell's standard error, but these versions of the standard required the timing information to be written to time.out.
Another issue was that if time is a reserved word, an application cannot define a function with that name, but these
versions of the standard required that applications could do so. Hence time has now been added to the list of unspecified
reserved words, but with its use as a reserved word limited in order to be compatible with its use as a utility in the cases where
the two have traditionally had the same effect (other than possible output format differences).
There was a strong argument for promoting braces to operators (instead of reserved words), so they would be
syntactically equivalent to subshell operators. Concerns about compatibility outweighed the advantages of this approach.
Nevertheless, conforming applications should consider quoting '{' and '}' when they represent themselves.
When used in circumstances where reserved words are recognized, all words whose final character is a
(':') are reserved. The case of a name suffixed with a colon is reserved to allow implementations to support named labels
for flow control; see the RATIONALE for the break special built-in utility.
Other words ending in  are reserved to provide implementations with a way to add new reserved words while still
conforming to this standard.
It is possible that a future version of the Shell and Utilities volume of POSIX.1-2024 may require that
'{' and '}' be treated individually as control operators, although the token "{}" will probably be a
special-case exemption from this because of the often-used find{} construct.
Austin Group Defect 267 is applied, adding time to the list of words that may be recognized as reserved
words while specifying its behavior if it is recognized as a reserved word, and extending the reservation of words whose final
character is  from those that are a name followed by a  to all such words.
Austin Group Defect 465 is applied, adding namespace to the list of words that may be recognized as reserved
words.
C.2.5 Parameters and Variables
Austin Group Defect 1561 is applied, clarifying that parameters can contain byte sequences that do not form valid
characters and that the shell processes their values as characters only when performing operations that are described in this
standard in terms of characters.
C.2.5.1 Positional Parameters
Austin Group Defect 1491 is applied, clarifying the handling of leading zeros in positional parameter
identifiers.
C.2.5.2 Special Parameters
Most historical implementations implement subshells by forking; thus, the special parameter '$' does not
necessarily represent the process ID of the shell process executing the commands since the subshell execution environment preserves
the value of '$'.
If a subshell were to execute a background command, the value of "$!" for the parent would not change. For
example:
(
date &
echo $!
)
echo $!
would echo two different values for "$!".
The "$-" special parameter can be used to save and restore set options:
Save=$(echo $- | sed 's/[ics]//g')
...
set +aCefnuvx
if [ -n "$Save" ]; then
set -$Save
fi
The three options are removed using sed in the example because they may
appear in the value of "$-" (from the sh command line), but are not valid
options to set.
The descriptions of parameters '*' and '@' assume the reader is familiar with the field splitting
discussion in XCU 2.6.5 Field Splitting and understands that portions
of the word remain concatenated unless there is some reason to split them into separate fields.
The following examples illustrate some of the ways in which '*' and '@' can be expanded:
set "abc" "def ghi" "jkl"
unset novar
IFS=' ' # a space
printf '%s\n' $*
abc
def
ghi
jkl
printf '%s\n' "$*"
abc def ghi jkl
printf '%s\n' xx$*yy
xxabc
def
ghi
jklyy
printf '%s\n' "xx$*yy"
xxabc def ghi jklyy
printf '%s\n' $@
abc
def
ghi
jkl
printf '%s\n' "$@"
abc
def ghi
jkl
printf '%s\n' ${1+"$@"}
abc
def ghi
jkl
printf '%s\n' ${novar-"$@"}
abc
def ghi
jkl
printf '%s\n' xx$@yy
xxabc
def
ghi
jklyy
printf '%s\n' "xx$@yy"
xxabc
def ghi
jklyy
printf '%s\n' $@$@
abc
def
ghi
jklabc
def
ghi
jkl
printf '%s\n' "$@$@"
abc
def ghi
jklabc
def ghi
jkl
IFS=':'
printf '%s\n' "$*"
abc:def ghi:jkl
var=$*; printf '%s\n' "$var"
abc:def ghi:jkl
var="$*"; printf '%s\n' "$var"
abc:def ghi:jkl
unset var
printf '%s\n' ${var-$*}
abc
def ghi
jkl
printf '%s\n' "${var-$*}"
abc:def ghi:jkl
printf '%s\n' ${var-"$*"}
abc:def ghi:jkl
printf '%s\n' ${var=$*}
abc
def ghi
jkl
printf 'var=%s\n' "$var"
var=abc:def ghi:jkl
unset var
printf '%s\n' "${var=$*}"
abc:def ghi:jkl
printf 'var=%s\n' "$var"
var=abc:def ghi:jkl
IFS='' # null
printf '%s\n' "$*"
abcdef ghijkl
var=$*; printf '%s\n' "$var"
abcdef ghijkl
var="$*"; printf '%s\n' "$var"
abcdef ghijkl
unset var
printf '%s\n' ${var-$*}
abc
def ghi
jkl
printf '%s\n' "${var-$*}"
abcdef ghijkl
printf '%s\n' ${var-"$*"}
abcdef ghijkl
printf '%s\n' ${var=$*}
abcdef ghijkl
printf 'var=%s\n' "$var"
var=abcdef ghijkl
unset var
printf '%s\n' "${var=$*}"
abcdef ghijkl
printf 'var=%s\n' "$var"
var=abcdef ghijkl
printf '%s\n' "$@"
abc
def ghi
jkl
unset IFS
printf '%s\n' "$*"
abc def ghi jkl
var=$*; printf '%s\n' "$var"
abc def ghi jkl
var="$*"; printf '%s\n' "$var"
abc def ghi jkl
unset var
printf '%s\n' ${var-$*}
abc
def
ghi
jkl
printf '%s\n' "${var-$*}"
abc def ghi jkl
printf '%s\n' ${var-"$*"}
abc def ghi jkl
printf '%s\n' ${var=$*}
abc
def
ghi
jkl
printf 'var=%s\n' "$var"
var=abc def ghi jkl
unset var
printf '%s\n' "${var=$*}"
abc def ghi jkl
printf 'var=%s\n' "$var"
var=abc def ghi jkl
printf '%s\n' "$@"
abc
def ghi
jkl
set one "" three
printf '[%s]\n' $*
[one]
[] (this line of output is optional)
[three]
printf '[%s]\n' $@
[one]
[] (this line of output is optional)
[three]
set --
printf '[%s]\n' foo "$*"
[foo]
[]
printf '[%s]\n' foo "$novar$*$(echo)"
[foo]
[]
printf '[%s]\n' foo $@
[foo]
printf '[%s]\n' foo "$@"
[foo]
printf '[%s]\n' foo ''$@
[foo]
[]
printf '[%s]\n' foo ''"$@"
[foo]
[]
printf '[%s]\n' foo "$novar$@$(echo)"
[foo]
[] (this line of output is optional)
printf '[%s]\n' foo ''"$novar$@$(echo)"
[foo]
[]
In all of the following commands the results of the expansion of '@' (if performed) are unspecified:
var=$@
var="$@"
printf '%s\n' ${var=$@}
printf '%s\n' "${var=$@}"
printf '%s\n' ${var="$@"}
printf '%s\n' ${var?$@}
printf '%s\n' "${var?$@}"
printf '%s\n' ${var?"$@"}
printf '%s\n' ${#@}
printf '%s\n' "${#@}"
printf '%s\n' ${@%foo}
printf '%s\n' "${@%foo}"
printf '%s\n' ${@#foo}
printf '%s\n' "${@#foo}"
printf '%s\n' ${var%$@}
printf '%s\n' "${var%$@}"
printf '%s\n' ${var%"$@"}
printf '%s\n' ${var%%$@}
printf '%s\n' "${var%%$@}"
printf '%s\n' ${var%%"$@"}
printf '%s\n' ${var#$@}
printf '%s\n' "${var#$@}"
printf '%s\n' ${var#"$@"}
printf '%s\n' ${var##$@}
printf '%s\n' "${var##$@}"
printf '%s\n' ${var##"$@"}
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0009 [888] is applied.
Austin Group Defect 1039 is applied, clarifying the description of the '-' special parameter.
Austin Group Defect 1052 is applied, clarifying that decimal valued special parameters expand to the shortest
representation.
Austin Group Defects 1150 and 1309 are applied, clarifying the description of the '?' special
parameter.
Austin Group Defect 1254 is applied, clarifying how the '?' and '!' special parameters are
affected by job control.
C.2.5.3 Shell Variables
Since shell variables are parameters denoted by a name, the shell cannot initialize shell variables from
environment variables that do not have a valid name. However, the shell may initialize parameters that do not have valid names from
such environment variables.
See the discussion of IFS in C.2.6.5 Field Splitting and the RATIONALE for
the sh utility.
The prohibition on LC_CTYPE changes affecting lexical processing protects the shell implementor (and the
shell programmer) from the ill effects of changing the definition of  or the set of alphabetic characters in the
current environment. It would probably not be feasible to write a compiled version of a shell script without this rule. The rule
applies only to the current invocation of the shell and its subshells—invoking a shell script or performing exec sh would subject the new shell to the
changes in LC_CTYPE .
Other common environment variables used by historical shells are not specified by the Shell and Utilities volume of
POSIX.1-2024, but they should be reserved for the historical uses.
Tilde expansion for components of PATH in an assignment such as:
PATH=~hlj/bin:~dwc/bin:$PATH
is a feature of some historical shells and is allowed by the wording of XCU 2.6.1 Tilde Expansion. Note that the  characters are expanded
during the assignment to PATH , not when PATH is accessed during command search.
The following entries represent additional information about variables included in the Shell and Utilities volume
of POSIX.1-2024, or rationale for common variables in use by shells that have been excluded:
_
(Underscore.) While  is historical practice, its overloaded usage in the KornShell is confusing, and it has
been omitted from the Shell and Utilities volume of POSIX.1-2024.
ENV
This variable can be used to set aliases and other items local to the invocation of a shell. The file referred to by ENV
differs from $HOME/.profile in that .profile is typically executed at session start-up, whereas the ENV file
is executed at the beginning of each shell invocation. The ENV value is interpreted in a manner similar to a dot script, in
that the commands are executed in the current environment and the file needs to be readable, but not executable. However, unlike
dot scripts, no PATH searching is performed. This is used as a guard against Trojan Horse security breaches.
ERRNO
This variable was omitted from the Shell and Utilities volume of POSIX.1-2024 because the values of error numbers are not
defined in POSIX.1-2024 in a portable manner.
FCEDIT
Since this variable affects only the fc utility, it has been omitted from this more
global place. The value of FCEDIT does not affect the command-line editing mode in the shell; see the description of
set -o vi in the set built-in utility.
PS1
This variable is used for interactive prompts. Historically, the "superuser" has had a prompt of '#'. Since
privileges are not required to be monolithic, it is difficult to define which privileges should cause the alternate prompt.
However, a sufficiently powerful user should be reminded of that power by having an alternate prompt.
PS3
This variable is used by the KornShell for the select command. Since the POSIX shell does not include select,
PS3 was omitted.
PS4
This variable is used for shell debugging. For example, the following script:
PS4='[${LINENO}]+ '
set -x
echo Hello
writes the following to standard error:
[3]+ echo Hello
RANDOM
This pseudo-random number generator was not seen as being useful to interactive users.
SECONDS
Although this variable is sometimes used with PS1 to allow the display of the current time in the prompt of the user, it
is not one that would be manipulated frequently enough by an interactive user to include in the Shell and Utilities volume of
POSIX.1-2024.
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0002 [152] is applied.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0010 [888], XCU/TC2-2008/0011 [884], and XCU/TC2-2008/0012
[494] are applied.
Austin Group Defect 953 is applied, clarifying how the ENV file is parsed.
Austin Group Defect 1006 is applied, clarifying how the values of the PS1 , PS2 , and PS4
variables are expanded.
Austin Group Defect 1441 is applied, requiring PS4 to be used in non-interactive shells.
Austin Group Defect 1511 is applied, making the description of LINENO consistent with other variables as
regards how they relate to the User Portability Utilities option.
Austin Group Defect 1561 is applied, clarifying that shell variables are initialized only from environment
variables that have valid names.
C.2.6 Word Expansions
Some shells implement brace expansion which expands, for example, file{A,B,C}.c into the fields
fileA.c, fileB.c, and fileC.c or file{1..3}.c into the fields file1.c,
file2.c, and file3.c. This form of expansion is allowed but not required by this standard, but if supported must
be performed before all of the standard word expansions. A variant which some shells implement whereby brace expansion is performed
following field splitting was considered by the standard developers and rejected because it causes surprising behavior if the
results of parameter expansion and command substitution happen to produce a valid brace expansion. For example, if the shell
variable patt contains an arbitrary pathname, glob pattern applications cannot rely on some_command -- $patt
passing a list of pathnames that match the pattern to some_command. Note that quoting the braces or commas prevents this
form of expansion, but quoting the periods need not prevent it.
Step (2) refers to the "portions of fields generated by step (1)". For example, if the word being expanded were
"$x+$y" and IFS =+, the word would be split only if "$x" or "$y" contained '+'; the
'+' in the original word was not generated by step (1).
IFS is used for performing field splitting on the results of parameter and command substitution; it is not
used for splitting all fields. Earlier versions of the shell used it for splitting all fields during field splitting, but this has
severe problems because the shell can no longer parse its own script. There are also important security implications caused by this
behavior. All useful applications of IFS use it for parsing input of the read
utility and for splitting the results of parameter and command substitution.
The rule concerning expansion to a single field requires that if foo=abc and bar=def,
that:
"$foo""$bar"
expands to the single field:
abcdef
The rule concerning empty fields can be illustrated by:
$    unset foo
$    set $foo bar '' xyz "$foo" abc
$    for i
>    do
>        echo "-$i-"
>    done
-bar-
--
-xyz-
--
-abc-
Step (1) indicates that parameter expansion, command substitution, and arithmetic expansion are all processed
simultaneously as they are scanned. For example, the following is valid arithmetic:
x=1
echo $(( $(echo 3)+$x ))
An early proposal stated that tilde expansion preceded the other steps, but this is not the case in known
historical implementations; if it were, and if a referenced home directory contained a '$' character, expansions would
result within the directory name.
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0003 [49,430] is applied.
Austin Group Defect 249 is applied, adding the dollar-single-quotes quoting mechanism.
Austin Group Defect 985 is applied, clarifying that quote removal is not always performed.
Austin Group Defect 1038 is applied, clarifying that a '$' that is followed by a ,
, or a , or is not followed by any character, is treated as a literal character.
Austin Group Defect 1123 is applied, clarifying the environment in which expansions are performed and requirements
relating to empty fields.
Austin Group Defect 1193 is applied, adding optional brace expansion.
C.2.6.1 Tilde Expansion
Tilde expansion generally occurs only at the beginning of words, but an exception based on historical practice has
been included:
PATH=/posix/bin:~dgk/bin
This is eligible for tilde expansion because  follows a  and none of the relevant
characters is quoted. Consideration was given to prohibiting this behavior because any of the following are reasonable
substitutes:
PATH=$(printf %s ~karels/bin : ~bostic/bin)
for Dir in ~maart/bin ~srb/bin ...
do
PATH=${PATH:+$PATH:}$Dir
done
In the first command, explicit  characters are used for each directory. In all cases, the shell
performs tilde expansion on each directory because all are separate words to the shell.
Note that expressions in operands such as:
make -k mumble LIBDIR=~chet/lib
do not qualify as shell variable assignments, and tilde expansion is not performed (unless the command does so
itself, which make does not).
Because of the requirement that the word is not quoted, the following are not equivalent; only the last causes
tilde expansion:
\~hlj/   ~h\lj/   ~"hlj"/   ~hlj\/   ~hlj/
In an early proposal, tilde expansion occurred following any unquoted  or , but
this was removed because of its complexity and to avoid breaking commands such as:
rcp hostname:~marc/.profile .
System administrators on systems where // has an implementation-defined meaning which is different to
/, should not create users with a home directory of / or //, since this may lead to unexpected filename
resolution on those systems.
A suggestion was made that the special sequence "$~" should be allowed to force tilde expansion anywhere.
Since this is not historical practice, it has been left for future implementations to evaluate. (The description in XCU 2.2 Quoting requires that a  be quoted to represent itself,
so the "$~" combination is already unspecified.)
The results of giving  with an unknown login name are undefined because the KornShell "~+"
and "~-" constructs make use of this condition, but in general it is an error to give an incorrect login name with
. The results of having HOME unset are unspecified because some historical shells treat this as an error.
Historically, the Korn shell performed field splitting and pathname expansion on the results of tilde expansion,
and earlier versions of this standard reflected this. However, tilde expansion results in a pathname, and performing field
splitting and pathname expansion on something that is already a pathname is at best redundant and at worst will change the value
from the correct pathname to one or more incorrect ones. Later versions of the Korn shell do not perform these expansions and
POSIX.1-2024 has been updated to match. Note that although pathname expansion is not performed on the results of tilde expansion,
this does not prevent other parts of the same word from being expanded. For example, ~/a* expands to all files in $HOME
beginning with 'a'.
Austin Group Defect 1172 is applied, clarifying how quoting affects tilde expansion.
Austin Group Defect 1632 is applied, clarifying the treatment of  characters in tilde expansion.
C.2.6.2 Parameter Expansion
The rule for finding the closing '}' in "${...}" is the one used in the KornShell and is
upwardly-compatible with the Bourne shell, which does not determine the closing '}' until the word is expanded. The
advantage of this is that incomplete expansions, such as:
${foo
can be determined during tokenization, rather than during expansion.
Quote removal is performed when assigning the value in the ${parameter:=[word]} form of
expansion in order that a subsequent expansion of the same parameter produces the same value as the original expansion. That is,
the commands:
unset parameter
foo=${parameter:=word}
bar=${parameter}
assign the same value to foo and bar. A consequence of this is that the expansions
${parameter:=[word]} and ${parameter:-[word]} can produce different results
for the same word. For example, with parameter unset or empty:
${parameter:-a\ b}
expands to a single field "a b", whereas:
${parameter:=a\ b}
expands to two fields 'a' and 'b' (because parameter is assigned the value "a b"
before its value is substituted).
For rationale regarding expansion of "${...}" within double-quotes, see C.2.2.3
Double-Quotes.
The string length and substring capabilities were included because of the demonstrated need for them, based on
their usage in other shells, such as C shell and KornShell.
Historical versions of the KornShell have not performed tilde expansion on the word part of parameter expansion;
however, it is more consistent to do so.
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0004 [458], XCU/TC1-2008/0005 [458], XCU/TC1-2008/0006 [457],
XCU/TC1-2008/0007 [457], XCU/TC1-2008/0008 [417], XCU/TC1-2008/0009 [457], XCU/TC1-2008/0010 [457], XCU/TC1-2008/0011 [457],
XCU/TC1-2008/0012 [457], XCU/TC1-2008/0013 [457], XCU/TC1-2008/0014 [457], XCU/TC1-2008/0015 [457], XCU/TC1-2008/0016 [457],
XCU/TC1-2008/0017 [457], and XCU/TC1-2008/0018 [458] are applied.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0013 [888] and XCU/TC2-2008/0014 [867] are applied.
Austin Group Defect 221 is applied, removing a statement about counting brace levels and clarifying that quote
removal is performed when expanding word in ${parameter:=[word]}.
Austin Group Defect 985 is applied, clarifying when quote removal is performed.
Austin Group Defect 1052 is applied, clarifying the description of string length expansion.
Austin Group Defect 1268 is applied, removing text relating to parameter expansion inside double-quotes.
Austin Group Defect 1478 is applied, making explicitly unspecified the results of parameter expansions that test
whether the parameter '*' or '@' is unset or null.
Austin Group Defect 1491 is applied, restructuring a paragraph that used "Otherwise" after two conditions.
Austin Group Defect 1561 is applied, clarifying that the varieties of parameter expansion that provide for
substring processing process parameter values as characters.
C.2.6.3 Command Substitution
The "$()" form of command substitution solves a problem of inconsistent behavior when using backquotes.
For example:
Command
Output
echo '\$x'
\$x
echo `echo '\$x'`
$x
echo $(echo '\$x')
\$x
Additionally, the backquoted syntax has historical restrictions on the contents of the embedded command. While the
newer "$()" form can process any kind of valid embedded script (with a few caveats; see below), the backquoted form cannot
handle some valid scripts that include backquotes. For example, these otherwise valid embedded scripts do not work in the left
column, but do work on the right:
echo `                         echo $(
cat  characters deleted.
was omitted from the Shell and Utilities volume of POSIX.1-2024 because $(cat word) is an appropriate substitute. However, to prevent breaking numerous scripts
relying on this feature, it is unspecified to have a script within "$()" that has only redirections.
In IEEE Std 1003.2-1992 the $(commands) form of command substitution only had unspecified behavior
for a commands string consisting solely of redirections. However, two additional unspecified cases have since been added
with relation to aliases:
Implementations are permitted to parse the entire commands string before executing any of it, and in this
case alias and unalias commands in
commands have no effect during parsing. For example, the following commands:
alias foo='echo "hello globe"'
echo $(alias foo='echo "Hello World"';foo)
produce the output "hello globe" if the commands string is executed as an entire command and
produce the output "Hello World" if the commands string is executed incrementally.
Although existing aliases are required to be expanded when the shell parses the input that follows the
"$(" in order to find the terminating ')' (see 2.3 Token
Recognition), it is unspecified whether the terminating ')' can result from alias substitution. For example, with
this script:
alias foo="echo foo )"
echo $(foo ; echo bar
some shells output lines containing "foo" and "bar" whereas other shells report a syntax error
because they do not find a terminating ')' for the command substitution.
Arithmetic expansions have precedence over command substitutions. That is, if the shell can parse an expansion
beginning with "$((" as an arithmetic expansion then it will do so. It will only parse the expansion as a command
substitution (that starts with a subshell) if it determines that it cannot parse the expansion as an arithmetic expansion. If the
syntax is valid for neither type of expansion, then it is unspecified what kind of syntax error the shell reports.
How well the shell performs this determination is a quality of implementation issue. Current shell implementations
use heuristics. In particular, the shell need not evaluate nested expansions when determining whether it can parse an expansion
beginning with "$((" as an arithmetic expansion. For example:
$((a $op b))
is always an arithmetic expansion if "$op" expands to, say, '+', but if "$op" expands to
'(' then the shell might still parse the expansion as an arithmetic expansion (resulting in a syntax error due to
unbalanced parentheses) or it might perform a command substitution.
This standard requires that conforming applications always separate the "$(" and '(' with white
space when a command substitution starts with a subshell. This is because implementations may support extensions in arithmetic
expressions which could result in the shell parsing the input as an arithmetic expansion even though a minimally conforming shell
would not. For example, many shells support arrays with the array index (which can be an expression) in square brackets. Therefore,
the presence of "myfile[0-9]" within an expansion beginning "$((" is no guarantee that it will be parsed as a
command substitution.
The ambiguity is not restricted to the simple case of a single subshell. More complicated ambiguous cases are
possible (even with just the standard shell syntax), such as:
$(( cat  when a backquoted command
substitution is within double-quotes.
Austin Group Defect 1268 is applied, removing text relating to command substitution inside double-quotes.
Austin Group Defect 1342 is applied, clarifying the requirements for alias substitutions inside command
substitutions.
Austin Group Defect 1560 is applied, clarifying that the standard output of the command(s) in a command
substitution is treated as a sequence of bytes.
C.2.6.4 Arithmetic Expansion
The standard developers agreed that there was a strong desire for some kind of arithmetic evaluator to provide
functionality similar to expr, that relating it to '$' makes it work well with
the standard shell language and provides access to arithmetic evaluation in places where accessing a utility would be
inconvenient.
The syntax and semantics for arithmetic were revised for the ISO/IEC 9945-2:1993 standard. The language
represents a simple subset of the previous arithmetic language (which was derived from the KornShell "(())" construct).
The syntax was changed from that of a command denoted by ((expression)) to an expansion denoted by $((expression)).
The new form is a dollar expansion ('$') that evaluates the expression and substitutes the resulting value. Objections to
the previous style of arithmetic included that it was too complicated, did not fit in well with the use of variables in the shell,
and its syntax conflicted with subshells. The justification for the new syntax is that the shell is traditionally a macro language,
and if a new feature is to be added, it should be accomplished by extending the capabilities presented by the current model of the
shell, rather than by inventing a new one outside the model; adding a new dollar expansion was perceived to be the most intuitive
and least destructive way to add such a new capability.
The standard requires assignment operators to be supported (as listed in XCU 1.1.2 Concepts Derived from the ISO C Standard), and since arithmetic
expansions are not specified to be evaluated in a subshell environment, changes to variables there have to be in effect after the
arithmetic expansion, just as in the parameter expansion "${x=value}".
Note, however, that "$(( x=5 ))" need not be equivalent to "$(( $x=5 ))". If
the value of the environment variable x is the string "y=", the expansion of "$(( x=5 ))" would
set x to 5 and output 5, but "$(( $x=5 ))" would output 0 if the value of the environment variable
y is not 5 and would output 1 if the environment variable y is 5. Similarly, if the value of the environment variable
is 4, the expansion of "$(( x=5 ))" would still set x to 5 and output 5, but
"$(( $x=5 ))" (which would be equivalent to "$(( 4=5 ))") would yield a syntax error.
In early proposals, a form $[expression] was used. It was functionally equivalent to the "$(())" of
the current text, but objections were lodged that the 1988 KornShell had already implemented "$(())" and there was no
compelling reason to invent yet another syntax. Furthermore, the "$[]" syntax had a minor incompatibility involving the
patterns in case statements.
The portion of the ISO C standard arithmetic operations selected corresponds to the operations historically
supported in the KornShell. In addition to the exceptions listed in XCU 2.6.4
Arithmetic Expansion, the use of the following are explicitly outside the scope of the rules defined in XCU 1.1.2.1 Arithmetic Precision and Operations:
The prefix operator '&' and the "[]", "->", and '.' operators.
Casts
It was concluded that the test command ([) was sufficient for
the majority of relational arithmetic tests, and that tests involving complicated relational expressions within the shell are rare,
yet could still be accommodated by testing the value of "$(())" itself. For example:
# a complicated relational expression
while [ $(( (($x + $y)/($a * $b))  5 && $y  and single-quote
characters (needed to specify character constants) within an arithmetic expansion were ambiguous. Furthermore, no known shells
supported them. Changes made in response to IEEE PASC Interpretation 1003.2 #208 removed the requirement to support them (if they
were indeed required before). POSIX.1-2024 clearly does not require support for character constants.
IEEE Std 1003.1-2001/Cor 2-2004, item XCU/TC2/D6/3 is applied, clarifying arithmetic
expressions.
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0020 [50] is applied.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0015 [584] is applied.
C.2.6.5 Field Splitting
The operation of field splitting using IFS , as described in early proposals, was based on the way the
KornShell splits words, but it is incompatible with other common versions of the shell. However, each has merit, and so a decision
was made to allow both. If the IFS variable is unset or is , the operation is
equivalent to the way the System V shell splits words. Using characters outside the
set yields the KornShell behavior, where each of the non-s is significant. This behavior,
which affords the most flexibility, was taken from the way the original awk handled
field splitting.
The different handling of white space and non-white-space characters in IFS can be summarized as a
pseudo-ERE:
(s*ns*|s+)
where s is an IFS white-space character and n is a character in the IFS that is not
white space. Any string matching that ERE delimits a field, except that the s+ form does not delimit fields at the beginning
or the end of a line. For example, if IFS is //, the string:
red,whiteblue
yields the three colors as the delimited fields.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0016 [832] is applied.
Austin Group Defect 1123 is applied, clarifying the requirements if no fields are delimited.
Austin Group Defect 1560 is applied, clarifying that the results of word expansions are treated as a sequences of
bytes when searching for (bytes that form) IFS characters.
Austin Group Defect 1649 is applied, clarifying how field splitting is performed.
C.2.6.6 Pathname Expansion
There is no additional rationale provided for this section.
C.2.6.7 Quote Removal
The golden rule in quote removal is that if a quote character was treated as special in the original word, it is
removed; if it was treated as a literal character, it is not removed.
Austin Group Defect 221 is applied, clarifying the conditions under which quote characters are, or are not,
removed.
Austin Group Defect 249 is applied, adding the dollar-single-quotes quoting mechanism.
C.2.7 Redirection
In the System Interfaces volume of POSIX.1-2024, file descriptors are integers in the range 0-({OPEN_MAX}-1). The
file descriptors discussed in XCU 2.7 Redirection are that same set of
small integers.
Having multi-digit file descriptor numbers for I/O redirection can cause some obscure compatibility problems.
Specifically, scripts that depend on an example command:
echo 22>/dev/null
echoing "2" to standard error or "22" to standard output are no longer portable. However, the
file descriptor number must still be delimited from the preceding text. For example:
cat file2>foo
writes the contents of file2, not the contents of file.
The limitation to 9 file descriptors is overcome in some shells via a form of redirection whereby a shell variable
stores the file descriptor number. For example:
exec {fdvar}> foo
opens the file foo on a file descriptor greater than 9 and stores the file descriptor number in shell
variable fdvar. (This can later be closed using exec {fdvar}>&-.) This form of redirection is allowed but
not required by this standard.
The ">|" format of output redirection was adopted from the KornShell. Along with the noclobber
option, set -C, it provides a safety feature to prevent inadvertent
overwriting of existing files. (See the RATIONALE for the pathchk utility for why
this step was taken.) The restriction on regular files is historical practice.
The System V shell and the KornShell have differed historically on pathname expansion of word; the
former never performed it, the latter only when the result was a single field (file). As a compromise, it was decided that the
KornShell functionality was useful, but only as a shorthand device for interactive users. No reasonable shell script would be
written with a command such as:
cat foo > a*
Thus, shell scripts are prohibited from doing it, while interactive users can select the shell with which they are
most comfortable.
The construct "2>&1" is often used to redirect standard error to the same file as standard output.
Since the redirections take place beginning to end, the order of redirections is significant. For example:
ls > foo 2>&1
directs both standard output and standard error to file foo. However:
ls 2>&1 > foo
only directs standard output to file foo because standard error was duplicated as standard output before
standard output was directed to file foo.
Applications should not use the [n]&- operators to execute a utility or application with file descriptor 0 not open for
reading or with file descriptor 1 or 2 not open for writing, as this might cause the executed program (or shell built-in) to
misbehave. In order not to pass on these file descriptors to an executed utility or application, applications should not just close
them but should reopen them on, for example, /dev/null. Some implementations may reopen them automatically, but applications
should not rely on this being done.
The "<>" operator could be useful in writing an application that worked with several terminals, and
occasionally wanted to start up a shell. That shell would in turn be unable to run applications that run from an ordinary
controlling terminal unless it could make use of "<>" redirection. The specific example is a historical version of
the pager more, which reads from standard error to get its commands, so standard input
and standard output are both available for their usual usage. There is no way of saying the following in the shell without
"<>":
cat food | more - >/dev/tty03 2<>/dev/tty03
Another example of "<>" is one that opens /dev/tty on file descriptor 3 for reading and
writing:
exec 3<> /dev/tty
An example of creating a lock file for a critical code region:
set -C
until    2> /dev/null > lockfile
do       sleep 30
done
set +C
perform critical function
rm lockfile
Since /dev/null is not a regular file, no error is generated by redirecting to it in noclobber
mode.
Tilde expansion is not performed on a here-document because the data is treated as if it were enclosed in
double-quotes.
Austin Group Defect 1193 is applied, adding the optional redirection form
{location}redir-op word.
Austin Group Defect 1232 is applied, clarifying the allowed behaviors in an interactive shell when pathname
expansion on the word following a redirection operator would result in more than one word.
Austin Group Defect 1493 is applied, moving some information from this section to the definition of "file
descriptor" in XBD 3.141 File Descriptor.
C.2.7.1 Redirecting Input
There is no additional rationale provided for this section.
C.2.7.2 Redirecting Output
Earlier versions of this standard did not require redirection using '>' when noclobber is set to
perform the file creation step as an atomic operation. Historical shells just called stat() to check if a regular file existed and then called creat(). The operation thus involved a race condition which meant that it could not be used
for reliable creation of lock files. Many shell implementations improved on this by using open() with the O_CREAT and O_EXCL flags set as one step in a multi-step process which still
meant that an existing non-regular file (for example /dev/null, /dev/tty, or a FIFO) was opened successfully.
However, the methods employed still involved a race condition and could produce misleading diagnostics if there is concurrent
creation or removal of files.
An ideal solution would be an O_NOCLOBBER flag for open() which the
shell could use in order to perform the entire operation atomically, and implementations are encouraged to adopt this solution,
adding the flag as described in the FUTURE DIRECTIONS section of open(), and using it
in the implementation's POSIX shell and in other shells. Authors of portable shells should make use of #ifdef O_NOCLOBBER
so that it is used on implementations that provide it.
If O_NOCLOBBER is not used, shells can use one of the following methods:
The "stat first" method.
Call stat() and if the file exists and is a regular file, the
redirection fails. Otherwise:
Call open() without O_CREAT or O_TRUNC to open an existing file. If
the open succeeds, use fstat() to check whether the opened file is a regular file. If
it is, close it and fail the redirection. If it is a non-regular file, the redirection succeeds. Otherwise:
Call open() with O_CREAT|O_EXCL. The redirection succeeds or fails
depending on whether the open succeeds or fails.
The "exclusive create first" method.
Call open() with O_CREAT|O_EXCL. If the open succeeds, the redirection
succeeds. If the open fails with [EMFILE] or [ENFILE], use stat() to check whether a
regular file exists; if it does, fail the redirection. Otherwise:
Call open() without O_CREAT or O_TRUNC to open an existing file. If
the open succeeds, use fstat() to check whether the opened file is a regular file. If
it is, close it and fail the redirection. If it is a non-regular file, the redirection succeeds. If the second open fails, the
redirection fails with a diagnostic based on the errno value set by the first open.
(A minor variation of this method could also be used whereby step 2.b is only done if the open() in step 2.a fails with [EEXIST].)
Method 1 is in widespread use. Method 2 has not been observed exactly as described, although an implementation
which omits the stat() in step 2.a has been observed. Without the stat(), this method has a problem in that if a regular file exists but the open() fails with [EMFILE] or [ENFILE] instead of [EEXIST] (which is to be expected if those
conditions exist, because detecting [EEXIST] is more expensive), then the shell will give an incorrect diagnostic. (Reporting that
no file descriptors are available implies that a non-regular file exists, because the shell tried to open the file and it is not
supposed to open an existing regular file.)
A variant of method 1 which omits the initial stat() call has also been
observed; this has the same problem with [EMFILE] and [ENFILE]. With the stat(), this
misleading diagnostic can also happen, but only if a regular file is created in the timing window between steps 1.a and 1.b, which
makes it an allowed case. (The standard allows a misleading diagnostic when there is concurrent creation or removal of files.)
Both methods have cases where a misleading diagnostic is given when a non-regular file is concurrently created or
removed. With method 1 it occurs if no file exists at steps 1.a and 1.b, and a non-regular file is created before step 1.c. With
method 2 it occurs if a non-regular file exists at step 2.a and is removed before step 2.b. (In both cases, the diagnostic
misleadingly implies that a regular file exists).
Both methods differ from historical shell behavior in that the redirection fails if there is an existing symbolic
link whose target does not exist, instead of the link's target being created as a regular file. The standard developers consider
reliable lock file creation to be more important than the creation of symbolic link targets.
Creation of lock files and unique (often temporary) files with noclobber set is only reliable provided
neither non-regular files nor symbolic links to non-regular files exist or are created in the same directory with the same names,
and no other processes delete the files while still in use. If a directory such as /tmp is used for lock files, then another
process could accidentally or maliciously create a FIFO (or a special file, given sufficient privilege) with the same name, causing
multiple processes to simultaneously open the same lock file instead of one succeeding and the others failing.
Austin Group Defects 1016 and 1364 are applied, changing the requirements when the noclobber option is
set.
C.2.7.3 Appending Redirected Output
Note that when a file is opened (even with the O_APPEND flag set), the initial file offset for that file is set to
the beginning of the file. Some historic shells set the file offset to the current end-of-file when append mode shell
redirection was used, but this is not allowed by POSIX.1-2024.
Austin Group Defect 1016 is applied, changing "with the O_APPEND flag" to "with the O_APPEND flag set".
C.2.7.4 Here-Document
Historical shell behavior was to treat the end of input as being equivalent to the delimiter of a here-document,
terminating the here-document, usually without any indication, and continuing as if the delimiter had been recognized. This can
cause problems where the delimiter had been intended to occur much earlier in the script, but was incorrectly entered—a mistake
which for many other errors would have resulted in a syntax error, and an aborted script, instead simply generates incorrect
results. Because of this some shell implementations have changed to reporting an undelimited here-document as a syntax error. Other
implementations are encouraged to do the same.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0017 [890], XCU/TC2-2008/0018 [583], and XCU/TC2-2008/0019
[580] are applied.
Austin Group Defect 1036 is applied, clarifying how here-documents are parsed.
Austin Group Defect 1411 is applied, adding a paragraph break.
C.2.7.5 Duplicating an Input File Descriptor
The file descriptor duplication redirection operators, [n]&word, make a copy of one file descriptor as another. If the operation is successful,
the new file descriptor has the same access mode as the source (old) file descriptor, because the access mode is determined by the
open file description to which both file descriptors point. To avoid a redirection error, applications need to ensure that they use
the appropriate redirection operator for the access mode of the file descriptor being duplicated.
Austin Group Defect 1536 is applied, making it optional whether attempting to duplicate an open file descriptor
that is not open for input results in a redirection error.
C.2.7.6 Duplicating an Output File Descriptor
See C.2.7.5 Duplicating an Input File Descriptor.
Austin Group Defect 1536 is applied, making it optional whether attempting to duplicate an open file descriptor
that is not open for output results in a redirection error.
C.2.7.7 Open File Descriptors for Reading and Writing
There is no additional rationale provided for this section.
C.2.8 Exit Status and Errors
There is no additional rationale provided for this section.
C.2.8.1 Consequences of Shell Errors
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0020 [882] and XCU/TC2-2008/0021 [717,882] are applied.
Austin Group Defect 914 is applied, requiring that the shell does not exit when a redirection error occurs with
compound commands or with function execution.
Austin Group Defect 1427 is applied, changing this section to account for the effect of the command utility when it is used to execute a special built-in utility.
Austin Group Defect 1629 is applied, requiring that the shell exits if an unrecoverable read error occurs when
reading commands.
C.2.8.2 Exit Status for Commands
There is a historical difference in sh and ksh non-interactive
error behavior. When a command named in a script is not found, some implementations of sh
exit immediately, but ksh continues with the next command. Thus, the Shell and Utilities volume of POSIX.1-2024 says that
the shell "may" exit in this case. This puts a small burden on the programmer, who has to test for successful completion
following a command if it is important that the next command not be executed if the previous command was not found. If it is
important for the command to have been found, it was probably also important for it to complete successfully. The test for
successful completion would not need to change.
Historically, shells have returned an exit status of 128+n, where n represents the signal number.
Since signal numbers are not standardized, there is no portable way to determine which signal caused the termination. Also, it is
possible for a command to exit with a status in the same range of numbers that the shell would use to report that the command was
terminated by a signal. Implementations are encouraged to choose exit values greater than 256 to indicate programs that terminate
by a signal so that the exit status cannot be confused with an exit status generated by a normal termination. However, the use of
exit values greater than 256 poses a problem for the shell's own exit status. Historically this was the exit status of the last
command invoked by the shell, but if the last command was terminated by a signal and was assigned an exit status greater than 256
by the shell, this value would be truncated to eight bits in the shell's exit status. Likewise truncation would occur with use
of
exit $?
or
ret=$?
....
exit $ret
in shell scripts. To avoid this truncation, shells which assign exit statuses greater than 256 are required to
propagate the wait status of the last command to the shell's own wait status (by sending itself the same signal), and to handle
exit values greater than 256 passed to the exit builtin by mimicking the wait status
that would give rise to assignment of that exit status in the shell. Note that this requirement does not apply to signals that do
not cause termination, such as SIGCHLD, since the shell can never actually assign a corresponding exit status greater than 256, and
the requirement is worded in terms of this assignment.
Historical shells make the distinction between "utility not found" and "utility found but cannot execute" in
their error messages. By specifying two seldomly used exit status values for these cases, 127 and 126 respectively, this gives an
application the opportunity to make use of this distinction without having to parse an error message that would probably change
from locale to locale. The command, env,
nohup, and xargs utilities in the Shell
and Utilities volume of POSIX.1-2024 have also been specified to use this convention.
When a command fails during word expansion or redirection, most historical implementations exit with a status of 1.
However, there was some sentiment that this value should probably be much higher so that an application could distinguish this case
from the more normal exit status values. Thus, the language "greater than zero" was selected to allow either method to be
implemented.
If a C application calls exit(256), the command's exit status in the shell becomes zero due to the modulo
256 operation. Since zero is interpreted as "true" or "success" for if statements, AND and OR lists, set -e,
and so on, applications should be careful to avoid exiting with a value that is a multiple of 256 unless the value is intended to
be interpreted as true or success.
To avoid ambiguity caused by the modulo 256 operation, applications are encouraged to avoid using a count or the
result of a computation as the exit value unless the value is guaranteed to be non-negative and less than 256.
The ambiguity caused by the modulo 256 operation is unfortunate, but required due to historical implementation
behavior. A future version of this standard may change the definition of exit status to remove the modulo 256 requirement and use
all bits of the value passed to exit() (or equivalent), and may introduce a way to
select whether the special parameter '?' contains the exit status modulo 256 or the full exit status.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0022 [717] is applied.
Austin Group Defect 51 is applied, clarifying the exit status when a command is terminated due to the receipt of a
signal.
Austin Group Defect 947 is applied, clarifying the exit status of commands.
C.2.9 Shell Commands
A description of an "empty command" was removed from an early proposal because it is only relevant in the cases
of sh -c "", system(""), or an empty shell-script file
(such as the implementation of true on some historical systems). Since it is no longer
mentioned in the Shell and Utilities volume of POSIX.1-2024, it falls into the silently unspecified category of behavior where
implementations can continue to operate as they have historically, but conforming applications do not construct empty commands.
(However, note that sh does explicitly state an exit status for an empty string or file.)
In an interactive session or a script with other commands, extra  or  characters, such as:
$ false
$
$ echo $?
1
would not qualify as the empty command described here because they would be consumed by other parts of the
grammar.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0023 [473] is applied.
C.2.9.1 Simple Commands
Austin Group Defect 1224 is applied, correcting a mismatch between the description of simple commands and the
formal simple_command grammar.
Austin Group Defect 1227 is applied, inserting additional subsection headings.
Order of Processing
The enumerated list is used only when the command is actually going to be executed. For example, in:
true || $foo *
no expansions are performed.
Expansion of words in an assignment context following the command name can only occur for declaration utilities,
and only when the word can be used as a variable assignment in isolation.
For example, this code sequence exports the single variable a with the value "1 b=2", but invokes
make with the macro a set to '1' and b set to '2',
since make is not a declaration utility:
set '1 b=2'
export a=$1
make a=$1
Conversely, this code sequence exports two variables, a set to '1' and b set to
'2', because the use of quoting means that the word could not be recognized as a variable assignment, and regular
expansion rules require that field splitting occurs on the unquoted expansion of $1:
set '1 b=2'
export \a=$1
Likewise, this code sequence will not be parsed in assignment context, but is still required to export the variable
named foo with the value '1':
var=foo
export $var=1
Implementations are permitted to provide extensions that serve as declaration utilities, such as typeset or
local, or even a way to define a function that can behave as a declaration utility.
Declaration utilities are only required to be recognized via lexical analysis; if any expansions are required
before the command name is known, or before the first argument to the command
utility is known, then it is unspecified whether subsequent arguments will be treated with an assignment context during expansion.
For example, it is unspecified whether
var=export; $var a=~
sets the variable a to a literal  or to the value of $HOME, since lexical analysis
sees "$var" rather than "export" as the command name.
Austin Group Defects 351 and 1535 are applied, adding requirements relating to declaration utilities.
Variable Assignments
The following example illustrates both how a variable assignment without a command name affects the current
execution environment, and how an assignment with a command name only affects the execution environment of the command:
$ x=red
$ echo $x
red
$ export x
$ sh -c 'echo $x'
red
$ x=blue sh -c 'echo $x'
blue
$ echo $x
red
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0021 [255] is applied.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0024 [654] is applied.
Austin Group Defect 1009 is applied, clarifying the behavior when a special built-in utility is executed with a
variable assignment.
Commands with no Command Name
This next example illustrates that redirections without a command name are still performed:
$ ls foo
ls: foo: no such file or directory
$ > foo
$ ls foo
foo
A command without a command name, but one that includes a command substitution, has an exit status of the last
command substitution that the shell performed. For example:
if      x=$(command)
then    ...
fi
An example of redirections without a command name being performed in a subshell shows that the here-document does
not disrupt the standard input of the while loop:
IFS=:
while    read a b
do       echo $a
foo || {
echo "error: foo cannot be created" >&2
exit 1
}
# set saved if /vmunix.save exists
test -f /vmunix.save && saved=1
Command substitution and redirections without command names both occur in subshells, but they are not necessarily
the same ones. For example, in:
exec 3> file
var=$(echo foo >&3) 3>&1
it is unspecified whether foo is echoed to the file or to standard output.
Austin Group Defect 1150 is applied, clarifying the exit status of a command that has no command name and has more
than one command substitution.
Command Search and Execution
This description requires that the shell can execute shell scripts directly, even if the underlying system does not
support the common "#!" interpreter convention. That is, if file foo contains shell commands and is executable, the
following executes foo:
./foo
The command search shown here does not match all historical implementations. A more typical sequence has been:
Any built-in (special or regular)
Functions
Path search for executable files
But there are problems with this sequence. Since the programmer has no idea in advance which utilities might have
been built into the shell, a function cannot be used to override portably a utility of the same name. (For example, a function
named cd cannot be written for many historical systems.) Furthermore, the PATH
variable is partially ineffective in this case, and only a pathname with a  can be used to ensure a specific
executable file is invoked.
After the execve() failure described, the shell normally executes the
file as a shell script. Some implementations, however, attempt to detect whether the file is actually a script and not an
executable from some other architecture. The method used by the KornShell is allowed by the text that indicates non-text files may
be bypassed.
The sequence selected for the Shell and Utilities volume of POSIX.1-2024 acknowledges that special built-ins cannot
be overridden, but gives the programmer full control over which versions of other utilities are executed (with some exceptions). It
provides a means of suppressing function lookup (via the command utility) for the
user's own functions and, with the exception of the intrinsic utilities (see XCU 1.7 Intrinsic Utilities), ensures that any regular built-ins or functions
provided by the implementation are under the control of the path search. The mechanisms for associating non-intrinsic built-ins or
functions with executable files in the path are not specified by the Shell and Utilities volume of POSIX.1-2024, but the wording
requires that if either is implemented, the application is not able to distinguish a function or built-in from an executable (other
than in terms of performance, presumably). The implementation ensures that all effects specified by the Shell and Utilities volume
of POSIX.1-2024 resulting from the invocation of the regular built-in or function (interaction with the environment, variables,
traps, and so on) are identical to those resulting from the invocation of an executable file.
Various historical implementations have used the names in item 1.b. as built-ins or reserved words. This standard
does not specify their behavior, but their existence means that it is important for portable applications to avoid giving functions
(or utilities in PATH ) those names because the function (or utility in PATH ) might not be executed as expected.
IEEE Std 1003.1-2001/Cor 2-2004, item XCU/TC2/D6/4 is applied, updating the case where execve() fails due to an error equivalent to the [ENOEXEC] error.
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0022 [168], XCU/TC1-2008/0023 [168], XCU/TC1-2008/0024 [168],
XCU/TC1-2008/0025 [168], XCU/TC1-2008/0026 [168,430], XCU/TC1-2008/0027 [168,430], and XCU/TC1-2008/0028 [173] are applied.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0025 [935] and XCU/TC2-2008/0026 [705] are applied.
Austin Group Defect 465 is applied, adding compound, enum, float, integer, and
nameref to the table of command names for which the results are unspecified.
Austin Group Defect 854 is applied, adding intrinsic utilities.
Austin Group Defect 1391 is applied, clarifying the execution of a standard utility provided by the implementation
in the form of a function.
Standard File Descriptors
There is no additional rationale provided for this section.
Non-built-in Utility Execution
Austin Group Defect 1157 is applied, clarifying the execution of non-built-in utilities.
Austin Group Defects 1226 and 1435 are applied, clarifying the circumstances under which the shell may bypass
execution of a non-built-in utility as a shell script.
Examples
Consider three versions of the ls utility:
The application includes a shell function named ls.
The user writes a utility named ls and puts it in /fred/bin.
The example implementation provides ls as a regular shell built-in that
is invoked (either by the shell or directly by exec) when the path search reaches the directory /posix/bin.
If PATH =/posix/bin, various invocations yield different versions of ls:
Invocation
Version of ls
ls (from within application script)
(1) function
command ls (from within application script)
(3) built-in
ls (from within makefile called by application)
(3) built-in
system("ls")
(3) built-in
PATH="/fred/bin:$PATH" ls
(2) user's version
C.2.9.2 Pipelines
Because pipeline assignment of standard input or standard output or both takes place before redirection, it can be
modified by redirection. For example:
$ command1 2>&1 | command2
sends both the standard output and standard error of command1 to the standard input of command2.
The reserved word ! allows more flexible testing using AND and OR lists. The behavior of !( is
unspecified because in the Korn Shell this introduces a negated pathname expansion. Portable applications need to separate the
! and ( to ensure the command is treated as a negated subshell.
It was suggested that it would be better to return a non-zero value if any command in the pipeline terminates with
non-zero status (perhaps the bitwise-inclusive OR of all return values). However, the choice of the last-specified command
semantics are historical practice and would cause applications to break if changed. An example of historical behavior:
$ sleep 5 | (exit 4)
$ echo $?
4
$ (exit 4) | sleep 5
$ echo $?
0
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0029 [205] is applied.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0027 [521] is applied.
Exit Status
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0030 [52] is applied.
Austin Group Defect 789 is applied, adding the pipefail option.
C.2.9.3 Lists
The equal precedence of "&&" and "||" is historical practice. The standard developers
evaluated the model used more frequently in high-level programming languages, such as C, to allow the shell logical operators to be
used for complex expressions in an unambiguous way, but they could not allow historical scripts to break in the subtle way unequal
precedence might cause. Some arguments were posed concerning the "{}" or "()" groupings that are required
historically. There are some disadvantages to these groupings:
The "()" can be expensive, as they spawn other processes on some implementations. This performance
concern is primarily an implementation issue.
The "{}" braces are not operators (they are reserved words) and require a trailing  after
each '{', and a  before each '}'. Most programmers (and certainly interactive users) have
avoided braces as grouping constructs because of the problematic syntax required. Braces were not changed to operators because that
would generate compatibility issues even greater than the precedence question; braces appear outside the context of a keyword in
many shell scripts.
IEEE PASC Interpretation 1003.2 #204 is applied, clarifying that the operators "&&" and
"||" are evaluated with left associativity.
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0031 [45] and XCU/TC1-2008/0032 [45] are applied.
Asynchronous AND-OR Lists
Unless the implementation has an internal limit, such as {CHILD_MAX}, on the retained process IDs, it would require
unbounded memory for the following example:
while true
do      foo & echo $!
done
The treatment of the signals SIGINT and SIGQUIT with asynchronous AND-OR lists is described in XCU 2.12 Signals and Error Handling.
Since the connection of the input to the equivalent of /dev/null is considered to occur before redirections,
the following script would produce no output:
exec  is frequently used.
A proposal was made to use the  construct in all cases where command grouping in the current
process environment is performed, identifying it as a construct for the grouping commands, as well as for shell functions. This was
not included because the shell already has a grouping construct for this purpose ("{}"), and changing it would have been
counter-productive.
The requirement for conforming applications to separate two leading '(' characters with white space if a
grouping command would be parsed as an arithmetic expansion if preceded by a '$' is to allow shells which implement the
"(( arithmetic expression ))" extension to apply the same disambiguation rules consistently to $((...)) and
((...)). See C.2.6.3 Command Substitution.
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0033 [217] is applied.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0029 [473] is applied.
For Loop
The format is shown with generous usage of  characters. See the grammar in XCU 2.10 Shell Grammar for a precise description of where  and
characters can be interchanged.
Some historical implementations support '{' and '}' as substitutes for do and done.
The standard developers chose to omit them, even as an obsolescent feature. (Note that these substitutes were only for the
for command; the while and until commands could not use them historically because they are followed by
compound-lists that may contain "{...}" grouping commands themselves.)
The reserved word pair do ... done was selected rather than do ... od (which would have
matched the spirit of if ... fi and case ... esac) because od
is already the name of a standard utility.
PASC Interpretation 1003.2 #169 has been applied changing the grammar.
Case Conditional Construct
An optional  before pattern was added to allow numerous historical KornShell scripts
to conform. At one time, using the leading parenthesis was required if the case statement was to be embedded within a
"$()" command substitution; this is no longer the case with the POSIX shell. Nevertheless, many historical scripts use the
, if only because it makes matching-parenthesis searching easier in vi and other editors. This is a relatively simple implementation change that is
upwards-compatible for all scripts.
Consideration was given to requiring break inside the
compound-list to prevent falling through to the next pattern action list. This was rejected as being nonexisting practice.
Instead, the standard now requires a feature first added in KornShell that using ";&" instead of ";;" as a
terminator causes the exact opposite behavior—the flow of control continues with the next compound-list.
Although the standard is explicit that the order of side-effects due to pattern expansion within a single clause is
unspecified, it is clear that patterns are expanded in clause order, and that no further pattern expansions are attempted after the
first match. That is, the following example is required to output "1.0":
x=0 y=1
case 1 in
$((y=0)) ) ;;
$((x=1)) ) ;&
$((x=2)) ) echo $x.$y ;;
esac
Some implementations of the shell also allow ";;&" as a terminator which falls through to the next
matching pattern (regardless of the choice of terminator in any intermediate non-matching clauses), in contrast to
";&" falling through to the next clause (regardless of the pattern guarding that clause). This is an allowed
extension, but is not required by the standard at this time.
The pattern '*', given as the last pattern in a case construct, is equivalent to the default case
in a C-language switch statement.
The grammar shows that reserved words can be used as patterns, even if one is the first word on a line. Obviously,
the reserved word esac cannot be used in this manner.
Some historical shells would fall back to doing a byte to byte comparison with each pattern if the pattern matching
rules did not produce a match. That behavior is not allowed by this standard because it allows user input to bypass input
validations like:
case $1 in
[0123456789]) : OK;;
*) echo >&2 not a decimal digit; exit 1;;
esac
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0029 [473] is applied.
Austin Group Defect 449 is applied, adding ;& as a case clause terminator.
Austin Group Defect 1454 is applied, clarifying that a case statement with no patterns is valid syntax.
If Conditional Construct
The precise format for the command syntax is described in XCU 2.10 Shell Grammar.
While Loop
The precise format for the command syntax is described in XCU 2.10 Shell Grammar.
Until Loop
The precise format for the command syntax is described in XCU 2.10 Shell Grammar.
C.2.9.5 Function Definition Command
The description of functions in an early proposal was based on the notion that functions should behave like
miniature shell scripts; that is, except for sharing variables, most elements of an execution environment should behave as if they
were a new execution environment, and changes to these should be local to the function. For example, traps and options should be
reset on entry to the function, and any changes to them do not affect the traps or options of the caller. There were numerous
objections to this basic idea, and the opponents asserted that functions were intended to be a convenient mechanism for grouping
common commands that were to be executed in the current execution environment, similar to the execution of the dot special built-in.
It was also pointed out that the functions described in that early proposal did not provide a local scope for
everything a new shell script would, such as the current working directory, or umask,
but instead provided a local scope for only a few select properties. The basic argument was that if a local scope is needed for the
execution environment, the mechanism already existed: the application can put the commands in a new shell script and call that
script. All historical shells that implemented functions, other than the KornShell, have implemented functions that operate in the
current execution environment. Because of this, traps and options have a global scope within a shell script. Local variables within
a function were considered and included in another early proposal (controlled by the special built-in local), but were
removed because they do not fit the simple model developed for functions and because there was some opposition to adding yet
another new special built-in that was not part of historical practice. Implementations should reserve the identifier local
(as well as typeset, as used in the KornShell) in case this local variable mechanism is adopted in a future version of this
standard.
A separate issue from the execution environment of a function is the availability of that function to child shells.
A few objectors maintained that just as a variable can be shared with child shells by exporting it, so should a function. In early
proposals, the export command therefore had a -f flag for exporting
functions. Functions that were exported were to be put into the environment as name()=value pairs, and upon
invocation, the shell would scan the environment for these and automatically define these functions. This facility was strongly
opposed and was omitted. Some of the arguments against exportable functions were as follows:
There was little historical practice. The Ninth Edition shell provided them, but there was controversy over how
well it worked.
There are numerous security problems associated with functions appearing in the environment of a user and
overriding standard utilities or the utilities owned by the application.
There was controversy over requiring make to import functions, where
it has historically used an exec function for many of its command line executions.
Functions can be big and the environment is of a limited size. (The counter-argument was that functions are no
different from variables in terms of size: there can be big ones, and there can be small ones—and just as one does not export huge
variables, one does not export huge functions. However, this might not apply to the average shell-function writer, who typically
writes much larger functions than variables.)
As far as can be determined, the functions in the Shell and Utilities volume of POSIX.1-2024 match those in
System V. Earlier versions of the KornShell had two methods of defining functions:
function fname { compound-list }
and:
fname() { compound-list }
The latter used the same definition as the Shell and Utilities volume of POSIX.1-2024, but differed in semantics,
as described previously. The current edition of the KornShell aligns the latter syntax with the Shell and Utilities volume of
POSIX.1-2024 and keeps the former as is.
Some shells accept simple commands (see XCU 2.9.1 Simple
Commands) after fname() in addition to compound commands (see XCU 2.9.4 Compound Commands); however this standard only requires support for
compound commands.
The name space for functions is limited to that of a name because of historical practice. Complications in
defining the syntactic rules for the function definition command and in dealing with known extensions such as the "@()"
usage in the KornShell prevented the name space from being widened to a word. Using functions to support synonyms such as
the "!!" and '%' usage in the C shell is thus disallowed to conforming applications, but acceptable as an
extension. For interactive users, the aliasing facilities in the Shell and Utilities volume of POSIX.1-2024 should be adequate for
this purpose. It is recognized that the name space for utilities in the file system is wider than that currently supported for
functions, if the portable filename character set guidelines are ignored, but it did not seem useful to mandate extensions in
systems for so little benefit to conforming applications.
The "()" in the function definition command consists of two operators. Therefore, intermixing
characters with the fname, '(', and ')' is allowed, but unnecessary.
An example of how a function definition can be used wherever a simple command is allowed:
# If variable i is equal to "yes",
# define function foo to be ls -l
#
[ "$i" = yes ] && foo() {
ls -l
}
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0034 [383] and XCU/TC1-2008/0035 [214] are applied.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0029 [473] and XCU/TC2-2008/0030 [654] are applied.
C.2.10 Shell Grammar
There are several subtle aspects of this grammar where conventional usage implies rules about the grammar that in
fact are not true.
For compound_list, only the forms that end in a separator allow a reserved word to be recognized, so
usually only a separator can be used where a compound list precedes a reserved word (such as Then, Else,
Do, and Rbrace). Explicitly requiring a separator would disallow such valid (if rare) statements as:
if (false) then (echo x) else (echo y) fi
See the Note under special grammar rule (1).
Concerning the third sentence of rule (1) ("Also, if the parser ..."):
This sentence applies rather narrowly: when a compound list is terminated by some clear delimiter (such as the
closing fi of an inner if_clause) then it would apply; where the compound list might continue (as in after a
';'), rule (7a) (and consequently the first sentence of rule (1)) would apply. In many instances the two conditions are
identical, but this part of rule (1) does not give license to treating a WORD as a reserved word unless it is in a place
where a reserved word has to appear.
The statement is equivalent to requiring that when the LR(1) lookahead set contains exactly one reserved word, it
must be recognized if it is present. (Here "LR(1)" refers to the theoretical concepts, not to any real parser generator.)
For example, in the construct below, and when the parser is at the point marked with '^', the only next
legal token is then (this follows directly from the grammar rules):
if if...fi then ... fi
^
At that point, the then must be recognized as a reserved word.
(Depending on the parser generator actually used, "extra" reserved words may be in some lookahead sets. It does
not really matter if they are recognized, or even if any possible reserved word is recognized in that state, because if it is
recognized and is not in the (theoretical) LR(1) lookahead set, an error is ultimately detected. In the example above, if some
other reserved word (for example, while) is also recognized, an error occurs later.
This is approximately equivalent to saying that reserved words are recognized after other reserved words (because
it is after a reserved word that this condition occurs), but avoids the "except for ..." list that would be required for
case, for, and so on. (Reserved words are of course recognized anywhere a simple_command can appear, as well.
Other rules take care of the special cases of non-recognition, such as rule (4) for case statements.)
Note that the body of here-documents are handled by token recognition (see XCU 2.3 Token Recognition) and do not appear in the grammar directly. (However, the
here-document I/O redirection operator is handled as part of the grammar.)
The optional redirection syntax:
{location}redir-op word
(see XCU 2.7 Redirection) is accommodated in the
grammar rules by the optional IO_LOCATION token identifier and two correspondingly optional elements in
io_redirect. Without these, the grammar would not permit this form of redirection because it would require that, for
example, echo {var}> foo is parsed such that {var} is a WORD to be expanded and passed to echo. The grammar does not restrict the location given between the '{' and
'}' in these forms (other than requiring it to be non-empty) since shells may parse an invalid location as part of an
io_redirect and later treat the invalid location as an error.
C.2.10.1 Shell Grammar Lexical Conventions
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0031 [648] and XCU/TC2-2008/0032 [574,646] are applied.
Austin Group Defect 1193 is applied, adding the optional IO_LOCATION token identifier.
Austin Group Defect 1454 is applied, clarifying how to convert the token identifier type of the TOKEN when
rule 1 applies.
C.2.10.2 Shell Grammar Rules
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0036 [44] is applied.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0033 [643,839], XCU/TC2-2008/0034 [643], XCU/TC2-2008/0035
[648], XCU/TC2-2008/0036 [736], XCU/TC2-2008/0037 [737], XCU/TC2-2008/0038 [581], and XCU/TC2-2008/0039 [735] are applied.
Austin Group Defect 249 is applied, adding the dollar-single-quotes quoting mechanism.
Austin Group Defect 449 is applied, adding ;& as a case clause terminator.
Austin Group Defect 1193 is applied, adding the optional IO_LOCATION token identifier.
Austin Group Defects 1276 and 1279 are applied, clarifying rule 7.
Austin Group Defect 1454 is applied, clarifying how rule 4 applies.
C.2.11 Job Control
See also Job Control.
Shell implementations differ regarding how much of a foreground job is retained when it is converted to a suspended
job. For example, given this foreground job:
sleep 10; echo foo; echo bar &
if this is suspended during execution of the sleep, ksh93 retains all of the commands in the suspended job
and executes them when fg is used:
^Z[1] + Stopped                  sleep 10; echo foo; echo bar &
$ jobs
[1] + Stopped                  sleep 10; echo foo; echo bar &
$ fg
sleep 10; echo foo; echo bar
foo
[1]     30686
bar
$
However, some other shells create a suspended job containing only the sleep 10 command.
Some historical shells did not handle suspending a foreground AND-OR list well. They would treat the wait status of
a process that indicated it had stopped as if it was a non-zero exit status and (if the next operator in the AND-OR list was ||)
would execute the remainder of the AND-OR list at that point. This behavior is not allowed by the standard for two reasons:
It does not meet the fundamental requirement of an AND-OR list that the decision on whether to execute each part
(except the first) is made based on the exit status of the previous part when it completes.
It can lead to data loss. For example, consider a user who often runs this command:
generate_report > report.out || rm report.out
with the intention that the incomplete results from a failed generate_report run are never retained in order
that they cannot be mistaken for a complete set of results. If one day the user decides to check on the progress of the command by
stopping it and examining what has been written so far, they will find that the report.out file has already been
removed.
Austin Group Defects 1254 and 1675 are applied, adding this section.
C.2.12 Signals and Error Handling
Historically, some shell implementations silently ignored attempts to use trap to set SIGINT or SIGQUIT to the default action or to set a trap for them after they have
been set to be ignored by the shell when it executes an asynchronous subshell (and job control is disabled). This behavior is not
conforming. For example, if a shell script containing the following line is run in the foreground at a terminal:
(trap - INT; exec sleep 10) & wait
and is then terminated by typing the interrupt character, this standard requires that the sleep command is terminated by the SIGINT signal.
SD5-XCU-ERN-93 is applied, updating the first paragraph of XCU 2.12 Signals and Error Handling.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0040 [750] is applied.
C.2.13 Shell Execution Environment
Some implementations have implemented the last stage of a pipeline in the current environment so that commands such
as:
command | read foo
set variable foo in the current environment. This extension is allowed, but not required; therefore, a shell
programmer should consider a pipeline to be in a subshell environment, but not depend on it.
In early proposals, the description of execution environment failed to mention that each command in a multiple
command pipeline could be in a subshell execution environment. For compatibility with some historical shells, the wording was
phrased to allow an implementation to place any or all commands of a pipeline in the current environment. However, this means that
a POSIX application must assume each command is in a subshell environment, but not depend on it.
The wording about shell scripts is meant to convey the fact that describing "trap actions" can only be understood
in the context of the shell command language. Outside of this context, such as in a C-language program, signals are the operative
condition, not traps.
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0037 [238] is applied.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0041 [706] is applied.
Austin Group Defect 1247 is applied, changing "signal traps" to "traps" and changing "All other commands" to
"Except where otherwise stated, all other commands".
Austin Group Defect 1254 is applied, changing the list item relating to process IDs "known to this shell
environment".
Austin Group Defect 1384 is applied, changing the requirements for subshells of interactive shells.
Austin Group Defect 1580 is applied, adding a list item about environment variables with invalid names.
C.2.14 Pattern Matching Notation
Pattern matching is a simpler concept and has a simpler syntax than REs, as the former is generally used for the
manipulation of filenames, which are relatively simple collections of characters, while the latter is generally used to manipulate
arbitrary text strings of potentially greater complexity. However, some of the basic concepts are the same, so this section points
liberally to the detailed descriptions in XBD 9. Regular Expressions.
Austin Group Defect 1443 is applied, adding non-shell uses to the description of what shell pattern matching
notation is used for.
Austin Group Defect 1564 is applied, clarifying that pattern matching notation is used for matching character
strings (not arbitrary byte strings), and that if an attempt is made to use pattern matching notation to match a string that
contains one or more bytes that do not form part of a valid character, the behavior is unspecified.
C.2.14.1 Patterns Matching a Single Character
Both quoting and escaping are described here because pattern matching must work in three separate
circumstances:
Calling directly upon the shell, such as in pathname expansion or in a case statement. All of the following
match the string or file abc:
abc "abc" a"b"c a\bc a[b]c a["b"]c a[\b]c a["\b"]c a?c a*c
The following do not:
"a?c" a\*c a\[b]c
Calling a utility or function without going through a shell, as described for find and the fnmatch() and glob() functions defined in the System Interfaces volume of POSIX.1-2024, or pattern matching
in the shell in situations where the pattern is specified indirectly instead of directly to the shell, such as:
ls -ld -- $pattern
or
case $var in ($pattern) ...
Calling utilities such as find, cpio, tar, or pax through the shell command line. In this case, shell quote removal is performed before the
utility sees the argument. For example, in:
find /bin -name "e\c[\h]o" -print
after quote removal, the  characters are presented to find and it treats them as escape characters. Both precede ordinary characters, so the c
and h represent themselves and echo would be found on many historical systems
(that have it in /bin). To find a filename that contained shell special characters or pattern characters, both quoting and
escaping are required, such as:
pax -r ... "*a(\?"
to extract a filename ending with "a(?".
The wording "In a pattern, or part of one, where a shell-quoting  cannot be used to preserve the
literal value of a character that would otherwise be treated as special" has been carefully crafted so that for the shell it only
applies to certain contexts. In particular:
The use of "or part of one" is needed because a single pattern can be produced partly from characters directly
included in a word and partly from characters that result from one or more of the word expansions. For example, in the following
command the  escapes the '?' character:
dir='abc\?'
ls -l -- $dir/*.c
The reference to "a shell-quoting " rather than just using "where shell quoting cannot be
used" is because there are ways that other types of shell quoting can be used where a shell-quoting  cannot, such
as placing an expansion within double-quotes as in this example:
dir='abc?'
ls -l -- "$dir"/*.c
The use of "that would otherwise be treated as special" is needed because otherwise the condition would apply to
in single-quotes. For example, in the following command the  is not treated as escaping the
'?' because the '?' would not be treated as special anyway:
ls -l 'abc\?'/*.c
In patterns specified indirectly to the shell, it is unspecified whether or not  is special inside
bracket expressions. This is because there are two mutually exclusive consistency aims and neither is considered more important
than the other. One is consistency with direct patterns, where  is special inside bracket expressions (which is,
in turn, for consistency with the way single-quotes and double-quotes preserve the literal value of characters inside bracket
expressions); the other is consistency with regular expressions, find, pax, fnmatch(), and glob(), where  is not special inside bracket expressions (not counting the
extra C-string escaping in EREs in awk).
Earlier versions of this standard allowed two behaviors when a pattern ends with an unescaped : it
could match nothing or be treated as an invalid pattern. However, a third behavior has since been observed, where the ending
is treated as a literal , and therefore this standard now simply states that the behavior is
unspecified.
Earlier versions of this standard included the statement "The shell special characters always require quoting" in
XCU 2.14.1 Patterns Matching a Single Character. It is unclear what
was intended by this, since there are pattern matching contexts in which it is not possible to quote those characters, such as:
execlp("find", "find", ".", "-name", "*[()]*", (char *)0);
where the parentheses cannot be escaped with a  because  is not special in
bracket expressions in that context. The statement is thought to have been a warning to application writers and interactive shell
users that shell special characters (sometimes called metacharacters) always need quoting in patterns that appear directly in shell
code; for example, this code:
case $char in
[()]) ... ;;
esac
is incorrect because the parentheses are parsed as operators—they need to be quoted in order to be treated as part
of the pattern. This standard now simply requires instead that applications quote or escape any character that would otherwise be
treated as special, in order for it to be matched as an ordinary character. If shell special characters are used without this
protection in contexts where they are treated as special, syntax errors can result or implementation extensions can be triggered.
Some shells support a series of extensions based on parentheses in patterns that are valid extensions in these contexts because
they would otherwise cause syntax errors. However, this means that they are not allowed by this standard to be recognized in
contexts where those syntax errors would not occur anyway, such as in:
pattern='a*(b)'; ls -- $pattern
which this standard requires to list files with names beginning 'a' and ending "(b)". It is recommended that
implementations do not extend pattern matching in the shell in ways that are only valid extensions because they would otherwise be
syntax errors, in order to avoid inconsistency between different pattern matching contexts. One way to provide an extension that is
consistent between different pattern matching contexts in the shell (although still not consistent with find -name, fnmatch(), etc.) is to enable
the extension only when a non-standard shell option is set, or when the shell is executed using a command name other than sh. Consistency with non-shell contexts can then be achieved by enabling equivalent extensions in
those other contexts by use of non-standard utility options or non-standard FNM_* and GLOB_* flags.
The restriction on a  in a bracket expression is to allow implementations that support pattern
matching using the  as the negation character in addition to the . A conforming
application must use something like "[\^!]" to match either character.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0042 [806] is applied.
Austin Group Defect 985 is applied, changing the description of the '[' special character.
Austin Group Defect 1234 is applied, clarifying how  is handled in patterns.
C.2.14.2 Patterns Matching Multiple Characters
Since each  matches zero or more occurrences, the patterns "a*b" and "a**b" have
identical functionality.
Examples
a[bc]
Matches the strings "ab" and "ac".
a*d
Matches the strings "ad", "abd", and "abcd", but not the string "abc".
a*d*
Matches the strings "ad", "abcd", "abcdef", "aaaad", and "adddd".
*a*d
Matches the strings "ad", "abcd", "efabcd", "aaaad", and "adddd".
C.2.14.3 Patterns Used for Filename Expansion
The caveat about a  within a bracket expression is derived from historical practice. The pattern
"a[b/c]d" does not match such pathnames as abd or a/d. On some implementations (including those conforming
to the Single UNIX Specification), it matched a pathname of literally "a[b/c]d". On other systems, it produced an
undefined condition (an unescaped '[' used outside a bracket expression). In this version, the XSI behavior is now
required.
Filenames beginning with a  historically have been specially protected from view on UNIX systems. A
proposal to allow an explicit  in a bracket expression to match a leading  was considered; it is
allowed as an implementation extension, but a conforming application cannot make use of it. If this extension becomes popular in
the future, it will be considered for a future version of the Shell and Utilities volume of POSIX.1-2024.
Patterns are matched against existing filenames and pathnames only when the pattern contains a '*',
'?' or '[' character that will be treated as special. This prevents accidental removal of
characters in variable expansions where generating a list of matching files is not intended and a (usually oddly named) file with a
matching name happens to exist. For example, a shell script that tries to be portable to systems that predate the introduction of
functions and printf might use this on POSIX systems:
myecho='printf %s\n'
to be used as:
$myecho args...
If %s\n were to be matched against existing files, this would not work if a file called %sn happened to exist.
Historical systems have varied in their permissions requirements. To match f*/bar has required read
permissions on the f* directories in the System V shell, but the Shell and Utilities volume of POSIX.1-2024, the C
shell, and KornShell require only search permissions. If read or search permission is denied, shells do not report an error but
treat this as a successful "no match" condition. Error conditions that are related to file system contents and occur when
attempting to read or search a directory are also required to be treated the same way because they imply that there are no matches
(that are accessible to the process). For example, if the pattern is foo/*bar and attempting to open the directory
foo fails because it does not exist or is not a directory, then there can be no matching pathnames. The error conditions
listed in XSH 2.3 Error Numbers that are related to file system contents
and could occur when attempting to open or search a directory are [EACCES], [ELOOP], [ENAMETOOLONG], [ENOENT], and [ENOTDIR]. Error
conditions that are not related to file system contents or which occur when reading a directory, notably [EMFILE] and [ENFILE] but
also things like [EIO], [ENOMEM], and [EOVERFLOW], can either be treated as errors or be treated the same way as when permission is
denied. Treating them as errors is seen as desirable, because to do otherwise would mean the shell could execute a command with an
unchanged pattern when pathnames matching the pattern exist, but it is not historical practice. Implementations that handle the two
categories of error differently should also handle non-standard error conditions appropriately, if encountered, depending on which
category they fit into.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0043 [963] is applied.
Austin Group Defect 1070 is applied, requiring that when the matching filenames or pathnames are sorted, any that
collate equally are further compared byte-by-byte using the collating sequence for the POSIX locale.
Austin Group Defect 1228 is applied, allowing directory entries for dot and dot-dot to be ignored when matching
patterns against existing filenames.
Austin Group Defect 1234 is applied, changing the behavior of patterns used for filename expansion such that a
pattern is matched against existing filenames and pathnames only when it contains a '*', '?' or '['
character that will be treated as special.
Austin Group Defects 1273 and 1275 are applied, clarifying how errors are treated when attempting to open or search
a pathname as a directory or attempting to read an opened directory.
C.2.15 Special Built-In Utilities
See the RATIONALE sections on the individual reference pages.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0044 [882] and XCU/TC2-2008/0045 [654] are applied.
Austin Group Defect 1009 is applied, clarifying the behavior when a special built-in utility is executed with a
variable assignment.
Austin Group Defect 1445 is applied, changing text relating to the term "built-in".
C.3 Utilities
For the utilities included in POSIX.1-2024, see the RATIONALE sections on the individual reference pages.
C.3.1 Utilities Removed in this Version
The following utilities were removed in this version of this standard:
qalter
qdel
qhold
qmove
qmsg
qrerun
qrls
qselect
qsig
qstat
qsub
C.3.2 Utilities Removed in the Previous Version
None.
C.3.3 Exclusion of Utilities
The set of utilities contained in POSIX.1-2024 is drawn from the base documents for IEEE Std 1003.2-1992,
with one addition: the c17 utility. This section contains rationale for some of the
deliberations that led to this set of utilities, and why certain utilities were excluded.
Many utilities were evaluated by the standard developers; more historical utilities were excluded from the base
documents for IEEE Std 1003.2-1992 than included. The following list contains many common UNIX system utilities that were
not included as mandatory utilities, in the User Portability Utilities option, in the XSI option, or in one of the software
development groups. It is logistically difficult for this rationale to distribute correctly the reasons for not including a utility
among the various utility options. Therefore, this section covers the reasons for all utilities not included in POSIX.1-2024.
This rationale is limited to a discussion of only those utilities actively or indirectly evaluated by the
IEEE Std 1003.2-1992 standard developers, rather than the list of all known UNIX utilities from all its variants.
adb
The intent of the various software development utilities was to assist in the installation (rather than the actual development
and debugging) of applications. This utility is primarily a debugging tool. Furthermore, many useful aspects of adb are very
hardware-specific.
as
Assemblers are hardware-specific and are included implicitly as part of the compilers in POSIX.1-2024.
banner
The only known use of this command is as part of the lp printer header pages. It was
decided that the format of the header is implementation-defined, so this utility is superfluous to application portability.
calendar
This reminder service program is not useful to conforming applications.
cancel
The lp (line printer spooling) system specified is the most basic possible and did
not need this level of application control.
chroot
This is primarily of administrative use, requiring superuser privileges.
col
No utilities defined in POSIX.1-2024 produce output requiring such a filter. The nroff text formatter is present on many
historical systems and will continue to remain as an extension; col is expected to be shipped by all the systems that ship
nroff.
cpio
This has been replaced by pax, for reasons explained in the rationale for that
utility.
cpp
This is subsumed by c17.
cu
This utility is terminal-oriented and is not useful from shell scripts or typical application programs.
dc
The functionality of this utility can be provided by the bc utility; bc was selected because it was easier to use and had superior functionality. Although the
historical versions of bc are implemented using dc as a base, POSIX.1-2024
prescribes the interface and not the underlying mechanism used to implement it.
dircmp
Although a useful concept, the historical output of this directory comparison program is not suitable for processing in
application programs. Also, the diff -r command gives equivalent functionality.
dis
Disassemblers are hardware-specific.
emacs
The community of emacs editing enthusiasts was adamant that the full emacs editor not be included in
IEEE Std 1003.2-1992 because they were concerned that an attempt to standardize this very powerful environment would
encourage vendors to ship versions conforming strictly to the standard, but lacking the extensibility required by the community.
The author of the original emacs program also expressed his desire to omit the program. Furthermore, there were a number of
historical UNIX systems that did not include emacs, or included it without supporting it, but there were very few that did
not include and support vi.
ld
This is subsumed by c17.
line
The functionality of line can be provided with read.
lint
This technology is partially subsumed by c17. It is also hard to specify the degree
of checking for possible error conditions in programs in any compiler, and specifying what lint would do in these cases is
equally difficult.
It is fairly easy to specify what a compiler does. It requires specifying the language, what it does with that
language, and stating that the interpretation of any incorrect program is unspecified. Unfortunately, any description of
lint is required to specify what to do with erroneous programs. Since the number of possible errors and questionable
programming practices is infinite, one cannot require lint to detect all errors of any given class.
Additionally, some vendors complained that since many compilers are distributed in a binary form without a
lint facility (because the ISO C standard does not require one), implementing the standard as a stand-alone product
will be much harder. Rather than being able to build upon a standard compiler component (simply by providing c17 as an interface), source to that compiler would most likely need to be modified to provide
the lint functionality. This was considered a major burden on system providers for a very small gain to developers
(users).
login
This utility is terminal-oriented and is not useful from shell scripts or typical application programs.
lorder
This utility is an aid in creating an implementation-defined detail of object libraries that the standard developers did not
feel required standardization.
lpstat
The lp system specified is the most basic possible and did not need this level of
application control.
mail
This utility was omitted in favor of mailx because there was a considerable
functionality overlap between the two.
mknod
This was omitted in favor of mkfifo, as mknod has too many
implementation-defined functions.
news
This utility is terminal-oriented and is not useful from shell scripts or typical application programs.
pack
This compression program was considered inferior to compress.
passwd
This utility was proposed in an early draft of the IEEE Std 1003.2-1992 UPE but met with too many objections to be
included. There were various reasons:
Changing a password should not be viewed as a command, but as part of the login sequence. Changing a password
should only be done while a trusted path is in effect.
Even though the text in early drafts was intended to allow a variety of implementations to conform, the security
policy for one site may differ from another site running with identical hardware and software. One site might use password
authentication while the other did not. Vendors could not supply a passwd utility that would conform to POSIX.1-2024 for all
sites using their system.
This is really a subject for a system administration working group or a security working group.
pcat
This compression program was considered inferior to zcat.
pg
This duplicated many of the features of the more pager, which was preferred by the
standard developers.
prof
The intent of the various software development utilities was to assist in the installation (rather than the actual development
and debugging) of applications. This utility is primarily a debugging tool.
RCS
RCS was originally considered as part of a version control utilities portion of the scope. However, this aspect was abandoned
by the standard developers. SCCS is now included as an optional part of the XSI option.
red
Restricted editor. This was not considered by the standard developers because it never provided the level of security
restriction required.
rsh
Restricted shell. This was not considered by the standard developers because it does not provide the level of security
restriction that is implied by historical documentation.
sdb
The intent of the various software development utilities was to assist in the installation (rather than the actual development
and debugging) of applications. This utility is primarily a debugging tool. Furthermore, some useful aspects of sdb are very
hardware-specific.
sdiff
The "side-by-side diff" utility from System V was omitted because it is used infrequently, and even less so by
conforming applications. Despite being in System V, it is not in the SVID or XPG.
shar
Any of the numerous "shell archivers" were excluded because they did not meet the requirement of existing practice.
shl
This utility is terminal-oriented and is not useful from shell scripts or typical application programs. The job control aspects
of the shell command language are generally more useful.
size
The intent of the various software development utilities was to assist in the installation (rather than the actual development
and debugging) of applications. This utility is primarily a debugging tool.
spell
This utility is not useful from shell scripts or typical application programs. The spell utility was considered, but was
omitted because there is no known technology that can be used to make it recognize general language for user-specified input
without providing a complete dictionary along with the input file.
su
This utility is not useful from shell scripts or typical application programs. (There was also sentiment to avoid
security-related utilities.)
sum
This utility was renamed cksum.
tar
This has been replaced by pax, for reasons explained in the rationale for that
utility.
unpack
This compression program was considered inferior to uncompress.
wall
This utility is terminal-oriented and is not useful in shell scripts or typical applications. It is generally used only by
system administrators.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/nfindex.html =====
The Base Specifications Issue 8
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
[Frames Index]
Select a letter to display all entries in the Index which begin with that letter.
[ A | B | C | D |
E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z | Index ]
The Keyword Search performed is equivalent to man -k and matches a string in the
database.
Or perform a Word Search of the Specification
Base
Definitions and Headers
System
Interfaces
Shell &
Utilities
Rationale
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
===== susv5-html/utilities/ln.html =====
ln
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ln — link files
SYNOPSIS
ln [-fs] [-L|-P] source_file target_file
ln [-fs] [-L|-P] source_file... target_dir
DESCRIPTION
In the first synopsis form, the ln utility shall create a new directory entry at the destination path specified by the
target_file operand. If the -s option is specified, a symbolic link shall be created with the contents specified by
the source_file operand (which need not name an existing file); otherwise, a hard link shall be created to the file named by
the source_file operand. This first synopsis form shall be assumed when the final operand does not name an existing
directory; if more than two operands are specified and the final is not an existing directory, an error shall result.
In the second synopsis form, the ln utility shall create a new directory entry for each source_file operand, at a
destination path in the existing directory named by target_dir. If the -s option is specified, a symbolic link shall
be created with the contents specified by each source_file operand (which need not name an existing file); otherwise, a hard
link shall be created to each file named by a source_file operand.
If the last operand specifies an existing file of a type not specified by the System Interfaces volume of POSIX.1-2024, the
behavior is implementation-defined.
The corresponding destination path for each source_file shall be the concatenation of the target directory pathname, a
character if the target directory pathname did not end in a , and the last pathname component of the
source_file. The second synopsis form shall be assumed when the final operand names an existing directory.
For each source_file:
If the destination path exists and was created by a previous step, it is unspecified whether ln writes a diagnostic
message to standard error, does nothing more with the current source_file, and goes on to any remaining source_files;
or continues processing the current source_file. If the destination path exists:
If the -f option is not specified, ln shall write a diagnostic message to standard error, do nothing more with the
current source_file, and go on to any remaining source_files.
If the destination path names the same directory entry as the current source_file ln shall write a diagnostic
message to standard error, do nothing more with the current source_file, and go on to any remaining
source_files.
Actions shall be performed equivalent to the unlink() function defined in the
System Interfaces volume of POSIX.1-2024, called using the destination path as the path argument. If this fails for any
reason, ln shall write a diagnostic message to standard error, do nothing more with the current source_file, and go
on to any remaining source_files.
If the -s option is specified, actions shall be performed equivalent to the symlink() function with source_file as the path1 argument and the destination
path as the path2 argument. The ln utility shall do nothing more with source_file and shall go on to any
remaining files.
If source_file is a symbolic link:
If the -P option is in effect, actions shall be performed equivalent to the linkat() function with source_file as the path1 argument, the destination path
as the path2 argument, AT_FDCWD as the fd1 and fd2 arguments, and zero as the flag argument.
If the -L option is in effect, actions shall be performed equivalent to the linkat() function with source_file as the path1 argument, the destination path
as the path2 argument, AT_FDCWD as the fd1 and fd2 arguments, and AT_SYMLINK_FOLLOW as the flag
argument.
The ln utility shall do nothing more with source_file and shall go on to any remaining files.
Actions shall be performed equivalent to the link() function defined in the System
Interfaces volume of POSIX.1-2024 using source_file as the path1 argument, and the destination path as the
path2 argument.
OPTIONS
The ln utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-f
Force existing destination pathnames to be removed to allow the link.
-L
For each source_file operand that names a file of type symbolic link, create a hard link to the file referenced by the
symbolic link.
-P
For each source_file operand that names a file of type symbolic link, create a hard link to the symbolic link
itself.
-s
Create symbolic links instead of hard links. If the -s option is specified, the -L and -P options shall be
silently ignored.
Specifying more than one of the mutually-exclusive options -L and -P shall not be considered an error. The last
option specified shall determine the behavior of the utility (unless the -s option causes it to be ignored).
If the -s option is not specified and neither a -L nor a -P option is specified, it is
implementation-defined which of the -L and -P options is used as the default.
OPERANDS
The following operands shall be supported:
source_file
A pathname of a file to be linked. If the -s option is specified, no restrictions on the type of file or on its
existence shall be made. If the -s option is not specified, whether a directory can be linked is
implementation-defined.
target_file
The pathname of the new directory entry to be created.
target_dir
A pathname of an existing directory in which the new directory entries are created.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of ln:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
Not used.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
None.
EXAMPLES
None.
RATIONALE
The CONSEQUENCES OF ERRORS section does not require ln -f a b to remove b if a subsequent link
operation would fail.
Some historic versions of ln (including the one specified by the SVID) unlink the destination file, if it exists, by
default. If the mode does not permit writing, these versions prompt for confirmation before attempting the unlink. In these
versions the -f option causes ln not to attempt to prompt for confirmation.
This allows ln to succeed in creating links when the target file already exists, even if the file itself is not writable
(although the directory must be). Early proposals specified this functionality.
This volume of POSIX.1-2024 does not allow the ln utility to unlink existing destination paths by default for the
following reasons:
The ln utility has historically been used to provide locking for shell applications, a usage that is incompatible with
ln unlinking the destination path by default. There was no corresponding technical advantage to adding this
functionality.
This functionality gave ln the ability to destroy the link structure of files, which changes the historical behavior of
ln.
This functionality is easily replicated with a combination of rm and ln.
It is not historical practice in many systems; BSD and BSD-derived systems do not support this behavior. Unfortunately,
whichever behavior is selected can cause scripts written expecting the other behavior to fail.
It is preferable that ln perform in the same manner as the link() function,
which does not permit the target to exist already.
This volume of POSIX.1-2024 retains the -f option to provide support for shell scripts depending on the SVID semantics.
It seems likely that shell scripts would not be written to handle prompting by ln and would therefore have specified the
-f option.
The -f option is an undocumented feature of many historical versions of the ln utility, allowing linking to
directories. These versions require modification.
Early proposals of this volume of POSIX.1-2024 also required a -i option, which behaved like the -i options in
cp and mv, prompting for confirmation before
unlinking existing files. This was not historical practice for the ln utility and has been omitted.
The -L and -P options allow for implementing both common behaviors of the ln utility. Earlier versions of
this standard did not specify these options and required the behavior now described for the -L option. Many systems by
default or as an alternative provided a non-conforming ln utility with the behavior now described for the -P option.
Since applications could not rely on ln following links in practice, the -L and -P options were added to
specify the desired behavior for the application.
The -L and -P options are ignored when -s is specified in order to allow an alias to be created to alter
the default behavior when creating hard links (for example, alias ln='ln -L'). They serve no purpose when -s is specified, since source_file is
then just a string to be used as the contents of the created symbolic link and need not exist as a file.
The specification ensures that ln a a with or without the -f option will not unlink the file
a. Earlier versions of this standard were unclear in this case.
FUTURE DIRECTIONS
If this utility is directed to create a new directory entry that contains any bytes that have the encoded value of a
character, implementations are encouraged to treat this as an error. A future version of this standard may require
implementations to treat this as an error.
SEE ALSO
chmod, find, pax, readlink, realpath, rm
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
XSH link(), unlink()
CHANGE HISTORY
First released in Issue 2.
Issue 6
The ln utility is updated to include symbolic link processing as defined in the IEEE P1003.2b draft standard.
Issue 7
Austin Group Interpretations 1003.1-2001 #164, #168, and #169 are applied.
SD5-XCU-ERN-27 is applied, adding a new paragraph to the RATIONALE.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
The -L and -P options are added to make it implementation-defined whether the ln utility follows symbolic
links.
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0096 [136] is applied.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0113 [930] is applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1380 is applied, changing text using the term "link" in line with its updated definition.
Austin Group Defect 1457 is applied, adding readlink and realpath to the SEE ALSO section.
Austin Group Defect 1506 is applied, changing the EXIT STATUS section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/sort.html =====
sort
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sort — sort, merge, or sequence check text files
SYNOPSIS
sort [-m] [-o output] [-bdfinru] [-t
char] [-k keydef]... [file...]
sort [-c|-C] [-bdfinru] [-t char] [-k keydef]
[file]
DESCRIPTION
The sort utility shall perform one of the following functions:
Sort lines of all the named files together and write the result to the specified output.
Merge lines of all the named (presorted) files together and write the result to the specified output.
Check that a single input file is correctly presorted.
Comparisons shall be based on one or more sort keys extracted from each line of input (or, if no sort keys are specified, the
entire line up to, but not including, the terminating ), and shall be performed using the collating sequence of the
current locale. If this collating sequence does not have a total ordering of all characters (see XBD 7.3.2 LC_COLLATE), any lines of input that collate equally shall be further
compared byte-by-byte using the collating sequence for the POSIX locale.
OPTIONS
The sort utility shall conform to XBD 12.2 Utility Syntax
Guidelines, except for Guideline 9, and the -k keydef option should follow the -b, -d,
-f, -i, -n, and -r options. In addition, '+' may be recognized as an option delimiter as well
as '-'.
The following options shall be supported:
-c
Check that the single input file is ordered as specified by the arguments and the collating sequence of the current locale.
Output shall not be sent to standard output. The exit code shall indicate whether or not disorder was detected or an error
occurred. If disorder (or, with -u, a duplicate key) is detected, a warning message shall be sent to standard error
indicating where the disorder or duplicate key was found.
-C
Same as -c, except that a warning message shall not be sent to standard error if disorder or, with -u, a
duplicate key is detected.
-m
Merge only; the input file shall be assumed to be already sorted.
-o output
Specify the name of an output file to be used instead of the standard output. This file can be the same as one of the input
files.
-u
Unique: suppress all but one in each set of lines having equal keys. If used with the -c option, check that there are no
lines with duplicate keys, in addition to checking that the input file is sorted.
The following options shall override the default ordering rules. When ordering options appear independent of any key field
specifications, the requested field ordering rules shall be applied globally to all sort keys. When attached to a specific key (see
-k), the specified ordering options shall override all global ordering options for that key.
-d
Specify that only  characters and alphanumeric characters, according to the current setting of LC_CTYPE ,
shall be significant in comparisons. The behavior is undefined for a sort key to which -i or -n also applies.
-f
Consider all lowercase characters that have uppercase equivalents, according to the current setting of LC_CTYPE , to be
the uppercase equivalent for the purposes of comparison.
-i
Ignore all characters that are non-printable, according to the current setting of LC_CTYPE . The behavior is undefined
for a sort key for which -n also applies.
-n
Restrict the sort key to an initial numeric string, consisting of optional  characters, optional
character, and zero or more digits with an optional radix character and thousands separators (as defined in
the current locale), which shall be sorted by arithmetic value. An empty digit string shall be treated as zero. Leading zeros and
signs on zeros shall not affect ordering.
-r
Reverse the sense of comparisons.
The treatment of field separators can be altered using the options:
-b
Ignore leading  characters when determining the starting and ending positions of a restricted sort key. If the
-b option is specified before the first -k option, it shall be applied to all -k options. Otherwise, the
-b option can be attached independently to each -k field_start or field_end option-argument (see
below).
-t char
Use char as the field separator character; char shall not be considered to be part of a field (although it can be
included in a sort key). Each occurrence of char shall be significant (for example,
delimits an empty field). If -t is not specified,  characters shall be used as default field separators; each
maximal non-empty sequence of  characters that follows a non- shall be a field separator.
Sort keys can be specified using the options:
-k keydef
The keydef argument is a restricted sort key field definition. The format of this definition is:
field_start[type][,field_end[type]]
where field_start and field_end define a key field restricted to a portion of the line (see the EXTENDED
DESCRIPTION section), and type is one or more modifiers from the list of characters 'b', 'd',
'f', 'i', 'n', 'r'. The 'b' modifier shall behave like the -b option, but shall
apply only to the field_start or field_end to which it is attached. The other modifiers shall behave like the
corresponding options, but shall apply only to the key field to which they are attached; they shall have this effect if specified
with field_start, field_end, or both. If any modifier is attached to a field_start or to a field_end,
no option shall apply to either. Implementations shall support at least nine occurrences of the -k option, which shall be
significant in command line order. If no -k option is specified, a default sort key of the entire line shall be used.
When there are multiple key fields, later keys shall be compared only after all earlier keys compare equal. Except when the
-u option is specified, lines that otherwise compare equal shall be ordered as if none of the options -d, -f,
-i, -n, or -k were present (but with -r still in effect, if it was specified) and with all bytes in the
lines significant to the comparison. The order in which lines that still compare equal are written is unspecified.
OPERANDS
The following operand shall be supported:
file
A pathname of a file to be sorted, merged, or checked. If no file operands are specified, or if a file operand is
'-', the standard input shall be used. If sort encounters an error when opening or reading a file operand,
it may exit without writing any output to standard output or processing later operands.
STDIN
The standard input shall be used only if no file operands are specified, or if a file operand is '-'. See
the INPUT FILES section.
INPUT FILES
The input files shall be text files, except that the sort utility shall add a  to the end of a file ending
with an incomplete last line.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of sort:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_COLLATE
Determine the locale for ordering rules.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files) and the behavior of character classification for the -b,
-d, -f, -i, and -n options.
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
LC_NUMERIC
Determine the locale for the definition of the radix character and thousands separator for the -n option.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
TMPDIR
Provide a pathname that shall override the default directory for temporary files, if any.
ASYNCHRONOUS EVENTS
Default.
STDOUT
Unless the -o or -c options are in effect, the standard output shall contain the sorted input.
STDERR
The standard error shall be used for diagnostic messages. When -c is specified, if disorder is detected (or if -u
is also specified and a duplicate key is detected), a message shall be written to the standard error which identifies the input
line at which disorder (or a duplicate key) was detected. A warning message about correcting an incomplete last line of an input
file may be generated, but need not affect the final exit status.
OUTPUT FILES
If the -o option is in effect, the sorted input shall be written to the file output.
EXTENDED DESCRIPTION
The notation:
-k field_start[type][,field_end[type]]
shall define a key field that begins at field_start and ends at field_end inclusive, unless field_start
falls beyond the end of the line or after field_end, in which case the key field is empty. A missing field_end shall
mean the last character of the line.
A field comprises a maximal sequence of non-separating characters and, in the absence of option -t, any preceding field
separator.
The field_start portion of the keydef option-argument shall have the form:
field_number[.first_character]
Fields and characters within fields shall be numbered starting with 1. The field_number and first_character
pieces, interpreted as positive decimal integers, shall specify the first character to be used as part of a sort key. If
.first_character is omitted, it shall refer to the first character of the field.
The field_end portion of the keydef option-argument shall have the form:
field_number[.last_character]
The field_number shall be as described above for field_start. The last_character piece, interpreted as a
non-negative decimal integer, shall specify the last character to be used as part of the sort key. If last_character
evaluates to zero or .last_character is omitted, it shall refer to the last character of the field specified by
field_number.
If the -b option or b type modifier is in effect, characters within a field shall be counted from the first
non- in the field. (This shall apply separately to first_character and last_character.)
EXIT STATUS
The following exit values shall be returned:
0
All input files were output successfully, or -c was specified and the input file was correctly sorted.
1
Under the -c option, the file was not ordered as specified, or if the -c and -u options were both
specified, two input lines were found with equal keys.
>1
An error occurred.
CONSEQUENCES OF ERRORS
The default requirements shall apply, except that if sort encounters an error when opening or reading a file
operand, it may exit without writing any output to standard output or processing later operands.
The following sections are informative.
APPLICATION USAGE
The default value for -t, , has different properties from, for example, -t"". If a line
contains:
foo
the following treatment would occur with default separation as opposed to specifically selecting a :
Field
Default
-t ""
1
foo
empty
2
empty
empty
3
empty
foo
The leading field separator itself is included in a field when -t is not used. For example, this command
returns an exit status of zero, meaning the input was already sorted:
sort -c -k 2 b
xa
eof
(assuming that a  precedes the  in the current collating sequence). The field separator is
not included in a field when it is explicitly set via -t. This is historical practice and allows usage such as:
sort -t "|" -k 2n
of the second field as the sort key:
sort -k 2.2b,2.2b infile1 infile2
The following command prints the System V password file (user database) sorted by the numeric user ID (the
third -separated field):
sort -t : -k 3,3n /etc/passwd
The following command prints the lines of the already sorted file infile, suppressing all but one
occurrence of lines having the same third field:
sort -um -k 3.1,3.0 infile
RATIONALE
Examples in some historical documentation state that options -um with one input file keep the first in each set of lines
with equal keys. This behavior was deemed to be an implementation artifact and was not standardized.
The -z option was omitted; it is not standard practice on most systems and is inconsistent with using
sort to sort several files individually and then merge them together. The text concerning -z in historical
documentation appeared to require implementations to determine the proper buffer length during the sort phase of operation, but not
during the merge.
The -y option was omitted because of non-portability. The -M option, present in System V, was omitted
because of non-portability in international usage.
An undocumented -T option exists in some implementations. It is used to specify a directory for intermediate
files. Implementations are encouraged to support the use of the TMPDIR environment variable instead of adding an option to
support this functionality.
The -k option was added to satisfy two objections. First, the zero-based counting used by sort is not
consistent with other utility conventions. Second, it did not meet syntax guideline requirements.
Historical documentation indicates that "setting -n implies -b". The description of -n
already states that optional leading s are tolerated in doing the comparison. If -b is enabled, rather than
implied, by -n, this has unusual side-effects. When a character offset is used in a column of numbers (for example, to sort
modulo 100), that offset is measured relative to the most significant digit, not to the column. Based upon a recommendation from
the author of the original sort utility, the -b implication has been omitted from this volume of POSIX.1-2024, and an
application wishing to achieve the previously mentioned side-effects has to code the -b flag explicitly.
Earlier versions of this standard allowed the -o option to appear after operands. Historical practice
allowed all options to be interspersed with operands. This version of the standard allows implementations to accept options after
operands but conforming applications should not use this form.
Earlier versions of this standard also allowed the -number and +number options. These
options are no longer specified by POSIX.1-2024 but may be present in some implementations.
Historical implementations produced a message on standard error when -c was specified and disorder was
detected, and when -c and -u were specified and a duplicate key was detected. An earlier version of this standard
contained wording that did not make it clear that this message was allowed and some implementations removed this message to be sure
that they conformed to the standard's requirements. Confronted with this difference in behavior, interactive users that wanted to
be sure that they got visual feedback instead of just exit code 1 could have used a command like:
sort -c file || echo disorder
whether or not the sort utility provided a message in this case. But, it was not easy for a user to find
where the disorder or duplicate key occurred on implementations that do not produce a message, especially when some parts of the
input line were not part of the key and when one or more of the -b, -d, -f, -i, -n, or -r
options or keydef type modifiers were in use. POSIX.1-2024 requires a message to be produced in this case. POSIX.1-2024 also
contains the -C option giving users the ability to choose either behavior.
When a disorder or duplicate is found when the -c option is specified, some implementations print a message
containing the first line that is out of order or contains a duplicate key; others print a message specifying the line number of
the offending line. This standard allows either type of message.
The required further byte-by-byte comparison of lines that collate equally may have an impact on efficiency, but
this can be mitigated by only performing the additional comparison if the current locale's collating sequence does not have a total
ordering of all characters (if the implementation provides a way to query this) or by only performing the additional comparison if
the locale name associated with the LC_COLLATE category has an '@' modifier in the name (since
implementation-supplied locales without an '@' modifier have a total ordering of all characters — see XBD 7.3.2 LC_COLLATE — and localedef users are warned to follow the same convention). Note that if the implementation
provides a stable sort option as an extension (usually -s), the additional comparison should not be performed when
this option has been specified.
FUTURE DIRECTIONS
If this utility is directed to create a new directory entry that contains any bytes that have the encoded value of a
character, implementations are encouraged to treat this as an error. A future version of this standard may require
implementations to treat this as an error.
SEE ALSO
comm, join, uniq
XBD 7.3.2 LC_COLLATE, 8. Environment Variables, 12.2
Utility Syntax Guidelines
XSH toupper()
CHANGE HISTORY
First released in Issue 2.
Issue 6
IEEE PASC Interpretation 1003.2 #174 is applied, updating the DESCRIPTION of comparisons.
IEEE PASC Interpretation 1003.2 #168 is applied.
Issue 7
Austin Group Interpretation 1003.1-2001 #027 is applied, clarifying that Guideline 9 of the Utility Syntax Guidelines does not
apply and noting that '+' may be recognized as an option delimiter.
Austin Group Interpretation 1003.1-2001 #120 is applied, clarifying the use of the -c option and introducing
the -C option.
XCU-ERN-81 is applied, modifying the description of the -i option.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0182 [963], XCU/TC2-2008/0183 [584], XCU/TC2-2008/0184 [510],
XCU/TC2-2008/0185 [962], XCU/TC2-2008/0186 [663], and XCU/TC2-2008/0187 [963] are applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defect 862 is applied, adding TMPDIR to the ENVIRONMENT VARIABLES section.
Austin Group Defect 1070 is applied, requiring that any lines of input that collate equally when comparing them as
whole lines are further compared byte-by-byte using the collating sequence for the POSIX locale.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/read.html =====
read
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
read — read from standard input into shell variables
SYNOPSIS
read [-r] [-d delim] var...
DESCRIPTION
The read utility shall read a single logical line from standard input into one or more shell variables.
If the -r option is not specified,  shall act as an escape character. An unescaped
shall preserve the literal value of a following  and shall prevent a following byte (if any) from being used to
split fields, with the exception of either  or the logical line delimiter specified with the -d delim
option (if it is used and delim is not ); it is unspecified which. If this excepted character follows the
, the read utility shall interpret this as line continuation. The  and the excepted
character shall be removed before splitting the input into fields. All other unescaped  characters shall be
removed after splitting the input into fields.
If standard input is a terminal device and the invoking shell is interactive, read shall prompt for a continuation line
when it reads an input line ending with a  , unless the -r option is specified.
The terminating logical line delimiter (if any) shall be removed from the input. Then, if the shell variable IFS (see
2.5.3 Shell Variables) is set, and its value is an empty string, the
resulting data shall be assigned to the variable named by the first var operand, and the variables named by other var
operands (if any) shall be set to the empty string. No other processing shall be performed in this case.
If IFS is unset, or is set to any non-empty value, then a modified version of the field splitting algorithm specified in
2.6.5 Field Splitting shall be applied, with the modifications as
follows:
The input to the algorithm shall be the logical line (minus terminating delimiter) that was read from standard input, and shall
be considered as a single initial field, all of which resulted from expansions, with any escaped byte and the preceding
escape character treated as if they were the result of a quoted expansion, and all other bytes treated as if they
were the results of unquoted expansions.
The loop over the contents of that initial field shall cease when either the input is empty or n output fields have been
generated, where n is one less than the number of var operands passed to the read utility. Any remaining input
in the original field being processed shall be returned to the read utility "unsplit"; that is, unmodified except that any
leading or trailing IFS white space, as defined in 2.6.5 Field
Splitting, shall be removed.
The specified var operands shall be processed in the order they appear on the command line, and the output fields
generated by the field splitting algorithm shall be used in the order they were generated, by repeating the following checks until
neither is true:
If more than one var operand is yet to be processed and one or more output fields are yet to be used, the variable named
by the first unprocessed var operand shall be assigned the value of the first unused output field.
If exactly one var operand is yet to be processed and there was some remaining unsplit input returned from the modified
field splitting algorithm, the variable named by the unprocessed var operand shall be assigned the unsplit input.
If there are still one or more unprocessed var operands, each of the variables names by those operands shall be assigned
an empty string.
Note that in the case where just one var operand is given on the read command line, the modified field splitting
algorithm ceases after producing zero output fields and simply returns the original input field, with any leading and trailing
IFS white space removed, as unsplit input. This unsplit input is assigned to the variable named by the var
operand.
The setting of variables specified by the var operands shall affect the current shell execution environment; see 2.13 Shell Execution Environment. An error in setting any variable (such as if
a var has previously been marked readonly) shall be considered an error of read processing, and shall result
in a return value greater than one. Variables named before the one generating the error shall be set as described above; it is
unspecified whether variables named later shall be set as above, or read simply ceases processing when the error occurs,
leaving later named variables unaltered. If read is called in a subshell or separate utility execution environment, such as
one of the following:
(read foo)
nohup read ...
find . -exec read ... \;
it shall not affect the shell variables in the caller's environment.
If end-of-file is detected before a terminating logical line delimiter is encountered, the variables specified by the var
operands shall be set as described above and the exit status shall be 1.
OPTIONS
The read utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-d delim
If delim consists of one single-byte character, that byte shall be used as the logical line delimiter. If delim
is the null string, the logical line delimiter shall be the null byte. Otherwise, the behavior is unspecified.
-r
Do not treat a  character in any special way. Consider each  to be part of the input
line.
OPERANDS
The following operand shall be supported:
var
The name of an existing or nonexisting shell variable. If a var operand names the variable IFS , the behavior is
unspecified.
If a var operand names one of the variables LANG , LC_CTYPE , or LC_ALL and the new value assigned
to the variable would change how the bytes in IFS form characters, or which characters in IFS are considered to be
IFS white space (see 2.6.5 Field Splitting), it is
unspecified what effects, if any, the change has on how read performs field splitting.
STDIN
If the -d delim option is not specified, or if it is specified and delim is not the null string, the
standard input shall contain zero or more bytes (which need not form valid characters) and shall not contain any null bytes.
If the -d delim option is specified and delim is the null string, the standard input shall contain zero or
more bytes (which need not form valid characters).
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of read:
IFS
Determine the internal field separators used to delimit fields; see 2.5.3
Shell Variables.
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
PS2
Provide the prompt string that an interactive shell shall write to standard error when a line ending with a
is read and the -r option was not specified.
ASYNCHRONOUS EVENTS
Default.
STDOUT
Not used.
STDERR
The standard error shall be used for diagnostic messages and prompts for continued input.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
1
End-of-file was detected.
>1
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
This utility is required to be intrinsic. See 1.7 Intrinsic Utilities
for details.
The -r option is included to enable read to subsume the purpose of the line utility, which is not included
in POSIX.1-2024.
The -d delim option enables reading up to an arbitrary single-byte delimiter. When delim is the null
string, the delimiter is the null byte and this allows read to be used to process null-terminated lists of pathnames (as
produced by the find -print0 primary), with correct handling of pathnames that
contain  characters. Note that in order to specify the null string as the delimiter, -d and delim need
to be specified as two separate arguments. Implementations differ in their handling of  for line continuation when
-d delim is specified (and delim is not ); some treat delim (or
if delim is the null string) as a line continuation, whereas others still treat
as a line continuation. Consequently, portable applications need to specify -r whenever
they specify -d delim (and delim is not ).
When reading a pathname it is inadvisable to use the contents of the first var operand, if non-empty, when the exit
status of read is 1, as it is likely the result of the command used to generate the list of pathnames (for example find with -print or -print0) being terminated after it has written a partial
pathname, and consequently using it could result in the wrong pathname being processed.
Since the var operands are processed in the order specified on the command line, if any variable name is specified more
than once as a var operand, the last assignment made is the one that is in effect when read returns, including when
an empty string is assigned because no field data was available.
EXAMPLES
The following command:
while read -r xx yy
do
printf "%s %s\n" "$yy" "$xx"
done  character was encountered. However, all of the most
popular shell implementations have been found to have consistent behavior in this case, and so the behavior is now specified and
the requirement for standard input to be a text file has been relaxed to allow non-empty input that does not end with a
.
FUTURE DIRECTIONS
None.
SEE ALSO
2. Shell Command Language
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 2.
Issue 7
Austin Group Interpretation 1003.1-2001 #194 is applied, clarifying the handling of the  escape character.
SD5-XCU-ERN-126 is applied, clarifying that input lines end with a .
The description of here-documents is removed from the read reference page.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0162 [958] is applied.
Issue 8
Austin Group Defect 243 is applied, adding the -d option and relaxing the requirement for standard input to be a text
file.
Austin Group Defect 367 is applied, requiring that read distinguishes between detecting end-of-file and an error
occurring, setting its exit status to one and greater than one, respectively.
Austin Group Defect 854 is applied, adding a note to the APPLICATION USAGE section that this utility is required to be
intrinsic.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1778 is applied, clarifying how field splitting is performed.
Austin Group Defect 1779 is applied, clarifying how an error in setting any variable affects the processing of variables named
before or after the one generating the error.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/join.html =====
join
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
join — relational database operator
SYNOPSIS
join [-a file_number|-v file_number] [-e string]
[-o list] [-t char]
[-1 field] [-2 field] file1 file2
DESCRIPTION
The join utility shall perform an equality join on the files file1 and file2. The joined files shall be
written to the standard output.
The join field is a field in each file on which the files are compared. The join utility shall write one line in the
output for each pair of lines in file1 and file2 that have join fields that collate equally. The output line by
default shall consist of the join field, then the remaining fields from file1, then the remaining fields from file2.
This format can be changed by using the -o option (see below). The -a option can be used to add unmatched lines to
the output. The -v option can be used to output only unmatched lines.
The files file1 and file2 shall be ordered in the collating sequence of sort -b on the fields on which they shall be joined, by default the first in each line.
All selected output shall be written in the same collating sequence.
The default input field separators shall be  characters. In this case, multiple separators shall count as one field
separator, and leading separators shall be ignored. The default output field separator shall be a .
The field separator and collating sequence can be changed by using the -t option (see below).
If the same key appears more than once in either file, all combinations of the set of remaining fields in file1 and the
set of remaining fields in file2 are output in the order of the lines encountered.
If the input files are not in the appropriate collating sequence, the results are unspecified.
OPTIONS
The join utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-a file_number
Produce a line for each unpairable line in file file_number, where file_number is 1 or 2, in addition to the default
output. If both -a1 and -a2 are specified, all unpairable lines shall be output.
-e string
Replace empty output fields in the list selected by -o with the string string.
-o list
Construct the output line to comprise the fields specified in list, each element of which shall have one of the
following two forms:
file_number.field, where file_number is a file number and field is a decimal integer field number
0 (zero), representing the join field
The elements of list shall be either -separated or -separated, as specified in Guideline 8 of
XBD 12.2 Utility Syntax Guidelines. The fields specified by list
shall be written for all selected output lines. Fields selected by list that do not appear in the input shall be treated as
empty output fields. (See the -e option.) Only specifically requested fields shall be written. The application shall ensure
that list is a single command line argument.
-t char
Use character char as a separator, for both input and output. Every appearance of char in a line shall be
significant. When this option is specified, the collating sequence shall be the same as sort without the -b option.
-v file_number
Instead of the default output, produce a line only for each unpairable line in file_number, where file_number is 1 or
2. If both -v1 and -v2 are specified, all unpairable lines shall be output.
-1 field
Join on the fieldth field of file 1. Fields are decimal integers starting with 1.
-2 field
Join on the fieldth field of file 2. Fields are decimal integers starting with 1.
OPERANDS
The following operands shall be supported:
file1, file2
A pathname of a file to be joined. If either of the file1 or file2 operands is '-', the standard input
shall be used in its place.
STDIN
The standard input shall be used only if the file1 or file2 operand is '-'. See the INPUT FILES
section.
INPUT FILES
The input files shall be text files.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of join:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_COLLATE
Determine the locale of the collating sequence join expects to have been used when the input files were sorted.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
The join utility output shall be a concatenation of selected character fields. When the -o option is not
specified, the output shall be:
"%s%s%s\n", , ,
If the join field is not the first field in a file, the  for that file shall be:
,
When the -o option is specified, the output format shall be:
"%s\n",
where the concatenation of fields is described by the -o option, above.
For either format, each field (except the last) shall be written with its trailing separator character. If the separator is the
default ( characters), a single  shall be written after each field (except the last).
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
All input files were output successfully.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
Pathnames consisting of numeric digits or of the form string.string should not be specified directly following the
-o list.
If the collating sequence of the current locale does not have a total ordering of all characters (see XBD 7.3.2 LC_COLLATE), join treats fields that collate equally but are not
identical as being the same. If this behavior is not desired, it can be avoided by forcing the use of the POSIX locale (although
this means re-sorting the input files into the POSIX locale collating sequence.)
When using join to process pathnames, it is recommended that LC_ALL, or at least LC_CTYPE and LC_COLLATE, are set to
POSIX or C in the environment, since pathnames can contain byte sequences that do not form valid characters in some locales, in
which case the utility's behavior would be undefined. In the POSIX locale each byte is a valid single-byte character, and therefore
this problem is avoided.
EXAMPLES
The -o 0 field essentially selects the union of the join fields. For example, given file phone:
!Name           Phone Number
Don             +1 123-456-7890
Hal             +1 234-567-8901
Yasushi         +2 345-678-9012
and file fax:
!Name           Fax Number
Don             +1 123-456-7899
Keith           +1 456-789-0122
Yasushi         +2 345-678-9011
(where the large expanses of white space are meant to each represent a single ), the command:
join -t "" -a 1 -a 2 -e '(unknown)' -o 0,1.2,2.2 phone fax
(where  is a literal  character) would produce:
!Name           Phone Number            Fax Number
Don             +1 123-456-7890         +1 123-456-7899
Hal             +1 234-567-8901         (unknown)
Keith           (unknown)               +1 456-789-0122
Yasushi         +2 345-678-9012         +2 345-678-9011
Multiple instances of the same key will produce combinatorial results. The following:
fa:
a x
a y
a z
fb:
a p
will produce:
a x p
a y p
a z p
And the following:
fa:
a b c
a d e
fb:
a w x
a y z
a o p
will produce:
a b c w x
a b c y z
a b c o p
a d e w x
a d e y z
a d e o p
RATIONALE
The -e option is only effective when used with -o because, unless specific fields are identified using -o,
join is not aware of what fields might be empty. The exception to this is the join field, but identifying an empty join
field with the -e string is not historical practice and some scripts might break if this were changed.
The 0 field in the -o list was adopted from the Tenth Edition version of join to satisfy international objections
that the join in the base documents for IEEE Std 1003.2-1992 did not support the "full join" or "outer join"
described in relational database literature. Although it has been possible to include a join field in the output (by default, or by
field number using -o), the join field could not be included for an unpaired line selected by -a. The -o 0
field essentially selects the union of the join fields.
This sort of outer join was not possible with the join commands in the base documents for IEEE Std 1003.2-1992.
The -o 0 field was chosen because it is an upwards-compatible change for applications. An alternative was considered: have
the join field represent the union of the fields in the files (where they are identical for matched lines, and one or both are null
for unmatched lines). This was not adopted because it would break some historical applications.
The ability to specify file2 as - is not historical practice; it was added for completeness.
The -v option is not historical practice, but was considered necessary because it permitted the writing of only
those lines that do not match on the join field, as opposed to the -a option, which prints both lines that do and do not
match. This additional facility is parallel with the -v option of grep.
Some historical implementations have been encountered where a blank line in one of the input files was considered to be the end
of the file; the description in this volume of POSIX.1-2024 does not cite this as an allowable case.
Earlier versions of this standard allowed -j, -j1, -j2 options, and a form of the -o option that
allowed the list option-argument to be multiple arguments. These forms are no longer specified by POSIX.1-2024 but may be
present in some implementations.
FUTURE DIRECTIONS
None.
SEE ALSO
awk, comm, sort, uniq
XBD 7.3.2 LC_COLLATE, 8. Environment Variables, 12.2
Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 2.
Issue 6
The obsolescent -j options and the multi-argument -o option are removed in this version.
The normative text is reworded to avoid use of the term "must" for application requirements.
Issue 7
Austin Group Interpretation 1003.1-2001 #027 is applied.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0109 [963], XCU/TC2-2008/0110 [663], XCU/TC2-2008/0111 [971], and
XCU/TC2-2008/0112 [885] are applied.
Issue 8
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/newgrp.html =====
newgrp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
newgrp — change to a new group
SYNOPSIS
newgrp [-l] [group]
DESCRIPTION
The newgrp utility shall create a new shell execution environment with a new real and effective group identification. Of
the attributes listed in 2.13 Shell Execution Environment, the new
shell execution environment shall retain the working directory, file creation mask, and exported variables from the previous
environment (that is, open files, traps, unexported variables, alias definitions, shell functions, and set options may be lost). All other aspects of the process environment that are
preserved by the exec family of functions defined in the System Interfaces volume of POSIX.1-2024 shall also be preserved by
newgrp; whether other aspects are preserved is unspecified.
A failure to assign the new group identifications (for example, for security or password-related reasons) shall not prevent the
new shell execution environment from being created.
The newgrp utility shall affect the supplemental groups for the process as follows:
On systems where the effective group ID is normally in the supplementary group list (or whenever the old effective group ID
actually is in the supplementary group list):
If the new effective group ID is also in the supplementary group list, newgrp shall change the effective group ID.
If the new effective group ID is not in the supplementary group list, newgrp shall add the new effective group ID to the
list, if there is room to add it.
On systems where the effective group ID is not normally in the supplementary group list (or whenever the old effective group ID
is not in the supplementary group list):
If the new effective group ID is in the supplementary group list, newgrp shall delete it.
If the old effective group ID is not in the supplementary list, newgrp shall add it if there is room.
Note:
The System Interfaces volume of POSIX.1-2024 does not specify whether the effective group ID of a process is included in its
supplementary group list.
With no operands, newgrp shall change the effective group back to the groups identified in the user's user entry, and
shall set the list of supplementary groups to that set in the user's group database entries.
If the first argument is '-', the results are unspecified.
If a password is required for the specified group, and the user is not listed as a member of that group in the group database,
the user shall be prompted to enter the correct password for that group. If the user is listed as a member of that group, no
password shall be requested. If no password is required for the specified group, it is implementation-defined whether users not
listed as members of that group can change to that group. Whether or not a password is required, implementation-defined system
accounting or security mechanisms may impose additional authorization restrictions that may cause newgrp to write a
diagnostic message and suppress the changing of the group identification.
OPTIONS
The newgrp utility shall conform to XBD 12.2 Utility Syntax
Guidelines, except for the unspecified usage of '-'.
The following option shall be supported:
-l
(The letter ell.) Change the environment to what would be expected if the user actually logged in again.
OPERANDS
The following operand shall be supported:
group
A group name from the group database or a non-negative numeric group ID. Specifies the group ID to which the real and effective
group IDs shall be set. If group is a non-negative numeric string and exists in the group database as a group name (see
getgrnam()), the numeric group ID associated with that group name shall be used as
the group ID.
STDIN
Not used.
INPUT FILES
The file /dev/tty shall be used to read a single line of text for password checking, when one is required.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of newgrp:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
Not used.
STDERR
The standard error shall be used for diagnostic messages and a prompt string for a password, if one is required. Diagnostic
messages may be written in cases where the exit status is not available. See the EXIT STATUS section.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
If newgrp succeeds in creating a new shell execution environment, whether or not the group identification was changed
successfully, the exit status shall be the exit status of the shell. Otherwise, the following exit value shall be returned:
>0
An error occurred.
CONSEQUENCES OF ERRORS
The invoking shell may terminate.
The following sections are informative.
APPLICATION USAGE
There is no convenient way to enter a password into the group database. Use of group passwords is not encouraged, because by
their very nature they encourage poor security practices. Group passwords may disappear in the future.
A common implementation of newgrp is that the current shell uses exec to overlay itself with newgrp, which
in turn overlays itself with a new shell after changing group. On some implementations, however, this may not occur and
newgrp may be invoked as a subprocess.
The newgrp command is intended only for use from an interactive terminal. It does not offer a useful interface for the
support of applications.
The exit status of newgrp is generally inapplicable. If newgrp is used in a script, in most cases it successfully
invokes a new shell and the rest of the original shell script is bypassed when the new shell exits. Used interactively,
newgrp displays diagnostic messages to indicate problems. But usage such as:
newgrp foo
echo $?
is not useful because the new shell might not have access to any status newgrp may have generated (and most historical
systems do not provide this status). A zero status echoed here does not necessarily indicate that the user has changed to the new
group successfully. Following newgrp with the id command provides a portable means
of determining whether the group change was successful or not.
EXAMPLES
None.
RATIONALE
Most historical implementations use one of the exec functions to implement the behavior of newgrp. Errors detected
before the exec leave the environment unchanged, while errors detected after the exec leave the user in a changed
environment. While it would be useful to have newgrp issue a diagnostic message to tell the user that the environment
changed, it would be inappropriate to require this change to some historical implementations.
The password mechanism is allowed in the group database, but how this would be implemented is not specified.
The newgrp utility was retained in this volume of POSIX.1-2024, even given the existence of the multiple group
permissions feature in the System Interfaces volume of POSIX.1-2024, for several reasons. First, in some implementations, the group
ownership of a newly created file is determined by the group of the directory in which the file is created, as allowed by the
System Interfaces volume of POSIX.1-2024; on other implementations, the group ownership of a newly created file is determined by
the effective group ID. On implementations of the latter type, newgrp allows files to be created with a specific group
ownership. Finally, many implementations use the real group ID in accounting, and on such systems, newgrp allows the
accounting identity of the user to be changed.
FUTURE DIRECTIONS
None.
SEE ALSO
2. Shell Command Language, sh
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
XSH exec, getgrnam()
CHANGE HISTORY
First released in Issue 2.
Issue 6
This utility is marked as part of the User Portability Utilities option.
The obsolescent SYNOPSIS is removed.
The text describing supplemental groups is no longer conditional on {NGROUPS_MAX} being greater than 1. This is because
{NGROUPS_MAX} now has a minimum value of 8. This is a FIPS requirement.
Issue 7
Austin Group Interpretation 1003.1-2001 #027 is applied, clarifying the behavior if the first argument is '-'.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
The newgrp utility is moved from the User Portability Utilities option to the Base. User Portability Utilities is now an
option for interactive utilities.
Issue 8
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/od.html =====
od
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
od — dump files in various formats
SYNOPSIS
od [-v] [-A address_base] [-j skip] [-N
count] [-t type_string]...
[file...]
[XSI]  od [-bcdosx] [file]
[[+]offset[.][b]]
DESCRIPTION
The od utility shall write the contents of its input files to standard output in a user-specified format.
OPTIONS
The od utility shall conform to XBD 12.2 Utility Syntax
Guidelines, except that the order of presentation of the -t options [XSI]   and the
-bcdosx options  is significant.
The following options shall be supported:
-A address_base
Specify the input offset base. See the EXTENDED DESCRIPTION section. The application shall ensure that the address_base
option-argument is a character. The characters 'd', 'o', and 'x' specify that the offset base shall be
written in decimal, octal, or hexadecimal, respectively. The character 'n' specifies that the offset shall not be
written.
-b
[XSI]
Interpret bytes in octal. This shall be equivalent to -t o1.
-c
[XSI]
Interpret bytes as characters specified by the current setting of the LC_CTYPE category. Certain non-graphic characters
appear as C escapes: "NUL=\0", "BS=\b", "FF=\f", "NL=\n", "CR=\r", "HT=\t";
others appear as 3-digit octal numbers.
-d
[XSI]
Interpret words (two-byte units) in unsigned decimal. This shall be equivalent to -t u2.
-j skip
Jump over skip bytes from the beginning of the input. The od utility shall read or seek past the first
skip bytes in the concatenated input files. If the combined input is not at least skip bytes long, the od
utility shall write a diagnostic message to standard error and exit with a non-zero exit status.
By default, the skip option-argument shall be interpreted as a decimal number. With a leading 0x or 0X, the offset shall
be interpreted as a hexadecimal number; otherwise, with a leading '0', the offset shall be interpreted as an octal number.
Appending the character 'b', 'k', or 'm' to offset shall cause it to be interpreted as a multiple of
512, 1024, or 1048576 bytes, respectively. If the skip number is hexadecimal, any appended 'b' shall be considered
to be the final hexadecimal digit.
-N count
Format no more than count bytes of input. By default, count shall be interpreted as a decimal number. With a
leading 0x or 0X, count shall be interpreted as a hexadecimal number; otherwise, with a leading '0', it shall be
interpreted as an octal number. If count bytes of input (after successfully skipping, if -j skip is specified)
are not available, it shall not be considered an error; the od utility shall format the input that is available.
-o
[XSI]
Interpret words (two-byte units) in octal. This shall be equivalent to -t o2.
-s
[XSI]
Interpret words (two-byte units) in signed decimal. This shall be equivalent to -t d2.
-t type_string
Specify one or more output types. See the EXTENDED DESCRIPTION section. The application shall ensure that the type_string
option-argument is a string specifying the types to be used when writing the input data. The string shall consist of the type
specification characters a, c, d, f, o, u, and x, specifying named
character, character, signed decimal, floating point, octal, unsigned decimal, and hexadecimal, respectively. The type
specification characters d, f, o, u, and x can be followed by an optional unsigned
decimal integer that specifies the number of bytes to be transformed by each instance of the output type. The type specification
character f can be followed by an optional F, D, or L indicating that the conversion should be
applied to an item of type float, double, or long double, respectively. The type specification characters
d, o, u, and x can be followed by an optional C, S, I, or L
indicating that the conversion should be applied to an item of type char, short, int, or long,
respectively. Multiple types can be concatenated within the same type_string and multiple -t options can be
specified. Output lines shall be written for each type specified in the order in which the type specification characters are
specified.
-v
Write all input data. Without the -v option, any number of groups of output lines, which would be identical to the
immediately preceding group of output lines (except for the byte offsets), shall be replaced with a line containing only an
('*').
-x
[XSI]
Interpret words (two-byte units) in hexadecimal. This shall be equivalent to -t x2.
[XSI]
Multiple types can be specified by using multiple -bcdostx options. Output lines are written for each type specified in the
order in which the types are specified.
OPERANDS
The following operands shall be supported:
file
A pathname of a file to be read. If no file operands are specified, the standard input shall be used.
If there are no more than two operands, none of the -A, -j, -N, -t, or -v options is
specified, and either of the following is true: the first character of the last operand is a  ('+'), or
there are two operands and the first character of the last operand is numeric; [XSI]   the last
operand shall be interpreted as an offset operand on XSI-conformant systems.  Under these conditions, the results are unspecified on systems that are not XSI-conformant systems.
[+]offset[.][b]
[XSI]
The offset operand specifies the offset in the file where dumping is to commence. This operand is normally interpreted as
octal bytes. If '.' is appended, the offset shall be interpreted in decimal. If 'b' is appended, the offset shall
be interpreted in units of 512 bytes.
STDIN
The standard input shall be used if no file operands are specified, and shall be used if a file operand is
'-' and the implementation treats the '-' as meaning standard input. Otherwise, the standard input shall not be
used. See the INPUT FILES section.
INPUT FILES
The input files can be any file type.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of od:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
LC_NUMERIC
Determine the locale for selecting the radix character used when writing floating-point formatted output.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
See the EXTENDED DESCRIPTION section.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
The od utility shall copy sequentially each input file to standard output, transforming the input data according to the
output types specified by the -t option [XSI]   or the -bcdosx options.  If no output type is specified, the default output shall be as if -t oS had been
specified.
The number of bytes transformed by the output type specifier c may be variable depending on the LC_CTYPE
category.
The default number of bytes transformed by output type specifiers d, f, o, u, and x
corresponds to the various C-language types as follows. If the c17 compiler is present
on the system, these specifiers shall correspond to the sizes used by default in that compiler. Otherwise, these sizes may vary
among systems that conform to POSIX.1-2024.
For the type specifier characters d, o, u, and x, the default number of bytes shall
correspond to the size of the underlying implementation's basic integer type. For these specifier characters, the implementation
shall support values of the optional number of bytes to be converted corresponding to the number of bytes in the C-language types
char, short, int, and long. These numbers can also be specified by an application as the characters
'C', 'S', 'I', and 'L', respectively. The implementation shall also support the values 1, 2, 4,
and 8, even if it provides no C-Language types of those sizes. The implementation shall support the decimal value corresponding to
the C-language type long long. The byte order used when interpreting numeric values is implementation-defined, but shall
correspond to the order in which a constant of the corresponding type is stored in memory on the system.
For the type specifier character f, the default number of bytes shall correspond to the number of bytes in the
underlying implementation's basic double precision floating-point data type. The implementation shall support values of the
optional number of bytes to be converted corresponding to the number of bytes in the C-language types float, double,
and long double. These numbers can also be specified by an application as the characters 'F', 'D', and
'L', respectively.
The type specifier character a specifies that bytes shall be interpreted as named characters from the International
Reference Version (IRV) of the ISO/IEC 646:1991 standard. Only the least significant seven bits of each byte shall be used for
this type specification. Bytes with the values listed in the following table shall be written using the corresponding names for
those characters.
Table: Named Characters in od
Value
Name
Value
Name
Value
Name
Value
Name
\000
nul
\001
soh
\002
stx
\003
etx
\004
eot
\005
enq
\006
ack
\007
bel
\010
bs
\011
ht
\012
lf or nl*
\013
vt
\014
ff
\015
cr
\016
so
\017
si
\020
dle
\021
dc1
\022
dc2
\023
dc3
\024
dc4
\025
nak
\026
syn
\027
etb
\030
can
\031
em
\032
sub
\033
esc
\034
fs
\035
gs
\036
rs
\037
us
\040
sp
\177
del
Note:
The "\012" value may be written either as lf or nl.
The type specifier character c specifies that bytes shall be interpreted as characters specified by the
current setting of the LC_CTYPE locale category. Characters listed in the table in XBD 5. File Format Notation ('\\', '\a', '\b', '\f',
'\n', '\r', '\t', '\v') shall be written as the corresponding escape sequences, except that
shall be written as a single  and a NUL shall be written as '\0'. Other non-printable
characters shall be written as one three-digit octal number for each byte in the character. Printable multi-byte characters shall
be written in the area corresponding to the first byte of the character; the two-character sequence "**" shall be written
in the area corresponding to each remaining byte in the character, as an indication that the character is continued. When either
the -j skip or -N count option is specified along with the c type specifier, and this results
in an attempt to start or finish in the middle of a multi-byte character, the result is implementation-defined.
The input data shall be manipulated in blocks, where a block is defined as a multiple of the least common multiple
of the number of bytes transformed by the specified output types. If the least common multiple is greater than 16, the results are
unspecified. Each input block shall be written as transformed by each output type, one per written line, in the order that the
output types were specified. If the input block size is larger than the number of bytes transformed by the output type, the output
type shall sequentially transform the parts of the input block, and the output from each of the transformations shall be separated
by one or more  characters.
If, as a result of the specification of the -N option or end-of-file being reached on the last input file,
input data only partially satisfies an output type, the input shall be extended sufficiently with null bytes to write the last byte
of the input.
Unless -A n is specified, the first output line produced for each input block shall be preceded by the
input offset, cumulative across input files, of the next byte to be written. The format of the input offset is unspecified;
however, it shall not contain any  characters, shall start at the first character of the output line, and shall be
followed by one or more  characters. In addition, the offset of the byte following the last byte written shall be
written after all the input data has been processed, but shall not be followed by any  characters. If -A n
is specified, it is unspecified whether the line that would contain this final offset is written as an empty line or is not
written.
If no -A option is specified, the input offset base is unspecified.
EXIT STATUS
The following exit values shall be returned:
0
All input files were processed successfully.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
XSI-conformant applications are warned not to use filenames starting with '+' or a first operand starting with a
numeric character so that the old functionality can be maintained by implementations, unless they specify one of the -A,
-j, or -N options. To guarantee that one of these filenames is always interpreted as a filename, an application could
always specify the address base format with the -A option.
EXAMPLES
If a file containing 128 bytes with decimal values zero to 127, in increasing order, is supplied as standard input to the
command:
od -A d -t a
on an implementation using an input block size of 16 bytes, the standard output, independent of the current locale
setting, would be similar to:
0000000 nul soh stx etx eot enq ack bel  bs  ht  nl  vt  ff  cr  so  si
0000016 dle dc1 dc2 dc3 dc4 nak syn etb can  em sub esc  fs  gs  rs  us
0000032  sp   !   "   #   $   %   &   '   (   )   *   +   ,   -   .  /
0000048   0   1   2   3   4   5   6   7   8   9   :   ;      ?
0000064   @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
0000080   P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
0000096   `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
0000112   p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~ del
0000128
Note that this volume of POSIX.1-2024 allows nl or lf to be used as the name for the
ISO/IEC 646:1991 standard IRV character with decimal value 10. The IRV names this character lf (line feed), but
traditional implementations have referred to this character as newline (nl) and the POSIX locale character set symbolic name
for the corresponding character is a .
The command:
od -A o -t o2x2x -N 18
on a system with 32-bit words and an implementation using an input block size of 16 bytes could write 18 bytes in
approximately the following format:
0000000 032056 031440 041123 042040 052516 044530 020043 031464
342e   3320   4253   4420   554e   4958   2023   3334
342e3320      42534420      554e4958      20233334
0000020 032472
353a
353a0000
0000022
The command:
od -A d -t f -t o4 -t x4 -N 24 -j 0x15
on a system with 64-bit doubles (for example, IEEE Std 754-1985 double precision floating-point format)
would skip 21 bytes of input data and then write 24 bytes in approximately the following format:
0000000    1.00000000000000e+00    1.57350000000000e+01
07774000000 00000000000 10013674121 35341217270
3ff00000    00000000    402f3851    eb851eb8
0000016    1.40668230000000e+02
10030312542 04370303230
40619562    23e18698
0000024
RATIONALE
The od utility went through several names in early proposals, including hd, xd, and most recently
hexdump. There were several objections to all of these based on the following reasons:
The hd and xd names conflicted with historical utilities that behaved differently.
The hexdump description was much more complex than needed for a simple dump utility.
The od utility has been available on all historical implementations and there was no need to create a new
name for a utility so similar to the historical od utility.
The original reasons for not standardizing historical od were also fairly widespread. Those reasons are
given below along with rationale explaining why the standard developers believe that this version does not suffer from the
indicated problem:
The BSD and System V versions of od have diverged, and the intersection of features provided by both does
not meet the needs of the user community. In fact, the System V version only provides a mechanism for dumping octal bytes and
shorts, signed and unsigned decimal shorts, hexadecimal shorts, and ASCII characters. BSD added the ability to
dump floats, doubles, named ASCII characters, and octal, signed decimal, unsigned decimal, and hexadecimal
longs. The version presented here provides more normalized forms for dumping bytes, shorts, ints, and
longs in octal, signed decimal, unsigned decimal, and hexadecimal; float, double, and long double; and
named ASCII as well as current locale characters.
It would not be possible to come up with a compatible superset of the BSD and System V flags that met the
requirements of the standard developers. The historical default od output is the specified default output of this utility.
None of the option letters chosen for this version of od conflict with any of the options to historical versions of
od.
On systems with different sizes for short, int, and long, there was no way to ask for dumps
of ints, even in the BSD version. Because of the way options are named, the name space could not be extended to solve these
problems. This is why the -t option was added (with type specifiers more closely matched to the printf() formats used in the rest of this volume of POSIX.1-2024) and the optional field
sizes were added to the d, f, o, u, and x type specifiers. It is also one of the
reasons why the historical practice was not mandated as a required obsolescent form of od. (Although the old versions of
od are not listed as an obsolescent form, implementations are urged to continue to recognize the older forms for several
more years.) The a, c, f, o, and x types match the meaning of the corresponding format
characters in the historical implementations of od except for the default sizes of the fields converted. The d
format is signed in this volume of POSIX.1-2024 to match the printf() notation.
(Historical versions of od used d as a synonym for u in this version. The System V implementation uses
s for signed decimal; BSD uses i for signed decimal and s for null-terminated strings.) Other than
d and u, all of the type specifiers match format characters in the historical BSD version of od.
The sizes of the C-language types char, short, int, long, float, double,
and long double are used even though it is recognized that there may be zero or more than one compiler for the C language on
an implementation and that they may use different sizes for some of these types. (For example, one compiler might use 2 bytes
shorts, 2 bytes ints, and 4 bytes longs, while another compiler (or an option to the same compiler) uses 2
bytes shorts, 4 bytes ints, and 4 bytes longs.) Nonetheless, there has to be a basic size known by the
implementation for these types, corresponding to the values reported by invocations of the getconf utility when called with system_var operands {UCHAR_MAX}, {USHORT_MAX},
{UINT_MAX}, and {ULONG_MAX} for the types char, short, int, and long, respectively. There are similar
constants required by the ISO C standard, but not required by the System Interfaces volume of POSIX.1-2024 or this volume of
POSIX.1-2024. They are {FLT_MANT_DIG}, {DBL_MANT_DIG}, and {LDBL_MANT_DIG} for the types float, double, and long
double, respectively. If the optional c17 utility is provided by the implementation
and used as specified by this volume of POSIX.1-2024, these are the sizes that would be provided. If an option is used that
specifies different sizes for these types, there is no guarantee that the od utility is able to interpret binary data output
by such a program correctly.
This volume of POSIX.1-2024 requires that the numeric values of these lengths be recognized by the od
utility and that symbolic forms also be recognized. Thus, a conforming application can always look at an array of unsigned
long data elements using od -t uL.
The method of specifying the format for the address field based on specifying a starting offset in a file
unnecessarily tied the two together. The -A option now specifies the address base and the -S option specifies a
starting offset.
It would be difficult to break the dependence on US ASCII to achieve an internationalized utility. It does not
seem to be any harder for od to dump characters in the current locale than it is for the ed or sed l commands. The c type
specifier does this without difficulty and is completely compatible with the historical implementations of the c format
character when the current locale uses a superset of the ISO/IEC 646:1991 standard as a codeset. The a type specifier
(from the BSD a format character) was left as a portable means to dump ASCII (or more correctly ISO/IEC 646:1991
standard (IRV)) so that headers produced by pax could be deciphered even on systems that
do not use the ISO/IEC 646:1991 standard as a subset of their base codeset.
The use of "**" as an indication of continuation of a multi-byte character in c specifier output
was chosen based on seeing an implementation that uses this method. The continuation bytes have to be marked in a way that is not
ambiguous with another single-byte or multi-byte character.
An early proposal used -S and -n, respectively, for the -j and -N options eventually
selected. These were changed to avoid conflicts with historical implementations.
The original standard specified -t o2 as the default when no output type was given. This was changed to
-t oS (the length of a short) to accommodate a supercomputer implementation that historically used 64 bits as its
default (and that defined shorts as 64 bits). This change should not affect conforming applications. The requirement to support
lengths of 1, 2, and 4 was added at the same time to address an historical implementation that had no two-byte data types in its C
compiler.
The use of a basic integer data type is intended to allow the implementation to choose a word size commonly used by
applications on that architecture.
Earlier versions of this standard allowed for implementations with bytes other than eight bits, but this has been
modified in this version.
FUTURE DIRECTIONS
All option and operand interfaces marked XSI may be removed in a future version.
SEE ALSO
c17, sed
XBD 5. File Format Notation, 8. Environment Variables, 12.2
Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 2.
Issue 5
In the description of the -c option, the phrase "This is equivalent to -t c." is deleted.
The FUTURE DIRECTIONS section is modified.
Issue 6
The od utility is changed to remove the assumption that short was a two-byte entity, as per the revisions in the
IEEE P1003.2b draft standard.
The normative text is reworded to avoid use of the term "must" for application requirements.
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/33 is applied, correcting the examples which used
an undefined -n option, which should have been -N.
IEEE Std 1003.1-2001/Cor 2-2004, item XCU/TC2/D6/19 is applied, removing text describing behavior on
systems with bytes consisting of more than eight bits.
Issue 7
Austin Group Interpretation 1003.1-2001 #092 is applied.
SD5-XCU-ERN-37 is applied, updating the OPERANDS section.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
Issue 8
Austin Group Defect 1017 is applied, clarifying that when -A n is specified, the line that would contain the final
offset can either be written as an empty line or not be written.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/mkfifo.html =====
mkfifo
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mkfifo — make FIFO special files
SYNOPSIS
mkfifo [-m mode] file...
DESCRIPTION
The mkfifo utility shall create the FIFO special files specified by the operands, in the order specified.
For each file operand, the mkfifo utility shall perform actions equivalent to the mkfifo() function defined in the System Interfaces volume of POSIX.1-2024, called with the
following arguments:
The file operand is used as the path argument.
The value of the bitwise-inclusive OR of S_IRUSR, S_IWUSR, S_IRGRP, S_IWGRP, S_IROTH, and S_IWOTH is used as the mode
argument. (If the -m option is specified, the value of the mkfifo()
mode argument is unspecified, but the FIFO shall at no time have permissions less restrictive than the -m mode
option-argument.)
OPTIONS
The mkfifo utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following option shall be supported:
-m mode
Set the file permission bits of the newly-created FIFO to the specified mode value. The mode option-argument
shall be the same as the mode operand defined for the chmod utility. In the
symbolic_mode strings, the op characters '+' and '-' shall be interpreted relative to an assumed
initial mode of a=rw.
OPERANDS
The following operand shall be supported:
file
A pathname of the FIFO special file to be created.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of mkfifo:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
Not used.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
All the specified FIFO special files were created successfully.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
None.
EXAMPLES
None.
RATIONALE
This utility was added to permit shell applications to create FIFO special files.
The -m option was added to control the file mode, for consistency with the similar functionality provided by the mkdir utility.
Early proposals included a -p option similar to the mkdir -p option
that created intermediate directories leading up to the FIFO specified by the final component. This was removed because it is not
commonly needed and is not common practice with similar utilities.
The functionality of mkfifo is described substantially through a reference to the mkfifo() function in the System Interfaces volume of POSIX.1-2024. For example, by default,
the mode of the FIFO file is affected by the file mode creation mask in accordance with the specified behavior of the mkfifo() function. In this way, there is less duplication of effort required for describing
details of the file creation.
FUTURE DIRECTIONS
If this utility is directed to create a new directory entry that contains any bytes that have the encoded value of a
character, implementations are encouraged to treat this as an error. A future version of this standard may require
implementations to treat this as an error.
SEE ALSO
chmod, umask
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
XSH mkfifo()
CHANGE HISTORY
First released in Issue 3.
Issue 6
The -m option is aligned with the IEEE P1003.2b draft standard to clarify an ambiguity.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/crontab.html =====
crontab
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
crontab — schedule periodic background work
SYNOPSIS
crontab [file]
[UP] crontab [-e|-l|-r]
DESCRIPTION
The crontab utility shall create, replace, [UP]   or edit a user's crontab entry;   a crontab entry is a list of commands and the times at which they shall be executed. The new
crontab entry can be input by specifying file or input from standard input if no file operand is specified,
[UP]
or by using an editor, if -e is specified.
Upon execution of a command from a crontab entry, the implementation shall supply a default environment, defining at least the
following environment variables:
HOME
A pathname of the user's home directory.
LOGNAME
The user's login name.
PATH
A string representing a search path guaranteed to find all of the standard utilities.
SHELL
A pathname of the command interpreter. When crontab is invoked as specified by this volume of POSIX.1-2024, the value
shall be a pathname for sh.
The values of these variables when crontab is invoked as specified by this volume of POSIX.1-2024 shall not affect the
default values provided when the scheduled command is run.
If standard output and standard error are not redirected by commands executed from the crontab entry, any generated output or
errors shall be mailed, via an implementation-defined method, to the user.
[XSI]
Users shall be permitted to use crontab if their names appear in the file cron.allow which is located in an
implementation-defined directory. If that file does not exist, the file cron.deny, which is located in an
implementation-defined directory, shall be checked to determine whether the user shall be denied access to crontab. If
neither file exists, only a process with appropriate privileges shall be allowed to submit a job. If only cron.deny exists
and is empty, global usage shall be permitted. The cron.allow and cron.deny files shall consist of one user name per
line.
OPTIONS
The crontab utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-e
[UP]
Edit a copy of the invoking user's crontab entry, or create an empty entry to edit if the crontab entry does not exist. When
editing is complete, the entry shall be installed as the user's crontab entry.
-l
(The letter ell.) List the invoking user's crontab entry.
-r
Remove the invoking user's crontab entry.
OPERANDS
The following operand shall be supported:
file
The pathname of a file that contains specifications, in the format defined in the INPUT FILES section, for crontab
entries.
STDIN
See the INPUT FILES section.
INPUT FILES
In the POSIX locale, the user or application shall ensure that a crontab entry is a text file consisting of lines of six fields
each. The fields shall be separated by  characters. The first five fields shall be integer patterns that specify the
following:
Minute [0,59]
Hour [0,23]
Day of the month [1,31]
Month of the year [1,12]
Day of the week ([0,6] with 0=Sunday)
Each of these patterns can be either an  (meaning all valid values), an element, or a list of elements separated
by  characters. An element shall be either a number or two numbers separated by a  (meaning an
inclusive range). The specification of days can be made by two fields (day of the month and day of the week). If month, day of
month, and day of week are all  characters, every day shall be matched. If either the month or day of month is
specified as an element or list, but the day of week is an , the month and day of month fields shall specify the
days that match. If both month and day of month are specified as an , but day of week is an element or list, then
only the specified days of the week match. Finally, if either the month or day of month is specified as an element or list, and the
day of week is also specified as an element or list, then any day matching either the month and day of month, or the day of week,
shall be matched.
The sixth field of a line in a crontab entry is a string that shall be executed by sh
at the specified times. A  character in this field shall be translated to a . Any character
preceded by a  (including the '%') shall cause that character to be treated literally. Only the first
line (up to a '%' or end-of-line) of the command field shall be executed by the command interpreter. The other lines shall
be made available to the command as standard input.
Blank lines and those whose first non- is '#' shall be ignored.
[XSI]
The text files cron.allow and cron.deny, which are located in an implementation-defined directory, shall contain zero
or more user names, one per line, of users who are, respectively, authorized or denied access to the service underlying the
crontab utility.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of crontab:
EDITOR
Determine the editor to be invoked when the -e option is specified. The default editor shall be vi.
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
If the -l option is specified, the crontab entry shall be written to the standard output.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
The user's crontab entry is not submitted, removed, [UP]   edited,   or listed.
The following sections are informative.
APPLICATION USAGE
The format of the crontab entry shown here is guaranteed only for the POSIX locale. Other cultures may be supported with
substantially different interfaces, although implementations are encouraged to provide comparable levels of functionality.
The default settings of the HOME , LOGNAME , PATH , and SHELL variables that are given to the
scheduled job are not affected by the settings of those variables when crontab is run; as stated, they are defaults. The
text about "invoked as specified by this volume of POSIX.1-2024" means that the implementation may provide extensions that allow
these variables to be affected at runtime, but that the user has to take explicit action in order to access the extension, such as
give a new option flag or modify the format of the crontab entry.
A typical user error is to type only crontab; this causes the system to wait for the new crontab entry on standard input.
If end-of-file is typed (generally -D), the crontab entry is replaced by an empty file. In this case, the user
should type the interrupt character, which prevents the crontab entry from being replaced.
EXAMPLES
Clean up files named core every weekday morning at 3:15 am:
15 3 * * 1-5 find "$HOME" -name core -exec rm -f {} + 2>/dev/null
Mail a birthday greeting:
0 12 14 2 * mailx john%Happy Birthday!%Time for lunch.
As an example of specifying the two types of days:
0 0 1,15 * 1
would run a command on the first and fifteenth of each month, as well as on every Monday. To specify days by only one field, the
other field should be set to '*'; for example:
0 0 * * 1
would run a command only on Mondays.
RATIONALE
All references to a cron daemon and to cron files have been omitted. Although historical implementations
have used this arrangement, there is no reason to limit future implementations.
This description of crontab is designed to support only users with normal privileges. The format of the input is based on
the System V crontab; however, there is no requirement here that the actual system database used by the cron daemon
(or a similar mechanism) use this format internally. For example, systems derived from BSD are likely to have an additional field
appended that indicates the user identity to be used when the job is submitted.
The -e option was adopted from the SVID as a user convenience, although it does not exist in all historical
implementations.
FUTURE DIRECTIONS
None.
SEE ALSO
at
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 2.
Issue 6
This utility is marked as part of the User Portability Utilities option.
The normative text is reworded to avoid use of the term "must" for application requirements.
Issue 7
The crontab utility (except for the -e option) is moved from the User Portability Utilities option to the Base.
User Portability Utilities is now an option for interactive utilities.
SD5-XCU-ERN-95 is applied, removing the references to fixed locations for the files referenced by the crontab
utility.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
The first example is changed to remove the unreliable use of find | xargs.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0079 [584] is applied.
Issue 8
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1141 is applied, changing "core files" to "files named core".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/cut.html =====
cut
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cut — cut out selected fields of each line of a file
SYNOPSIS
cut -b list [-n] [file...]
cut -c list [file...]
cut -f list [-d delim] [-s] [file...]
DESCRIPTION
The cut utility shall cut out bytes (-b option), characters (-c option), or character-delimited fields
(-f option) from each line in one or more files, concatenate them, and write them to standard output.
OPTIONS
The cut utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The application shall ensure that the option-argument list (see options -b, -c, and -f below) is a
-separated list or -separated list of positive numbers and ranges. Ranges can be in three forms. The
first is two positive numbers separated by a  (low-high), which represents all fields from the
first number to the second number. The second is a positive number preceded by a  (-high), which
represents all fields from field number 1 to that number. The third is a positive number followed by a
(low-), which represents that number to the last field, inclusive. The elements in list can be repeated, can overlap,
and can be specified in any order, but the bytes, characters, or fields selected shall be written in the order of the input data.
If an element appears in the selection list more than once, it shall be written exactly once.
The following options shall be supported:
-b list
Cut based on a list of bytes. Each selected byte shall be output unless the -n option is also specified. It shall
not be an error to select bytes not present in the input line.
-c list
Cut based on a list of characters. Each selected character shall be output. It shall not be an error to select
characters not present in the input line.
-d delim
Set the field delimiter to the character delim. The default is the .
-f list
Cut based on a list of fields, assumed to be separated in the file by a delimiter character (see -d). Each
selected field shall be output. Output fields shall be separated by a single occurrence of the field delimiter character. Lines
with no field delimiters shall be passed through intact, unless -s is specified. It shall not be an error to select fields
not present in the input line.
-n
Do not split characters. When specified with the -b option, each element in list of the form
low-high (-separated numbers) shall be modified as follows:
If the byte selected by low is not the first byte of a character, low shall be decremented to select the first
byte of the character originally selected by low. If the byte selected by high is not the last byte of a character,
high shall be decremented to select the last byte of the character prior to the character originally selected by
high, or zero if there is no prior character. If the resulting range element has high equal to zero or low
greater than high, the list element shall be dropped from list for that input line without causing an error.
Each element in list of the form low- shall be treated as above with high set to the number of bytes in the
current line, not including the terminating . Each element in list of the form -high shall be treated
as above with low set to 1. Each element in list of the form num (a single number) shall be treated as above
with low set to num and high set to num.
-s
Suppress lines with no delimiter characters, when used with the -f option. Unless specified, lines with no delimiters
shall be passed through untouched.
OPERANDS
The following operand shall be supported:
file
A pathname of an input file. If no file operands are specified, or if a file operand is '-', the
standard input shall be used.
STDIN
The standard input shall be used only if no file operands are specified, or if a file operand is '-'. See
the INPUT FILES section.
INPUT FILES
The input files shall be text files, except that line lengths shall be unlimited.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of cut:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
The cut utility output shall be a concatenation of the selected bytes, characters, or fields (one of the following):
"%s\n",
"%s\n",
"%s\n",
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
All input files were output successfully.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
The cut and fold utilities can be used to create text files out of files with
arbitrary line lengths. The cut utility should be used when the number of lines (or records) needs to remain constant. The
fold utility should be used when the contents of long lines need to be kept
contiguous.
Earlier versions of the cut utility worked in an environment where bytes and characters were considered equivalent
(modulo  and  processing in some implementations). In the extended world of multi-byte characters, the
new -b option has been added. The -n option (used with -b) allows it to be used to act on bytes rounded to
character boundaries. The algorithm specified for -n guarantees that:
cut -b 1-500 -n file > file1
cut -b 501- -n file > file2
ends up with all the characters in file appearing exactly once in file1 or file2. (There is, however, a
in both file1 and file2 for each  in file.)
EXAMPLES
Examples of the option qualifier list:
1,4,7
Select the first, fourth, and seventh bytes, characters, or fields and field delimiters.
1-3,8
Equivalent to 1,2,3,8.
-5,10
Equivalent to 1,2,3,4,5,10.
3-
Equivalent to third to last, inclusive.
The low-high forms are not always equivalent when used with -b and -n and multi-byte characters; see
the description of -n.
The following command:
cut -d : -f 1,6 /etc/passwd
reads the System V password file (user database) and produces lines of the form:
:
Most utilities in this volume of POSIX.1-2024 work on text files. The cut utility can be used to turn files with
arbitrary line lengths into a set of text files containing the same data. The paste
utility can be used to create (or recreate) files with arbitrary line lengths. For example, if file contains long lines:
cut -b 1-500 -n file > file1
cut -b 501- -n file > file2
creates file1 (a text file) with lines no longer than 500 bytes (plus the ) and file2 that contains
the remainder of the data from file. (Note that file2 is not a text file if there are lines in file that are
longer than 500 + {LINE_MAX} bytes.) The original file can be recreated from file1 and file2 using the command:
paste -d "\0" file1 file2 > file
RATIONALE
Some historical implementations do not count  characters in determining character counts with the -c
option. This may be useful for using cut for processing nroff output. It was deliberately decided not to have the
-c option treat either  or  characters in any special fashion. The fold utility does treat these characters specially.
Unlike other utilities, some historical implementations of cut exit after not finding an input file, rather than
continuing to process the remaining file operands. This behavior is prohibited by this volume of POSIX.1-2024, where only
the exit status is affected by this problem.
The behavior of cut when provided with either mutually-exclusive options or options that do not work logically together
has been deliberately left unspecified in favor of global wording in 1.4 Utility
Description Defaults.
The OPTIONS section was changed in response to IEEE PASC Interpretation 1003.2 #149. The change represents historical practice
on all known systems. The original standard was ambiguous on the nature of the output.
The list option-arguments are historically used to select the portions of the line to be written, but do not affect the
order of the data. For example:
echo abcdefghi | cut -c6,2,4-7,1
yields "abdefg".
A proposal to enhance cut with the following option:
-o
Preserve the selected field order. When this option is specified, each byte, character, or field (or ranges of such) shall be
written in the order specified by the list option-argument, even if this requires multiple outputs of the same bytes,
characters, or fields.
was rejected because this type of enhancement is outside the scope of the IEEE P1003.2b draft standard.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Parameters and Variables, fold, grep, paste
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 2.
Issue 6
The OPTIONS section is changed to align with the IEEE P1003.2b draft standard.
The normative text is reworded to avoid use of the term "must" for application requirements.
Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
SD5-XCU-ERN-171 is applied, adding APPLICATION USAGE.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0080 [584] is applied.
Issue 8
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/jobs.html =====
jobs
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
jobs — display status of jobs in the current shell execution environment
SYNOPSIS
[UP]  jobs [-l|-p] [job_id...]
DESCRIPTION
If the current shell execution environment (see 2.13 Shell Execution
Environment) is not a subshell environment, the jobs utility shall display the status of background jobs that were
created in the current shell execution environment; it may also do so if the current shell execution environment is a subshell
environment.
When jobs reports the termination status of a job, the shell shall remove the job from the background jobs list and the
associated process ID from the list of those "known in the current shell execution environment"; see 2.9.3.1 Asynchronous AND-OR Lists. If a write error occurs when
jobs writes to standard output, some process IDs might have been removed from the list but not successfully reported.
OPTIONS
The jobs utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-l
(The letter ell.) Provide more information about each job listed. See STDOUT for details.
-p
Display only the process IDs for the process group leaders of job-control background jobs and the process IDs associated with
non-job-control background jobs (if supported).
By default, the jobs utility shall display the status of all background jobs, both running and suspended, and all jobs
whose status has changed and have not been reported by the shell.
OPERANDS
The following operand shall be supported:
job_id
Specifies the jobs for which the status is to be displayed. If no job_id is given, the status information for all jobs
shall be displayed. The format of job_id is described in XBD 3.182 Job
ID.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of jobs:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error and
informative messages written to standard output.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
If the -p option is specified, the output shall consist of one line for each process ID:
"%d\n",
Otherwise, if the -l option is not specified, the output shall be a series of lines of the form:
"[%d] %c %s %s\n", , , ,
where the fields shall be as follows:
The character '+' identifies the job that would be used as a default for the fg or bg utilities; this job can also be specified
using the job_id %+ or "%%". The character '-' identifies the job that would become the default if the
current default job were to exit; this job can also be specified using the job_id %-. For other jobs, this field is a
. At most one job can be identified with '+' and at most one job can be identified with '-'. If
there is any suspended job, then the current job shall be a suspended job. If there are at least two suspended jobs, then the
previous job also shall be a suspended job.
A number that can be used to identify the job to the wait, fg, bg, and kill utilities. Using these utilities, the job can be identified by prefixing the job number
with '%'.
One of the following strings (in the POSIX locale):
Running
Indicates that the job has not been suspended by a signal and has not exited.
Done
Indicates that the job completed and returned exit status zero.
Done(code)
Indicates that the job completed normally and that it exited with the specified non-zero exit status, code, expressed as
a decimal number.
Stopped
Indicates that the job was suspended by the SIGTSTP signal.
Stopped (SIGTSTP)
Indicates that the job was suspended by the SIGTSTP signal.
Stopped (SIGSTOP)
Indicates that the job was suspended by the SIGSTOP signal.
Stopped (SIGTTIN)
Indicates that the job was suspended by the SIGTTIN signal.
Stopped (SIGTTOU)
Indicates that the job was suspended by the SIGTTOU signal.
The implementation may substitute the string Suspended in place of Stopped. If the job was terminated by a signal,
the format of  is unspecified, but it shall be visibly distinct from all of the other
formats shown here and shall indicate the name or description of the signal causing the termination.
The associated command that was given to the shell.
If the -l option is specified:
For job-control background jobs, a field containing the process group ID shall be inserted before the
field. Also, more processes in a process group may be output on separate lines, using only the process ID and
fields.
For non-job-control background jobs (if supported), a field containing the process ID associated with the job shall be inserted
before the  field. Also, more processes created to execute the job may be output on separate lines, using only
the process ID and  fields.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
The output specified in STDOUT was successfully written to standard output.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
This utility is required to be intrinsic. See 1.7 Intrinsic Utilities
for details.
The -p option is the only portable way to find out the process group of a job-control background job because different
implementations have different strategies for defining the process group of the job. Usage such as $(jobs -p)
provides a way of referring to the process group of the job in an implementation-independent way.
The jobs utility does not work as expected when it is operating in its own utility execution environment because that
environment has no applicable jobs to manipulate. See the APPLICATION USAGE section for bg. For this reason, jobs is generally implemented as a shell regular built-in.
EXAMPLES
None.
RATIONALE
Both "%%" and "%+" are used to refer to the current job. Both forms are of equal validity—the "%%"
mirroring "$$" and "%+" mirroring the output of jobs. Both forms reflect historical practice of the
KornShell and the C shell with job control.
The job control features provided by bg, fg,
and jobs are based on the KornShell. The standard developers examined the characteristics of the C shell versions of these
utilities and found that differences exist. Despite widespread use of the C shell, the KornShell versions were selected for this
volume of POSIX.1-2024 to maintain a degree of uniformity with the rest of the KornShell features selected (such as the very
popular command line editing features).
The jobs utility is not dependent on job control being enabled, as are the seemingly related bg and fg utilities because jobs is useful for
examining background jobs, regardless of the current state of job control. When job control has been disabled using set +m, the jobs utility can still be used to examine the job-control
background jobs and (if supported) non-job-control background jobs that were created in the current shell execution environment.
See also the RATIONALE for kill and wait.
The output for terminated jobs is left unspecified to accommodate various historical systems. The following formats have been
witnessed:
Killed(signal name)
signal name
signal name(coredump)
signal description- core dumped
Most users should be able to understand these formats, although it means that applications have trouble parsing them.
The calculation of job IDs was not described since this would suggest an implementation, which may impose unnecessary
restrictions.
In an early proposal, a -n option was included to "Display the status of jobs that have changed, exited, or stopped
since the last status report". It was removed because the shell always writes any changed status of jobs before each prompt.
If jobs uses buffered writes to standard output, a write error could be detected when attempting to flush a buffer
containing multiple reports of terminated jobs, resulting in some unreported jobs having their process IDs removed from the list of
those known in the current shell execution environment (because they were removed when the report was added to the buffer).
FUTURE DIRECTIONS
None.
SEE ALSO
2.13 Shell Execution Environment, bg, fg, kill, wait
XBD 3.182 Job ID, 8.
Environment Variables, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 4.
Issue 6
This utility is marked as part of the User Portability Utilities option.
The JC shading is removed as job control is mandatory in this version.
Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
Issue 8
Austin Group Defect 854 is applied, adding a note to the APPLICATION USAGE section that this utility is required to be
intrinsic.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1254 is applied, updating various requirements for the jobs utility to account for the addition of
2.11 Job Control.
Austin Group Defect 1492 is applied, clarifying the requirements when a write error to standard output occurs.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/chmod.html =====
chmod
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
chmod — change the file modes
SYNOPSIS
chmod [-R] mode file...
DESCRIPTION
The chmod utility shall change any or all of the file mode bits of the file named by each file operand in the way
specified by the mode operand.
It is implementation-defined whether and how the chmod utility affects any alternate or additional file access control
mechanism (see XBD 4.7 File Access Permissions) being used for the
specified file.
Only a process whose effective user ID matches the user ID of the file, or a process with appropriate privileges, shall be
permitted to change the file mode bits of a file.
Upon successfully changing the file mode bits of a file, the chmod utility shall mark for update the last file status
change timestamp of the file.
OPTIONS
The chmod utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following option shall be supported:
-R
Recursively change file mode bits. For each file operand that names a directory, chmod shall change the file mode
bits of the directory and all files in the file hierarchy below it.
OPERANDS
The following operands shall be supported:
mode
Represents the change to be made to the file mode bits of each file named by one of the file operands; see the EXTENDED
DESCRIPTION section.
file
A pathname of a file whose file mode bits shall be modified.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of chmod:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
Not used.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
The mode operand shall be either a symbolic_mode expression or a non-negative octal integer. The
symbolic_mode form is described by the grammar later in this section.
Each clause shall specify an operation to be performed on the current file mode bits of each file. The operations
shall be performed on each file in the order in which the clauses are specified.
The who symbols u, g, and o shall specify the user, group, and other parts of
the file mode bits, respectively. A who consisting of the symbol a shall be equivalent to ugo.
The perm symbols r, w, and x represent the read, write, and
execute/search portions of file mode bits, respectively. The perm symbol s shall represent the
set-user-ID-on-execution (when who contains or implies u) and set-group-ID-on-execution (when
who contains or implies g) bits.
The perm symbol X shall represent the execute/search portion of the file mode bits if the file is a directory or
if the current (unmodified) file mode bits have at least one of the execute bits (S_IXUSR, S_IXGRP, or S_IXOTH) set. It shall be
ignored if the file is not a directory and none of the execute bits are set in the current file mode bits.
The permcopy symbols u, g, and o shall represent the current permissions associated with the user,
group, and other parts of the file mode bits, respectively. For the remainder of this section, perm refers to the
non-terminals perm and permcopy in the grammar.
If multiple actionlists are grouped with a single wholist in the grammar, each actionlist shall be applied
in the order specified with that wholist. The op symbols shall represent the operation performed, as follows:
+
If perm is not specified, the '+' operation shall not change the file mode bits.
If who is not specified, the file mode bits represented by perm for the owner, group, and other permissions,
except for those with corresponding bits in the file mode creation mask of the invoking process, shall be set.
Otherwise, the file mode bits represented by the specified who and perm values shall be set.
-
If perm is not specified, the '-' operation shall not change the file mode bits.
If who is not specified, the file mode bits represented by perm for the owner, group, and other permissions,
except for those with corresponding bits in the file mode creation mask of the invoking process, shall be cleared.
Otherwise, the file mode bits represented by the specified who and perm values shall be cleared.
=
Clear the file mode bits specified by the who value, or, if no who value is specified, all of the file mode bits
specified in this volume of POSIX.1-2024.
If perm is not specified, the '=' operation shall make no further modifications to the file mode bits.
If who is not specified, the file mode bits represented by perm for the owner, group, and other permissions,
except for those with corresponding bits in the file mode creation mask of the invoking process, shall be set.
Otherwise, the file mode bits represented by the specified who and perm values shall be set.
When using the symbolic mode form on a regular file, it is implementation-defined whether or not:
Requests to set the set-user-ID-on-execution or set-group-ID-on-execution bit when all execute bits are currently clear and none
are being set are ignored.
Requests to clear all execute bits also clear the set-user-ID-on-execution and set-group-ID-on-execution bits.
Requests to clear the set-user-ID-on-execution or set-group-ID-on-execution bits when all execute bits are currently clear are
ignored. However, if the command ls -l file writes an s in the
position indicating that the set-user-ID-on-execution or set-group-ID-on-execution is set, the commands chmod u-s
file or chmod g-s file, respectively, shall not be ignored.
When using the symbolic mode form on other file types, it is implementation-defined whether or not requests to set or clear the
set-user-ID-on-execution or set-group-ID-on-execution bits are honored.
If the who symbol o is used in conjunction with the perm symbol s with no other who symbols
being specified, the set-user-ID-on-execution and set-group-ID-on-execution bits shall not be modified. It shall not be an error to
specify the who symbol o in conjunction with the perm symbol s.
[XSI]
The perm symbol t shall specify the S_ISVTX bit. When used with a file of type directory, it can be used with the
who symbol a, or with no who symbol. It shall not be an error to specify a who symbol of u,
g, or o in conjunction with the perm symbol t, but the meaning of these combinations is unspecified.
The effect when using the perm symbol t with any file type other than directory is unspecified.
For an octal integer mode operand, the file mode bits shall be set absolutely.
For each bit set in the octal number, the corresponding file permission bit shown in the following table shall be set; all other
file permission bits shall be cleared. For regular files, for each bit set in the octal number corresponding to the
set-user-ID-on-execution or the set-group-ID-on-execution, bits shown in the following table shall be set; if these bits are not
set in the octal number, they are cleared. For other file types, it is implementation-defined whether or not requests to set or
clear the set-user-ID-on-execution or set-group-ID-on-execution bits are honored.
Octal
Mode Bit
Octal
Mode Bit
Octal
Mode Bit
Octal
Mode Bit
4000
S_ISUID
0400
S_IRUSR
0040
S_IRGRP
0004
S_IROTH
2000
S_ISGID
0200
S_IWUSR
0020
S_IWGRP
0002
S_IWOTH
1000
S_ISVTX
0100
S_IXUSR
0010
S_IXGRP
0001
S_IXOTH
When bits are set in the octal number other than those listed in the table above, the behavior is unspecified.
Grammar for chmod
The grammar and lexical conventions in this section describe the syntax for the symbolic_mode operand. The
general conventions for this style of grammar are described in 1.3 Grammar
Conventions. A valid symbolic_mode can be represented as the non-terminal symbol symbolic_mode in the
grammar. This formal syntax shall take precedence over the preceding text syntax description.
The lexical processing is based entirely on single characters. Implementations need not allow
characters within the single argument being processed.
%start    symbolic_mode
%%
symbolic_mode    : clause
| symbolic_mode ',' clause
;
clause           : actionlist
| wholist actionlist
;
wholist          : who
| wholist who
;
who              : 'u' | 'g' | 'o' | 'a'
;
actionlist       : action
| actionlist action
;
action           : op
| op permlist
| op permcopy
;
permcopy         : 'u' | 'g' | 'o'
;
op               : '+' | '-' | '='
;
permlist         : perm
| perm permlist
;
[XSI]
perm             : 'r' | 'w' | 'x' | 'X' | 's' | 't'
;
EXIT STATUS
The following exit values shall be returned:
0
The utility executed successfully and all requested changes were made.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
Some implementations of the chmod utility change the mode of a directory before the files in the directory when
performing a recursive (-R option) change; others change the directory mode after the files in the directory. If an
application tries to remove read or search permission for a file hierarchy, the removal attempt fails if the directory is changed
first; on the other hand, trying to re-enable permissions to a restricted hierarchy fails if directories are changed last. Users
should not try to make a hierarchy inaccessible to themselves.
Some implementations of chmod never used the umask of the
process when changing modes; systems conformant with this volume of POSIX.1-2024 do so when who is not specified. Note the
difference between:
chmod a-w file
which removes all write permissions, and:
chmod -- -w file
which removes write permissions that would be allowed if file was created with the same umask.
Conforming applications should never assume that they know how the set-user-ID and set-group-ID bits on directories
are interpreted.
EXAMPLES
Mode
Results
a+=
Equivalent to a+,a=; clears all file mode bits.
go+-w
Equivalent to go+,go-w; clears group and other write bits.
g=o-w
Equivalent to g=o,g-w; sets group bit to match other bits and then clears group write
bit.
g-r+w
Equivalent to g-r,g+w; clears group read bit and sets group write bit.
uo=g
Sets owner bits to match group bits and sets other bits to match group bits.
RATIONALE
The functionality of chmod is described substantially through references to concepts defined in the System Interfaces
volume of POSIX.1-2024. In this way, there is less duplication of effort required for describing the interactions of permissions.
However, the behavior of this utility is not described in terms of the chmod()
function from the System Interfaces volume of POSIX.1-2024 because that specification requires certain side-effects upon alternate
file access control mechanisms that might not be appropriate, depending on the implementation.
Implementations that support mandatory file and record locking as specified by the 1984 /usr/group standard
historically used the combination of set-group-ID bit set and group execute bit clear to indicate mandatory locking. This condition
is usually set or cleared with the symbolic mode perm symbol l instead of the perm symbols s and
x so that the mandatory locking mode is not changed without explicit indication that that was what the user intended.
Therefore, the details on how the implementation treats these conditions must be defined in the documentation. This volume of
POSIX.1-2024 does not require mandatory locking (nor does the System Interfaces volume of POSIX.1-2024), but does allow it as an
extension. However, this volume of POSIX.1-2024 does require that the ls and chmod
utilities work consistently in this area. If ls -l file indicates that the
set-group-ID bit is set, chmod g-s file must clear it (assuming appropriate privileges exist to change
modes).
The System V and BSD versions use different exit status codes. Some implementations used the exit status as a count
of the number of errors that occurred; this practice is unworkable since it can overflow the range of valid exit status values.
This problem is avoided here by specifying only 0 and >0 as exit values.
The System Interfaces volume of POSIX.1-2024 indicates that implementation-defined restrictions may cause the
S_ISUID and S_ISGID bits to be ignored. This volume of POSIX.1-2024 allows the chmod utility to choose to modify these bits
before calling chmod() (or some function providing equivalent capabilities) for
non-regular files. Among other things, this allows implementations that use the set-user-ID and set-group-ID bits on directories to
enable extended features to handle these extensions in an intelligent manner.
The X perm symbol was adopted from BSD-based systems because it provides commonly desired
functionality when doing recursive (-R option) modifications. Similar functionality is not provided by the find utility. Historical BSD versions of chmod, however, only supported X with
op+; it has been extended in this volume of POSIX.1-2024 because it is also useful with op=. (It has also been added
for op- even though it duplicates x, in this case, because it is intuitive and easier to explain.)
The grammar was extended with the permcopy non-terminal to allow historical-practice forms of symbolic modes
like o=u -g (that is, set the "other" permissions to the permissions of "owner" minus the permissions of
"group").
FUTURE DIRECTIONS
None.
SEE ALSO
ls, umask
XBD 4.7 File Access Permissions, 8. Environment Variables, 12.2
Utility Syntax Guidelines
XSH chmod()
CHANGE HISTORY
First released in Issue 2.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
Octal modes have been kept and made mandatory despite being marked obsolescent in the ISO POSIX-2:1993
standard.
IEEE PASC Interpretation 1003.2 #172 is applied, changing the CONSEQUENCES OF ERRORS section to "Default.".
The Open Group Base Resolution bwg2001-010 is applied, adding the description of the S_ISVTX bit and the
t perm symbol as part of the XSI option.
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/16 is applied, changing the XSI shaded text in the
EXTENDED DESCRIPTION from:
"The perm symbol t shall specify the S_ISVTX bit and shall apply to directories only. The effect when
using it with any other file type is unspecified. It can be used with the who symbols o, a, or with no
who symbol. It shall not be an error to specify a who symbol of u or g in conjunction with the
perm symbol t; it shall be ignored for u and g."
to:
"The perm symbol t shall specify the S_ISVTX bit. When used with a file of type directory, it can be
used with the who symbol a, or with no who symbol. It shall not be an error to specify a who symbol of
u, g, or o in conjunction with the perm symbol t, but the meaning of these combinations is
unspecified. The effect when using the perm symbol t with any file type other than directory is
unspecified."
This change is to permit historical behavior.
Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
Austin Group Interpretation 1003.1-2001 #130 is applied, adding text to the DESCRIPTION about about marking for
update the last file status change timestamp of the file.
Issue 8
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/localedef.html =====
localedef
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
localedef — define locale environment
SYNOPSIS
localedef [-c] [-f charmap] [-i sourcefile]
[-u code_set_name] name
DESCRIPTION
The localedef utility shall convert source definitions for locale categories into a format usable by the functions and
utilities whose operational behavior is determined by the setting of the locale environment variables defined in XBD 7. Locale. It is implementation-defined whether users have the capability to create
new locales, in addition to those supplied by the implementation. If the symbolic constant POSIX2_LOCALEDEF is defined, the system
supports the creation of new locales. [XSI]   On XSI-conformant systems, the symbolic constant POSIX2_LOCALEDEF shall be defined.
The utility shall read source definitions for one or more locale categories belonging to the same locale from the file named in
the -i option (if specified) or from standard input.
The name operand identifies the target locale. The utility shall support the creation of public, or generally
accessible locales, as well as private, or restricted-access locales. Implementations may restrict the capability to create
or modify public locales to users with appropriate privileges.
Each category source definition shall be identified by the corresponding environment variable name and terminated by an
END category-name statement. The following categories shall be supported. In addition, the input may contain source
for implementation-defined categories.
LC_CTYPE
Defines character classification and case conversion.
LC_COLLATE
Defines collation rules.
LC_MONETARY
Defines the format and symbols used in formatting of monetary information.
LC_NUMERIC
Defines the decimal delimiter, grouping, and grouping symbol for non-monetary numeric editing.
LC_TIME
Defines the format and content of date and time information.
LC_MESSAGES
Defines the format and values of affirmative and negative responses.
If the LC_COLLATE category defines a collation sequence that does not have a total ordering of all characters,
localedef shall write a warning message to standard error and, if the exit status would otherwise have been zero, shall exit
with status 1.
OPTIONS
The localedef utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-c
Create permanent output even if warning messages have been issued.
-f charmap
Specify the pathname of a file containing a mapping of character symbols and collating element symbols to actual character
encodings. The format of the charmap is described in XBD 6.4 Character Set
Description File. The application shall ensure that this option is specified if symbolic names (other than collating
symbols defined in a collating-symbol keyword) are used. If the -f option is not present, an implementation-defined
character mapping shall be used.
-i inputfile
The pathname of a file containing the source definitions. If this option is not present, source definitions shall be read from
standard input. The format of the inputfile is described in XBD 7.3 Locale
Definition.
-u code_set_name
Specify the name of a codeset used as the target mapping of character symbols and collating element symbols whose encoding values
are defined in terms of the ISO/IEC 10646-1:2020 standard position constant values.
OPERANDS
The following operand shall be supported:
name
Identifies the locale; see XBD 7. Locale for a description of the use of
this name. If the name contains one or more  characters, name shall be interpreted as a pathname where the
created locale definitions shall be stored. If name does not contain any  characters, the interpretation of the
name is implementation-defined and the locale shall be public. The ability to create public locales in this way may be restricted
to users with appropriate privileges. (As a consequence of specifying one name, although several categories can be processed
in one execution, only categories belonging to the same locale can be processed.)
STDIN
Unless the -i option is specified, the standard input shall be a text file containing one or more locale category source
definitions, as described in XBD 7.3 Locale Definition. When lines are
continued using the escape character mechanism, there is no limit to the length of the accumulated continued line.
INPUT FILES
The character set mapping file specified as the charmap option-argument is described in XBD 6.4 Character Set Description File. If a locale category source definition
contains a copy statement, as defined in XBD 7. Locale, and the
copy statement names a valid, existing locale, then localedef shall behave as if the source definition had contained
a valid category source definition for the named locale.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of localedef:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_COLLATE
(This variable has no affect on localedef; the POSIX locale is used for this category.)
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files). This variable has no affect on the processing of localedef
input data; the POSIX locale is used for this purpose, regardless of the value of this variable.
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
The utility shall report all categories successfully processed, in an unspecified format.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
The format of the created output is unspecified. If the name operand does not contain a , the existence of
an output file for the locale is unspecified.
EXTENDED DESCRIPTION
When the -u option is used, the code_set_name option-argument shall be interpreted as an implementation-defined
name of a codeset to which the ISO/IEC 10646-1:2020 standard position constant values shall be converted via an
implementation-defined method. Both the ISO/IEC 10646-1:2020 standard position constant values and other formats (decimal,
hexadecimal, or octal) shall be valid as encoding values within the charmap file. The codeset represented by the
implementation-defined name can be any codeset that is supported by the implementation.
When conflicts occur between the charmap specification of , , or
and the implementation-defined interpretation of these respective items for the codeset represented by
the -u option-argument code_set_name, the result is unspecified.
When conflicts (including omissions) occur between the charmap encoding values specified for symbolic names of characters
of the portable character set and the implementation-defined assignment of character encoding values, the result is unspecified. If
the result is that localedef creates the specified locale, any attempted use of that locale by an application or utility
results in undefined behavior.
If a non-printable character in the charmap has a width specified that is not -1, the result is undefined.
EXIT STATUS
The following exit values shall be returned:
0
No errors occurred and the locales were successfully created.
1
Warnings occurred and the locales were successfully created.
2
The locale specification exceeded implementation limits or the coded character set or sets used were not supported by the
implementation, and no locale was created.
3
The capability to create new locales is not supported by the implementation.
>3
Warnings or errors occurred and no output was created.
CONSEQUENCES OF ERRORS
If an error is detected, no permanent output shall be created.
If warnings occur, permanent output shall be created if the -c option was specified. The following conditions shall cause
warning messages to be issued:
If a symbolic name not found in the charmap file is used for the descriptions of the LC_CTYPE or LC_COLLATE
categories (for other categories, this shall be an error condition).
If the number of operands to the order keyword exceeds the {COLL_WEIGHTS_MAX} limit.
If optional keywords not supported by the implementation are present in the source.
Other implementation-defined conditions may also cause warnings.
The following sections are informative.
APPLICATION USAGE
The charmap definition is optional, and is contained outside the locale definition. This allows both completely
self-defined source files, and generic sources (applicable to more than one codeset). To aid portability, all charmap
definitions must use the same symbolic names for the portable character set. As explained in XBD 6.4 Character Set Description File, it is implementation-defined whether or not
users or applications can provide additional character set description files. Therefore, the -f option might be operable
only when an implementation-defined charmap is named.
EXAMPLES
None.
RATIONALE
The output produced by the localedef utility is implementation-defined. The name operand is used to identify the
specific locale. (As a consequence, although several categories can be processed in one execution, only categories belonging to the
same locale can be processed.)
When conflicts (including omissions) occur between the charmap encoding values specified for symbolic names of characters
of the portable character set and the implementation-defined assignment of character encoding values, it is recommended that
localedef treats this as an error in order to prevent the undefined behavior that results if localedef creates the
specified locale and an application or utility attempts to use it.
FUTURE DIRECTIONS
If this utility is directed to create a new directory entry that contains any bytes that have the encoded value of a
character, implementations are encouraged to treat this as an error. A future version of this standard may require
implementations to treat this as an error.
SEE ALSO
locale
XBD 6.4 Character Set Description File, 7. Locale, 8. Environment
Variables, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 4.
Issue 6
The -u option is added, as specified in the IEEE P1003.2b draft standard.
The normative text is reworded to avoid use of the term "must" for application requirements.
IEEE Std 1003.1-2001/Cor 2-2004, item XCU/TC2/D6/15 is applied, rewording text in the OPERANDS section describing
the ability to create public locales.
IEEE Std 1003.1-2001/Cor 2-2004, item XCU/TC2/D6/16 is applied, making the text consistent with the descriptions
of WIDTH and WIDTH_DEFAULT in the Base Definitions volume of POSIX.1-2024.
Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defect 1070 is applied, requiring that localedef issues a warning if the LC_COLLATE category defines
a collation sequence that does not have a total ordering of all characters.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1609 is applied, clarifying the behavior when conflicts (including omissions) occur between the
charmap encoding values specified for symbolic names of characters of the portable character set and the
implementation-defined assignment of character encoding values.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/logname.html =====
logname
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
logname — return the user's login name
SYNOPSIS
logname
DESCRIPTION
The logname utility shall write the user's login name to standard output. The login name shall be the string that would
be returned by the getlogin() function defined in the System Interfaces volume of
POSIX.1-2024. Under the conditions where the getlogin() function would fail, the
logname utility shall write a diagnostic message to standard error and exit with a non-zero exit status.
OPTIONS
None.
OPERANDS
None.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of logname:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
The logname utility output shall be a single line consisting of the user's login name:
"%s\n",
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
The logname utility explicitly ignores the LOGNAME environment variable because environment changes could produce
erroneous results.
EXAMPLES
None.
RATIONALE
The passwd file is not listed as required because the implementation may have other means of mapping login names.
FUTURE DIRECTIONS
None.
SEE ALSO
id, who
XBD 8. Environment Variables
XSH getlogin()
CHANGE HISTORY
First released in Issue 2.
Issue 8
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/val.html =====
val
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
val — validate SCCS files (DEVELOPMENT)
SYNOPSIS
[XSI]  val -
val [-s] [-m name] [-r SID] [-y
type] file...
DESCRIPTION
The val utility shall determine whether the specified file is an SCCS file meeting the characteristics specified
by the options.
OPTIONS
The val utility shall conform to XBD 12.2 Utility Syntax
Guidelines, except that the usage of the '-' operand is not strictly as intended by the guidelines (that is,
reading options and operands from standard input).
The following options shall be supported:
-m name
Specify a name, which is compared with the SCCS %M% keyword in file; see get.
-r SID
Specify a SID (SCCS Identification String), an SCCS delta number. A check shall be made to determine whether the
SID is ambiguous (for example, -r 1 is ambiguous because it physically does not exist but implies 1.1, 1.2, and
so on, which may exist) or invalid (for example, -r 1.0 or -r 1.1.0 are invalid because neither case can
exist as a valid delta number). If the SID is valid and not ambiguous, a check shall be made to determine whether it
actually exists.
-s
Silence the diagnostic message normally written to standard output for any error that is detected while processing each named
file on a given command line.
-y type
Specify a type, which shall be compared with the SCCS %Y% keyword in file; see get.
OPERANDS
The following operands shall be supported:
file
A pathname of an existing SCCS file. If exactly one file operand appears, and it is '-', the standard input
shall be read: each line shall be independently processed as if it were a command line argument list. (However, the line is not
subjected to any of the shell word expansions, such as parameter expansion or quote removal.)
STDIN
The standard input shall be a text file used only when the file operand is specified as '-'.
INPUT FILES
Any SCCS files processed shall be files of an unspecified format.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of val:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error, and
informative messages written to standard output.
NLSPATH
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
The standard output shall consist of informative messages about either:
Each file processed
Each command line read from standard input
If the standard input is not used, for each file operand yielding a discrepancy, the output line shall have the following
format:
"%s: %s\n", ,
If the standard input is used, for each input line yielding a discrepancy, the output shall have the following format:
"%s\n\n %s: %s\n", , ,
where  is the input line minus its terminating .
STDERR
Not used.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The 8-bit code returned by val shall be a disjunction of the possible errors; that is, it can be interpreted as a bit
string where set bits are interpreted as follows:
0x80
=
Missing file argument.
0x40
=
Unknown or duplicate option.
0x20
=
Corrupted SCCS file.
0x10
=
Cannot open file or file not SCCS.
0x08
=
SID is invalid or ambiguous.
0x04
=
SID does not exist.
0x02
=
%Y%, -y mismatch.
0x01
=
%M%, -m mismatch.
Note that val can process two or more files on a given command line and can process multiple command lines
(when reading the standard input). In these cases an aggregate code shall be returned: a logical OR of the codes generated for each
command line and file processed.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
Since the val exit status sets the 0x80 bit, shell applications checking "$?" cannot tell if it terminated due
to a missing file argument or receipt of a signal.
EXAMPLES
In a directory with three SCCS files—s.x (of t type "text"), s.y, and s.z (a corrupted file)—the
following command could produce the output shown:
val -
character when  is a terminator or separator in the output format being used, implementations are encouraged to
treat this as an error. A future version of this standard may require implementations to treat this as an error.
SEE ALSO
admin, delta, get, prs
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 2.
Issue 6
The Open Group Corrigendum U025/4 is applied, correcting a typographical error in the EXIT STATUS.
Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0147 [416] and XCU/TC1-2008/0148 [416] are applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to report an error if a utility is directed to display a
pathname that contains any bytes that have the encoded value of a  character when  is a terminator or
separator in the output format being used.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/unget.html =====
unget
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
unget — undo a previous get of an SCCS file (DEVELOPMENT)
SYNOPSIS
[XSI]  unget [-ns] [-r SID] file...
DESCRIPTION
The unget utility shall reverse the effect of a get -e done prior to
creating the intended new delta.
OPTIONS
The unget utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-r SID
Uniquely identify which delta is no longer intended. (This would have been specified by get as the new delta.) The use of this option is necessary only if two or more outstanding
get commands for editing on the same SCCS file were done by the same person (login
name).
-s
Suppress the writing to standard output of the intended delta's SID.
-n
Retain the file that was obtained by get, which would normally be removed from the
current directory.
OPERANDS
The following operands shall be supported:
file
A pathname of an existing SCCS file or a directory. If file is a directory, the unget utility shall behave as
though each file in the directory were specified as a named file, except that non-SCCS files (last component of the pathname does
not begin with s.) and unreadable files shall be silently ignored.
If exactly one file operand appears, and it is '-', the standard input shall be read; each line of the standard
input shall be taken to be the name of an SCCS file to be processed. Non-SCCS files and unreadable files shall be silently
ignored.
STDIN
The standard input shall be a text file used only when the file operand is specified as '-'. Each line of the
text file shall be interpreted as an SCCS pathname.
INPUT FILES
Any SCCS files processed shall be files of an unspecified format.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of unget:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
The standard output shall consist of a line for each file, in the following format:
"%s\n",
If there is more than one named file or if a directory or standard input is named, each pathname shall be written before each of
the preceding lines:
"\n%s:\n",
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
Any SCCS files updated shall be files of an unspecified format. During processing of a file, a locking z-file, as
described in get, and a q-file (a working copy of the p-file), may be
created and deleted. The p-file and g-file, as described in get, shall be
deleted.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
None.
EXAMPLES
None.
RATIONALE
None.
FUTURE DIRECTIONS
If this utility is directed to create a new directory entry that contains any bytes that have the encoded value of a
character, implementations are encouraged to treat this as an error. A future version of this standard may require
implementations to treat this as an error.
SEE ALSO
delta, get, sact
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 2.
Issue 6
The normative text is reworded to avoid use of the term "must" for application requirements.
Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/continue.html =====
Shell Command Language
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
Please enable javascript in your browser to automatically redirect to the target page, otherwise select the link below.
2.15 Special Built-In Utilities
break
colon
continue
dot
eval
exec
exit
export
readonly
return
set
shift
times
trap
unset
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
===== susv5-html/utilities/readlink.html =====
readlink
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
readlink — display the contents of a symbolic link
SYNOPSIS
readlink [-n] file
DESCRIPTION
If the file operand names a symbolic link, the readlink utility shall not follow the symbolic link when resolving
file and shall write the contents of the symbolic link to standard output. If the -n option is not specified, the
output to standard output shall be followed by a  character.
If file does not name a symbolic link, readlink shall write a diagnostic message to standard error and exit with
non-zero status.
OPTIONS
The readlink utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following option shall be supported:
-n
Do not output a trailing  character.
OPERANDS
The following operand shall be supported:
file
A pathname of a symbolic link to be read.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of readlink:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
See DESCRIPTION.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
None.
EXAMPLES
None.
RATIONALE
The readlink utility was added because using ls -l to obtain the
contents of a symbolic link is difficult if the output includes more than one occurrence of the string " -> ".
The -f option found in many implementations was not included, as the realpath utility provides equivalent functionality with a choice of behaviors.
FUTURE DIRECTIONS
None.
SEE ALSO
ln, ls, realpath
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
XSH readlink()
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/asa.html =====
asa
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
asa — interpret carriage-control characters
SYNOPSIS
[FR]  asa [file...]
DESCRIPTION
The asa utility shall write its input files to standard output, mapping carriage-control characters from the text files
to line-printer control sequences in an implementation-defined manner.
The first character of every line shall be removed from the input, and the following actions are performed.
If the character removed is:
The rest of the line is output without change.
0
A  is output, then the rest of the input line.
1
One or more implementation-defined characters that causes an advance to the next page shall be output, followed by the rest of
the input line.
+
The  of the previous line shall be replaced with one or more implementation-defined characters that causes
printing to return to column position 1, followed by the rest of the input line. If the '+' is the first character in the
input, it shall be equivalent to .
The action of the asa utility is unspecified upon encountering any character other than those listed above as the first
character in a line.
OPTIONS
None.
OPERANDS
file
A pathname of a text file used for input. If no file operands are specified, the standard input shall be used.
STDIN
The standard input shall be used if no file operands are specified, and shall be used if a file operand is
'-' and the implementation treats the '-' as meaning standard input. Otherwise, the standard input shall not be
used. See the INPUT FILES section.
INPUT FILES
The input files shall be text files.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of asa:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
The standard output shall be the text from the input file modified as described in the DESCRIPTION section.
STDERR
None.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
All input files were output successfully.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
None.
EXAMPLES
The following command:
asa file
permits the viewing of file (created by a program using FORTRAN-style carriage-control characters) on a terminal.
The following command:
a.out | asa | lp
formats the FORTRAN output of a.out and directs it to the printer.
RATIONALE
The asa utility is needed to map "standard" FORTRAN 77 output into a form acceptable to contemporary printers. Usually,
asa is used to pipe data to the lp utility; see lp.
This utility is generally used only by FORTRAN programs. The standard developers decided to retain asa to avoid breaking
the historical large base of FORTRAN applications that put carriage-control characters in their output files. There is no
requirement that a system have a FORTRAN compiler in order to run applications that need asa.
Historical implementations have used an ASCII  in response to a 1 and an ASCII  in
response to a '+'. It is suggested that implementations treat characters other than 0, 1, and '+' as
in the absence of any compelling reason to do otherwise. However, the action is listed here as "unspecified",
permitting an implementation to provide extensions to access fast multiple-line slewing and channel seeking in a non-portable
manner.
FUTURE DIRECTIONS
None.
SEE ALSO
lp
XBD 8. Environment Variables
CHANGE HISTORY
First released in Issue 4.
Issue 6
This utility is marked as part of the FORTRAN Runtime Utilities option.
The normative text is reworded to avoid use of the term "must" for application requirements.
Issue 7
Austin Group Interpretation 1003.1-2001 #092 is applied.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
Issue 8
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/ar.html =====
ar
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ar — create and maintain library archives
SYNOPSIS
[SD]  ar -d [-v] archive file...
[XSI]  ar -m [-v] archive file...
ar -m -a [-v] posname archive file...
ar -m -b [-v] posname archive file...
ar -m -i [-v] posname archive file...
[XSI] ar -p [-v] [-s] archive
[file...]
[XSI]  ar -q [-cv] archive file...
ar -r [-cuv] archive file...
[XSI]  ar -r -a [-cuv] posname archive file...
ar -r -b [-cuv] posname archive file...
ar -r -i [-cuv] posname archive file...
[XSI] ar -t [-v] [-s] archive
[file...]
[XSI] ar -x [-v] [-sCT] archive
[file...]
DESCRIPTION
The ar utility is part of the Software Development Utilities option.
The ar utility can be used to create and maintain groups of files combined into an archive. Once an archive has been
created, new files can be added, and existing files in an archive can be extracted, deleted, or replaced. When an archive consists
entirely of valid object files, the implementation shall format the archive so that it is usable as a library for link editing (see
c17). When some of the archived files are not valid object files, the suitability of the
archive for library use is undefined. [XSI]   If an archive consists entirely of printable files, the entire archive shall be
printable.
When ar creates an archive, it creates administrative information indicating whether a symbol table is present in the
archive. When there is at least one object file that ar recognizes as such in the archive, an archive symbol table shall be
created in the archive and maintained by ar; it is used by the link editor to search the archive. Whenever the ar
utility is used to create or update the contents of such an archive, the symbol table shall be rebuilt. The -s option shall
force the symbol table to be rebuilt.
All file operands can be pathnames. However, files within archives shall be named by a filename, which is the last
component of the pathname used when the file was entered into the archive. The comparison of file operands to the names of
files in archives shall be performed by comparing the last component of the operand to the name of the file in the archive.
It is unspecified whether multiple files in the archive may be identically named. In the case of such files, however, each
file [XSI]   and posname  operand shall match only the
first file in the archive having a name that is the same as the last component of the operand.
OPTIONS
The ar utility shall conform to XBD 12.2 Utility Syntax
Guidelines, except for Guideline 9.
The following options shall be supported:
-a
[XSI]
Position new files in the archive after the file named by the posname operand.
-b
[XSI]
Position new files in the archive before the file named by the posname operand.
-c
Suppress the diagnostic message that is written to standard error by default when the archive archive is created.
-C
[XSI]
Prevent extracted files from replacing like-named files in the file system. This option is useful when -T is also used, to
prevent truncated filenames from replacing files with the same prefix.
-d
Delete one or more files from archive.
-i
[XSI]
Position new files in the archive before the file in the archive named by the posname operand (equivalent to -b).
-m
[XSI]
Move the named files in the archive. The -a, -b, or -i options with the posname operand indicate the
position; otherwise, move the names files in the archive to the end of the archive.
-p
Write the contents of the files in the archive named by file operands from archive to the standard output.
If no file operands are specified, the contents of all files in the archive shall be written in the order of the
archive.
-q
[XSI]
Append the named files to the end of the archive. In this case ar does not check whether the added files are already in the
archive. This is useful to bypass the searching otherwise done when creating a large archive piece by piece.
-r
Replace or add files to archive. If the archive named by archive does not exist, a new archive shall be
created and a diagnostic message shall be written to standard error (unless the -c option is specified). If no files
are specified and the archive exists, the results are undefined. Files that replace existing files in the archive shall not
change the order of the archive. Files that do not replace existing files in the archive shall be appended to the archive
[XSI]
unless a -a, -b, or -i option specifies another position.
-s
[XSI]
Force the regeneration of the archive symbol table even if ar is not invoked with an option that modifies the archive
contents. This option is useful to restore the archive symbol table after it has been stripped; see strip.
-t
Write a table of contents of archive to the standard output. Only the files specified by the file operands shall
be included in the written list. If no file operands are specified, all files in archive shall be included in the
order of the archive.
-T
[XSI]
Allow filename truncation of extracted files whose archive names are longer than the file system can support. By default,
extracting a file with a name that is too long shall be an error; a diagnostic message shall be written and the file shall not be
extracted.
-u
Update older files in the archive. When used with the -r option, files in the archive shall be replaced only if the
corresponding file has a modification time that is at least as new as the modification time of the file in the archive.
-v
Give verbose output. When used with the option characters -d, -r, or -x, write a detailed file-by-file
description of the archive creation and maintenance activity, as described in the STDOUT section.
When used with -p, write the name of the file in the archive to the standard output before writing the file in the
archive itself to the standard output, as described in the STDOUT section.
When used with -t, include a long listing of information about the files in the archive, as described in the STDOUT
section.
-x
Extract the files in the archive named by the file operands from archive. The contents of the archive shall not
be changed. If no file operands are given, all files in the archive shall be extracted. The modification time of each file
extracted shall be set to the time the file is extracted from the archive.
OPERANDS
The following operands shall be supported:
archive
A pathname of the archive.
file
A pathname. Only the last component shall be used when comparing against the names of files in the archive. If two or more
file operands have the same last pathname component (basename), the results are unspecified. The implementation's archive
format shall not truncate valid filenames of files added to or replaced in the archive.
posname
[XSI]
The name of a file in the archive, used for relative positioning; see options -m and -r.
STDIN
Not used.
INPUT FILES
The archive named by archive shall be a file in the format created by ar -r.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of ar:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
LC_TIME
Determine the format and content for date and time strings written by ar -tv.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
TMPDIR
Determine the pathname that overrides the default directory for temporary files, if any.
TZ
Determine the timezone used to calculate date and time strings written by ar -tv. If TZ is unset or null,
an unspecified default timezone shall be used.
ASYNCHRONOUS EVENTS
Default.
STDOUT
If the -d option is used with the -v option, the standard output format shall be:
"d - %s\n",
where file is the operand specified on the command line.
If the -p option is used with the -v option, ar shall precede the contents of each file with:
"\n\n\n",
where file is the operand specified on the command line, if file operands were specified, and the name of the file
in the archive if they were not.
If the -r option is used with the -v option:
If file is already in the archive, the standard output format shall be:
"r - %s\n",
where  is the operand specified on the command line.
If file is not already in the archive, the standard output format shall be:
"a - %s\n",
where  is the operand specified on the command line.
If the -t option is used, ar shall write the names of the files in the archive to the standard output in the
format:
"%s\n",
where file is the operand specified on the command line, if file operands were specified, or the name of the file
in the archive if they were not.
If the -t option is used with the -v option, the standard output format shall be:
"%s %u/%u %u %s %d %d:%d %d %s\n", , ,
, ,
, , ,
, ,
where:
Shall be the operand specified on the command line, if file operands were specified, or the name of the file in the
archive if they were not.
Shall be formatted the same as the  string defined in the STDOUT section of ls, except that the first character, the , is not used; the string
represents the file mode of the file in the archive at the time it was added to or replaced in the archive.
The following represent the last-modification time of a file when it was most recently added to or replaced in the archive:
Equivalent to the format of the %b conversion specification format in date.
Equivalent to the format of the %e conversion specification format in date.
Equivalent to the format of the %H conversion specification format in date.
Equivalent to the format of the %M conversion specification format in date.
Equivalent to the format of the %Y conversion specification format in date.
When LC_TIME does not specify the POSIX locale, a different format and order of presentation of these fields relative to
each other may be used in a format appropriate in the specified locale.
If the -x option is used with the -v option, the standard output format shall be:
"x - %s\n",
where file is the operand specified on the command line, if file operands were specified, or the name of the file
in the archive if they were not.
STDERR
The standard error shall be used only for diagnostic messages. The diagnostic message about creating a new archive when
-c is not specified shall not modify the exit status.
OUTPUT FILES
Archives are files with unspecified formats.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
None.
EXAMPLES
None.
RATIONALE
The archive format is not described. It is recognized that there are several known ar formats, which are not compatible.
The ar utility is included, however, to allow creation of archives that are intended for use only on one machine. The
archive is specified as a file, and it can be moved as a file. This does allow an archive to be moved from one machine to another
machine that uses the same implementation of ar.
Utilities such as pax (and its forebears tar and cpio) also provide
portable "archives". This is a not a duplication; the ar utility is included to provide an interface primarily for
make and the compilers, based on a historical model.
In historical implementations, the -q option (available on XSI-conforming systems) is known to execute quickly because
ar does not check on whether the added members are already in the archive. This is useful to bypass the searching otherwise
done when creating a large archive piece-by-piece. These remarks may but need not remain true for a brand new implementation of
this utility; hence, these remarks have been moved into the RATIONALE.
BSD implementations historically required applications to provide the -s option whenever the archive was supposed to
contain a symbol table. As in this volume of POSIX.1-2024, System V historically creates or updates an archive symbol table
whenever an object file is removed from, added to, or updated in the archive.
The OPERANDS section requires what might seem to be true without specifying it: the archive cannot truncate the filenames below
{NAME_MAX}. Some historical implementations do so, however, causing unexpected results for the application. Therefore, this volume
of POSIX.1-2024 makes the requirement explicit to avoid misunderstandings.
According to the System V documentation, the options -dmpqrtx are not required to begin with a
('-'). This volume of POSIX.1-2024 requires that a conforming application use the leading .
The archive format used by the 4.4 BSD implementation is documented in this RATIONALE as an example:
A file created by ar begins with the "magic" string "!\n". The rest of the archive is
made up of objects, each of which is composed of a header for a file, a possible filename, and the file contents. The header is
portable between machine architectures, and, if the file contents are printable, the archive is itself printable.
The header is made up of six ASCII fields, followed by a two-character trailer. The fields are the object name (16 characters),
the file last modification time (12 characters), the user and group IDs (each 6 characters), the file mode (8 characters), and the
file size (10 characters). All numeric fields are in decimal, except for the file mode, which is in octal.
The modification time is the file st_mtime field. The user and group IDs are the file st_uid and st_gid
fields. The file mode is the file st_mode field. The file size is the file st_size field. The two-byte trailer is the
string "`".
Only the name field has any provision for overflow. If any filename is more than 16 characters in length or contains an embedded
space, the string "#1/" followed by the ASCII length of the name is written in the name field. The file size (stored in
the archive header) is incremented by the length of the name. The name is then written immediately following the archive
header.
Any unused characters in any of these fields are written as  characters. If any fields are their particular maximum
number of characters in length, there is no separation between the fields.
Objects in the archive are always an even number of bytes long; files that are an odd number of bytes long are padded with a
, although the size in the header does not reflect this.
The ar utility description requires that (when all its members are valid object files) ar produce an object code
library, which the linkage editor can use to extract object modules. If the linkage editor needs a symbol table to permit random
access to the archive, ar must provide it; however, ar does not require a symbol table.
The BSD -o option was omitted. It is a rare conforming application that uses ar to extract object code from a
library with concern for its modification time, since this can only be of importance to make. Hence, since this functionality is not deemed important for applications portability, the
modification time of the extracted files is set to the current time.
There is at least one known implementation (for a small computer) that can accommodate only object files for that system,
disallowing mixed object and other files. The ability to handle any type of file is not only historical practice for most
implementations, but is also a reasonable expectation.
Consideration was given to changing the output format of ar -tv to the same format as the output of ls -l. This would have made parsing the output of ar the same as that of ls. This was rejected in part because the current ar format is commonly used and changes
would break historical usage. Second, ar gives the user ID and group ID in numeric format separated by a .
Changing this to be the user name and group name would not be correct if the archive were moved to a machine that contained a
different user database. Since ar cannot know whether the archive was generated on the same machine, it cannot tell what to
report.
The text on the -ur option combination is historical practice—since one filename can easily represent two different files
(for example, /a/foo and /b/foo), it is reasonable to replace the file in the archive even when the modification time
in the archive is identical to that in the file system.
FUTURE DIRECTIONS
If this utility is directed to display a pathname that contains any bytes that have the encoded value of a
character when  is a terminator or separator in the output format being used, implementations are encouraged to
treat this as an error. A future version of this standard may require implementations to treat this as an error.
If this utility is directed to create a new directory entry that contains any bytes that have the encoded value of a
character, implementations are encouraged to treat this as an error. A future version of this standard may require
implementations to treat this as an error.
SEE ALSO
c17, date, pax, strip
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines, , description of {POSIX_NO_TRUNC}
CHANGE HISTORY
First released in Issue 2.
Issue 5
The FUTURE DIRECTIONS section is added.
Issue 6
This utility is marked as part of the Software Development Utilities option.
The STDOUT description is changed for the -v option to align with the IEEE P1003.2b draft standard.
The normative text is reworded to avoid use of the term "must" for application requirements.
The TZ entry is added to the ENVIRONMENT VARIABLES section.
IEEE PASC Interpretation 1003.2 #198 is applied, changing the description to consistently use "file" to refer to a file in the
file system hierarchy, "archive" to refer to the archive being operated upon by the ar utility, and "file in the
archive" to refer to a copy of a file that is contained in the archive.
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/10 is applied, making corrections to the SYNOPSIS. The change
was needed since the -a, -b, and -i options are mutually-exclusive, and posname is required if any of
these options is specified.
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/11 is applied, correcting the description of the two-byte
trailer in RATIONALE which had missed out a backquote. The correct trailer is a backquote followed by a .
Issue 7
SD5-XCU-ERN-6 is applied, clarifying that Guideline 9 of the Utility Syntax Guidelines does not apply.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
The description of the -t option is changed to say "Only the files specified ...".
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0057 [584] is applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to behave as follows:
Report an error if a utility is directed to display a pathname that contains any bytes that have the encoded value of a
character when  is a terminator or separator in the output format being used.
Disallow the creation of filenames containing any bytes that have the encoded value of a  character.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/uudecode.html =====
uudecode
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
uudecode — decode a binary file
SYNOPSIS
uudecode [-o outfile] [file]
DESCRIPTION
The uudecode utility shall read a file, or standard input if no file is specified, that includes data created by the
uuencode utility. The uudecode utility shall scan the input file, searching
for data compatible with one of the formats specified in uuencode, and determine
the pathname for the output file from the -o option if given, otherwise from the input data. If the pathname for the output
file is either of the magic cookies - or /dev/stdout, uudecode shall write the decoded file to standard
output, otherwise it shall attempt to create or overwrite the file named by the pathname. The file access permission bits and
contents for the file to be produced shall be contained in the input data. The mode bits of the created file (other than standard
output) shall be set from the file access permission bits contained in the data; that is, other attributes of the mode, including
the file mode creation mask (see umask), shall not affect the file being produced. If
either of the op characters '+' and '-' (see chmod) are
specified in symbolic mode, the initial mode on which those operations are based is unspecified.
If the pathname of the file resolves to an existing file and the user does not have write permission on that file,
uudecode shall terminate with an error. If the pathname of the file resolves to an existing file and the user has write
permission on that file, the existing file shall be overwritten and, if possible, the mode bits of the file (other than standard
output) shall be set as described above; if the mode bits cannot be set, uudecode shall not treat this as an error.
If the input data was produced by uuencode on a system with a different number
of bits per byte than on the target system, the results of uudecode are unspecified.
OPTIONS
The uudecode utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following option shall be supported by the implementation:
-o outfile
A pathname of a file that shall be used instead of any pathname contained in the input data. Specifying an outfile
option-argument of - or /dev/stdout shall indicate standard output.
OPERANDS
The following operand shall be supported:
file
The pathname of a file containing the output of uuencode.
STDIN
See the INPUT FILES section.
INPUT FILES
The input files shall be files containing the output of uuencode.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of uudecode:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
If the pathname specified for the output file is - or /dev/stdout, the standard output shall be in the same format
as the file originally encoded by uuencode. Otherwise, the standard output shall
not be used.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
The output file shall be in the same format as the file originally encoded by uuencode.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
The user who is invoking uudecode must have write permission on any file being created.
The output of uuencode is essentially an encoded bit stream that is not
cognizant of byte boundaries. It is possible that a 9-bit byte target machine can process input from an 8-bit source, if it is
aware of the requirement, but the reverse is unlikely to be satisfying. Of course, the only data that is meaningful for such a
transfer between architectures is generally character data.
In order to create an output file named -, it needs to be specified using an alternative pathname, for example, -o
./-, since - alone is considered a magic cookie by uudecode. Likewise, in order to write to an output file
named /dev/stdout it also needs to be specified as, for example, -o ///dev/stdout.
EXAMPLES
None.
RATIONALE
Input files are not necessarily text files, as stated by an early proposal. Although the uuencode output is a text file, that output could have been wrapped within another file or
mail message that is not a text file.
The -o option is not historical practice, but was added at the request of WG15 so that the user could override the target
pathname without having to edit the input data itself.
In early drafts, the [-o outfile] option-argument allowed the use of - to mean standard output. The
standard developers did not wish to overload the meaning of - in this manner, resulting in previous versions only using
/dev/stdout for this purpose. POSIX.1-2024 now allows it as most implementations were already supporting - as an
extension. The file /dev/stdout exists as a special file on most modern systems. However, the /dev/stdout syntax in
uudecode does not refer to a new file. It is just a magic cookie to specify standard output.
FUTURE DIRECTIONS
If this utility is directed to create a new directory entry that contains any bytes that have the encoded value of a
character, implementations are encouraged to treat this as an error. A future version of this standard may require
implementations to treat this as an error.
SEE ALSO
chmod, umask,
uuencode
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 4.
Issue 6
This utility is marked as part of the User Portability Utilities option.
The -o outfile option is added, as specified in the IEEE P1003.2b draft standard.
The normative text is reworded to avoid use of the term "must" for application requirements.
IEEE Std 1003.1-2001/Cor 2-2004, item XCU/TC2/D6/35 is applied, clarifying in the DESCRIPTION that the initial
mode used if either of the op characters is '+' or '-' is unspecified.
Issue 7
The uudecode utility is moved from the User Portability Utilities option to the Base. User Portability Utilities is now
an option for interactive utilities.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0201 [635] is applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1544 is applied, changing the -o option to require that an option-argument of - is treated as
meaning standard output.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/du.html =====
du
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
du — estimate file space usage
SYNOPSIS
du [-a|-s] [-kx] [-H|-L] [file...]
DESCRIPTION
By default, the du utility shall write to standard output the size of the file space allocated to, and the size of the
file space allocated to each subdirectory of, the file hierarchy rooted in each of the specified files. By default, when a symbolic
link is encountered on the command line or in the file hierarchy, du shall count the size of the symbolic link (rather than
the file referenced by the link), and shall not follow the link to another portion of the file hierarchy. The size of the file
space allocated to a file of type directory shall be defined as the sum total of space allocated to all files in the file hierarchy
rooted in the directory plus the space allocated to the directory itself.
When du cannot stat() files or stat() or read directories, it shall report an error condition and the final exit status is
affected. A file that occurs multiple times shall be counted and written for only one entry, even if the occurrences are under
different file operands. The directory entry that is selected in the report is unspecified. By default, file sizes shall be written
in 512-byte units, rounded up to the next 512-byte unit.
OPTIONS
The du utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-a
In addition to the default output, report the size of each file not of type directory in the file hierarchy rooted in the
specified file. The -a option shall not affect whether non-directories given as file operands are listed.
-H
If a symbolic link is specified on the command line, du shall count the size of the file or file hierarchy referenced by
the link.
-k
Write the files sizes in units of 1024 bytes, rather than the default 512-byte units.
-L
If a symbolic link is specified on the command line or encountered during the traversal of a file hierarchy, du shall
count the size of the file or file hierarchy referenced by the link.
-s
Instead of the default output, report only the total sum for each of the specified files.
-x
When evaluating file sizes, evaluate only those files that have the same device as the file specified by the file
operand.
Specifying more than one of the mutually-exclusive options -H and -L shall not be considered an error. The last
option specified shall determine the behavior of the utility.
OPERANDS
The following operand shall be supported:
file
The pathname of a file whose size is to be written. If no file is specified, the current directory shall be used.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of du:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
The output from du shall consist of the amount of space allocated to a file and the name of the file, in the following
format:
"%d %s\n", ,
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
None.
EXAMPLES
None.
RATIONALE
The use of 512-byte units is historical practice and maintains compatibility with ls
and other utilities in this volume of POSIX.1-2024. This does not mandate that the file system itself be based on 512-byte blocks.
The -k option was added as a compromise measure. It was agreed by the standard developers that 512 bytes was the best
default unit because of its complete historical consistency on System V (versus the mixed 512/1024-byte usage on BSD
systems), and that a -k option to switch to 1024-byte units was a good compromise. Users who prefer the 1024-byte quantity
can easily alias du to du -k without breaking the many historical scripts relying on the 512-byte units.
The -b option was added to an early proposal to provide a resolution to the situation where System V and BSD systems give
figures for file sizes in blocks, which is an implementation-defined concept. (In common usage, the block size is 512 bytes
for System V and 1024 bytes for BSD systems.) However, -b was later deleted, since the default was eventually decided as
512-byte units.
Historical file systems provided no way to obtain exact figures for the space allocation given to files. There are two known
areas of inaccuracies in historical file systems: cases of indirect blocks being used by the file system or sparse
files yielding incorrectly high values. An indirect block is space used by the file system in the storage of the file, but that
need not be counted in the space allocated to the file. A sparse file is one in which an lseek() call has been made to a position beyond the end of the file and data has subsequently
been written at that point. A file system need not allocate all the intervening zero-filled blocks to such a file. It is up to the
implementation to define exactly how accurate its methods are.
The -a and -s options were mutually-exclusive in the original version of du. The POSIX Shell and Utilities
description is implied by the language in the SVID where -s is described as causing "only the grand total" to be reported.
Some systems may produce output for -sa, but a Strictly Conforming POSIX Shell and Utilities Application cannot use that
combination.
The -a and -s options were adopted from the SVID except that the System V behavior of not listing non-directories
explicitly given as operands, unless the -a option is specified, was considered a bug; the BSD-based behavior (report for
all operands) is mandated. The default behavior of du in the SVID with regard to reporting the failure to read files (it
produces no messages) was considered counter-intuitive, and thus it was specified that the POSIX Shell and Utilities default
behavior shall be to produce such messages. These messages can be turned off with shell redirection to achieve the System V
behavior.
The -x option is historical practice on recent BSD systems. It has been adopted by this volume of POSIX.1-2024 because
there was no other historical method of limiting the du search to a single file hierarchy. This limitation of the search is
necessary to make it possible to obtain file space usage information about a file system on which other file systems are mounted,
without having to resort to a lengthy find and awk script.
The use of the -L option, or of multiple file operands, requires that du track all file entries
encountered, even with a link count of one. However, when -L is not used and only a single file operand is given, an
implementation can optimize by only tracking files with a link count greater than one, since in that scenario, those are the only
files that could be encountered more than once.
FUTURE DIRECTIONS
If this utility is directed to display a pathname that contains any bytes that have the encoded value of a
character when  is a terminator or separator in the output format being used, implementations are encouraged to
treat this as an error. A future version of this standard may require implementations to treat this as an error.
SEE ALSO
ls
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
XSH fstatat()
CHANGE HISTORY
First released in Issue 2.
Issue 6
This utility is marked as part of the User Portability Utilities option.
The APPLICATION USAGE section is added.
The obsolescent -r option is removed.
The Open Group Corrigendum U025/3 is applied. The du utility is reinstated, as it had incorrectly been marked LEGACY in
Issue 5.
The -H and -L options for symbolic links are added as described in the IEEE P1003.2b draft standard.
Issue 7
The du utility is moved from the User Portability Utilities option to the Base. User Portability Utilities is now an
option for interactive utilities.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0089 [527] is applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to report an error if a utility is directed to display a
pathname that contains any bytes that have the encoded value of a  character when  is a terminator or
separator in the output format being used.
Austin Group Defect 539 is applied, requiring a file that occurs multiple times to be counted and written for only one
entry.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/ctags.html =====
ctags
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ctags — create a tags file (DEVELOPMENT)
SYNOPSIS
[CD SD]  ctags [-a] [-f tagsfile] pathname...
ctags -x pathname...
DESCRIPTION
The ctags utility shall write a tagsfile or an index of objects from C-language source files specified by the
pathname operands. The tagsfile shall list the locators of C-language objects within the source files. A locator
consists of a name, pathname, and either a search pattern or a line number that can be used in searching for the object definition.
The objects that shall be recognized are specified in the EXTENDED DESCRIPTION section.
OPTIONS
The ctags utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-a
Append to tagsfile.
-f tagsfile
Write the object locator lists into tagsfile instead of the default file named tags in the current
directory.
-x
Produce a list of object names, the line number, and filename in which each is defined, as well as the text of that line, and
write this to the standard output. A tagsfile shall not be created when -x is specified.
OPERANDS
The following pathname operands are supported:
file.c
Files with basenames ending with the .c suffix shall be treated as C-language source code. Such files that are not valid
input to c17 produce unspecified results.
file.h
Files with basenames ending with the .h suffix shall be treated as C-language source code. Such files that are not valid
input to c17 produce unspecified results.
The handling of other files is implementation-defined.
STDIN
See the INPUT FILES section.
INPUT FILES
The input files shall be text files containing C-language source code.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of ctags:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_COLLATE
Determine the order in which output is sorted for the -x option. The POSIX locale determines the order in which the
tagsfile is written.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files). If the locale is not compatible with the C locale described by the
ISO C standard, the results are unspecified.
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
The list of object name information produced by the -x option shall be written to standard output in the following
format:
"%s %d %s %s", , , ,
where  is the text of line  of file .
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
When the -x option is not specified, the format of the output file shall be:
"%s\t%s\t/%s/\n", , ,
where  is a search pattern that could be used by an editor to find the defining instance of
in  (where defining instance is indicated by the declarations listed in the
EXTENDED DESCRIPTION).
An optional  ('^') can be added as a prefix to , and an optional
can be appended to  to indicate that the pattern is anchored to the beginning (end) of a
line of text. Any  or  characters in  shall be preceded by a
character. The anchoring , , and escaping  characters shall not be considered
part of the search pattern. All other characters in the search pattern shall be considered literal characters.
An alternative format is:
"%s\t%s\t?%s?\n", , ,
which is identical to the first format except that  characters in  shall not be preceded by
escaping  characters, and  characters in  shall be preceded by
characters.
A second alternative format is:
"%s\t%s\t%d\n", , ,
where  is a decimal line number that could be used by an editor to find  in
.
Neither alternative format shall be produced by ctags when it is used as described by POSIX.1-2024, but the standard
utilities that process tags files shall be able to process those formats as well as the first format.
In any of these formats, the file shall be sorted by identifier, based on the collation sequence in the POSIX locale.
EXTENDED DESCRIPTION
The ctags utility shall attempt to produce an output line for each of the following objects:
Function definitions
Type definitions
Macros with arguments
It may also produce output for any of the following objects:
Function prototypes
Structures
Unions
Global variable definitions
Enumeration types
Macros without arguments
#define statements
#line statements
Any #if and #ifdef statements shall produce no output. The tag main is treated specially in C programs. The
tag formed shall be created by prefixing M to the name of the file, with the trailing .c, and leading pathname
components (if any) removed.
It is implementation-defined what other objects (including duplicate identifiers) produce output.
On systems that do not support the C-Language Development Utilities option, if ctags is supported it produces unspecified
results for C-language source code files. It should write to standard error a message identifying this condition and cause a
non-zero exit status to be produced.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
The output with -x is meant to be a simple index that can be written out as an off-line readable function index. If the
input files to ctags (such as .c files) were not created using the same locale as that in effect when ctags
-x is run, results might not be as expected.
The description of C-language processing says "attempts to" because the C language can be greatly confused, especially through
the use of #defines, and this utility would be of no use if the real C preprocessor were run to identify them. The output
from ctags may be fooled and incorrect for various constructs.
EXAMPLES
None.
RATIONALE
The option list was significantly reduced from that provided by historical implementations. The -F option was omitted as
redundant, since it is the default. The -B option was omitted as being of very limited usefulness. The -t option was
omitted since the recognition of typedefs is now required for C source files. The -u option was omitted because the
update function was judged to be not only inefficient, but also rarely needed.
An early proposal included a -w option to suppress warning diagnostics. Since the types of such diagnostics could not be
described, the option was omitted as being not useful.
The text for LC_CTYPE about compatibility with the C locale acknowledges that the ISO C standard imposes
requirements on the locale used to process C source. This could easily be a superset of that known as "the C locale" by way of
implementation extensions, or one of a few alternative locales for systems supporting different codesets.
The collation sequence of the tags file is not affected by LC_COLLATE because it is typically not used by human readers,
but only by programs such as vi to locate the tag within the source files. Using the
POSIX locale eliminates some of the problems of coordinating locales between the ctags file creator and the vi file reader.
Historically, the tags file has been used only by ex and vi. However, the format of the tags file has been published to encourage other programs to use
the tags in new ways. The format allows either patterns or line numbers to find the identifiers because the historical vi recognizes either. The ctags utility does not produce the format using line numbers
because it is not useful following any source file changes that add or delete lines. The documented search patterns match
historical practice. It should be noted that literal leading  or trailing  characters in the
search pattern will only behave correctly if anchored to the beginning of the line or end of the line by an additional
or  character.
Historical implementations also understand the objects used by the languages FORTRAN, Pascal, and sometimes LISP, and they
understand the C source output by lex and yacc. The ctags utility is not required to accommodate these languages, although
implementors are encouraged to do so.
The following historical option was not specified, as vgrind is not included in this volume of POSIX.1-2024:
-v
If the -v flag is given, an index of the form expected by vgrind is produced on the standard output. This listing
contains the function name, filename, and page number (assuming 64-line pages). Since the output is sorted into lexicographic
order, it may be desired to run the output through sort -f. Sample use:
ctags -v files | sort -f > index
vgrind -x index
The special treatment of the tag main makes the use of ctags practical in directories with more than one
program.
FUTURE DIRECTIONS
If this utility is directed to display a pathname that contains any bytes that have the encoded value of a
character when  is a terminator or separator in the output format being used, implementations are encouraged to
treat this as an error. A future version of this standard may require implementations to treat this as an error.
If this utility is directed to create a new directory entry that contains any bytes that have the encoded value of a
character, implementations are encouraged to treat this as an error. A future version of this standard may require
implementations to treat this as an error.
SEE ALSO
c17, vi
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 4.
Issue 5
The FUTURE DIRECTIONS section is added.
Issue 6
This utility is marked as part of the User Portability Utilities option.
The OUTPUT FILES section is changed to align with the IEEE P1003.2b draft standard.
The normative text is reworded to avoid use of the term "must" for application requirements.
IEEE PASC Interpretation 1003.2 #168 is applied, changing "create" to "write" in the DESCRIPTION.
Issue 7
The ctags utility is no longer dependent on support for the User Portability Utilities option.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to behave as follows:
Report an error if a utility is directed to display a pathname that contains any bytes that have the encoded value of a
character when  is a terminator or separator in the output format being used.
Disallow the creation of filenames containing any bytes that have the encoded value of a  character.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1312 is applied, inserting a missing line break in the example commands in the RATIONALE section.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/unset.html =====
Shell Command Language
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
Please enable javascript in your browser to automatically redirect to the target page, otherwise select the link below.
2.15 Special Built-In Utilities
break
colon
continue
dot
eval
exec
exit
export
readonly
return
set
shift
times
trap
unset
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
===== susv5-html/utilities/false.html =====
false
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
false — return false value
SYNOPSIS
false
DESCRIPTION
The false utility shall return with a non-zero exit code.
OPTIONS
None.
OPERANDS
None.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
None.
ASYNCHRONOUS EVENTS
Default.
STDOUT
Not used.
STDERR
Not used.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The false utility shall always exit with a value between 1 and 125, inclusive.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
None.
EXAMPLES
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
true
CHANGE HISTORY
First released in Issue 2.
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/24 is applied, changing the STDERR section from "None." to
"Not used." for alignment with 1.4 Utility Description Defaults.
Issue 8
Austin Group Defect 1321 is applied, changing the EXIT STATUS section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/uname.html =====
uname
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
uname — return system name
SYNOPSIS
uname [-amnrsv]
DESCRIPTION
By default, the uname utility shall write the operating system name to standard output. When options are specified,
symbols representing one or more system characteristics shall be written to the standard output. The format and contents of the
symbols are implementation-defined. On systems conforming to the System Interfaces volume of POSIX.1-2024, the symbols written
shall be those supported by the uname() function as defined in the System Interfaces
volume of POSIX.1-2024.
OPTIONS
The uname utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-a
Behave as though all of the options -mnrsv were specified.
-m
Write the name of the hardware type on which the system is running to standard output.
-n
Write the name of this node within an implementation-defined communications network.
-r
Write the current release level of the operating system implementation.
-s
Write the name of the implementation of the operating system.
-v
Write the current version level of this release of the operating system implementation.
If no options are specified, the uname utility shall write the operating system name, as if the -s option had been
specified.
OPERANDS
None.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of uname:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
By default, the output shall be a single line of the following form:
"%s\n",
If the -a option is specified, the output shall be a single line of the following form:
"%s %s %s %s %s\n", , , ,
,
Additional implementation-defined symbols may be written; all such symbols shall be written at the end of the line of output
before the .
If options are specified to select different combinations of the symbols, only those symbols shall be written, in the order
shown above for the -a option. If a symbol is not selected for writing, its corresponding trailing  characters
also shall not be written.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
The requested information was successfully written.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
Note that any of the symbols could include embedded  characters, which may affect parsing algorithms if multiple
options are selected for output.
The node name is typically a name that the system uses to identify itself for inter-system communication addressing.
EXAMPLES
The following command:
uname -sr
writes the operating system name and release level, separated by one or more  characters.
RATIONALE
It was suggested that this utility cannot be used portably since the format of the symbols is implementation-defined. The
POSIX.1 working group could not achieve consensus on defining these formats in the underlying uname() function, and there was no expectation that this volume of POSIX.1-2024 would be any
more successful. Some applications may still find this historical utility of value. For example, the symbols could be used for
system log entries or for comparison with operator or user input.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
XSH uname()
CHANGE HISTORY
First released in Issue 2.
Issue 8
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/link.html =====
link
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
link — call link function
SYNOPSIS
[XSI]  link file1 file2
DESCRIPTION
The link utility shall perform the function call:
link(file1, file2);
A user may need appropriate privileges to invoke the link utility.
OPTIONS
None.
OPERANDS
The following operands shall be supported:
file1
The pathname of an existing file.
file2
The pathname of the new directory entry to be created.
STDIN
Not used.
INPUT FILES
Not used.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of link:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
None.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
None.
EXAMPLES
None.
RATIONALE
None.
FUTURE DIRECTIONS
If this utility is directed to create a new directory entry that contains any bytes that have the encoded value of a
character, implementations are encouraged to treat this as an error. A future version of this standard may require
implementations to treat this as an error.
SEE ALSO
ln, unlink
XBD 8. Environment Variables
XSH link()
CHANGE HISTORY
First released in Issue 5.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/mesg.html =====
mesg
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mesg — permit or deny messages
SYNOPSIS
mesg [y|n]
DESCRIPTION
The mesg utility shall control whether other users are allowed to send messages via write, talk, or other utilities to a terminal
device. The terminal device affected shall be determined by searching for the first terminal in the sequence of devices associated
with standard input, standard output, and standard error, respectively. With no arguments, mesg shall report the current
state without changing it. Processes with appropriate privileges may be able to send messages to the terminal independent of the
current state.
OPTIONS
None.
OPERANDS
The following operands shall be supported in the POSIX locale:
y
Grant permission to other users to send messages to the terminal device.
n
Deny permission to other users to send messages to the terminal device.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of mesg:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written (by mesg) to
standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
If no operand is specified, mesg shall display the current terminal state in an unspecified format.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Receiving messages is allowed.
1
Receiving messages is not allowed.
>1
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
The mechanism by which the message status of the terminal is changed is unspecified. Therefore, unspecified actions may cause
the status of the terminal to change after mesg has successfully completed. These actions may include, but are not limited
to: another invocation of the mesg utility, login procedures; invocation of the stty utility, invocation of the chmod utility or
chmod() function, and so on.
EXAMPLES
None.
RATIONALE
The terminal changed by mesg is that associated with the standard input, output, or error, rather than the controlling
terminal for the session. This is because users logged in more than once should be able to change any of their login terminals
without having to stop the job running in those sessions. This is not a security problem involving the terminals of other users
because appropriate privileges would be required to affect the terminal of another user.
The method of checking each of the first three file descriptors in sequence until a terminal is found was adopted from System
V.
The file /dev/tty is not specified for the terminal device because it was thought to be too restrictive. Typical
environment changes for the n operand are that write permissions are removed for others and group from the
appropriate device. It was decided to leave the actual description of what is done as unspecified because of potential differences
between implementations.
The format for standard output is unspecified because of differences between historical implementations. This output is
generally not useful to shell scripts (they can use the exit status), so exact parsing of the output is unnecessary.
FUTURE DIRECTIONS
None.
SEE ALSO
talk, write
XBD 8. Environment Variables
CHANGE HISTORY
First released in Issue 2.
Issue 6
This utility is marked as part of the User Portability Utilities option.
Issue 7
The mesg utility is moved from the User Portability Utilities option to the Base. User Portability Utilities is now an
option for interactive utilities.
Issue 8
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/eval.html =====
Shell Command Language
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
Please enable javascript in your browser to automatically redirect to the target page, otherwise select the link below.
2.15 Special Built-In Utilities
break
colon
continue
dot
eval
exec
exit
export
readonly
return
set
shift
times
trap
unset
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
===== susv5-html/utilities/tput.html =====
tput
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
tput — change terminal characteristics
SYNOPSIS
tput [-T type] operand...
DESCRIPTION
The tput utility shall display terminal-dependent information. The manner in which this information is retrieved is
unspecified. The information displayed shall clear the terminal screen, initialize the user's terminal, or reset the user's
terminal, depending on the operand given. The exact consequences of displaying this information are unspecified.
OPTIONS
The tput utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following option shall be supported:
-T type
Indicate the type of terminal. If this option is not supplied and the TERM variable is unset or null, an unspecified
default terminal type shall be used. The setting of type shall take precedence over the value in TERM .
OPERANDS
The following strings shall be supported as operands by the implementation in the POSIX locale:
clear
Display the clear-screen sequence.
init
Display the sequence that initializes the user's terminal in an implementation-defined manner.
reset
Display the sequence that resets the user's terminal in an implementation-defined manner.
If a terminal does not support any of the operations described by these operands, this shall not be considered an error
condition.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of tput:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
TERM
Determine the terminal type. If this variable is unset or null, and if the -T option is not specified, an unspecified
default terminal type shall be used.
ASYNCHRONOUS EVENTS
Default.
STDOUT
If standard output is a terminal device, it may be used for writing the appropriate sequence to clear the screen or reset or
initialize the terminal. If standard output is not a terminal device, undefined results occur.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
The requested string was written successfully.
1
Unspecified.
2
Usage error.
3
No information is available about the specified terminal type.
4
The specified operand is invalid.
>4
An error occurred.
CONSEQUENCES OF ERRORS
If one of the operands is not available for the terminal, tput continues processing the remaining operands.
The following sections are informative.
APPLICATION USAGE
The difference between resetting and initializing a terminal is left unspecified, as they vary greatly based on hardware types.
In general, resetting is a more severe action.
Some terminals use control characters to perform the stated functions, and on such terminals it might make sense to use
tput to store the initialization strings in a file or environment variable for later use. However, because other terminals
might rely on system calls to do this work, the standard output cannot be used in a portable manner, such as the following
non-portable constructs:
ClearVar=`tput clear`
tput reset | mailx -s "Wake Up" ddg
EXAMPLES
Initialize the terminal according to the type of terminal in the environmental variable TERM . This command can be
included in a .profile file.
tput init
Reset a 450 terminal.
tput -T 450 reset
RATIONALE
The list of operands was reduced to a minimum for the following reasons:
The only features chosen were those that were likely to be used by human users interacting with a terminal.
Specifying the full terminfo set was not considered desirable, but the standard developers did not want to select among
operands.
This volume of POSIX.1-2024 does not attempt to provide applications with sophisticated terminal handling capabilities, as that
falls outside of its assigned scope and intersects with the responsibilities of other standards bodies.
The difference between resetting and initializing a terminal is left unspecified as this varies greatly based on hardware types.
In general, resetting is a more severe action.
The exit status of 1 is historically reserved for finding out if a Boolean operand is not set. Although the operands were
reduced to a minimum, the exit status of 1 should still be reserved for the Boolean operands, for those sites that wish to support
them.
FUTURE DIRECTIONS
None.
SEE ALSO
stty, tabs
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 4.
Issue 6
This utility is marked as part of the User Portability Utilities option.
Issue 7
The tput utility is moved from the User Portability Utilities option to the Base. User Portability Utilities is now an
option for interactive utilities.
Issue 8
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/uux.html =====
uux
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
uux — remote command execution
SYNOPSIS
[UU]  uux [-jnp] command-string
DESCRIPTION
The uux utility shall gather zero or more files from various systems, execute a shell pipeline (see 2.9 Shell Commands) on a specified system, and then send the standard output of
the command to a file on a specified system. Only the first command of a pipeline can have a system-name! prefix. All other
commands in the pipeline shall be executed on the system of the first command.
The following restrictions are applicable to the shell pipeline processed by uux:
In gathering files from different systems, pathname expansion shall not be performed by uux. Thus, a request such as:
uux "c17 remsys!~/*.c"
would attempt to copy the file named literally *.c to the local system.
The redirection operators ">>", "|", and ">&" shall not be
accepted. Any use of these redirection operators shall cause this utility to write an error message describing the problem and exit
with a non-zero exit status.
The reserved word ! cannot be used at the head of the pipeline to modify the exit status. (See the command-string
operand description below.)
Alias substitution shall not be performed.
A filename can be specified as for uucp; it can be an absolute pathname, a pathname
preceded by ~name (which is replaced by the corresponding login directory), a pathname specified as ~/dest
(dest is prefixed by the public directory called PUBDIR; the actual location of PUBDIR is
implementation-defined), or a simple filename (which is prefixed by uux with the current directory). See uucp for the details.
The execution of commands on remote systems shall take place in an execution directory known to the uucp system. All files required for the execution shall be put into this directory unless they
already reside on that machine. Therefore, the application shall ensure that non-local filenames (without path or machine
reference) are unique within the uux request.
The uux utility shall attempt to get all files to the execution system. For files that are output files, the application
shall ensure that the filename is escaped using parentheses.
The remote system shall notify the user by mail if the requested command on the remote system was disallowed or the files were
not accessible. This notification can be turned off by the -n option.
Typical implementations of this utility require a communications line configured to use XBD 11. General Terminal Interface, but other communications means may be used. On
systems where there are no available communications means (either temporarily or permanently), this utility shall write an error
message describing the problem and exit with a non-zero exit status.
The uux utility cannot guarantee support for all character encodings in all circumstances. For example, transmission data
may be restricted to 7 bits by the underlying network, 8-bit data and filenames need not be portable to non-internationalized
systems, and so on. Under these circumstances, it is recommended that only characters defined in the ISO/IEC 646:1991 standard
International Reference Version (equivalent to ASCII) 7-bit range of characters be used and that only characters defined in the
portable filename character set be used for naming files.
OPTIONS
The uux utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-j
Write the job identification string to standard output. This job identification can be used by uustat to obtain the status or terminate a job.
-n
Do not notify the user if the command fails.
-p
Make the standard input to uux the standard input to the command-string.
OPERANDS
The following operand shall be supported:
command-string
A string made up of one or more arguments that are similar to normal command arguments, except that the command and any filenames
can be prefixed by system-name!. A null system-name shall be interpreted as the local system.
STDIN
The standard input shall not be used unless the '-' or -p option is specified; in those cases, the standard
input shall be made the standard input of the command-string.
INPUT FILES
Input files shall be selected according to the contents of command-string.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of uux:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
The standard output shall not be used unless the -j option is specified; in that case, the job identification string
shall be written to standard output in the following format:
"%s\n",
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
Output files shall be created or written, or both, according to the contents of command-string.
If -n is not used, mail files shall be modified following any command or file-access failures on the remote system.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
This utility is part of the UUCP Utilities option and need not be supported by all implementations.
Note that, for security reasons, many installations limit the list of commands executable on behalf of an incoming request from
uux. Many sites permit little more than the receipt of mail via uux.
Any characters special to the command interpreter should be quoted either by quoting the entire command-string or quoting
the special characters as individual arguments.
As noted in uucp, shell pattern matching notation characters appearing in pathnames
are expanded on the appropriate local system. This is done under the control of local settings of LC_COLLATE and LC_CTYPE
. Thus, care should be taken when using bracketed filename patterns, as collation and typing rules may vary from one system to
another. Also be aware that certain types of expression (that is, equivalence classes, character classes, and collating symbols)
need not be supported on non-internationalized systems.
EXAMPLES
The following command gets file1 from system a and file2 from system b, executes diff on the local system, and puts the results in file.diff in the local PUBDIR
directory. (PUBDIR is the uucp public directory on the local system.)
uux "!diff a!/usr/file1 b!/a4/file2 >!~/file.diff"
The following command fails because uux places all files copied to a system in the same working directory. Although the
files xyz are from two different systems, their filenames are the same and conflict.
uux "!diff a!/usr1/xyz b!/usr2/xyz >!~/xyz.diff"
The following command succeeds (assuming diff is permitted on system a)
because the file local to system a is not copied to the working directory, and hence does not conflict with the file from
system c.
uux "a!diff a!/usr/xyz c!/usr/xyz >!~/xyz.diff"
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2. Shell Command Language, uucp, uuencode, uustat
XBD 8. Environment Variables, 11. General Terminal Interface, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 2.
Issue 6
The obsolescent SYNOPSIS is removed.
The normative text is reworded to avoid use of the term "must" for application requirements.
The UN margin code and associated shading are removed from the -j option in response to The Open Group Base Resolution
bwg2001-003.
Issue 7
SD5-XCU-ERN-46 is applied, moving this utility to the UUCP Utilities Option Group.
Issue 8
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1516 is applied, adding XSI shading to text relating to NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/rmdir.html =====
rmdir
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
rmdir — remove directories
SYNOPSIS
rmdir [-p] dir...
DESCRIPTION
The rmdir utility shall remove the directory entry specified by each dir operand.
For each dir operand, the rmdir utility shall perform actions equivalent to the rmdir() function called with the dir operand as its only argument.
Directories shall be processed in the order specified. If a directory and a subdirectory of that directory are specified in a
single invocation of the rmdir utility, the application shall specify the subdirectory before the parent directory so that
the parent directory is empty when the rmdir utility tries to remove it.
OPTIONS
The rmdir utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following option shall be supported:
-p
Remove all directories in a pathname. For each dir operand:
The directory entry it names shall be removed.
If the dir operand includes more than one pathname component, effects equivalent to the following command shall
occur:
rmdir -p $(dirname dir)
OPERANDS
The following operand shall be supported:
dir
A pathname of an empty directory to be removed.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of rmdir:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
Not used.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Each directory entry specified by a dir operand was removed successfully.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
The definition of an empty directory is one that contains, at most, directory entries for dot and dot-dot.
EXAMPLES
If a directory a in the current directory is empty except it contains a directory b and a/b is empty except
it contains a directory c:
rmdir -p a/b/c
removes all three directories.
RATIONALE
On historical System V systems, the -p option also caused a message to be written to the standard output. The message
indicated whether the whole path was removed or whether part of the path remained for some reason. The STDERR section requires this
diagnostic when the entire path specified by a dir operand is not removed, but does not allow the status message reporting
success to be written as a diagnostic.
The rmdir utility on System V also included a -s option that suppressed the informational message output by the
-p option. This option has been omitted because the informational message is not specified by this volume of
POSIX.1-2024.
FUTURE DIRECTIONS
None.
SEE ALSO
rm
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
XSH remove(), rmdir(),
unlink()
CHANGE HISTORY
First released in Issue 2.
Issue 6
The normative text is reworded to avoid use of the term "must" for application requirements.
Issue 8
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/patch.html =====
patch
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
patch — apply changes to files
SYNOPSIS
patch [-blNR] [-c|-e|-n|-u] [-d dir] [-D
define] [-i patchfile]        [-o
outfile] [-p num] [-r rejectfile] [file]
DESCRIPTION
The patch utility shall read a source (patch) file containing any of four forms of difference (diff) listings produced by
the diff utility (normal, copied context, unified context, or in the style of ed) and apply those differences to a file. By default, patch shall read from the standard
input.
The patch utility shall attempt to determine the type of the diff listing,
unless overruled by a -c, -e, -n, or -u option.
If the patch file contains more than one patch, patch shall attempt to apply each of them as if they came from separate
patch files. (In this case, the application shall ensure that the name of the patch file is determinable for each diff listing.)
OPTIONS
The patch utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-b
Save a copy of the original contents of each modified file, before the differences are applied, in a file of the same name with
the suffix .orig appended to it. If the file already exists, it shall be overwritten; if multiple patches are applied to the
same file, the .orig file shall be written only for the first patch. When the -o outfile option is also
specified, file.orig shall not be created but, if outfile already exists, outfile.orig shall be
created.
-c
Interpret the patch file as a copied context difference (the output of the utility diff when the -c or -C options are specified).
-d dir
Change the current directory to dir before processing as described in the EXTENDED DESCRIPTION section.
-D define
Mark changes with one of the following C preprocessor constructs:
#ifdef define
...
#endif
#ifndef define
...
#endif
optionally combined with the C preprocessor construct #else. If the patched file is processed with the C preprocessor,
where the macro define is defined, the output shall contain the changes from the patch file; otherwise, the output shall not
contain the patches specified in the patch file.
-e
Interpret the patch file as an ed script, rather than a diff script.
-i patchfile
Read the patch information from the file named by the pathname patchfile, rather than the standard input.
-l
(The letter ell.) Cause any sequence of  characters in the difference script to match any sequence of
characters in the input file. Other characters shall be matched exactly.
-n
Interpret the script as a normal difference.
-N
Ignore patches where the differences have already been applied to the file; by default, already-applied patches shall be
rejected.
-o outfile
Instead of modifying the files (specified by the file operand or the difference listings) directly, write a copy of the
file referenced by each patch, with the appropriate differences applied, to outfile. Multiple patches for a single file
shall be applied to the intermediate versions of the file created by any previous patches, and shall result in multiple,
concatenated versions of the file being written to outfile.
-p num
For all pathnames in the patch file that indicate the names of files to be patched, delete num pathname components from
the beginning of each pathname. If the pathname in the patch file is absolute, any leading  characters shall be
considered the first component (that is, -p 1 shall remove the leading  characters). Specifying
-p 0 shall cause the full pathname to be used. If -p is not specified, only the basename (the final pathname
component) shall be used.
-R
Reverse the sense of the patch script; that is, assume that the difference script was created from the new version to the old
version. The -R option cannot be used with ed scripts. The patch utility
shall attempt to reverse each portion of the script before applying it. Rejected differences shall be saved in swapped format. If
this option is not specified, and until a portion of the patch file is successfully applied, patch attempts to apply each
portion in its reversed sense as well as in its normal sense. If the attempt is successful, the user shall be prompted to determine
whether the -R option should be set.
-r rejectfile
Override the default reject filename. In the default case, the reject file shall have the same name as the output file, with
the suffix .rej appended to it; see Patch Application.
-u
Interpret the patch file as a unified context difference (the output of the diff
utility when the -u or -U options are specified).
OPERANDS
The following operand shall be supported:
file
A pathname of a file to patch.
STDIN
See the INPUT FILES section.
INPUT FILES
Input files shall be text files.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of patch:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_COLLATE
Determine the locale for the behavior of ranges, equivalence classes, and multi-character collating elements used in the extended
regular expression defined for the yesexpr locale keyword in the LC_MESSAGES category.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files), and the behavior of character classes used in the extended regular
expression defined for the yesexpr locale keyword in the LC_MESSAGES category.
LC_MESSAGES
Determine the locale used to process affirmative responses, and the locale used to affect the format and contents of diagnostic
messages and prompts written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
LC_TIME
Determine the locale for recognizing the format of file timestamps written by the diff utility in a context-difference input file.
ASYNCHRONOUS EVENTS
Default.
STDOUT
Not used.
STDERR
The standard error shall be used for diagnostic and informational messages.
OUTPUT FILES
The output of the patch utility, the save files (.orig suffixes), and the reject files (.rej suffixes)
shall be text files.
EXTENDED DESCRIPTION
A patch file may contain patching instructions for more than one file; filenames shall be determined as specified in Filename Determination. When the -b option is specified, for each patched file, the original shall
be saved in a file of the same name with the suffix .orig appended to it.
For each patched file, a reject file may also be created as noted in Patch Application. In the
absence of a -r option, the name of this file shall be formed by appending the suffix .rej to the original
filename.
Patch File Format
The patch file shall contain zero or more lines of header information followed by one or more patches. Each patch shall contain
zero or more lines of filename identification in the format produced by the -c, -C, -u, or -U options
of the diff utility, and one or more sets of diff output, which are customarily called hunks.
The patch utility shall recognize the following expression in the header information:
Index: pathname
The file to be patched is named pathname.
If all lines (including headers) within a patch begin with the same leading sequence of  characters, the
patch utility shall remove this sequence before proceeding. Within each patch, if the type of difference is common context,
the patch utility shall recognize the following expressions:
*** filename timestamp
The patches arose from filename.
--- filename timestamp
The patches should be applied to filename.
If the type of difference is unified context, the patch utility shall recognize the following expressions:
--- filename timestamp
The patches arose from filename.
+++ filename timestamp
The patches should be applied to filename.
Each hunk within a patch shall be the diff output to change a line range within the
original file. The line numbers for successive hunks within a patch shall occur in ascending order.
Filename Determination
If no file operand is specified, patch shall perform the following steps to determine the filename to use:
If the type of diff is context, the patch utility shall delete pathname
components (as specified by the -p option) from the filename on the line beginning with "***" (if copied context)
or "---" (if unified context), then test for the existence of this file relative to the current directory (or the
directory specified with the -d option). If the file exists, the patch utility shall use this filename.
If the type of diff is context, the patch utility shall delete the pathname
components (as specified by the -p option) from the filename on the line beginning with "---" (if copied context)
or "+++" (if unified context), then test for the existence of this file relative to the current directory (or the
directory specified with the -d option). If the file exists, the patch utility shall use this filename.
If the header information contains a line beginning with the string Index:, the patch utility shall delete
pathname components (as specified by the -p option) from this line, then test for the existence of this file relative to the
current directory (or the directory specified with the -d option). If the file exists, the patch utility shall use
this filename.
[XSI]
If an SCCS directory exists in the current directory, patch shall attempt to perform a get -e SCCS/s.filename command to retrieve an editable version of the file.
If the file exists, the patch utility shall use this filename.
The patch utility shall write a prompt to standard output and request a filename interactively from the controlling
terminal (for example, /dev/tty).
Patch Application
If the -c, -e, -n, or -u option is present, the patch utility shall interpret information
within each hunk as a copied context difference, an ed difference, a normal difference,
or a unified context difference, respectively. In the absence of any of these options, the patch utility shall determine the
type of difference based on the format of information within the hunk.
For each hunk, the patch utility shall begin to search for the place to apply the patch at the line number at the
beginning of the hunk, plus or minus any offset used in applying the previous hunk. If lines matching the hunk context are not
found, patch shall scan both forwards and backwards at least 1000 bytes for a set of lines that match the hunk context.
If no such place is found and it is a context difference, then another scan shall take place, ignoring the first and last line
of context. If that fails, the first two and last two lines of context shall be ignored and another scan shall be made.
Implementations may search more extensively for installation locations.
If no location can be found, the patch utility shall append the hunk to the reject file. A rejected hunk that is a copied
context difference, an ed difference, or a normal difference shall be written in
copied-context-difference format regardless of the format of the patch file. It is implementation-defined whether a rejected hunk
that is a unified context difference is written in copied-context-difference format or in unified-context-difference format. If the
input was a normal or ed-style difference, the reject file may contain differences with
zero lines of context. The line numbers on the hunks in the reject file may be different from the line numbers in the patch file
since they shall reflect the approximate locations for the failed hunks in the new file rather than the old one.
If the type of patch is an ed diff, the implementation may accomplish the patching by
invoking the ed utility.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
1
One or more lines were written to a reject file.
>1
An error occurred.
CONSEQUENCES OF ERRORS
Patches that cannot be correctly placed in the file shall be written to a reject file.
The following sections are informative.
APPLICATION USAGE
The -R option does not work with ed scripts because there is too little
information to reconstruct the reverse operation.
The -p option makes it possible to customize a patch file to local user directory structures without manually editing the
patch file. For example, if the filename in the patch file was:
/curds/whey/src/blurfl/blurfl.c
Setting -p 0 gives the entire pathname unmodified; -p 1 gives:
curds/whey/src/blurfl/blurfl.c
without the leading , -p 4 gives:
blurfl/blurfl.c
and not specifying -p at all gives:
blurfl.c .
EXAMPLES
None.
RATIONALE
Some of the functionality in historical patch implementations was not specified. The following documents those features
present in historical implementations that have not been specified.
A deleted piece of functionality was the '+' pseudo-option allowing an additional set of options and a patch file
operand to be given. This was seen as being insufficiently useful to standardize.
In historical implementations, if the string "Prereq:" appeared in the header, the patch utility would search
for the corresponding version information (the string specified in the header, delimited by  characters or the
beginning or end of a line or the file) anywhere in the original file. This was deleted as too simplistic and insufficiently
trustworthy a mechanism to standardize. For example, if:
Prereq: 1.2
were in the header, the presence of a delimited 1.2 anywhere in the file would satisfy the prerequisite.
The following options were dropped from historical implementations of patch as insufficiently useful to standardize:
-b
The -b option historically provided a method for changing the name extension of the backup file from the default
.orig. This option has been modified and retained in this volume of POSIX.1-2024.
-F
The -F option specified the number of lines of a context diff to ignore when searching for a place to install a
patch.
-f
The -f option historically caused patch not to request additional information from the user.
-r
The -r option historically provided a method of overriding the extension of the reject file from the default
.rej.
-s
The -s option historically caused patch to work silently unless an error occurred.
-x
The -x option historically set internal debugging flags.
In some file system implementations, the saving of a .orig file may produce unwanted results. In the case of 12, 13, or
14-character filenames (on file systems supporting 14-character maximum filenames), the .orig file overwrites the new file.
The reject file may also exceed this filename limit. It was suggested, due to some historical practice, that a
('~') suffix be used instead of .orig and some other character instead of the .rej suffix. This was rejected
because it is not obvious to the user which file is which. The suffixes .orig and .rej are clearer and more
understandable.
The -b option has the opposite sense in some historical implementations—do not save the .orig file. The default
case here is not to save the files, making patch behave more consistently with the other standard utilities.
The -w option in early proposals was changed to -l to match historical practice.
The -N option was included because without it, a non-interactive application cannot reject previously applied patches.
For example, if a user is piping the output of diff into the patch utility, and
the user only wants to patch a file to a newer version non-interactively, the -N option is required.
Changes to the -l option description were proposed to allow matching across  characters in addition to
just  characters. Since this is not historical practice, and since some ambiguities could result, it is suggested that
future developments in this area utilize another option letter, such as -L.
The -u option of GNU patch has been added, along with support for unified context formats.
FUTURE DIRECTIONS
If this utility is directed to create a new directory entry that contains any bytes that have the encoded value of a
character, implementations are encouraged to treat this as an error. A future version of this standard may require
implementations to treat this as an error.
SEE ALSO
diff, ed
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 4.
Issue 5
The FUTURE DIRECTIONS section is added.
Issue 6
This utility is marked as part of the User Portability Utilities option.
The description of the -D option and the steps in Filename Determination are changed to
match historical practice as defined in the IEEE P1003.2b draft standard.
The normative text is reworded to avoid use of the term "must" for application requirements.
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/34 is applied, clarifying the way that the patch utility
performs ifdef selection for the -D option.
Issue 7
The patch utility is moved from the User Portability Utilities option to the Base. User Portability Utilities is now an
option for interactive utilities.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
SD5-XCU-ERN-103 and SD5-XCU-ERN-120 are applied, adding the -u option.
Austin Group Interpretation 1003.1-2001 #126 is applied, changing the description of the LC_MESSAGES and LC_CTYPE
environment variables and adding the LC_COLLATE environment variable.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/dirname.html =====
dirname
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
dirname — return the directory portion of a pathname
SYNOPSIS
dirname string
DESCRIPTION
The string operand shall be treated as a pathname, as defined in XBD 3.254 Pathname, and shall be converted to a pathname of the directory
containing the entry of the final pathname component. The resulting string shall be written to standard output. The dirname
utility shall not perform pathname resolution; the result shall not be affected by whether or not a file with the pathname
string exists or by its file type. Trailing '/' characters in string that are not also leading '/'
characters shall not be counted as part of the pathname. If the pathname does not contain a '/', the resulting string
shall be ".". If string is an empty string, the resulting string shall be ".".
It is unspecified whether redundant '/' characters and '.' pathname components in string are removed
after determining the pathname to output. However, ".." pathname components occurring prior to the final component shall
not be removed.
OPTIONS
None.
OPERANDS
The following operand shall be supported:
string
A string.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of dirname:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
The dirname utility shall write a line to the standard output in the following format:
"%s\n",
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
The definition of pathname specifies implementation-defined behavior for pathnames starting with two
characters. Therefore, applications shall not arbitrarily add  characters to the beginning of a pathname unless they
can ensure that there are more or less than two or are prepared to deal with the implementation-defined consequences.
EXAMPLES
The EXAMPLES section of the basename() function (see XSH basename()) includes a table showing examples of the results of processing
several sample pathnames by the basename() and dirname() functions and by the basename and
dirname utilities.
See also the examples for the basename utility.
RATIONALE
The behaviors of basename and dirname in this volume of POSIX.1-2024 have
been coordinated so that when string is a valid pathname:
$(basename -- "string")
would be a valid filename for the file in the directory:
$(dirname -- "string")
This would not work for the versions of these utilities in early proposals due to the way processing of trailing
characters was specified. Consideration was given to leaving processing unspecified if there were trailing
characters, but this cannot be done; XBD 3.254 Pathname allows trailing
characters. The basename and dirname utilities have to specify
consistent handling for all valid pathnames.
The dirname utility is not specified in terms of the dirname() function,
because the two may produce slightly different output where both output forms are still compliant. An implementation should prefer
the shortest output possible; however, this is not required, in part because earlier versions of the standard did not permit
elision of redundant  characters or dot ('.') components. Removal of the dot-dot ("..") pathname
component is not permitted, because eliding it correctly would require performing pathname resolution to ensure the resulting
string would still point to the correct pathname if the original string resolved as a pathname. On implementations where pathname
"//" has an implementation-defined meaning distinct from the pathname "/", the dirname of "//" will be
"//".
FUTURE DIRECTIONS
If this utility is directed to display a pathname that contains any bytes that have the encoded value of a
character when  is a terminator or separator in the output format being used, implementations are encouraged to
treat this as an error. A future version of this standard may require implementations to treat this as an error.
SEE ALSO
2.5 Parameters and Variables, basename
XBD 3.254 Pathname, 8. Environment Variables
XSH basename(), dirname()
CHANGE HISTORY
First released in Issue 2.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0083 [192,430], XCU/TC1-2008/0084 [192], and XCU/TC1-2008/0085 [192] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0086 [612], XCU/TC2-2008/0087 [620], and XCU/TC2-2008/0088 [612] are
applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to report an error if a utility is directed to display a
pathname that contains any bytes that have the encoded value of a  character when  is a terminator or
separator in the output format being used.
Austin Group Defect 1073 is applied, replacing the DESCRIPTION section with one that matches the dirname() function.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/type.html =====
type
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
type — write a description of command type
SYNOPSIS
[XSI]  type name...
DESCRIPTION
The type utility shall indicate how each argument would be interpreted if used as a command name.
OPTIONS
None.
OPERANDS
The following operand shall be supported:
name
A name to be interpreted.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of type:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
Determine the location of messages objects and message catalogs.
PATH
Determine the location of name, as described in XBD 8. Environment
Variables.
ASYNCHRONOUS EVENTS
Default.
STDOUT
The standard output of type contains information about each operand in an unspecified format. The information provided
typically identifies the operand as a shell built-in, function, alias, or keyword, and where applicable, may display the operand's
pathname.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
This utility is required to be intrinsic. See 1.7 Intrinsic Utilities
for details.
Since type must be aware of the contents of the current shell execution environment (such as the lists of commands,
functions, and built-ins processed by hash), it is always provided as a shell regular
built-in. If it is called in a separate utility execution environment, such as one of the following:
nohup type writer
find . -type f -exec type {} +
it might not produce accurate results.
EXAMPLES
None.
RATIONALE
None.
FUTURE DIRECTIONS
If this utility is directed to display a pathname that contains any bytes that have the encoded value of a
character when  is a terminator or separator in the output format being used, implementations are encouraged to
treat this as an error. A future version of this standard may require implementations to treat this as an error.
SEE ALSO
command, hash
XBD 8. Environment Variables
CHANGE HISTORY
First released in Issue 2.
Issue 8
Austin Group Defect 248 is applied, changing a command line in the APPLICATION USAGE section.
Austin Group Defect 251 is applied, encouraging implementations to report an error if a utility is directed to display a
pathname that contains any bytes that have the encoded value of a  character when  is a terminator or
separator in the output format being used.
Austin Group Defect 854 is applied, adding a note to the APPLICATION USAGE section that this utility is required to be
intrinsic.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/basename.html =====
basename
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
basename — return non-directory portion of a pathname
SYNOPSIS
basename string [suffix]
DESCRIPTION
The string operand shall be treated as a pathname, as defined in XBD 3.254 Pathname. The string string shall be converted to the filename
corresponding to the last pathname component in string and then the suffix string suffix, if present, shall be
removed. This shall be done by performing actions equivalent to the following steps in order:
If string is a null string, it is unspecified whether the resulting string is '.' or a null string. In either
case, skip steps 2 through 6.
If string is "//", it is implementation-defined whether steps 3 to 6 are skipped or processed.
If string consists entirely of  characters, string shall be set to a single  character.
In this case, skip steps 4 to 6.
If there are any trailing  characters in string, they shall be removed.
If there are any  characters remaining in string, the prefix of string up to and including the last
character in string shall be removed.
If the suffix operand is present, is not identical to the characters remaining in string, and is identical to a
suffix of the characters remaining in string, the suffix suffix shall be removed from string. Otherwise,
string is not modified by this step. It shall not be considered an error if suffix is not found in string.
The resulting string shall be written to standard output.
OPTIONS
None.
OPERANDS
The following operands shall be supported:
string
A string.
suffix
A string.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of basename:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
The basename utility shall write a line to the standard output in the following format:
"%s\n",
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
The definition of pathname specifies implementation-defined behavior for pathnames starting with two
characters. Therefore, applications shall not arbitrarily add  characters to the beginning of a pathname unless they
can ensure that there are more or less than two or are prepared to deal with the implementation-defined consequences.
EXAMPLES
If the string string is a valid pathname:
$(basename -- "string")
produces a filename that could be used to open the file named by string in the directory returned by:
$(dirname -- "string")
If the string string is not a valid pathname, the same algorithm is used, but the result need not be a valid filename.
The basename utility is not expected to make any judgements about the validity of string as a pathname; it just
follows the specified algorithm to produce a result string.
The following shell script compiles /usr/src/cmd/cat.c and moves the output to a file named cat in the current
directory when invoked with the argument /usr/src/cmd/cat or with the argument /usr/src/cmd/cat.c:
c17 -- "$(dirname -- "$1")/$(basename -- "$1" .c).c" &&
mv a.out "$(basename -- "$1" .c)"
The EXAMPLES section of the basename() function (see XSH basename()) includes a table showing examples of the results of processing
several sample pathnames by the basename() and dirname() functions and by the basename and dirname utilities.
RATIONALE
The behaviors of basename and dirname have been coordinated so that when
string is a valid pathname:
$(basename -- "string")
would be a valid filename for the file in the directory:
$(dirname -- "string")
This would not work for the early proposal versions of these utilities due to the way it specified handling of trailing
characters.
Since the definition of pathname specifies implementation-defined behavior for pathnames starting with two
characters, this volume of POSIX.1-2024 specifies similar implementation-defined behavior for the basename and dirname utilities.
FUTURE DIRECTIONS
If this utility is directed to display a pathname that contains any bytes that have the encoded value of a
character when  is a terminator or separator in the output format being used, implementations are encouraged to
treat this as an error. A future version of this standard may require implementations to treat this as an error.
SEE ALSO
2.5 Parameters and Variables, dirname
XBD 3.254 Pathname, 8. Environment Variables
XSH basename(), dirname()
CHANGE HISTORY
First released in Issue 2.
Issue 6
IEEE PASC Interpretation 1003.2 #164 is applied.
The normative text is reworded to avoid use of the term "must" for application requirements.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0065 [192,538], XCU/TC1-2008/0066 [192,538], and XCU/TC1-2008/0067
[192,430,538] are applied.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0065 [612] is applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to report an error if a utility is directed to display a
pathname that contains any bytes that have the encoded value of a  character when  is a terminator or
separator in the output format being used.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/id.html =====
id
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
id — return user identity
SYNOPSIS
id [user]
id -G [-n] [user]
id -g [-nr] [user]
id -u [-nr] [user]
DESCRIPTION
If no user operand is provided, the id utility shall write the user and group IDs and the corresponding user and
group names of the invoking process to standard output. If the effective and real IDs do not match, both shall be written. If
multiple groups are supported by the underlying system (see the description of {NGROUPS_MAX} in the System Interfaces volume of
POSIX.1-2024), the supplementary group affiliations of the invoking process shall also be written.
If a user operand is provided and the process has appropriate privileges, the user and group IDs of the selected user
shall be written. In this case, effective IDs shall be assumed to be identical to real IDs. If the selected user has more than one
allowable group membership listed in the group database, these shall be written in the same manner as the supplementary groups
described in the preceding paragraph.
OPTIONS
The id utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-G
Output all different group IDs (effective, real, and supplementary) only, using the format "%u\n". If there is more
than one distinct group affiliation, output each such affiliation, using the format " %u", before the
is output.
-g
Output only the effective group ID, using the format "%u\n".
-n
Output the name in the format "%s" instead of the numeric ID using the format "%u".
-r
Output the real ID instead of the effective ID.
-u
Output only the effective user ID, using the format "%u\n".
OPERANDS
The following operand shall be supported:
user
The login name for which information is to be written.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of id:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error and
informative messages written to standard output.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
The following formats shall be used when the LC_MESSAGES locale category specifies the POSIX locale. In other locales,
the strings uid, gid, euid, egid, and groups may be replaced with more appropriate strings
corresponding to the locale.
"uid=%u(%s) gid=%u(%s)\n", , ,
,
If the effective and real user IDs do not match, the following shall be inserted immediately before the '\n' character
in the previous format:
" euid=%u(%s)"
with the following arguments added at the end of the argument list:
,
If the effective and real group IDs do not match, the following shall be inserted directly before the '\n' character in
the format string (and after any addition resulting from the effective and real user IDs not matching):
" egid=%u(%s)"
with the following arguments added at the end of the argument list:
,
If the process has supplementary group affiliations or the selected user is allowed to belong to multiple groups, the first
shall be added directly before the  in the format string:
" groups=%u(%s)"
with the following arguments added at the end of the argument list:
,
and the necessary number of the following added after that for any remaining supplementary group IDs:
",%u(%s)"
and the necessary number of the following arguments added at the end of the argument list:
,
If any of the user ID, group ID, effective user ID, effective group ID, or supplementary/multiple group IDs cannot be mapped by
the system into printable user or group names, the corresponding "(%s)" and name argument shall be omitted from the
corresponding format string.
When any of the options are specified, the output format shall be as described in the OPTIONS section.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
Output produced by the -G option and by the default case could potentially produce very long lines on systems that
support large numbers of supplementary groups. (On systems with user and group IDs that are 32-bit integers and with group names
with a maximum of 8 bytes per name, 93 supplementary groups plus distinct effective and real group and user IDs could theoretically
overflow the 2048-byte {LINE_MAX} text file line limit on the default output case. It would take about 186 supplementary groups to
overflow the 2048-byte barrier using id -G). This is not expected to be a problem in practice, but in cases where it
is a concern, applications should consider using fold -s before post-processing
the output of id.
EXAMPLES
None.
RATIONALE
The functionality provided by the 4 BSD groups utility can be simulated using:
id -Gn [ user ]
The 4 BSD command groups was considered, but it was not included because it did not provide the functionality of the
id utility of the SVID. Also, it was thought that it would be easier to modify id to provide the additional
functionality necessary to systems with multiple groups than to invent another command.
The options -u, -g, -n, and -r were added to ease the use of id with shell commands
substitution. Without these options it is necessary to use some preprocessor such as sed
to select the desired piece of information. Since output such as that produced by:
id -u -n
is frequently wanted, it seemed desirable to add the options.
FUTURE DIRECTIONS
None.
SEE ALSO
fold, logname, who
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
XSH getgid(), getgroups(),
getuid()
CHANGE HISTORY
First released in Issue 2.
Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
Issue 8
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/c17.html =====
c17
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
c17 — compile standard C programs
SYNOPSIS
[CD]  c17 [options...] pathname [[pathname]
[-I directory]        [-L
directory] [-l library] [-R directory]]...
DESCRIPTION
The c17 utility is an interface to the standard C compilation system; it shall accept source code written in the C
language as defined in section 6 of the ISO C standard. The system conceptually consists of a compilation phase, encompassing
Translation Phases 1 through 7 of the ISO C standard, and a linkage phase, for handling Phase 8 of the ISO C standard and
extensions described here. The reference to "library components" in Phase 8 shall be taken to refer to components of libraries
specified using the -l option, libraries specified as file.a or file.so operands, and the
equivalent of a -l c option passed to the link editor in the manner specified in the EXTENDED DESCRIPTION. In addition, the
compilation phase can be split into a separate preprocessing operation, handling Translation Phases 1 through 4, and a processing
operation, handling Phases 5 though 7. Whether a single utility or multiple utilities for handling phases separately is provided by
an implementation is left unspecified. The input files referenced by pathname operands and -l option-arguments shall
be compiled and linked to produce an executable file or, if the -G option is specified, a shared library file. It is
unspecified whether the linking of an executable file occurs entirely within the operation of c17; when a pathname
operand or -l option-argument names a shared library, an executable object may be produced that is not fully resolved until
the file is executed.
If the -c option is specified and the -o option is not specified, for all pathname operands of the form
file.c or file.i, the files:
$(basename pathname .c).o
or
$(basename pathname .i).o
respectively shall be created as the result of successful compilation. If the -c option is not specified, it is
unspecified whether such .o files are created or deleted for the file.c and file.i operands.
If there are no options that prevent link editing (such as -c or -E), and all input files compile and link without
error, the resulting executable file or shared library file shall be written according to the -o outfile option, if
present. If -o outfile is not specified, a resulting executable file shall be written to the file a.out; if
the file to be written is a shared library file, the behavior is unspecified.
Executable files shall be created as specified in 1.1.1.4 File Read,
Write, and Creation, except that the file permission bits shall be set to: S_IRWXO | S_IRWXG | S_IRWXU
and the bits specified by the umask of the process shall be cleared.
OPTIONS
The c17 utility shall conform to XBD 12.2 Utility Syntax
Guidelines, except that:
Options can be interspersed with operands.
The order of specifying the -L, -l, and -R options, and the order of specifying -l options with
respect to pathname operands is significant.
Conforming applications shall specify each option separately; that is, grouping option letters (for example, -cO) need
not be recognized by all implementations.
The following options shall be supported:
-B mode
If mode is dynamic, produce a dynamically linked executable file. If the -B option is present with
-c, -E, or -G, the result is unspecified.
-c
Suppress the link-edit phase of the compilation, and do not remove any object files that are produced. The application shall
ensure that all operands are of the form file.c or file.i.
-D name[=value]
Define name as if by a C-language #define directive. If no =value is given, a value of 1 shall be used. The
-D option has lower precedence than the -U option. That is, if name is used in both a -U and a
-D option, name shall be undefined regardless of the order of the options. Additional implementation-defined
names may be provided by the compiler. Implementations shall support at least 2048 bytes of -D definitions and 256
names.
-E
Copy C-language source files to standard output, executing all preprocessor directives; no compilation shall be performed. If
any operand is not a text file, the effects are unspecified.
-G
Create a shared library or create object files suitable for inclusion in such a shared library. Compilations shall be performed
in a manner suitable for the creation of shared libraries (for example, by producing position-independent code).
If -c is also specified, create object files suitable for inclusion in a shared library.
If -c is not specified, create a shared library. In this case the application shall ensure that the file named by the
-o outfile option-argument includes an element named so or an implementation-defined element denoting a shared
library, where elements in the last component of outfile are separated by  characters, for example
libx.so.1; if no -o option is included in the options or the file named by the -o outfile option does
not contain an element named so or an implementation-defined element denoting a shared library, the result is unspecified.
If a pathname operand or -l option-argument names a shared library and that shared library defines an object used by
the library being created, it shall become a dependency of the created shared library.
If the -G option is present with -B or -E, the result is unspecified.
-g
Produce symbolic information in the object or executable files; the nature of this information is unspecified, and may be
modified by implementation-defined interactions with other options.
-I directory
Change the algorithm for searching for headers whose names are not absolute pathnames to look in the directory named by the
directory pathname before looking in the usual places. Thus, headers whose names are enclosed in double-quotes ("")
shall be searched for first in the directory of the file with the #include line, then in directories named in -I
options, and last in the usual places. For headers whose names are enclosed in angle brackets ("<>"), the header
shall be searched for only in directories named in -I options and then in the usual places. Directories named in -I
options shall be searched in the order specified. If the -I option is used to specify a directory that is one of the usual
places searched by default, the results are unspecified. Implementations shall support at least ten instances of this option in a
single c17 command invocation.
-L directory
Change the algorithm of searching for the libraries named in the -l objects to look in the directory named by the
directory pathname before looking in the usual places. Directories named in -L options shall be searched in the order
specified. If the -L option is used to specify a directory that is one of the usual places searched by default, the results
are unspecified. Implementations shall support at least ten instances of this option in a single c17 command invocation. If
a directory specified by a -L option contains files with names starting with any of the strings "libc.",
"libl.", "libpthread.", "libm.", "librt.", "libxnet.", or "liby.", the
results are unspecified.
-l library
Search the library named liblibrary.a or liblibrary.so. When searching for a library, the linker
shall look at each directory specified by -L options that appear on the command line before this -l option, in the
order given, and then the system default libraries. If liblibrary.a and liblibrary.so both exist in a
directory, c17 shall use liblibrary.so if either -B dynamic or -G is specified. Once a library
has been found (shared or static) in a directory, later directories in the list shall not be considered. A library shall be
searched when its name is encountered, so the placement of a -l option is significant. Several standard libraries can be
specified in this manner, as described in the EXTENDED DESCRIPTION section. Implementations may recognize implementation-defined
suffixes other than .a and .so as denoting libraries.
-O optlevel
Specify the level of code optimization. If the optlevel option-argument is the digit '0', all special code
optimizations shall be disabled. If it is the digit '1', the nature of the optimization is unspecified. If the -O
option is omitted, the nature of the system's default optimization is unspecified. It is unspecified whether code generated in the
presence of the -O 0 option is the same as that generated when -O is omitted. Other optlevel values may be
supported.
-o outfile
Name the output file to be produced. If the -o option is present with -E, or with -c and more than one
input file, the result is unspecified.
When creating a single object file (by using -c with a single input file), use the pathname outfile, instead of
the default file.o, for the object file produced.
When creating an executable file, use the pathname outfile, instead of the default a.out, for the executable file
produced.
When creating a shared library, use the pathname outfile as the name of the shared library. If no -o
outfile option is specified when creating a shared library, the result is unspecified.
-s
Produce object or executable files, or both, from which symbolic and other information not required for proper execution using
the exec family defined in the System Interfaces volume of POSIX.1-2024 has been removed (stripped). If both -g and
-s options are present, the action taken is unspecified.
-R directory
If the object file format supports it, specify a directory to be searched for shared libraries when an executable file or
shared library being created by c17 is subsequently executed, or loaded using dlopen(). If directory contains any  or  characters,
the behavior is unspecified. If an implementation provides a means for setting a default load time search location or locations,
the -R option shall take precedence.
The directory named by directory shall not be searched by a process performing dynamic loading if either of the following
are true:
The real and effective user IDs of that process are different and the directory has write permission for a user ID outside the
set of the effective user ID of that process and any implementation-specific user IDs used for directories containing system
libraries.
The real and effective group IDs of that process are different and the directory has write permission for group IDs other than
the effective group ID of that process.
Directories named in -R options shall be searched in the order specified, before the default system library locations are
searched.
If a directory specified by a -R option contains files with names starting with any of the strings "libc.",
"libl.", "libpthread.", "libm.", "librt.", "libxnet.", or "liby.", the result
is unspecified.
If the -R option is present with -c or -E, the result is unspecified.
-U name
Remove any initial definition of name.
Multiple instances of the -D, -I, -L, -l, -R, and -U options can be specified.
OPERANDS
The application shall ensure that at least one pathname operand is specified. The following forms for pathname
operands shall be supported:
file.c
A C-language source file to be compiled and optionally linked.
file.i
A text file containing the output of c17 -E, to be compiled and optionally linked. The processing already
performed by c17 -E when the file was produced shall not be repeated when the file is compiled.
file.a
A library of static object files typically produced by the ar utility, and referenced
during the link-edit phase. Implementations may recognize implementation-defined suffixes other than .a as denoting static
object file libraries.
file.so
A library of shared object files typically produced by the c17 utility with the -G option, and referenced during
the link-edit phase. Implementations may recognize implementation-defined suffixes other than .so as denoting shared object
file libraries.
file.o
An object file produced by c17 -c and passed directly to the link editor. Implementations may recognize
implementation-defined suffixes other than .o as denoting object files.
The processing of other files is implementation-defined.
STDIN
Not used.
INPUT FILES
Each input file shall be one of the following:
A text file containing a C-language source program or the output of c17 -E
An object file in the format produced by c17 -c
A library of object files in the format produced by archiving zero or more object files using ar
A shared library in the format produced by c17 -G
Implementations may supply additional utilities that produce files in these formats. Additional input file formats are
implementation-defined.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of c17:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
TMPDIR
Provide a pathname that should override the default directory for temporary files, if any. [XSI]   On
XSI-conforming systems, provide a pathname that shall override the default directory for temporary files, if any.
ASYNCHRONOUS EVENTS
Default.
STDOUT
If more than one pathname operand ending in .c or .i (or possibly other unspecified suffixes) is given, for
each such file:
"%s:\n",
may be written. These messages, if written, shall precede the processing of each input file; they shall not be written to the
standard output if they are written to the standard error, as described in the STDERR section.
If the -E option is specified, the standard output shall be a text file that represents the results of the preprocessing
stage of the language; it may contain extra information appropriate for subsequent compilation passes and shall contain at least
one line with the format:
"# %d \"%s\"\n", ,
for each file processed as a result of a #include directive, unless no other output generated from that file is present
in the output, where line is a line number and pathname is the pathname used to open the file.
STDERR
The standard error shall be used only for diagnostic messages, except that if more than one pathname operand ending in
.c or .i (or possibly other unspecified suffixes) is given, for each such file:
"%s:\n",
may be written to allow identification of the diagnostic and warning messages with the appropriate input file. These messages,
if written, shall precede the processing of each input file; they shall not be written to the standard error if they are written to
the standard output, as described in the STDOUT section.
This utility may produce warning messages about certain conditions that do not warrant returning an error (non-zero) exit
value.
OUTPUT FILES
Object files or executable files or both are produced in unspecified formats. If the pathname of an object file or executable
file to be created by c17 resolves to an existing directory entry for a file that is not a regular file, it is unspecified
whether c17 shall attempt to create the file or shall issue a diagnostic and exit with a non-zero exit status.
EXTENDED DESCRIPTION
Standard Libraries
The c17 utility shall recognize the following -l options for standard libraries:
-l c
This option shall make available all interfaces referenced in the System Interfaces volume of POSIX.1-2024, with the possible
exception of those interfaces listed as residing in , , ,
, , , , , ,
, ,
, , ,
, pthread_kill() and pthread_sigmask() in , interfaces marked as optional in , interfaces marked as ADV (Advisory Information) in , and interfaces beginning with the prefix clock_ or timer_ in . This option shall not be required to be present to cause a search of this
library.
-l l