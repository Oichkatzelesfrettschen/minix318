When a connection is available, select() indicates that the file descriptor for
the socket is ready for reading.
Many socket options are described as having implementation-defined default values, which may differ according to the protocol in
use by the socket. Existing practice differs on whether socket options such as SO_SNDBUF that were customized on the original
listening socket will impact the corresponding option on the newly returned socket. Implementations are permitted to allow
inheritance of customized settings where it makes sense, although the most portable approach for applications is to limit setsockopt() customizations to only the accepted socket.
For AF_UNIX sockets, it is recommended that address points to a buffer of length greater than sizeof(struct
sockaddr_un) which has been initialized with null bytes. That way, even if the implementation supports the use of all bytes of
sun_path without a terminating null byte, the larger buffer guarantees that the sun_path member can then be passed to
other interfaces that expect a null-terminated string. If no truncation occurred based on the input value of address_len, it
is unspecified whether the returned address_len will be sizeof(struct sockaddr_un), or merely a value at least as
large as offsetof(struct sockaddr_un, sun_path) plus the number of non-null bytes stored in sun_path.
RATIONALE
The SOCK_CLOEXEC and SOCK_CLOFORK flags of accept4() are necessary to avoid a data race in multi-threaded applications.
Without SOCK_CLOFORK, a file descriptor is leaked into a child process created by one thread in the window between another thread
creating a file descriptor with accept() and then using fcntl() to set the
FD_CLOFORK flag. Without SOCK_CLOEXEC, a file descriptor intentionally inherited by child processes is similarly leaked into an
executed program if FD_CLOEXEC is not set atomically.
Two designs often used for network servers are multi-threaded servers with a pre-created pool of worker threads, where the
thread that accepts the connection request hands over the new file descriptor to a worker thread for servicing, and pre-fork
servers with a pre-created pool of worker processes, where the process that accepts the connection request passes the new file
descriptor (for example via sendmsg()) to a worker process. In both of these
designs, accept4() should be used with the SOCK_CLOFORK flag set. Simpler designs are also sometimes used that do not
pre-create a pool. For a multi-threaded server that creates a thread to handle each request, SOCK_CLOFORK should still be used. For
a forking server that creates a child to service each request, clearly SOCK_CLOFORK cannot be used if the child is to inherit the
file descriptor to be serviced, and therefore this type of server needs to use an alternative method of indicating the end of
communications, for example using shutdown(), to ensure the client sees
end-of-file, rather than just closing the socket. Such child processes should set FD_CLOFORK on the inherited file descriptor
before they attempt to start any additional child processes to avoid leakage into those children.
The SOCK_NONBLOCK flag is for convenience in avoiding additional fcntl() calls, as
well as providing specific control over the O_NONBLOCK flag, since traditional implementations of accept() differ on whether
O_NONBLOCK is inherited from the socket argument.
FUTURE DIRECTIONS
None.
SEE ALSO
2.6 File Descriptor Allocation, bind(), connect(), listen(), socket()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
The restrict keyword is added to the accept() prototype for alignment with the ISO/IEC 9899:1999
standard.
Issue 7
SD5-XBD-ERN-4 is applied, changing the definition of the [EMFILE] error.
Austin Group Interpretation 1003.1-2001 #044 is applied, changing the "may fail" [ENOBUFS] and [ENOMEM] errors to become
"shall fail" errors.
Functionality relating to XSI STREAMS is marked obsolescent.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0018 [464] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0035 [835] and XSH/TC2-2008/0036 [836] are applied.
Issue 8
Austin Group Defects 411 and 1318 are applied, adding accept4(), requiring FD_CLOEXEC and FD_CLOFORK to be clear for the
file descriptor returned by accept(), and clarifying the requirements for O_NONBLOCK on the file description created by
accept().
Austin Group Defect 561 is applied, adding a paragraph about sun_path to APPLICATION USAGE.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
Austin Group Defect 1337 is applied, clarifying socket option default values.
Austin Group Defect 1565 is applied, changing the description of address_len.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ccoshl.html =====
ccosh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ccosh, ccoshf, ccoshl — complex hyperbolic cosine functions
SYNOPSIS
#include
double complex ccosh(double complex z);
float complex ccoshf(float complex z);
long double complex ccoshl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex hyperbolic cosine of z.
RETURN VALUE
These functions shall return the complex hyperbolic cosine value.
[MXC]
ccosh(conj(z)), ccoshf(conjf(z)), and ccoshl(conjl(z)) shall return
exactly the same value as conj(ccosh(z)), conjf(ccoshf(z)), and
conjl(ccoshl(z)), respectively, and ccosh(-z), ccoshf(-z), and
ccoshl(-z) shall return exactly the same value as ccosh(z), ccoshf(z), and
ccoshl(z), respectively, including for the special values of z below.
If z is +0 + i0, 1 + i0 shall be returned.
If z is +0 + iInf, NaN ± i0 shall be returned and the invalid floating-point exception shall be raised; the
sign of the imaginary part of the result is unspecified.
If z is +0 + iNaN, NaN ± i0 shall be returned; the sign of the imaginary part of the result is
unspecified.
If z is x + iInf where x is non-zero and finite, NaN + iNaN shall be returned and the invalid
floating-point exception shall be raised.
If z is x + iNaN where x is non-zero and finite, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is +Inf + i0, +Inf + i0 shall be returned.
If z is +Inf + iy where y is non-zero and finite, +Inf (cos(y) + isin(y)) shall
be returned.
If z is +Inf + iInf, ±Inf + iNaN shall be returned and the invalid floating-point exception shall be
raised; the sign of the real part of the result is unspecified.
If z is +Inf + iNaN, +Inf + iNaN shall be returned.
If z is NaN + i0, NaN ± i0 shall be returned; the sign of the imaginary part of the result is
unspecified.
If z is NaN + iy where y is any non-zero number, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is NaN + iNaN, NaN + iNaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
cacosh()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/isfinite.html =====
isfinite
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
isfinite — test for finite value
SYNOPSIS
#include
int isfinite(real-floating x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The isfinite() macro shall determine whether its argument has a finite value (zero, subnormal, or normal, and not
infinite or NaN). First, an argument represented in a format wider than its semantic type is converted to its semantic type. Then
determination is based on the type of the argument.
RETURN VALUE
The isfinite() macro shall return a non-zero value if and only if its argument has a finite value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
fpclassify(), isinf(),
isnan(), isnormal(), signbit()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mtx_unlock.html =====
mtx_lock
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mtx_lock, mtx_timedlock, mtx_trylock, mtx_unlock — lock and unlock a mutex
SYNOPSIS
#include
int mtx_lock(mtx_t *mtx);
int mtx_timedlock(mtx_t *restrict mtx,
const struct timespec *restrict ts);
int mtx_trylock(mtx_t *mtx);
int mtx_unlock(mtx_t *mtx);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The mtx_lock() function shall block until it locks the mutex pointed to by mtx. If the mutex is non-recursive, the
application shall ensure that it is not already locked by the calling thread.
The mtx_timedlock() function shall block until it locks the mutex pointed to by mtx or until after the
TIME_UTC-based calendar time pointed to by ts. The application shall ensure that the specified mutex supports timeout.
[CX]  Under
no circumstance shall the function fail with a timeout if the mutex can be locked immediately. The validity of the ts
parameter need not be checked if the mutex can be locked immediately.
The mtx_trylock() function shall endeavor to lock the mutex pointed to by mtx. If the mutex is already locked (by
any thread, including the current thread), the function shall return without blocking. If the mutex is recursive and the mutex is
currently owned by the calling thread, the mutex lock count (see below) shall be incremented by one and the mtx_trylock()
function shall immediately return success.
[CX]
These functions shall not be affected if the calling thread executes a signal handler during the call; if a signal is delivered to
a thread waiting for a mutex, upon return from the signal handler the thread shall resume waiting for the mutex as if it was not
interrupted.
If a call to mtx_lock(), mtx_timedlock() or mtx_trylock() locks the mutex, prior calls to
mtx_unlock() on the same mutex shall synchronize with this lock operation.
The mtx_unlock() function shall unlock the mutex pointed to by mtx. The application shall ensure that the mutex
pointed to by mtx is locked by the calling thread. [CX]   If there are threads blocked on the mutex object referenced by
mtx when mtx_unlock() is called, resulting in the mutex becoming available, the scheduling policy shall determine
which thread shall acquire the mutex.
A recursive mutex shall maintain the concept of a lock count. When a thread successfully acquires a mutex for the first time,
the lock count shall be set to one. Every time a thread relocks this mutex, the lock count shall be incremented by one. Each time
the thread unlocks the mutex, the lock count shall be decremented by one. When the lock count reaches zero, the mutex shall become
available for other threads to acquire.
For purposes of determining the existence of a data race, mutex lock and unlock operations on mutexes of type mtx_t
behave as atomic operations. All lock and unlock operations on a particular mutex occur in some particular total order.
If mtx does not refer to an initialized mutex object, the behavior of these functions is undefined.
RETURN VALUE
The mtx_lock() and mtx_unlock() functions shall return thrd_success on success, or thrd_error if
the request could not be honored.
The mtx_timedlock() function shall return thrd_success on success, or thrd_timedout if the time
specified was reached without acquiring the requested resource, or thrd_error if the request could not be honored.
The mtx_trylock() function shall return thrd_success on success, or thrd_busy if the resource requested
is already in use, or thrd_error if the request could not be honored. The mtx_trylock() function can spuriously
fail to lock an unused resource, in which case it shall return thrd_busy.
ERRORS
See RETURN VALUE.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
These functions are not affected by signal handlers for the reasons stated in XRAT B.2.3 Error Numbers.
Since  has no equivalent of the mtx_timed mutex
property, if the  interfaces are implemented as a thin wrapper
around  interfaces (meaning mtx_t and
pthread_mutex_t are the same type), all mutexes support timeout and mtx_timedlock() will not fail for a mutex that
was not initialized with mtx_timed. Alternatively, implementations can use a less thin wrapper where mtx_t contains
additional properties that are not held in pthread_mutex_t in order to be able to return a failure indication from
mtx_timedlock() calls where the mutex was not initialized with mtx_timed.
FUTURE DIRECTIONS
None.
SEE ALSO
mtx_destroy(), timespec_get()
XBD
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/lrintf.html =====
lrint
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
lrint, lrintf, lrintl — round to nearest integer value using current rounding direction
SYNOPSIS
#include
long lrint(double x);
long lrintf(float x);
long lrintl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall round their argument to the nearest integer value, rounding according to the current rounding
direction.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the rounded integer value.
[MX]  If
x is NaN, a domain error shall occur and an unspecified value is returned.
If x is +Inf, a domain error shall occur and an unspecified value is returned.
If x is -Inf, a domain error shall occur and an unspecified value is returned.
If the correct value is positive and too large to represent as a long, an unspecified value shall be returned.
[MX]
On systems that support the IEC 60559 Floating-Point option, a domain error shall occur;   otherwise, a [CX]   domain  error may occur.
If the correct value is negative and too large to represent as a long, an unspecified value shall be returned.
[MX]
On systems that support the IEC 60559 Floating-Point option, a domain error shall occur;   otherwise, a [CX]   domain  error may occur.
ERRORS
These functions shall fail if:
Domain Error
[MX]
The x argument is NaN or ±Inf, or the correct value is not representable as an integer.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
These functions may fail if:
Domain Error
The correct value is not representable as an integer.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
These functions provide floating-to-integer conversions. They round according to the current rounding direction. If the rounded
value is outside the range of the return type, the numeric result is unspecified and the invalid floating-point exception is
raised. When they raise no other floating-point exception and the result differs from the argument, they raise the inexact
floating-point exception.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), llrint()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #53 (SD5-XSH-ERN-77) is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mq_timedsend.html =====
mq_send
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mq_send, mq_timedsend — send a message to a message queue (REALTIME)
SYNOPSIS
[MSG]  #include
int mq_send(mqd_t mqdes, const char *msg_ptr, size_t msg_len,
unsigned msg_prio);
int mq_timedsend(mqd_t mqdes, const char *msg_ptr, size_t msg_len,
unsigned msg_prio, const struct timespec *abstime);
DESCRIPTION
The mq_send() function shall add the message pointed to by the argument msg_ptr to the message queue specified by
mqdes. The msg_len argument specifies the length of the message, in bytes, pointed to by msg_ptr. The value of
msg_len shall be less than or equal to the mq_msgsize attribute of the message queue, or mq_send() shall
fail.
If the specified message queue is not full, mq_send() shall behave as if the message is inserted into the message queue
at the position indicated by the msg_prio argument. A message with a larger numeric value of msg_prio shall be
inserted before messages with lower values of msg_prio. A message shall be inserted after other messages in the queue, if
any, with equal msg_prio. The value of msg_prio shall be less than {MQ_PRIO_MAX}.
If the specified message queue is full and O_NONBLOCK is not set in the message queue description associated with mqdes,
mq_send() shall block until space becomes available to enqueue the message, or until mq_send() is interrupted by a
signal. If more than one thread is waiting to send when space becomes available in the message queue and the Priority Scheduling
option is supported, then the thread of the highest priority that has been waiting the longest shall be unblocked to send its
message. Otherwise, it is unspecified which waiting thread is unblocked. If the specified message queue is full and O_NONBLOCK is
set in the message queue description associated with mqdes, the message shall not be queued and mq_send() shall
return an error.
The mq_timedsend() function shall add a message to the message queue specified by mqdes in the manner defined for
the mq_send() function. However, if the specified message queue is full and O_NONBLOCK is not set in the message queue
description associated with mqdes, the wait for sufficient room in the queue shall be terminated when the specified timeout
expires. If O_NONBLOCK is set in the message queue description, this function shall be equivalent to mq_send().
The timeout shall expire when the absolute time specified by abstime passes, as measured by the clock on which timeouts
are based (that is, when the value of that clock equals or exceeds abstime), or if the absolute time specified by
abstime has already been passed at the time of the call.
The timeout shall be based on the CLOCK_REALTIME clock. The resolution of the timeout shall be the resolution of the clock on
which it is based.
Under no circumstance shall the operation fail with a timeout if there is sufficient room in the queue to add the message
immediately. The validity of the abstime parameter need not be checked when there is sufficient room in the queue.
RETURN VALUE
Upon successful completion, the mq_send() and mq_timedsend() functions shall return a value of zero. Otherwise, no
message shall be enqueued, the functions shall return -1, and errno shall be set to indicate the error.
ERRORS
The mq_send() and mq_timedsend() functions shall fail if:
[EAGAIN]
The O_NONBLOCK flag is set in the message queue description associated with mqdes, and the specified message queue is
full.
[EBADF]
The mqdes argument is not a valid message queue descriptor open for writing.
[EINTR]
A signal interrupted the call to mq_send() or mq_timedsend().
[EINVAL]
The value of msg_prio was outside the valid range.
[EINVAL]
The process or thread would have blocked, and the abstime parameter specified a nanoseconds field value less than zero
or greater than or equal to 1000 million.
[EMSGSIZE]
The specified message length, msg_len, exceeds the message size attribute of the message queue.
[ETIMEDOUT]
The O_NONBLOCK flag was not set when the message queue was opened, but the timeout expired before the message could be added to
the queue.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The value of the symbol {MQ_PRIO_MAX} limits the number of priority levels supported by the application. Message priorities
range from 0 to {MQ_PRIO_MAX}-1.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
mq_open(), mq_receive(),
mq_setattr(), time()
XBD ,
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The mq_send() function is marked as part of the Message Passing option.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Message
Passing option.
The mq_timedsend() function is added for alignment with IEEE Std 1003.1d-1999.
Issue 7
The mq_timedsend() function is moved from the Timeouts option to the Base.
Functionality relating to the Timers option is moved to the Base.
Issue 8
Austin Group Defect 592 is applied, removing text relating to  from
the SYNOPSIS and DESCRIPTION sections.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/iswgraph.html =====
iswgraph
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
iswgraph, iswgraph_l — test for a visible wide-character code
SYNOPSIS
#include
int iswgraph(wint_t wc);
[CX]  int iswgraph_l(wint_t wc, locale_t locale);
DESCRIPTION
For iswgraph(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The iswgraph() [CX]   and iswgraph_l()
functions shall test whether wc is a wide-character code representing a character of class graph in the current
locale, [CX]   or in the locale represented by locale,
respectively; see XBD 7. Locale.
The wc argument is a wint_t, the value of which the application shall ensure is a wide-character code
corresponding to a valid character in the locale used by the function, or equal to the value of the macro WEOF. If the argument has
any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to iswgraph_l() is the special locale object LC_GLOBAL_LOCALE or is not
a valid locale object handle.
RETURN VALUE
The iswgraph() [CX]   and iswgraph_l()
functions shall return non-zero if wc is a wide-character code with a visible representation; otherwise, they shall
return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
iswalnum(), iswalpha(),
iswcntrl(), iswctype(),
iswdigit(), iswlower(),
iswprint(), iswpunct(),
iswspace(), iswupper(),
iswxdigit(), setlocale(),
uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 4.
Issue 5
The following change has been made in this version for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E):
The SYNOPSIS has been changed to indicate that this function and associated data types are now made visible by inclusion of the
header rather than .
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The iswgraph_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0326 [302], XSH/TC1-2008/0327 [283], and XSH/TC1-2008/0328 [283] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0187 [685] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/towctrans_l.html =====
towctrans
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
towctrans, towctrans_l — wide-character transliteration
SYNOPSIS
#include
wint_t towctrans(wint_t wc, wctrans_t desc);
[CX]  wint_t towctrans_l(wint_t wc, wctrans_t desc,
locale_t locale);
DESCRIPTION
For towctrans(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The towctrans() [CX]   and towctrans_l()
functions shall transliterate the wide-character code wc using the mapping described by desc.
The current setting of the LC_CTYPE category in the current locale [CX]   or in the
locale represented by locale,   respectively, should be
the same as during the call to wctrans() [CX]   or wctrans_l()   that
returned the value desc.
If the value of desc is invalid (that is, not obtained by a call to wctrans() or desc is invalidated by a subsequent call to setlocale() that has affected category LC_CTYPE ), the result is unspecified.
[CX]  If
the value of desc is invalid (that is, not obtained by a call to wctrans_l() with the same locale object locale) the result is unspecified.
[CX]  An
application wishing to check for error situations should set errno to 0 before calling towctrans() or
towctrans_l().
If errno is non-zero on return, an error has occurred.
The behavior is undefined if the locale argument to towctrans_l() is the special locale object LC_GLOBAL_LOCALE or
is not a valid locale object handle.
RETURN VALUE
If successful, the towctrans() [CX]   and towctrans_l()   functions shall return the mapped value of wc using the mapping described by desc,
or the value of wc unchanged if desc is zero. [CX]   Otherwise, they shall return wc unchanged.
ERRORS
These functions may fail if:
[EINVAL]
[CX]
desc contains an invalid transliteration descriptor.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The strings "tolower" and "toupper" are reserved for the standard mapping names. In the table below, the
functions in the left column are equivalent to the functions in the right column.
towlower(wc)            towctrans(wc, wctrans("tolower"))
towlower_l(wc, locale)  towctrans_l(wc, wctrans("tolower"), locale)
towupper(wc)            towctrans(wc, wctrans("toupper"))
towupper_l(wc, locale)  towctrans_l(wc, wctrans("toupper"), locale)
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
towlower(), towupper(),
wctrans()
XBD
CHANGE HISTORY
First released in Issue 5. Derived from ISO/IEC 9899:1990/Amendment 1:1995 (E).
Issue 6
Extensions beyond the ISO C standard are marked.
Issue 7
The towctrans_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0675 [302], XSH/TC1-2008/0676 [283], and XSH/TC1-2008/0677 [283] are
applied.
Issue 8
Austin Group Defect 1302 is applied, aligning the towctrans() function with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_mutexattr_getpshared.html =====
pthread_mutexattr_getpshared
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_mutexattr_getpshared, pthread_mutexattr_setpshared — get and set the process-shared attribute
SYNOPSIS
[TSH]  #include
int pthread_mutexattr_getpshared(const pthread_mutexattr_t
*restrict attr, int *restrict pshared);
int pthread_mutexattr_setpshared(pthread_mutexattr_t *attr,
int pshared);
DESCRIPTION
The pthread_mutexattr_getpshared() function shall obtain the value of the process-shared attribute from the
attributes object referenced by attr.
The pthread_mutexattr_setpshared() function shall set the process-shared attribute in an initialized attributes
object referenced by attr.
The process-shared attribute is set to PTHREAD_PROCESS_SHARED to permit a mutex to be operated upon by any thread that
has access to the memory where the mutex is allocated, even if the mutex is allocated in memory that is shared by multiple
processes. See 2.9.9 Synchronization Object Copies and Alternative
Mappings for further requirements. The default value of the attribute shall be PTHREAD_PROCESS_PRIVATE.
The behavior is undefined if the value specified by the attr argument to pthread_mutexattr_getpshared() or
pthread_mutexattr_setpshared() does not refer to an initialized mutex attributes object.
RETURN VALUE
Upon successful completion, pthread_mutexattr_setpshared() shall return zero; otherwise, an error number shall be
returned to indicate the error.
Upon successful completion, pthread_mutexattr_getpshared() shall return zero and store the value of the
process-shared attribute of attr into the object referenced by the pshared parameter. Otherwise, an error
number shall be returned to indicate the error.
ERRORS
The pthread_mutexattr_setpshared() function may fail if:
[EINVAL]
The new value specified for the attribute is outside the range of legal values for that attribute.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
If an implementation detects that the value specified by the attr argument to pthread_mutexattr_getpshared() or
pthread_mutexattr_setpshared() does not refer to an initialized mutex attributes object, it is recommended that the function
should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_cond_destroy(), pthread_create(), pthread_mutex_destroy(), pthread_mutexattr_destroy()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_mutexattr_getpshared() and pthread_mutexattr_setpshared() functions are marked as part of the Threads
and Thread Process-Shared Synchronization options.
The restrict keyword is added to the pthread_mutexattr_getpshared() prototype for alignment with the
ISO/IEC 9899:1999 standard.
Issue 7
The pthread_mutexattr_getpshared() and pthread_mutexattr_setpshared() functions are marked only as part of the
Thread Process-Shared Synchronization option as the Threads option is now part of the Base.
The [EINVAL] error for an uninitialized mutex attributes object is removed; this condition results in undefined behavior.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0281 [972] and XSH/TC2-2008/0282 [757] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ldiv.html =====
ldiv
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ldiv, lldiv — compute quotient and remainder of a long division
SYNOPSIS
#include
ldiv_t ldiv(long numer, long denom);
lldiv_t lldiv(long long numer, long long denom);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the quotient and remainder of the division of the numerator numer by the denominator
denom. If the division is inexact, the resulting quotient is the long integer (for the ldiv() function) or
long long integer (for the lldiv() function) of lesser magnitude that is the nearest to the algebraic quotient. If
the result cannot be represented, the behavior is undefined; otherwise, quot * denom+rem shall equal
numer.
RETURN VALUE
The ldiv() function shall return a structure of type ldiv_t, comprising both the quotient and the remainder. The
structure shall include the following members, in any order:
long   quot;    /* Quotient */
long   rem;     /* Remainder */
The lldiv() function shall return a structure of type lldiv_t, comprising both the quotient and the remainder. The
structure shall include the following members, in any order:
long long   quot;    /* Quotient */
long long   rem;     /* Remainder */
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
div()
XBD
CHANGE HISTORY
First released in Issue 4. Derived from the ISO C standard.
Issue 6
The lldiv() function is added for alignment with the ISO/IEC 9899:1999 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_mutexattr_setrobust.html =====
pthread_mutexattr_getrobust
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_mutexattr_getrobust, pthread_mutexattr_setrobust — get and set the mutex robust attribute
SYNOPSIS
#include
int pthread_mutexattr_getrobust(const pthread_mutexattr_t *restrict
attr, int *restrict robust);
int pthread_mutexattr_setrobust(pthread_mutexattr_t *attr,
int robust);
DESCRIPTION
The pthread_mutexattr_getrobust() and pthread_mutexattr_setrobust() functions, respectively, shall get and set the
mutex robust attribute. This attribute is set in the robust parameter. Valid values for robust include:
PTHREAD_MUTEX_STALLED
No special actions are taken if the owner of the mutex is terminated while holding the mutex lock. This can lead to deadlocks if no
other thread can unlock the mutex.
This is the default value.
PTHREAD_MUTEX_ROBUST
If the process containing the owning thread of a robust mutex terminates while holding the mutex lock, the next thread that
acquires the mutex shall be notified about the termination by the return value [EOWNERDEAD] from the locking function. If the
owning thread of a robust mutex terminates while holding the mutex lock, the next thread that attempts to acquire the mutex may be
notified about the termination by the return value [EOWNERDEAD]. The notified thread can then attempt to make the state protected
by the mutex consistent again, and if successful can mark the mutex state as consistent by calling pthread_mutex_consistent(). After a subsequent successful call to pthread_mutex_unlock(), the mutex lock shall be released and can be used
normally by other threads. If the mutex is unlocked without a call to pthread_mutex_consistent(), it shall be in a permanently unusable state and
all attempts to lock the mutex shall fail with the error [ENOTRECOVERABLE]. The only permissible operation on such a mutex is
pthread_mutex_destroy().
The behavior is undefined if the value specified by the attr argument to pthread_mutexattr_getrobust() or
pthread_mutexattr_setrobust() does not refer to an initialized mutex attributes object.
RETURN VALUE
Upon successful completion, the pthread_mutexattr_getrobust() function shall return zero and store the value of the
robust attribute of attr into the object referenced by the robust parameter. Otherwise, an error value shall
be returned to indicate the error. If successful, the pthread_mutexattr_setrobust() function shall return zero; otherwise,
an error number shall be returned to indicate the error.
ERRORS
The pthread_mutexattr_setrobust() function shall fail if:
[EINVAL]
The value of robust is invalid.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The actions required to make the state protected by the mutex consistent again are solely dependent on the application. If it is
not possible to make the state of a mutex consistent, robust mutexes can be used to notify this situation by calling pthread_mutex_unlock() without a prior call to pthread_mutex_consistent().
If the state is declared inconsistent by calling pthread_mutex_unlock() without a prior call to pthread_mutex_consistent(), a possible approach could be to destroy the
mutex and then reinitialize it. However, it should be noted that this is possible only in certain situations where the state
protected by the mutex has to be reinitialized and coordination achieved with other threads blocked on the mutex, because otherwise
a call to a locking function with a reference to a mutex object invalidated by a call to pthread_mutex_destroy() results in undefined behavior.
RATIONALE
If an implementation detects that the value specified by the attr argument to pthread_mutexattr_getrobust() or
pthread_mutexattr_setrobust() does not refer to an initialized mutex attributes object, it is recommended that the function
should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_mutex_consistent(), pthread_mutex_destroy(), pthread_mutex_lock()
XBD
CHANGE HISTORY
First released in Issue 7.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0283 [748] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_sigmask.html =====
pthread_sigmask
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_sigmask, sigprocmask — examine and change blocked signals
SYNOPSIS
[CX]  #include
int pthread_sigmask(int how, const sigset_t *restrict set,
sigset_t *restrict oset);
int sigprocmask(int how, const sigset_t *restrict set,
sigset_t *restrict oset);
DESCRIPTION
The pthread_sigmask() function shall examine or change (or both) the calling thread's signal mask.
If the argument set is not a null pointer, it points to a set of signals to be used to change the currently blocked
set.
The argument how indicates the way in which the set is changed, and the application shall ensure it consists of one of
the following values:
SIG_BLOCK
The resulting set shall be the union of the current set and the signal set pointed to by set.
SIG_SETMASK
The resulting set shall be the signal set pointed to by set.
SIG_UNBLOCK
The resulting set shall be the intersection of the current set and the complement of the signal set pointed to by
set.
If the argument oset is not a null pointer, the previous mask shall be stored in the location pointed to by oset.
If set is a null pointer, the value of the argument how is not significant and the thread's signal mask shall be
unchanged; thus the call can be used to enquire about currently blocked signals.
If the argument set is not a null pointer, after pthread_sigmask() changes the currently blocked set of signals it
shall determine whether there are any pending unblocked signals; if there are any, then at least one of those signals shall be
delivered before the call to pthread_sigmask() returns.
It is not possible to block those signals which cannot be ignored. This shall be enforced by the system without causing an error
to be indicated.
If any of the SIGFPE, SIGILL, SIGSEGV, or SIGBUS signals are generated while they are blocked, the result is undefined, unless
the signal was generated by the action of another process, or by one of the functions kill(), pthread_kill(), raise(), or sigqueue().
If pthread_sigmask() fails, the thread's signal mask shall not be changed.
The sigprocmask() function shall be equivalent to pthread_sigmask(), except that its behavior is unspecified if
called from a multi-threaded process, and on error it returns -1 and sets errno to the error number instead of returning the
error number directly.
RETURN VALUE
Upon successful completion, pthread_sigmask() shall return 0; otherwise, it shall return the corresponding error
number.
Upon successful completion, sigprocmask() shall return 0; otherwise, -1 shall be returned and errno shall be set
to indicate the error.
ERRORS
These functions shall fail if:
[EINVAL]
The set argument is not a null pointer and the value of the how argument is not equal to one of the defined
values.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
Signaling in a Multi-Threaded Process
This example shows the use of pthread_sigmask() in order to deal with signals in a multi-threaded process. It provides a
fairly general framework that could be easily adapted/extended.
#include
#include
#include
#include
#include
#include
...
static sigset_t   signal_mask;  /* signals to block         */
int main (int argc, char *argv[])
{
pthread_t  sig_thr_id;      /* signal handler thread ID */
int        rc;              /* return code              */
sigemptyset (&signal_mask);
sigaddset (&signal_mask, SIGINT);
sigaddset (&signal_mask, SIGTERM);
rc = pthread_sigmask (SIG_BLOCK, &signal_mask, NULL);
if (rc != 0) {
/* handle error */
...
}
/* any newly created threads inherit the signal mask */
rc = pthread_create (&sig_thr_id, NULL, signal_thread, NULL);
if (rc != 0) {
/* handle error */
...
}
/* APPLICATION CODE */
...
}
void *signal_thread (void *arg)
{
int       sig_caught;    /* signal caught       */
int       rc;            /* returned code       */
rc = sigwait (&signal_mask, &sig_caught);
if (rc != 0) {
/* handle error */
}
switch (sig_caught)
{
case SIGINT:     /* process SIGINT  */
...
break;
case SIGTERM:    /* process SIGTERM */
...
break;
default:         /* should normally not happen */
fprintf (stderr, "\nUnexpected signal %d\n", sig_caught);
break;
}
}
APPLICATION USAGE
Although pthread_sigmask() has to deliver at least one of any pending unblocked signals that exist after it has changed
the currently blocked set of signals, there is no requirement that the delivered signal(s) include any that were unblocked by the
change. If one or more signals that were already unblocked become pending (see 2.4.1 Signal Generation and Delivery) during the period the
pthread_sigmask() call is executing, the signal(s) delivered before the call returns might include only those signals.
RATIONALE
When a thread's signal mask is changed in a signal-catching function that is installed by sigaction(), the restoration of the signal mask on return from the signal-catching
function overrides that change (see sigaction()). If the signal-catching function
was installed with signal(), it is unspecified whether this occurs.
See kill() for a discussion of the requirement on delivery of signals.
FUTURE DIRECTIONS
None.
SEE ALSO
exec, kill(), sigaction(), sigaddset(), sigdelset(), sigemptyset(), sigfillset(),
sigismember(), sigpending()
, sigqueue(), sigsuspend()
XBD
CHANGE HISTORY
First released in Issue 3. Included for alignment with the POSIX.1-1988 standard.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Threads Extension.
The pthread_sigmask() function is added for alignment with the POSIX Threads Extension.
Issue 6
The pthread_sigmask() function is marked as part of the Threads option.
The SYNOPSIS for sigprocmask() is marked as a CX extension to note that the presence of this function in the  header is an extension to the ISO C standard.
The following changes are made for alignment with the ISO POSIX-1:1996 standard:
The DESCRIPTION is updated to explicitly state the functions which may generate the signal.
The normative text is updated to avoid use of the term "must" for application requirements.
The restrict keyword is added to the pthread_sigmask() and sigprocmask() prototypes for alignment with the
ISO/IEC 9899:1999 standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/105 is applied, updating "process' signal mask" to "thread's
signal mask" in the DESCRIPTION and RATIONALE sections.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/106 is applied, adding the example to the EXAMPLES section.
Issue 7
The pthread_sigmask() function is moved from the Threads option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0467 [319] is applied.
Issue 8
Austin Group Defect 1132 is applied, clarifying the [EINVAL] error.
Austin Group Defect 1636 is applied, clarifying the exceptions to the equivalence of pthread_sigmask() and
sigprocmask().
Austin Group Defect 1731 is applied, clarifying that although pthread_sigmask() has to deliver at least one of any
pending unblocked signals that exist after it has changed the currently blocked set of signals, there is no requirement that the
delivered signal(s) include any that were unblocked by the change.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/linkat.html =====
link
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
link, linkat — hard link one file to another file
SYNOPSIS
#include
int link(const char *path1, const char *path2);
[OH] #include
int linkat(int fd1, const char *path1, int fd2,
const char *path2, int flag);
DESCRIPTION
The link() function shall create a new hard link (directory entry) for the existing file, path1.
The path1 argument points to a pathname naming an existing file. The path2 argument points to a pathname naming
the new directory entry to be created. The link() function shall atomically create a new hard link for the existing file and
the link count of the file shall be incremented by one.
If path1 names a directory, link() shall fail unless the process has appropriate privileges and the implementation
supports using link() on directories.
If path1 names a symbolic link, it is implementation-defined whether link() follows the symbolic link, or creates
a new hard link to the symbolic link itself.
Upon successful completion, link() shall mark for update the last file status change timestamp of the file. Also, the
last data modification and last file status change timestamps of the directory that contains the new entry shall be marked for
update.
If link() fails, no link shall be created and the link count of the file shall remain unchanged.
The implementation may require that the calling process has permission to access the existing file.
The linkat() function shall be equivalent to the link() function except that symbolic links shall be handled as
specified by the value of flag (see below) and except in the case where either path1 or path2 or both are
relative paths. In this case a relative path path1 is interpreted relative to the directory associated with the file
descriptor fd1 instead of the current working directory and similarly for path2 and the file descriptor fd2.
If the access mode of the open file description associated with the file descriptor is not O_SEARCH, the function shall check
whether directory searches are permitted using the current permissions of the directory underlying the file descriptor. If the
access mode is O_SEARCH, the function shall not perform the check.
Values for flag are constructed by a bitwise-inclusive OR of flags from the following list, defined in :
AT_SYMLINK_FOLLOW
If path1 names a symbolic link, a new hard link for the target of the symbolic link is created.
If linkat() is passed the special value AT_FDCWD in the fd1 or fd2 parameter, the current working directory
shall be used for the respective path argument. If both fd1 and fd2 have value AT_FDCWD, the behavior shall be
identical to a call to link(), except that symbolic links shall be handled as specified by the value of flag.
If the AT_SYMLINK_FOLLOW flag is clear in the flag argument and the path1 argument names a symbolic link, a new
hard link is created for the symbolic link path1 and not its target.
RETURN VALUE
Upon successful completion, these functions shall return 0. Otherwise, these functions shall return -1 and set errno to
indicate the error.
ERRORS
These functions shall fail if:
[EACCES]
A component of either path prefix denies search permission, or the requested link requires writing in a directory that denies
write permission, or the calling process does not have permission to access the existing file and this is required by the
implementation.
[EEXIST]
The path2 argument resolves to an existing directory entry or refers to a symbolic link.
[EILSEQ]
The last pathname component of path2 is not a portable filename, and cannot be created in the target directory.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path1 or path2 argument.
[EMLINK]
The number of hard links to the file named by path1 would exceed {LINK_MAX}.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of either path prefix does not exist; the file named by path1 does not exist; or path1 or
path2 points to an empty string.
[ENOENT] or [ENOTDIR]
The path1 argument names an existing non-directory file, and the path2 argument contains at least one
non- character and ends with one or more trailing  characters. If path2 without the trailing
characters would name an existing file, an [ENOENT] error shall not occur.
[ENOSPC]
The directory to contain the link cannot be extended.
[ENOTDIR]
A component of either path prefix names an existing file that is neither a directory nor a symbolic link to a directory, or the
path1 argument contains at least one non- character and ends with one or more trailing  characters
and the last pathname component names an existing file that is neither a directory nor a symbolic link to a directory, or the
path1 argument names an existing non-directory file and the path2 argument names a nonexistent file, contains at
least one non- character, and ends with one or more trailing  characters.
[EPERM]
The file named by path1 is a directory and either the calling process does not have appropriate privileges or the
implementation prohibits using link() on directories.
[EROFS]
The requested link requires writing in a directory on a read-only file system.
[EXDEV]
The file named by path1 and the directory in which the directory entry named by path2 is to be created are on
different file systems and the implementation does not support hard links between file systems.
The linkat() function shall fail if:
[EACCES]
The access mode of the open file description associated with fd1 or fd2 is not O_SEARCH and the permissions of
the directory underlying fd1 or fd2, respectively, do not permit directory searches.
[EBADF]
The path1 or path2 argument does not specify an absolute path and the fd1 or fd2 argument,
respectively, is neither AT_FDCWD nor a valid file descriptor open for reading or searching.
[ENOTDIR]
The path1 or path2 argument is not an absolute path and fd1 or fd2, respectively, is a file
descriptor associated with a non-directory file.
These functions may fail if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path1 or path2 argument.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
The linkat() function may fail if:
[EINVAL]
The value of the flag argument is not valid.
The following sections are informative.
EXAMPLES
Creating a Hard Link to a File
The following example shows how to create an additional hard link to a file named /home/cnd/mod1 by creating a new
directory entry named /modules/pass1.
#include
char *path1 = "/home/cnd/mod1";
char *path2 = "/modules/pass1";
int   status;
...
status = link (path1, path2);
Creating a Hard Link to a File Within a Program
In the following program example, the link() function hard links the /etc/passwd file (defined as
PASSWDFILE) to a file named /etc/opasswd (defined as SAVEFILE), which is used to save the current password
file. Then, after removing the current password file (defined as PASSWDFILE), the new password file is saved as the current
password file using the link() function again.
#include
#define LOCKFILE "/etc/ptmp"
#define PASSWDFILE "/etc/passwd"
#define SAVEFILE "/etc/opasswd"
...
/* Save current password file */
link (PASSWDFILE, SAVEFILE);
/* Remove current password file. */
unlink (PASSWDFILE);
/* Save new password file as current password file. */
link (LOCKFILE,PASSWDFILE);
APPLICATION USAGE
Some implementations do allow hard links between file systems.
If path1 refers to a symbolic link, application developers should use linkat() with appropriate flags to select
whether or not the symbolic link should be resolved.
RATIONALE
Creating additional hard links to a directory is restricted to the superuser in most historical implementations because this
capability may produce loops in the file hierarchy or otherwise corrupt the file system. This volume of POSIX.1-2024 continues that
philosophy by prohibiting link() and unlink() from doing this. Other functions
could do it if the implementor designed such an extension.
Some historical implementations allow hard linking of files on different file systems. Wording was added to explicitly allow
this optional behavior.
The exception for cross-file system hard links is intended to apply only to links that are programmatically indistinguishable
from traditional hard links.
The purpose of the linkat() function is to link files in directories other than the current working directory without
exposure to race conditions. Any part of the path of a file could be changed in parallel to a call to link(), resulting in
unspecified behavior. By opening a file descriptor for the directory of both the existing file and the target location and using
the linkat() function it can be guaranteed that the both filenames are in the desired directories.
Earlier versions of this standard specified only the link() function, and required it to behave like linkat() with
the AT_SYMLINK_FOLLOW flag. However, historical practice from SVR4 and Linux kernels had link() behaving like
linkat() with no flags, and many systems that attempted to provide a conforming link() function did so in a way that
was rarely used, and when it was used did not conform to the standard (e.g., by not being atomic, or by dereferencing the symbolic
link incorrectly). Since applications could not rely on link() following symbolic links in practice, the linkat()
function was added taking a flag to specify the desired behavior for the application.
Implementations are encouraged to have link() and linkat() report an [EILSEQ] error if the file named by
path2 did not previously exist, and the last component of that pathname contains any bytes that have the encoded value of a
character.
FUTURE DIRECTIONS
None.
SEE ALSO
rename(), symlink(), unlink()
XBD ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The [ELOOP] mandatory error condition is added.
A second [ENAMETOOLONG] is added as an optional error condition.
The following changes were made to align with the IEEE P1003.1a draft standard:
An explanation is added of the action when path2 refers to a symbolic link.
The [ELOOP] optional error condition is added.
Issue 7
Austin Group Interpretation 1003.1-2001 #143 is applied.
SD5-XSH-ERN-93 is applied, adding RATIONALE.
The linkat() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 2.
Functionality relating to XSI STREAMS is marked obsolescent.
Changes are made related to support for finegrained timestamps.
The [EOPNOTSUPP] error is removed.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0354 [326], XSH/TC1-2008/0355 [461], XSH/TC1-2008/0356 [326],
XSH/TC1-2008/0357 [324], XSH/TC1-2008/0358 [147,429], XSH/TC1-2008/0359 [277], XSH/TC1-2008/0360 [278], and XSH/TC1-2008/0361 [278]
are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0195 [873], XSH/TC2-2008/0196 [591], XSH/TC2-2008/0197 [817],
XSH/TC2-2008/0198 [822], and XSH/TC2-2008/0199 [817] are applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defect 293 is applied, adding the [EILSEQ] error.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
Austin Group Defect 1380 is applied, changing text using the term "link" in line with its updated definition and removing a
paragraph from the RATIONALE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/vdprintf.html =====
vfprintf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
vasprintf, vdprintf, vfprintf, vprintf, vsnprintf, vsprintf — format output of a stdarg argument list
SYNOPSIS
#include
#include
[CX]  int vasprintf(char **restrict ptr, const char *restrict format,
va_list ap);
int vdprintf(int fildes, const char *restrict format, va_list ap);
int vfprintf(FILE *restrict stream, const char *restrict format,
va_list ap);
int vprintf(const char *restrict format, va_list ap);
int vsnprintf(char *restrict s, size_t n, const char *restrict format,
va_list ap);
int vsprintf(char *restrict s, const char *restrict format, va_list
ap);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The [CX]
vasprintf(), vdprintf(),  vfprintf(),
vprintf(), vsnprintf(), and vsprintf() functions shall be equivalent to the [CX]  asprintf(), dprintf(),  fprintf(), printf(), snprintf(), and sprintf() functions respectively, except that instead of being called with a variable number
of arguments, they are called with an argument list as defined by .
These functions shall not invoke the va_end macro. As these functions invoke the va_arg macro, the value of
ap after the return is unspecified.
RETURN VALUE
Refer to fprintf().
ERRORS
Refer to fprintf().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications using these functions should call va_end(ap) afterwards to clean up.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fprintf()
XBD ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The vsnprintf() function is added.
Issue 6
The vfprintf(), vprintf(), vsnprintf(), and vsprintf() functions are updated for alignment with the
ISO/IEC 9899:1999 standard.
Issue 7
The vdprintf() function is added to complement the dprintf() function from
The Open Group Technical Standard, 2006, Extended API Set Part 1.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0703 [14] is applied.
Issue 8
Austin Group Defect 1496 is applied, adding the vasprintf() function.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_spin_destroy.html =====
pthread_spin_destroy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_spin_destroy, pthread_spin_init — destroy or initialize a spin lock object
SYNOPSIS
#include
int pthread_spin_destroy(pthread_spinlock_t *lock);
int pthread_spin_init(pthread_spinlock_t *lock, int pshared);
DESCRIPTION
The pthread_spin_destroy() function shall destroy the spin lock referenced by lock and release any resources used
by the lock. The effect of subsequent use of the lock is undefined until the lock is reinitialized by another call to
pthread_spin_init(). The results are undefined if pthread_spin_destroy() is called when a thread holds the lock, or
if this function is called with an uninitialized thread spin lock.
The pthread_spin_init() function shall allocate any resources required to use the spin lock referenced by lock and
initialize the lock to an unlocked state.
[TSH]
If the Thread Process-Shared Synchronization option is supported and the value of pshared is PTHREAD_PROCESS_SHARED, the
implementation shall permit the spin lock to be operated upon by any thread that has access to the memory where the spin lock is
allocated, even if it is allocated in memory that is shared by multiple processes.
See 2.9.9 Synchronization Object Copies and Alternative Mappings
for further requirements.
The results are undefined if pthread_spin_init() is called specifying an already initialized spin lock. The results are
undefined if a spin lock is used without first being initialized.
If the pthread_spin_init() function fails, the lock is not initialized and the contents of lock are undefined.
Only the object referenced by lock may be used for performing synchronization.
The result of referring to copies of that object in calls to pthread_spin_destroy(), pthread_spin_lock(), pthread_spin_trylock(), or pthread_spin_unlock() is undefined.
RETURN VALUE
Upon successful completion, these functions shall return zero; otherwise, an error number shall be returned to indicate the
error.
ERRORS
The pthread_spin_init() function shall fail if:
[EAGAIN]
The system lacks the necessary resources to initialize another spin lock.
[ENOMEM]
Insufficient memory exists to initialize the lock.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
If an implementation detects that the value specified by the lock argument to pthread_spin_destroy() does not
refer to an initialized spin lock object, it is recommended that the function should fail and report an [EINVAL] error.
If an implementation detects that the value specified by the lock argument to pthread_spin_destroy() or
pthread_spin_init() refers to a locked spin lock object, or detects that the value specified by the lock argument to
pthread_spin_init() refers to an already initialized spin lock object, it is recommended that the function should fail and
report an [EBUSY] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_spin_lock(), pthread_spin_unlock()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1j-2000.
In the SYNOPSIS, the inclusion of  is no longer
required.
Issue 7
The pthread_spin_destroy() and pthread_spin_init() functions are moved from the Spin Locks option to the Base.
The [EINVAL] error for an uninitialized spin lock object is removed; this condition results in undefined behavior.
The [EBUSY] error for a locked spin lock object or an already initialized spin lock object is removed; this condition results in
undefined behavior.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0297 [972] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/isgraph_l.html =====
isgraph
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
isgraph, isgraph_l — test for a visible character
SYNOPSIS
#include
int isgraph(int c);
[CX]  int isgraph_l(int c, locale_t locale);
DESCRIPTION
For isgraph(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The isgraph() [CX]   and isgraph_l()
functions shall test whether c is a character of class graph in the current locale, [CX]   or in the
locale represented by locale,  respectively; see XBD 7. Locale.
The c argument is an int, the value of which the application shall ensure is a character representable as an
unsigned char or equal to the value of the macro EOF. If the argument has any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to isgraph_l() is the special locale object LC_GLOBAL_LOCALE or is not a
valid locale object handle.
RETURN VALUE
The isgraph() [CX]   and isgraph_l()
functions shall return non-zero if c is a character with a visible representation; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
isalnum(), isalpha(), isblank(), iscntrl(), isdigit(), islower(), isprint(), ispunct(), isspace(), isupper(), isxdigit(), setlocale(), uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The isgraph_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0289 [302], XSH/TC1-2008/0290 [283], and XSH/TC1-2008/0291 [283] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/dngettext.html =====
gettext
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
dgettext, dgettext_l, dcgettext, dcgettext_l, gettext, gettext_l, ngettext, ngettext_l, dngettext, dngettext_l,
dcngettext, dcngettext_l — message handling functions
SYNOPSIS
#include
char *dgettext(const char *domainname, const char *msgid);
char *dgettext_l(const char *domainname, const char *msgid,
locale_t locale);
char *dcgettext(const char *domainname, const char *msgid,
int category);
char *dcgettext_l(const char *domainname, const char *msgid,
int category, locale_t locale);
char *dngettext(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n);
char *dngettext_l(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n,
locale_t locale);
char *dcngettext(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n,
int category);
char *dcngettext_l(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n,
int category, locale_t locale);
char *gettext(const char *msgid);
char *gettext_l(const char *msgid, locale_t locale);
char *ngettext(const char *msgid, const char *msgid_plural,
unsigned long int n);
char *ngettext_l(const char *msgid, const char *msgid_plural,
unsigned long int n, locale_t locale);
DESCRIPTION
The gettext() function shall:
attempt to locate a suitable messages object (described in detail below) for the LC_MESSAGES category in the current
locale, and for the current text domain (see bindtextdomain()), containing
the string identified by msgid,
retrieve the string identified by msgid from the messages object,
convert the string to the output codeset if necessary (described in detail below), and
return the result.
If the locale name in effect is "POSIX" or "C" (i.e. the name associated with the LC_MESSAGES locale
category in the current locale), or if no suitable messages object exists, or if no string identified by msgid exists in the
messages object, or if an error occurs, msgid shall be returned.
The dgettext() function shall be equivalent to gettext(), except domainname shall be used instead of the
current text domain to locate the messages object.
The dcgettext() function shall be equivalent to dgettext(), except the locale category identified by
category shall be used instead of LC_MESSAGES .
The ngettext() function shall be equivalent to gettext(), except:
The string to retrieve shall be identified by a combination of msgid and n (see msgfmt).
If the locale name in effect is "POSIX" or "C", or if no suitable messages object exists, or if no string
identified by the combination of msgid and n exists in the messages object, or if an error occurs, the return value
shall be msgid if n is 1, otherwise msgid_plural.
The dngettext() function shall be equivalent to ngettext(), except domainname shall be used instead of the
current text domain to locate the messages object.
The dcngettext() function shall be equivalent to dngettext(), except the locale category identified by
category shall be used instead of LC_MESSAGES .
The *_l() functions shall be equivalent to their counterparts without the _l suffix, except locale shall be
used instead of the current locale. If locale is the special locale object LC_GLOBAL_LOCALE or is not a valid locale object
handle, the behavior is undefined.
The application shall ensure that the msgid and msgid_plural arguments are strings. If either msgid or
msgid_plural is an empty string, or contains characters not in the portable character set, the results are unspecified. If
the category argument is LC_ALL , the results are unspecified.
The location of the messages object shall be determined according to the following criteria, stopping when the first messages
object is found:
[XSI]
If the NLSPATH environment variable is set to a non-empty string, an NLSPATH search shall be performed as described
in XBD 8.2 Internationalization Variables. If NLSPATH identifies
more than one template to use, each template in turn shall be used until a valid messages object is found.
If the LANGUAGE environment variable is set to a non-empty string, a LANGUAGE search shall be performed as
described below. If LANGUAGE identifies more than one directory to search, each directory shall be searched until a valid
messages object is found.
A single-locale search shall be performed as described below.
For [XSI]   the NLSPATH search and   the single-locale search,
the single locale name used to locate the messages object shall be the locale name associated with the selected locale category
from the current locale, or the provided locale object if calling one of the *_l() functions; additional searches of locale
names without .codeset (if present), without _territory (if present), and without @modifier (if present) may
be performed.
For the LANGUAGE search, the value of the LANGUAGE environment variable shall be a list of one or more locale
names separated by a  (':') character. Each locale name shall be tried in the specified order. If a messages
object for the locale does not exist, or cannot be opened, or is unsuitable for implementation-defined reasons (such as security),
the next locale name (if any) shall be tried. If:
a messages object for the locale can be opened but cannot be processed without error, or
the messages object does not contain a string identified by msgid, or msgid and n for the ngettext
functions,
it is unspecified whether the next locale name (if any) is tried. In all other cases, the messages object for the locale shall
be used.
For each locale name in LANGUAGE , or if LANGUAGE is not set or is empty, or no suitable messages object is found
in processing LANGUAGE , the pathname used to locate the messages object shall be
dirname/localename/categoryname/textdomainname.mo, where:
The dirname part is the dirname argument of the most recent successful call to bindtextdomain() that had textdomainname as the domainname argument;
any trailing  characters in dirname shall be discarded. If a successful call to bindtextdomain() has not been made for textdomainname, an
implementation-defined default directory shall be used.
For the LANGUAGE search, the localename part is each locale name from LANGUAGE in turn; if a locale name
has the format language[_territory][.codeset][@modifier], additional
searches of locale names without .codeset (if present), without _territory (if present), and without @modifier
(if present) may be performed; if .codeset is not present, additional searches of locale names with an added .codeset
may be performed. For the single-locale search, the localename part is the name of the current locale, or the locale
specified in an *_l() function call, for the category named by categoryname. Spellings of codeset names are not
standardized, and implementations may attempt to use different commonly known spellings, for example "utf8" and
"UTF-8".
The categoryname part is the string "LC_MESSAGES" if gettext(), dgettext(), ngettext(), or
dngettext() is called, or the locale category name corresponding to the category argument to dcgettext() or
dcngettext(). Likewise for the *_l() variants of all these functions.
For gettext(), gettext_l(), ngettext(), and ngettext_l(), the textdomainname part is the text
domain set by the last successful call to textdomain(). For dgettext(),
dcgettext(), dngettext(), dcngettext(), and the *_l() variants of these functions,
textdomainname is the text domain specified by the domainname argument. The domainname argument shall be
equivalent in syntax and meaning to the domainname argument to textdomain(), except that the selection of the text domain shall affect only the
dgettext(), dcgettext(), dngettext(), and dcngettext() function calls and their *_l() variants.
If the domainname argument is a null pointer, the text domain set by the last successful call to textdomain() shall be used. For all of these functions, if a successful call to textdomain() has not been made the default text domain "messages" shall be
used.
Resolution of the messages object pathname shall be performed the first time one of the gettext family of functions is
called for a given combination of dirname, localename, categoryname, and textdomainname. It is
unspecified whether the pathname is re-resolved if the combination has been used before in a call to one of the gettext
family of functions. If bindtextdomain() performs pathname resolution of its
dirname argument, only the part of the messages object pathname after dirname shall be resolved by the gettext
family of functions.
When one of the gettext family of functions returns a message string that was found in a messages object, it shall
convert the codeset of the message string to the output codeset if a codeset is specified in the messages object (see msgfmt) and the output codeset is not the same as that codeset. If a successful call to
bind_textdomain_codeset() has been made with the text domain of the
messages object as the domainname argument and a non-null codeset argument, the output codeset shall be the
codeset argument from the most recent such call. Otherwise, the output codeset shall be the codeset of characters in the
current locale, or the provided locale object if calling one of the *_l() functions, as specified by the LC_CTYPE
category of the locale. The conversion shall be performed as if by a call to iconv()
using a conversion descriptor returned by iconv_open(, ),
except that if the return value of iconv() would be greater than zero, the
non-identical conversions performed by the gettext family of functions need not be the same as those that such an iconv() call would perform. If an error prevents the codeset conversion from being performed,
the gettext family of functions shall behave as if no message string was found in the messages object. If at least one
non-identical conversion is performed that results in a fallback character (one that does not provide any information about the
character it was converted from, for example, a  or "replacement-character"), the gettext family of
functions may behave as if no message string was found in the messages object.
RETURN VALUE
The gettext(), gettext_l(), dgettext(), dgettext_l(), dcgettext(), and dcgettext_l()
functions shall return the message string described in DESCRIPTION if successful. Otherwise, they shall return msgid.
The ngettext(), ngettext_l(), dngettext(), dngettext_l(), dcngettext(), and
dcngettext_l() functions shall return the message string described in DESCRIPTION if successful. Otherwise, msgid
shall be returned if n is equal to 1, or msgid_plural if n is not equal to 1.
The application shall ensure that it does not modify the returned string. A subsequent call to a gettext family function
shall not overwrite or invalidate the returned string. The returned string may be invalidated by a subsequent call to bind_textdomain_codeset(), bindtextdomain(), setlocale(), or
textdomain() in the same process, except for calls that only query values. The
returned string shall not be invalidated by a subsequent call to uselocale().
ERRORS
The gettext family of functions shall not modify errno. If an error occurs these functions shall return a string
as described in RETURN VALUE.
The following sections are informative.
EXAMPLES
The example code below assumes the following:
The implementation-defined default directory is /system/gettextlib.
The following locales are available on the target system: en_US, en_GB, de_DE. The codeset used for all of these locales is
UTF-8.
The en_AU locale is not available on the target system.
The target system supports conversion from ISO/IEC 8859-1 to UTF-8.
The codeset used for the POSIX locale is ASCII.
The target system does not support conversion from ISO/IEC 8859-1 to ASCII.
Furthermore, the following .mo files (and only the following .mo files) are installed:
/system/gettextlib/en_US/LC_MESSAGES/mail.mo
/messagecatalogs/example/en_US/LC_MESSAGES/mail.mo
These are compiled from a portable messages object source file (dot-po file) with the following ISO/IEC 8859-1 encoded contents
(see the EXTENDED DESCRIPTION of the msgfmt utility for a description of the dot-po
file format):
msgid ""
msgstr ""
"Content-Type: text/plain; charset=ISO_8859-1\n"
"Plural-Forms: nplurals=4; plural= n==1?0: (n>1&&n1&&n1&&n,
XCU gettext, msgfmt,
xgettext
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/aio_return.html =====
aio_return
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
aio_return — retrieve return status of an asynchronous I/O operation
SYNOPSIS
#include
ssize_t aio_return(struct aiocb *aiocbp);
DESCRIPTION
The aio_return() function shall return the return status associated with the aiocb structure referenced by the
aiocbp argument. The return status for an asynchronous I/O operation is the value that would be returned by the
corresponding read(), write(), or fsync() function call. If the error status for the operation is equal to [EINPROGRESS], then
the return status for the operation is undefined. The aio_return() function may be called exactly once to retrieve the
return status of a given asynchronous operation; thereafter, if the same aiocb structure is used in a call to
aio_return() or aio_error(), an error may be returned. When the
aiocb structure referred to by aiocbp is used to submit another asynchronous operation, then aio_return() may
be successfully used to retrieve the return status of that operation.
RETURN VALUE
If the asynchronous I/O operation has completed, then the return status, as described for read(), write(), and fsync(), shall be returned. If the asynchronous I/O operation has not yet completed, the
results of aio_return() are undefined.
If the aio_return() function fails, it shall return -1 and set errno to indicate the error.
ERRORS
The aio_return() function may fail if:
[EINVAL]
The aiocbp argument does not refer to an asynchronous operation whose return status has not yet been retrieved.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
aio_cancel(), aio_error()
, aio_fsync(), aio_read(),
aio_write(), close(), exec, exit(), fork(), lio_listio(), lseek(), read()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the
Asynchronous Input and Output option.
The APPLICATION USAGE section is added.
The [EINVAL] error condition is made optional. This is for consistency with the DESCRIPTION.
Issue 7
SD5-XSH-ERN-148 is applied.
The aio_return() function is moved from the Asynchronous Input and Output option to the Base.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/futimens.html =====
futimens
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
futimens, utimensat, utimes — set file access and modification times
SYNOPSIS
#include
int futimens(int fd, const struct timespec times[2]);
[OH] #include
int utimensat(int fd, const char *path, const struct timespec times[2],
int flag);
[XSI]
#include
int utimes(const char *path, const struct timeval times[2]);
DESCRIPTION
The futimens() and utimensat() functions shall set the access and modification times of a file to the values of
the times argument. The futimens() function changes the times of the file associated with the file descriptor
fd. The utimensat() function changes the times of the file pointed to by the path argument, relative to the
directory associated with the file descriptor fd. Both functions allow time specifications accurate to the nanosecond.
For futimens() and utimensat(), the times argument is an array of two timespec structures. The first
array member represents the date and time of last access, and the second member represents the date and time of last modification.
The times in the timespec structure are measured in seconds and nanoseconds since the Epoch. The file's relevant timestamp
shall be set to the greatest value supported by the file system that is not greater than the specified time.
If the tv_nsec field of a timespec structure has the special value UTIME_NOW, the file's relevant timestamp shall
be set to the greatest value supported by the file system that is not greater than the current time. If the tv_nsec field
has the special value UTIME_OMIT, the file's relevant timestamp shall not be changed. In either case, the tv_sec field shall
be ignored.
If the times argument is a null pointer, both the access and modification timestamps shall be set to the greatest value
supported by the file system that is not greater than the current time. If utimensat() is passed a relative path in the
path argument, the file to be used shall be relative to the directory associated with the file descriptor fd instead
of the current working directory. If the access mode of the open file description associated with the file descriptor is not
O_SEARCH, the function shall check whether directory searches are permitted using the current permissions of the directory
underlying the file descriptor. If the access mode is O_SEARCH, the function shall not perform the check.
If utimensat() is passed the special value AT_FDCWD in the fd parameter, the current working directory shall be
used.
Only a process with the effective user ID equal to the user ID of the file, or with write access to the file, or with
appropriate privileges may use futimens() or utimensat() with a null pointer as the times argument or with
both tv_nsec fields set to the special value UTIME_NOW. Only a process with the effective user ID equal to the user ID of
the file or with appropriate privileges may use futimens() or utimensat() with a non-null times argument that
does not have both tv_nsec fields set to UTIME_NOW and does not have both tv_nsec fields set to UTIME_OMIT. If both
tv_nsec fields are set to UTIME_OMIT, no ownership or permissions check shall be performed for the file, but other error
conditions may still be detected (including [EACCES] errors related to the path prefix).
Values for the flag argument of utimensat() are constructed by a bitwise-inclusive OR of flags from the following
list, defined in :
AT_SYMLINK_NOFOLLOW
If path names a symbolic link, then the access and modification times of the symbolic link are changed.
Upon successful completion, futimens() and utimensat() shall mark the last file status change timestamp for
update, with the exception that if both tv_nsec fields are set to UTIME_OMIT, the file status change timestamp need not be
marked for update.
The utimes() function shall be equivalent to the utimensat() function with the special value AT_FDCWD as the
fd argument and the flag argument set to zero, except that the times argument is a timeval structure
rather than a timespec structure, and accuracy is only to the microsecond, not nanosecond, and rounding towards the nearest
second may occur.
RETURN VALUE
Upon successful completion, these functions shall return 0. Otherwise, these functions shall return -1 and set errno to
indicate the error. If -1 is returned, the file times shall not be affected.
ERRORS
The utimes() function shall fail, the futimens() and utimensat() functions shall fail in the case that the
times argument does not have both tv_nsec fields set to UTIME_OMIT, and the futimens() and utimensat()
functions may fail in the case that the times argument has both tv_nsec fields set to UTIME_OMIT, if:
[EACCES]
The times argument is a null pointer, or both tv_nsec values are UTIME_NOW, and the effective user ID of the
process does not match the owner of the file and write access is denied.
[EINVAL]
Either of the times argument structures specified a tv_nsec value that was neither UTIME_NOW nor UTIME_OMIT, and
was a value less than zero or greater than or equal to 1000 million.
[EINVAL]
A new file timestamp would be a value whose tv_sec component is not a value supported by the file system.
[EPERM]
The times argument is not a null pointer, does not have both tv_nsec fields set to UTIME_NOW, does not have both
tv_nsec fields set to UTIME_OMIT, the calling process' effective user ID does not match the owner of the file, and the
calling process does not have appropriate privileges.
[EROFS]
The file system containing the file is read-only.
The futimens() function shall fail in the case that the times argument does not have both tv_nsec fields
set to UTIME_OMIT, and may fail in the case that the times argument has both tv_nsec fields set to UTIME_OMIT,
if:
[EBADF]
The fd argument is not a valid file descriptor.
The utimensat() function shall fail in the case that the times argument does not have both tv_nsec fields
set to UTIME_OMIT, and may fail in the case that the times argument has both tv_nsec fields set to UTIME_OMIT,
if:
[EACCES]
The access mode of the open file description associated with fd is not O_SEARCH and the permissions of the directory
underlying fd do not permit directory searches.
[EBADF]
The path argument does not specify an absolute path and the fd argument is neither AT_FDCWD nor a valid file
descriptor open for reading or searching.
[ENOTDIR]
The path argument is not an absolute path and fd is a file descriptor associated with a non-directory file.
The utimes() function shall fail, the utimensat() function shall fail in the case that the times argument
does not have both tv_nsec fields set to UTIME_OMIT, and the utimensat() function may fail in the case that the
times argument has both tv_nsec fields set to UTIME_OMIT, if:
[EACCES]
Search permission is denied by a component of the path prefix.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of path does not name an existing file or path is an empty string.
[ENOTDIR]
A component of the path prefix names an existing file that is neither a directory nor a symbolic link to a directory, or the
path argument contains at least one non- character and ends with one or more trailing  characters
and the last pathname component names an existing file that is neither a directory nor a symbolic link to a directory.
The utimensat() and utimes() functions may fail if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
The utimensat() function may fail if:
[EINVAL]
The value of the flag argument is not valid.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The purpose of the utimensat() function is to set the access and modification time of files in directories other than the
current working directory without exposure to race conditions. Any part of the path of a file could be changed in parallel to a
call to utimes(), resulting in unspecified behavior. By opening a file descriptor for the target directory and using the
utimensat() function it can be guaranteed that the changed file is located relative to the desired directory.
The standard developers considered including a special case for the permissions required by utimensat() when one
tv_nsec field is UTIME_NOW and the other is UTIME_OMIT. One possibility would be to include this case in with the cases
where times is a null pointer or both fields are UTIME_NOW, where the call is allowed if the process has write permission
for the file. However, associating write permission with an update to just the last data access timestamp (which is normally
updated by read()) did not seem appropriate. The other possibility would be to specify
that this one case is allowed if the process has read permission, but this was felt to be too great a departure from the
utime() and utimes() functions on which utimensat() is based. If an application needs to set the last data
access timestamp to the current time for a file on which it has read permission but is not the owner, it can do so by opening the
file, reading one or more bytes (or reading a directory entry, if the file is a directory), and then closing it.
FUTURE DIRECTIONS
None.
SEE ALSO
read()
XBD , ,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
This function is marked LEGACY.
The normative text is updated to avoid use of the term "must" for application requirements.
The wording of the mandatory [ELOOP] error condition is updated, and a second optional [ELOOP] error condition is added.
Issue 7
Austin Group Interpretation 1003.1-2001 #143 is applied.
The LEGACY marking is removed.
The utimensat() function (renamed from futimesat()) is added from The Open Group Technical Standard, 2006,
Extended API Set Part 2, and changed to allow modifying a symbolic link by adding a flag argument.
The futimens() function is added.
Changes are made related to support for finegrained timestamps.
Changes are made to allow a directory to be opened for searching.
The [ENOTDIR] error condition is clarified to cover the condition where the last component of a pathname exists but is not a
directory or a symbolic link to a directory.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0220 [63,428], XSH/TC1-2008/0221 [278], XSH/TC1-2008/0222 [324],
XSH/TC1-2008/0223 [306], and XSH/TC1-2008/0224 [278] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0140 [591], XSH/TC2-2008/0141 [817], XSH/TC2-2008/0142 [485], and
XSH/TC2-2008/0143 [817] are applied.
Issue 8
Austin Group Defect 1280 is applied, changing the ERRORS section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/shmget.html =====
shmget
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
shmget — get an XSI shared memory segment
SYNOPSIS
[XSI]  #include
int shmget(key_t key, size_t size, int shmflg);
DESCRIPTION
The shmget() function operates on XSI shared memory (see XBD 3.332
Shared Memory Object). It is unspecified whether this function interoperates with the realtime interprocess communication
facilities defined in 2.8 Realtime.
The shmget() function shall return the shared memory identifier associated with key.
A shared memory identifier, associated data structure, and shared memory segment of at least size bytes (see ) are created for key if one of the following is true:
The argument key is equal to IPC_PRIVATE.
The argument key does not already have a shared memory identifier associated with it and (shmflg &IPC_CREAT)
is non-zero.
Upon creation, the data structure associated with the new shared memory identifier shall be initialized as follows:
The values of shm_perm.cuid, shm_perm.uid, shm_perm.cgid, and shm_perm.gid are set to the effective
user ID and effective group ID, respectively, of the calling process.
The low-order nine bits of shm_perm.mode are set to the low-order nine bits of shmflg.
The value of shm_segsz is set to the value of size.
The values of shm_lpid, shm_nattch, shm_atime, and shm_dtime are set to 0.
The value of shm_ctime is set to the current time, as described in 2.7.1 IPC General Description.
When the shared memory segment is created, it shall be initialized with all zero values.
RETURN VALUE
Upon successful completion, shmget() shall return a non-negative integer, namely a shared memory identifier; otherwise,
it shall return -1 and set errno to indicate the error.
ERRORS
The shmget() function shall fail if:
[EACCES]
A shared memory identifier exists for key but operation permission as specified by the low-order nine bits of
shmflg would not be granted; see 2.7 XSI Interprocess
Communication.
[EEXIST]
A shared memory identifier exists for the argument key but (shmflg &IPC_CREAT) &&(shmflg
&IPC_EXCL) is non-zero.
[EINVAL]
A shared memory segment is to be created and the value of size is less than the system-imposed minimum or greater than the
system-imposed maximum.
[EINVAL]
No shared memory segment is to be created and a shared memory segment exists for key but the size of the segment
associated with it is less than size.
[ENOENT]
A shared memory identifier does not exist for the argument key and (shmflg &IPC_CREAT) is 0.
[ENOMEM]
A shared memory identifier and associated shared memory segment are to be created, but the amount of available physical memory
is not sufficient to fill the request.
[ENOSPC]
A shared memory identifier is to be created, but the system-imposed limit on the maximum number of allowed shared memory
identifiers system-wide would be exceeded.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The POSIX Realtime Extension defines alternative interfaces for interprocess communication. Application developers who need to
use IPC should design their applications so that modules using the IPC routines described in 2.7 XSI Interprocess Communication can be easily modified to use the alternative
interfaces.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.7 XSI Interprocess Communication, 2.8 Realtime, ftok(), shmat(), shmctl(), shmdt(), shm_open(), shm_unlink()
XBD 3.332 Shared Memory Object,
CHANGE HISTORY
First released in Issue 2. Derived from Issue 2 of the SVID.
Issue 5
Moved from SHARED MEMORY to BASE.
The note about use of POSIX Realtime Extension IPC routines has been moved from FUTURE DIRECTIONS to a new APPLICATION USAGE
section.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0575 [345], XSH/TC1-2008/0576 [363], and XSH/TC1-2008/0577 [344] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0328 [640] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sigdelset.html =====
sigdelset
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sigdelset — delete a signal from a signal set
SYNOPSIS
[CX]  #include
int sigdelset(sigset_t *set, int signo);
DESCRIPTION
The sigdelset() function deletes the individual signal specified by signo from the signal set pointed to by
set.
Applications should call either sigemptyset() or sigfillset() at least once for each object of type sigset_t prior to any other use
of that object. If such an object is not initialized in this way, but is nonetheless supplied as an argument to any of pthread_sigmask(), sigaction(),
sigaddset(), sigdelset(), sigismember(), sigpending(), sigprocmask(), sigsuspend(), sigtimedwait(), sigwait(), or sigwaitinfo(), the results are undefined.
RETURN VALUE
Upon successful completion, sigdelset() shall return 0; otherwise, it shall return -1 and set errno to indicate
the error.
ERRORS
The sigdelset() function may fail if:
[EINVAL]
The signo argument is not a valid signal number, or is an unsupported signal number.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.4 Signal Concepts, pthread_sigmask(), sigaction(),
sigaddset(), sigemptyset(),
sigfillset(), sigismember()
, sigpending(), sigsuspend()
XBD
CHANGE HISTORY
First released in Issue 3. Included for alignment with the POSIX.1-1988 standard.
Issue 5
The last paragraph of the DESCRIPTION was included as an APPLICATION USAGE note in previous issues.
Issue 6
The SYNOPSIS is marked CX since the presence of this function in the  header is an extension over the ISO C standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/dbm_close.html =====
dbm_clearerr
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
dbm_clearerr, dbm_close, dbm_delete, dbm_error, dbm_fetch, dbm_firstkey, dbm_nextkey, dbm_open, dbm_store — database
functions
SYNOPSIS
[XSI]  #include
int dbm_clearerr(DBM *db);
void dbm_close(DBM *db);
int dbm_delete(DBM *db, datum key);
int dbm_error(DBM *db);
datum dbm_fetch(DBM *db, datum key);
datum dbm_firstkey(DBM *db);
datum dbm_nextkey(DBM *db);
DBM *dbm_open(const char *file, int open_flags, mode_t file_mode);
int dbm_store(DBM *db, datum key, datum content, int
store_mode);
DESCRIPTION
These functions create, access, and modify a database.
A datum consists of at least two members, dptr and dsize. The dptr member points to an object that
is dsize bytes in length. Arbitrary binary data, as well as character strings, may be stored in the object pointed to by
dptr.
A database shall be stored in one or two files. When one file is used, the name of the database file shall be formed by
appending the suffix .db to the file argument given to dbm_open(). When two files are used, the names of the
database files shall be formed by appending the suffixes .dir and .pag respectively to the file argument.
The dbm_open() function shall open a database. The file argument to the function is the pathname of the database.
Values for the open_flags argument are constructed by a bitwise-inclusive OR of flags from the following list, defined in
. Applications shall specify exactly one of the first three values
(file access modes) below in the value of open_flags:
O_RDONLY
Open the database, and the underlying file(s) used to store the database, for reading only.
O_RDWR
Open the database, and the underlying file(s) used to store the database, for reading and writing.
O_WRONLY
Open the database for writing only. The underlying file(s) used to store the database shall be opened for reading and
writing.
Any combination of the following can be used:
O_CLOEXEC
If set, the FD_CLOEXEC flag for the new file descriptor(s) used to open the underlying file(s) shall be set.
O_CREAT
If the database exists, this flag has no effect except as noted under O_EXCL below. Otherwise, the database shall be created;
the user ID of the underlying file(s) shall be set to the effective user ID of the process; the group ID of the underlying file(s)
shall be set to the group ID of the file's parent directory or to the effective group ID of the process. Implementations shall
provide a way to initialize the group ID to the group ID of the parent directory. Implementations may, but need not, provide an
implementation-defined way to initialize the group ID to the effective group ID of the calling process.
O_DSYNC
[SIO]
Write I/O operations on the file(s) used to store the database shall complete as defined by synchronized I/O data integrity
completion.
O_EXCL
If O_CREAT and O_EXCL are set, dbm_open() shall fail if the database exists according to the following criteria. If the
database is stored in a file with a .db suffix, a check for the existence of the file and the creation of the file if it
does not exist shall be performed as a single atomic operation. If the database is stored in files with .pag and .dir
suffixes, this atomic existence check and creation operation shall be performed for each file, but it is unspecified which file is
first. If the first file is successfully created and the second file is found to exist, the first file should be removed before
dbm_open() returns.
If O_EXCL is set and O_CREAT is not set, the result is undefined.
O_RSYNC
[SIO]
Read I/O operations on the file(s) used to store the database shall complete at the same level of integrity as specified by the
O_DSYNC and O_SYNC flags. If both O_DSYNC and O_RSYNC are set in oflag, all I/O operations on the file(s) shall complete as defined
by synchronized I/O data integrity completion. If both O_SYNC and O_RSYNC are set in flags, all I/O operations on the file(s) shall
complete as defined by synchronized I/O file integrity completion.
O_SYNC
Write I/O operations on the file(s) used to store the database shall complete as defined by synchronized I/O file integrity
completion.
O_TRUNC
If the database exists and is successfully opened O_RDWR or O_WRONLY, it shall be emptied, and the mode and owner of the
underlying file(s) shall be unchanged. The result of using O_TRUNC without either O_RDWR or O_WRONLY is undefined.
The behaviour of other flags described for the flags argument of open() is
unspecified.
The file_mode argument has the same meaning as the third argument of open()
and shall apply to the underlying file(s) used to store the database.
The dbm_open() function need not accept pathnames longer than {PATH_MAX}-4 bytes (including the terminating null), or
pathnames with a last component longer than {NAME_MAX}-4 bytes (excluding the terminating null).
The dbm_close() function shall close a database. The application shall ensure that argument db is a pointer to a
dbm structure that has been returned from a call to dbm_open().
These database functions shall support an internal block size large enough to support key/content pairs of at least 1023
bytes.
The dbm_fetch() function shall read a record from a database. The argument db is a pointer to a database structure
that has been returned from a call to dbm_open(). The argument key is a datum that has been initialized by the
application to the value of the key that matches the key of the record the program is fetching.
The dbm_store() function shall write a record to a database. The argument db is a pointer to a database structure
that has been returned from a call to dbm_open(). The argument key is a datum that has been initialized by the
application to the value of the key that identifies (for subsequent reading, writing, or deleting) the record the application is
writing. The argument content is a datum that has been initialized by the application to the value of the record the
program is writing. The argument store_mode controls whether dbm_store() replaces any pre-existing record that has
the same key that is specified by the key argument. The application shall set store_mode to either DBM_INSERT or
DBM_REPLACE. If the database contains a record that matches the key argument and store_mode is DBM_REPLACE, the
existing record shall be replaced with the new record. If the database contains a record that matches the key argument and
store_mode is DBM_INSERT, the existing record shall be left unchanged and the new record ignored. If the database does not
contain a record that matches the key argument and store_mode is either DBM_INSERT or DBM_REPLACE, the new record
shall be inserted in the database.
If the sum of a key/content pair exceeds the internal block size, the result is unspecified. Moreover, the application shall
ensure that all key/content pairs that hash together fit on a single block. The dbm_store() function shall return an error
in the event that a disk block fills with inseparable data.
The dbm_delete() function shall delete a record and its key from the database. The argument db is a pointer to a
database structure that has been returned from a call to dbm_open(). The argument key is a datum that has been
initialized by the application to the value of the key that identifies the record the program is deleting.
The dbm_firstkey() function shall return the first key in the database. The argument db is a pointer to a database
structure that has been returned from a call to dbm_open().
The dbm_nextkey() function shall return the next key in the database. The argument db is a pointer to a database
structure that has been returned from a call to dbm_open(). The application shall ensure that the dbm_firstkey()
function is called before calling dbm_nextkey(). Subsequent calls to dbm_nextkey() return the next key until all of
the keys in the database have been returned.
The dbm_error() function shall return the error condition of the database. The argument db is a pointer to a
database structure that has been returned from a call to dbm_open().
The dbm_clearerr() function shall clear the error condition of the database. The argument db is a pointer to a
database structure that has been returned from a call to dbm_open().
The dptr pointers returned by these functions may point into static storage that may be changed by subsequent calls.
These functions need not be thread-safe.
RETURN VALUE
The dbm_store() and dbm_delete() functions shall return 0 when they succeed and a negative value when they
fail.
The dbm_store() function shall return 1 if it is called with a flags value of DBM_INSERT and the function finds an
existing record with the same key.
The dbm_error() function shall return 0 if the error condition is not set and return a non-zero value if the error
condition is set.
The return value of dbm_clearerr() is unspecified.
The dbm_firstkey() and dbm_nextkey() functions shall return a key datum. When the end of the database is
reached, the dptr member of the key is a null pointer. If an error is detected, the dptr member of the key shall be a
null pointer and the error condition of the database shall be set.
The dbm_fetch() function shall return a content datum. If no record in the database matches the key or if an error
condition has been detected in the database, the dptr member of the content shall be a null pointer.
The dbm_open() function shall return a pointer to a database structure. If an error is detected during the operation,
dbm_open() shall return a (DBM *)0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The following code can be used to traverse the database:
for(key = dbm_firstkey(db); key.dptr != NULL; key = dbm_nextkey(db))
The dbm_* functions provided in this library should not be confused in any way with those of a general-purpose database
management system. These functions do not provide for multiple search keys per entry, they do not protect against multi-user access
(in other words they do not lock records or files), and they do not provide the many other useful database functions that are found
in more robust database management systems. Creating and updating databases by use of these functions is relatively slow because of
data copies that occur upon hash collisions. These functions are useful for applications requiring fast lookup of relatively static
information that is to be indexed by a single key.
Note that a strictly conforming application is extremely limited by these functions: since there is no way to determine that the
keys in use do not all hash to the same value (although that would be rare), a strictly conforming application cannot be guaranteed
that it can store more than one block's worth of data in the database. As long as a key collision does not occur, additional data
may be stored, but because there is no way to determine whether an error is due to a key collision or some other error condition
(dbm_error() being effectively a Boolean), once an error is detected, the
application is effectively limited to guessing what the error might be if it wishes to continue using these functions.
The dbm_delete() function need not physically reclaim file space, although it does make it available for reuse by the
database.
After calling dbm_store() or dbm_delete() during a pass through the keys by dbm_firstkey() and
dbm_nextkey(), the application should reset the database by calling dbm_firstkey() before again calling
dbm_nextkey(). The contents of these files are unspecified and may not be portable.
Applications should take care that database pathname arguments specified to dbm_open() are not prefixes of unrelated
files. This might be done, for example, by placing databases in a separate directory.
Since some implementations use three characters for a suffix and others use four characters for a suffix, applications should
ensure that the maximum portable pathname length passed to dbm_open() is no greater than {PATH_MAX}-4 bytes, with the last
component of the pathname no greater than {NAME_MAX}-4 bytes.
RATIONALE
and having .dir as its suffix. The second file containing all data and having .pag as its suffix. This has been
changed not to specify the use of the files and to allow newer implementations of the Berkeley DB interface using a single file
that have evolved while remaining compatible with the application programming interface. The standard developers considered
removing the specific suffixes altogether but decided to retain them so as not to pollute the application file name space more than
necessary and to allow for portable backups of the database.
FUTURE DIRECTIONS
A future revision of this standard may mandate the file removal that is currently recommended (by the use of "should") in the
description of O_EXCL.
SEE ALSO
open()
XBD ,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Normative text previously in the APPLICATION USAGE section is moved to the DESCRIPTION.
A note indicating that these functions need not be reentrant is added to the DESCRIPTION.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
Austin Group Interpretation 1003.1-2001 #042 is applied so that the DESCRIPTION permits newer implementations of the Berkeley DB
interface.
Austin Group Interpretation 1003.1-2001 #156 is applied.
Issue 8
Austin Group Defect 1057 is applied, clarifying how the O_ flags defined for use with open() apply to dbm_open().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strcasecmp.html =====
strcasecmp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strcasecmp, strcasecmp_l, strncasecmp, strncasecmp_l — case-insensitive string comparisons
SYNOPSIS
#include
int strcasecmp(const char *s1, const char *s2);
int strcasecmp_l(const char *s1, const char *s2,
locale_t locale);
int strncasecmp(const char *s1, const char *s2, size_t n);
int strncasecmp_l(const char *s1, const char *s2,
size_t n, locale_t locale);
DESCRIPTION
The strcasecmp() and strcasecmp_l() functions shall compare, while ignoring differences in case, the string
pointed to by s1 to the string pointed to by s2. The strncasecmp() and strncasecmp_l() functions shall
compare, while ignoring differences in case, not more than n bytes from the string pointed to by s1 to the string
pointed to by s2.
The strcasecmp() and strncasecmp() functions use the current locale to determine the case of the characters.
The strcasecmp_l() and strncasecmp_l() functions use the locale represented by locale to determine the case
of the characters.
When the LC_CTYPE category of the locale being used is from the POSIX locale, these functions shall behave as if the
strings had been converted to lowercase and then a byte comparison performed, and errno shall not be changed on valid input.
Otherwise, the results are unspecified.
The behavior is undefined if the locale argument to strcasecmp_l() or strncasecmp_l() is the special locale
object LC_GLOBAL_LOCALE or is not a valid locale object handle.
RETURN VALUE
Upon completion, strcasecmp() and strcasecmp_l() shall return an integer greater than, equal to, or less than 0,
if the string pointed to by s1 is, ignoring case, greater than, equal to, or less than the string pointed to by s2,
respectively.
Upon successful completion, strncasecmp() and strncasecmp_l() shall return an integer greater than, equal to, or
less than 0, if the possibly null-terminated array pointed to by s1 is, ignoring case, greater than, equal to, or less than
the possibly null-terminated array pointed to by s2, respectively.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
wcscasecmp()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 7
The strcasecmp() and strncasecmp() functions are moved from the XSI option to the Base.
The strcasecmp_l() and strncasecmp_l() functions are added from The Open Group Technical Standard, 2006, Extended
API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0589 [302], XSH/TC1-2008/0590 [294], XSH/TC1-2008/0591 [283], and
XSH/TC1-2008/0592 [283] are applied.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that errno is not changed on valid input.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/gettext.html =====
gettext
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
dgettext, dgettext_l, dcgettext, dcgettext_l, gettext, gettext_l, ngettext, ngettext_l, dngettext, dngettext_l,
dcngettext, dcngettext_l — message handling functions
SYNOPSIS
#include
char *dgettext(const char *domainname, const char *msgid);
char *dgettext_l(const char *domainname, const char *msgid,
locale_t locale);
char *dcgettext(const char *domainname, const char *msgid,
int category);
char *dcgettext_l(const char *domainname, const char *msgid,
int category, locale_t locale);
char *dngettext(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n);
char *dngettext_l(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n,
locale_t locale);
char *dcngettext(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n,
int category);
char *dcngettext_l(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n,
int category, locale_t locale);
char *gettext(const char *msgid);
char *gettext_l(const char *msgid, locale_t locale);
char *ngettext(const char *msgid, const char *msgid_plural,
unsigned long int n);
char *ngettext_l(const char *msgid, const char *msgid_plural,
unsigned long int n, locale_t locale);
DESCRIPTION
The gettext() function shall:
attempt to locate a suitable messages object (described in detail below) for the LC_MESSAGES category in the current
locale, and for the current text domain (see bindtextdomain()), containing
the string identified by msgid,
retrieve the string identified by msgid from the messages object,
convert the string to the output codeset if necessary (described in detail below), and
return the result.
If the locale name in effect is "POSIX" or "C" (i.e. the name associated with the LC_MESSAGES locale
category in the current locale), or if no suitable messages object exists, or if no string identified by msgid exists in the
messages object, or if an error occurs, msgid shall be returned.
The dgettext() function shall be equivalent to gettext(), except domainname shall be used instead of the
current text domain to locate the messages object.
The dcgettext() function shall be equivalent to dgettext(), except the locale category identified by
category shall be used instead of LC_MESSAGES .
The ngettext() function shall be equivalent to gettext(), except:
The string to retrieve shall be identified by a combination of msgid and n (see msgfmt).
If the locale name in effect is "POSIX" or "C", or if no suitable messages object exists, or if no string
identified by the combination of msgid and n exists in the messages object, or if an error occurs, the return value
shall be msgid if n is 1, otherwise msgid_plural.
The dngettext() function shall be equivalent to ngettext(), except domainname shall be used instead of the
current text domain to locate the messages object.
The dcngettext() function shall be equivalent to dngettext(), except the locale category identified by
category shall be used instead of LC_MESSAGES .
The *_l() functions shall be equivalent to their counterparts without the _l suffix, except locale shall be
used instead of the current locale. If locale is the special locale object LC_GLOBAL_LOCALE or is not a valid locale object
handle, the behavior is undefined.
The application shall ensure that the msgid and msgid_plural arguments are strings. If either msgid or
msgid_plural is an empty string, or contains characters not in the portable character set, the results are unspecified. If
the category argument is LC_ALL , the results are unspecified.
The location of the messages object shall be determined according to the following criteria, stopping when the first messages
object is found:
[XSI]
If the NLSPATH environment variable is set to a non-empty string, an NLSPATH search shall be performed as described
in XBD 8.2 Internationalization Variables. If NLSPATH identifies
more than one template to use, each template in turn shall be used until a valid messages object is found.
If the LANGUAGE environment variable is set to a non-empty string, a LANGUAGE search shall be performed as
described below. If LANGUAGE identifies more than one directory to search, each directory shall be searched until a valid
messages object is found.
A single-locale search shall be performed as described below.
For [XSI]   the NLSPATH search and   the single-locale search,
the single locale name used to locate the messages object shall be the locale name associated with the selected locale category
from the current locale, or the provided locale object if calling one of the *_l() functions; additional searches of locale
names without .codeset (if present), without _territory (if present), and without @modifier (if present) may
be performed.
For the LANGUAGE search, the value of the LANGUAGE environment variable shall be a list of one or more locale
names separated by a  (':') character. Each locale name shall be tried in the specified order. If a messages
object for the locale does not exist, or cannot be opened, or is unsuitable for implementation-defined reasons (such as security),
the next locale name (if any) shall be tried. If:
a messages object for the locale can be opened but cannot be processed without error, or
the messages object does not contain a string identified by msgid, or msgid and n for the ngettext
functions,
it is unspecified whether the next locale name (if any) is tried. In all other cases, the messages object for the locale shall
be used.
For each locale name in LANGUAGE , or if LANGUAGE is not set or is empty, or no suitable messages object is found
in processing LANGUAGE , the pathname used to locate the messages object shall be
dirname/localename/categoryname/textdomainname.mo, where:
The dirname part is the dirname argument of the most recent successful call to bindtextdomain() that had textdomainname as the domainname argument;
any trailing  characters in dirname shall be discarded. If a successful call to bindtextdomain() has not been made for textdomainname, an
implementation-defined default directory shall be used.
For the LANGUAGE search, the localename part is each locale name from LANGUAGE in turn; if a locale name
has the format language[_territory][.codeset][@modifier], additional
searches of locale names without .codeset (if present), without _territory (if present), and without @modifier
(if present) may be performed; if .codeset is not present, additional searches of locale names with an added .codeset
may be performed. For the single-locale search, the localename part is the name of the current locale, or the locale
specified in an *_l() function call, for the category named by categoryname. Spellings of codeset names are not
standardized, and implementations may attempt to use different commonly known spellings, for example "utf8" and
"UTF-8".
The categoryname part is the string "LC_MESSAGES" if gettext(), dgettext(), ngettext(), or
dngettext() is called, or the locale category name corresponding to the category argument to dcgettext() or
dcngettext(). Likewise for the *_l() variants of all these functions.
For gettext(), gettext_l(), ngettext(), and ngettext_l(), the textdomainname part is the text
domain set by the last successful call to textdomain(). For dgettext(),
dcgettext(), dngettext(), dcngettext(), and the *_l() variants of these functions,
textdomainname is the text domain specified by the domainname argument. The domainname argument shall be
equivalent in syntax and meaning to the domainname argument to textdomain(), except that the selection of the text domain shall affect only the
dgettext(), dcgettext(), dngettext(), and dcngettext() function calls and their *_l() variants.
If the domainname argument is a null pointer, the text domain set by the last successful call to textdomain() shall be used. For all of these functions, if a successful call to textdomain() has not been made the default text domain "messages" shall be
used.
Resolution of the messages object pathname shall be performed the first time one of the gettext family of functions is
called for a given combination of dirname, localename, categoryname, and textdomainname. It is
unspecified whether the pathname is re-resolved if the combination has been used before in a call to one of the gettext
family of functions. If bindtextdomain() performs pathname resolution of its
dirname argument, only the part of the messages object pathname after dirname shall be resolved by the gettext
family of functions.
When one of the gettext family of functions returns a message string that was found in a messages object, it shall
convert the codeset of the message string to the output codeset if a codeset is specified in the messages object (see msgfmt) and the output codeset is not the same as that codeset. If a successful call to
bind_textdomain_codeset() has been made with the text domain of the
messages object as the domainname argument and a non-null codeset argument, the output codeset shall be the
codeset argument from the most recent such call. Otherwise, the output codeset shall be the codeset of characters in the
current locale, or the provided locale object if calling one of the *_l() functions, as specified by the LC_CTYPE
category of the locale. The conversion shall be performed as if by a call to iconv()
using a conversion descriptor returned by iconv_open(, ),
except that if the return value of iconv() would be greater than zero, the
non-identical conversions performed by the gettext family of functions need not be the same as those that such an iconv() call would perform. If an error prevents the codeset conversion from being performed,
the gettext family of functions shall behave as if no message string was found in the messages object. If at least one
non-identical conversion is performed that results in a fallback character (one that does not provide any information about the
character it was converted from, for example, a  or "replacement-character"), the gettext family of
functions may behave as if no message string was found in the messages object.
RETURN VALUE
The gettext(), gettext_l(), dgettext(), dgettext_l(), dcgettext(), and dcgettext_l()
functions shall return the message string described in DESCRIPTION if successful. Otherwise, they shall return msgid.
The ngettext(), ngettext_l(), dngettext(), dngettext_l(), dcngettext(), and
dcngettext_l() functions shall return the message string described in DESCRIPTION if successful. Otherwise, msgid
shall be returned if n is equal to 1, or msgid_plural if n is not equal to 1.
The application shall ensure that it does not modify the returned string. A subsequent call to a gettext family function
shall not overwrite or invalidate the returned string. The returned string may be invalidated by a subsequent call to bind_textdomain_codeset(), bindtextdomain(), setlocale(), or
textdomain() in the same process, except for calls that only query values. The
returned string shall not be invalidated by a subsequent call to uselocale().
ERRORS
The gettext family of functions shall not modify errno. If an error occurs these functions shall return a string
as described in RETURN VALUE.
The following sections are informative.
EXAMPLES
The example code below assumes the following:
The implementation-defined default directory is /system/gettextlib.
The following locales are available on the target system: en_US, en_GB, de_DE. The codeset used for all of these locales is
UTF-8.
The en_AU locale is not available on the target system.
The target system supports conversion from ISO/IEC 8859-1 to UTF-8.
The codeset used for the POSIX locale is ASCII.
The target system does not support conversion from ISO/IEC 8859-1 to ASCII.
Furthermore, the following .mo files (and only the following .mo files) are installed:
/system/gettextlib/en_US/LC_MESSAGES/mail.mo
/messagecatalogs/example/en_US/LC_MESSAGES/mail.mo
These are compiled from a portable messages object source file (dot-po file) with the following ISO/IEC 8859-1 encoded contents
(see the EXTENDED DESCRIPTION of the msgfmt utility for a description of the dot-po
file format):
msgid ""
msgstr ""
"Content-Type: text/plain; charset=ISO_8859-1\n"
"Plural-Forms: nplurals=4; plural= n==1?0: (n>1&&n1&&n1&&n,
XCU gettext, msgfmt,
xgettext
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/lroundl.html =====
lround
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
lround, lroundf, lroundl — round to nearest integer value
SYNOPSIS
#include
long lround(double x);
long lroundf(float x);
long lroundl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall round their argument to the nearest integer value, rounding halfway cases away from zero, regardless of
the current rounding direction.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the rounded integer value.
[MX]  If
x is NaN, a domain error shall occur and an unspecified value is returned.
If x is +Inf, a domain error shall occur and an unspecified value is returned.
If x is -Inf, a domain error shall occur and an unspecified value is returned.
If the correct value is positive and too large to represent as a long, an unspecified value shall be returned.
[MX]
On systems that support the IEC 60559 Floating-Point option, a domain shall occur;  otherwise, a [CX]   domain  error may occur.
If the correct value is negative and too large to represent as a long, an unspecified value shall be returned.
[MX]
On systems that support the IEC 60559 Floating-Point option, a domain shall occur;  otherwise, a [CX]   domain  error may occur.
ERRORS
These functions shall fail if:
Domain Error
[MX]
The x argument is NaN or ±Inf, or the correct value is not representable as an integer.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
These functions may fail if:
Domain Error
The correct value is not representable as an integer.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
These functions differ from the lrint() functions in the default rounding
direction, with the lround() functions rounding halfway cases away from zero and needing not to raise the inexact
floating-point exception for non-integer arguments that round to within the range of the return type.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), llround()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #54 (SD5-XSH-ERN-78) is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/readdir.html =====
readdir
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
readdir, readdir_r — read a directory
SYNOPSIS
#include
struct dirent *readdir(DIR *dirp);
[OB]  int readdir_r(DIR *restrict dirp, struct dirent *restrict entry,
struct dirent **restrict result);
DESCRIPTION
The type DIR, which is defined in the  header, represents
a directory stream, which is an ordered sequence of all the directory entries in a particular directory. Directory entries
represent files; files may be removed from a directory or added to a directory asynchronously to the operation of
readdir().
The readdir() function shall return a pointer to a structure representing the directory entry at the current position in
the directory stream specified by the argument dirp, and position the directory stream at the next entry. It shall return a
null pointer upon reaching the end of the directory stream. The structure dirent defined in the  header describes a directory entry. The value of the structure's
d_ino member shall be set to the file serial number of the file named by the d_name member. If the d_name
member names a symbolic link, the value of the d_ino member shall be set to the file serial number of the symbolic link
itself. The d_name member shall be a filename string, and (if not dot or dot-dot) shall contain the same byte sequence as
the last pathname component of the string used to create the directory entry, plus the terminating  byte.
The readdir() function shall not return directory entries containing empty names. If entries for dot or dot-dot exist,
one entry shall be returned for dot and one entry shall be returned for dot-dot; otherwise, they shall not be returned.
The application shall not modify the structure to which the return value of readdir() points, nor any storage areas
pointed to by pointers within the structure. The returned pointer, and pointers within the structure, might be invalidated or the
structure or the storage areas might be overwritten by a subsequent call to readdir() on the same directory stream. They
shall not be affected by a call to readdir() on a different directory stream. The returned pointer, and pointers within the
structure, might also be invalidated if the calling thread is terminated.
If a file is removed from or added to the directory after the most recent call to opendir() or rewinddir(), whether a
subsequent call to readdir() returns an entry for that file is unspecified.
The readdir() function may buffer several directory entries per actual read operation; readdir() shall mark for
update the last data access timestamp of the directory each time the directory is actually read.
After a call to fork(), either the parent or child (but not both) may continue
processing the directory stream using readdir(), rewinddir(),
[XSI]
or seekdir().
If both the parent and child processes use these functions, the result is undefined.
The readdir() function need not be thread-safe if concurrent calls are made for the same directory stream.
Applications wishing to check for error situations should set errno to 0 before calling readdir(). If errno
is set to non-zero on return, an error occurred.
[OB]  The
readdir_r() function shall initialize the dirent structure referenced by entry to represent the directory
entry at the current position in the directory stream referred to by dirp, store a pointer to this structure at the location
referenced by result, and position the directory stream at the next entry.
The storage pointed to by entry shall be large enough for a dirent with an array of char d_name
members containing at least {NAME_MAX}+1 elements.
Upon successful return, the pointer returned at *result shall have the same value as the argument entry. Upon
reaching the end of the directory stream, this pointer shall have the value NULL.
The readdir_r() function shall not return directory entries containing empty names.
If a file is removed from or added to the directory after the most recent call to opendir() or rewinddir(), whether a
subsequent call to readdir_r() returns an entry for that file is unspecified.
The readdir_r() function may buffer several directory entries per actual read operation; readdir_r() shall mark
for update the last data access timestamp of the directory each time the directory is actually read.
RETURN VALUE
Upon successful completion, readdir() shall return a pointer to an object of type struct dirent. When an error is
encountered, a null pointer shall be returned and errno shall be set to indicate the error. When the end of the directory is
encountered, a null pointer shall be returned and errno is not changed.
[OB]  If
successful, the readdir_r() function shall return zero; otherwise, an error number shall be returned to indicate the error.
ERRORS
The readdir() [OB]   and readdir_r()
functions shall fail if:
[EOVERFLOW]
One of the values in the structure to be returned cannot be represented correctly.
[ENOMEM]
Insufficient memory is available.
The readdir() [OB]   and readdir_r()
functions may fail if:
[EBADF]
The dirp argument does not refer to an open directory stream.
[ENOENT]
The current position of the directory stream is invalid.
The following sections are informative.
EXAMPLES
The following sample program searches the current directory for each of the arguments supplied on the command line.
#include
#include
#include
#include
static void lookup(const char *arg)
{
DIR *dirp;
struct dirent *dp;
if ((dirp = opendir(".")) == NULL) {
perror("couldn't open '.'");
return;
}
do {
errno = 0;
if ((dp = readdir(dirp)) != NULL) {
if (strcmp(dp->d_name, arg) != 0)
continue;
(void) printf("found %s\n", arg);
(void) closedir(dirp);
return;
}
} while (dp != NULL);
if (errno != 0)
perror("error reading directory");
else
(void) printf("failed to find %s\n", arg);
(void) closedir(dirp);
return;
}
int main(int argc, char *argv[])
{
int i;
for (i = 1; i , even if a
trailing  was present in the pathname presented to mkdir() when creating
a sub-directory.
However, there are non-conforming file systems where filenames are converted to a canonical representation before a directory
entry is created, such that it is possible to create a file using one string, then perform opendir() and a readdir() loop and not encounter the same string, because
readdir() returns the canonical form of the string instead. Such non-conforming file systems also have the issue that
multiple filenames can resolve to the same directory entry, with potentially confusing results. This standard cannot mandate the
behavior of non-conforming file systems, and strictly conforming applications need not worry about dealing with such file systems,
but it is a concern for developers of portable applications. Therefore, this standard recommends that file system implementations
that perform canonicalization of filenames should reject attempts to create a directory entry with a non-canonical filename using
the [EILSEQ] error. However, if a directory entry already exists, it is reasonable for a file system to permit accessing that file
via a non-canonical filename.
FUTURE DIRECTIONS
The readdir_r() function may be removed in a future version.
SEE ALSO
closedir(), dirfd(), exec, fdopendir(), fstatat(), posix_getdents(), rewinddir(),
symlink()
XBD ,
CHANGE HISTORY
First released in Issue 2.
Issue 5
Large File Summit extensions are added.
The readdir_r() function is included for alignment with the POSIX Threads Extension.
A note indicating that the readdir() function need not be reentrant is added to the DESCRIPTION.
Issue 6
The readdir_r() function is marked as part of the Thread-Safe Functions option.
The Open Group Corrigendum U026/7 is applied, correcting the prototype for readdir_r().
The Open Group Corrigendum U026/8 is applied, clarifying the wording of the successful return for the readdir_r()
function.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
A statement is added to the DESCRIPTION indicating the disposition of certain fields in struct dirent when an entry
refers to a symbolic link.
The [EOVERFLOW] mandatory error condition is added. This change is to support large files.
The [ENOENT] optional error condition is added.
The APPLICATION USAGE section is updated to include a note on the thread-safe function and its avoidance of possibly using a
static data area.
The restrict keyword is added to the readdir_r() prototype for alignment with the ISO/IEC 9899:1999
standard.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/50 is applied, replacing the EXAMPLES section with a new
example.
Issue 7
Austin Group Interpretation 1003.1-2001 #059 is applied, updating the ERRORS section.
Austin Group Interpretation 1003.1-2001 #156 is applied.
The readdir_r() function is moved from the Thread-Safe Functions option to the Base.
Changes are made related to support for finegrained timestamps.
The value of the d_ino member is no longer unspecified for symbolic links.
SD5-XSH-ERN-193 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0486 [75] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0304 [656] is applied.
Issue 8
Austin Group Defect 293 is applied, adding a requirement that d_name contains the same byte sequence as the last pathname
component of the string used to create the directory entry.
Austin Group Defects 696 and 1664 are applied, making readdir_r() obsolescent, requiring readdir() to be
thread-safe except when concurrent calls are made for the same directory stream, and adding the [ENOMEM] error.
Austin Group Defect 697 is applied, adding posix_getdents() to the SEE
ALSO section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/rand_r.html =====
rand
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
rand, srand — pseudo-random number generator
SYNOPSIS
#include
int rand(void);
void srand(unsigned seed);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The rand() function shall compute a sequence of pseudo-random integers in the range [0,{RAND_MAX}] [XSI]   with a
period of at least 232.
The rand() function need not be thread-safe; however, rand() shall avoid data races with all functions other than
non-thread-safe pseudo-random sequence generation functions.
The srand() function uses the argument as a seed for a new sequence of pseudo-random numbers to be returned by subsequent
calls to rand(). If srand() is then called with the same seed value, the sequence of pseudo-random numbers shall be
repeated. If rand() is called before any calls to srand() are made, the same sequence shall be generated as when
srand() is first called with a seed value of 1.
The srand() function need not be thread-safe; however, srand() shall avoid data races with all functions other
than non-thread-safe pseudo-random sequence generation functions.
The implementation shall behave as if no function defined in this volume of POSIX.1-2024 calls rand() or
srand().
RETURN VALUE
The rand() function shall return the next pseudo-random number in the sequence.
The srand() function shall not return a value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
Generating a Pseudo-Random Number Sequence
The following example demonstrates how to generate a sequence of pseudo-random numbers.
#include
#include
...
long count, i;
char *keystr;
int elementlen, len;
char c;
...
/* Initial random number generator. */
srand(1);
/* Create keys using only lowercase characters */
len = 0;
for (i=0; i
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The rand_r() function is included for alignment with the POSIX Threads Extension.
A note indicating that the rand() function need not be reentrant is added to the DESCRIPTION.
Issue 6
Extensions beyond the ISO C standard are marked.
The rand_r() function is marked as part of the Thread-Safe Functions option.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
The rand_r() function is marked obsolescent.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0301 [743] is applied.
Issue 8
Austin Group Defect 1134 is applied, adding getentropy().
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/posix_spawnattr_setsigdefault.html =====
posix_spawnattr_getsigdefault
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
posix_spawnattr_getsigdefault, posix_spawnattr_setsigdefault — get and set the spawn-sigdefault attribute of a spawn
attributes object (ADVANCED REALTIME)
SYNOPSIS
[SPN]  #include
#include
int posix_spawnattr_getsigdefault(const posix_spawnattr_t
*restrict attr, sigset_t *restrict sigdefault);
int posix_spawnattr_setsigdefault(posix_spawnattr_t *restrict attr,
const sigset_t *restrict sigdefault);
DESCRIPTION
The posix_spawnattr_getsigdefault() function shall obtain the value of the spawn-sigdefault attribute from the
attributes object referenced by attr.
The posix_spawnattr_setsigdefault() function shall set the spawn-sigdefault attribute in an initialized attributes
object referenced by attr.
The spawn-sigdefault attribute represents the set of signals to be forced to default signal handling in the new process
image (if POSIX_SPAWN_SETSIGDEF is set in the spawn-flags attribute) by a spawn operation. The default value of this
attribute shall be an empty signal set.
RETURN VALUE
Upon successful completion, posix_spawnattr_getsigdefault() shall return zero and store the value of the
spawn-sigdefault attribute of attr into the object referenced by the sigdefault parameter; otherwise, an error
number shall be returned to indicate the error.
Upon successful completion, posix_spawnattr_setsigdefault() shall return zero; otherwise, an error number shall be
returned to indicate the error.
ERRORS
These functions may fail if:
[EINVAL]
The value specified by attr is invalid.
The posix_spawnattr_setsigdefault() function may fail if:
[EINVAL]
The value of the attribute being set is not valid.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
These functions are part of the Spawn option and need not be provided on all implementations.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
posix_spawn(), posix_spawnattr_destroy(), posix_spawnattr_getflags(), posix_spawnattr_getpgroup(), posix_spawnattr_getschedparam(), posix_spawnattr_getschedpolicy(), posix_spawnattr_getsigmask()
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1d-1999.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/tgammal.html =====
tgamma
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
tgamma, tgammaf, tgammal — compute gamma() function
SYNOPSIS
#include
double tgamma(double x);
float tgammaf(float x);
long double tgammal(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute Γ(x) where Γ(x) is defined as
\(\int_0^{\infty} e^{-t} t^{x-1} d t\)
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the gamma of x.
If x is a negative integer, either a domain error or a pole error may occur and either a NaN (if supported) or ±Inf (if
supported), respectively, or an implementation-defined value shall be returned. [MX]   On systems
that support the IEC 60559 Floating-Point option, a domain error shall occur and a NaN shall be returned.
If x is ±0, tgamma(), tgammaf(), and tgammal() shall return ±HUGE_VAL, ±HUGE_VALF, and ±HUGE_VALL,
respectively. [MX]   On systems that support the IEC 60559 Floating-Point option, a pole error shall occur;   otherwise, a [CX]
pole  error may occur.
If the correct value would cause overflow, a range error shall occur and tgamma(), tgammaf(), and tgammal()
shall return ±HUGE_VAL, ±HUGE_VALF, or ±HUGE_VALL, respectively, with the same sign as the correct value of the function.
If the correct value would cause underflow, [MXX]   and is not representable,   a range error may occur, and tgamma(), tgammaf(), and tgammal() shall return
[MXX]
0.0, or   (if IEC 60559 Floating-Point is not supported)
an implementation-defined value no greater in magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
[MXX]
If the correct value would cause underflow, and is representable, a range error may occur and the correct value shall be
returned.
If x is subnormal and 1/ x is representable, 1/ x should be returned.
[MX]  If
x is NaN, a NaN shall be returned.
If x is +Inf, x shall be returned.
If x is -Inf, a domain error shall occur, and a NaN shall be returned.
ERRORS
These functions shall fail if:
Domain Error
[MX]
The value of x is a negative integer, or x is -Inf.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If
the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall
be raised.
Pole Error
[MX]
The value of x is zero.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If
the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the divide-by-zero floating-point exception
shall be raised.
Range Error
The value overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If
the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall
be raised.
These functions may fail if:
Domain Error
The value of x is a negative integer.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If
the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall
be raised.
Pole Error
The value of x is zero or a negative integer.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If
the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the divide-by-zero floating-point exception
shall be raised.
Range Error
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If
the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception
shall be raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are
independent of each other, but at least one of them must be non-zero.
RATIONALE
This function is named tgamma() in order to avoid conflicts with the historical gamma() and lgamma() functions.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept, fetestexcept, lgamma
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/65 is applied, correcting the third paragraph in the RETURN
VALUE section.
Issue 7
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #52 (SD5-XSH-ERN-85) is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0660 [68], XSH/TC1-2008/0661 [320], and XSH/TC1-2008/0662 [68] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0367 [604] and XSH/TC2-2008/0368 [630] are applied.
Issue 8
Austin Group Defect 1461 is applied, changing the requirements for a negative integer argument to match the ISO C
standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcpncpy.html =====
wcsncpy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcpncpy, wcsncpy — copy a fixed-size wide-character string, returning a pointer to its end
SYNOPSIS
#include
[CX]  wchar_t *wcpncpy(wchar_t restrict *ws1, const wchar_t *restrict
ws2,
size_t n);
wchar_t *wcsncpy(wchar_t *restrict ws1, const wchar_t *restrict ws2,
size_t n);
DESCRIPTION
For wcsncpy(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The [CX]
wcpncpy()  and wcsncpy() functions shall copy not more
than n wide-character codes (wide-character codes that follow a null wide-character code are not copied) from the array
pointed to by ws2 to the array pointed to by ws1. If copying takes place between objects that overlap, the behavior
is undefined.
If the array pointed to by ws2 is a wide-character string that is shorter than n wide-character codes, null
wide-character codes shall be appended to the copy in the array pointed to by ws1, until n wide-character codes in
all are written.
[CX]  The
wcsncpy() and wcpncpy() functions shall not change the setting of errno on valid input.
RETURN VALUE
[CX]  If
any null wide-character codes were written into the destination, the wcpncpy() function shall return the address of the
first such null wide-character code. Otherwise, it shall return &ws1[n].
The wcsncpy() function shall return ws1.
No return values are reserved to indicate an error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
If there is no null wide-character code in the first n wide-character codes of the array pointed to by ws2, the
result is not null-terminated.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
strncpy(), wcscpy(), wcslcat()
XBD
CHANGE HISTORY
First released in Issue 4. Derived from the MSE working draft.
Issue 6
The wcsncpy() prototype is updated for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
The wcpncpy() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 1.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that wcsncpy() and wcpncpy() do not change the setting of
errno on valid input.
Austin Group Defect 986 is applied, adding wcslcat() to the SEE ALSO section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/posix_spawnp.html =====
posix_spawn
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
posix_spawn, posix_spawnp — spawn a process (ADVANCED REALTIME)
SYNOPSIS
[SPN]  #include
int posix_spawn(pid_t *restrict pid, const char *restrict path,
const posix_spawn_file_actions_t *restrict file_actions,
const posix_spawnattr_t *restrict attrp,
char *const argv[restrict], char *const envp[restrict]);
int posix_spawnp(pid_t *restrict pid, const char *restrict file,
const posix_spawn_file_actions_t *restrict file_actions,
const posix_spawnattr_t *restrict attrp,
char *const argv[restrict], char *const envp[restrict]);
DESCRIPTION
The posix_spawn() and posix_spawnp() functions shall create a new process (child process) from the specified
process image. The new process image shall be constructed from a regular executable file called the new process image file.
When a C program is executed as the result of this call, it shall be entered as a C-language function call as follows:
int main(int argc, char *argv[]);
where argc is the argument count and argv is an array of character pointers to the arguments themselves. In
addition, the following variable:
extern char **environ;
shall be initialized as a pointer to an array of character pointers to the environment strings.
The argument argv is an array of character pointers to null-terminated strings. The last member of this array shall be a
null pointer and is not counted in argc. These strings constitute the argument list available to the new process image. The
value in argv[0] should point to a filename string that is associated with the process image being started by the
posix_spawn() or posix_spawnp() function.
The argument envp is an array of character pointers to null-terminated strings. These strings constitute the environment
for the new process image. The environment array is terminated by a null pointer.
The number of bytes available for the combined argument and environment lists of the child process is {ARG_MAX}. The
implementation shall specify in the system documentation (see XBD 2.
Conformance) whether any list overhead, such as length words, null terminators, pointers, or alignment bytes, is included
in this total.
The path argument to posix_spawn() is a pathname that identifies the new process image file to execute; if the
pathname does not start with a , it shall be interpreted relative to the working directory of the child process after
all file_actions have been performed.
The file parameter to posix_spawnp() shall be used to construct a pathname that identifies the new process image
file. If the file parameter contains a  character, the file parameter shall be used as the pathname for
the new process image file. Otherwise, the path prefix for this file shall be obtained by a search of the directories passed as the
environment variable PATH (see XBD 8. Environment Variables), using
the working directory of the child process after all file_actions have been performed. If this environment variable is not
defined, the results of the search are implementation-defined. However, if at least one of the exec family of functions would fail with [ENOEXEC] because the process image contents are not
executable, this shall cause posix_spawnp() to fail rather than attempting a fallback to invoking the process as a shell
script passed to sh.
If file_actions is a null pointer, then file descriptors open in the calling process shall remain open in the child
process, except for those whose FD_CLOEXEC or FD_CLOFORK flag is set (see fcntl()),
and except for file descriptors that are closed by a fork handler (if fork handlers are called). For those file descriptors that
remain open, the child process shall not inherit any process-owned file locks, but all remaining attributes of the corresponding
open file descriptions (see fcntl()), shall remain unchanged. The current working
directory of the child process shall be the same as it is in the parent process.
If file_actions is not a null pointer, then the file descriptors open in the child process shall be those open in the
calling process as modified by FD_CLOFORK file descriptor flags, fork handlers (if they are called), the spawn file actions object
pointed to by file_actions, and the FD_CLOEXEC flag of each remaining open file descriptor after the spawn file actions have
been processed. The effective order of processing the spawn file actions shall be:
The set of open file descriptors for the child process shall initially be the same set as is open for the calling process,
except for those that have the FD_CLOFORK flag set and any that are closed by fork handlers (if they are called). The child process
shall not inherit any file locks, but all remaining attributes of the corresponding open file descriptions (see fcntl()), shall remain unchanged.
The signal mask, signal default actions, and the effective user and group IDs for the child process shall be changed as
specified in the attributes object referenced by attrp.
The file actions specified by the spawn file actions object shall be performed in the order in which they were added to the
spawn file actions object, and relative pathnames in a given action shall be interpreted in relation to the tracked working
directory. The tracked working directory shall begin with the current working directory of the parent process, and can be altered
according to chdir or fchdir file actions; the current working directory of the child process shall be the final
state of the tracked working directory after all file actions have been applied.
Any file descriptor that has its FD_CLOEXEC flag set shall be closed.
If file descriptor 0, 1, or 2 would otherwise be closed in the new process image created by posix_spawn() or
posix_spawnp(), implementations may open an unspecified file for the file descriptor in the new process image. If a standard
utility or a conforming application is executed with file descriptor 0 not open for reading or with file descriptor 1 or 2 not open
for writing, the environment in which the utility or application is executed shall be deemed non-conforming, and consequently the
utility or application might not behave as described in this standard.
The posix_spawnattr_t spawn attributes object type is defined in . It shall contain at least the attributes defined below.
If the POSIX_SPAWN_SETPGROUP flag is set in the spawn-flags attribute of the object referenced by attrp, and the
spawn-pgroup attribute of the same object is non-zero, then the child's process group shall be as specified in the
spawn-pgroup attribute of the object referenced by attrp.
As a special case, if the POSIX_SPAWN_SETPGROUP flag is set in the spawn-flags attribute of the object referenced by
attrp, and the spawn-pgroup attribute of the same object is set to zero, then the child shall be in a new process
group with a process group ID equal to its process ID.
If the POSIX_SPAWN_SETSID flag is set in the spawn-flags attribute of the object referenced by attrp, the child
process shall be the session leader of a new session, shall be the process group leader of a new process group, and shall have no
controlling terminal. The process group ID of the child process shall be set equal to the process ID of the child process. The
child process shall be the only process in the new process group and the only process in the new session.
If both the POSIX_SPAWN_SETPGROUP flag and the POSIX_SPAWN_SETSID flag are set in the spawn-flags attribute of the object
referenced by attrp, the behavior is unspecified.
If neither the POSIX_SPAWN_SETPGROUP flag nor the POSIX_SPAWN_SETSID flag is set in the spawn-flags attribute of the
object referenced by attrp, the new child process shall inherit the parent's process group.
[PS]  If
the POSIX_SPAWN_SETSCHEDPARAM flag is set in the spawn-flags attribute of the object referenced by attrp, but
POSIX_SPAWN_SETSCHEDULER is not set, the new process image shall initially have the scheduling policy of the calling process with
the scheduling parameters specified in the spawn-schedparam attribute of the object referenced by attrp.
If the POSIX_SPAWN_SETSCHEDULER flag is set in the spawn-flags attribute of the object referenced by attrp
(regardless of the setting of the POSIX_SPAWN_SETSCHEDPARAM flag), the new process image shall initially have the scheduling policy
specified in the spawn-schedpolicy attribute of the object referenced by attrp and the scheduling parameters
specified in the spawn-schedparam attribute of the same object.
The POSIX_SPAWN_RESETIDS flag in the spawn-flags attribute of the object referenced by attrp governs the effective
user ID of the child process. If this flag is not set, the child process shall inherit the effective user ID of the parent process.
If this flag is set, the effective user ID of the child process shall be reset to the parent's real user ID. In either case, if the
set-user-ID mode bit of the new process image file is set, the effective user ID of the child process shall become that file's
owner ID before the new process image begins execution.
The POSIX_SPAWN_RESETIDS flag in the spawn-flags attribute of the object referenced by attrp also governs the
effective group ID of the child process. If this flag is not set, the child process shall inherit the effective group ID of the
parent process. If this flag is set, the effective group ID of the child process shall be reset to the parent's real group ID. In
either case, if the set-group-ID mode bit of the new process image file is set, the effective group ID of the child process shall
become that file's group ID before the new process image begins execution.
If the POSIX_SPAWN_SETSIGMASK flag is set in the spawn-flags attribute of the object referenced by attrp, the
child process shall initially have the signal mask specified in the spawn-sigmask attribute of the object referenced by
attrp.
If the POSIX_SPAWN_SETSIGDEF flag is set in the spawn-flags attribute of the object referenced by attrp, the
signals specified in the spawn-sigdefault attribute of the same object shall be set to their default actions in the child
process. Signals set to the default action in the parent process shall be set to the default action in the child process.
Signals set to be caught by the calling process shall be set to the default action in the child process.
Except for SIGCHLD, signals set to be ignored by the calling process image shall be set to be ignored by the child process,
unless otherwise specified by the POSIX_SPAWN_SETSIGDEF flag being set in the spawn-flags attribute of the object referenced
by attrp and the signals being indicated in the spawn-sigdefault attribute of the object referenced by
attrp.
If the SIGCHLD signal is set to be ignored by the calling process, it is unspecified whether the SIGCHLD signal is set to be
ignored or to the default action in the child process, unless otherwise specified by the POSIX_SPAWN_SETSIGDEF flag being set in
the spawn_flags attribute of the object referenced by attrp and the SIGCHLD signal being indicated in the
spawn_sigdefault attribute of the object referenced by attrp.
If the value of the attrp pointer is a null pointer, then the default values are used.
All process attributes, other than those influenced by the attributes set in the object referenced by attrp as specified
above or by the file descriptor manipulations specified in file_actions, shall appear in the new process image as though
fork() had been called to create a child process and then a member of the exec family of functions had been called by the child process to execute the new process
image.
It is implementation-defined whether the fork handlers are run when posix_spawn() or posix_spawnp() is called.
RETURN VALUE
Upon successful completion, posix_spawn() and posix_spawnp() shall return the process ID of the child process to
the parent process, in the variable pointed to by a non-null pid argument, and shall return zero as the function return
value. Otherwise, no child process shall be created, the value stored into the variable pointed to by a non-null pid is
unspecified, and an error number shall be returned as the function return value to indicate the error. If the pid argument
is a null pointer, the process ID of the child is not returned to the caller.
ERRORS
These functions may fail if:
[EINVAL]
The value specified by file_actions or attrp is invalid.
If this error occurs after the calling process successfully returns from the posix_spawn() or posix_spawnp()
function, the child process may exit with exit status 127.
If posix_spawn() or posix_spawnp() fail for any of the reasons that would cause fork() or one of the exec family of functions to
fail, including when the corresponding exec function would attempt a fallback to
sh instead of failing with [ENOEXEC], an error value shall be returned as described by
fork() and exec, respectively; or, if the
error occurs after the calling process successfully returns, the child process shall exit with exit status 127.
If POSIX_SPAWN_SETPGROUP is set in the spawn-flags attribute of the object referenced by attrp, and
posix_spawn() or posix_spawnp() fails while changing the child's process group, an error value shall be returned as
described by setpgid(); or, if the error occurs after the calling process
successfully returns, the child process shall exit with exit status 127.
If POSIX_SPAWN_SETSID is set in the spawn-flags attribute of the object referenced by attrp, and
posix_spawn() or posix_spawnp() fails while creating the new session, changing the child's session ID, or changing
the child's process group, an error value shall be returned as described by setsid();
or, if the error occurs after the calling process successfully returns, the child process shall exit with exit status 127.
[PS]  If
POSIX_SPAWN_SETSCHEDPARAM is set and POSIX_SPAWN_SETSCHEDULER is not set in the spawn-flags attribute of the object
referenced by attrp, then if posix_spawn() or posix_spawnp() fails for any of the reasons that would cause
sched_setparam() to fail, an error value shall be returned as described by
sched_setparam(); or, if the error occurs after the calling process
successfully returns, the child process shall exit with exit status 127.
If POSIX_SPAWN_SETSCHEDULER is set in the spawn-flags attribute of the object referenced by attrp, and if
posix_spawn() or posix_spawnp() fails for any of the reasons that would cause sched_setscheduler() to fail, an error value shall be returned as described by
sched_setscheduler(); or, if the error occurs after the calling process
successfully returns, the child process shall exit with exit status 127.
If the file_actions argument is not a null pointer, and specifies any chdir, close, dup2,
fchdir, or open actions to be performed, and if posix_spawn() or posix_spawnp() fails for any of the
reasons that would cause chdir(), close(), dup2(), fchdir(), or open() to fail, other than
attempting a close() on a file descriptor that is in range but already closed, an
error value shall be returned as described by chdir(), close(), dup2(), fchdir(), and open(), respectively; or, if the
error occurs after the calling process successfully returns, the child process shall exit with exit status 127. An open file action
may, by itself, result in any of the errors described by close() or dup2(), in addition to those described by open().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
These functions are part of the Spawn option and need not be provided on all implementations.
See also the APPLICATION USAGE section for exec.
RATIONALE
The posix_spawn() function and its close relation posix_spawnp() have been introduced to overcome the following perceived
difficulties with fork(): the fork()
function is difficult or impossible to implement without swapping or dynamic address translation.
Swapping is generally too slow for a realtime environment.
Dynamic address translation is not available everywhere that POSIX might be useful.
Processes are too useful to simply option out of POSIX whenever it must run without address translation or other MMU
services.
Thus, POSIX needs process creation and file execution primitives that can be efficiently implemented without address translation
or other MMU services.
The posix_spawn() function is implementable as a library routine, but both posix_spawn() and posix_spawnp()
are designed as kernel operations. Also, although they may be an efficient replacement for many fork()/exec pairs, their goal is to provide useful process creation primitives for
systems that have difficulty with fork(), not to provide drop-in replacements for
fork()/exec.
This view of the role of posix_spawn() and posix_spawnp() influenced the design of their API. It does not attempt
to provide the full functionality of fork()/exec in which arbitrary
user-specified operations of any sort are permitted between the creation of the child process and the execution of the new process
image; any attempt to reach that level would need to provide a programming language as parameters. Instead, posix_spawn()
and posix_spawnp() are process creation primitives like the Start_Process and Start_Process_Search Ada
language bindings package POSIX_Process_Primitives and also like those in many operating systems that are not UNIX systems,
but with some POSIX-specific additions.
To achieve its coverage goals, posix_spawn() and posix_spawnp() have control of seven types of inheritance: file
descriptors, current working directory, process group ID, user and group ID, signal mask, scheduling, and whether each signal
ignored in the parent will remain ignored in the child, or be reset to its default action in the child.
Control of file descriptors is required to allow an independently written child process image to access data streams opened by
and even generated or read by the parent process without being specifically coded to know which parent files and file descriptors
are to be used. Control of the current working directory is required because the parent process may want to constrain the resources
that the child process can reach from its current working directory or affect how relative pathnames are interpreted, while
recognizing that a multi-threaded parent process would require a lot of overhead to safely change its own working directory prior
to creating the child process. Control of the process group ID is required to control how the job control of the child process
relates to that of the parent.
Control of the signal mask and signal defaulting is sufficient to support the implementation of system(). Although support for system() is not
explicitly one of the goals for posix_spawn() and posix_spawnp(), it is covered under the "at least 50%" coverage
goal.
The intention is that the normal file descriptor inheritance across fork(), the
subsequent effect of the specified spawn file actions, and the normal file descriptor inheritance across one of the exec family of functions should fully specify open file inheritance. The implementation need make
no decisions regarding the set of open file descriptors when the child process image begins execution, those decisions having
already been made by the caller and expressed as the set of open file descriptors and their FD_CLOEXEC and FD_CLOFORK flags at the
time of the call, the actions of fork handlers (if they are called), and the spawn file actions object specified in the call. We
have been assured that in cases where the POSIX Start_Process Ada primitives have been implemented in a library, this method
of controlling file descriptor inheritance may be implemented very easily.
We can identify several problems with posix_spawn() and posix_spawnp(), but there does not appear to be a solution
that introduces fewer problems. Environment modification for child process attributes not specifiable via the attrp or
file_actions arguments must be done in the parent process, and since the parent generally wants to save its context, it is
more costly than similar functionality with fork()/exec. It is also complicated
to modify the environment of a multi-threaded process temporarily, since all threads must agree when it is safe for the environment
to be changed. However, this cost is only borne by those invocations of posix_spawn() and posix_spawnp() that use the
additional functionality. Since extensive modifications are not the usual case, and are particularly unlikely in time-critical
code, keeping much of the environment control out of posix_spawn() and posix_spawnp() is appropriate design.
The posix_spawn() and posix_spawnp() functions do not have all the power of fork()/exec. This is to be expected. The fork() function is a wonderfully powerful operation. We do not expect to duplicate its
functionality in a simple, fast function with no special hardware requirements. It is worth noting that posix_spawn() and
posix_spawnp() are very similar to the process creation operations on many operating systems that are not UNIX systems.
Requirements
The requirements for posix_spawn() and posix_spawnp() are:
They must be implementable without an MMU or unusual hardware.
They must be compatible with existing POSIX standards.
Additional goals are:
They should be efficiently implementable.
They should be able to replace at least 50% of typical executions of fork().
A system with posix_spawn() and posix_spawnp() and without fork()
should be useful, at least for realtime applications.
A system with fork() and the exec family
should be able to implement posix_spawn() and posix_spawnp() as library routines.
Two-Syntax
POSIX exec has several calling sequences with approximately the same functionality.
These appear to be required for compatibility with existing practice. Since the existing practice for the posix_spawn*()
functions is otherwise substantially unlike POSIX, we feel that simplicity outweighs compatibility. There are, therefore, only two
names for the posix_spawn*() functions.
The parameter list does not differ between posix_spawn() and posix_spawnp(); posix_spawnp() interprets the
second parameter more elaborately than posix_spawn().
Compatibility with POSIX.5 (Ada)
The Start_Process and Start_Process_Search procedures from the POSIX_Process_Primitives package from the
Ada language binding to POSIX.1 encapsulate fork() and exec functionality in a manner similar to that of posix_spawn() and posix_spawnp().
Originally, in keeping with our simplicity goal, the standard developers had limited the capabilities of posix_spawn() and
posix_spawnp() to a subset of the capabilities of Start_Process and Start_Process_Search; certain non-default
capabilities were not supported. However, based on suggestions by the ballot group to improve file descriptor mapping or drop it,
and on the advice of an Ada Language Bindings working group member, the standard developers decided that posix_spawn() and
posix_spawnp() should be sufficiently powerful to implement Start_Process and Start_Process_Search. The
rationale is that if the Ada language binding to such a primitive had already been approved as an IEEE standard, there can be
little justification for not approving the functionally-equivalent parts of a C binding. The only three capabilities provided by
posix_spawn() and posix_spawnp() that are not provided by Start_Process and Start_Process_Search are
optionally specifying the child's process group ID, the set of signals to be reset to default signal handling in the child process,
and the child's scheduling policy and parameters.
For the Ada language binding for Start_Process to be implemented with posix_spawn(), that binding would need to
explicitly pass an empty signal mask and the parent's environment to posix_spawn() whenever the caller of
Start_Process allowed these arguments to default, since posix_spawn() does not provide such defaults. The ability of
Start_Process to mask user-specified signals during its execution is functionally unique to the Ada language binding and
must be dealt with in the binding separately from the call to posix_spawn().
Process Group
The process group inheritance field can be used to join the child process with an existing process group. By assigning a value
of zero to the spawn-pgroup attribute of the object referenced by attrp, the setpgid() mechanism will place the child process in a new process group.
Threads
Without the posix_spawn() and posix_spawnp() functions, systems without address translation can still use threads
to give an abstraction of concurrency. In many cases, thread creation suffices, but it is not always a good substitute. The
posix_spawn() and posix_spawnp() functions are considerably "heavier" than thread creation. Processes have several
important attributes that threads do not. Even without address translation, a process may have base-and-bound memory protection.
Each process has a process environment including security attributes and file capabilities, and powerful scheduling attributes.
Processes abstract the behavior of non-uniform-memory-architecture multi-processors better than threads, and they are more
convenient to use for activities that are not closely linked.
The posix_spawn() and posix_spawnp() functions may not bring support for multiple processes to every
configuration. Process creation is not the only piece of operating system support required to support multiple processes. The total
cost of support for multiple processes may be quite high in some circumstances. Existing practice shows that support for multiple
processes is uncommon and threads are common among "tiny kernels". There should, therefore, probably continue to be AEPs for
operating systems with only one process.
Asynchronous Error Notification
A library implementation of posix_spawn() or posix_spawnp() may not be able to detect all possible errors before
it forks the child process. POSIX.1-2024 provides for an error indication returned from a child process which could not
successfully complete the spawn operation via a special exit status which may be detected using the status value returned by
wait(), waitid(), and waitpid().
The stat_val interface and the macros used to interpret it are not well suited to the purpose of returning API errors,
but they are the only path available to a library implementation. Thus, an implementation may cause the child process to exit with
exit status 127 for any error detected during the spawn process after the posix_spawn() or posix_spawnp() function
has successfully returned.
The standard developers had proposed using two additional macros to interpret stat_val. The first, WIFSPAWNFAIL, would
have detected a status that indicated that the child exited because of an error detected during the posix_spawn() or
posix_spawnp() operations rather than during actual execution of the child process image; the second, WSPAWNERRNO, would
have extracted the error value if WIFSPAWNFAIL indicated a failure. Unfortunately, the ballot group strongly opposed this because
it would make a library implementation of posix_spawn() or posix_spawnp() dependent on kernel modifications to
waitpid() to be able to embed special information in stat_val to indicate a
spawn failure.
The 8 bits of child process exit status that are guaranteed by POSIX.1-2024 to be accessible to the waiting parent process are
insufficient to disambiguate a spawn error from any other kind of error that may be returned by an arbitrary process image. No
other bits of the exit status are required to be visible in stat_val, so these macros could not be strictly implemented at
the library level. Reserving an exit status of 127 for such spawn errors is consistent with the use of this value by system() and popen() to signal failures in these
operations that occur after the function has returned but before a shell is able to execute. The exit status of 127 does not
uniquely identify this class of error, nor does it provide any detailed information on the nature of the failure. Note that a
kernel implementation of posix_spawn() or posix_spawnp() is permitted (and encouraged) to return any possible error
as the function value, thus providing more detailed failure information to the parent process.
Thus, no special macros are available to isolate asynchronous posix_spawn() or posix_spawnp() errors. Instead,
errors detected by the posix_spawn() or posix_spawnp() operations in the context of the child process before the new
process image executes are reported by setting the child's exit status to 127. The calling process may use the WIFEXITED and
WEXITSTATUS macros on the stat_val stored by the wait() or waitpid() functions to detect spawn failures to the extent that other status values with
which the child process image may exit (before the parent can conclusively determine that the child process image has begun
execution) are distinct from exit status 127.
FUTURE DIRECTIONS
None.
SEE ALSO
alarm(), chmod(),
close(), dup(), exec, exit(), fcntl(), fork(), fstatat(), kill(), open(), posix_spawn_file_actions_addchdir(), posix_spawn_file_actions_addclose(), posix_spawn_file_actions_adddup2(), posix_spawn_file_actions_destroy(), posix_spawnattr_destroy(), posix_spawnattr_getsigdefault(), posix_spawnattr_getflags(), posix_spawnattr_getpgroup(), posix_spawnattr_getschedparam(), posix_spawnattr_getschedpolicy(), posix_spawnattr_getsigmask(), sched_setparam(), sched_setscheduler(), setpgid()
, setsid(), setuid(), times(), wait(), waitid()
XBD 8. Environment Variables,
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1d-1999.
IEEE PASC Interpretation 1003.1 #103 is applied, noting that the signal default actions are changed as well as the signal mask
in step 2.
IEEE PASC Interpretation 1003.1 #132 is applied.
Issue 7
Functionality relating to the Threads option is moved to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0433 [291], XSH/TC1-2008/0434 [173], and XSH/TC1-2008/0435 [173] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0255 [824] is applied.
Issue 8
Austin Group Defect 370 is applied, requiring that attempting to close a file descriptor that is in range but already closed is
not treated as an error.
Austin Group Defect 768 is applied, adding OFD-owned file locks.
Austin Group Defect 1044 is applied, adding POSIX_SPAWN_SETSID.
Austin Group Defect 1208 is applied, adding posix_spawn_file_actions_addchdir() and posix_spawn_file_actions_addfchdir().
Austin Group Defect 1318 is applied, adding FD_CLOFORK and clarifying that the inherited set of file descriptors is affected by
the actions of fork handlers (if they are called).
Austin Group Defect 1328 is applied, adding the restrict keyword to the third parameter of posix_spawn() and
posix_spawnp().
Austin Group Defect 1362 is applied, removing parentheses around some text intended to be normative.
Austin Group Defect 1674 is applied, adding a requirement that posix_spawnp() does not fallback to executing sh when the corresponding exec function would do so
instead of failing with [ENOEXEC].
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/thrd_join.html =====
thrd_join
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
thrd_join — wait for thread termination
SYNOPSIS
#include
int thrd_join(thrd_t thr, int *res);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The thrd_join() function shall join the thread identified by thr with the current thread by blocking until the
other thread has terminated. If the parameter res is not a null pointer, thrd_join() shall store the thread's exit
status in the integer pointed to by res. The termination of the other thread shall synchronize with the completion of the
thrd_join() function. The application shall ensure that the thread identified by thr has not been previously detached
or joined with another thread.
The results of multiple simultaneous calls to thrd_join() specifying the same target thread are undefined.
The behavior is undefined if the value specified by the thr argument to thrd_join() refers to the calling
thread.
[CX]  It
is unspecified whether a zombie thread counts against {PTHREAD_THREADS_MAX}.
If thr refers to a thread that was created using pthread_create()
or via a SIGEV_THREAD notification and the thread terminates, or has already terminated, by returning from its start routine, the
behavior of thrd_join() is undefined. If thr refers to a thread that terminates, or has already terminated, by
calling pthread_exit() or by being cancelled, the behavior of
thrd_join() is undefined.
The thrd_join() function shall not be affected if the calling thread executes a signal handler during the call.
RETURN VALUE
The thrd_join() function shall return thrd_success on success or thrd_error if the request could not be
honored.
[CX]  It
is implementation-defined whether thrd_join() detects deadlock situations; if it does detect them, it shall return
thrd_error when one is detected.
ERRORS
See RETURN VALUE.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The thrd_join() function provides a simple mechanism allowing an application to wait for a thread to terminate. After the
thread terminates, the application may then choose to clean up resources that were used by the thread. For instance, after
thrd_join() returns, any application-provided stack storage could be reclaimed.
The thrd_join() or thrd_detach() function should eventually be called
for every thread that is created using thrd_create() so that storage associated
with the thread may be reclaimed.
The thrd_join() function cannot be used to obtain the exit status of a thread that was created using pthread_create() or via a SIGEV_THREAD notification and which terminates by returning
from its start routine, or of a thread that terminates by calling pthread_exit(), because such threads have a void * exit status, instead of the
int that thrd_join() returns via its res argument.
The thrd_join() function cannot be used to obtain the exit status of a thread that terminates by being cancelled because
it has no way to indicate that a thread was cancelled. (The pthread_join()
function does this by returning a reserved void * exit status; it is not possible to reserve an int value for this
purpose without introducing a conflict with the ISO C standard.) The standard developers considered adding a
thrd_canceled enumeration constant that thrd_join() would return in this case. However, this return would be
unexpected in code that is written to conform to the ISO C standard, and it would also not solve the problem that threads
which use only ISO C  interfaces (such as ones created by third
party libraries written to conform to the ISO C standard) have no way to handle being cancelled, as the ISO C standard
does not provide cancellation cleanup handlers.
The thrd_join() function is not affected by signal handlers for the reasons stated in XRAT B.2.3 Error Numbers.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_create(), pthread_exit(), pthread_join(),
thrd_create(), thrd_exit()
XBD 4.15.2 Memory Synchronization,
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/memmem.html =====
memmem
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
memmem — find a byte subsequence in a byte sequence
SYNOPSIS
[CX]  #include
void *memmem(const void *haystack, size_t haystacklen,
const void *needle, size_t needlelen);
DESCRIPTION
The memmem() function shall locate the first occurrence of byte sequence needle of length needlelen in byte
sequence haystack of length haystacklen.
RETURN VALUE
Upon successful completion, memmem() shall return a pointer to the the first byte of the located byte sequence in
haystack, or a null pointer if the byte sequence is not found.
If needlelen is zero, the function shall return haystack.
If haystacklen is less than needlelen, the function shall return a null pointer.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
This function is similar to strstr(), except that NUL bytes may be included in
either needle or haystack.
FUTURE DIRECTIONS
None.
SEE ALSO
memchr(), strstr()
XBD
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strerror_r.html =====
strerror
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strerror, strerror_l, strerror_r — get error message string
SYNOPSIS
#include
char *strerror(int errnum);
[CX]  char *strerror_l(int errnum, locale_t locale);
int strerror_r(int errnum, char *strerrbuf, size_t buflen);
DESCRIPTION
For strerror(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The strerror() function shall map the error number in errnum to a locale-dependent error message string and shall
return a pointer to it. Typically, the values for errnum come from errno, but strerror() shall map any value
of type int to a message.
The application shall not modify the string returned. [CX]   The returned string pointer might be invalidated or   the string content might be overwritten by a subsequent call to
strerror(), [CX]   or by a subsequent call to strerror_l() in the same thread. The returned pointer and the string content
might also be invalidated if the calling thread is terminated.
[CX]  The
string may be overwritten by a subsequent call to strerror_l() in the same thread.
The contents of the error message strings returned by strerror() should be determined by the setting of the
LC_MESSAGES category in the current locale.
The implementation shall behave as if no function defined in this volume of POSIX.1-2024 calls strerror().
[CX]  The
strerror() and strerror_l() functions shall not change the setting of errno if successful.
Since no return value is reserved to indicate an error of strerror(), an application wishing to check for error
situations should set errno to 0, then call strerror(), then check errno. Similarly, since strerror_l()
is required to return a string for some errors, an application wishing to check for all error situations should set errno to
0, then call strerror_l(), then check errno.
The strerror() function need not be thread-safe; however, strerror() shall avoid data races with all other
functions.
[CX]  The
strerror_l() function shall map the error number in errnum to a locale-dependent error message string in the locale
represented by locale and shall return a pointer to it.
The strerror_r() function shall map the error number in errnum to a locale-dependent error message string and
shall return the string in the buffer pointed to by strerrbuf, with length buflen.
[CX]  If
the value of errnum is a valid error number, the message string shall indicate what error occurred; if the value of
errnum is zero, the message string shall either be an empty string or indicate that no error occurred; otherwise, if these
functions complete successfully, the message string shall indicate that an unknown error occurred.
[CX]  The
behavior is undefined if the locale argument to strerror_l() is the special locale object LC_GLOBAL_LOCALE or is not
a valid locale object handle.
RETURN VALUE
Upon completion, whether successful or not, strerror() shall return a pointer to the generated message string.
[CX]
On error errno may be set, but no return value is reserved to indicate an error.
Upon successful completion, strerror_l() shall return a pointer to the generated message string. If errnum is not
a valid error number, errno may be set to [EINVAL], but a pointer to a message string shall still be returned. If any other
error occurs, errno shall be set to indicate the error and a null pointer shall be returned.
Upon successful completion, strerror_r() shall return 0. Otherwise, an error number shall be returned to indicate the
error.
ERRORS
These functions may fail if:
[EINVAL]
[CX]
The value of errnum is neither a valid error number nor zero.
The strerror_r() function shall fail if:
[ERANGE]
[CX]
Insufficient storage was supplied via strerrbuf and buflen to contain the generated message string.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Historically in some implementations, calls to perror() would overwrite the string
that the pointer returned by strerror() points to. Such implementations did not conform to the ISO C standard; however,
application developers should be aware of this behavior if they wish their applications to be portable to such implementations.
Applications should use strerror_l() rather than strerror() or strerror_r() to avoid thread safety and
possible alternative (non-conforming) versions of these functions in some implementations.
RATIONALE
The strerror_l() function is required to be thread-safe, thereby eliminating the need for an equivalent to the
strerror_r() function.
Earlier versions of this standard did not explicitly require that the error message strings returned by strerror() and
strerror_r() provide any information about the error. This version of the standard requires a meaningful message for any
successful completion.
Since no return value is reserved to indicate a strerror() error, but all calls (whether successful or not) must return a
pointer to a message string, on error strerror() can return a pointer to an empty string or a pointer to a meaningful string
that can be printed.
Note that the [EINVAL] error condition is a may fail error. If an invalid error number is supplied as the value of
errnum, applications should be prepared to handle any of the following:
Error (with no meaningful message): errno is set to [EINVAL], the return value is a pointer to an empty string.
Successful completion: errno is unchanged and the return value points to a string like "unknown error" or
"error number xxx" (where xxx is the value of errnum).
Combination of #1 and #2: errno is set to [EINVAL] and the return value points to a string like "unknown error"
or "error number xxx" (where xxx is the value of errnum). Since applications frequently use the return value
of strerror() as an argument to functions like fprintf() (without checking
the return value) and since applications have no way to parse an error message string to determine whether errnum represents
a valid error number, implementations are encouraged to implement #3. Similarly, implementations are encouraged to have
strerror_r() return [EINVAL] and put a string like "unknown error" or "error number xxx" in the buffer
pointed to by strerrbuf when the value of errnum is not a valid error number.
Additionally, implementations are encouraged to null terminate strerrbuf when failing with [ERANGE] for any size other
than buflen of zero.
Some applications rely on being able to set errno to 0 before calling a function with no reserved value to indicate an
error, then call strerror(errno) afterwards to detect whether an error occurred (because errno changed) or to
indicate success (because errno remained zero). This usage pattern requires that strerror(0) succeed with useful
results. Previous versions of the standard did not specify the behavior when errnum is zero.
FUTURE DIRECTIONS
None.
SEE ALSO
perror()
XBD
CHANGE HISTORY
First released in Issue 3.
Issue 5
The DESCRIPTION is updated to indicate that errno is not changed if the function is successful.
A note indicating that the strerror() function need not be reentrant is added to the DESCRIPTION.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the RETURN VALUE section, the fact that errno may be set is added.
The [EINVAL] optional error condition is added.
The normative text is updated to avoid use of the term "must" for application requirements.
The strerror_r() function is added in response to IEEE PASC Interpretation 1003.1c #39.
The strerror_r() function is marked as part of the Thread-Safe Functions option.
Issue 7
Austin Group Interpretation 1003.1-2001 #072 is applied, updating the ERRORS section.
Austin Group Interpretation 1003.1-2001 #156 is applied.
Austin Group Interpretation 1003.1-2001 #187 is applied, clarifying the behavior when the generated error message is an empty
string.
SD5-XSH-ERN-191 is applied, updating the APPLICATION USAGE section.
The strerror_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
The strerror_r() function is moved from the Thread-Safe Functions option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0595 [75], XSH/TC1-2008/0596 [447], XSH/TC1-2008/0597 [382,428],
XSH/TC1-2008/0598 [283], XSH/TC1-2008/0599 [382,428], XSH/TC1-2008/0600 [283], and XSH/TC1-2008/0601 [382,428] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0339 [656] is applied.
Issue 8
Austin Group Defect 398 is applied, changing the [ERANGE] error from "may fail" to "shall fail".
Austin Group Defect 655 is applied, changing the APPLICATION USAGE section.
Austin Group Defect 1302 is applied, aligning the strerror() function with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ffs.html =====
ffs
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ffs, ffsl, ffsll — find first set bit
SYNOPSIS
[XSI]  #include
int ffs(int i);
int ffsl(long i);
int ffsll(long long i);
DESCRIPTION
The ffs(), ffsl(), and ffsll() functions shall find the first bit set (beginning with the least significant
bit) in i, and return the index of that bit. Bits are numbered starting at one (the least significant bit).
RETURN VALUE
The ffs(), ffsl(), and ffsll() functions shall return the index of the first bit set. If i is 0,
then these functions shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 8
Austin Group Defect 617 is applied, adding ffsl() and ffsll().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fmodf.html =====
fmod
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fmod, fmodf, fmodl — floating-point remainder value function
SYNOPSIS
#include
double fmod(double x, double y);
float fmodf(float x, float y);
long double fmodl(long double x, long double y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall return the floating-point remainder of the division of x by y.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
These functions shall return the value x-i*y, for some integer i such that, if y is non-zero,
the result has the same sign as x and magnitude less than the magnitude of y.
If the correct value would cause underflow, [MXX]   and is not representable,   a range error may occur, and fmod(), modf(),
and fmodl() shall return [MXX]   0.0, or   (if the IEC 60559
Floating-Point option is not supported) an implementation-defined value no greater in magnitude than DBL_MIN, FLT_MIN, and
LDBL_MIN, respectively.
[MX]  If
x or y is NaN, a NaN shall be returned, and none of the conditions below shall be considered.
If y is zero, a domain error shall occur, and a NaN shall be returned.
If x is infinite, a domain error shall occur, and a NaN shall be returned.
If x is ±0 and y is not zero, ±0 shall be returned.
If x is not infinite and y is ±Inf, x shall be returned.
When subnormal results are supported, the returned value shall be exact and shall be independent of the current rounding
direction mode.
ERRORS
These functions shall fail if:
Domain Error
[MX]
The x argument is infinite or y is zero.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
These functions may fail if:
Range Error
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), isnan()
4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The behavior for when the y argument is zero is now defined.
The fmodf() and fmodl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0151 [68], XSH/TC1-2008/0152 [320], and XSH/TC1-2008/0153 [68] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0120 [605] is applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sqrt.html =====
sqrt
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sqrt, sqrtf, sqrtl — square root function
SYNOPSIS
#include
double sqrt(double x);
float sqrtf(float x);
long double sqrtl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the square root of their argument \(x\),
\(\sqrt{x}\).
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the square root of \(x\).
[MX]  The
returned value shall be dependent on the current rounding direction mode.
For finite values of \(x\)
...
double x = 9.0;
double result;
...
result = sqrt(x);
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are
independent of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept, fetestexcept, isnan
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The sqrtf() and sqrtl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0588 [320] is applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mq_close.html =====
mq_close
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mq_close — close a message queue (REALTIME)
SYNOPSIS
[MSG]  #include
int mq_close(mqd_t mqdes);
DESCRIPTION
The mq_close() function shall remove the association between the message queue descriptor, mqdes, and its message
queue. The results of using this message queue descriptor after successful return from this mq_close(), and until the return
of this message queue descriptor from a subsequent mq_open(), are undefined.
If a message queue descriptor is implemented using a file descriptor, mq_close() shall close the file descriptor.
If the process has successfully attached a notification request to the message queue via this mqdes, this attachment
shall be removed, and the message queue is available for another process to attach for notification.
RETURN VALUE
Upon successful completion, the mq_close() function shall return a value of zero; otherwise, the function shall return a
value of -1 and set errno to indicate the error.
ERRORS
The mq_close() function shall fail if:
[EBADF]
The mqdes argument is not a valid message queue descriptor.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
mq_open(), mq_unlink(),
msgctl(), msgget(), msgrcv(), msgsnd()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The mq_close() function is marked as part of the Message Passing option.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Message
Passing option.
Issue 8
Austin Group Defect 368 is applied, adding a requirement that if a message queue descriptor is implemented using a file
descriptor, mq_close() closes the file descriptor.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/stderr.html =====
stdin
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
stderr, stdin, stdout — standard I/O streams
SYNOPSIS
#include
extern FILE *stderr, *stdin, *stdout;
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
A file with associated buffering is called a stream and is declared to be a pointer to a defined type FILE. The
fopen() function shall create certain descriptive data for a stream and return a
pointer to designate the stream in all further transactions. Normally, there are three open streams with constant pointers declared
in the  header and associated with the standard open files.
At program start-up, three streams shall be predefined and already open: stdin (standard input, for conventional input)
for reading, stdout (standard output, for conventional output) for writing, and stderr (standard error, for
diagnostic output) for writing. When opened, stderr shall not be fully buffered; stdin and stdout shall be
fully buffered if and only if [CX]   the file descriptor associated with the stream is determined not to be associated with an
interactive device.
[CX]  The
following symbolic values in  define the file descriptors that shall
be associated with the C-language stdin, stdout, and stderr when the application is started:
STDIN_FILENO
Standard input value, stdin. Its value is 0.
STDOUT_FILENO
Standard output value, stdout. Its value is 1.
STDERR_FILENO
Standard error value, stderr. Its value is 2.
These file descriptors are often all associated with a single open file description which has access mode O_RDWR (e.g., in the
case of a terminal device for a login shell). However, the stderr, stdin, and stdout streams need not be
opened for both reading and writing at program start-up in this case.
RETURN VALUE
None.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
fclose(), feof(), ferror(), fileno(), fopen(), fprintf(), fread(), fscanf(), fseek(), getc(), isatty(), popen(), putc(), puts(), read(), setbuf(), setvbuf(), tmpfile(), ungetc(), vfprintf()
XBD ,
CHANGE HISTORY
First released in Issue 1.
Issue 6
Extensions beyond the ISO C standard are marked.
A note that stderr is expected to be open for reading and writing is added to the DESCRIPTION.
Issue 8
Austin Group Defect 1347 is applied, clarifying the requirements for how stderr, stdin, and stdout are
opened at program start-up.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ctime.html =====
ctime
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ctime — convert a time value to a date and time string
SYNOPSIS
[OB]  #include
char *ctime(const time_t *clock);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The ctime() function shall convert the time pointed to by clock, representing time in seconds since the Epoch, to
local time in the form of a string. It shall be equivalent to:
asctime(localtime(clock))
The asctime(), ctime(), gmtime(), and localtime() functions shall
return values in one of two static objects: a broken-down time structure and an array of char. Execution of any of the
functions that return a pointer to one of these object types may overwrite the information in any object of the same type pointed
to by the value returned from any previous call to any of them.
The ctime() function need not be thread-safe; however, ctime() shall avoid data races with all functions other
than itself, asctime(), gmtime(), and
localtime().
RETURN VALUE
The ctime() function shall return the pointer returned by asctime() with
that broken-down time as an argument.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
This function is included only for compatibility with older implementations. It has undefined behavior if the resulting string
would be too long, so the use of this function should be discouraged. On implementations that do not detect output string length
overflow, it is possible to overflow the output buffer in such a way as to cause applications to fail, or possible system security
violations. Also, this function does not support localized date and time formats. To avoid these problems, applications should use
strftime() to generate strings from broken-down times.
Values for the broken-down time structure can be obtained by calling gmtime() or
localtime().
Attempts to use ctime() for times before the Epoch or for times beyond the year 9999 produce undefined results. Refer to
asctime().
RATIONALE
The standard developers decided to mark the ctime() function obsolescent even though it is in the ISO C standard due
to the possibility of buffer overflow. The ISO C standard also provides the strftime() function which can be used to avoid these problems.
FUTURE DIRECTIONS
This function may be removed in a future version, but not until after it has been removed from the ISO C standard.
SEE ALSO
asctime(), clock(), difftime(), futimens(), gmtime(), localtime(), mktime(), strftime(), strptime(), time()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
Normative text previously in the APPLICATION USAGE section is moved to the DESCRIPTION.
The ctime_r() function is included for alignment with the POSIX Threads Extension.
A note indicating that the ctime() function need not be reentrant is added to the DESCRIPTION.
Issue 6
Extensions beyond the ISO C standard are marked.
In the DESCRIPTION, the note about reentrancy is expanded to cover thread-safety.
The APPLICATION USAGE section is updated to include a note on the thread-safe function and its avoidance of possibly using a
static data area.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
SD5-XSH-ERN-25 is applied, updating the APPLICATION USAGE.
Austin Group Interpretation 1003.1-2001 #053 is applied, marking these functions obsolescent.
The ctime_r() function is moved from the Thread-Safe Functions option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0066 [321,428] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0075 [664] is applied.
Issue 8
Austin Group Defect 1302 is applied, aligning this function with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1330 is applied, changing the FUTURE DIRECTIONS section.
Austin Group Defect 1376 is applied, removing CX shading from some text derived from the ISO C standard and updating it to
match the ISO C standard.
Austin Group Defect 1410 is applied, removing the ctime_r() function.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/vwprintf.html =====
vfwprintf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
vfwprintf, vswprintf, vwprintf — wide-character formatted output of a stdarg argument list
SYNOPSIS
#include
#include
#include
int vfwprintf(FILE *restrict stream, const wchar_t *restrict format,
va_list arg);
int vswprintf(wchar_t *restrict ws, size_t n,
const wchar_t *restrict format, va_list arg);
int vwprintf(const wchar_t *restrict format, va_list arg);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The vfwprintf(), vswprintf(), and vwprintf() functions shall be equivalent to fwprintf(), swprintf(), and wprintf() respectively, except that instead of being called with a variable number of
arguments, they are called with an argument list as defined by .
These functions shall not invoke the va_end macro. However, as these functions do invoke the va_arg macro, the
value of ap after the return is unspecified.
RETURN VALUE
Refer to fwprintf().
ERRORS
Refer to fwprintf().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications using these functions should call va_end(ap) afterwards to clean up.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fwprintf()
XBD , ,
CHANGE HISTORY
First released in Issue 5. Included for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E).
Issue 6
The vfwprintf(), vswprintf(), and vwprintf() prototypes are updated for alignment with the
ISO/IEC 9899:1999 standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0705 [14] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/contents.html =====
System Interfaces: Table of contents
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
System Interfaces: Table of Contents
1. Introduction
1.1 Relationship to Other Formal Standards
1.2 Format of Entries
2. General Information
2.1 Use and Implementation of Interfaces
2.1.1 Use and Implementation of Functions
2.1.2 Use and Implementation of Macros
2.2 The Compilation Environment
2.2.1 POSIX.1 Symbols
2.2.1.1 The _POSIX_C_SOURCE Feature Test Macro
2.2.1.2 The _XOPEN_SOURCE Feature Test Macro
2.2.1.3 The __STDC_WANT_LIB_EXT1__ Feature Test Macro
2.2.2 The Name Space
2.3 Error Numbers
2.3.1 Additional Error Numbers
2.4 Signal Concepts
2.4.1 Signal Generation and Delivery
2.4.2 Realtime Signal Generation and Delivery
2.4.3 Signal Actions
SIG_DFL
SIG_IGN
Pointer to a Function
2.4.4 Signal Effects on Other Functions
2.5 Standard I/O Streams
2.5.1 Interaction of File Descriptors and Standard I/O Streams
2.5.2 Stream Orientation and Encoding Rules
2.6 File Descriptor Allocation
2.7 XSI Interprocess Communication
2.7.1 IPC General Description
2.8 Realtime
2.8.1 Realtime Signals
2.8.2 Asynchronous I/O
2.8.3 Memory Management
2.8.3.1 Memory Locking
2.8.3.2 Memory Mapped Files
2.8.3.3 Memory Protection
2.8.3.4 Typed Memory Objects
2.8.4 Process Scheduling
Scheduling Policies
SCHED_FIFO
SCHED_RR
SCHED_SPORADIC
SCHED_OTHER
2.8.5 Clocks and Timers
Time Value Specification Structures
Timer Event Notification Control Block
Manifest Constants
Execution Time Monitoring
2.9 Threads
2.9.1 Thread-Safety
2.9.2 Thread IDs
2.9.3 Thread Mutexes
2.9.4 Thread Scheduling
Thread Scheduling Attributes
Thread Scheduling Contention Scope
Scheduling Allocation Domain
Scheduling Documentation
2.9.5 Thread Cancellation
2.9.5.1 Cancelability States
2.9.5.2 Cancellation Points
2.9.5.3 Thread Cancellation Cleanup Handlers
2.9.5.4 Async-Cancel Safety
2.9.6 Thread Read-Write Locks
2.9.7 Thread Interactions with File Operations
2.9.8 Use of Application-Managed Thread Stacks
2.9.9 Synchronization Object Copies and Alternative Mappings
2.10 Sockets
2.10.1 Address Families
2.10.2 Addressing
2.10.3 Protocols
2.10.4 Routing
2.10.5 Interfaces
2.10.6 Socket Types
2.10.7 Socket I/O Mode
2.10.8 Socket Owner
2.10.9 Socket Queue Limits
2.10.10 Pending Error
2.10.11 Socket Receive Queue
2.10.12 Socket Out-of-Band Data State
2.10.13 Connection Indication Queue
2.10.14 Signals
2.10.15 Asynchronous Errors
2.10.16 Use of Options
2.10.17 Use of Sockets for Local UNIX Connections
2.10.17.1 Headers
2.10.18 Use of Sockets over Internet Protocols
2.10.19 Use of Sockets over Internet Protocols Based on IPv4
2.10.19.1 Headers
2.10.20 Use of Sockets over Internet Protocols Based on IPv6
2.10.20.1 Addressing
2.10.20.2 Compatibility with IPv4
2.10.20.3 Interface Identification
2.10.20.4 Options
2.10.20.5 Headers
2.11 Data Types
2.11.1 Defined Types
2.11.2 The char Type
2.12 Status Information
Footnotes
3. System Interfaces
CMPLX
_Exit
a64l
abort
abs
accept
access
acos
acosh
aio_cancel
aio_error
aio_fsync
aio_read
aio_return
aio_suspend
aio_write
alarm
aligned_alloc
alphasort
asctime
asin
asinh
assert
at_quick_exit
atan
atan2
atanh
atexit
atof
atoi
atol
atomic_compare_exchange_strong
atomic_exchange
atomic_fetch_add
atomic_flag_clear
atomic_flag_test_and_set
atomic_init
atomic_is_lock_free
atomic_load
atomic_signal_fence
atomic_store
basename
be16toh
bind
bindtextdomain
bsearch
btowc
c16rtomb
cabs
cacos
cacosh
call_once
calloc
carg
casin
casinh
catan
catanh
catclose
catgets
catopen
cbrt
ccos
ccosh
ceil
cexp
cfgetispeed
cfgetospeed
cfsetispeed
cfsetospeed
chdir
chmod
chown
cimag
clearerr
clock
clock_getcpuclockid
clock_getres
clock_nanosleep
clog
close
closedir
closelog
cnd_broadcast
cnd_destroy
cnd_timedwait
confstr
conj
connect
copysign
cos
cosh
cpow
cproj
creal
creat
crypt
csin
csinh
csqrt
ctan
ctanh
ctermid
ctime
dbm_clearerr
difftime
dirfd
dirname
div
dladdr
dlclose
dlerror
dlopen
dlsym
drand48
dup
duplocale
encrypt
endgrent
endhostent
endnetent
endprotoent
endpwent
endservent
endutxent
erf
erfc
errno
exec
exit
exp
exp2
expm1
fabs
fchdir
fchmod
fchown
fclose
fcntl
fdatasync
fdim
fdopen
fdopendir
feclearexcept
fegetenv
fegetexceptflag
fegetround
feholdexcept
feof
feraiseexcept
ferror
fetestexcept
feupdateenv
fflush
ffs
fgetc
fgetpos
fgets
fgetwc
fgetws
fileno
flockfile
floor
fma
fmax
fmemopen
fmin
fmod
fmtmsg
fnmatch
fopen
fork
fpathconf
fpclassify
fprintf
fputc
fputs
fputwc
fputws
fread
free
freeaddrinfo
freelocale
freopen
frexp
fscanf
fseek
fsetpos
fstat
fstatat
fstatvfs
fsync
ftell
ftok
ftruncate
futimens
fwide
fwprintf
fwrite
fwscanf
gai_strerror
getc
getc_unlocked
getchar
getcwd
getdate
getdelim
getegid
getentropy
getenv
geteuid
getgid
getgrgid
getgrnam
getgroups
gethostid
gethostname
getlocalename_l
getlogin
getnameinfo
getopt
getpeername
getpgid
getpgrp
getpid
getppid
getpriority
getpwnam
getpwuid
getresgid
getresuid
getrlimit
getrusage
getsid
getsockname
getsockopt
getsubopt
gettext
getuid
getwc
getwchar
glob
gmtime
grantpt
hcreate
htonl
hypot
iconv
iconv_close
iconv_open
if_freenameindex
if_indextoname
if_nameindex
if_nametoindex
ilogb
imaxabs
imaxdiv
in6addr_any
inet_addr
inet_ntop
initstate
insque
isalnum
isalpha
isatty
isblank
iscntrl
isdigit
isfinite
isgraph
isgreater
isinf
islower
isnan
isnormal
isprint
ispunct
isspace
isunordered
isupper
iswalnum
iswalpha
iswblank
iswcntrl
iswctype
iswdigit
iswgraph
iswlower
iswprint
iswpunct
iswspace
iswupper
iswxdigit
isxdigit
j0
kill
kill_dependency
killpg
labs
lchown
ldexp
ldiv
lgamma
link
lio_listio
listen
llrint
llround
localeconv
localtime
lockf
log
log10
log1p
log2
logb
longjmp
lrint
lround
lsearch
lseek
malloc
mblen
mbrlen
mbrtoc16
mbrtowc
mbsinit
mbsrtowcs
mbstowcs
mbtowc
memccpy
memchr
memcmp
memcpy
memmem
memmove
memset
mkdir
mkdtemp
mkfifo
mknod
mktime
mlock
mlockall
mmap
modf
mprotect
mq_close
mq_getattr
mq_notify
mq_open
mq_receive
mq_send
mq_setattr
mq_unlink
msgctl
msgget
msgrcv
msgsnd
msync
mtx_destroy
mtx_lock
munmap
nan
nanosleep
nearbyint
newlocale
nextafter
nftw
nice
nl_langinfo
open
open_memstream
pause
pclose
perror
pipe
poll
popen
posix_devctl
posix_fadvise
posix_fallocate
posix_getdents
posix_madvise
posix_mem_offset
posix_memalign
posix_openpt
posix_spawn
posix_spawn_file_actions_addchdir
posix_spawn_file_actions_addclose
posix_spawn_file_actions_adddup2
posix_spawn_file_actions_destroy
posix_spawnattr_destroy
posix_spawnattr_getflags
posix_spawnattr_getpgroup
posix_spawnattr_getschedparam
posix_spawnattr_getschedpolicy
posix_spawnattr_getsigdefault
posix_spawnattr_getsigmask
posix_typed_mem_get_info
posix_typed_mem_open
pow
pselect
psiginfo
pthread_atfork
pthread_attr_destroy
pthread_attr_getdetachstate
pthread_attr_getguardsize
pthread_attr_getinheritsched
pthread_attr_getschedparam
pthread_attr_getschedpolicy
pthread_attr_getscope
pthread_attr_getstack
pthread_attr_getstacksize
pthread_barrier_destroy
pthread_barrier_wait
pthread_barrierattr_destroy
pthread_barrierattr_getpshared
pthread_cancel
pthread_cleanup_pop
pthread_cond_broadcast
pthread_cond_clockwait
pthread_cond_destroy
pthread_condattr_destroy
pthread_condattr_getclock
pthread_condattr_getpshared
pthread_create
pthread_detach
pthread_equal
pthread_exit
pthread_getcpuclockid
pthread_getschedparam
pthread_getspecific
pthread_join
pthread_key_create
pthread_key_delete
pthread_kill
pthread_mutex_clocklock
pthread_mutex_consistent
pthread_mutex_destroy
pthread_mutex_getprioceiling
pthread_mutex_lock
pthread_mutexattr_destroy
pthread_mutexattr_getprioceiling
pthread_mutexattr_getprotocol
pthread_mutexattr_getpshared
pthread_mutexattr_getrobust
pthread_mutexattr_gettype
pthread_once
pthread_rwlock_clockrdlock
pthread_rwlock_clockwrlock
pthread_rwlock_destroy
pthread_rwlock_rdlock
pthread_rwlock_trywrlock
pthread_rwlock_unlock
pthread_rwlockattr_destroy
pthread_rwlockattr_getpshared
pthread_self
pthread_setcancelstate
pthread_setschedprio
pthread_sigmask
pthread_spin_destroy
pthread_spin_lock
pthread_spin_unlock
ptsname
putc
putchar
putenv
puts
putwc
putwchar
qsort
quick_exit
raise
rand
read
readdir
readlink
readv
realloc
realpath
recv
recvfrom
recvmsg
regcomp
remainder
remove
remquo
rename
rewind
rewinddir
rint
rmdir
round
scalbln
sched_get_priority_max
sched_getparam
sched_getscheduler
sched_rr_get_interval
sched_setparam
sched_setscheduler
sched_yield
seekdir
sem_clockwait
sem_close
sem_destroy
sem_getvalue
sem_init
sem_open
sem_post
sem_trywait
sem_unlink
semctl
semget
semop
send
sendmsg
sendto
setbuf
setegid
setenv
seteuid
setgid
setjmp
setkey
setlocale
setpgid
setregid
setresgid
setresuid
setreuid
setsid
setsockopt
setuid
setvbuf
shm_open
shm_unlink
shmat
shmctl
shmdt
shmget
shutdown
sig2str
sigaction
sigaddset
sigaltstack
sigdelset
sigemptyset
sigfillset
sigismember
siglongjmp
signal
signbit
sigpending
sigqueue
sigsetjmp
sigsuspend
sigtimedwait
sigwait
sin
sinh
sleep
sockatmark
socket
socketpair
sqrt
stdin
strcasecmp
strcat
strchr
strcmp
strcoll
strcpy
strcspn
strdup
strerror
strfmon
strftime
strlcat
strlen
strncat
strncmp
strncpy
strpbrk
strptime
strrchr
strsignal
strspn
strstr
strtod
strtoimax
strtok
strtol
strtoul
strxfrm
swab
symlink
sync
sysconf
system
tan
tanh
tcdrain
tcflow
tcflush
tcgetattr
tcgetpgrp
tcgetsid
tcgetwinsize
tcsendbreak
tcsetattr
tcsetpgrp
tcsetwinsize
tdelete
telldir
tgamma
thrd_create
thrd_current
thrd_detach
thrd_equal
thrd_exit
thrd_join
thrd_sleep
thrd_yield
time
timer_create
timer_delete
timer_getoverrun
times
timespec_get
tmpfile
tmpnam
tolower
toupper
towctrans
towlower
towupper
trunc
truncate
tss_create
tss_delete
tss_get
ttyname
tzset
umask
uname
ungetc
ungetwc
unlink
unlockpt
unsetenv
uselocale
vfprintf
vfscanf
vfwprintf
vfwscanf
wait
waitid
wcrtomb
wcscasecmp
wcscat
wcschr
wcscmp
wcscoll
wcscpy
wcscspn
wcsdup
wcsftime
wcslcat
wcslen
wcsncat
wcsncmp
wcsncpy
wcspbrk
wcsrchr
wcsrtombs
wcsspn
wcsstr
wcstod
wcstoimax
wcstok
wcstol
wcstombs
wcstoul
wcswidth
wcsxfrm
wctob
wctomb
wctrans
wctype
wcwidth
wmemchr
wmemcmp
wmemcpy
wmemmove
wmemset
wordexp
write
writev
y0
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index |
XBD |
XSH |
XCU |
XRAT ]
===== susv5-html/functions/dlerror.html =====
dlerror
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
dlerror — get diagnostic information
SYNOPSIS
#include
char *dlerror(void);
DESCRIPTION
The dlerror() function shall return a null-terminated character string (with no trailing ) that describes
the last error that occurred during dynamic linking processing. If no dynamic linking errors have occurred since the last
invocation of dlerror(), dlerror() shall return NULL. Thus, invoking dlerror() a second time, immediately
following a prior invocation, shall result in NULL being returned.
It is implementation-defined whether or not the dlerror() function is thread-safe. A thread-safe implementation shall
return only errors that occur on the current thread.
RETURN VALUE
If successful, dlerror() shall return a null-terminated character string; otherwise, NULL shall be returned.
The application shall not modify the string returned. The returned pointer might be invalidated or the string content might be
overwritten by a subsequent call to dlerror() in the same thread (if dlerror() is thread-safe) or in any thread (if
dlerror() is not thread-safe). The returned pointer might also be invalidated if the calling thread is terminated.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
The following example prints out the last dynamic linking error:
...
#include
char *errstr;
errstr = dlerror();
if (errstr != NULL)
printf ("A dynamic linking error occurred: (%s)\n", errstr);
...
APPLICATION USAGE
Depending on the application environment with respect to asynchronous execution events, such as signals or other asynchronous
computation sharing the address space, conforming applications should use a critical section to retrieve the error pointer and
buffer.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
dladdr(), dlclose(), dlopen(), dlsym()
XBD
CHANGE HISTORY
First released in Issue 5.
Issue 6
A note indicating that this function need not be reentrant is added to the DESCRIPTION.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
The dlerror() function is moved from the XSI option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0070 [75], XSH/TC1-2008/0071 [97], and XSH/TC1-2008/0072 [133] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0082 [656] is applied.
Issue 8
Austin Group Defect 993 is applied, adding dladdr() to the SEE ALSO section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_attr_setstacksize.html =====
pthread_attr_getstacksize
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_attr_getstacksize, pthread_attr_setstacksize — get and set the stacksize attribute
SYNOPSIS
[TSS]  #include
int pthread_attr_getstacksize(const pthread_attr_t *restrict attr,
size_t *restrict stacksize);
int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);
DESCRIPTION
The pthread_attr_getstacksize() and pthread_attr_setstacksize() functions, respectively, shall get and set the
thread creation stacksize attribute in the attr object.
The stacksize attribute shall define the minimum stack size (in bytes) allocated for the created threads stack.
The behavior is undefined if the value specified by the attr argument to pthread_attr_getstacksize() or
pthread_attr_setstacksize() does not refer to an initialized thread attributes object.
RETURN VALUE
Upon successful completion, pthread_attr_getstacksize() and pthread_attr_setstacksize() shall return a value of 0;
otherwise, an error number shall be returned to indicate the error.
The pthread_attr_getstacksize() function stores the stacksize attribute value in stacksize if
successful.
ERRORS
The pthread_attr_setstacksize() function shall fail if:
[EINVAL]
The value of stacksize is less than {PTHREAD_STACK_MIN} or exceeds a system-imposed limit.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
If an implementation detects that the value specified by the attr argument to pthread_attr_getstacksize() or
pthread_attr_setstacksize() does not refer to an initialized thread attributes object, it is recommended that the function
should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_attr_destroy(), pthread_attr_getdetachstate(), pthread_create()
XBD ,
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_attr_getstacksize() and pthread_attr_setstacksize() functions are marked as part of the Threads and
Thread Stack Size Attribute options.
The restrict keyword is added to the pthread_attr_getstacksize() prototype for alignment with the
ISO/IEC 9899:1999 standard.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/43 is applied, correcting the margin code in the SYNOPSIS from
TSA to TSS and updating the CHANGE HISTORY from "Thread Stack Address Attribute" option to "Thread Stack Size Attribute"
option.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/87 is applied, updating the ERRORS section to include optional
errors for the case when attr refers to an uninitialized thread attribute object.
Issue 7
The pthread_attr_getstacksize() and pthread_attr_setstacksize() functions are marked only as part of the Thread
Stack Size Attribute option as the Threads option is now part of the Base.
The [EINVAL] error for an uninitialized thread attributes object is removed; this condition results in undefined behavior.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0265 [757] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/open_memstream.html =====
open_memstream
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
open_memstream, open_wmemstream — open a dynamic memory buffer stream
SYNOPSIS
[CX]  #include
FILE *open_memstream(char **bufp, size_t *sizep);
#include
FILE *open_wmemstream(wchar_t **bufp, size_t *sizep);
DESCRIPTION
The open_memstream() and open_wmemstream() functions shall create an I/O stream associated with a dynamically
allocated memory buffer. The stream shall be opened for writing and shall be seekable.
The stream associated with a call to open_memstream() shall be byte-oriented.
The stream associated with a call to open_wmemstream() shall be wide-oriented.
The stream shall maintain a current position in the allocated buffer and a current buffer length. The position shall be
initially set to zero (the start of the buffer). Each write to the stream shall start at the current position and move this
position by the number of successfully written bytes for open_memstream() or the number of successfully written wide
characters for open_wmemstream(). The length shall be initially set to zero. If a write moves the position to a value larger
than the current length, the current length shall be set to this position. In this case a null character for
open_memstream() or a null wide character for open_wmemstream() shall be appended to the current buffer. For both
functions the terminating null is not included in the calculation of the buffer length.
After a successful fflush() or fclose(), the pointer referenced by bufp shall contain the address of the buffer, and
the variable pointed to by sizep shall contain the smaller of the current buffer length and the number of bytes for
open_memstream(), or the number of wide characters for open_wmemstream(), between the beginning of the buffer and the
current file position indicator.
The fseek() and fseeko() functions
can be used to set the file position beyond the current buffer length. It is implementation-defined whether this extends the buffer
to the new length. If it extends the buffer, the added buffer contents shall be set to null bytes for open_memstream(), or
null wide characters for open_wmemstream(); if it does not extend the buffer, then if data is later written at this point,
the buffer contents in the gap shall be set to null bytes for open_memstream(), or null wide characters for
open_wmemstream(). If fseek() or fseeko() is called with SEEK_END as the whence argument, it is implementation-defined
whether the file position is adjusted relative to the current buffer length or relative to the buffer size that would be set by an
fflush() call made immediately before the fseek() or fseeko() call.
After a successful fflush() the pointer referenced by bufp and the variable
referenced by sizep remain valid only until the next write operation on the stream or a call to fclose().
After a successful fclose(), the pointer referenced by bufp can be passed
to free().
RETURN VALUE
Upon successful completion, these functions shall return a pointer to the object controlling the stream. Otherwise, a null
pointer shall be returned, and errno shall be set to indicate the error.
ERRORS
These functions shall fail if:
[EMFILE]
{STREAM_MAX} streams are currently open in the calling process.
These functions may fail if:
[EINVAL]
bufp or sizep are NULL.
[EMFILE]
{FOPEN_MAX} streams are currently open in the calling process.
[ENOMEM]
Memory for the stream or the buffer could not be allocated.
The following sections are informative.
EXAMPLES
#include
#include
int
main (void)
{
FILE *stream;
char *buf;
size_t len;
off_t eob;
stream = open_memstream (&buf, &len);
if (stream == NULL)
/* handle error */ ;
fprintf (stream, "hello my world");
fflush (stream);
printf ("buf=%s, len=%zu\n", buf, len);
eob = ftello(stream);
fseeko (stream, 0, SEEK_SET);
fprintf (stream, "good-bye");
fseeko (stream, eob, SEEK_SET);
fclose (stream);
printf ("buf=%s, len=%zu\n", buf, len);
free (buf);
return 0;
}
This program produces the following output:
buf=hello my world, len=14
buf=good-bye world, len=14
APPLICATION USAGE
The buffer created by these functions should be freed by the application after closing the stream, by means of a call to
free().
RATIONALE
These functions are similar to fmemopen() except that the memory is always
allocated dynamically by the function, and the stream is opened only for output.
FUTURE DIRECTIONS
None.
SEE ALSO
fclose(), fdopen(), fflush(), fmemopen(), fopen(), free(), freopen()
XBD ,
CHANGE HISTORY
First released in Issue 7.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0244 [588] and XSH/TC2-2008/0245 [586] are applied.
Issue 8
Austin Group Defect 1406 is applied, clarifying the behavior of fseek() and
fseeko() on streams created by open_memstream() and
open_wmemstream().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strcoll.html =====
strcoll
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strcoll, strcoll_l — string comparison using collating information
SYNOPSIS
#include
int strcoll(const char *s1, const char *s2);
[CX]  int strcoll_l(const char *s1, const char *s2,
locale_t locale);
DESCRIPTION
For strcoll(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The strcoll() [CX]   and strcoll_l()
functions shall compare the string pointed to by s1 to the string pointed to by s2, both interpreted as
appropriate to the LC_COLLATE category of the current locale, [CX]
or of the locale represented by locale,   respectively.
The strcoll() [CX]   and strcoll_l()
functions shall not change the setting of errno if successful.
Since no return value is reserved to indicate an error, an application wishing to check for error situations should set
errno to 0, then call strcoll(), [CX]   or strcoll_l()   then check errno.
[CX]  The
behavior is undefined if the locale argument to strcoll_l() is the special locale object LC_GLOBAL_LOCALE or is not a
valid locale object handle.
RETURN VALUE
Upon successful completion, strcoll() shall return an integer greater than, equal to, or less than 0, according to
whether the string pointed to by s1 is greater than, equal to, or less than the string pointed to by s2 when both are
interpreted as appropriate to the current locale. [CX]   On error, strcoll() may set errno, but no return
value is reserved to indicate an error.
Upon successful completion, strcoll_l() shall return an integer greater than, equal to, or less than 0, according to
whether the string pointed to by s1 is greater than, equal to, or less than the string pointed to by s2 when both are
interpreted as appropriate to the locale represented by locale. On error, strcoll_l() may set errno, but no
return value is reserved to indicate an error.
ERRORS
These functions may fail if:
[EINVAL]
[CX]
The s1 or s2 arguments contain characters outside the domain of the collating sequence.
The following sections are informative.
EXAMPLES
Comparing Nodes
The following example uses an application-defined function, node_compare(), to compare two nodes based on an alphabetical
ordering of the string field.
#include
...
struct node { /* These are stored in the table. */
char *string;
int length;
};
...
int node_compare(const void *node1, const void *node2)
{
return strcoll(((const struct node *)node1)->string,
((const struct node *)node2)->string);
}
...
APPLICATION USAGE
The strxfrm() and strcmp()
functions should be used for sorting large lists.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
alphasort(), strcmp(),
strxfrm()
XBD
CHANGE HISTORY
First released in Issue 3.
Issue 5
The DESCRIPTION is updated to indicate that errno does not change if the function is successful.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The [EINVAL] optional error condition is added.
An example is added.
Issue 7
The strcoll_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0593 [283] and XSH/TC1-2008/0594 [283] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fmaxl.html =====
fmax
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fmax, fmaxf, fmaxl — determine maximum numeric value of two floating-point numbers
SYNOPSIS
#include
double fmax(double x, double y);
float fmaxf(float x, float y);
long double fmaxl(long double x, long double y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall determine the maximum numeric value of their arguments. [MX]   NaN arguments
shall be treated as missing data: if one argument is a NaN and the other numeric, then these functions shall choose the numeric
value.
RETURN VALUE
Upon successful completion, these functions shall return the maximum numeric value of their arguments.
[MX]  The
returned value shall be exact and shall be independent of the current rounding direction mode.
If just one argument is a NaN, the other argument shall be returned.
If x and y are NaN, a NaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
fdim(), fmin()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
Austin Group Interpretation 1003.1-2001 #007 is applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/dup.html =====
dup
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
dup, dup2, dup3 — duplicate an open file descriptor
SYNOPSIS
#include
int dup(int fildes);
int dup2(int fildes, int fildes2);
int dup3(int fildes, int fildes2, int flag);
DESCRIPTION
The dup() function provides an alternative interface to the service provided by fcntl() using the F_DUPFD command. The call dup(fildes) shall be equivalent
to:
fcntl(fildes, F_DUPFD, 0);
The dup2() function shall cause the file descriptor fildes2 to refer to the same open file description as the file
descriptor fildes and to share any locks, and shall return fildes2. If fildes2 is already a valid open file
descriptor, it shall be closed first, unless fildes is equal to fildes2 in which case dup2() shall return
fildes2 without closing it. If the close operation fails to close fildes2, dup2() shall return -1 without
changing the open file description to which fildes2 refers. If fildes is not a valid file descriptor, dup2()
shall return -1 and shall not close fildes2. If fildes2 is less than 0 or greater than or equal to {OPEN_MAX},
dup2() shall return -1 with errno set to [EBADF].
Upon successful completion, if fildes is not equal to fildes2, the FD_CLOEXEC and FD_CLOFORK flags associated with
fildes2 shall be cleared. If fildes is equal to fildes2, the FD_CLOEXEC and FD_CLOFORK flags associated with
fildes2 shall not be changed.
The dup3() function shall be equivalent to the dup2() function, except that it shall be an error if fildes
is equal to fildes2, and the state of FD_CLOEXEC and FD_CLOFORK on the fildes2 file descriptor shall be determined
solely by the flag argument, which can be constructed from a bitwise-inclusive OR of flags from the following list:
O_CLOEXEC
Atomically set the FD_CLOEXEC flag on fildes2.
O_CLOFORK
Atomically set the FD_CLOFORK flag on fildes2.
[TYM]
If fildes refers to a typed memory object, the result of the dup2() or dup3() functions is unspecified.
RETURN VALUE
Upon successful completion a non-negative integer, namely the file descriptor, shall be returned; otherwise, -1 shall be
returned and errno set to indicate the error.
ERRORS
The dup() function shall fail if:
[EBADF]
The fildes argument is not a valid open file descriptor.
[EMFILE]
All file descriptors available to the process are currently open.
The dup2() and dup3() functions shall fail if:
[EBADF]
The fildes argument is not a valid open file descriptor or the argument fildes2 is negative or greater than or
equal to {OPEN_MAX}.
[EINTR]
The function was interrupted by a signal.
The dup3() function shall fail if:
[EINVAL]
The fildes and fildes2 arguments are equal.
The dup2() and dup3() functions may fail if:
[EIO]
An I/O error occurred while attempting to close fildes2.
The dup3() function may fail if:
[EINVAL]
The value of the flag argument is invalid.
The following sections are informative.
EXAMPLES
Redirecting Standard Output to a File
The following example closes standard output for the current processes, re-assigns standard output to go to the file referenced
by pfd, and closes the original file descriptor to clean up.
#include
...
int pfd;
...
close(1);
dup(pfd);
close(pfd);
...
Redirecting Error Messages
The following example redirects messages from stderr to stdout.
#include
...
dup2(1, 2);
...
APPLICATION USAGE
Implementations may use file descriptors that must be inherited into child processes for the child process to remain conforming,
such as for message catalog or tracing purposes. Therefore, an application that calls dup2() with an arbitrary integer for
fildes2 risks non-conforming behavior, and dup2() can only portably be used to overwrite file descriptor values that
the application has obtained through explicit actions, or for the three file descriptors corresponding to the standard file
streams. In order to avoid a race condition of leaking an unintended file descriptor into a child process or executed program, an
application should consider opening all file descriptors with the FD_CLOFORK or FD_CLOEXEC flag, or both flags, set unless the file
descriptor is intended to be inherited by child processes or executed programs, respectively.
RATIONALE
The dup() function is redundant. Its services are also provided by the fcntl() function. It has been included in this volume of POSIX.1-2024 primarily for historical
reasons, since many existing applications use it. On the other hand, the dup2() function provides unique services, as no
other interface is able to atomically replace an existing file descriptor.
The dup2() function is not marked obsolescent because it presents a type-safe version of functionality provided in a
type-unsafe version by fcntl(). It is used in the POSIX Ada binding.
The dup2() function is not intended for use in critical regions as a synchronization mechanism.
In the description of [EBADF], the case of fildes being out of range is covered by the given case of fildes not
being valid. The descriptions for fildes and fildes2 are different because the only kind of invalidity that is
relevant for fildes2 is whether it is out of range; that is, it does not matter whether fildes2 refers to an open
file when the dup2() call is made.
The dup3() function with the O_CLOEXEC and O_CLOFORK flags is necessary to avoid a data race in multi-threaded
applications. Without O_CLOFORK, a file descriptor is leaked into a child process created by one thread in the window between
another thread creating a file descriptor with dup2() and then using fcntl() to
set the FD_CLOFORK flag. Without O_CLOEXEC, a file descriptor intentionally inherited by child processes is similarly leaked into
an executed program if FD_CLOEXEC is not set atomically. The safe counterpart for avoiding the same race with dup() is the
use of the F_DUPFD_CLOFORK or F_DUPFD_CLOEXEC action of the fcntl() function.
FUTURE DIRECTIONS
None.
SEE ALSO
close(), fcntl(), open()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 7
SD5-XSH-ERN-187 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0075 [149,428] and XSH/TC1-2008/0076 [149] are applied.
Issue 8
Austin Group Defects 411, 1318, 1483, and 1577 are applied, adding dup3() and FD_CLOFORK.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/posix_spawnattr_getsigdefault.html =====
posix_spawnattr_getsigdefault
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
posix_spawnattr_getsigdefault, posix_spawnattr_setsigdefault — get and set the spawn-sigdefault attribute of a spawn
attributes object (ADVANCED REALTIME)
SYNOPSIS
[SPN]  #include
#include
int posix_spawnattr_getsigdefault(const posix_spawnattr_t
*restrict attr, sigset_t *restrict sigdefault);
int posix_spawnattr_setsigdefault(posix_spawnattr_t *restrict attr,
const sigset_t *restrict sigdefault);
DESCRIPTION
The posix_spawnattr_getsigdefault() function shall obtain the value of the spawn-sigdefault attribute from the
attributes object referenced by attr.
The posix_spawnattr_setsigdefault() function shall set the spawn-sigdefault attribute in an initialized attributes
object referenced by attr.
The spawn-sigdefault attribute represents the set of signals to be forced to default signal handling in the new process
image (if POSIX_SPAWN_SETSIGDEF is set in the spawn-flags attribute) by a spawn operation. The default value of this
attribute shall be an empty signal set.
RETURN VALUE
Upon successful completion, posix_spawnattr_getsigdefault() shall return zero and store the value of the
spawn-sigdefault attribute of attr into the object referenced by the sigdefault parameter; otherwise, an error
number shall be returned to indicate the error.
Upon successful completion, posix_spawnattr_setsigdefault() shall return zero; otherwise, an error number shall be
returned to indicate the error.
ERRORS
These functions may fail if:
[EINVAL]
The value specified by attr is invalid.
The posix_spawnattr_setsigdefault() function may fail if:
[EINVAL]
The value of the attribute being set is not valid.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
These functions are part of the Spawn option and need not be provided on all implementations.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
posix_spawn(), posix_spawnattr_destroy(), posix_spawnattr_getflags(), posix_spawnattr_getpgroup(), posix_spawnattr_getschedparam(), posix_spawnattr_getschedpolicy(), posix_spawnattr_getsigmask()
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1d-1999.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atomic_is_lock_free.html =====
atomic_is_lock_free
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atomic_is_lock_free — indicate whether or not atomic operations are lock-free
SYNOPSIS
#include
_Bool atomic_is_lock_free(const volatile A *obj);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
Implementations that define the macro __STDC_NO_ATOMICS__ need not provide the  header nor support these generic functions.
The atomic_is_lock_free() generic function shall indicate whether or not atomic operations on objects of the type pointed
to by obj are lock-free; obj can be a null pointer.
RETURN VALUE
The atomic_is_lock_free() generic function shall return a non-zero value if and only if atomic operations on objects of
the type pointed to by obj are lock-free. During the lifetime of the calling process, the result of the lock-free query
shall be consistent for all pointers of the same type.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
Operations that are lock-free should also be address-free. That is, atomic operations on the same memory location via two
different addresses will communicate atomically. The implementation should not depend on any per-process state. This restriction
enables communication via memory mapped into a process more than once and memory shared between two processes.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/regfree.html =====
regcomp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
regcomp, regerror, regexec, regfree — regular expression matching
SYNOPSIS
#include
int regcomp(regex_t *restrict preg, const char *restrict pattern,
int cflags);
size_t regerror(int errcode, const regex_t *restrict preg,
char *restrict errbuf, size_t errbuf_size);
int regexec(const regex_t *restrict preg, const char *restrict string,
size_t nmatch, regmatch_t pmatch[restrict], int
eflags);
void regfree(regex_t *preg);
DESCRIPTION
These functions interpret basic and extended regular expressions as described in XBD 9. Regular Expressions.
The regex_t structure is defined in  and contains at least
the following member:
Member Type
Member Name
Description
size_t
re_nsub
Number of parenthesized subexpressions.
The regmatch_t structure is defined in  and
contains at least the following members:
Member Type
Member Name
Description
regoff_t
rm_so
Byte offset from start of string to start of substring.
regoff_t
rm_eo
Byte offset from start of string of the first character after the end of substring.
The regcomp() function shall compile the regular expression contained in the string pointed to by the
pattern argument and place the results in the structure pointed to by preg. The cflags argument is the
bitwise-inclusive OR of zero or more of the following flags, which are defined in the  header:
REG_EXTENDED
Use Extended Regular Expressions.
REG_ICASE
Perform matching in a case-insensitive manner (see XBD 9.2 Regular Expression
General Requirements).
REG_MINIMAL
Change the matching behavior for duplication symbols to the leftmost shortest possible match, and invert the behavior of the
repetition modifier '?' () to match the longest possible match instead of the shortest. Only
applicable to REG_EXTENDED regular expressions.
REG_NOSUB
Report only success/fail in regexec().
REG_NEWLINE
Change the handling of  characters, as described in the text.
The default regular expression type for pattern is a Basic Regular Expression. The application can specify
Extended Regular Expressions using the REG_EXTENDED cflags flag.
If the REG_NOSUB flag was not set in cflags, then regcomp() shall set re_nsub to the number of
parenthesized subexpressions (delimited by "\(\)" in basic regular expressions or "()" in extended regular
expressions) found in pattern.
The regexec() function compares the null-terminated string specified by string with the compiled
regular expression preg initialized by a previous call to regcomp(). If it finds a match, regexec() shall
return 0; otherwise, it shall return non-zero indicating either no match or an error. The eflags argument is the
bitwise-inclusive OR of zero or more of the following flags, which are defined in the  header:
REG_NOTBOL
The first character of the string pointed to by string is not the beginning of the line. Therefore, the
character ('^'), when taken as a special character, shall not match the beginning of
string.
REG_NOTEOL
The last character of the string pointed to by string is not the end of the line. Therefore, the
('$'), when taken as a special character, shall not match the end of string.
If nmatch is 0 or REG_NOSUB was set in the cflags argument to regcomp(), then regexec()
shall ignore the pmatch argument. Otherwise, the application shall ensure that the pmatch argument points to an array
with at least nmatch elements, and regexec() shall fill in the elements of that array with offsets of the substrings
of string that correspond to the parenthesized subexpressions of pattern: pmatch[i].rm_so shall
be the byte offset of the beginning and pmatch[i].rm_eo shall be one greater than the byte offset of the end
of substring i. (Subexpression i begins at the ith matched open parenthesis, counting from 1.) Offsets in
pmatch[0] identify the substring that corresponds to the entire regular expression. Unused elements of pmatch up to
pmatch[nmatch-1] shall be filled with -1. If there are more than nmatch subexpressions in pattern
(pattern itself counts as a subexpression), then regexec() shall still do the match, but shall record only the first
nmatch substrings.
When matching a basic or extended regular expression, any given parenthesized subexpression of pattern might
participate in the match of several different substrings of string, or it might not match any substring even though the
pattern as a whole did match. The following rules shall be used to determine which substrings to report in pmatch when
matching regular expressions:
If subexpression i in a regular expression is not contained within another subexpression, and it
participated in the match several times, then the byte offsets in pmatch[i] shall delimit the last such match.
If subexpression i is not contained within another subexpression, and it did not participate in an
otherwise successful match, the byte offsets in pmatch[i] shall be -1. A subexpression does not participate in the
match when:
'*' or "\{\}" appears immediately after the subexpression in a basic regular expression, or
'*', '?', or "{}" appears immediately after the subexpression in an extended regular expression, and the
subexpression did not match (matched 0 times)
or:
'|' is used in an extended regular expression to select this subexpression or another, and the other
subexpression matched.
If subexpression i is contained within another subexpression j, and i is not contained within
any other subexpression that is contained within j, and a match of subexpression j is reported in
pmatch[j], then the match or non-match of subexpression i reported in pmatch[i] shall be as
described in 1. and 2. above, but within the substring reported in pmatch[j] rather than the whole string. The
offsets in pmatch[i] are still relative to the start of string.
If subexpression i is contained in subexpression j, and the byte offsets in pmatch[j]
are -1, then the pointers in pmatch[i] shall also be -1.
If subexpression i matched a zero-length string, then both byte offsets in pmatch[i] shall be
the byte offset of the character or null terminator immediately following the zero-length string.
If, when regexec() is called, the locale is different from when the regular expression was compiled, the
result is undefined.
If REG_NEWLINE is not set in cflags, then a  in pattern or string shall be
treated as an ordinary character. If REG_NEWLINE is set, then  shall be treated as an ordinary character except as
follows:
A  in string shall not be matched by a  outside a bracket expression or by any
form of a non-matching list (see XBD 9. Regular Expressions).
A  ('^') in pattern, when used to specify expression anchoring (see XBD 9.3.8 BRE Expression Anchoring), shall match the zero-length string
immediately after a  in string, regardless of the setting of REG_NOTBOL.
A  ('$') in pattern, when used to specify expression anchoring, shall match the
zero-length string immediately before a  in string, regardless of the setting of REG_NOTEOL.
The regfree() function shall free any memory allocated by regcomp() associated with preg. The
regfree() function shall not modify errno if preg was previously returned by regcomp() and not yet
freed.
The following constants are defined as the minimum set of error return values, although other errors listed as
implementation extensions in  are possible:
REG_BADBR
Content of "\{\}" invalid: not a number, number too large, more than two numbers, first larger than second.
REG_BADPAT
Invalid regular expression.
REG_BADRPT
'?', '*', or '+' not preceded by valid regular expression.
REG_EBRACE
"\{\}" imbalance.
REG_EBRACK
"[]" imbalance.
REG_ECOLLATE
Invalid collating element referenced.
REG_ECTYPE
Invalid character class type referenced.
REG_EESCAPE
Trailing  character in pattern.
REG_EPAREN
"\(\)" or "()" imbalance.
REG_ERANGE
Invalid endpoint in range expression.
REG_ESPACE
Out of memory.
REG_ESUBREG
Number in "\digit" invalid or in error.
REG_NOMATCH
regexec() failed to match.
If more than one error occurs in processing a function call, any one of the possible constants may be returned, as
the order of detection is unspecified.
The regerror() function provides a mapping from error codes returned by regcomp() and
regexec() to unspecified printable strings. It generates a string corresponding to the value of the errcode argument,
which the application shall ensure is the last non-zero value returned by regcomp() or regexec() with the given value
of preg. If errcode is not such a value, the content of the generated string is unspecified.
If preg is a null pointer, but errcode is a value returned by a previous call to regexec() or
regcomp(), the regerror() still generates an error string corresponding to the value of errcode, but it might
not be as detailed under some implementations.
If the errbuf_size argument is not 0, regerror() shall place the generated string into the buffer of
size errbuf_size bytes pointed to by errbuf. If the string (including the terminating null) cannot fit in the buffer,
regerror() shall truncate the string and null-terminate the result.
If errbuf_size is 0, regerror() shall ignore the errbuf argument, and return the size of the
buffer needed to hold the generated string.
If the preg argument to regexec() or regfree() is not a compiled regular expression returned
by regcomp(), the result is undefined. A preg is no longer treated as a compiled regular expression after it is given
to regfree().
RETURN VALUE
Upon successful completion, the regcomp() function shall return 0. Otherwise, it shall return an integer value indicating
an error as described in , and the content of preg is
undefined. If a code is returned, the interpretation shall be as given in .
If regcomp() detects an invalid RE, it may return REG_BADPAT, or it may return one of the error codes that
more precisely describes the error.
Upon successful completion, the regexec() function shall return 0. Otherwise, it shall return REG_NOMATCH to
indicate no match.
Upon successful completion, the regerror() function shall return the number of bytes needed to hold the
entire generated string, including the null termination. If the return value is greater than errbuf_size, the string
returned in the buffer pointed to by errbuf has been truncated.
The regfree() function shall not return a value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
#include
/*
* Match string against the extended regular expression in
* pattern, treating errors as no match.
*
* Return 1 for match, 0 for no match.
*/
int
match(const char *string, char *pattern)
{
int    status;
regex_t    re;
if (regcomp(&re, pattern, REG_EXTENDED|REG_NOSUB) != 0) {
return(0);      /* Report error. */
}
status = regexec(&re, string, (size_t) 0, NULL, 0);
regfree(&re);
if (status != 0) {
return(0);      /* Report error. */
}
return(1);
}
The following demonstrates how the REG_NOTBOL flag could be used with regexec() to find all substrings in a
line that match a pattern supplied by a user. (For simplicity of the example, very little error checking is done.)
(void) regcomp (&re, pattern, 0);
/* This call to regexec() finds the first match on the line. */
error = regexec (&re, &buffer[0], 1, &pm, 0);
while (error == 0) {  /* While matches found. */
/* Substring found between pm.rm_so and pm.rm_eo. */
/* This call to regexec() finds the next match. */
error = regexec (&re, buffer + pm.rm_eo, 1, &pm, REG_NOTBOL);
}
APPLICATION USAGE
An application could use:
regerror(code,preg,(char *)NULL,(size_t)0)
to find out how big a buffer is needed for the generated string, malloc() a buffer to hold the string, and then call regerror() again to get the
string. Alternatively, it could allocate a fixed, static buffer that is big enough to hold most strings, and then use malloc() to allocate a larger buffer if it finds that this is too small.
To match a pattern as described in XCU 2.14 Pattern Matching
Notation, use the fnmatch() function.
RATIONALE
The regexec() function must fill in all nmatch elements of pmatch, where nmatch and pmatch
are supplied by the application, even if some elements of pmatch do not correspond to subexpressions in pattern. The
application developer should note that there is probably no reason for using a value of nmatch that is larger than
preg->re_nsub+1.
The REG_NEWLINE flag supports a use of RE matching that is needed in some applications like text editors. In such
applications, the user supplies an RE asking the application to find a line that matches the given expression. An anchor in such an
RE anchors at the beginning or end of any line. Such an application can pass a sequence of -separated lines to
regexec() as a single long string and specify REG_NEWLINE to regcomp() to get the desired behavior. The application
must ensure that there are no explicit  characters in pattern if it wants to ensure that any match occurs
entirely within a single line.
The REG_NEWLINE flag affects the behavior of regexec(), but it is in the cflags parameter to
regcomp() to allow flexibility of implementation. Some implementations will want to generate the same compiled RE in
regcomp() regardless of the setting of REG_NEWLINE and have regexec() handle anchors differently based on the setting
of the flag. Other implementations will generate different compiled REs based on the REG_NEWLINE.
The REG_ICASE flag supports the operations taken by the grep -i
option and the historical implementations of ex and vi. Including this flag will make it easier for application code to be written that does the same
thing as these utilities.
The substrings reported in pmatch[] are defined using offsets from the start of the string rather than
pointers. This allows type-safe access to both constant and non-constant strings.
The type regoff_t is used for the elements of pmatch[] to ensure that the application can represent
large arrays in memory (important for an application conforming to the Shell and Utilities volume of POSIX.1-2024).
The 1992 edition of this standard required regoff_t to be at least as wide as off_t, to facilitate
future extensions in which the string to be searched is taken from a file. However, these future extensions have not appeared. The
requirement rules out popular implementations with 32-bit regoff_t and 64-bit off_t, so it has been removed.
The standard developers rejected the inclusion of a regsub() function that would be used to do substitutions
for a matched RE. While such a routine would be useful to some applications, its utility would be much more limited than the
matching function described here. Both RE parsing and substitution are possible to implement without support other than that
required by the ISO C standard, but matching is much more complex than substituting. The only difficult part of substitution,
given the information supplied by regexec(), is finding the next character in a string when there can be multi-byte
characters. That is a much larger issue, and one that needs a more general solution.
The errno variable has not been used for error returns to avoid filling the errno name space for this
feature.
The interface is defined so that the matched substrings rm_sp and rm_ep are in a separate
regmatch_t structure instead of in regex_t. This allows a single compiled RE to be used simultaneously in several
contexts; in main() and a signal handler, perhaps, or in multiple threads of lightweight processes. (The preg
argument to regexec() is declared with type const, so the implementation is not permitted to use the structure to
store intermediate results.) It also allows an application to request an arbitrary number of substrings from an RE. The number of
subexpressions in the RE is reported in re_nsub in preg. With this change to regexec(), consideration was
given to dropping the REG_NOSUB flag since the user can now specify this with a zero nmatch argument to regexec().
However, keeping REG_NOSUB allows an implementation to use a different (perhaps more efficient) algorithm if it knows in
regcomp() that no subexpressions need be reported. The implementation is only required to fill in pmatch if
nmatch is not zero and if REG_NOSUB is not specified. Note that the size_t type, as defined in the ISO C
standard, is unsigned, so the description of regexec() does not need to address negative values of nmatch.
REG_NOTBOL was added to allow an application to do repeated searches for the same pattern in a line. If the pattern
contains a  character that should match the beginning of a line, then the pattern should only match when matched
against the beginning of the line. Without the REG_NOTBOL flag, the application could rewrite the expression for subsequent
matches, but in the general case this would require parsing the expression. The need for REG_NOTEOL is not as clear; it was added
for symmetry.
The addition of the regerror() function addresses the historical need for conforming application programs to
have access to error information more than "Function failed to compile/match your RE for unknown reasons".
This interface provides for two different methods of dealing with error conditions. The specific error codes
(REG_EBRACE, for example), defined in , allow an application to
recover from an error if it is so able. Many applications, especially those that use patterns supplied by a user, will not try to
deal with specific error cases, but will just use regerror() to obtain a human-readable error message to present to the
user.
The regerror() function uses a scheme similar to confstr() to
deal with the problem of allocating memory to hold the generated string. The scheme used by strerror() in the ISO C standard was considered unacceptable since it creates
difficulties for multi-threaded applications.
The preg argument is provided to regerror() to allow an implementation to generate a more descriptive
message than would be possible with errcode alone. An implementation might, for example, save the character offset of the
offending character of the pattern in a field of preg, and then include that in the generated message string. The
implementation may also ignore preg.
A REG_FILENAME flag was considered, but omitted. This flag caused regexec() to match patterns as described
in XCU 2.14 Pattern Matching Notation instead of REs. This service is
now provided by the fnmatch() function.
Notice that there is a difference in philosophy between the ISO POSIX-2:1993 standard and POSIX.1-2024 in how
to handle a "bad" regular expression. The ISO POSIX-2:1993 standard says that many bad constructs "produce undefined
results", or that "the interpretation is undefined". POSIX.1-2024, however, says that the interpretation of such REs is
unspecified. The term "undefined" means that the action by the application is an error, of similar severity to passing a bad
pointer to a function.
The regcomp() and regexec() functions are required to accept any null-terminated string as the
pattern argument. If the meaning of the string is "undefined", the behavior of the function is "unspecified".
POSIX.1-2024 does not specify how the functions will interpret the pattern; they might return error codes, or they might do pattern
matching in some completely unexpected way, but they should not do something like abort the process.
FUTURE DIRECTIONS
None.
SEE ALSO
fnmatch(), glob()
XBD 9. Regular Expressions, ,
XCU 2.14 Pattern Matching Notation
CHANGE HISTORY
First released in Issue 4. Derived from the ISO POSIX-2 standard.
Issue 5
Moved from POSIX2 C-language Binding to BASE.
Issue 6
In the SYNOPSIS, the optional include of the  header is
removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX
Specification:
The requirement to include  has been removed.
Although  was required for conforming implementations of
previous POSIX specifications, it was not required for UNIX applications.
The normative text is updated to avoid use of the term "must" for application requirements.
The REG_ENOSYS constant is removed.
The restrict keyword is added to the regcomp(), regerror(), and regexec() prototypes
for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
Austin Group Interpretation 1003.1-2001 #134 is applied, clarifying that if more than one error occurs in processing a function
call, any one of the possible constants may be returned.
SD5-XBD-ERN-60 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0505 [305] is applied.
Issue 8
Austin Group Defect 385 is applied, adding a requirement that regfree() does not modify errno when passed a
pointer to a regex_t that can be freed.
Austin Group Defects 793 and 1329 are applied, adding REG_MINIMAL.
Austin Group Defect 1031 is applied, changing the description of REG_ICASE.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/aio_write.html =====
aio_write
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
aio_write — asynchronous write to a file
SYNOPSIS
#include
int aio_write(struct aiocb *aiocbp);
DESCRIPTION
The aio_write() function shall write aiocbp->aio_nbytes to the file associated with
aiocbp->aio_fildes from the buffer pointed to by aiocbp->aio_buf. The function shall return when
the write request has been initiated or, at a minimum, queued to the file or device.
[PIO]
If prioritized I/O is supported for this file, then the asynchronous operation shall be submitted at a priority equal to a base
scheduling priority minus aiocbp->aio_reqprio. If Thread Execution Scheduling is not supported, then the base
scheduling priority is that of the calling process;
[PIO
TPS]  otherwise, the base scheduling priority is that
of the calling thread.
The aiocbp argument may be used as an argument to aio_error() and
aio_return() in order to determine the error status and return status,
respectively, of the asynchronous operation while it is proceeding.
The aiocbp argument points to an aiocb structure. If the buffer pointed to by aiocbp->aio_buf or
the control block pointed to by aiocbp becomes an illegal address prior to asynchronous I/O completion, then the behavior is
undefined.
If O_APPEND is not set for the file descriptor aio_fildes, then the requested operation shall take place at the absolute
position in the file as given by aio_offset, as if lseek() were called
immediately prior to the operation with an offset equal to aio_offset and a whence equal to SEEK_SET. If
O_APPEND is set for the file descriptor, or if aio_fildes is associated with a device that is incapable of seeking, write
operations append to the file in the same order as the calls were made, except under circumstances described in 2.8.2 Asynchronous I/O. After a successful call to enqueue an asynchronous
I/O operation, the value of the file offset for the file is unspecified.
The aio_sigevent member specifies the notification which occurs when the request is completed.
The aiocbp->aio_lio_opcode field shall be ignored by aio_write().
Simultaneous asynchronous operations using the same aiocbp produce undefined results.
[SIO]
If synchronized I/O is enabled on the file associated with aiocbp->aio_fildes, the behavior of this function shall
be according to the definitions of synchronized I/O data integrity completion, and synchronized I/O file integrity completion.
For any system action that changes the process memory space while an asynchronous I/O is outstanding to the address range being
changed, the result of that action is undefined.
For regular files, no data transfer shall occur past the offset maximum established in the open file description associated with
aiocbp->aio_fildes.
If the request would cause the file size to exceed the soft file size limit for the process and there is no room for any bytes
to be written, the request shall fail [XSI]   and the implementation shall generate a SIGXFSZ signal for the thread.
RETURN VALUE
The aio_write() function shall return the value zero if the I/O operation is successfully queued; otherwise, the function
shall return the value -1 and set errno to indicate the error.
ERRORS
The aio_write() function shall fail if:
[EAGAIN]
The requested asynchronous I/O operation was not queued due to system resource limitations.
Each of the following conditions may be detected synchronously at the time of the call to aio_write(), or asynchronously.
If any of the conditions below are detected synchronously, the aio_write() function shall return -1 and set errno to
the corresponding value. If any of the conditions below are detected asynchronously, the return status of the asynchronous
operation shall be set to -1, and the error status of the asynchronous operation is set to the corresponding value.
[EBADF]
The aiocbp->aio_fildes argument is not a valid file descriptor open for writing.
[EINVAL]
The file offset value implied by aiocbp->aio_offset would be invalid,
[PIO]
aiocbp->aio_reqprio is not a valid value,   or
aiocbp->aio_nbytes is an invalid value.
In the case that the aio_write() successfully queues the I/O operation, the return status of the asynchronous operation
shall be one of the values normally returned by the write() function call. If the
operation is successfully queued but is subsequently canceled or encounters an error, the error status for the asynchronous
operation contains one of the values normally set by the write() function call, or one
of the following:
[EBADF]
The aiocbp->aio_fildes argument is not a valid file descriptor open for writing.
[EINVAL]
The file offset value implied by aiocbp->aio_offset would be invalid.
[ECANCELED]
The requested I/O was canceled before the I/O completed due to an explicit aio_cancel() request.
The following condition may be detected synchronously or asynchronously:
[EFBIG]
The file is a regular file, aiobcp->aio_nbytes is greater than 0, and the starting position is greater than or
equal to the offset maximum in the open file description associated with aiocbp->aio_fildes.
[EFBIG]
The file is a regular file, aiobcp->aio_nbytes is greater than 0, and there is no room for any bytes to be
written at the starting position without exceeding the file size limit for the process. [XSI]   A SIGXFSZ
signal shall also be generated for the thread.
[EFBIG]
The file is a regular file, aiobcp->aio_nbytes is greater than 0, and there is no room for any bytes to be
written at the starting position without exceeding the implementation-defined maximum file size.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.8.2 Asynchronous I/O, aio_cancel(), aio_error(), aio_read(), aio_return(), close(), exec, exit(), fork(), lio_listio(), lseek(), write()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Large File Summit extensions are added.
Issue 6
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the
Asynchronous Input and Output option.
The APPLICATION USAGE section is added.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the DESCRIPTION, text is added to indicate that for regular files no data transfer occurs past the offset maximum established
in the open file description associated with aiocbp->aio_fildes.
The [EFBIG] error is added as part of the large file support extensions.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/14 is applied, rewording the DESCRIPTION when prioritized I/O is
supported to account for threads, and removing the words "to the calling process" in the RETURN VALUE section.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/15 is applied, updating the [EINVAL] error, so that detection of
an [EINVAL] error for an invalid value of aiocbp->aio_reqprio is only required if the Prioritized Input and Output
option is supported.
Issue 7
Austin Group Interpretation 1003.1-2001 #082 is applied.
The aio_write() function is moved from the Asynchronous Input and Output option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0028 [317] is applied.
Issue 8
Austin Group Defect 308 is applied, clarifying the handling of [EFBIG] errors.
Austin Group Defect 1669 is applied, removing XSI shading from part of the [EFBIG] error relating to the file size limit for the
process.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/siglongjmp.html =====
siglongjmp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
siglongjmp — non-local goto with signal handling
SYNOPSIS
[CX]  #include
_Noreturn void siglongjmp(sigjmp_buf env, int val);
DESCRIPTION
The siglongjmp() function shall be equivalent to the longjmp() function,
except as follows:
References to setjmp() shall be equivalent to sigsetjmp().
The siglongjmp() function shall restore the saved signal mask if and only if the env argument was initialized by a
call to sigsetjmp() with a non-zero savemask argument.
RETURN VALUE
After siglongjmp() is completed, thread execution shall continue as if the corresponding invocation of sigsetjmp() had just returned the value specified by val. The siglongjmp()
function shall not cause sigsetjmp() to return 0; if val is 0, sigsetjmp() shall return the value 1.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The distinction between setjmp() or longjmp() and sigsetjmp() or
siglongjmp() is only significant for programs which use sigaction(),
sigprocmask(), or sigsuspend().
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
longjmp(), pthread_sigmask(), setjmp(),
sigsetjmp(), sigsuspend()
XBD
CHANGE HISTORY
First released in Issue 3. Included for alignment with the ISO POSIX-1 standard.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Threads Extension.
Issue 6
The DESCRIPTION is rewritten in terms of longjmp().
The SYNOPSIS is marked CX since the presence of this function in the  header is an extension over the ISO C standard.
Issue 8
Austin Group Defect 1302 is applied, adding _Noreturn to the SYNOPSIS.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sem_init.html =====
sem_init
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sem_init — initialize an unnamed semaphore
SYNOPSIS
#include
int sem_init(sem_t *sem, int pshared, unsigned value);
DESCRIPTION
The sem_init() function shall initialize the unnamed semaphore referred to by sem. The value of the initialized
semaphore shall be value. Following a successful call to sem_init(), the semaphore can be used in subsequent calls to
sem_clockwait(), sem_destroy(), sem_post(), sem_timedwait(), sem_trywait(), and
sem_wait(). This semaphore shall remain usable until the semaphore is destroyed. An
unnamed semaphore may be implemented using a file descriptor.
If the pshared argument has a non-zero value, then the semaphore is shared between processes; in this case, any process
that can access the semaphore sem can use sem for performing sem_clockwait(), sem_destroy(),
sem_post(), sem_timedwait(),
sem_trywait(), and sem_wait()
operations.
If the pshared argument is zero, then the semaphore is shared between threads of the process; any thread in this process
can use sem for performing sem_clockwait(), sem_destroy(), sem_post(), sem_timedwait(), sem_trywait(), and
sem_wait() operations.
See 2.9.9 Synchronization Object Copies and Alternative Mappings
for further requirements.
Attempting to initialize an already initialized semaphore results in undefined behavior.
RETURN VALUE
Upon successful completion, the sem_init() function shall initialize the semaphore in sem and return 0. Otherwise,
it shall return -1 and set errno to indicate the error.
ERRORS
The sem_init() function shall fail if:
[EINVAL]
The value argument exceeds {SEM_VALUE_MAX}.
[ENOSPC]
A resource required to initialize the semaphore has been exhausted, or the limit on semaphores ({SEM_NSEMS_MAX}) has been
reached.
[EPERM]
The process lacks appropriate privileges to initialize the semaphore.
The sem_init() function may fail if:
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum allowable number of files is currently open in the system.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
sem_clockwait(), sem_destroy(), sem_post(), sem_trywait()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The sem_init() function is marked as part of the Semaphores option.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Semaphores
option.
The sem_timedwait() function is added to the SEE ALSO section for alignment
with IEEE Std 1003.1d-1999.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/116 is applied, updating the DESCRIPTION to add the sem_timedwait() function for alignment with IEEE Std 1003.1d-1999.
Issue 7
SD5-XSH-ERN-176 is applied.
The sem_init() function is moved from the Semaphores option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0526 [37] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0318 [972] is applied.
Issue 8
Austin Group Defect 368 is applied, adding a statement that an unnamed semaphore may be implemented using a file descriptor and
adding the [EMFILE] and [ENFILE] errors.
Austin Group Defect 1216 is applied, adding sem_clockwait().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mq_unlink.html =====
mq_unlink
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mq_unlink — remove a message queue (REALTIME)
SYNOPSIS
[MSG]  #include
int mq_unlink(const char *name);
DESCRIPTION
The mq_unlink() function shall remove the message queue named by the string name. If one or more processes have the
message queue open when mq_unlink() is called, destruction of the message queue shall be postponed until all references to
the message queue have been closed. However, the mq_unlink() call need not block until all references have been closed; it
may return immediately.
After a successful call to mq_unlink(), reuse of the name shall subsequently cause mq_open() to behave as if no message queue of this name exists (that is, mq_open() shall fail if O_CREAT is not set, or shall create a new message queue if O_CREAT
is set).
RETURN VALUE
Upon successful completion, the function shall return a value of zero. Otherwise, the named message queue shall be unchanged by
this function call, and the function shall return a value of -1 and set errno to indicate the error.
ERRORS
The mq_unlink() function shall fail if:
[EACCES]
Permission is denied to unlink the named message queue.
[EINTR]
The call to mq_unlink() blocked waiting for all references to the named message queue to be closed and a signal
interrupted the call.
[ENOENT]
The named message queue does not exist.
The mq_unlink() function may fail if:
[ENAMETOOLONG]
The length of the name argument exceeds {_POSIX_PATH_MAX} on systems that do not support the XSI option [XSI]   or exceeds
{_XOPEN_PATH_MAX} on XSI systems,   or has a pathname component
that is longer than {_POSIX_NAME_MAX} on systems that do not support the XSI option [XSI]   or longer
than {_XOPEN_NAME_MAX} on XSI systems.   A call to
mq_unlink() with a name argument that contains the same message queue name as was previously used in a successful
mq_open() call shall not give an [ENAMETOOLONG] error.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
A future version might require the mq_open() and mq_unlink() functions to
have semantics similar to normal file system operations.
SEE ALSO
mq_close(), mq_open(),
msgctl(), msgget(), msgrcv(), msgsnd()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The mq_unlink() function is marked as part of the Message Passing option.
The Open Group Corrigendum U021/5 is applied, clarifying that upon unsuccessful completion, the named message queue is unchanged
by this function.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Message
Passing option.
Issue 7
Austin Group Interpretation 1003.1-2001 #077 is applied, changing [ENAMETOOLONG] from a "shall fail" to a "may fail" error
.
Austin Group Interpretation 1003.1-2001 #141 is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0230 [504] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atoll.html =====
atol
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atol, atoll — convert a string to a long integer
SYNOPSIS
#include
long atol(const char *nptr);
long long atoll(const char *nptr);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
Except as noted below, the call atol(nptr) shall be equivalent to:
strtol(nptr, (char **)NULL, 10)
Except as noted below, the call to atoll(nptr) shall be equivalent to:
strtoll(nptr, (char **)NULL, 10)
The handling of errors may differ. If the value cannot be represented, the behavior is undefined.
RETURN VALUE
These functions shall return the converted value if the value can be represented.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
If the number is not known to be in range, strtol() or strtoll() should be used because atol() and atoll() are not required to
perform any error checking.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
strtol()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The atoll() function is added for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
SD5-XSH-ERN-61 is applied, correcting the DESCRIPTION of atoll().
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0046 [892] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fegetround.html =====
fegetround
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fegetround, fesetround — get and set current rounding direction
SYNOPSIS
#include
int fegetround(void);
int fesetround(int round);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The fegetround() function shall get the current rounding direction.
The fesetround() function shall establish the rounding direction represented by its argument round. If the
argument is not equal to the value of a rounding direction macro, the rounding direction is not changed.
RETURN VALUE
The fegetround() function shall return the value of the rounding direction macro representing the current rounding
direction or a negative value if there is no such rounding direction macro or the current rounding direction is not
determinable.
The fesetround() function shall return a zero value if and only if the requested rounding direction was established.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
The following example saves, sets, and restores the rounding direction, reporting an error and aborting if setting the rounding
direction fails:
#include
#include
void f(int round_dir)
{
#pragma STDC FENV_ACCESS ON
int save_round;
int setround_ok;
save_round = fegetround();
setround_ok = fesetround(round_dir);
assert(setround_ok == 0);
/* ... */
fesetround(save_round);
/* ... */
}
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
ISO/IEC 9899:1999 standard, Technical Corrigendum 1 is incorporated.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sigsuspend.html =====
sigsuspend
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sigsuspend — wait for a signal
SYNOPSIS
[CX]  #include
int sigsuspend(const sigset_t *sigmask);
DESCRIPTION
The sigsuspend() function shall atomically both replace the current signal mask of the calling thread with the set of
signals pointed to by sigmask and suspend the thread until delivery of a signal whose action is either to execute a
signal-catching function or to terminate the process. This shall not cause any other signals that may have been pending on the
process to become pending on the thread.
If the action is to terminate the process then sigsuspend() shall never return. If the action is to execute a
signal-catching function, then sigsuspend() shall return after the signal-catching function returns, with the signal mask
restored to the set that existed prior to the sigsuspend() call.
It is not possible to block signals that cannot be ignored. This is enforced by the system without causing an error to be
indicated.
RETURN VALUE
Since sigsuspend() suspends thread execution indefinitely, there is no successful completion return value. If a return
occurs, -1 shall be returned and errno set to indicate the error.
ERRORS
The sigsuspend() function shall fail if:
[EINTR]
A signal is caught by the calling process and control is returned from the signal-catching function.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Normally, at the beginning of a critical code section, a specified set of signals is blocked using the sigprocmask() function. When the thread has completed the critical section and needs to
wait for the previously blocked signal(s), it pauses by calling sigsuspend() with the mask that was returned by the sigprocmask() call.
RATIONALE
Code which wants to avoid the ambiguity of the signal mask for thread cancellation handlers can install an additional
cancellation handler which resets the signal mask to the expected value.
void cleanup(void *arg)
{
sigset_t *ss = (sigset_t *) arg;
pthread_sigmask(SIG_SETMASK, ss, NULL);
}
int call_sigsuspend(const sigset_t *mask)
{
sigset_t oldmask;
int result;
pthread_sigmask(SIG_SETMASK, NULL, &oldmask);
pthread_cleanup_push(cleanup, &oldmask);
result = sigsuspend(mask);
pthread_cleanup_pop(0);
return result;
}
FUTURE DIRECTIONS
None.
SEE ALSO
2.4 Signal Concepts, pause(), sigaction(), sigaddset(), sigdelset(), sigemptyset(), sigfillset()
XBD
CHANGE HISTORY
First released in Issue 3. Included for alignment with the POSIX.1-1988 standard.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Threads Extension.
Issue 6
The text in the RETURN VALUE section has been changed from "suspends process execution" to "suspends thread execution". This
reflects IEEE PASC Interpretation 1003.1c #40.
Text in the APPLICATION USAGE section has been replaced.
The SYNOPSIS is marked CX since the presence of this function in the  header is an extension over the ISO C standard.
Issue 7
SD5-XSH-ERN-122 is applied, adding the example code in the RATIONALE.
Issue 8
Austin Group Defect 1201 is applied, clarifying the atomicity requirements for sigsuspend().
Austin Group Defect 1223 is applied, changing the example code in the RATIONALE.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mq_receive.html =====
mq_receive
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mq_receive, mq_timedreceive — receive a message from a message queue (REALTIME)
SYNOPSIS
[MSG]  #include
ssize_t mq_receive(mqd_t mqdes, char *msg_ptr, size_t msg_len,
unsigned *msg_prio);
ssize_t mq_timedreceive(mqd_t mqdes, char *restrict msg_ptr,
size_t msg_len, unsigned *restrict msg_prio,
const struct timespec *restrict abstime);
DESCRIPTION
The mq_receive() function shall receive the oldest of the highest priority message(s) from the message queue specified by
mqdes. If the size of the buffer in bytes, specified by the msg_len argument, is less than the mq_msgsize
attribute of the message queue, the function shall fail and return an error. Otherwise, the selected message shall be removed from
the queue and copied to the buffer pointed to by the msg_ptr argument.
If the value of msg_len is greater than {SSIZE_MAX}, the result is implementation-defined.
If the argument msg_prio is not NULL, the priority of the selected message shall be stored in the location referenced by
msg_prio.
If the specified message queue is empty and O_NONBLOCK is not set in the message queue description associated with mqdes,
mq_receive() shall block until a message is enqueued on the message queue or until mq_receive() is interrupted by a
signal. If more than one thread is waiting to receive a message when a message arrives at an empty queue and the Priority
Scheduling option is supported, then the thread of highest priority that has been waiting the longest shall be selected to receive
the message. Otherwise, it is unspecified which waiting thread receives the message. If the specified message queue is empty and
O_NONBLOCK is set in the message queue description associated with mqdes, no message shall be removed from the queue, and
mq_receive() shall return an error.
The mq_timedreceive() function shall receive the oldest of the highest priority messages from the message queue specified
by mqdes as described for the mq_receive() function. However, if O_NONBLOCK was not specified when the message queue
was opened via the mq_open() function, and no message exists on the queue to satisfy
the receive, the wait for such a message shall be terminated when the specified timeout expires. If O_NONBLOCK is set, this
function is equivalent to mq_receive().
The timeout expires when the absolute time specified by abstime passes, as measured by the clock on which timeouts are
based (that is, when the value of that clock equals or exceeds abstime), or if the absolute time specified by abstime
has already been passed at the time of the call.
The timeout shall be based on the CLOCK_REALTIME clock. The resolution of the timeout shall be the resolution of the clock on
which it is based.
Under no circumstance shall the operation fail with a timeout if a message can be removed from the message queue immediately.
The validity of the abstime parameter need not be checked if a message can be removed from the message queue
immediately.
RETURN VALUE
Upon successful completion, the mq_receive() and mq_timedreceive() functions shall return the length of the
selected message in bytes and the message shall be removed from the queue. Otherwise, no message shall be removed from the queue,
the functions shall return a value of -1, and set errno to indicate the error.
ERRORS
These functions shall fail if:
[EAGAIN]
O_NONBLOCK was set in the message description associated with mqdes, and the specified message queue is empty.
[EBADF]
The mqdes argument is not a valid message queue descriptor open for reading.
[EMSGSIZE]
The specified message buffer size, msg_len, is less than the message size attribute of the message queue.
[EINTR]
The mq_receive() or mq_timedreceive() operation was interrupted by a signal.
[EINVAL]
The process or thread would have blocked, and the abstime parameter specified a nanoseconds field value less than zero
or greater than or equal to 1000 million.
[ETIMEDOUT]
The O_NONBLOCK flag was not set when the message queue was opened, but no message arrived on the queue before the specified
timeout expired.
These functions may fail if:
[EBADMSG]
The implementation has detected a data corruption problem with the message.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
mq_open(), mq_send(), msgctl(), msgget(), msgrcv(), msgsnd(), time()
XBD ,
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The mq_receive() function is marked as part of the Message Passing option.
The Open Group Corrigendum U021/4 is applied. The DESCRIPTION is changed to refer to msg_len rather than
maxsize.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Message
Passing option.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In this function it is possible for the return value to exceed the range of the type ssize_t (since size_t has a
larger range of positive values than ssize_t). A sentence restricting the size of the size_t object is added to the
description to resolve this conflict.
The mq_timedreceive() function is added for alignment with IEEE Std 1003.1d-1999.
The restrict keyword is added to the mq_timedreceive() prototype for alignment with the ISO/IEC 9899:1999
standard.
IEEE PASC Interpretation 1003.1 #109 is applied, correcting the return type for mq_timedreceive() from int to
ssize_t.
Issue 7
The mq_timedreceive() function is moved from the Timeouts option to the Base.
Functionality relating to the Timers option is moved to the Base.
Issue 8
Austin Group Defect 592 is applied, removing text relating to  from
the SYNOPSIS and DESCRIPTION sections.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/floorl.html =====
floor
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
floor, floorf, floorl — floor function
SYNOPSIS
#include
double floor(double x);
float floorf(float x);
long double floorl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the largest integral value not greater than x.
[MX]
These functions may raise the inexact floating-point exception for finite non-integer arguments.
RETURN VALUE
[MX]  The
returned value shall be independent of the current rounding direction mode and shall have the same sign as x.
Upon successful completion, these functions shall return the largest integral value not greater than x, expressed as a
double, float, or long double, as appropriate for the return type of the function.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0 or ±Inf, x shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The integral value returned by these functions might not be expressible as an intmax_t. The return value should be tested
before assigning it to an integer type to avoid the undefined results of an integer overflow.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
ceil(), feclearexcept(),
fetestexcept(), isnan()
4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The floorf() and floorl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0141 [346] is applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/stpcpy.html =====
strcpy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
stpcpy, strcpy — copy a string
SYNOPSIS
#include
[CX]  char *stpcpy(char *restrict s1, const char *restrict s2);
char *strcpy(char *restrict s1, const char *restrict s2);
DESCRIPTION
For strcpy(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The [CX]
stpcpy()   and strcpy() functions shall copy the
string pointed to by s2 (including the terminating NUL character) into the array pointed to by s1.
If copying takes place between objects that overlap, the behavior is undefined.
[CX]  The
strcpy() and stpcpy() functions shall not change the setting of errno on valid input.
RETURN VALUE
[CX]  The
stpcpy() function shall return a pointer to the terminating NUL character copied into the s1 buffer.
The strcpy() function shall return s1.
No return values are reserved to indicate an error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
Construction of a Multi-Part Message in a Single Buffer
#include
#include
int
main (void)
{
char buffer [10];
char *name = buffer;
name = stpcpy (stpcpy (stpcpy (name, "ice"),"-"), "cream");
puts (buffer);
return 0;
}
Initializing a String
The following example copies the string "----------" into the permstring variable.
#include
...
static char permstring[11];
...
strcpy(permstring, "----------");
...
Storing a Key and Data
The following example allocates space for a key using malloc() then uses
strcpy() to place the key there. Then it allocates space for data using malloc(), and uses strcpy() to place data there. (The user-defined function
dbfree() frees memory previously allocated to an array of type struct element *.)
#include
#include
#include
...
/* Structure used to read data and store it. */
struct element {
char *key;
char *data;
};
struct element *tbl, *curtbl;
char *key, *data;
int count;
...
void dbfree(struct element *, int);
...
if ((curtbl->key = malloc(strlen(key) + 1)) == NULL) {
perror("malloc"); dbfree(tbl, count); return NULL;
}
strcpy(curtbl->key, key);
if ((curtbl->data = malloc(strlen(data) + 1)) == NULL) {
perror("malloc"); free(curtbl->key); dbfree(tbl, count); return NULL;
}
strcpy(curtbl->data, data);
...
APPLICATION USAGE
Character movement is performed differently in different implementations. Thus, overlapping moves may yield surprises.
This version is aligned with the ISO C standard; this does not affect compatibility with XPG3 applications. Reliable error
detection by this function was never guaranteed.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
strncpy(), wcscpy()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The strcpy() prototype is updated for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
The stpcpy() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 1.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that strcpy() and stpcpy() do not change the setting of
errno on valid input.
Austin Group Defect 1787 is applied, changing the NAME section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/posix_madvise.html =====
posix_madvise
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
posix_madvise — memory advisory information and alignment control (ADVANCED REALTIME)
SYNOPSIS
[ADV]  #include
int posix_madvise(void *addr, size_t len, int advice);
DESCRIPTION
The posix_madvise() function shall advise the implementation on the expected behavior of the application with respect to
the data in the memory starting at address addr, and continuing for len bytes. The implementation may use this
information to optimize handling of the specified data. The posix_madvise() function shall have no effect on the semantics
of access to memory in the specified range, although it may affect the performance of access.
The implementation may require that addr be a multiple of the page size, which is the value returned by sysconf() when the name value _SC_PAGESIZE is used.
The advice to be applied to the memory range is specified by the advice parameter and may be one of the following
values:
POSIX_MADV_NORMAL
Specifies that the application has no advice to give on its behavior with respect to the specified range. It is the default
characteristic if no advice is given for a range of memory.
POSIX_MADV_SEQUENTIAL
Specifies that the application expects to access the specified range sequentially from lower addresses to higher addresses.
POSIX_MADV_RANDOM
Specifies that the application expects to access the specified range in a random order.
POSIX_MADV_WILLNEED
Specifies that the application expects to access the specified range in the near future.
POSIX_MADV_DONTNEED
Specifies that the application expects that it will not access the specified range in the near future.
These values are defined in the  header.
RETURN VALUE
Upon successful completion, posix_madvise() shall return zero; otherwise, an error number shall be returned to indicate
the error.
ERRORS
The posix_madvise() function shall fail if:
[EINVAL]
The value of advice is invalid.
[ENOMEM]
Addresses in the range starting at addr and continuing for len bytes are partly or completely outside the range
allowed for the address space of the calling process.
The posix_madvise() function may fail if:
[EINVAL]
The value of addr is not a multiple of the value returned by sysconf()
when the name value _SC_PAGESIZE is used.
[EINVAL]
The value of len is zero.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The posix_madvise() function is part of the Advisory Information option and need not be provided on all
implementations.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
mmap(), posix_fadvise(),
sysconf()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1d-1999.
IEEE PASC Interpretation 1003.1 #102 is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/setvbuf.html =====
setvbuf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
setvbuf — assign buffering to a stream
SYNOPSIS
#include
int setvbuf(FILE *restrict stream, char *restrict buf, int type,
size_t size);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The setvbuf() function may be used after the stream pointed to by stream is associated with an open file but
before any other operation (other than an unsuccessful call to setvbuf()) is performed on the stream. The argument
type determines how stream shall be buffered, as follows:
{_IOFBF} shall cause input/output to be fully buffered.
{_IOLBF} shall cause input/output to be line buffered.
{_IONBF} shall cause input/output to be unbuffered.
If buf is not a null pointer, the array it points to may be used instead of a buffer allocated by setvbuf() and
the argument size specifies the size of the array; otherwise, size may determine the size of a buffer allocated by
the setvbuf() function. The contents of the array at any time are unspecified.
For information about streams, see 2.5 Standard I/O Streams.
RETURN VALUE
Upon successful completion, setvbuf() shall return 0. Otherwise, it shall return a non-zero value if an invalid value is
given for type or if the request cannot be honored, [CX]   and may set errno to indicate the error.
ERRORS
The setvbuf() function may fail if:
[EBADF]
[CX]
The stream is not a memory stream and the file descriptor underlying the stream is not valid.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
A common source of error is allocating buffer space as an "automatic" variable in a code block, and then failing to close the
stream in the same block.
With setvbuf(), allocating a buffer of size bytes does not necessarily imply that all of size bytes are
used for the buffer area.
Applications should note that many implementations only provide line buffering on input from terminal devices.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fopen(), setbuf()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
Extensions beyond the ISO C standard are marked.
The setvbuf() prototype is updated for alignment with the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1144 is applied, changing the [EBADF] error condition.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/powf.html =====
pow
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pow, powf, powl — power function
SYNOPSIS
#include
double pow(double x, double y);
float powf(float x, float y);
long double powl(long double x, long double y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the value of x raised to the power y, xy. If
x is negative, the application shall ensure that y is an integer value.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the value of x raised to the power y.
For finite values of x  0, if x is ±0, ±0 shall be returned.
For y > 0 and not an odd integer, if x is ±0, +0 shall be returned.
If x is -1, and y is ±Inf, 1.0 shall be returned.
For |x|  1, if y is -Inf, +0 shall be returned.
For |x|  1, if y is +Inf, +Inf shall be returned.
For y an odd integer  0, if x is -Inf, -Inf shall be returned.
For y > 0 and not an odd integer, if x is -Inf, +Inf shall be returned.
For y  0, if x is +Inf, +Inf shall be returned.
[MXX]
If the correct value would cause underflow, and is representable, a range error may occur and the correct value shall be returned.
ERRORS
These functions shall fail if:
Domain Error
The value of x is negative and y is a finite non-integer.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
Pole Error
[MX]
The value of x is zero and y is negative.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the divide-by-zero floating-point exception shall
be raised.
Range Error
The result overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
These functions may fail if:
Pole Error
The value of x is zero and y is negative.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the divide-by-zero floating-point exception shall
be raised.
Range Error
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
exp(), feclearexcept(),
fetestexcept(), isnan()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
The powf() and powl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/42 is applied, correcting the third paragraph in the RETURN
VALUE section.
Issue 7
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #51 (SD5-XSH-ERN-81) is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0443 [68], XSH/TC1-2008/0444 [148], and XSH/TC1-2008/0445 [68] are
applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/gettext_l.html =====
gettext
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
dgettext, dgettext_l, dcgettext, dcgettext_l, gettext, gettext_l, ngettext, ngettext_l, dngettext, dngettext_l,
dcngettext, dcngettext_l — message handling functions
SYNOPSIS
#include
char *dgettext(const char *domainname, const char *msgid);
char *dgettext_l(const char *domainname, const char *msgid,
locale_t locale);
char *dcgettext(const char *domainname, const char *msgid,
int category);
char *dcgettext_l(const char *domainname, const char *msgid,
int category, locale_t locale);
char *dngettext(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n);
char *dngettext_l(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n,
locale_t locale);
char *dcngettext(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n,
int category);
char *dcngettext_l(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n,
int category, locale_t locale);
char *gettext(const char *msgid);
char *gettext_l(const char *msgid, locale_t locale);
char *ngettext(const char *msgid, const char *msgid_plural,
unsigned long int n);
char *ngettext_l(const char *msgid, const char *msgid_plural,
unsigned long int n, locale_t locale);
DESCRIPTION
The gettext() function shall:
attempt to locate a suitable messages object (described in detail below) for the LC_MESSAGES category in the current
locale, and for the current text domain (see bindtextdomain()), containing
the string identified by msgid,
retrieve the string identified by msgid from the messages object,
convert the string to the output codeset if necessary (described in detail below), and
return the result.
If the locale name in effect is "POSIX" or "C" (i.e. the name associated with the LC_MESSAGES locale
category in the current locale), or if no suitable messages object exists, or if no string identified by msgid exists in the
messages object, or if an error occurs, msgid shall be returned.
The dgettext() function shall be equivalent to gettext(), except domainname shall be used instead of the
current text domain to locate the messages object.
The dcgettext() function shall be equivalent to dgettext(), except the locale category identified by
category shall be used instead of LC_MESSAGES .
The ngettext() function shall be equivalent to gettext(), except:
The string to retrieve shall be identified by a combination of msgid and n (see msgfmt).
If the locale name in effect is "POSIX" or "C", or if no suitable messages object exists, or if no string
identified by the combination of msgid and n exists in the messages object, or if an error occurs, the return value
shall be msgid if n is 1, otherwise msgid_plural.
The dngettext() function shall be equivalent to ngettext(), except domainname shall be used instead of the
current text domain to locate the messages object.
The dcngettext() function shall be equivalent to dngettext(), except the locale category identified by
category shall be used instead of LC_MESSAGES .
The *_l() functions shall be equivalent to their counterparts without the _l suffix, except locale shall be
used instead of the current locale. If locale is the special locale object LC_GLOBAL_LOCALE or is not a valid locale object
handle, the behavior is undefined.
The application shall ensure that the msgid and msgid_plural arguments are strings. If either msgid or
msgid_plural is an empty string, or contains characters not in the portable character set, the results are unspecified. If
the category argument is LC_ALL , the results are unspecified.
The location of the messages object shall be determined according to the following criteria, stopping when the first messages
object is found:
[XSI]
If the NLSPATH environment variable is set to a non-empty string, an NLSPATH search shall be performed as described
in XBD 8.2 Internationalization Variables. If NLSPATH identifies
more than one template to use, each template in turn shall be used until a valid messages object is found.
If the LANGUAGE environment variable is set to a non-empty string, a LANGUAGE search shall be performed as
described below. If LANGUAGE identifies more than one directory to search, each directory shall be searched until a valid
messages object is found.
A single-locale search shall be performed as described below.
For [XSI]   the NLSPATH search and   the single-locale search,
the single locale name used to locate the messages object shall be the locale name associated with the selected locale category
from the current locale, or the provided locale object if calling one of the *_l() functions; additional searches of locale
names without .codeset (if present), without _territory (if present), and without @modifier (if present) may
be performed.
For the LANGUAGE search, the value of the LANGUAGE environment variable shall be a list of one or more locale
names separated by a  (':') character. Each locale name shall be tried in the specified order. If a messages
object for the locale does not exist, or cannot be opened, or is unsuitable for implementation-defined reasons (such as security),
the next locale name (if any) shall be tried. If:
a messages object for the locale can be opened but cannot be processed without error, or
the messages object does not contain a string identified by msgid, or msgid and n for the ngettext
functions,
it is unspecified whether the next locale name (if any) is tried. In all other cases, the messages object for the locale shall
be used.
For each locale name in LANGUAGE , or if LANGUAGE is not set or is empty, or no suitable messages object is found
in processing LANGUAGE , the pathname used to locate the messages object shall be
dirname/localename/categoryname/textdomainname.mo, where:
The dirname part is the dirname argument of the most recent successful call to bindtextdomain() that had textdomainname as the domainname argument;
any trailing  characters in dirname shall be discarded. If a successful call to bindtextdomain() has not been made for textdomainname, an
implementation-defined default directory shall be used.
For the LANGUAGE search, the localename part is each locale name from LANGUAGE in turn; if a locale name
has the format language[_territory][.codeset][@modifier], additional
searches of locale names without .codeset (if present), without _territory (if present), and without @modifier
(if present) may be performed; if .codeset is not present, additional searches of locale names with an added .codeset
may be performed. For the single-locale search, the localename part is the name of the current locale, or the locale
specified in an *_l() function call, for the category named by categoryname. Spellings of codeset names are not
standardized, and implementations may attempt to use different commonly known spellings, for example "utf8" and
"UTF-8".
The categoryname part is the string "LC_MESSAGES" if gettext(), dgettext(), ngettext(), or
dngettext() is called, or the locale category name corresponding to the category argument to dcgettext() or
dcngettext(). Likewise for the *_l() variants of all these functions.
For gettext(), gettext_l(), ngettext(), and ngettext_l(), the textdomainname part is the text
domain set by the last successful call to textdomain(). For dgettext(),
dcgettext(), dngettext(), dcngettext(), and the *_l() variants of these functions,
textdomainname is the text domain specified by the domainname argument. The domainname argument shall be
equivalent in syntax and meaning to the domainname argument to textdomain(), except that the selection of the text domain shall affect only the
dgettext(), dcgettext(), dngettext(), and dcngettext() function calls and their *_l() variants.
If the domainname argument is a null pointer, the text domain set by the last successful call to textdomain() shall be used. For all of these functions, if a successful call to textdomain() has not been made the default text domain "messages" shall be
used.
Resolution of the messages object pathname shall be performed the first time one of the gettext family of functions is
called for a given combination of dirname, localename, categoryname, and textdomainname. It is
unspecified whether the pathname is re-resolved if the combination has been used before in a call to one of the gettext
family of functions. If bindtextdomain() performs pathname resolution of its
dirname argument, only the part of the messages object pathname after dirname shall be resolved by the gettext
family of functions.
When one of the gettext family of functions returns a message string that was found in a messages object, it shall
convert the codeset of the message string to the output codeset if a codeset is specified in the messages object (see msgfmt) and the output codeset is not the same as that codeset. If a successful call to
bind_textdomain_codeset() has been made with the text domain of the
messages object as the domainname argument and a non-null codeset argument, the output codeset shall be the
codeset argument from the most recent such call. Otherwise, the output codeset shall be the codeset of characters in the
current locale, or the provided locale object if calling one of the *_l() functions, as specified by the LC_CTYPE
category of the locale. The conversion shall be performed as if by a call to iconv()
using a conversion descriptor returned by iconv_open(, ),
except that if the return value of iconv() would be greater than zero, the
non-identical conversions performed by the gettext family of functions need not be the same as those that such an iconv() call would perform. If an error prevents the codeset conversion from being performed,
the gettext family of functions shall behave as if no message string was found in the messages object. If at least one
non-identical conversion is performed that results in a fallback character (one that does not provide any information about the
character it was converted from, for example, a  or "replacement-character"), the gettext family of
functions may behave as if no message string was found in the messages object.
RETURN VALUE
The gettext(), gettext_l(), dgettext(), dgettext_l(), dcgettext(), and dcgettext_l()
functions shall return the message string described in DESCRIPTION if successful. Otherwise, they shall return msgid.
The ngettext(), ngettext_l(), dngettext(), dngettext_l(), dcngettext(), and
dcngettext_l() functions shall return the message string described in DESCRIPTION if successful. Otherwise, msgid
shall be returned if n is equal to 1, or msgid_plural if n is not equal to 1.
The application shall ensure that it does not modify the returned string. A subsequent call to a gettext family function
shall not overwrite or invalidate the returned string. The returned string may be invalidated by a subsequent call to bind_textdomain_codeset(), bindtextdomain(), setlocale(), or
textdomain() in the same process, except for calls that only query values. The
returned string shall not be invalidated by a subsequent call to uselocale().
ERRORS
The gettext family of functions shall not modify errno. If an error occurs these functions shall return a string
as described in RETURN VALUE.
The following sections are informative.
EXAMPLES
The example code below assumes the following:
The implementation-defined default directory is /system/gettextlib.
The following locales are available on the target system: en_US, en_GB, de_DE. The codeset used for all of these locales is
UTF-8.
The en_AU locale is not available on the target system.
The target system supports conversion from ISO/IEC 8859-1 to UTF-8.
The codeset used for the POSIX locale is ASCII.
The target system does not support conversion from ISO/IEC 8859-1 to ASCII.
Furthermore, the following .mo files (and only the following .mo files) are installed:
/system/gettextlib/en_US/LC_MESSAGES/mail.mo
/messagecatalogs/example/en_US/LC_MESSAGES/mail.mo
These are compiled from a portable messages object source file (dot-po file) with the following ISO/IEC 8859-1 encoded contents
(see the EXTENDED DESCRIPTION of the msgfmt utility for a description of the dot-po
file format):
msgid ""
msgstr ""
"Content-Type: text/plain; charset=ISO_8859-1\n"
"Plural-Forms: nplurals=4; plural= n==1?0: (n>1&&n1&&n1&&n,
XCU gettext, msgfmt,
xgettext
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/logb.html =====
logb
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
logb, logbf, logbl — radix-independent exponent
SYNOPSIS
#include
double logb(double x);
float logbf(float x);
long double logbl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the exponent of x, which is the integral part of logr
|x|, as a signed floating-point value, for non-zero x, where r is the radix of the machine's floating-point
arithmetic, which is the value of FLT_RADIX defined in the
header.
If x is subnormal it is treated as though it were normalized; thus for finite positive x:
1 ,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The logb() function is no longer marked as an extension.
The logbf() and logbl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #50 (SD5-XSH-ERN-76) is applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/timer_gettime.html =====
timer_getoverrun
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
timer_getoverrun, timer_gettime, timer_settime — per-process timers
SYNOPSIS
[CX]  #include
int timer_getoverrun(timer_t timerid);
int timer_gettime(timer_t timerid, struct itimerspec *value);
int timer_settime(timer_t timerid, int flags,
const struct itimerspec *restrict value,
struct itimerspec *restrict ovalue);
DESCRIPTION
The timer_gettime() function shall store the amount of time until the specified timer, timerid, expires and the
reload value of the timer into the space pointed to by the value argument. The it_value member of this structure
shall contain the amount of time before the timer expires, or zero if the timer is disarmed. This value is returned as the interval
until timer expiration, even if the timer was armed with absolute time. The it_interval member of value shall contain
the reload value last set by timer_settime().
The timer_settime() function shall set the time until the next expiration of the timer specified by timerid from
the it_value member of the value argument and arm the timer if the it_value member of value is
non-zero. If the specified timer was already armed when timer_settime() is called, this call shall reset the time until next
expiration to the value specified. If the it_value member of value is zero, the timer shall be disarmed. The
effect of disarming or resetting a timer with pending expiration notifications is unspecified.
If the flag TIMER_ABSTIME is not set in the argument flags, timer_settime() shall behave as if the time until next
expiration is set to be equal to the interval specified by the it_value member of value. That is, the timer shall
expire in it_value nanoseconds from when the call is made. If the flag TIMER_ABSTIME is set in the argument flags,
timer_settime() shall behave as if the time until next expiration is set to be equal to the difference between the absolute
time specified by the it_value member of value and the current value of the clock associated with timerid.
That is, the timer shall expire when the clock reaches the value specified by the it_value member of value. If the
specified time has already passed, the function shall succeed and the expiration notification shall be made.
The reload value of the timer shall be set to the value specified by the it_interval member of value. When a timer
is armed with a non-zero it_interval, a periodic (or repetitive) timer is specified.
Time values that are between two consecutive non-negative integer multiples of the resolution of the specified timer shall be
rounded up to the larger multiple of the resolution. Quantization error shall not cause the timer to expire earlier than the
rounded time value.
If the argument ovalue is not NULL, the timer_settime() function shall store, in the location referenced by
ovalue, a value representing the previous amount of time before the timer would have expired, or zero if the timer was
disarmed, together with the previous timer reload value. Timers shall not expire before their scheduled time.
Only a single signal shall be queued to the process for a given timer at any point in time. When a timer for which a signal is
still pending expires, no signal shall be queued, and a timer overrun shall occur. When a timer expiration signal is delivered to
or accepted by a process, the timer_getoverrun() function shall return the timer expiration overrun count for the specified
timer. The overrun count returned contains the number of extra timer expirations that occurred between the time the signal was
generated (queued) and when it was delivered or accepted, up to but not including an implementation-defined maximum of
{DELAYTIMER_MAX}. If the number of such extra expirations is greater than or equal to {DELAYTIMER_MAX}, then the overrun count
shall be set to {DELAYTIMER_MAX}. The value returned by timer_getoverrun() shall apply to the most recent expiration signal
delivery or acceptance for the timer. If no expiration signal has been delivered for the timer, the return value of
timer_getoverrun() is unspecified.
The behavior is undefined if the value specified by the timerid argument to timer_getoverrun(),
timer_gettime(), or timer_settime() does not correspond to a timer ID returned by timer_create() but not yet deleted by timer_delete().
RETURN VALUE
If the timer_getoverrun() function succeeds, it shall return the timer expiration overrun count as explained above.
If the timer_gettime() or timer_settime() functions succeed, a value of 0 shall be returned.
If an error occurs for any of these functions, the value -1 shall be returned, and errno set to indicate the error.
ERRORS
The timer_settime() function shall fail if:
[EINVAL]
A value structure specified a nanosecond value less than zero or greater than or equal to 1000 million, and the
it_value member of that structure did not specify zero seconds and nanoseconds.
The timer_settime() function may fail if:
[EINVAL]
The it_interval member of value is not zero and the timer was created with notification by creation of a new
thread (sigev_sigev_notify was SIGEV_THREAD) and a fixed stack address has been set in the thread attribute pointed to by
sigev_notify_attributes.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Using fixed stack addresses is problematic when timer expiration is signaled by the creation of a new thread. Since it cannot be
assumed that the thread created for one expiration is finished before the next expiration of the timer, it could happen that two
threads use the same memory as a stack at the same time. This is invalid and produces undefined results.
RATIONALE
Practical clocks tick at a finite rate, with rates of 100 hertz and 1000 hertz being common. The inverse of this tick rate is
the clock resolution, also called the clock granularity, which in either case is expressed as a time duration, being 10
milliseconds and 1 millisecond respectively for these common rates. The granularity of practical clocks implies that if one reads a
given clock twice in rapid succession, one may get the same time value twice; and that timers must wait for the next clock tick
after the theoretical expiration time, to ensure that a timer never returns too soon. Note also that the granularity of the clock
may be significantly coarser than the resolution of the data format used to set and get time and interval values. Also note that
some implementations may choose to adjust time and/or interval values to exactly match the ticks of the underlying clock.
This volume of POSIX.1-2024 defines functions that allow an application to determine the implementation-supported resolution for
the clocks and requires an implementation to document the resolution supported for timers and nanosleep() if they differ from the supported clock resolution. This is more of a
procurement issue than a runtime application issue.
If an implementation detects that the value specified by the timerid argument to timer_getoverrun(),
timer_gettime(), or timer_settime() does not correspond to a timer ID returned by timer_create() but not yet deleted by timer_delete(), it is recommended that the function should fail and report an [EINVAL]
error.
FUTURE DIRECTIONS
None.
SEE ALSO
clock_getres(), timer_create()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The timer_getoverrun(), timer_gettime(), and timer_settime() functions are marked as part of the Timers
option.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Timers
option.
The [EINVAL] error condition is updated to include the following: "and the it_value member of that structure did not
specify zero seconds and nanoseconds." This change is for IEEE PASC Interpretation 1003.1 #89.
The DESCRIPTION for timer_getoverrun() is updated to clarify that "If no expiration signal has been delivered for the
timer, or if the Realtime Signals Extension is not supported, the return value of timer_getoverrun() is unspecified".
The restrict keyword is added to the timer_settime() prototype for alignment with the ISO/IEC 9899:1999
standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/140 is applied, updating the ERRORS section so that the
mandatory [EINVAL] error ("The timerid argument does not correspond to an ID returned by timer_create() but not yet deleted by timer_delete()") becomes optional.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/141 is applied, updating the ERRORS section to include an
optional [EINVAL] error for the case when a timer is created with the notification method set to SIGEV_THREAD. APPLICATION USAGE
text is also added.
Issue 7
The timer_getoverrun(), timer_gettime(), and timer_settime() functions are moved from the Timers option to
the Base.
Functionality relating to the Realtime Signals Extension option is moved to the Base.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0370 [659] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getnetbyaddr.html =====
endnetent
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
endnetent, getnetbyaddr, getnetbyname, getnetent, setnetent — network database functions
SYNOPSIS
#include
void endnetent(void);
struct netent *getnetbyaddr(uint32_t net, int type);
struct netent *getnetbyname(const char *name);
struct netent *getnetent(void);
void setnetent(int stayopen);
DESCRIPTION
These functions shall retrieve information about networks. This information is considered to be stored in a database that can be
accessed sequentially or randomly. The implementation of this database is unspecified.
The setnetent() function shall open and rewind the database. If the stayopen argument is non-zero, the connection
to the net database shall not be closed after each call to getnetent() (either directly, or indirectly through one of
the other getnet*() functions), and the implementation may maintain an open file descriptor to the database. If a file
descriptor is used, the FD_CLOEXEC flag shall be set; see .
The getnetent() function shall read the next entry of the database, opening and closing a connection to the database as
necessary.
The getnetbyaddr() function shall search the database from the beginning, and find the first entry for which the address
family specified by type matches the n_addrtype member and the network number net matches the n_net
member, opening and closing a connection to the database as necessary. The net argument shall be the network number in host
byte order.
The getnetbyname() function shall search the database from the beginning and find the first entry for which the network
name specified by name matches the n_name member, opening and closing a connection to the database as necessary.
The getnetbyaddr(), getnetbyname(), and getnetent() functions shall each return a pointer to a
netent structure, the members of which shall contain the fields of an entry in the network database.
The endnetent() function shall close the database, releasing any open file descriptor.
These functions need not be thread-safe.
RETURN VALUE
Upon successful completion, getnetbyaddr(), getnetbyname(), and getnetent() shall return a pointer to a
netent structure if the requested entry was found, and a null pointer if the end of the database was reached or the
requested entry was not found. Otherwise, a null pointer shall be returned.
The application shall not modify the structure to which the return value points, nor any storage areas pointed to by pointers
within the structure. The returned pointer, and pointers within the structure, might be invalidated or the structure or the storage
areas might be overwritten by a subsequent call to getnetbyaddr(), getnetbyname(), or getnetent(). The
returned pointer, and pointers within the structure, might also be invalidated if the calling thread is terminated.
ERRORS
The getnetbyaddr(), getnetbyname(), getnetent(), and setnetent() functions may fail if:
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum allowable number of files is currently open in the system.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0083 [75] and XSH/TC1-2008/0084 [75] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0090 [656] is applied.
Issue 8
Austin Group Defect 368 is applied, adding a requirement for FD_CLOEXEC to be set if a file descriptor is used, and adding the
[EMFILE] and [ENFILE] errors.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/catgets.html =====
catgets
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
catgets — read a program message
SYNOPSIS
#include
char *catgets(nl_catd catd, int set_id, int msg_id, const char
*s);
DESCRIPTION
The catgets() function shall attempt to read message msg_id, in set set_id, from the message catalog
identified by catd. The catd argument is a message catalog descriptor returned from an earlier call to catopen(). The results are undefined if catd is not a value returned by catopen() for a message catalog still open in the process. The s argument points to a
default message string which shall be returned by catgets() if it cannot retrieve the identified message.
The catgets() function need not be thread-safe.
RETURN VALUE
If the identified message is retrieved successfully, catgets() shall return a pointer to an internal buffer area
containing the null-terminated message string. If the call is unsuccessful for any reason, s shall be returned and
errno shall be set to indicate the error.
ERRORS
The catgets() function shall fail if:
[EINTR]
The read operation was terminated due to the receipt of a signal, and no data was transferred.
[ENOMSG]
The message identified by set_id and msg_id is not in the message catalog.
The catgets() function may fail if:
[EBADF]
The catd argument is not a valid message catalog descriptor open for reading.
[EBADMSG]
The message identified by set_id and msg_id in the specified message catalog did not satisfy
implementation-defined security criteria.
[EINVAL]
The message catalog identified by catd is corrupted.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
catclose(), catopen()
XBD
CHANGE HISTORY
First released in Issue 2.
Issue 5
A note indicating that this function need not be reentrant is added to the DESCRIPTION.
Issue 6
In the DESCRIPTION, the note about reentrancy is expanded to cover thread-safety.
Issue 7
Austin Group Interpretation 1003.1-2001 #044 is applied, changing the "may fail" [EINTR] and [ENOMSG] errors to become "shall
fail" errors, updating the RETURN VALUE section, and updating the DESCRIPTION to note that: "The results are undefined if
catd is not a value returned by catopen() for a message catalog still open in
the process."
The catgets() function is moved from the XSI option to the Base.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_attr_setdetachstate.html =====
pthread_attr_getdetachstate
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_attr_getdetachstate, pthread_attr_setdetachstate — get and set the detachstate attribute
SYNOPSIS
#include
int pthread_attr_getdetachstate(const pthread_attr_t *attr,
int *detachstate);
int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);
DESCRIPTION
The detachstate attribute controls whether the thread is created in a detached state. If the thread is created detached,
then use of the ID of the newly created thread by the pthread_detach() or
pthread_join() function is an error.
The pthread_attr_getdetachstate() and pthread_attr_setdetachstate() functions, respectively, shall get and set the
detachstate attribute in the attr object.
For pthread_attr_getdetachstate(), detachstate shall be set to either PTHREAD_CREATE_DETACHED or
PTHREAD_CREATE_JOINABLE.
For pthread_attr_setdetachstate(), the application shall set detachstate to either PTHREAD_CREATE_DETACHED or
PTHREAD_CREATE_JOINABLE.
A value of PTHREAD_CREATE_DETACHED shall cause all threads created with attr to be in the detached state, whereas using a
value of PTHREAD_CREATE_JOINABLE shall cause all threads created with attr to be in the joinable state. The default value of
the detachstate attribute shall be PTHREAD_CREATE_JOINABLE.
The behavior is undefined if the value specified by the attr argument to pthread_attr_getdetachstate() or
pthread_attr_setdetachstate() does not refer to an initialized thread attributes object.
RETURN VALUE
Upon successful completion, pthread_attr_getdetachstate() and pthread_attr_setdetachstate() shall return a value
of 0; otherwise, an error number shall be returned to indicate the error.
The pthread_attr_getdetachstate() function stores the value of the detachstate attribute in detachstate if
successful.
ERRORS
The pthread_attr_setdetachstate() function shall fail if:
[EINVAL]
The value of detachstate was not valid
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
Retrieving the detachstate Attribute
This example shows how to obtain the detachstate attribute of a thread attribute object.
#include
pthread_attr_t thread_attr;
int            detachstate;
int            rc;
/* code initializing thread_attr */
...
rc = pthread_attr_getdetachstate (&thread_attr, &detachstate);
if (rc!=0) {
/* handle error */
...
}
else {
/* legal values for detachstate are:
* PTHREAD_CREATE_DETACHED or PTHREAD_CREATE_JOINABLE
*/
...
}
APPLICATION USAGE
None.
RATIONALE
If an implementation detects that the value specified by the attr argument to pthread_attr_getdetachstate() or
pthread_attr_setdetachstate() does not refer to an initialized thread attributes object, it is recommended that the function
should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_attr_destroy(), pthread_attr_getstacksize(), pthread_create()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_attr_setdetachstate() and pthread_attr_getdetachstate() functions are marked as part of the Threads
option.
The normative text is updated to avoid use of the term "must" for application requirements.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/72 is applied, adding the example to the EXAMPLES section.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/73 is applied, updating the ERRORS section to include the
optional [EINVAL] error.
Issue 7
The pthread_attr_setdetachstate() and pthread_attr_getdetachstate() functions are moved from the Threads option to
the Base.
The [EINVAL] error for an uninitialized thread attributes object is removed; this condition results in undefined behavior.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ctanh.html =====
ctanh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ctanh, ctanhf, ctanhl — complex hyperbolic tangent functions
SYNOPSIS
#include
double complex ctanh(double complex z);
float complex ctanhf(float complex z);
long double complex ctanhl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex hyperbolic tangent of z.
RETURN VALUE
These functions shall return the complex hyperbolic tangent value.
[MXC]
ctanh(conj(z)), ctanhf(conjf(z)), and ctanhl(conjl(z)) shall return
exactly the same value as conj(ctanh(z)), conjf(ctanhf(z)), and
conjl(ctanhl(z)), respectively, and ctanh(-z), ctanhf(-z), and
ctanhl(-z) shall return exactly the same value as -ctanh(z), -ctanhf(z), and
-ctanhl(z), respectively, including for the special values of z below.
If z is +0 + i0, +0 + i0 shall be returned.
If z is 0 + iInf, 0 + iNaN shall be returned and the invalid floating-point exception shall be raised.
If z is x + iInf where x is non-zero and finite, NaN + iNaN shall be returned and the invalid
floating-point exception shall be raised.
If z is 0 + iNaN, 0 + iNaN shall be returned.
If z is x + iNaN where x is non-zero and finite, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is +Inf + iy where y is positive-signed and finite, 1 + i0 sin(2y) shall be
returned.
If z is +Inf + iInf, 1 ± i0 shall be returned; the sign of the imaginary part of the result is
unspecified.
If z is +Inf + iNaN, 1 ± i0 shall be returned; the sign of the imaginary part of the result is
unspecified.
If z is NaN + i0, NaN + i0 shall be returned.
If z is NaN + iy where y is any non-zero number, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is NaN + iNaN, NaN + iNaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
catanh()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/setsockopt.html =====
setsockopt
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
setsockopt — set the socket options
SYNOPSIS
#include
int setsockopt(int socket, int level, int option_name,
const void *option_value, socklen_t option_len);
DESCRIPTION
The setsockopt() function shall set the option specified by the option_name argument, at the protocol level
specified by the level argument, to the value pointed to by the option_value argument for the socket associated with
the file descriptor specified by the socket argument.
The level argument specifies the protocol level at which the option resides. To set options at the socket level, specify
the level argument as SOL_SOCKET. To set options at other levels, supply the appropriate level identifier for the
protocol controlling the option. For example, to indicate that an option is interpreted by the TCP (Transport Control Protocol),
set level to IPPROTO_TCP as defined in the
header.
The option_name argument specifies a single option to set. It can be one of the socket-level options defined in  and described in 2.10.16 Use of Options. If option_name is equal to SO_RCVTIMEO or
SO_SNDTIMEO and the implementation supports setting the option, it is unspecified whether the struct timeval pointed to by
option_value is stored as provided by this function or is rounded up to align with the resolution of the clock being used.
If setsockopt() is called with option_name equal to SO_ACCEPTCONN, SO_ERROR, or SO_TYPE, the behavior is
unspecified.
RETURN VALUE
Upon successful completion, setsockopt() shall return 0. Otherwise, -1 shall be returned and errno set to indicate
the error.
ERRORS
The setsockopt() function shall fail if:
[EBADF]
The socket argument is not a valid file descriptor.
[EDOM]
The send and receive timeout values are too big to fit into the timeout fields in the socket structure.
[EINVAL]
The specified option is invalid at the specified socket level or the socket has been shut down.
[EISCONN]
The socket is already connected, and a specified option cannot be set while the socket is connected.
[ENOPROTOOPT]
The option is not supported by the protocol.
[ENOTSOCK]
The socket argument does not refer to a socket.
The setsockopt() function may fail if:
[ENOMEM]
There was insufficient memory available for the operation to complete.
[ENOBUFS]
Insufficient resources are available in the system to complete the call.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The setsockopt() function provides an application program with the means to control socket behavior. An application
program can use setsockopt() to allocate buffer space, control timeouts, or permit socket data broadcasts. The  header defines the socket-level options available to
setsockopt().
Options may exist at multiple protocol levels. The SO_ options are always present at the uppermost socket level.
It is implementation-defined which socket options, if any, are inherited from a listening socket to an accepted socket by
accept() or accept4().
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.10 Sockets, bind(),
endprotoent(), getsockopt()
, socket()
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/125 is applied, updating the SO_LINGER option in the DESCRIPTION
to refer to the calling thread rather than the process.
Issue 7
Austin Group Interpretation 1003.1-2001 #158 is applied, removing text relating to socket options that is now in 2.10.16 Use of Options.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0571 [369] is applied.
Issue 8
Austin Group Defect 1337 is applied, clarifying socket option default values.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/access.html =====
access
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
access, faccessat — determine accessibility of a file descriptor
SYNOPSIS
#include
int access(const char *path, int amode);
[OH] #include
int faccessat(int fd, const char *path, int amode, int
flag);
DESCRIPTION
The access() function shall check the file named by the pathname pointed to by the path argument for accessibility
according to the bit pattern contained in amode. The checks for accessibility (including directory permissions checked
during pathname resolution) shall be performed using the real user ID in place of the effective user ID and the real group ID in
place of the effective group ID.
The value of amode is either the bitwise-inclusive OR of the access permissions to be checked (R_OK, W_OK, X_OK) or the
existence test (F_OK).
If any access permissions are checked, each shall be checked individually, as described in XBD 4.7 File Access Permissions, except that where that description refers to
execute permission for a process with appropriate privileges, an implementation may indicate success for X_OK even if execute
permission is not granted to any user.
The faccessat() function, when called with a flag value of zero, shall be equivalent to the access()
function, except in the case where path specifies a relative path. In this case the file whose accessibility is to be
determined shall be located relative to the directory associated with the file descriptor fd instead of the current working
directory. If the access mode of the open file description associated with the file descriptor is not O_SEARCH, the function shall
check whether directory searches are permitted using the current permissions of the directory underlying the file descriptor. If
the access mode is O_SEARCH, the function shall not perform the check.
If faccessat() is passed the special value AT_FDCWD in the fd parameter, the current working directory shall be
used and, if flag is zero, the behavior shall be identical to a call to access().
Values for flag are constructed by a bitwise-inclusive OR of flags from the following list, defined in :
AT_EACCESS
The checks for accessibility (including directory permissions checked during pathname resolution) shall be performed using the
effective user ID and group ID instead of the real user ID and group ID as required in a call to access().
RETURN VALUE
Upon successful completion, these functions shall return 0. Otherwise, these functions shall return -1 and set errno to
indicate the error.
ERRORS
These functions shall fail if:
[EACCES]
Permission bits of the file mode do not permit the requested access, or search permission is denied on a component of the path
prefix.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of path does not name an existing file or path is an empty string.
[ENOTDIR]
A component of the path prefix names an existing file that is neither a directory nor a symbolic link to a directory, or the
path argument contains at least one non- character and ends with one or more trailing  characters
and the last pathname component names an existing file that is neither a directory nor a symbolic link to a directory.
[EROFS]
Write access is requested for a file on a read-only file system.
The faccessat() function shall fail if:
[EACCES]
The access mode of the open file description associated with fd is not O_SEARCH and the permissions of the directory
underlying fd do not permit directory searches.
[EBADF]
The path argument does not specify an absolute path and the fd argument is neither AT_FDCWD nor a valid file
descriptor open for reading or searching.
[ENOTDIR]
The path argument is not an absolute path and fd is a file descriptor associated with a non-directory file.
These functions may fail if:
[EINVAL]
The value of the amode argument is invalid.
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
[ETXTBSY]
Write access is requested for a pure procedure (shared text) file that is being executed.
The faccessat() function may fail if:
[EINVAL]
The value of the flag argument is not valid.
The following sections are informative.
EXAMPLES
Testing for the Existence of a File
The following example tests whether a file named myfile exists in the /tmp directory.
#include
...
int result;
const char *pathname = "/tmp/myfile";
result = access (pathname, F_OK);
APPLICATION USAGE
Use of these functions is discouraged since by the time the returned information is acted upon, it is out-of-date. (That is,
acting upon the information always leads to a time-of-check-to-time-of-use race condition.) An application should instead attempt
the action itself and handle the [EACCES] error that occurs if the file is not accessible (with a change of effective user and
group IDs beforehand, and perhaps a change back afterwards, in the case where access() or faccessat() without
AT_EACCES would have been used.)
Historically, one of the uses of access() was in set-user-ID root programs to check whether the user running the program
had access to a file. This relied on "super-user" privileges which were granted based on the effective user ID being zero, so
that when access() used the real user ID to check accessibility those privileges were not taken into account. On newer
systems where privileges can be assigned which have no association with user or group IDs, if a program with such privileges calls
access(), the change of IDs has no effect on the privileges and therefore they are taken into account in the accessibility
checks. Thus, access() (and faccessat() with flag zero) cannot be used for this historical purpose in such programs.
Likewise, if a system provides any additional or alternate file access control mechanisms that are not user ID-based, they will
still be taken into account.
If a relative pathname is used, no account is taken of whether the current directory (or the directory associated with the file
descriptor fd) is accessible via any absolute pathname. Applications using access(), or faccessat() without
AT_EACCES, may consequently act as if the file would be accessible to a user with the real user ID and group ID of the process when
such a user would not in practice be able to access the file because access would be denied at some point above the current
directory (or the directory associated with the file descriptor fd) in the file hierarchy.
If access() or faccessat() is used with W_OK to check for write access to a directory which has the S_ISVTX bit
set, a return value indicating the directory is writable can be misleading since some operations on files in the directory would
not be permitted based on the ownership of those files (see XBD 4.5 Directory
Protection).
Additional values of amode other than the set defined in the description may be valid; for example, if a system has
extended access controls.
The use of the AT_EACCESS value for flag enables functionality not available in access().
RATIONALE
In early proposals, some inadequacies in the access() function led to the creation of an eaccess() function
because:
Historical implementations of access() do not test file access correctly when the process' real user ID is superuser. In
particular, they always return zero when testing execute permissions without regard to whether the file is executable.
The superuser has complete access to all files on a system. As a consequence, programs started by the superuser and switched to
the effective user ID with lesser privileges cannot use access() to test their file access permissions.
However, the historical model of eaccess() does not resolve problem (1), so this volume of POSIX.1-2024 now allows
access() to behave in the desired way because several implementations have corrected the problem. It was also argued that
problem (2) is more easily solved by using open(), chdir(), or one of the exec functions as
appropriate and responding to the error, rather than creating a new function that would not be as reliable. Therefore,
eaccess() is not included in this volume of POSIX.1-2024.
The sentence concerning appropriate privileges and execute permission bits reflects the two possibilities implemented by
historical implementations when checking superuser access for X_OK.
New implementations are discouraged from returning X_OK unless at least one execution permission bit is set.
The purpose of the faccessat() function is to enable the checking of the accessibility of files in directories other than
the current working directory without exposure to race conditions. Any part of the path of a file could be changed in parallel to a
call to access(), resulting in unspecified behavior. By opening a file descriptor for the target directory and using the
faccessat() function it can be guaranteed that the file tested for accessibility is located relative to the desired
directory.
FUTURE DIRECTIONS
These functions may be formally deprecated (for example, by shading them OB) in a future version of this standard.
SEE ALSO
chmod(), fstatat()
XBD 4.7 File Access Permissions, ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The [ELOOP] mandatory error condition is added.
A second [ENAMETOOLONG] is added as an optional error condition.
The [ETXTBSY] optional error condition is added.
The following changes were made to align with the IEEE P1003.1a draft standard:
The [ELOOP] optional error condition is added.
Issue 7
Austin Group Interpretations 1003.1-2001 #046 and #143 are applied.
The faccessat() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 2.
Changes are made to allow a directory to be opened for searching.
The [ENOTDIR] error condition is clarified to cover the condition where the last component of a pathname exists but is not a
directory or a symbolic link to a directory.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0019 [461], XSH/TC1-2008/0020 [324], XSH/TC1-2008/0021 [278],
XSH/TC1-2008/0022 [278], and XSH/TC1-2008/0023 [291] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0037 [873], XSH/TC2-2008/0038 [591], XSH/TC2-2008/0039 [838],
XSH/TC2-2008/0040 [817], XSH/TC2-2008/0041 [487], XSH/TC2-2008/0042 [838], XSH/TC2-2008/0043 [817], and XSH/TC2-2008/0044 [838] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wctomb.html =====
wctomb
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wctomb — convert a wide-character code to a character
SYNOPSIS
#include
int wctomb(char *s, wchar_t wchar);
DESCRIPTION
[CX]  Except for requirements relating to data races, the functionality described on this reference page is aligned with the
ISO C standard. Any other conflict between the requirements described here and the ISO C standard is unintentional. This
volume of POSIX.1-2024 defers to the ISO C standard for all wctomb() functionality except in relation to data races.
The wctomb() function shall determine the number of bytes needed to represent the character corresponding to the
wide-character code whose value is wchar (including any change in the shift state). It shall store the character
representation (possibly multiple bytes and any special bytes to change shift state) in the array object pointed to by s (if
s is not a null pointer). At most {MB_CUR_MAX} bytes shall be stored. If wchar is 0, a null byte shall be stored,
preceded by any shift sequence needed to restore the initial shift state, and wctomb() shall be left in the initial shift
state.
The behavior of this function is affected by the LC_CTYPE category of the current locale. For a state-dependent encoding,
this function shall be placed into its initial state by a call for which its character pointer argument, s, is a null
pointer. Subsequent calls with s as other than a null pointer shall cause the internal state of the function to be altered
as necessary. A call with s as a null pointer shall cause this function to return a non-zero value if encodings have state
dependency, and 0 otherwise. Changing the LC_CTYPE category causes the shift state of this function to be unspecified.
The wctomb() function [CX]   need not be thread-safe; however, it   shall avoid data races with all other functions.
The implementation shall behave as if no function defined in this volume of POSIX.1-2024 calls wctomb().
RETURN VALUE
If s is a null pointer, wctomb() shall return a non-zero or 0 value, if character encodings, respectively, do or
do not have state-dependent encodings. If s is not a null pointer, wctomb() shall return -1 if the value of
wchar does not correspond to a valid character, or return the number of bytes that constitute the character corresponding to
the value of wchar.
In no case shall the value returned be greater than the value of the {MB_CUR_MAX} macro.
ERRORS
The wctomb() function shall fail if:
[EILSEQ]
[CX]  An
invalid wide-character code is detected.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
When the ISO C standard introduced threads in C11, it required wctomb() to avoid data races (with itself as well as
with other functions), whereas POSIX.1-2008 did not require it to be thread-safe, and in many implementations it did not avoid data
races with itself and still does not. The ISO C committee intend to change the requirements in a future version of the ISO C
standard, but since POSIX.1 currently refers to C17 it is necessary for it not to defer to the ISO C standard regarding data
races in order to continue to allow this function not to avoid data races with itself.
FUTURE DIRECTIONS
It is expected that a change in a future version of the ISO C standard will allow a future version of this standard to
remove the data race exception from the statement that it defers to the ISO C standard.
SEE ALSO
mblen(), mbtowc(), mbstowcs(), wcstombs()
XBD
CHANGE HISTORY
First released in Issue 4. Derived from the ANSI C standard.
Issue 6
Extensions beyond the ISO C standard are marked.
A note indicating that this function need not be reentrant is added to the DESCRIPTION.
Issue 7
Austin Group Interpretations 1003.1-2001 #156 and #170 are applied.
Issue 8
Austin Group Defects 708 and 1302 are applied, aligning this function with the ISO/IEC 9899:2018 standard, except in
relation to data races.
Austin Group Defect 1572 is applied, removing CX shading from some text derived from the ISO C standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/iswalpha.html =====
iswalpha
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
iswalpha, iswalpha_l — test for an alphabetic wide-character code
SYNOPSIS
#include
int iswalpha(wint_t wc);
[CX]  int iswalpha_l(wint_t wc, locale_t locale);
DESCRIPTION
For iswalpha(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The iswalpha() [CX]   and iswalpha_l()
functions shall test whether wc is a wide-character code representing a character of class alpha in the current
locale, [CX]   or in the locale represented by locale,
respectively; see XBD 7. Locale.
The wc argument is a wint_t, the value of which the application shall ensure is a wide-character code
corresponding to a valid character in the locale used by the function, or equal to the value of the macro WEOF. If the argument has
any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to iswalpha_l() is the special locale object LC_GLOBAL_LOCALE or is not
a valid locale object handle.
RETURN VALUE
The iswalpha() [CX]   and iswalpha_l()
functions shall return non-zero if wc is an alphabetic wide-character code; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
iswalnum(), iswcntrl(),
iswctype(), iswdigit(),
iswgraph(), iswlower(),
iswprint(), iswpunct(),
iswspace(), iswupper(),
iswxdigit(), setlocale(),
uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 4.
Issue 5
The following change has been made in this version for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E):
The SYNOPSIS has been changed to indicate that this function and associated data types are now made visible by inclusion of the
header rather than .
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The iswalpha_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0312 [302], XSH/TC1-2008/0313 [283], and XSH/TC1-2008/0314 [283] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0181 [685] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/setrlimit.html =====
getrlimit
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getrlimit, setrlimit — control maximum resource consumption
SYNOPSIS
#include
int getrlimit(int resource, struct rlimit *rlp);
int setrlimit(int resource, const struct rlimit *rlp);
DESCRIPTION
The getrlimit() function shall get, and the setrlimit() function shall set, limits on the consumption of a variety
of resources.
Each call to either getrlimit() or setrlimit() identifies a specific resource to be operated upon as well as a
resource limit. A resource limit is represented by an rlimit structure. The rlim_cur member specifies the current or
soft limit and the rlim_max member specifies the maximum or hard limit. Soft limits can be changed by a process to any value
that is less than or equal to the hard limit. A process can (irreversibly) lower its hard limit to any value that is greater than
or equal to the soft limit. Only a process with appropriate privileges can raise a hard limit. Both hard and soft limits can be
changed in a single call to setrlimit() subject to the constraints described above.
The value RLIM_INFINITY, defined in , shall be
considered to be larger than any other limit value. If a call to getrlimit() returns RLIM_INFINITY for a resource, it means
the implementation shall not enforce limits on that resource. Specifying RLIM_INFINITY as any resource limit value on a successful
call to setrlimit() shall inhibit enforcement of that resource limit.
The following resources are defined:
RLIMIT_CORE
This is the maximum size of a file containing a core image, in bytes, that can be created by a process. A limit of 0 shall
prevent the creation of such a file. If this limit is exceeded, the writing of a file containing a core image shall terminate at
this size. Note that the production of such a file may be one of the implementation-defined actions for abnormal termination.
RLIMIT_CPU
[XSI]
This is the maximum amount of CPU time, in seconds, used by a process. If this limit is exceeded, SIGXCPU shall be generated for
the process. If the process is catching or ignoring SIGXCPU, or all threads belonging to that process are blocking SIGXCPU, the
behavior is unspecified.
RLIMIT_DATA
This is the maximum size of a data segment of the process, in bytes. If this limit is exceeded, the malloc() function shall fail with errno set to [ENOMEM].
RLIMIT_FSIZE
This is the maximum size of a file, in bytes, that can be created by a process. If a write or truncate operation would cause
this limit to be exceeded, [XSI]   a SIGXFSZ shall be generated for the thread; if the thread is blocking, or the process is
catching or ignoring SIGXFSZ,   the operation shall fail with
an [EFBIG] error.
RLIMIT_NOFILE
This is a number one greater than the maximum value that the system shall assign to a newly-created descriptor. If this limit
is exceeded, functions that allocate a file descriptor shall fail with errno set to [EMFILE]. This limit constrains the
number of file descriptors that a process can allocate.
RLIMIT_STACK
This is the maximum size of the initial thread's stack, in bytes. The implementation does not automatically grow the stack
beyond this limit. If this limit is exceeded, SIGSEGV shall be generated for the thread. If the thread is blocking SIGSEGV, or the
process is ignoring or catching SIGSEGV and has not made arrangements to use an alternate stack, the disposition of SIGSEGV shall
be set to SIG_DFL before it is generated.
RLIMIT_AS
This is the maximum size of total available memory of the process, in bytes. If this limit is exceeded, the malloc() and mmap() functions shall fail with
errno set to [ENOMEM]. In addition, the automatic stack growth fails with the effects outlined above.
When using the getrlimit() function, if a resource limit can be represented correctly in an object of type rlim_t,
then its representation is returned; otherwise, if the value of the resource limit is equal to that of the corresponding saved hard
limit, the value returned shall be RLIM_SAVED_MAX; otherwise, the value returned shall be RLIM_SAVED_CUR.
When using the setrlimit() function, if the requested new limit is RLIM_INFINITY, the new limit shall be "no limit";
otherwise, if the requested new limit is RLIM_SAVED_MAX, the new limit shall be the corresponding saved hard limit; otherwise, if
the requested new limit is RLIM_SAVED_CUR, the new limit shall be the corresponding saved soft limit; otherwise, the new limit
shall be the requested value. In addition, if the corresponding saved limit can be represented correctly in an object of type
rlim_t then it shall be overwritten with the new limit.
The result of setting a limit to RLIM_SAVED_MAX or RLIM_SAVED_CUR is unspecified unless a previous call to getrlimit()
returned that value as the soft or hard limit for the corresponding resource limit.
The determination of whether a limit can be correctly represented in an object of type rlim_t is implementation-defined.
For example, some implementations permit a limit whose value is greater than RLIM_INFINITY and others do not.
The exec family of functions shall cause resource limits to be saved.
RETURN VALUE
Upon successful completion, getrlimit() and setrlimit() shall return 0. Otherwise, these functions shall return -1
and set errno to indicate the error.
ERRORS
The getrlimit() and setrlimit() functions shall fail if:
[EINVAL]
An invalid resource was specified; or in a setrlimit() call, the new rlim_cur exceeds the new
rlim_max.
[EPERM]
The limit specified to setrlimit() would have raised the maximum limit value, and the calling process does not have
appropriate privileges.
The setrlimit() function may fail if:
[EINVAL]
The limit specified cannot be lowered because current usage is already higher than the limit.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
If a process attempts to set the hard limit or soft limit for RLIMIT_NOFILE to less than the value of {_POSIX_OPEN_MAX} from
, unexpected behavior may occur.
If a process attempts to set the hard limit or soft limit for RLIMIT_NOFILE to less than the highest currently open file
descriptor +1, unexpected behavior may occur.
RATIONALE
These functions were previously part of the XSI option and have been moved to the Base so that portable shells, and other
utilities that need to relay the wait status of a child process to a parent, can terminate themselves with the same signal that
terminated the child but without overwriting a core image created by the child (through setting RLIMIT_CORE to zero, which disables
core image creation). The RLIMIT_CPU and RLIMIT_FSIZE limits remain in the XSI option because they relate to other XSI
functionality (SIGXCPU and SIGXFSZ).
It should be noted that RLIMIT_STACK applies "at least" to the stack of the initial thread in the process, and not to the sum
of all the stacks in the process, as that would be very limiting unless the value is so big as to provide no value at all with a
single thread.
FUTURE DIRECTIONS
None.
SEE ALSO
exec, fork(), malloc(), open(), sigaltstack(), sysconf()
XBD
XCU ulimit
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
An APPLICATION USAGE section is added.
Large File Summit extensions are added.
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/25 is applied, changing wording for RLIMIT_NOFILE in the
DESCRIPTION related to functions that allocate a file descriptor failing with [EMFILE]. Text is added to the APPLICATION USAGE
section noting the consequences of a process attempting to set the hard or soft limit for RLIMIT_NOFILE less than the highest
currently open file descriptor +1.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/46 is applied, updating the definition of RLIMIT_STACK in the
DESCRIPTION from "the maximum size of a process stack" to "the maximum size of the initial thread's stack". Text is added to
the RATIONALE section.
Issue 8
Austin Group Defects 51 and 1669 are applied, moving the getrlimit() and setrlimit() functions, excluding the
RLIMIT_CPU limit, from the XSI option to the Base.
Austin Group Defect 1141 is applied, changing the description of RLIMIT_CORE.
Austin Group Defect 1416 is applied, changing some uses of "may" to "can" and one to "shall".
Austin Group Defect 1418 is applied, changing the SEE ALSO section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mktime.html =====
mktime
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mktime — convert broken-down time into time since the Epoch
SYNOPSIS
#include
time_t mktime(struct tm *timeptr);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The mktime() function shall convert the broken-down time, expressed as local time, in some members of the structure
pointed to by timeptr, into a time since the Epoch value with the same encoding as that of the values returned by time(). The mktime() function shall make use of only the tm_year, tm_mon,
tm_mday, tm_hour, tm_min, tm_sec, and tm_isdst members of the structure pointed to by
timeptr; the values of these members shall not be restricted to the ranges described in .
[CX]
Local timezone information shall be set as though mktime() called tzset().
The mktime() function shall calculate the time in seconds since the Epoch to be returned as if by manipulating the
members of the tm structure according to the following steps.
The tm_sec member may, but should not, be brought into the range 0 to 60, inclusive. For each 60 seconds added to or
subtracted from tm_sec, a decrement or increment, respectively, of 1 minute shall be saved for later application.
The tm_min member shall be brought into the range 0 to 59, inclusive, and any saved decrement or increment of minutes
shall then be applied, repeating the range adjustment afterwards if necessary. For each 60 minutes added to or subtracted from
tm_min, a decrement or increment, respectively, of 1 hour shall be saved for later application.
The tm_hour member shall be brought into the range 0 to 23, inclusive, and any saved decrement or increment of hours
shall then be applied, repeating the range adjustment afterwards if necessary. For each 24 hours added to or subtracted from
tm_hour, a decrement or increment, respectively, of 1 day shall be saved for later application.
The tm_mon member shall be brought into the range 0 to 11, inclusive. For each 12 months added to or subtracted from
tm_mon, a decrement or increment, respectively, of 1 year shall be saved for later use.
The tm_mday member shall be brought into the range 1 to 31, inclusive, and any saved decrement or increment of days shall
then be applied, repeating the range adjustment afterwards if necessary. Adjustments downwards shall be applied by subtracting the
number of days (according to the Gregorian calendar) in month tm_mon+1 of the year obtained by adding/subtracting any saved
increment/decrement of years to the value tm_year+1900, and then incrementing tm_mon by 1, repeated as necessary.
Adjustments upwards shall be applied by adding the number of days in the month before month tm_mon+1 of the year obtained by
adding/subtracting any saved increment/decrement of years to the value tm_year+1900, and then decrementing tm_mon by
1, repeated as necessary. During these adjustments, the tm_mon value shall be kept within the range 0 to 11, inclusive, by
applying step 4 as necessary.
If the tm_mday member is greater than the number of days in month tm_mon+1 of the year obtained by
adding/subtracting any saved increment/decrement of years to the value tm_year+1900, that number of days shall be subtracted
from tm_mday, and tm_mon shall be incremented by 1. If this results in tm_mon having the value 12, step 4
shall be applied.
The number of seconds since the Epoch in Coordinated Universal Time shall be calculated from the range-corrected values of the
relevant tm structure members (or the original value where a member was not range corrected) as specified in the expression
given in the definition of seconds since the Epoch (see XBD 4.19 Seconds Since
the Epoch), where the names other than tm_year and tm_yday in the structure and in the expression
correspond, the tm_year value used in the expression is the tm_year in the structure plus/minus any saved
increment/decrement of years, and the tm_yday value used in the expression is the day of the year from 0 to 365 inclusive,
calculated from the tm_mon and tm_mday members of the tm structure, for that year.
The time since the Epoch shall be corrected for the offset of the local timezone's standard time from Coordinated Universal
Time.
The time since the Epoch shall be further corrected (if applicable—see below) for Daylight Saving Time.
If the timezone is one that includes Daylight Saving Time (DST) adjustments, the value of tm_isdst in the tm
structure controls whether or not mktime() adjusts the calculated seconds since the Epoch value by the DST offset (after it
has made the timezone adjustment), as follows:
If tm_isdst is zero, mktime() shall not further adjust the seconds since the Epoch by the DST offset.
If tm_isdst is positive, mktime() shall further adjust the seconds since the Epoch by the DST offset.
If tm_isdst is negative, mktime() shall attempt to determine whether DST is in effect for the specified time; if
it determines that DST is in effect it shall produce the same result as an equivalent call with a positive tm_isdst value,
otherwise it shall produce the same result as an equivalent call with a tm_isdst value of zero. If the broken-down time
specifies a time that is either skipped over or repeated when a transition to or from DST occurs, it is unspecified whether
mktime() produces the same result as an equivalent call with a positive tm_isdst value or as an equivalent call with
a tm_isdst value of zero.
If the TZ environment variable specifies a geographical timezone for which the implementation's timezone database
includes historical or future changes to the offset from Coordinated Universal Time of the timezone's standard time, and the
broken-down time corresponds to a time that was (or will be) skipped over or repeated due to the occurrence of such a change,
mktime() shall calculate the time since the Epoch value using either the offset in effect before the change or the offset in
effect after the change.
Upon successful completion, the members of the structure shall be set to the values that would be returned by a call to localtime() with the calculated time since the Epoch as its argument.
RETURN VALUE
The mktime() function shall return the calculated time since the Epoch encoded as a value of type time_t. If the
time since the Epoch cannot be represented as a time_t [CX]   or the value to be returned in the tm_year member of the
structure pointed to by timeptr cannot be represented as an int,   the function shall return the value (time_t)-1 [CX]
and set errno to [EOVERFLOW], and shall not change
the value of the tm_wday component of the structure.
[CX]
Since (time_t)-1 is a valid return value for a successful call to mktime(), an application wishing to check for error
situations should set tm_wday to a value less than 0 or greater than 6 before calling mktime(). On return, if
tm_wday has not changed an error has occurred.
ERRORS
The mktime() function shall fail if:
[EOVERFLOW]
[CX]
The result cannot be represented.
The following sections are informative.
EXAMPLES
What day of the week is July 4, 2001?
#include
#include
struct tm time_str;
char daybuf[20];
int main(void)
{
time_str.tm_year = 2001 — 1900;
time_str.tm_mon = 7 — 1;
time_str.tm_mday = 4;
time_str.tm_hour = 0;
time_str.tm_min = 0;
time_str.tm_sec = 1;
time_str.tm_isdst = -1;
time_str.tm_wday = -1;
if (mktime(&time_str) == (time_t)-1 && time_str.tm_wday == -1)
(void)puts("-unknown-");
else {
(void)strftime(daybuf, sizeof(daybuf), "%A", &time_str);
(void)puts(daybuf);
}
return 0;
}
APPLICATION USAGE
When using mktime() to add or subtract a fixed time period (one that always corresponds to a fixed number of seconds) to
or from a broken-down time in the local timezone, reliable results for arbitrary TZ can only be assured by using
mktime() to convert the original broken-down time to a time since the Epoch, adding or subtracting the desired number of
seconds to that value, and then calling localtime() with the result. The
alternative of adjusting the broken-down time before calling mktime() may produce unexpected results if the original and
updated times are on different sides of a geographical timezone change. On implementations that follow the recommendation of not
range-correcting tm_sec (see step 1 in the DESCRIPTION), reliable results can also be assured by adding or subtracting the
desired number of seconds to tm_sec (and not modifying any other members of the tm structure). In applications
needing to be portable to non-POSIX systems where the time_t encoding is not a count of seconds, it is recommended that
conditional compilation is used such that the adjustment is performed on the mktime() return value when possible, and
otherwise on the tm_sec member. For timezones that are known not to have geographical timezone changes, such as
TZ=UTC0, adjustments using just mktime() do not have this problem.
The way the mktime() function interprets out-of-range tm structure fields might not produce the expected result
when multiple adjustments are made at the same time. For example, if an application tries to go back one day first and then one
year by calling localtime(), decrementing tm_mday and tm_year, and
then calling mktime() this would not produce the expected result if it was called on 2021-03-01 because mktime()
would see the supplied year as 2020 (a leap year) and correct Mar 0 to Feb 29, whereas the intended result was
Feb 28. Such issues can be avoided by doing multiple adjustments one at a time when the order in which they are done
matters.
Examples of how mktime() handles some adjustments are:
If given Feb 29 in a non-leap year it treats that as the day after Feb 28 and gives back Mar 1.
If given Feb 0 it treats that as the day before Feb 1 and gives back Jan 31.
If given 21:65 it treats that as 6 minutes after 21:59 and gives back 22:05.
If given tm_isdst=0 for a time when DST is in effect, it gives back a positive tm_isdst and alters the other
fields appropriately.
If there is a DST transition where 02:00 standard time becomes 03:00 DST and mktime() is given 02:30 (with negative
tm_isdst), it treats that as either 30 minutes after 02:00 standard time or 30 minutes before 03:00 DST and gives back a
zero or positive tm_isdst, respectively, with the tm_hour field altered appropriately.
If a geographical timezone changes its UTC offset such that "old 00:00" becomes "new 00:30" and mktime() is given
00:20, it treats that as either 20 minutes after "old 00:00" or 10 minutes before "new 00:30", and gives back appropriately
altered struct tm fields.
If an application wants to check whether a given broken-down time is one that is skipped over, it can do so by seeing whether
the tm_mday, tm_hour, and tm_min values it gets back from mktime() are the same ones it fed in. Just
checking tm_hour and tm_min might appear at first sight to suffice, but tm_mday could also change—without
tm_hour and tm_min changing—if, for example, TZ is set to "ABC12XYZ-12" (which might be used in a
torture test) or if a geographical timezone changes the offset from Coordinated Universal Time of its standard time by 24
hours.
RATIONALE
In order to allow applications to distinguish between a successful return of (time_t)-1 and an [EOVERFLOW] error,
mktime() is required not to change tm_wday on error. This mechanism is used rather than the convention used for other
functions whereby the application sets errno to zero before the call and the call does not change errno on error
because the ISO C standard does not require mktime() to set errno on error. The next revision of the ISO C
standard is expected to require that mktime() does not change tm_wday when returning (time_t)-1 to indicate an
error, and that this return convention is used both for the case where the value to be returned by the function cannot be
represented as a time_t and the case where the value to be returned in the tm_year member of the tm structure
cannot be represented as an int.
The DESCRIPTION section says that mktime() converts the specified broken-down time into a time since the
Epoch value. The use of the indefinite article here is necessary because, when tm_isdst is negative and the timezone has
Daylight Saving Time transitions, there is not a one-to-one correspondence between broken-down times and time since the Epoch
values.
The description of how the value of tm_isdst affects the behavior of mktime() is shaded CX because the
requirements in the ISO C standard are unclear. The next revision of the ISO C standard is expected to state the
requirements using wording equivalent to the wording in this standard.
Implementations are encouraged not to range-correct tm_sec (see step 1 in the DESCRIPTION) in order for the results of
making an adjustment to tm_sec always to be equivalent to making the same adjustment to the value returned by
mktime(), even when the original and updated times are on different sides of a geographical timezone change. This provides a
way for applications to do reliable fixed-period adjustment using only mktime(), as described in APPLICATION USAGE.
The described method for range-correcting the tm structure members uses separate variables to hold adjustment values to
be applied later to other members, or (for the year adjustment) used in later calculations, because this is one way of avoiding
intermediate member values that are not representable as an int. Implementations may use other methods; all that is required
is that tm_year is the only member for which an [EOVERFLOW] error can occur.
The described method for range-correcting tm_mday would, if implemented that way, be highly inefficient for very large
values. The efficiency can be improved by observing that any period of 400 years always has the same number of days, so the
month-by-month correction method need only be applied for a maximum of 4800 months.
FUTURE DIRECTIONS
A future version of this standard may require that mktime() does not perform the optional range correction of the
tm_sec member of the tm structure described at step 1 in the DESCRIPTION.
A future version of this standard is expected to add a timegm() function that is similar to mktime(), except that
the tm structure pointed to by timeptr contains a broken-down time in Coordinated Universal Time (rather than the
local timezone), where references to localtime() are replaced by references to
gmtime(), and where there are no timezone offset or Daylight Saving Time adjustments.
A combination of gmtime() and timegm() will be the expected way to perform
arithmetic upon a time_t value and remain compatible with the ISO C standard (where the internal structure of a
time_t is not specified), since attempting such manipulations using localtime() and mktime() can lead to unexpected results.
SEE ALSO
asctime(), clock(), ctime(), difftime(), futimens(), gmtime(), localtime(), strftime(), strptime(), time(), tzset()
XBD 4.19 Seconds Since the Epoch,
CHANGE HISTORY
First released in Issue 3. Included for alignment with the POSIX.1-1988 standard and the ANSI C standard.
Issue 6
Extensions beyond the ISO C standard are marked.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/58 is applied, updating the RETURN VALUE and ERRORS sections to
add the optional [EOVERFLOW] error as a CX extension.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/59 is applied, adding the tzset() function to the SEE ALSO section.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0393 [104] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0228 [724] is applied.
Issue 8
Austin Group Defect 1253 is applied, changing "Daylight Savings" to "Daylight Saving".
Austin Group Defect 1613 is applied, changing the way the tm structure members used by mktime() are specified and
clarifying that a successful call sets the members to the same values that would be returned by localtime().
Austin Group Defect 1614 is applied, clarifying how tm_isdst is handled and the conditions under which (time_t)-1
is returned.
Austin Group Defect 1627 is applied, clarifying how mktime() calculates the time in seconds since the Epoch from the
members of the tm structure.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wmemset.html =====
wmemset
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wmemset — set wide characters in memory
SYNOPSIS
#include
wchar_t *wmemset(wchar_t *ws, wchar_t wc, size_t n);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The wmemset() function shall copy the value of wc into each of the first n wide characters of the object
pointed to by ws. This function shall not be affected by locale and all wchar_t values shall be treated identically.
The null wide character and wchar_t values not corresponding to valid characters shall not be treated specially.
If n is zero, the application shall ensure that ws is a valid pointer, and the function shall copy zero wide
characters.
[CX]  The
wmemset() function shall not change the setting of errno on valid input.
RETURN VALUE
The wmemset() functions shall return the value of ws.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
wmemchr(), wmemcmp(), wmemcpy(), wmemmove()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E).
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that wmemset() does not change the setting of errno on
valid input.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atomic_flag_clear_explicit.html =====
atomic_flag_clear
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atomic_flag_clear, atomic_flag_clear_explicit — clear an atomic flag
SYNOPSIS
#include
void atomic_flag_clear(volatile atomic_flag *object);
void atomic_flag_clear_explicit(volatile atomic_flag *object,
memory_order order);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
Implementations that define the macro __STDC_NO_ATOMICS__ need not provide the  header nor support these generic functions.
The atomic_flag_clear_explicit() function shall atomically place the atomic flag pointed to by object into the
clear state. Memory shall be affected according to the value of order, which the application shall ensure is not
memory_order_acquire nor memory_order_acq_rel.
The atomic_flag_clear() function shall be equivalent to atomic_flag_clear_explicit() called with order set
to memory_order_seq_cst.
RETURN VALUE
These functions shall not return a value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD 4.15.1 Memory Ordering,
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getsubopt.html =====
getsubopt
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getsubopt — parse suboption arguments from a string
SYNOPSIS
[CX]  #include
int getsubopt(char **restrict optionp,
char * const *restrict keylistp, char **restrict valuep);
DESCRIPTION
The getsubopt() function shall parse suboption arguments in a flag argument. Such options often result from the use of
getopt().
The getsubopt() argument optionp is a pointer to a pointer to the option argument string. The suboption arguments
shall be separated by  characters and each may consist of either a single token, or a token-value pair separated by an
.
The keylistp argument shall be a pointer to a vector of strings. The end of the vector is identified by a null pointer.
Each entry in the vector is one of the possible tokens that might be found in *optionp. Since  characters
delimit suboption arguments in optionp, they should not appear in any of the strings pointed to by keylistp.
Similarly, because an  separates a token from its value, the application should not include an
in any of the strings pointed to by keylistp. The getsubopt() function shall not modify the
keylistp vector.
The valuep argument is the address of a value string pointer.
If a  appears in optionp, it shall be interpreted as a suboption separator. After  characters
have been processed, if there are one or more  characters in a suboption string, the first
in any suboption string shall be interpreted as a separator between a token and a value. Subsequent  characters
in a suboption string shall be interpreted as part of the value.
If the string at *optionp contains only one suboption argument (equivalently, no  characters),
getsubopt() shall update *optionp to point to the null character at the end of the string. Otherwise, it shall
isolate the suboption argument by replacing the  separator with a null character, and shall update *optionp to
point to the start of the next suboption argument. If the suboption argument has an associated value (equivalently, contains an
), getsubopt() shall update *valuep to point to the value's first character. Otherwise, it shall
set *valuep to a null pointer. The calling application may use this information to determine whether the presence or absence
of a value for the suboption is an error.
Additionally, when getsubopt() fails to match the suboption argument with a token in the keylistp array, the
calling application should decide if this is an error, or if the unrecognized option should be processed in another way.
RETURN VALUE
The getsubopt() function shall return the index of the matched token string, or -1 if no token strings were matched.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
Parsing Suboptions
The following example uses the getsubopt() function to parse a value argument in the optarg external
variable returned by a call to getopt().
#include
#include
#include
int do_all;
const char *type;
int read_size;
int write_size;
int read_only;
enum
{
RO_OPTION = 0,
RW_OPTION,
READ_SIZE_OPTION,
WRITE_SIZE_OPTION
};
const char *mount_opts[] =
{
[RO_OPTION] = "ro",
[RW_OPTION] = "rw",
[READ_SIZE_OPTION] = "rsize",
[WRITE_SIZE_OPTION] = "wsize",
NULL
};
int
main(int argc, char *argv[])
{
char *subopts, *value;
int opt;
while ((opt = getopt(argc, argv, "at:o:")) != -1)
switch(opt)
{
case 'a':
do_all = 1;
break;
case 't':
type = optarg;
break;
case 'o':
subopts = optarg;
while (*subopts != ' ')
{
char *saved = subopts;
switch(getsubopt(&subopts, (char **)mount_opts,
&value))
{
case RO_OPTION:
read_only = 1;
break;
case RW_OPTION:
read_only = 0;
break;
case READ_SIZE_OPTION:
if (value == NULL)
abort();
read_size = atoi(value);
break;
case WRITE_SIZE_OPTION:
if (value == NULL)
abort();
write_size = atoi(value);
break;
default:
/* Unknown suboption. */
printf("Unknown suboption `%s'\n", saved);
abort();
}
}
break;
default:
abort();
}
/* Do the real work. */
return 0;
}
If the above example is invoked with:
program -o ro,rsize=512
then after option parsing, the variable do_all will be 0, type will be a null pointer, read_size will be
512, write_size will be 0, and read_only will be 1. If it is invoked with:
program -o oops
it will print:
"Unknown suboption `oops'"
before aborting.
APPLICATION USAGE
The value of *valuep when getsubopt() returns -1 is unspecified. Historical implementations provide various
incompatible extensions to allow an application to access the suboption text that was not found in the keylistp array.
RATIONALE
The keylistp argument of getsubopt() is typed as char * const * to match historical practice. However, the
standard is clear that implementations will not modify either the array or the strings contained in the array, as if the argument
had been typed const char * const *.
FUTURE DIRECTIONS
None.
SEE ALSO
getopt()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/26 is applied, correcting an editorial error in the
SYNOPSIS.
Issue 7
The getsubopt() function is moved from the XSI option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0260 [196], XSH/TC1-2008/0261 [196], XSH/TC1-2008/0262 [196],
XSH/TC1-2008/0263 [196], XSH/TC1-2008/0264 [196], XSH/TC1-2008/0265 [196], XSH/TC1-2008/0266 [196], XSH/TC1-2008/0267 [196],
XSH/TC1-2008/0268 [196], and XSH/TC1-2008/0269 [196] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0174 [791] is applied.
Issue 8
Austin Group Defect 444 is applied, adding the restrict keyword to the getsubopt() prototype.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/remove.html =====
remove
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
remove — remove a file
SYNOPSIS
#include
int remove(const char *path);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The remove() function shall cause the file named by the pathname pointed to by path to be no longer accessible by
that name. A subsequent attempt to open that file using that name shall fail, unless it is created anew.
[CX]  If
path does not name a directory, remove(path) shall be equivalent to unlink(path).
If path names a directory, remove(path) shall be equivalent to rmdir(path).
RETURN VALUE
[CX]
Refer to rmdir() or unlink().
ERRORS
[CX]
Refer to rmdir() or unlink().
The following sections are informative.
EXAMPLES
Removing Access to a File
The following example shows how to remove access to a file named /home/cnd/old_mods.
#include
int status;
...
status = remove("/home/cnd/old_mods");
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
rmdir(), unlink()
XBD
CHANGE HISTORY
First released in Issue 3. Included for alignment with the POSIX.1-1988 standard and the ISO C standard.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The DESCRIPTION, RETURN VALUE, and ERRORS sections are updated so that if path is not a directory, remove() is
equivalent to unlink(), and if it is a directory, it is equivalent to rmdir().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/isdigit.html =====
isdigit
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
isdigit, isdigit_l — test for a decimal digit
SYNOPSIS
#include
int isdigit(int c);
[CX]  int isdigit_l(int c, locale_t locale);
DESCRIPTION
For isdigit(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The isdigit() [CX]   and isdigit_l()
functions shall test whether c is a character of class digit in the current locale, [CX]   or in the
locale represented by locale,  respectively; see XBD 7. Locale.
The c argument is an int, the value of which the application shall ensure is a character representable as an
unsigned char or equal to the value of the macro EOF. If the argument has any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to isdigit_l() is the special locale object LC_GLOBAL_LOCALE or is not a
valid locale object handle.
RETURN VALUE
The isdigit() [CX]   and isdigit_l()
functions shall return non-zero if c is a decimal digit; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
isalnum(), isalpha(), isblank(), iscntrl(), isgraph(), islower(), isprint(), ispunct(), isspace(), isupper(), isxdigit()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The isdigit_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0286 [302], XSH/TC1-2008/0287 [283], and XSH/TC1-2008/0288 [283] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/srandom.html =====
initstate
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
initstate, random, setstate, srandom — pseudo-random number functions
SYNOPSIS
[XSI]  #include
char *initstate(unsigned seed, char *state, size_t size);
long random(void);
char *setstate(char *state);
void srandom(unsigned seed);
DESCRIPTION
The random() function shall use a non-linear additive feedback random-number generator employing a default state array
size of 31 long integers to return successive pseudo-random numbers in the range from 0 to 231-1.
The period of this random-number generator is approximately 16 x (231-1). The size of the state array
determines the period of the random-number generator. Increasing the state array size shall increase the period.
With 256 bytes of state information, the period of the random-number generator shall be greater than
269.
Like rand(), random() shall produce by default a sequence of numbers that can
be duplicated by calling srandom() with 1 as the seed.
The srandom() function shall initialize the current state array using the value of seed.
The initstate() and setstate() functions handle restarting and changing random-number generators. The
initstate() function allows a state array, pointed to by the state argument, to be initialized for future use. The
size argument, which specifies the size in bytes of the state array, shall be used by initstate() to decide what type
of random-number generator to use; the larger the state array, the more random the numbers. Values for the amount of state
information are 8, 32, 64, 128, and 256 bytes. Other values greater than 8 bytes are rounded down to the nearest one of these
values. If initstate() is called with 8
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
In the DESCRIPTION, the phrase "values smaller than 8" is replaced with "values greater than or equal to 8, or less than
32", "size>>
===== susv5-html/functions/confstr.html =====
confstr
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
confstr — get configurable variables
SYNOPSIS
#include
size_t confstr(int name, char *buf, size_t len);
DESCRIPTION
The confstr() function shall return configuration-defined string values. Its use and purpose are similar to sysconf(), but it is used where string values rather than numeric values are returned.
The name argument represents the system variable to be queried. The implementation shall support the following name
values, defined in . It may support others:
_CS_PATH
_CS_POSIX_V8_ILP32_OFF32_CFLAGS
_CS_POSIX_V8_ILP32_OFF32_LDFLAGS
_CS_POSIX_V8_ILP32_OFF32_LIBS
_CS_POSIX_V8_ILP32_OFFBIG_CFLAGS
_CS_POSIX_V8_ILP32_OFFBIG_LDFLAGS
_CS_POSIX_V8_ILP32_OFFBIG_LIBS
_CS_POSIX_V8_LP64_OFF64_CFLAGS
_CS_POSIX_V8_LP64_OFF64_LDFLAGS
_CS_POSIX_V8_LP64_OFF64_LIBS
_CS_POSIX_V8_LPBIG_OFFBIG_CFLAGS
_CS_POSIX_V8_LPBIG_OFFBIG_LDFLAGS
_CS_POSIX_V8_LPBIG_OFFBIG_LIBS
_CS_POSIX_V8_THREADS_CFLAGS
_CS_POSIX_V8_THREADS_LDFLAGS
_CS_POSIX_V8_WIDTH_RESTRICTED_ENVS
_CS_V8_ENV
[OB]
_CS_POSIX_V7_ILP32_OFF32_CFLAGS
_CS_POSIX_V7_ILP32_OFF32_LDFLAGS
_CS_POSIX_V7_ILP32_OFF32_LIBS
_CS_POSIX_V7_ILP32_OFFBIG_CFLAGS
_CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS
_CS_POSIX_V7_ILP32_OFFBIG_LIBS
_CS_POSIX_V7_LP64_OFF64_CFLAGS
_CS_POSIX_V7_LP64_OFF64_LDFLAGS
_CS_POSIX_V7_LP64_OFF64_LIBS
_CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS
_CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS
_CS_POSIX_V7_LPBIG_OFFBIG_LIBS
_CS_POSIX_V7_THREADS_CFLAGS
_CS_POSIX_V7_THREADS_LDFLAGS
_CS_POSIX_V7_WIDTH_RESTRICTED_ENVS
_CS_V7_ENV
If len is not 0, and if name has a configuration-defined value, confstr() shall copy that value into the
len-byte buffer pointed to by buf. If the string to be returned is longer than len bytes, including the
terminating null, then confstr() shall truncate the string to len-1 bytes and null-terminate the result. The
application can detect that the string was truncated by comparing the value returned by confstr() with len.
If len is 0 and buf is a null pointer, then confstr() shall still return the integer value as defined
below, but shall not return a string. If len is 0 but buf is not a null pointer, the result is unspecified.
After a call to:
confstr(_CS_V8_ENV, buf, sizeof(buf))
the string stored in buf shall contain a -separated list of the variable=value environment variable pairs an
implementation requires as part of specifying a conforming environment, as described in the implementations' conformance
documentation.
If the implementation supports the POSIX shell option, the string stored in buf after a call to:
confstr(_CS_PATH, buf, sizeof(buf))
can be used as a value of the PATH environment variable that accesses all of the standard utilities of POSIX.1-2024, that
are provided in a manner accessible via the exec family of functions, if the return
value is less than or equal to sizeof(buf).
RETURN VALUE
If name has a configuration-defined value, confstr() shall return the size of buffer that would be needed to hold
the entire configuration-defined value including the terminating null. If this return value is greater than len, the string
returned in buf is truncated.
If name is invalid, confstr() shall return 0 and set errno to indicate the error.
If name does not have a configuration-defined value, confstr() shall return 0 and leave errno
unchanged.
ERRORS
The confstr() function shall fail if:
[EINVAL]
The value of the name argument is invalid.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
An application can distinguish between an invalid name parameter value and one that corresponds to a configurable
variable that has no configuration-defined value by checking if errno is modified. This mirrors the behavior of sysconf().
The original need for this function was to provide a way of finding the configuration-defined default value for the environment
variable PATH . Since PATH can be modified by the user to include directories that could contain utilities replacing
the standard utilities in the Shell and Utilities volume of POSIX.1-2024, applications need a way to determine the system-supplied
PATH environment variable value that contains the correct search path for the standard utilities.
An application could use:
confstr(name, (char *)NULL, (size_t)0)
to find out how big a buffer is needed for the string value; use malloc() to
allocate a buffer to hold the string; and call confstr() again to get the string. Alternately, it could allocate a fixed,
static buffer that is big enough to hold most answers (perhaps 512 or 1024 bytes), but then use malloc() to allocate a larger buffer if it finds that this is too small.
RATIONALE
Application developers can normally determine any configuration variable by means of reading from the stream opened by a call
to:
popen("command -p getconf variable", "r");
The confstr() function with a name argument of _CS_PATH returns a string that can be used as a PATH
environment variable setting that will reference the standard shell and utilities as described in the Shell and Utilities volume of
POSIX.1-2024.
The confstr() function copies the returned string into a buffer supplied by the application instead of returning a
pointer to a string. This allows a cleaner function in some implementations (such as those with lightweight threads) and resolves
questions about when the application must copy the string returned.
FUTURE DIRECTIONS
None.
SEE ALSO
exec, fpathconf(), sysconf()
XBD
XCU c17
CHANGE HISTORY
First released in Issue 4. Derived from the ISO POSIX-2 standard.
Issue 5
A table indicating the permissible values of name is added to the DESCRIPTION. All those marked EX are new in this
version.
Issue 6
The Open Group Corrigendum U033/7 is applied. The return value for the case returning the size of the buffer now explicitly
states that this includes the terminating null.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The DESCRIPTION is updated with new arguments which can be used to determine configuration strings for C compiler flags,
linker/loader flags, and libraries for each different supported programming environment. This is a change to support data size
neutrality.
The following changes were made to align with the IEEE P1003.1a draft standard:
The DESCRIPTION is updated to include text describing how _CS_PATH can be used to obtain a PATH to access the standard
utilities.
The macros associated with the c89 programming models are marked LEGACY and new equivalent macros associated with
c99 are introduced.
Issue 7
Austin Group Interpretation 1003.1-2001 #047 is applied, adding the _CS_V7_ENV variable.
Austin Group Interpretations 1003.1-2001 #166 is applied to permit an additional compiler flag to enable threads.
The V6 variables for the supported programming environments are marked obsolescent.
The variables for the supported programming environments are updated to be V7.
The LEGACY variables and obsolescent values are removed.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0070 [810] and XSH/TC2-2008/0071 [911] are applied.
Issue 8
Austin Group Defect 1330 is applied, changing "_V7_" to "_V8_" and "_V6_" to "_V7_".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/cprojl.html =====
cproj
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cproj, cprojf, cprojl — complex projection functions
SYNOPSIS
#include
double complex cproj(double complex z);
float complex cprojf(float complex z);
long double complex cprojl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute a projection of z onto the Riemann sphere: z projects to z, except that all
complex infinities (even those with one infinite part and one NaN part) project to positive infinity on the real axis. If z
has an infinite part, then cproj(z) shall be equivalent to:
INFINITY + I * copysign(0.0, cimag(z))
RETURN VALUE
These functions shall return the value of the projection onto the Riemann sphere.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
Two topologies are commonly used in complex mathematics: the complex plane with its continuum of infinities, and the Riemann
sphere with its single infinity. The complex plane is better suited for transcendental functions, the Riemann sphere for algebraic
functions. The complex types with their multiplicity of infinities provide a useful (though imperfect) model for the complex plane.
The cproj() function helps model the Riemann sphere by mapping all infinities to one, and should be used just before any
operation, especially comparisons, that might give spurious results for any of the other infinities. Note that a complex value with
one infinite part and one NaN part is regarded as an infinity, not a NaN, because if one part is infinite, the complex value is
infinite independent of the value of the other part. For the same reason, cabs()
returns an infinity if its argument has an infinite part and a NaN part.
FUTURE DIRECTIONS
None.
SEE ALSO
carg(), cimag(), conj(), creal()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/kill_dependency.html =====
kill_dependency
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
kill_dependency — terminate a dependency chain
SYNOPSIS
#include
type kill_dependency(type *y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
Implementations that define the macro __STDC_NO_ATOMICS__ need not provide the  header nor support the kill_dependency() macro.
The kill_dependency() macro shall terminate a dependency chain (see XBD 4.15.1 Memory Ordering). The argument shall not carry a dependency to the
return value.
RETURN VALUE
The kill_dependency() macro shall return the value of y.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD 4.15.1 Memory Ordering,
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sqrtl.html =====
sqrt
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sqrt, sqrtf, sqrtl — square root function
SYNOPSIS
#include
double sqrt(double x);
float sqrtf(float x);
long double sqrtl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the square root of their argument \(x\),
\(\sqrt{x}\).
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the square root of \(x\).
[MX]  The
returned value shall be dependent on the current rounding direction mode.
For finite values of \(x\)
...
double x = 9.0;
double result;
...
result = sqrt(x);
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are
independent of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept, fetestexcept, isnan
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The sqrtf() and sqrtl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0588 [320] is applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/freopen.html =====
freopen
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
freopen — open a stream
SYNOPSIS
#include
FILE *freopen(const char *restrict pathname, const char *restrict mode,
FILE *restrict stream);
DESCRIPTION
[CX]  Except for the "exclusive access" requirement (see fopen()), the
functionality described on this reference page is aligned with the ISO C standard. Any other conflict between the requirements
described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C standard for all
freopen() functionality except in relation to "exclusive access".
The freopen() function shall first attempt to flush the stream associated with stream as if by a call to
fflush(stream). Failure to flush the stream successfully shall be ignored. If pathname is not a null pointer,
freopen() shall close any file descriptor associated with stream. Failure to close the file descriptor successfully
shall be ignored. The error and end-of-file indicators for the stream shall be cleared.
The freopen() function shall open the file whose pathname is the string pointed to by pathname and associate the
stream pointed to by stream with it. The mode argument shall be used just as in fopen().
The original stream shall be closed regardless of whether the subsequent open succeeds.
If pathname is a null pointer, the freopen() function shall attempt to change the mode of the stream to that
specified by mode, as if the name of the file currently associated with the stream had been used. In this case, the file
descriptor associated with the stream need not be closed if the call to freopen() succeeds. It is implementation-defined
which changes of mode are permitted (if any), and under what circumstances.
After a successful call to the freopen() function, the orientation of the stream shall be cleared, [XSI]   the encoding
rule shall be cleared,  and the associated mbstate_t object
shall be set to describe an initial conversion state.
[CX]  If
pathname is not a null pointer, or if pathname is a null pointer and the specified mode change necessitates the file
descriptor associated with the stream to be closed and reopened, the file descriptor associated with the reopened stream shall be
allocated and opened as if by a call to open() with the flags specified for fopen() with the same mode argument.
RETURN VALUE
Upon successful completion, freopen() shall return the value of stream. Otherwise, a null pointer shall be
returned, [CX]   and errno shall be set to indicate the error.
ERRORS
The freopen() function shall fail if:
[EACCES]
[CX]
Search permission is denied on a component of the path prefix, or the file exists and the permissions specified by mode are
denied, or the file does not exist and write permission is denied for the parent directory of the file to be created.
[EBADF]
[CX]
The file descriptor underlying the stream is not a valid file descriptor when pathname is a null pointer.
[EILSEQ]
[CX]
The mode argument begins with w or a, the file did not previously exist, and the last pathname component is
not a portable filename and cannot be created in the target directory.
[EEXIST]
[CX]
The mode argument begins with w or a and includes x, but the file already exists.
[EINTR]
[CX]  A
signal was caught during freopen().
[EISDIR]
[CX]
The named file is a directory and mode requires write access.
[ELOOP]
[CX]  A
loop exists in symbolic links encountered during resolution of the pathname argument.
[EMFILE]
[CX]
All file descriptors available to the process are currently open.
[ENAMETOOLONG]
[CX]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENFILE]
[CX]
The maximum allowable number of files is currently open in the system.
[ENOENT]
[CX]
The mode string begins with 'r' and a component of pathname does not name an existing file, or mode
begins with 'w' or 'a' and a component of the path prefix of pathname does not name an existing file, or
pathname is an empty string.
[ENOENT] or [ENOTDIR]
[CX]
The pathname argument contains at least one non- character and ends with one or more trailing
characters. If pathname without the trailing  characters would name an existing file, an [ENOENT] error shall
not occur.
[ENOSPC]
[CX]
The directory or file system that would contain the new file cannot be expanded, the file does not exist, and it was to be created.
[ENOTDIR]
[CX]  A
component of the path prefix names an existing file that is neither a directory nor a symbolic link to a directory, or the
pathname argument contains at least one non- character and ends with one or more trailing
characters and the last pathname component names an existing file that is neither a directory nor a symbolic link to a directory.
[ENXIO]
[CX]
The named file is a character special or block special file, and the device associated with this special file does not exist.
[EOVERFLOW]
[CX]
The named file is a regular file and the size of the file cannot be represented correctly in an object of type off_t.
[EROFS]
[CX]
The named file resides on a read-only file system and mode requires write access.
The freopen() function may fail if:
[EBADF]
[CX]
The mode with which the file descriptor underlying the stream was opened does not support the requested mode when pathname
is a null pointer.
[EINVAL]
[CX]
The value of the mode argument is not valid.
[ELOOP]
[CX]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the pathname argument.
[ENAMETOOLONG]
[CX]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
[ENOMEM]
[CX]
Insufficient storage space is available.
[ENXIO]
[CX]  A
request was made of a nonexistent device, or the request was outside the capabilities of the device.
[ETXTBSY]
[CX]
The file is a pure procedure (shared text) file that is being executed and mode requires write access.
The following sections are informative.
EXAMPLES
Directing Standard Output to a File
The following example logs all standard output to the /tmp/logfile file.
#include
...
FILE *fp;
...
fp = freopen ("/tmp/logfile", "a+", stdout);
...
APPLICATION USAGE
The freopen() function is typically used to attach the pre-opened streams associated with stdin,
stdout, and stderr to other files.
Since implementations are not required to support any stream mode changes when the pathname argument is NULL, portable
applications cannot rely on the use of freopen() to change the stream mode, and use of this feature is discouraged. The
feature was originally added to the ISO C standard in order to facilitate changing stdin and stdout to binary
mode. Since a 'b' character in the mode has no effect on POSIX systems, this use of the feature is unnecessary in POSIX
applications. However, even though the 'b' is ignored, a successful call to freopen(NULL, "wb",
stdout) does have an effect. In particular, for regular files it truncates the file and sets the file-position indicator for
the stream to the start of the file. It is possible that these side-effects are an unintended consequence of the way the feature
was specified in the ISO/IEC 9899:1999 standard (and still is in the current standard), but unless or until the ISO C
standard is changed, applications which successfully call freopen(NULL, "wb", stdout) will behave in
unexpected ways on conforming systems in situations such as:
{ appl file1; appl file2; } > file3
which will result in file3 containing only the output from the second invocation of appl.
See also the APPLICATION USAGE for fopen().
RATIONALE
See the RATIONALE for fopen().
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fclose(), fdopen(), fflush(), fmemopen(), fopen(), mbsinit(), open(), open_memstream()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate that the orientation of the stream is cleared and the conversion state of the stream is
set to an initial conversion state by a successful call to the freopen() function.
Large File Summit extensions are added.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the DESCRIPTION, text is added to indicate setting of the offset maximum in the open file description. This change is to
support large files.
In the ERRORS section, the [EOVERFLOW] condition is added. This change is to support large files.
The [ELOOP] mandatory error condition is added.
A second [ENAMETOOLONG] is added as an optional error condition.
The [EINVAL], [ENOMEM], [ENXIO], and [ETXTBSY] optional error conditions are added.
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The freopen() prototype is updated.
The DESCRIPTION is updated.
The wording of the mandatory [ELOOP] error condition is updated, and a second optional [ELOOP] error condition is added.
The DESCRIPTION is updated regarding failure to close, changing the "file" to "file descriptor".
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/40 is applied, adding the following sentence to the DESCRIPTION:
"In this case, the file descriptor associated with the stream need not be closed if the call to freopen() succeeds.".
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/41 is applied, adding an mandatory [EBADF] error, and an
optional [EBADF] error to the ERRORS section.
Issue 7
Austin Group Interpretation 1003.1-2001 #043 is applied, clarifying that the freopen() function allocates a file
descriptor as per open().
Austin Group Interpretation 1003.1-2001 #143 is applied.
Austin Group Interpretation 1003.1-2001 #159 is applied, clarifying requirements for the flags set on the open file
description.
SD5-XBD-ERN-4 is applied, changing the definition of the [EMFILE] error.
SD5-XSH-ERN-150 and SD5-XSH-ERN-219 are applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0181 [291,433], XSH/TC1-2008/0182 [146,433], XSH/TC1-2008/0183 [324], and
XSH/TC1-2008/0184 [14] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0134 [822] is applied.
Issue 8
Austin Group Defect 293 is applied, adding the [EILSEQ] error.
Austin Group Defect 411 is applied, adding the e and x mode string characters.
Austin Group Defect 1200 is applied, correcting the argument name in the [ELOOP] errors.
Austin Group Defect 1302 is applied, aligning this function with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/msgctl.html =====
msgctl
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
msgctl — XSI message control operations
SYNOPSIS
[XSI]  #include
int msgctl(int msqid, int cmd, struct msqid_ds *buf);
DESCRIPTION
The msgctl() function operates on XSI message queues (see XBD 3.206
Message Queue). It is unspecified whether this function interoperates with the realtime interprocess communication
facilities defined in 2.8 Realtime.
The msgctl() function shall provide message control operations as specified by cmd. The following values for
cmd, and the message control operations they specify, are:
IPC_STAT
Place the current value of each member of the msqid_ds data structure associated with msqid into the structure
pointed to by buf. The contents of this structure are defined in .
IPC_SET
Set the value of the following members of the msqid_ds data structure associated with msqid to the corresponding
value found in the structure pointed to by buf:
msg_perm.uid
msg_perm.gid
msg_perm.mode
msg_qbytes
Also, the msg_ctime timestamp shall be set to the current time, as described in 2.7.1 IPC General Description.
IPC_SET can only be executed by a process with appropriate privileges or that has an effective user ID equal to the value of
msg_perm.cuid or msg_perm.uid in the msqid_ds data structure associated with msqid. Only a process with
appropriate privileges can raise the value of msg_qbytes.
IPC_RMID
Remove the message queue identifier specified by msqid from the system and destroy the message queue and msqid_ds
data structure associated with it. IPC_RMD can only be executed by a process with appropriate privileges or one that has an
effective user ID equal to the value of msg_perm.cuid or msg_perm.uid in the msqid_ds data structure
associated with msqid.
RETURN VALUE
Upon successful completion, msgctl() shall return 0; otherwise, it shall return -1 and set errno to indicate the
error.
ERRORS
The msgctl() function shall fail if:
[EACCES]
The argument cmd is IPC_STAT and the calling process does not have read permission; see 2.7 XSI Interprocess Communication.
[EINVAL]
The value of msqid is not a valid message queue identifier; or the value of cmd is not a valid command.
[EPERM]
The argument cmd is IPC_RMID or IPC_SET and the effective user ID of the calling process is not equal to that of a
process with appropriate privileges and it is not equal to the value of msg_perm.cuid or msg_perm.uid in the data
structure associated with msqid.
[EPERM]
The argument cmd is IPC_SET, an attempt is being made to increase to the value of msg_qbytes, and the effective
user ID of the calling process does not have appropriate privileges.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The POSIX Realtime Extension defines alternative interfaces for interprocess communication (IPC). Application developers who
need to use IPC should design their applications so that modules using the IPC routines described in 2.7 XSI Interprocess Communication can be easily modified to use the alternative
interfaces.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.7 XSI Interprocess Communication, 2.8 Realtime, mq_close(),
mq_getattr(), mq_notify(),
mq_open(), mq_receive(),
mq_send(), mq_setattr(),
mq_unlink(), msgget(), msgrcv(), msgsnd()
XBD 3.206 Message Queue,
CHANGE HISTORY
First released in Issue 2. Derived from Issue 2 of the SVID.
Issue 5
The note about use of POSIX Realtime Extension IPC routines has been moved from FUTURE DIRECTIONS to a new APPLICATION USAGE
section.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0395 [345] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/openat.html =====
open
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
open, openat — open file
SYNOPSIS
[OH] #include
#include
int open(const char *path, int oflag, ...);
int openat(int fd, const char *path, int oflag, ...);
DESCRIPTION
The open() function shall establish the connection between a file and a file descriptor. It shall create an open file
description that refers to a file and a file descriptor that refers to that open file description. The file descriptor is used by
other I/O functions to refer to that file. The path argument points to a pathname naming the file.
The open() function shall return a file descriptor for the named file, allocated as described in 2.6 File Descriptor Allocation. The open file description is new, and therefore
the file descriptor shall not share it with any other process in the system. The FD_CLOEXEC file descriptor flag associated with
the new file descriptor shall be cleared unless the O_CLOEXEC flag is set in oflag. The FD_CLOFORK file descriptor flag
associated with the new file descriptor shall be cleared unless the O_CLOFORK flag is set in oflag.
The file offset used to mark the current position within the file shall be set to the beginning of the file.
The file status flags and file access modes of the open file description shall be set according to the value of
oflag.
Values for oflag are constructed by a bitwise-inclusive OR of flags from the following list, defined in . Applications shall specify exactly one of the first five values (file access
modes) below in the value of oflag:
O_EXEC
Open for execute only (non-directory files). If path names a directory and O_EXEC is not the same value as O_SEARCH,
open() shall fail.
O_RDONLY
Open for reading only.
O_RDWR
Open for reading and writing. If path names a FIFO, and the implementation does not support opening a FIFO for
simultaneous read and write, then open() shall fail.
O_SEARCH
Open directory for search only. If path names a non-directory file and O_SEARCH is not the same value as O_EXEC,
open() shall fail.
O_WRONLY
Open for writing only.
Any combination of the following may be used:
O_APPEND
If set, the file offset shall be set to the end of the file prior to each write.
O_CLOEXEC
If set, the FD_CLOEXEC flag for the new file descriptor shall be set.
O_CLOFORK
If set, the FD_CLOFORK flag for the new file descriptor shall be set.
O_CREAT
If the file exists, this flag has no effect except as noted under O_EXCL below. Otherwise, if O_DIRECTORY is not set the file
shall be created as a regular file; the user ID of the file shall be set to the effective user ID of the process; the group ID of
the file shall be set to the group ID of the file's parent directory or to the effective group ID of the process; and the access
permission bits (see ) of the file mode shall be set to the
value of the argument following the oflag argument taken as type mode_t modified as follows: a bitwise AND is
performed on the file-mode bits and the corresponding bits in the complement of the process' file mode creation mask. Thus, all
bits in the file mode whose corresponding bit in the file mode creation mask is set are cleared. When bits other than the file
permission bits are set, the effect is unspecified. The argument following the oflag argument does not affect whether the
file is open for reading, writing, or for both. Implementations shall provide a way to initialize the file's group ID to the group
ID of the parent directory. Implementations may, but need not, provide an implementation-defined way to initialize the file's group
ID to the effective group ID of the calling process.
O_DIRECTORY
If path resolves to a non-directory file, fail and set errno to [ENOTDIR].
O_DSYNC
[SIO]
Write I/O operations on the file descriptor shall complete as defined by synchronized I/O data integrity completion.
O_EXCL
If O_CREAT and O_EXCL are set, open() shall fail if the file exists. The check for the existence of the file and the
creation of the file if it does not exist shall be atomic with respect to other threads executing open() naming the same
filename in the same directory with O_EXCL and O_CREAT set. If O_EXCL and O_CREAT are set, and path names a symbolic link,
open() shall fail and set errno to [EEXIST], regardless of the contents of the symbolic link. If O_EXCL is set and
O_CREAT is not set, the result is undefined.
O_NOCTTY
If set and path identifies a terminal device, open() shall not cause the terminal device to become the
controlling terminal for the process. If path does not identify a terminal device, O_NOCTTY shall be ignored.
O_NOFOLLOW
If path names a symbolic link, fail and set errno to [ELOOP].
O_NONBLOCK
When opening a FIFO with O_RDONLY or O_WRONLY set:
If O_NONBLOCK is set, an open() for reading-only shall return without delay. An open() for writing-only shall
return an error if no process currently has the file open for reading.
If O_NONBLOCK is clear, an open() for reading-only shall block the calling thread until a thread opens the file for
writing. An open() for writing-only shall block the calling thread until a thread opens the file for reading.
When opening a block special or character special file that supports non-blocking opens:
If O_NONBLOCK is set, the open() function shall return without blocking for the device to be ready or available.
Subsequent behavior of the device is device-specific.
If O_NONBLOCK is clear, the open() function shall block the calling thread until the device is ready or available before
returning.
Otherwise, the O_NONBLOCK flag shall not cause an error, but it is unspecified whether the file status flags will include the
O_NONBLOCK flag.
O_RSYNC
[SIO]
Read I/O operations on the file descriptor shall complete at the same level of integrity as specified by the O_DSYNC and O_SYNC
flags. If both O_DSYNC and O_RSYNC are set in oflag, all I/O operations on the file descriptor shall complete as defined by
synchronized I/O data integrity completion. If both O_SYNC and O_RSYNC are set in flags, all I/O operations on the file descriptor
shall complete as defined by synchronized I/O file integrity completion.
O_SYNC
[XSI|SIO]  Write I/O operations on the file descriptor shall complete as defined by synchronized I/O file integrity completion.
[XSI]
The O_SYNC flag shall be supported for regular files, even if the Synchronized Input and Output option is not supported.
O_TRUNC
If the file exists and is a regular file, and the file is successfully opened O_RDWR or O_WRONLY, its length shall be truncated
to 0, and the mode and owner shall be unchanged. It shall have no effect on FIFO special files or terminal device files. Its effect
on other file types is implementation-defined. The result of using O_TRUNC without either O_RDWR or O_WRONLY is undefined.
O_TTY_INIT
If path identifies a terminal device other than a pseudo-terminal, the device is not already open in any process, and
either O_TTY_INIT is set in oflag or O_TTY_INIT has the value zero, open() shall set any non-standard termios
structure terminal parameters to a state that provides conforming behavior (see XBD 11.2 Parameters that Can be Set) and initialize the winsize structure
associated with the terminal to appropriate default settings. It is unspecified whether O_TTY_INIT has any effect if the device is
already open in any process. If path identifies the subsidiary side of a pseudo-terminal that is not already open in any
process, open() shall set any non-standard termios structure terminal parameters to a state that provides conforming
behavior and initialize the winsize structure associated with the terminal to appropriate default settings, regardless of
whether O_TTY_INIT is set. If path does not identify a terminal device, O_TTY_INIT shall be ignored.
If O_CREAT and O_DIRECTORY are set and the requested access mode is neither O_WRONLY nor O_RDWR, the result is unspecified.
If O_CREAT is set and the file did not previously exist, upon successful completion, open() shall mark for update the
last data access, last data modification, and last file status change timestamps of the file and the last data modification and
last file status change timestamps of the parent directory.
If O_TRUNC is set and the file did previously exist, upon successful completion, open() shall mark for update the last
data modification and last file status change timestamps of the file.
[SIO]
If both the O_SYNC and O_DSYNC flags are set, the effect is as if only the O_SYNC flag was set.
The application shall ensure that it specifies the O_TTY_INIT flag on the first open of a terminal device since system boot or
since the device was closed by the process that last had it open. The application need not specify the O_TTY_INIT flag when opening
pseudo-terminals. [XSI]   If path names the manager side of a pseudo-terminal device, then it is unspecified
whether open() locks the subsidiary side so that it cannot be opened. Conforming applications shall call unlockpt() before opening the subsidiary side.
The largest value that can be represented correctly in an object of type off_t shall be established as the offset maximum
in the open file description.
The openat() function shall be equivalent to the open() function except in the case where path specifies a
relative path. In this case the file to be opened is determined relative to the directory associated with the file descriptor
fd instead of the current working directory. If the access mode of the open file description associated with the file
descriptor is not O_SEARCH, the function shall check whether directory searches are permitted using the current permissions of the
directory underlying the file descriptor. If the access mode is O_SEARCH, the function shall not perform the check.
The oflag parameter and the optional fourth parameter correspond exactly to the parameters of open().
If openat() is passed the special value AT_FDCWD in the fd parameter, the current working directory shall be used
and the behavior shall be identical to a call to open().
RETURN VALUE
Upon successful completion, these functions shall open the file and return a non-negative integer representing the file
descriptor. Otherwise, these functions shall return -1 and set errno to indicate the error. If -1 is returned, no files
shall be created or modified.
ERRORS
These functions shall fail if:
[EACCES]
Search permission is denied on a component of the path prefix, or the file exists and the permissions specified by oflag
are denied, or the file does not exist and write permission is denied for the parent directory of the file to be created, or
O_TRUNC is specified and write permission is denied.
[EEXIST]
O_CREAT and O_EXCL are set, and the named file exists.
[EILSEQ]
O_CREAT was specified, the file did not exist, and the last pathname component of path is not a portable filename and
cannot be created in the target directory.
[EINTR]
A signal was caught during open().
[EINVAL]
The path argument names a FIFO, O_RDWR was specified, and the implementation considers this an error; [SIO]   or
synchronized I/O flags were specified and the implementation does not support synchronized I/O for the file.
[EISDIR]
The named file is a directory and oflag includes O_WRONLY or O_RDWR, or includes O_CREAT without O_DIRECTORY, or
includes O_EXEC when O_EXEC is not the same value as O_SEARCH.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path argument, or O_NOFOLLOW was specified and the
path argument names a symbolic link.
[EMFILE]
All file descriptors available to the process are currently open.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENFILE]
The maximum allowable number of files is currently open in the system.
[ENOENT]
O_CREAT is not set and a component of path does not name an existing file, or O_CREAT is set and a component of the path
prefix of path does not name an existing file, or path points to an empty string.
[ENOENT] or [ENOTDIR]
O_CREAT is set, and the path argument contains at least one non- character and ends with one or more trailing
characters. If path without the trailing  characters would name an existing file, an [ENOENT]
error shall not occur.
[ENOSPC]
The directory or file system that would contain the new file cannot be expanded, the file does not exist, and O_CREAT is
specified.
[ENOTDIR]
A component of the path prefix names an existing file that is neither a directory nor a symbolic link to a directory; or
O_CREAT and O_EXCL are not specified, the path argument contains at least one non- character and ends with one
or more trailing  characters, and the last pathname component names an existing file that is neither a directory nor a
symbolic link to a directory; or O_DIRECTORY was specified and the path argument names a non-directory file; or the
path argument names a non-directory file and O_SEARCH was specified when O_SEARCH is not the same value as O_EXEC.
[ENXIO]
O_NONBLOCK is set, the named file is a FIFO, O_WRONLY is set, and no process has the file open for reading.
[ENXIO]
The named file is a character special or block special file, and the device associated with this special file does not
exist.
[EOVERFLOW]
The named file is a regular file and the size of the file cannot be represented correctly in an object of type
off_t.
[EROFS]
The named file resides on a read-only file system and either O_WRONLY, O_RDWR, O_CREAT (if the file does not exist), or O_TRUNC
is set in the oflag argument.
The openat() function shall fail if:
[EACCES]
The access mode of the open file description associated with fd is not O_SEARCH and the permissions of the directory
underlying fd do not permit directory searches.
[EBADF]
The path argument does not specify an absolute path and the fd argument is neither AT_FDCWD nor a valid file
descriptor open for reading or searching.
[ENOTDIR]
The path argument is not an absolute path and fd is a file descriptor associated with a non-directory file.
These functions may fail if:
[EAGAIN]
[XSI]
The path argument names the subsidiary side of a pseudo-terminal device that is locked.
[EINVAL]
The value of the oflag argument is not valid.
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
[EOPNOTSUPP]
The path argument names a socket.
[ETXTBSY]
The file is a pure procedure (shared text) file that is being executed and oflag is O_WRONLY or O_RDWR.
The following sections are informative.
EXAMPLES
Opening a File for Writing by the Owner
The following example opens the file /tmp/file, either by creating it (if it does not already exist), or by truncating
its length to 0 (if it does exist). In the former case, if the call creates a new file, the access permission bits in the file mode
of the file are set to permit reading and writing by the owner, and to permit reading only by group members and others.
If the call to open() is successful, the file is opened for writing.
#include
...
int fd;
mode_t mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
char *pathname = "/tmp/file";
...
fd = open(pathname, O_WRONLY | O_CREAT | O_TRUNC, mode);
...
Opening a File Using an Existence Check
The following example uses the open() function to try to create the LOCKFILE file and open it for writing. Since
the open() function specifies the O_EXCL flag, the call fails if the file already exists. In that case, the program assumes
that someone else is updating the password file and exits.
#include
#include
#include
#define LOCKFILE "/etc/ptmp"
...
int pfd; /* Integer for file descriptor returned by open() call. */
...
if ((pfd = open(LOCKFILE, O_WRONLY | O_CREAT | O_EXCL,
S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) == -1)
{
fprintf(stderr, "Cannot open /etc/ptmp. Try again later.\n");
exit(1);
}
...
Opening a File for Writing
The following example opens a file for writing, creating the file if it does not already exist. If the file does exist, the
system truncates the file to zero bytes.
#include
#include
#include
#define LOCKFILE "/etc/ptmp"
...
int pfd;
char pathname[PATH_MAX+1];
...
if ((pfd = open(pathname, O_WRONLY | O_CREAT | O_TRUNC,
S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) == -1)
{
perror("Cannot open output file\n"); exit(1);
}
...
APPLICATION USAGE
POSIX.1-2024 does not require that terminal parameters be automatically set to any state on first open, nor that they be reset
after the last close. It is possible for a non-conforming application to leave a terminal device in a state where the next process
to use that device finds it in a non-conforming state, but has no way of determining this. To ensure that the device is set to a
conforming initial state, applications which perform a first open of a terminal (other than a pseudo-terminal) should do so using
the O_TTY_INIT flag to set the parameters associated with the terminal to a conforming state.
Except as specified in this volume of POSIX.1-2024, the flags allowed in oflag are not mutually-exclusive and any number
of them may be used simultaneously. Not all combinations of flags make sense. For example, using O_SEARCH | O_CREAT will
successfully open a pre-existing directory for searching, but if there is no existing file by that name, then it is unspecified
whether a regular file will be created. Likewise, if a non-directory file descriptor is successfully returned, it is unspecified
whether that descriptor will have execute permissions as if by O_EXEC (note that it is unspecified whether O_EXEC and O_SEARCH have
the same value).
The O_CLOEXEC and O_CLOFORK flags of open() are necessary to avoid a data race in multi-threaded applications. Without
O_CLOFORK, a file descriptor is leaked into a child process created by one thread in the window between another thread creating a
file descriptor with open() and then using fcntl() to set the FD_CLOFORK flag.
Without O_CLOEXEC, a file descriptor intentionally inherited by child processes is similarly leaked into an executed program if
FD_CLOEXEC is not set atomically.
RATIONALE
Some implementations permit opening FIFOs with O_RDWR. Since FIFOs could be implemented in other ways, and since two file
descriptors can be used to the same effect, an implementation is allowed to reject the use of O_RDWR on a FIFO.
See getgroups() about the group of a newly created file.
The use of open() to create a regular file is preferable to the use of creat(), because the latter is redundant and included only for historical reasons.
The use of the O_TRUNC flag on FIFOs and directories (pipes cannot be open()-ed) must be permissible without unexpected
side-effects (for example, creat() on a FIFO must not remove data). Since terminal
special files might have type-ahead data stored in the buffer, O_TRUNC should not affect their content, particularly if a program
that normally opens a regular file should open the current controlling terminal instead. Other file types, particularly
implementation-defined ones, are left implementation-defined.
POSIX.1-2024 permits [EACCES] to be returned for conditions other than those explicitly listed.
The O_NOCTTY flag was added to allow applications to avoid unintentionally acquiring a controlling terminal as a side-effect of
opening a terminal file. This volume of POSIX.1-2024 does not specify how a controlling terminal is acquired, but it allows an
implementation to provide this on open() if the O_NOCTTY flag is not set and other conditions specified in XBD 11. General Terminal Interface are met.
In historical implementations the value of O_RDONLY is zero. Because of that, it is not possible to detect the presence of
O_RDONLY and another option. Future implementations should encode O_RDONLY and O_WRONLY as bit flags so that:
O_RDONLY | O_WRONLY == O_RDWR
O_EXEC and O_SEARCH are specified as two of the five file access modes. Since O_EXEC does not apply to directories, and O_SEARCH
only applies to directories, their values need not be distinct. Although this standard requires open() to fail on an attempt
to use O_EXEC on a directory, or O_SEARCH on a non-directory, this only applies in implementations where the two modes have
distinct values. Since O_RDONLY has historically had the value zero, implementations are not able to distinguish between O_SEARCH
and O_SEARCH | O_RDONLY, and similarly for O_EXEC.
In general, the open() function follows the symbolic link if path names a symbolic link. However, the
open() function, when called with O_CREAT and O_EXCL, is required to fail with [EEXIST] if path names an existing
symbolic link, even if the symbolic link refers to a nonexistent file. This behavior is required so that privileged applications
can create a new file in a known location without the possibility that a symbolic link might cause the file to be created in a
different location.
For example, a privileged application that must create a file with a predictable name in a user-writable directory, such as the
user's home directory, could be compromised if the user creates a symbolic link with that name that refers to a nonexistent file in
a system directory. If the user can influence the contents of a file, the user could compromise the system by creating a new system
configuration or spool file that would then be interpreted by the system. The test for a symbolic link which refers to a
nonexisting file must be atomic with the creation of a new file.
In addition, the open() function refuses to open non-directories if the O_DIRECTORY flag is set. This avoids race
conditions whereby a user might compromise the system by substituting a hard link to a sensitive file (e.g., a device or a FIFO)
while a privileged application is running, where opening a file even for read access might have undesirable side-effects.
In addition, the open() function does not follow symbolic links if the O_NOFOLLOW flag is set. This avoids race
conditions whereby a user might compromise the system by substituting a symbolic link to a sensitive file (e.g., a device) while a
privileged application is running, where opening a file even for read access might have undesirable side-effects.
The POSIX.1-1990 standard required that the group ID of a newly created file be set to the group ID of its parent directory or
to the effective group ID of the creating process. FIPS 151-2 required that implementations provide a way to have the group ID be
set to the group ID of the containing directory, but did not prohibit implementations also supporting a way to set the group ID to
the effective group ID of the creating process. Conforming applications should not assume which group ID will be used. If it
matters, an application can use chown() to set the group ID after the file is created,
or determine under what conditions the implementation will set the desired group ID.
The purpose of the openat() function is to enable opening files in directories other than the current working directory
without exposure to race conditions. Any part of the path of a file could be changed in parallel to a call to open(),
resulting in unspecified behavior. By opening a file descriptor for the target directory and using the openat() function it
can be guaranteed that the opened file is located relative to the desired directory. Some implementations use the openat()
function for other purposes as well. In some cases, if the oflag parameter has the O_XATTR bit set, the returned file
descriptor provides access to extended attributes. This functionality is not standardized here.
Implementations are encouraged to have open() and openat() report an [EILSEQ] error if oflag includes
O_CREAT, the file did not previously exist, and the last component of path contains any bytes that have the encoded value of
a  character.
FUTURE DIRECTIONS
A future version of this standard may add an O_NOCLOBBER flag, specified as follows, for use by shells when the noclobber
option is set (see XRAT C.2.7.2 Redirecting Output):
O_NOCLOBBER
If O_CREAT and O_NOCLOBBER are set, open() shall fail if the file exists and is either a regular file or a symbolic link
that resolves to a regular file. The check for the existence and type of the file and the creation of the file if it does not exist
shall be atomic with respect to other threads executing open() naming the same filename in the same directory with
O_NOCLOBBER and O_CREAT set or with O_EXCL and O_CREAT set. If O_NOCLOBBER and O_CREAT are set, and the file exists and is either a
non-regular file or a symbolic link that resolves to a non-regular file, the file shall be opened as if neither flag was set. If
O_NOCLOBBER and O_CREAT are set, and path names a symbolic link that does not resolve to an existing file, an empty file
shall be created such that path resolves to the newly created file. If O_NOCLOBBER is set and O_CREAT is not set, the result
is undefined.
SEE ALSO
chmod(), close(),
creat(), dirfd(), dup(), exec, fcntl(), fdopendir(), link(), lseek(), mkdtemp(), mknod(), read(), symlink(), umask(), unlockpt(), write()
XBD 11. General Terminal Interface, , ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Realtime Extension and the POSIX Threads Extension.
Large File Summit extensions are added.
Issue 6
In the SYNOPSIS, the optional include of the  header is
removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
In the DESCRIPTION, O_CREAT is amended to state that the group ID of the file is set to the group ID of the file's parent
directory or to the effective group ID of the process. This is a FIPS requirement.
In the DESCRIPTION, text is added to indicate setting of the offset maximum in the open file description. This change is to
support large files.
In the ERRORS section, the [EOVERFLOW] condition is added. This change is to support large files.
The [ENXIO] mandatory error condition is added.
The [EINVAL], [ENAMETOOLONG], and [ETXTBSY] optional error conditions are added.
The DESCRIPTION and ERRORS sections are updated so that items related to the optional XSI STREAMS Option Group are marked.
The following changes were made to align with the IEEE P1003.1a draft standard:
An explanation is added of the effect of the O_CREAT and O_EXCL flags when the path refers to a symbolic link.
The [ELOOP] optional error condition is added.
The normative text is updated to avoid use of the term "must" for application requirements.
The DESCRIPTION of O_EXCL is updated in response to IEEE PASC Interpretation 1003.1c #48.
Issue 7
Austin Group Interpretations 1003.1-2001 #113 and #143 are applied.
Austin Group Interpretation 1003.1-2001 #144 is applied, adding the O_TTY_INIT flag.
Austin Group Interpretation 1003.1-2001 #171 is applied, adding support to set the FD_CLOEXEC flag atomically at open(),
and adding the F_DUPFD_CLOEXEC flag.
SD5-XBD-ERN-4 is applied, changing the definition of the [EMFILE] error.
This page is revised and the openat() function is added from The Open Group Technical Standard, 2006, Extended API Set
Part 2.
Functionality relating to the XSI STREAMS option is marked obsolescent.
Changes are made related to support for finegrained timestamps.
Changes are made to allow a directory to be opened for searching.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0418 [292], XSH/TC1-2008/0419 [141], XSH/TC1-2008/0420 [461],
XSH/TC1-2008/0421 [390], XSH/TC1-2008/0422 [146], XSH/TC1-2008/0423 [324], XSH/TC1-2008/0424 [292], XSH/TC1-2008/0425 [278],
XSH/TC1-2008/0426 [278], XSH/TC1-2008/0427 [291], and XSH/TC1-2008/0428 [307] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0235 [873], XSH/TC2-2008/0236 [835], XSH/TC2-2008/0237 [847],
XSH/TC2-2008/0238 [817], XSH/TC2-2008/0239 [835], XSH/TC2-2008/0240 [847], XSH/TC2-2008/0241 [822], XSH/TC2-2008/0242 [817], and
XSH/TC2-2008/0243 [943] are applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defect 293 is applied, adding the [EILSEQ] error.
Austin Group Defects 658 and 1665 are applied, restricting the allowed behaviors when O_EXEC is used on a directory, or O_SEARCH
on a non-directory file, or O_RDWR on a FIFO, so that the requirements for O_EXCL still apply.
Austin Group Defect 1016 is applied, changing the FUTURE DIRECTIONS section.
Austin Group Defect 1151 is applied, changing the description of O_TTY_INIT to include requirements relating to the
winsize structure.
Austin Group Defect 1318 is applied, adding FD_CLOFORK and O_CLOFORK.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
Austin Group Defect 1466 is applied, changing the terminology used for pseudo-terminal devices.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fwrite.html =====
fwrite
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fwrite — binary output
SYNOPSIS
#include
size_t fwrite(const void *restrict ptr, size_t size, size_t nitems,
FILE *restrict stream);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The fwrite() function shall write, from the array pointed to by ptr, up to nitems elements whose size is
specified by size, to the stream pointed to by stream. For each object, size calls shall be made to the
fputc() function, taking the values (in order) from an array of unsigned char
exactly overlaying the object. The file-position indicator for the stream (if defined) shall be advanced by the number of bytes
successfully written. If an error occurs, the resulting value of the file-position indicator for the stream is unspecified.
[CX]  The
last data modification and last file status change timestamps of the file shall be marked for update between the successful
execution of fwrite() and the next successful completion of a call to fflush()
or fclose() on the same stream, or a call to exit() or abort().
RETURN VALUE
The fwrite() function shall return the number of elements successfully written, which shall be less than nitems
only if a write error is encountered. If size or nitems is 0, fwrite() shall return 0 and the state of the
stream remains unchanged. Otherwise, if a write error occurs, the error indicator for the stream shall be set, [CX]   and
errno shall be set to indicate the error.
ERRORS
Refer to fputc().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Because of possible differences in element length and byte ordering, files written using fwrite() are
application-dependent, and possibly cannot be read using fread() by a different
application or by the same application on a different processor.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, ferror(), fopen(), fprintf(), putc(), puts(), write()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
Extensions beyond the ISO C standard are marked.
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The fwrite() prototype is updated.
The DESCRIPTION is updated to clarify how the data is written out using fputc().
Issue 7
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0228 [14] is applied.
Issue 8
Austin Group Defect 1196 is applied, clarifying the RETURN VALUE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_condattr_destroy.html =====
pthread_condattr_destroy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_condattr_destroy, pthread_condattr_init — destroy and initialize the condition variable attributes
object
SYNOPSIS
#include
int pthread_condattr_destroy(pthread_condattr_t *attr);
int pthread_condattr_init(pthread_condattr_t *attr);
DESCRIPTION
The pthread_condattr_destroy() function shall destroy a condition variable attributes object; the object becomes, in
effect, uninitialized. An implementation may cause pthread_condattr_destroy() to set the object referenced by attr to
an invalid value. A destroyed attr attributes object can be reinitialized using pthread_condattr_init(); the results
of otherwise referencing the object after it has been destroyed are undefined.
The pthread_condattr_init() function shall initialize a condition variable attributes object attr with the default
value for all of the attributes defined by the implementation.
Results are undefined if pthread_condattr_init() is called specifying an already initialized attr attributes
object.
After a condition variable attributes object has been used to initialize one or more condition variables, any function affecting
the attributes object (including destruction) shall not affect any previously initialized condition variables.
This volume of POSIX.1-2024 requires two attributes, the clock attribute and the process-shared attribute.
Additional attributes, their default values, and the names of the associated functions to get and set those attribute values are
implementation-defined.
The behavior is undefined if the value specified by the attr argument to pthread_condattr_destroy() does not refer
to an initialized condition variable attributes object.
RETURN VALUE
If successful, the pthread_condattr_destroy() and pthread_condattr_init() functions shall return zero; otherwise,
an error number shall be returned to indicate the error.
ERRORS
The pthread_condattr_init() function shall fail if:
[ENOMEM]
Insufficient memory exists to initialize the condition variable attributes object.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
A process-shared attribute has been defined for condition variables for the same reason it has been defined for
mutexes.
If an implementation detects that the value specified by the attr argument to pthread_condattr_destroy() does not
refer to an initialized condition variable attributes object, it is recommended that the function should fail and report an
[EINVAL] error.
See also pthread_attr_destroy() and pthread_mutex_destroy().
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_attr_destroy(), pthread_cond_destroy(), pthread_condattr_getpshared(), pthread_create(), pthread_mutex_destroy()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_condattr_destroy() and pthread_condattr_init() functions are marked as part of the Threads option.
Issue 7
The pthread_condattr_destroy() and pthread_condattr_init() functions are moved from the Threads option to the
Base.
The [EINVAL] error for an uninitialized condition variable attributes object is removed; this condition results in undefined
behavior.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/iscntrl_l.html =====
iscntrl
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
iscntrl, iscntrl_l — test for a control character
SYNOPSIS
#include
int iscntrl(int c);
[CX]  int iscntrl_l(int c, locale_t locale);
DESCRIPTION
For iscntrl(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The iscntrl() [CX]   and iscntrl_l()
functions shall test whether c is a character of class cntrl in the current locale, [CX]   or in the
locale represented by locale,  respectively; see XBD 7. Locale.
The c argument is a type int, the value of which the application shall ensure is a character representable as an
unsigned char or equal to the value of the macro EOF. If the argument has any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to iscntrl_l() is the special locale object LC_GLOBAL_LOCALE or is not a
valid locale object handle.
RETURN VALUE
The iscntrl() [CX]   and iscntrl_l()
functions shall return non-zero if c is a control character; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
isalnum(), isalpha(), isblank(), isdigit(), isgraph(), islower(), isprint(), ispunct(), isspace(), isupper(), isxdigit(), setlocale(), uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The iscntrl_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0283 [302], XSH/TC1-2008/0284 [283], and XSH/TC1-2008/0285 [283] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/nrand48.html =====
drand48
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
drand48, erand48, jrand48, lcong48, lrand48, mrand48, nrand48, seed48, srand48 — generate uniformly distributed
pseudo-random numbers
SYNOPSIS
[XSI]  #include
double drand48(void);
double erand48(unsigned short xsubi[3]);
long jrand48(unsigned short xsubi[3]);
void lcong48(unsigned short param[7]);
long lrand48(void);
long mrand48(void);
long nrand48(unsigned short xsubi[3]);
unsigned short *seed48(unsigned short seed16v[3]);
void srand48(long seedval);
DESCRIPTION
This family of functions shall generate pseudo-random numbers using a linear congruential algorithm and 48-bit integer
arithmetic.
The drand48() and erand48() functions shall return non-negative, double-precision, floating-point values,
uniformly distributed over the interval [0.0,1.0).
The lrand48() and nrand48() functions shall return non-negative, long integers, uniformly distributed over the
interval [0,231).
The mrand48() and jrand48() functions shall return signed long integers uniformly distributed over the interval
[-231,231).
The srand48(), seed48(), and lcong48() functions are initialization entry points, one of which should be
invoked before either drand48(), lrand48(), or mrand48() is called. (Although it is not recommended practice,
constant default initializer values shall be supplied automatically if drand48(), lrand48(), or mrand48() is
called without a prior call to an initialization entry point.) The erand48(), nrand48(), and jrand48()
functions do not require an initialization entry point to be called first.
All the routines work by generating a sequence of 48-bit integer values,
\(X_{i}\),
according to the linear congruential formula:
\(X_{n+1}=\left(a X_n+c\right)_{\bmod m} \quad n \geq 0\)
The parameter m=248; hence 48-bit integer arithmetic is performed. Unless lcong48() is invoked, the multiplier
value a and the addend value c are given by:
\(
\begin{aligned}
& a= \text { 5DEECE66D }_{16}=273673163155_8 \\
& c=\mathrm{B}_{16}=13_8
\end{aligned}
\)
The value returned by any of the drand48(), erand48(), jrand48(), lrand48(), mrand48(), or
nrand48() functions is computed by first generating the next 48-bit \(X_{i}\) in the sequence. \(X_{i}\) is then converted
to the return value as follows:
For drand48() and erand48() the value shall be 2-48 times \(X_{i}\).
For jrand48() and mrand48() the value shall be the largest integer not greater than 2-16 times \(X_{i}\).
For lrand48() and nrand48() the value shall be the largest integer not greater than 2-17 times \(X_{i}\).
The drand48(), lrand48(), and mrand48() functions store the last 48-bit \(X_{i}\) generated in an internal
buffer; that is why the application shall ensure that these are initialized prior to being invoked. The erand48(),
nrand48(), and jrand48() functions require the calling program to provide storage for the successive \(X_{i}\) values
in the array specified as an argument when the functions are invoked. That is why these routines do not have to be initialized; the
calling program merely has to place the desired initial value of \(X_{i}\) into the array and pass it as an argument. By using
different arguments, erand48(), nrand48(), and jrand48() allow separate modules of a large program to generate
several independent streams of pseudo-random numbers; that is, the sequence of numbers in each stream shall not
depend upon how many times the routines are called to generate numbers for the other streams.
The initializer function srand48() sets the high-order 32 bits of \(X_{i}\) to the low-order 32 bits contained in its
argument. The low-order 16 bits of \(X_{i}\) are set to the arbitrary value 330E16.
The initializer function seed48() sets the value of \(X_{i}\) to the 48-bit value specified in the argument array. The
low-order 16 bits of \(X_{i}\) are set to the low-order 16 bits of seed16v[0]. The mid-order 16 bits of \(X_{i}\) are
set to the low-order 16 bits of seed16v[1]. The high-order 16 bits of \(X_{i}\) are set to the low-order 16 bits of
seed16v[2]. In addition, the previous value of \(X_{i}\) is copied into a 48-bit internal buffer, used only by
seed48(), and a pointer to this buffer is the value returned by seed48(). This returned pointer, which can just be
ignored if not needed, is useful if a program is to be restarted from a given point at some future time—use the pointer to get at
and store the last \(X_{i}\) value, and then use this value to reinitialize via seed48() when the program is restarted.
The initializer function lcong48() allows the user to specify the initial \(X_{i}\), the multiplier value a, and the
addend value c. Argument array elements param[0-2] specify \(X_{i}\), param[3-5] specify the
multiplier a, and param[6] specifies the 16-bit addend c. After lcong48() is called, a subsequent call to
either srand48() or seed48() shall restore the standard multiplier and addend values, a and c,
specified above.
The drand48(), lrand48(), and mrand48() functions need not be thread-safe.
RETURN VALUE
As described in the DESCRIPTION above.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
The following program tests that the required pseudo-random number generator is used by these functions.
#include
#include
int main() {
{
unsigned short xsubi[3] = {37174, 64810, 11603};
double d = erand48(xsubi);
assert(d >= 0.896);
assert(d = 0.337);
assert(d = 0.647);
assert(d = 0.500);
assert(d = 0.506);
assert(d
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
A note indicating that the drand48(), lrand48(), and mrand48() functions need not be reentrant is added to
the DESCRIPTION.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0083 [743] is applied.
Issue 8
Austin Group Defect 1107 is applied, clarifying how the return value is calculated from  \(X_{i}\) for each function.
Austin Group Defect 1134 is applied, adding getentropy().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/if_nametoindex.html =====
if_nametoindex
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
if_nametoindex — map a network interface name to its corresponding index
SYNOPSIS
#include
unsigned if_nametoindex(const char *ifname);
DESCRIPTION
The if_nametoindex() function shall return the interface index corresponding to name ifname.
RETURN VALUE
The corresponding index if ifname is the name of an interface; otherwise, zero.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
getsockopt(), if_freenameindex(), if_indextoname(), if_nameindex(), setsockopt()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/dbm_clearerr.html =====
dbm_clearerr
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
dbm_clearerr, dbm_close, dbm_delete, dbm_error, dbm_fetch, dbm_firstkey, dbm_nextkey, dbm_open, dbm_store — database
functions
SYNOPSIS
[XSI]  #include
int dbm_clearerr(DBM *db);
void dbm_close(DBM *db);
int dbm_delete(DBM *db, datum key);
int dbm_error(DBM *db);
datum dbm_fetch(DBM *db, datum key);
datum dbm_firstkey(DBM *db);
datum dbm_nextkey(DBM *db);
DBM *dbm_open(const char *file, int open_flags, mode_t file_mode);
int dbm_store(DBM *db, datum key, datum content, int
store_mode);
DESCRIPTION
These functions create, access, and modify a database.
A datum consists of at least two members, dptr and dsize. The dptr member points to an object that
is dsize bytes in length. Arbitrary binary data, as well as character strings, may be stored in the object pointed to by
dptr.
A database shall be stored in one or two files. When one file is used, the name of the database file shall be formed by
appending the suffix .db to the file argument given to dbm_open(). When two files are used, the names of the
database files shall be formed by appending the suffixes .dir and .pag respectively to the file argument.
The dbm_open() function shall open a database. The file argument to the function is the pathname of the database.
Values for the open_flags argument are constructed by a bitwise-inclusive OR of flags from the following list, defined in
. Applications shall specify exactly one of the first three values
(file access modes) below in the value of open_flags:
O_RDONLY
Open the database, and the underlying file(s) used to store the database, for reading only.
O_RDWR
Open the database, and the underlying file(s) used to store the database, for reading and writing.
O_WRONLY
Open the database for writing only. The underlying file(s) used to store the database shall be opened for reading and
writing.
Any combination of the following can be used:
O_CLOEXEC
If set, the FD_CLOEXEC flag for the new file descriptor(s) used to open the underlying file(s) shall be set.
O_CREAT
If the database exists, this flag has no effect except as noted under O_EXCL below. Otherwise, the database shall be created;
the user ID of the underlying file(s) shall be set to the effective user ID of the process; the group ID of the underlying file(s)
shall be set to the group ID of the file's parent directory or to the effective group ID of the process. Implementations shall
provide a way to initialize the group ID to the group ID of the parent directory. Implementations may, but need not, provide an
implementation-defined way to initialize the group ID to the effective group ID of the calling process.
O_DSYNC
[SIO]
Write I/O operations on the file(s) used to store the database shall complete as defined by synchronized I/O data integrity
completion.
O_EXCL
If O_CREAT and O_EXCL are set, dbm_open() shall fail if the database exists according to the following criteria. If the
database is stored in a file with a .db suffix, a check for the existence of the file and the creation of the file if it
does not exist shall be performed as a single atomic operation. If the database is stored in files with .pag and .dir
suffixes, this atomic existence check and creation operation shall be performed for each file, but it is unspecified which file is
first. If the first file is successfully created and the second file is found to exist, the first file should be removed before
dbm_open() returns.
If O_EXCL is set and O_CREAT is not set, the result is undefined.
O_RSYNC
[SIO]
Read I/O operations on the file(s) used to store the database shall complete at the same level of integrity as specified by the
O_DSYNC and O_SYNC flags. If both O_DSYNC and O_RSYNC are set in oflag, all I/O operations on the file(s) shall complete as defined
by synchronized I/O data integrity completion. If both O_SYNC and O_RSYNC are set in flags, all I/O operations on the file(s) shall
complete as defined by synchronized I/O file integrity completion.
O_SYNC
Write I/O operations on the file(s) used to store the database shall complete as defined by synchronized I/O file integrity
completion.
O_TRUNC
If the database exists and is successfully opened O_RDWR or O_WRONLY, it shall be emptied, and the mode and owner of the
underlying file(s) shall be unchanged. The result of using O_TRUNC without either O_RDWR or O_WRONLY is undefined.
The behaviour of other flags described for the flags argument of open() is
unspecified.
The file_mode argument has the same meaning as the third argument of open()
and shall apply to the underlying file(s) used to store the database.
The dbm_open() function need not accept pathnames longer than {PATH_MAX}-4 bytes (including the terminating null), or
pathnames with a last component longer than {NAME_MAX}-4 bytes (excluding the terminating null).
The dbm_close() function shall close a database. The application shall ensure that argument db is a pointer to a
dbm structure that has been returned from a call to dbm_open().
These database functions shall support an internal block size large enough to support key/content pairs of at least 1023
bytes.
The dbm_fetch() function shall read a record from a database. The argument db is a pointer to a database structure
that has been returned from a call to dbm_open(). The argument key is a datum that has been initialized by the
application to the value of the key that matches the key of the record the program is fetching.
The dbm_store() function shall write a record to a database. The argument db is a pointer to a database structure
that has been returned from a call to dbm_open(). The argument key is a datum that has been initialized by the
application to the value of the key that identifies (for subsequent reading, writing, or deleting) the record the application is
writing. The argument content is a datum that has been initialized by the application to the value of the record the
program is writing. The argument store_mode controls whether dbm_store() replaces any pre-existing record that has
the same key that is specified by the key argument. The application shall set store_mode to either DBM_INSERT or
DBM_REPLACE. If the database contains a record that matches the key argument and store_mode is DBM_REPLACE, the
existing record shall be replaced with the new record. If the database contains a record that matches the key argument and
store_mode is DBM_INSERT, the existing record shall be left unchanged and the new record ignored. If the database does not
contain a record that matches the key argument and store_mode is either DBM_INSERT or DBM_REPLACE, the new record
shall be inserted in the database.
If the sum of a key/content pair exceeds the internal block size, the result is unspecified. Moreover, the application shall
ensure that all key/content pairs that hash together fit on a single block. The dbm_store() function shall return an error
in the event that a disk block fills with inseparable data.
The dbm_delete() function shall delete a record and its key from the database. The argument db is a pointer to a
database structure that has been returned from a call to dbm_open(). The argument key is a datum that has been
initialized by the application to the value of the key that identifies the record the program is deleting.
The dbm_firstkey() function shall return the first key in the database. The argument db is a pointer to a database
structure that has been returned from a call to dbm_open().
The dbm_nextkey() function shall return the next key in the database. The argument db is a pointer to a database
structure that has been returned from a call to dbm_open(). The application shall ensure that the dbm_firstkey()
function is called before calling dbm_nextkey(). Subsequent calls to dbm_nextkey() return the next key until all of
the keys in the database have been returned.
The dbm_error() function shall return the error condition of the database. The argument db is a pointer to a
database structure that has been returned from a call to dbm_open().
The dbm_clearerr() function shall clear the error condition of the database. The argument db is a pointer to a
database structure that has been returned from a call to dbm_open().
The dptr pointers returned by these functions may point into static storage that may be changed by subsequent calls.
These functions need not be thread-safe.
RETURN VALUE
The dbm_store() and dbm_delete() functions shall return 0 when they succeed and a negative value when they
fail.
The dbm_store() function shall return 1 if it is called with a flags value of DBM_INSERT and the function finds an
existing record with the same key.
The dbm_error() function shall return 0 if the error condition is not set and return a non-zero value if the error
condition is set.
The return value of dbm_clearerr() is unspecified.
The dbm_firstkey() and dbm_nextkey() functions shall return a key datum. When the end of the database is
reached, the dptr member of the key is a null pointer. If an error is detected, the dptr member of the key shall be a
null pointer and the error condition of the database shall be set.
The dbm_fetch() function shall return a content datum. If no record in the database matches the key or if an error
condition has been detected in the database, the dptr member of the content shall be a null pointer.
The dbm_open() function shall return a pointer to a database structure. If an error is detected during the operation,
dbm_open() shall return a (DBM *)0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The following code can be used to traverse the database:
for(key = dbm_firstkey(db); key.dptr != NULL; key = dbm_nextkey(db))
The dbm_* functions provided in this library should not be confused in any way with those of a general-purpose database
management system. These functions do not provide for multiple search keys per entry, they do not protect against multi-user access
(in other words they do not lock records or files), and they do not provide the many other useful database functions that are found
in more robust database management systems. Creating and updating databases by use of these functions is relatively slow because of
data copies that occur upon hash collisions. These functions are useful for applications requiring fast lookup of relatively static
information that is to be indexed by a single key.
Note that a strictly conforming application is extremely limited by these functions: since there is no way to determine that the
keys in use do not all hash to the same value (although that would be rare), a strictly conforming application cannot be guaranteed
that it can store more than one block's worth of data in the database. As long as a key collision does not occur, additional data
may be stored, but because there is no way to determine whether an error is due to a key collision or some other error condition
(dbm_error() being effectively a Boolean), once an error is detected, the
application is effectively limited to guessing what the error might be if it wishes to continue using these functions.
The dbm_delete() function need not physically reclaim file space, although it does make it available for reuse by the
database.
After calling dbm_store() or dbm_delete() during a pass through the keys by dbm_firstkey() and
dbm_nextkey(), the application should reset the database by calling dbm_firstkey() before again calling
dbm_nextkey(). The contents of these files are unspecified and may not be portable.
Applications should take care that database pathname arguments specified to dbm_open() are not prefixes of unrelated
files. This might be done, for example, by placing databases in a separate directory.
Since some implementations use three characters for a suffix and others use four characters for a suffix, applications should
ensure that the maximum portable pathname length passed to dbm_open() is no greater than {PATH_MAX}-4 bytes, with the last
component of the pathname no greater than {NAME_MAX}-4 bytes.
RATIONALE
and having .dir as its suffix. The second file containing all data and having .pag as its suffix. This has been
changed not to specify the use of the files and to allow newer implementations of the Berkeley DB interface using a single file
that have evolved while remaining compatible with the application programming interface. The standard developers considered
removing the specific suffixes altogether but decided to retain them so as not to pollute the application file name space more than
necessary and to allow for portable backups of the database.
FUTURE DIRECTIONS
A future revision of this standard may mandate the file removal that is currently recommended (by the use of "should") in the
description of O_EXCL.
SEE ALSO
open()
XBD ,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Normative text previously in the APPLICATION USAGE section is moved to the DESCRIPTION.
A note indicating that these functions need not be reentrant is added to the DESCRIPTION.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
Austin Group Interpretation 1003.1-2001 #042 is applied so that the DESCRIPTION permits newer implementations of the Berkeley DB
interface.
Austin Group Interpretation 1003.1-2001 #156 is applied.
Issue 8
Austin Group Defect 1057 is applied, clarifying how the O_ flags defined for use with open() apply to dbm_open().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/cpowf.html =====
cpow
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cpow, cpowf, cpowl — complex power functions
SYNOPSIS
#include
double complex cpow(double complex x, double complex y);
float complex cpowf(float complex x, float complex y);
long double complex cpowl(long double complex x,
long double complex y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex power function xy, with a branch cut for the first
parameter along the negative real axis.
[MXC]
These functions shall raise floating-point exceptions if appropriate for the calculation of the parts of the result, and may also
raise spurious floating-point exceptions.
RETURN VALUE
These functions shall return the complex power function value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
Permitting spurious floating-point exceptions allows cpow(z, c) to be implemented as
cexp(cclog(z)) without precluding implementations that treat special cases more carefully.
FUTURE DIRECTIONS
None.
SEE ALSO
cabs(), csqrt()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_cond_clockwait.html =====
pthread_cond_clockwait
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_cond_clockwait, pthread_cond_timedwait, pthread_cond_wait — wait on a condition
SYNOPSIS
#include
int pthread_cond_clockwait(pthread_cond_t *restrict cond,
pthread_mutex_t *restrict mutex, clockid_t clock_id,
const struct timespec *restrict abstime);
int pthread_cond_timedwait(pthread_cond_t *restrict cond,
pthread_mutex_t *restrict mutex,
const struct timespec *restrict abstime);
int pthread_cond_wait(pthread_cond_t *restrict cond,
pthread_mutex_t *restrict mutex);
DESCRIPTION
The pthread_cond_clockwait(), pthread_cond_timedwait(), and pthread_cond_wait() functions shall block on a
condition variable. The application shall ensure that these functions are called with mutex locked by the calling thread;
otherwise, an error (for PTHREAD_MUTEX_ERRORCHECK and robust mutexes) or undefined behavior (for other mutexes) results.
These functions atomically release mutex and cause the calling thread to block on the condition variable cond;
atomically here means "atomically with respect to access by another thread to the mutex and then the condition variable". That
is, if another thread is able to acquire the mutex after the about-to-block thread has released it, then a subsequent call to
pthread_cond_broadcast() or pthread_cond_signal() in that thread shall behave as if it were issued after the
about-to-block thread has blocked.
Upon successful return, the mutex shall have been locked and shall be owned by the calling thread.
If mutex is a robust mutex where an owner terminated while holding the lock and the state is recoverable, the mutex shall
be acquired even though the function returns [EOWNERDEAD].
When using condition variables there is always a Boolean predicate involving shared variables associated with each condition
wait that is true if the thread should proceed. Spurious wakeups from the pthread_cond_clockwait(),
pthread_cond_timedwait(), or pthread_cond_wait() functions may occur. Since the return from
pthread_cond_clockwait(), pthread_cond_timedwait(), or pthread_cond_wait() does not imply anything about the
value of this predicate, the predicate should be re-evaluated upon such return.
When a thread waits on a condition variable, having specified a particular mutex to the pthread_cond_clockwait(),
pthread_cond_timedwait(), or pthread_cond_wait() operation, a dynamic binding is formed between that mutex and
condition variable that remains in effect as long as at least one thread is blocked on the condition variable. During this time,
the effect of an attempt by any thread to wait on that condition variable using a different mutex is undefined. Once all waiting
threads have been unblocked (as by the pthread_cond_broadcast()
operation), the next wait operation on that condition variable shall form a new dynamic binding with the mutex specified by that
wait operation. Even though the dynamic binding between condition variable and mutex may be removed or replaced between the time a
thread is unblocked from a wait on the condition variable and the time that it returns to the caller or begins cancellation
cleanup, the unblocked thread shall always re-acquire the mutex specified in the condition wait operation call from which it is
returning.
A condition wait (whether timed or not) is a cancellation point. When the cancelability type of a thread is set to
PTHREAD_CANCEL_DEFERRED, a side-effect of acting upon a cancellation request while in a condition wait is that the mutex is (in
effect) re-acquired before calling the first cancellation cleanup handler. The effect is as if the thread were unblocked, allowed
to execute up to the point of returning from the call to pthread_cond_clockwait(), pthread_cond_timedwait(), or
pthread_cond_wait(), but at that point notices the cancellation request and, instead of returning to the caller, starts the
thread cancellation activities, which includes calling cancellation cleanup handlers.
A thread that has been unblocked because it has been canceled while blocked in a call to pthread_cond_clockwait(),
pthread_cond_timedwait(), or pthread_cond_wait() shall not consume any condition signal that may be directed
concurrently at the condition variable if there are other threads blocked on the condition variable.
The pthread_cond_clockwait() function shall be equivalent to pthread_cond_wait(), except that an error is returned
if the absolute time specified by abstime as measured against the clock indicated by clock_id passes (that is, the
current time measured by that clock equals or exceeds abstime) before the condition cond is signaled or broadcasted,
or if the absolute time specified by abstime has already been passed at the time of the call. Implementations shall support
passing CLOCK_REALTIME and CLOCK_MONOTONIC to pthread_cond_clockwait() as the clock_id argument. When such timeouts
occur, pthread_cond_clockwait() shall nonetheless release and re-acquire the mutex referenced by mutex, and may
consume a condition signal directed concurrently at the condition variable.
The pthread_cond_timedwait() function shall be equivalent to pthread_cond_clockwait(), except that it lacks the
clock_id argument. The clock to measure abstime against shall instead come from the condition variable's clock
attribute which can be set by pthread_condattr_setclock() prior to
the condition variable's creation. If no clock attribute has been set, the default shall be CLOCK_REALTIME.
If a signal is delivered to a thread waiting for a condition variable, upon return from the signal handler the thread resumes
waiting for the condition variable as if it was not interrupted, or it shall return zero due to spurious wakeup.
The behavior is undefined if the value specified by the cond or mutex argument to these functions does not refer
to an initialized condition variable or an initialized mutex object, respectively.
RETURN VALUE
Except for [ETIMEDOUT], [ENOTRECOVERABLE], and [EOWNERDEAD], all these error checks shall act as if they were performed
immediately at the beginning of processing for the function and shall cause an error return, in effect, prior to modifying the
state of the mutex specified by mutex or the condition variable specified by cond.
Upon successful completion, a value of zero shall be returned; otherwise, an error number shall be returned to indicate the
error.
ERRORS
These functions shall fail if:
[EAGAIN]
The mutex is a robust mutex and the system resources available for robust mutexes owned would be exceeded.
[ENOTRECOVERABLE]
The state protected by the mutex is not recoverable.
[EOWNERDEAD]
The mutex is a robust mutex and the process containing the previous owning thread terminated while holding the mutex lock. The
mutex lock shall be acquired by the calling thread and it is up to the new owner to make the state consistent.
[EPERM]
The mutex type is PTHREAD_MUTEX_ERRORCHECK or the mutex is a robust mutex, and the current thread does not own the mutex.
The pthread_cond_clockwait() and pthread_cond_timedwait() functions shall fail if:
[ETIMEDOUT]
The time specified by abstime has passed.
[EINVAL]
The abstime argument specified a nanosecond value less than zero or greater than or equal to 1000 million, or the
clock_id argument passed to pthread_cond_clockwait() is invalid or not supported.
These functions may fail if:
[EOWNERDEAD]
The mutex is a robust mutex and the previous owning thread terminated while holding the mutex lock. The mutex lock shall be
acquired by the calling thread and it is up to the new owner to make the state consistent.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications that have assumed that non-zero return values are errors will need updating for use with robust mutexes, since a
valid return for a thread acquiring a mutex which is protecting a currently inconsistent state is [EOWNERDEAD]. Applications that
do not check the error returns, due to ruling out the possibility of such errors arising, should not use robust mutexes. If an
application is supposed to work with normal and robust mutexes, it should check all return values for error conditions and if
necessary take appropriate action.
RATIONALE
If an implementation detects that the value specified by the cond argument to pthread_cond_clockwait(),
pthread_cond_timedwait(), or pthread_cond_wait() does not refer to an initialized condition variable, or detects that
the value specified by the mutex argument does not refer to an initialized mutex object, it is recommended that the function
should fail and report an [EINVAL] error.
Condition Wait Semantics
It is important to note that when pthread_cond_clockwait(), pthread_cond_timedwait(), and
pthread_cond_wait() return without error, the associated predicate may still be false. Similarly, when
pthread_cond_clockwait() or pthread_cond_timedwait() returns with the timeout error, the associated predicate may be
true due to an unavoidable race between the expiration of the timeout and the predicate state change.
The application needs to recheck the predicate on any return because it cannot be sure there is another thread waiting on the
thread to handle the signal, and if there is not then the signal is lost. The burden is on the application to check the
predicate.
Some implementations, particularly on a multi-processor, may sometimes cause multiple threads to wake up when the condition
variable is signaled simultaneously on different processors.
In general, whenever a condition wait returns, the thread has to re-evaluate the predicate associated with the condition wait to
determine whether it can safely proceed, should wait again, or should declare a timeout. A return from the wait does not imply that
the associated predicate is either true or false.
It is thus recommended that a condition wait be enclosed in the equivalent of a "while loop" that checks the predicate.
Timed Wait Semantics
An absolute time measure was chosen for specifying the timeout parameter for two reasons. First, a relative time measure can be
easily implemented on top of a function that specifies absolute time, but there is a race condition associated with specifying an
absolute timeout on top of a function that specifies relative timeouts. For example, assume that clock_gettime() returns the current time and cond_relative_timed_wait() uses
relative timeouts:
clock_gettime(CLOCK_REALTIME, &now)
reltime = sleep_til_this_absolute_time -now;
cond_relative_timed_wait(c, m, &reltime);
If the thread is preempted between the first statement and the last statement, the thread blocks for too long. Blocking,
however, is irrelevant if an absolute timeout is used. An absolute timeout also need not be recomputed if it is used multiple times
in a loop, such as that enclosing a condition wait.
For cases when the system clock is advanced discontinuously by an operator, it is expected that implementations process any
timed wait expiring at an intervening time as if that time had actually occurred.
Choice of Clock
Care should be taken to decide which clock is most appropriate when waiting with a timeout. The system clock CLOCK_REALTIME, as
used by default with pthread_cond_timedwait(), may be subject to jumps forwards and backwards in order to correct it against
actual time. CLOCK_MONOTONIC is guaranteed not to jump backwards and must also advance in real time, so using it via
pthread_cond_clockwait() or pthread_condattr_setclock() may
be more appropriate.
Cancellation and Condition Wait
A condition wait, whether timed or not, is a cancellation point. That is, the functions pthread_cond_clockwait(),
pthread_cond_timedwait(), and pthread_cond_wait() are points where a pending (or concurrent) cancellation request is
noticed. The reason for this is that an indefinite wait is possible at these points—whatever event is being waited for, even if the
program is totally correct, might never occur; for example, some input data being awaited might never be sent. By making condition
wait a cancellation point, the thread can be canceled and perform its cancellation cleanup handler even though it may be stuck in
some indefinite wait.
A side-effect of acting on a cancellation request while a thread is blocked on a condition variable is to re-acquire the mutex
before calling any of the cancellation cleanup handlers. This is done in order to ensure that the cancellation cleanup handler is
executed in the same state as the critical code that lies both before and after the call to the condition wait function. This rule
is also required when interfacing to POSIX threads from languages, such as Ada or C++, which may choose to map cancellation onto a
language exception; this rule ensures that each exception handler guarding a critical section can always safely depend upon the
fact that the associated mutex has already been locked regardless of exactly where within the critical section the exception was
raised. Without this rule, there would not be a uniform rule that exception handlers could follow regarding the lock, and so coding
would become very cumbersome.
Therefore, since some statement has to be made regarding the state of the lock when a cancellation is delivered during a
wait, a definition has been chosen that makes application coding most convenient and error free.
When acting on a cancellation request while a thread is blocked on a condition variable, the implementation is required to
ensure that the thread does not consume any condition signals directed at that condition variable if there are any other threads
waiting on that condition variable. This rule is specified in order to avoid deadlock conditions that could occur if these two
independent requests (one acting on a thread and the other acting on the condition variable) were not processed independently.
Performance of Mutexes and Condition Variables
Mutexes are expected to be locked only for a few instructions. This practice is almost automatically enforced by the desire of
programmers to avoid long serial regions of execution (which would reduce total effective parallelism).
When using mutexes and condition variables, one tries to ensure that the usual case is to lock the mutex, access shared data,
and unlock the mutex. Waiting on a condition variable should be a relatively rare situation. For example, when implementing a
read-write lock, code that acquires a read-lock typically needs only to increment the count of readers (under mutual-exclusion) and
return. The calling thread would actually wait on the condition variable only when there is already an active writer. So the
efficiency of a synchronization operation is bounded by the cost of mutex lock/unlock and not by condition wait. Note that in the
usual case there is no context switch.
This is not to say that the efficiency of condition waiting is unimportant. Since there needs to be at least one context switch
per Ada rendezvous, the efficiency of waiting on a condition variable is important. The cost of waiting on a condition variable
should be little more than the minimal cost for a context switch plus the time to unlock and lock the mutex.
Features of Mutexes and Condition Variables
It had been suggested that the mutex acquisition and release be decoupled from condition wait. This was rejected because it is
the combined nature of the operation that, in fact, facilitates realtime implementations. Those implementations can atomically move
a high-priority thread between the condition variable and the mutex in a manner that is transparent to the caller. This can prevent
extra context switches and provide more deterministic acquisition of a mutex when the waiting thread is signaled. Thus, fairness
and priority issues can be dealt with directly by the scheduling discipline. Furthermore, the current condition wait operation
matches existing practice.
Scheduling Behavior of Mutexes and Condition Variables
Synchronization primitives that attempt to interfere with scheduling policy by specifying an ordering rule are considered
undesirable. Threads waiting on mutexes and condition variables are selected to proceed in an order dependent upon the scheduling
policy rather than in some fixed order (for example, FIFO or priority). Thus, the scheduling policy determines which thread(s) are
awakened and allowed to proceed.
Timed Condition Wait
The pthread_cond_clockwait() and pthread_cond_timedwait() functions allow an application to give up waiting for a
particular condition after a given amount of time. An example follows:
(void) pthread_mutex_lock(&t.mn);
t.waiters++;
clock_gettime(CLOCK_MONOTONIC, &ts);
ts.tv_sec += 5;
rc = 0;
while (! mypredicate(&t) && rc == 0)
rc = pthread_cond_clockwait(&t.cond, &t.mn,
CLOCK_MONOTONIC, &ts);
t.waiters--;
if (rc == 0 || mypredicate(&t))
setmystate(&t);
(void) pthread_mutex_unlock(&t.mn);
By making the timeout parameter absolute, it does not need to be recomputed each time the program checks its blocking predicate.
If the timeout was relative, it would have to be recomputed before each call. This would be especially difficult since such code
would need to take into account the possibility of extra wakeups that result from extra broadcasts or signals on the condition
variable that occur before either the predicate is true or the timeout is due. Using CLOCK_MONOTONIC rather than CLOCK_REALTIME
means that the timeout is not influenced by the system clock being changed.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_cond_broadcast()
XBD 4.15.2 Memory Synchronization,
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_cond_timedwait() and pthread_cond_wait() functions are marked as part of the Threads option.
The Open Group Corrigendum U021/9 is applied, correcting the prototype for the pthread_cond_wait() function.
The DESCRIPTION is updated for alignment with IEEE Std 1003.1j-2000 by adding semantics for the Clock Selection
option.
The ERRORS section has an additional case for [EPERM] in response to IEEE PASC Interpretation 1003.1c #28.
The restrict keyword is added to the pthread_cond_timedwait() and pthread_cond_wait() prototypes for
alignment with the ISO/IEC 9899:1999 standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/89 is applied, updating the DESCRIPTION for consistency with the
pthread_cond_destroy() function that states it is safe to destroy an
initialized condition variable upon which no threads are currently blocked.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/90 is applied, updating words in the DESCRIPTION from "the
cancelability enable state" to "the cancelability type".
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/91 is applied, updating the ERRORS section to remove the error
case related to abstime from the pthread_cond_wait() function, and to make the error case related to abstime
mandatory for pthread_cond_timedwait() for consistency with other functions.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/92 is applied, adding a new paragraph to the RATIONALE section
stating that an application should check the predicate on any return from this function.
Issue 7
SD5-XSH-ERN-44 is applied, changing the definition of the "shall fail" case of the [EINVAL] error.
Changes are made from The Open Group Technical Standard, 2006, Extended API Set Part 3.
The pthread_cond_timedwait() and pthread_cond_wait() functions are moved from the Threads option to the Base.
The [EINVAL] error for an uninitialized condition variable or uninitialized mutex object is removed; this condition results in
undefined behavior"
The [EPERM] error is revised and moved to the "shall fail" list of error conditions for the pthread_cond_timedwait()
function.
The DESCRIPTION is updated to clarify the behavior when mutex is a robust mutex.
The ERRORS section is updated to include "shall fail" cases for PTHREAD_MUTEX_ERRORCHECK mutexes.
The DESCRIPTION is rewritten to clarify that undefined behavior occurs only for mutexes where the [EPERM] error is not
mandated.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0456 [91,286,437] and XSH/TC1-2008/0457 [239] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0271 [749] is applied.
Issue 8
Austin Group Defect 354 is applied, adding the [EAGAIN] error.
Austin Group Defect 1162 is applied, changing "an error code" to "[EOWNERDEAD]".
Austin Group Defects 1216 and 1485 are applied, adding pthread_cond_clockwait().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strpbrk.html =====
strpbrk
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strpbrk — scan a string for a byte
SYNOPSIS
#include
char *strpbrk(const char *s1, const char *s2);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The strpbrk() function shall locate the first occurrence in the string pointed to by s1 of any byte from the
string pointed to by s2.
[CX]  The
strpbrk() function shall not change the setting of errno on valid input.
RETURN VALUE
Upon successful completion, strpbrk() shall return a pointer to the byte or a null pointer if no byte from s2
occurs in s1.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
strchr(), strrchr()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that strpbrk() does not change the setting of errno on
valid input.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/vsscanf.html =====
vfscanf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
vfscanf, vscanf, vsscanf — format input of a stdarg argument list
SYNOPSIS
#include
#include
int vfscanf(FILE *restrict stream, const char *restrict format,
va_list arg);
int vscanf(const char *restrict format, va_list arg);
int vsscanf(const char *restrict s, const char *restrict format,
va_list arg);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The vscanf(), vfscanf(), and vsscanf() functions shall be equivalent to the scanf(), fscanf(), and sscanf() functions, respectively, except that instead of being called with a variable number
of arguments, they are called with an argument list as defined in the  header. These functions shall not invoke the va_end macro. As these
functions invoke the va_arg macro, the value of ap after the return is unspecified.
RETURN VALUE
Refer to fscanf().
ERRORS
Refer to fscanf().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications using these functions should call va_end(ap) afterwards to clean up.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fscanf()
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0704 [14] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/tanh.html =====
tanh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
tanh, tanhf, tanhl — hyperbolic tangent functions
SYNOPSIS
#include
double tanh(double x);
float tanhf(float x);
long double tanhl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the hyperbolic tangent of their argument x.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the hyperbolic tangent of x.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, x shall be returned.
If x is ±Inf, ±1 shall be returned.
[MXX]
If x is subnormal, x should be returned.
[MX]  If x is subnormal, a range error may occur and, if x is
not returned, tanh(), tanhf(), and tanhl() shall return an implementation-defined value no greater in
magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
ERRORS
These functions may fail if:
Range Error
[MX]
The value of x is subnormal.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
atanh(), feclearexcept(),
fetestexcept(), isnan(),
tan()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The tanhf() and tanhl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0638 [68] is applied.
Issue 8
Austin Group Defect 1382 is applied, rearranging the text describing the behavior when x is subnormal to avoid the need
for two shading changes.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/execv.html =====
exec
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
environ, execl, execle, execlp, execv, execve, execvp, fexecve — execute a file
SYNOPSIS
#include
extern char **environ;
int execl(const char *path, const char *arg0, ... /*, (char *)0 */);
int execle(const char *path, const char *arg0, ... /*,
(char *)0, char *const envp[]*/);
int execlp(const char *file, const char *arg0, ... /*, (char *)0 */);
int execv(const char *path, char *const argv[]);
int execve(const char *path, char *const argv[], char *const envp[]);
int execvp(const char *file, char *const argv[]);
int fexecve(int fd, char *const argv[], char *const envp[]);
DESCRIPTION
The exec family of functions shall replace the current process image with a new process image. The new image shall be
constructed from a regular, executable file called the new process image file. There shall be no return from a successful
exec, because the calling process image is overlaid by the new process image.
The fexecve() function shall be equivalent to the execve() function except that the file to be executed is
determined by the file descriptor fd instead of a pathname. The file offset of fd is ignored.
When a C-language program is executed as a result of a call to one of the exec family of functions, it shall be entered
as a C-language function call as follows:
int main (int argc, char *argv[]);
where argc is the argument count and argv is an array of character pointers to the arguments themselves. In
addition, the following variable, which needs to be declared by the user if it is to be used directly:
extern char **environ;
is initialized as a pointer to an array of character pointers to the environment strings. The argv and environ
arrays are each terminated by a null pointer. The null pointer terminating the argv array is not counted in argc.
Applications can change the entire environment in a single operation by assigning the environ variable to point to an
array of character pointers to the new environment strings. After assigning a new value to environ, applications should not
rely on the new environment strings remaining part of the environment, as a call to getenv(), secure_getenv(),
[XSI]
putenv(),  setenv(), unsetenv(), or any function that is
dependent on an environment variable may, on noticing that environ has changed, copy the environment strings to a new array
and assign environ to point to it.
Any application that directly modifies the pointers to which the environ variable points has undefined behavior.
Conforming multi-threaded applications shall not use the environ variable to access or modify any environment variable
while any other thread is concurrently modifying any environment variable. A call to any function dependent on any environment
variable shall be considered a use of the environ variable to access that environment variable.
The arguments specified by a program with one of the exec functions shall be passed on to the new process image in the
corresponding main() arguments.
For the execl(), execle(), execv(), and execve() functions, the argument path points to a
pathname that identifies the new process image file.
For the execlp() and execvp() functions, the argument file is used to construct a pathname that identifies
the new process image file. If the file argument contains a  character, the file argument shall be used
as the pathname for this file. Otherwise, the path prefix for this file is obtained by a search of the directories passed as the
environment variable PATH (see XBD 8. Environment Variables). If
this environment variable is not present, the results of the search are implementation-defined.
There are two distinct ways in which the contents of the process image file may cause the execution to fail, distinguished by
the setting of errno to either [ENOEXEC] or [EINVAL] (see the ERRORS section). In the cases where the other members of the
exec family of functions would fail and set errno to [ENOEXEC], the execlp() and execvp() functions
shall execute a command interpreter and the environment of the executed command shall be as if the process invoked the sh utility using execl() as follows:
execl(, , file, , (char *)0);
where  is an unspecified pathname for the sh utility,
is an unspecified string, file is the process image file, and where  is zero or more
parameters corresponding to any initial non-null arguments passed after arg0 for execlp() or to any initial non-null
members of argv starting at argv[1] for execvp().
The arguments represented by arg0,... are pointers to null-terminated character strings. These strings shall constitute
the argument list available to the new process image. The list is terminated by a null pointer. The argument arg0 should
point to a filename string that is associated with the process being started by one of the exec functions.
The argument argv is an array of character pointers to null-terminated strings. The application shall ensure that the
last member of this array is a null pointer. These strings shall constitute the argument list available to the new process image.
The value in argv[0] should point to a filename string that is associated with the process being started by one of the
exec functions.
The argument envp is an array of character pointers to null-terminated strings. These strings shall constitute the
environment for the new process image. The envp array is terminated by a null pointer.
For those forms not containing an envp pointer (execl(), execv(),
execlp(), and execvp()), the environment for the new process image shall be taken from the external variable
environ in the calling process.
The number of bytes available for the new process' combined argument and environment lists is {ARG_MAX}. It is
implementation-defined whether null terminators, pointers, and/or any alignment bytes are included in this total.
File descriptors open in the calling process image shall remain open in the new process image, except for those whose
close-on-exec flag FD_CLOEXEC is set. For those file descriptors that remain open, all attributes of the open file
description shall remain unchanged and the FD_CLOFORK file descriptor flag, if set, shall remain set. For any file descriptor that
is closed for this reason, process-owned file locks that the calling process owns on the file associated with the file descriptor
shall be unlocked as a result of the close, as described in close(). File locks that
are not unlocked by closing of file descriptors remain unchanged.
If file descriptor 0, 1, or 2 would otherwise be closed after a successful call to one of the exec family of functions,
implementations may open an unspecified file for the file descriptor in the new process image. If a standard utility or a
conforming application is executed with file descriptor 0 not open for reading or with file descriptor 1 or 2 not open for writing,
the environment in which the utility or application is executed shall be deemed non-conforming, and consequently the utility or
application might not behave as described in this standard.
Directory streams open in the calling process image shall be closed in the new process image.
The state of the floating-point environment in the initial thread of the new process image shall be set to the default.
The state of conversion descriptors and message catalog descriptors in the new process image is undefined.
For the new process image, the equivalent of:
setlocale(LC_ALL, "C")
shall be executed at start-up.
Signals set to the default action (SIG_DFL) in the calling process image shall be set to the default action in the new process
image. Except for SIGCHLD, signals set to be ignored (SIG_IGN) by the calling process image shall be set to be ignored by the new
process image. Signals set to be caught by the calling process image shall be set to the default action in the new process image
(see ).
If the SIGCHLD signal is set to be ignored by the calling process image, it is unspecified whether the SIGCHLD signal is set to
be ignored or to the default action in the new process image.
[XSI]
After a successful call to any of the exec functions, alternate signal stacks are not preserved and the SA_ONSTACK flag
shall be cleared for all signals.
After a successful call to any of the exec functions, any functions previously registered by the atexit(), at_quick_exit(), or pthread_atfork() functions are no longer registered.
[XSI]
If the ST_NOSUID bit is set for the file system containing the new process image file, then the effective user ID, effective group
ID, saved set-user-ID, and saved set-group-ID are unchanged in the new process image. Otherwise,  if the set-user-ID mode bit of the new process image file is set, the effective user ID of the new
process image shall be set to the user ID of the new process image file. Similarly, if the set-group-ID mode bit of the new process
image file is set, the effective group ID of the new process image shall be set to the group ID of the new process image file. The
real user ID, real group ID, and supplementary group IDs of the new process image shall remain the same as those of the calling
process image. The effective user ID and effective group ID of the new process image shall be saved (as the saved set-user-ID and
the saved set-group-ID) for use by setuid().
[XSI]
Any shared memory segments attached to the calling process image shall not be attached to the new process image.
Any named semaphores open in the calling process shall be closed as if by appropriate calls to sem_close(). Any unnamed semaphores open in the calling process shall be destroyed as if
by calls to sem_destroy().
[TYM]
Any blocks of typed memory that were mapped in the calling process are unmapped, as if munmap() was implicitly called to unmap them.
[ML]
Memory locks established by the calling process via calls to mlockall() or mlock() shall be removed. If locked pages in the address space of the calling process are also
mapped into the address spaces of other processes and are locked by those processes, the locks established by the other processes
shall be unaffected by the call by this process to the exec function. If the exec function fails, the effect on
memory locks is unspecified.
Memory mappings created in the process are unmapped before the address space is rebuilt for the new process image.
When the calling process image does not use the SCHED_FIFO, SCHED_RR, [SS]
or SCHED_SPORADIC   scheduling policies, the scheduling policy and parameters of the new process image and the initial
thread in that new process image are implementation-defined.
[PS]
When the calling process image uses the SCHED_FIFO, SCHED_RR, or SCHED_SPORADIC scheduling policies, the process policy and
scheduling parameter settings shall not be changed by a call to an exec function.  [TPS]   The initial thread in the new process image shall inherit the process scheduling policy and
parameters. It shall have the default system contention scope, but shall inherit its allocation domain from the calling process
image.
Per-process timers created by the calling process shall be deleted before replacing the current process image with the new
process image.
[MSG]
All open message queue descriptors in the calling process shall be closed, as described in mq_close().
Any outstanding asynchronous I/O operations may be canceled. Those asynchronous I/O operations that are not canceled shall
complete as if the exec function had not yet occurred, but any associated signal notifications shall be suppressed. It is
unspecified whether the exec function itself blocks awaiting such I/O completion. In no event, however, shall the new
process image created by the exec function be affected by the presence of outstanding asynchronous I/O operations at the
time the exec function is called. Whether any I/O is canceled, and which I/O may be canceled upon exec, is
implementation-defined.
[CPT]
The new process image shall inherit the CPU-time clock of the calling process image. This inheritance means that the process
CPU-time clock of the process being exec-ed shall not be reinitialized or altered as a result of the exec function
other than to reflect the time spent by the process executing the exec function itself.
[TCT]
The initial value of the CPU-time clock of the initial thread of the new process image shall be set to zero.
The thread ID of the initial thread in the new process image is unspecified.
The size and location of the stack on which the initial thread in the new process image runs is unspecified.
The initial thread in the new process image shall have its cancellation type set to PTHREAD_CANCEL_DEFERRED and its cancellation
state set to PTHREAD_CANCEL_ENABLED.
The initial thread in the new process image shall have all thread-specific data values set to NULL and all thread-specific data
keys shall be removed by the call to exec without running destructors.
The initial thread in the new process image shall be joinable, as if created with the detachstate attribute set to
PTHREAD_CREATE_JOINABLE.
The new process shall inherit at least the following attributes from the calling process image:
[XSI]
Nice value (see nice())
[XSI]
semadj values (see semop())
Process ID
Parent process ID
Process group ID
Session membership
Real user ID
Real group ID
Supplementary group IDs
Time left until an alarm clock signal (see alarm())
Current working directory
Root directory
File mode creation mask (see umask())
File size limit (see getrlimit() and setrlimit())
Process signal mask (see pthread_sigmask())
Pending signal (see sigpending())
tms_utime, tms_stime, tms_cutime, and tms_cstime (see times())
Resource limits
Controlling terminal
The initial thread of the new process shall inherit at least the following attributes from the calling thread:
Signal mask (see sigprocmask() and pthread_sigmask())
Pending signals (see sigpending())
All other process attributes defined in this volume of POSIX.1-2024 shall be inherited in the new process image from the old
process image. All other thread attributes defined in this volume of POSIX.1-2024 shall be inherited in the initial thread in the
new process image from the calling thread in the old process image. The inheritance of process or thread attributes not defined by
this volume of POSIX.1-2024 is implementation-defined.
A call to any exec function from a process with more than one thread shall result in all threads being terminated and the
new executable image being loaded and executed. No destructor functions or cleanup handlers shall be called.
Upon successful completion, the exec functions shall mark for update the last data access timestamp of the file. If an
exec function failed but was able to locate the process image file, whether the last data access timestamp is marked for
update is unspecified. Should the exec function succeed, the process image file shall be considered to have been opened with
open(). The corresponding close() shall be
considered to occur at a time after this open, but before process termination or successful completion of a subsequent call to one
of the exec functions, posix_spawn(), or posix_spawnp(). The argv[] and envp[] arrays of pointers and the strings
to which those arrays point shall not be modified by a call to one of the exec functions, except as a consequence of
replacing the process image.
The saved resource limits in the new process image are set to be a copy of the process' corresponding hard and soft limits.
RETURN VALUE
If one of the exec functions returns to the calling process image, an error has occurred; the return value shall be -1,
and errno shall be set to indicate the error.
ERRORS
The exec functions shall fail if:
[E2BIG]
The number of bytes used by the new process image's argument list and environment list is greater than the system-imposed limit
of {ARG_MAX} bytes.
[EACCES]
The new process image file is not a regular file and the implementation does not support execution of files of its type.
[EINVAL]
The new process image file has appropriate privileges and has a recognized executable binary format, but the system does not
support execution of a file with this format.
The exec functions, except for fexecve(), shall fail if:
[EACCES]
Search permission is denied for a directory listed in the new process image file's path prefix, or the new process image file
denies execution permission.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path or file argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of path or file does not name an existing file or path or file is an empty string.
[ENOTDIR]
A component of the new process image file's path prefix names an existing file that is neither a directory nor a symbolic link
to a directory, or the new process image file's pathname contains at least one non- character and ends with one or
more trailing  characters and the last pathname component names an existing file that is neither a directory nor a
symbolic link to a directory.
The exec functions, except for execlp() and execvp(), shall fail if:
[ENOEXEC]
The new process image file has the appropriate access permission but has an unrecognized format.
The fexecve() function shall fail if:
[EBADF]
The fd argument is not a valid file descriptor open for executing.
The exec functions may fail if:
[ENOMEM]
The new process image requires more memory than is allowed by the hardware or system-imposed memory management
constraints.
The exec functions, except for fexecve(), may fail if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path or file argument.
[ENAMETOOLONG]
The length of the path argument or the length of the pathname constructed from the file argument exceeds {PATH_MAX},
or pathname resolution of a symbolic link produced an intermediate result with a length that exceeds {PATH_MAX}.
[ETXTBSY]
The new process image file is a pure procedure (shared text) file that is currently open for writing by some process.
The following sections are informative.
EXAMPLES
Using execl()
The following example executes the ls command, specifying the pathname of the
executable (/bin/ls) and using arguments supplied directly to the command to produce single-column output.
#include
int ret;
...
ret = execl ("/bin/ls", "ls", "-1", (char *)0);
Using execle()
The following example is similar to Using execl(). In addition, it specifies the environment
for the new process image using the env argument.
#include
int ret;
char *env[] = { "HOME=/usr/home", "LOGNAME=home", (char *)0 };
...
ret = execle ("/bin/ls", "ls", "-l", (char *)0, env);
Using execlp()
The following example searches for the location of the ls command among the
directories specified by the PATH environment variable.
#include
int ret;
...
ret = execlp ("ls", "ls", "-l", (char *)0);
Using execv()
The following example passes arguments to the ls command in the cmd array.
#include
int ret;
char *cmd[] = { "ls", "-l", (char *)0 };
...
ret = execv ("/bin/ls", cmd);
Using execve()
The following example passes arguments to the ls command in the cmd array, and
specifies the environment for the new process image using the env argument.
#include
int ret;
char *cmd[] = { "ls", "-l", (char *)0 };
char *env[] = { "HOME=/usr/home", "LOGNAME=home", (char *)0 };
...
ret = execve ("/bin/ls", cmd, env);
Using execvp()
The following example searches for the location of the ls command among the
directories specified by the PATH environment variable, and passes arguments to the ls command in the cmd array.
#include
int ret;
char *cmd[] = { "ls", "-l", (char *)0 };
...
ret = execvp ("ls", cmd);
APPLICATION USAGE
As the state of conversion descriptors and message catalog descriptors in the new process image is undefined, conforming
applications should not rely on their use and should close them prior to calling one of the exec functions.
Applications that require other than the default POSIX locale as the global locale in the new process image should call setlocale() with the appropriate parameters.
When assigning a new value to the environ variable, applications should ensure that the environment to which it will
point contains at least the following:
Any implementation-defined variables required by the implementation to provide a conforming environment. See the _CS_V8_ENV
entry in  and confstr() for details.
A value for PATH which finds conforming versions of all standard utilities before any other versions.
The same constraint applies to the envp array passed to execle() or execve(), in order to ensure that the
new process image is invoked in a conforming environment.
Applications should not execute programs with file descriptor 0 not open for reading or with file descriptor 1 or 2 not open for
writing, as this might cause the executed program to misbehave. In order not to pass on these file descriptors to an executed
program, applications should not just close them but should reopen them on, for example, /dev/null. Some implementations may
reopen them automatically, but applications should not rely on this being done.
If an application wants to perform an integrity test of the file being executed before executing it, the file will need to be
opened with read permission to perform the integrity test.
Since execute permission is checked by fexecve(), the file description fd need not have been opened with the
O_EXEC flag. However, if the file to be executed denies read and write permission for the process preparing to do the exec,
the only way to provide the fd to fexecve() will be to use the O_EXEC flag when opening fd. In this case, the
application will not be able to perform an integrity test since it will not be able to read the contents of the file.
Note that when a file descriptor is opened with O_RDONLY, O_RDWR, or O_WRONLY mode, the file descriptor can be used to read,
read and write, or write the file, respectively, even if the mode of the file changes after the file was opened. Using the O_EXEC
open mode is different; fexecve() will ignore the mode that was used when the file descriptor was opened and the exec
will fail if the mode of the file associated with fd does not grant execute permission to the calling process at the time
fexecve() is called.
RATIONALE
Early proposals required that the value of argc passed to main() be "one or greater". This was driven by the
same requirement in drafts of the ISO C standard. In fact, historical implementations have passed a value of zero when no
arguments are supplied to the caller of the exec functions. This requirement was removed from the ISO C standard and
subsequently removed from this volume of POSIX.1-2024 as well. The wording, in particular the use of the word should,
requires a Strictly Conforming POSIX Application to pass at least one argument to the exec function, thus guaranteeing that
argc be one or greater when invoked by such an application. In fact, this is good practice, since many existing applications
reference argv[0] without first checking the value of argc.
The requirement on a Strictly Conforming POSIX Application also states that the value passed as the first argument be a filename
string associated with the process being started. Although some existing applications pass a pathname rather than a filename string
in some circumstances, a filename string is more generally useful, since the common usage of argv[0] is in printing
diagnostics. In some cases the filename passed is not the actual filename of the file; for example, many implementations of the
login utility use a convention of prefixing a  ('-') to the actual filename, which indicates to
the command interpreter being invoked that it is a "login shell".
Also, note that the test and [ utilities require specific strings for the
argv[0] argument to have deterministic behavior across all implementations.
Historically, there have been two ways that implementations can exec shell scripts.
One common historical implementation is that the execl(), execv(), execle(), and execve() functions
return an [ENOEXEC] error for any file not recognizable as executable, including a shell script. When the execlp() and
execvp() functions encounter such a file, they assume the file to be a shell script and invoke a known command interpreter
to interpret such files. This is now required by POSIX.1-2024. These implementations of execvp() and execlp() only
give the [ENOEXEC] error in the rare case of a problem with the command interpreter's executable file. Because of these
implementations, the [ENOEXEC] error is not mentioned for execlp() or execvp(), although implementations can still
give it.
Another way that some historical implementations handle shell scripts is by recognizing the first two bytes of the file as the
character string "#!" and using the remainder of the first line of the file as the name of the command interpreter to
execute.
One potential source of confusion noted by the standard developers is over how the contents of a process image file affect the
behavior of the exec family of functions. The following is a description of the actions taken:
If the process image file is a valid executable (in a format that is executable and valid and having appropriate privileges) for
this system, then the system executes the file.
If the process image file has appropriate privileges and is in a format that is executable but not valid for this system (such
as a recognized binary for another architecture), then this is an error and errno is set to [EINVAL] (see later RATIONALE on
[EINVAL]).
If the process image file has appropriate privileges but is not otherwise recognized:
If this is a call to execlp() or execvp(), then they invoke a command interpreter assuming that the process image
file is a shell script.
If this is not a call to execlp() or execvp(), then an error occurs and errno is set to [ENOEXEC].
Applications that do not require to access their arguments may use the form:
main(void)
as specified in the ISO C standard. However, the implementation will always provide the two arguments argc and
argv, even if they are not used.
Some implementations provide a third argument to main() called envp. This is defined as a pointer to the
environment. The ISO C standard specifies invoking main() with two arguments, so implementations are required to
support applications written this way. Since this volume of POSIX.1-2024 defines the global variable environ, which is also
provided by historical implementations and can be used anywhere that envp could be used, there is no functional need for the
envp argument. Applications should use the getenv() function rather than
accessing the environment directly via either envp or environ. Implementations are required to support the
two-argument calling sequence, but this does not prohibit an implementation from supporting envp as an optional third
argument.
This volume of POSIX.1-2024 specifies that signals set to SIG_IGN remain set to SIG_IGN, and that the new process image inherits
the signal mask of the thread that called exec in the old process image. This is consistent with historical implementations,
and it permits some useful functionality, such as the nohup command. However, it
should be noted that many existing applications wrongly assume that they start with certain signals set to the default action
and/or unblocked. In particular, applications written with a simpler signal model that does not include blocking of signals, such
as the one in the ISO C standard, may not behave properly if invoked with some signals blocked. Therefore, it is best not to
block or ignore signals across execs without explicit reason to do so, and especially not to block signals across
execs of arbitrary (not closely cooperating) programs.
The exec functions always save the value of the effective user ID and effective group ID of the process at the completion
of the exec, whether or not the set-user-ID or the set-group-ID bit of the process image file is set.
The statement about argv[] and envp[] being constants is included to make explicit to future writers of language
bindings that these objects are completely constant. Due to a limitation of the ISO C standard, it is not possible to state
that idea in standard C. Specifying two levels of const-qualification for the argv[] and envp[]
parameters for the exec functions may seem to be the natural choice, given that these functions do not modify either the
array of pointers or the characters to which the function points, but this would disallow existing correct code. Instead, only the
array of pointers is noted as constant. The table of assignment compatibility for dst=src derived from the ISO C
standard summarizes the compatibility:
dst:
char *[]
const char *[]
char *const[]
const char *const[]
src:
char *[]
VALID
—
VALID
—
const char *[]
—
VALID
—
VALID
char * const []
—
—
VALID
—
const char *const[]
—
—
—
VALID
Since all existing code has a source type matching the first row, the column that gives the most valid combinations
is the third column. The only other possibility is the fourth column, but using it would require a cast on the argv or
envp arguments. It is unfortunate that the fourth column cannot be used, because the declaration a non-expert would
naturally use would be that in the second row.
The ISO C standard and this volume of POSIX.1-2024 do not conflict on the use of environ, but some
historical implementations of environ may cause a conflict. As long as environ is treated in the same way as an entry
point (for example, fork()), it conforms to both standards. A library can contain
fork(), but if there is a user-provided fork(), that fork() is given precedence and no
problem ensues. The situation is similar for environ: the definition in this volume of POSIX.1-2024 is to be used if there
is no user-provided environ to take precedence. At least three implementations are known to exist that solve this
problem.
[E2BIG]
The limit {ARG_MAX} applies not just to the size of the argument list, but to the sum of that and the size of the environment
list.
[EFAULT]
Some historical systems return [EFAULT] rather than [ENOEXEC] when the new process image file is corrupted. They are
non-conforming.
[EINVAL]
This error condition was added to POSIX.1-2024 to allow an implementation to detect executable files generated for different
architectures, and indicate this situation to the application. Historical implementations of shells, execvp(), and
execlp() that encounter an [ENOEXEC] error will execute a shell on the assumption that the file is a shell script. This will
not produce the desired effect when the file is a valid executable for a different architecture. An implementation may now choose
to avoid this problem by returning [EINVAL] when a valid executable for a different architecture is encountered. Some historical
implementations return [EINVAL] to indicate that the path argument contains a character with the high order bit set. The
standard developers chose to deviate from historical practice for the following reasons:
The new utilization of [EINVAL] will provide some measure of utility to the user community.
Historical use of [EINVAL] is not acceptable in an internationalized operating environment.
[ENAMETOOLONG]
Since the file pathname may be constructed by taking elements in the PATH variable and putting them together with the
filename, the [ENAMETOOLONG] error condition could also be reached this way.
[ETXTBSY]
System V returns this error when the executable file is currently open for writing by some process. This volume of POSIX.1-2024
neither requires nor prohibits this behavior.
Other systems (such as System V) may return [EINTR] from exec. This is not addressed by this volume of
POSIX.1-2024, but implementations may have a window between the call to exec and the time that a signal could cause one of
the exec calls to return with [EINTR].
An explicit statement regarding the floating-point environment (as defined in the  header) was added to make it clear that the floating-point environment is set
to its default when a call to one of the exec functions succeeds. The requirements for inheritance or setting to the default
for other process and thread start-up functions is covered by more generic statements in their descriptions and can be summarized
as follows:
posix_spawn()
Set to default.
fork()
Inherit.
pthread_create()
Inherit.
The purpose of the fexecve() function is to enable executing a file which has been verified to be the
intended file. It is possible to actively check the file by reading from the file descriptor and be sure that the file is not
exchanged for another between the reading and the execution. Alternatively, a function like openat() can be used to open a file which has been found by reading the content of a
directory using readdir().
When execlp() or execvp() fall back to invoking sh because
of an [ENOEXEC] condition, the standard leaves the process name (what becomes argv[0] in the resulting sh process) unspecified. Existing implementations vary on whether they pass a variation of
"sh", or preserve the original arg0. There are existing implementations of sh that behave differently depending on the contents of argv[0], such that blindly passing
the original arg0 on to the fallback execution can fail to invoke a compliant shell environment. Because of the requirements
on how sh handles its command line arguments, the shell script will see $0
containing the pathname of the script being executed, regardless of the value of argv[0].
FUTURE DIRECTIONS
None.
SEE ALSO
alarm(), atexit(), chmod(), close(), confstr(), exit(), fcntl(), fork(), fstatvfs(), getenv(), getrlimit(), mknod(), mmap(), nice(), open(), posix_spawn(), pthread_atfork(), pthread_sigmask(), putenv(),
readdir(), semop(), setlocale(), shmat(), sigaction(), sigaltstack(),
sigpending(), system(),
times(), umask()
XBD 8. Environment Variables,
XCU test
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Realtime Extension and the POSIX Threads Extension.
Large File Summit extensions are added.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the DESCRIPTION, behavior is defined for when the process image file is not a valid executable.
In this version, _POSIX_SAVED_IDS is mandated, thus the effective user ID and effective group ID of the new
process image shall be saved (as the saved set-user-ID and the saved set-group-ID) for use by the setuid() function.
The [ELOOP] mandatory error condition is added.
A second [ENAMETOOLONG] is added as an optional error condition.
The [ETXTBSY] optional error condition is added.
The following changes were made to align with the IEEE P1003.1a draft standard:
The [EINVAL] mandatory error condition is added.
The [ELOOP] optional error condition is added.
The description of CPU-time clock semantics is added for alignment with IEEE Std 1003.1d-1999.
The DESCRIPTION is updated for alignment with IEEE Std 1003.1j-2000 by adding semantics for typed
memory.
The normative text is updated to avoid use of the term "must" for application requirements.
The description of tracing semantics is added for alignment with IEEE Std 1003.1q-2000.
IEEE PASC Interpretation 1003.1 #132 is applied.
The DESCRIPTION is updated to make it explicit that the floating-point environment in the new process image is set
to the default.
The DESCRIPTION and RATIONALE are updated to include clarifications of how the contents of a process image file
affect the behavior of the exec functions.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/15 is applied, adding a new paragraph to the
DESCRIPTION and text to the end of the APPLICATION USAGE section. This change addresses a security concern, where implementations
may want to reopen file descriptors 0, 1, and 2 for programs with the set-user-id or set-group-id file mode bits calling the
exec family of functions.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/24 is applied, applying changes to the DESCRIPTION,
addressing which attributes are inherited by threads, and behavioral requirements for threads attributes.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/25 is applied, updating text in the RATIONALE from
"the process signal mask be unchanged across an exec" to "the new process image inherits the signal mask of the thread
that called exec in the old process image".
Issue 7
Austin Group Interpretation 1003.1-2001 #047 is applied, adding the description of _CS_V7_ENV to the APPLICATION USAGE.
Austin Group Interpretation 1003.1-2001 #143 is applied.
The fexecve() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 2.
Functionality relating to the Asynchronous Input and Output, Memory Mapped Files, Threads, and Timers options is
moved to the Base.
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0095 [386], XSH/TC1-2008/0096 [167], XSH/TC1-2008/0097 [291],
XSH/TC1-2008/0098 [173], XSH/TC1-2008/0099 [296], XSH/TC1-2008/00100 [324], XSH/TC1-2008/00101 [296], XSH/TC1-2008/00102 [302],
XSH/TC1-2008/00103 [167], XSH/TC1-2008/00104 [173], and XSH/TC1-2008/00105 [291,429] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0097 [584], XSH/TC2-2008/0098 [898], and XSH/TC2-2008/0099
[734] are applied.
Issue 8
Austin Group Defects 51 and 1669 are applied, moving the getrlimit() and
setrlimit() functions from the XSI option to the Base.
Austin Group Defect 368 is applied, adding a requirement for unnamed semaphores to be destroyed.
Austin Group Defect 768 is applied, adding OFD-owned file locks.
Austin Group Defect 922 is applied, adding the secure_getenv()
function.
Austin Group Defect 1284 is applied, changing "checksum test" to "integrity test" in the APPLICATION USAGE
section.
Austin Group Defect 1318 is applied, adding FD_CLOFORK.
Austin Group Defect 1330 is applied, removing obsolescent interfaces and changing "_V7_" to "_V8_".
Austin Group Defect 1435 is applied, adding function lists to the descriptions of the path and file
arguments.
Austin Group Defect 1645 is applied, making it unspecified what string is passed to the shell in argv[0]
when executed by execlp() or execvp().
Austin Group Defect 1646 is applied, adding at_quick_exit() to
the list of registration functions whose registrations are not inherited across exec.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sem_getvalue.html =====
sem_getvalue
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sem_getvalue — get the value of a semaphore
SYNOPSIS
#include
int sem_getvalue(sem_t *restrict sem, int *restrict sval);
DESCRIPTION
The sem_getvalue() function shall update the location referenced by the sval argument to have the value of the
semaphore referenced by sem without affecting the state of the semaphore. The updated value represents an actual semaphore
value that occurred at some unspecified time during the call, but it need not be the actual value of the semaphore when it is
returned to the calling process.
If sem is locked, then the object to which sval points shall either be set to zero or to a negative number whose
absolute value represents the number of processes waiting for the semaphore at some unspecified time during the call.
RETURN VALUE
Upon successful completion, the sem_getvalue() function shall return a value of zero. Otherwise, it shall return a value
of -1 and set errno to indicate the error.
ERRORS
The sem_getvalue() function may fail if:
[EINVAL]
The sem argument does not refer to a valid semaphore.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
semctl(), semget(), semop(), sem_clockwait(), sem_post(), sem_trywait()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The sem_getvalue() function is marked as part of the Semaphores option.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Semaphores
option.
The sem_timedwait() function is added to the SEE ALSO section for alignment
with IEEE Std 1003.1d-1999.
The restrict keyword is added to the sem_getvalue() prototype for alignment with the ISO/IEC 9899:1999
standard.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/54 is applied.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/115 is applied, updating the ERRORS section so that the [EINVAL]
error becomes optional.
Issue 7
The sem_getvalue() function is moved from the Semaphores option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0525 [37] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/vscanf.html =====
vfscanf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
vfscanf, vscanf, vsscanf — format input of a stdarg argument list
SYNOPSIS
#include
#include
int vfscanf(FILE *restrict stream, const char *restrict format,
va_list arg);
int vscanf(const char *restrict format, va_list arg);
int vsscanf(const char *restrict s, const char *restrict format,
va_list arg);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The vscanf(), vfscanf(), and vsscanf() functions shall be equivalent to the scanf(), fscanf(), and sscanf() functions, respectively, except that instead of being called with a variable number
of arguments, they are called with an argument list as defined in the  header. These functions shall not invoke the va_end macro. As these
functions invoke the va_arg macro, the value of ap after the return is unspecified.
RETURN VALUE
Refer to fscanf().
ERRORS
Refer to fscanf().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications using these functions should call va_end(ap) afterwards to clean up.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fscanf()
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0704 [14] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/cbrt.html =====
cbrt
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cbrt, cbrtf, cbrtl — cube root functions
SYNOPSIS
#include
double cbrt(double x);
float cbrtf(float x);
long double cbrtl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the real cube root of their argument x.
RETURN VALUE
Upon successful completion, these functions shall return the cube root of x.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0 or ±Inf, x shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
For some applications, a true cube root function, which returns negative results for negative arguments, is more appropriate
than pow(x, 1.0/3.0), which returns a NaN for x less than 0.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The cbrt() function is no longer marked as an extension.
The cbrtf() and cbrtl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/erfcl.html =====
erfc
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
erfc, erfcf, erfcl — complementary error functions
SYNOPSIS
#include
double erfc(double x);
float erfcf(float x);
long double erfcl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complementary error function 1.0 - erf(x).
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the value of the complementary error function.
If the correct value would cause underflow, [MXX]   and is not representable,   a range error may occur, and erfc(), erfcf(), and erfcl() shall return
[MXX]
0.0, or   (if the IEC 60559 Floating-Point option is not
supported) an implementation-defined value no greater in magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, +1 shall be returned.
If x is -Inf, +2 shall be returned.
If x is +Inf, +0 shall be returned.
[MXX]
If the correct value would cause underflow and is representable, a range error may occur and the correct value shall be returned.
ERRORS
These functions may fail if:
Range Error
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The erfc() function is provided because of the extreme loss of relative accuracy if erf(x) is called for
large x and the result subtracted from 1.0.
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
erf(), feclearexcept(),
fetestexcept(), isnan()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The erfc() function is no longer marked as an extension.
These functions are split out from the erf() reference page.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0093 [68] and XSH/TC1-2008/0094 [68] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0096 [630] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strtoull.html =====
strtoul
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strtoul, strtoull — convert a string to an unsigned long
SYNOPSIS
#include
unsigned long strtoul(const char *restrict str,
char **restrict endptr, int base);
unsigned long long strtoull(const char *restrict str,
char **restrict endptr, int base);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall convert the initial portion of the string pointed to by str to a type unsigned long and
unsigned long long representation, respectively. First, they decompose the input string into three parts:
An initial, possibly empty, sequence of white-space bytes
A subject sequence interpreted as an integer represented in some radix determined by the value of base
A final string of one or more unrecognized characters, including the terminating NUL character of the input string
Then they shall attempt to convert the subject sequence to an unsigned integer, and return the result.
If the value of base is 0, the expected form of the subject sequence is that of a decimal constant, octal constant, or
hexadecimal constant, any of which may be preceded by a '+' or '-' sign. A decimal constant begins with a
non-zero digit, and consists of a sequence of decimal digits. An octal constant consists of the prefix '0' optionally
followed by a sequence of the digits '0' to '7' only. A hexadecimal constant consists of the prefix 0x or 0X
followed by a sequence of the decimal digits and letters 'a' (or 'A') to 'f' (or 'F') with
values 10 to 15 respectively.
If the value of base is between 2 and 36, the expected form of the subject sequence is a sequence of letters and digits
representing an integer with the radix specified by base, optionally preceded by a '+' or '-' sign. The
letters from 'a' (or 'A') to 'z' (or 'Z') inclusive are ascribed the values 10 to 35; only
letters whose ascribed values are less than that of base are permitted. If the value of base is 16, the characters 0x
or 0X may optionally precede the sequence of letters and digits, following the sign if present.
The subject sequence is defined as the longest initial subsequence of the input string, starting with the first non-white-space
byte, that is of the expected form. The subject sequence shall contain no characters if the input string is empty or consists
entirely of white-space bytes, or if the first non-white-space byte is other than a sign or a permissible letter or digit.
If the subject sequence has the expected form and the value of base is 0, the sequence of characters starting with the
first digit shall be interpreted as an integer constant. If the subject sequence has the expected form and the value of base
is between 2 and 36, it shall be used as the base for conversion, ascribing to each letter its value as given above. If the subject
sequence begins with a , the resulting value shall be the negative of the converted value; this action shall be
performed in the return type. A pointer to the final string shall be stored in the object pointed to by endptr, provided
that endptr is not a null pointer.
In other than the C [CX]   or POSIX  locale, additional
locale-specific subject sequence forms may be accepted.
If the subject sequence is empty or does not have the expected form, no conversion shall be performed; the value of str
shall be stored in the object pointed to by endptr, provided that endptr is not a null pointer.
These functions shall not change the setting of errno if successful.
Since 0, {ULONG_MAX}, and {ULLONG_MAX} are returned on error and are also valid returns on success, an application wishing to
check for error situations should set errno to 0, then call strtoul() or strtoull(), then check
errno.
RETURN VALUE
Upon successful completion, these functions shall return the converted value, if any. If no conversion could be performed, 0
shall be returned [CX]   and errno may be set to [EINVAL].
[CX]  If
the value of base is not supported, 0 shall be returned and errno shall be set to [EINVAL].
If the correct value is outside the range of representable values, {ULONG_MAX} or {ULLONG_MAX} shall be returned and
errno set to [ERANGE].
ERRORS
These functions shall fail if:
[EINVAL]
[CX]
The value of base is not supported.
[ERANGE]
The value to be returned is not representable.
These functions may fail if:
[EINVAL]
[CX]  No
conversion could be performed.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Since the value of *endptr is unspecified if the value of base is not supported, applications should either ensure
that base has a supported value (0 or between 2 and 36) before the call, or check for an [EINVAL] error before examining
*endptr.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
fscanf(), isalpha(), strtod(), strtol()
XBD
CHANGE HISTORY
First released in Issue 4. Derived from the ANSI C standard.
Issue 5
The DESCRIPTION is updated to indicate that errno is not changed if the function is successful.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The [EINVAL] error condition is added for when the value of base is not supported.
In the RETURN VALUE and ERRORS sections, the [EINVAL] optional error condition is added if no conversion could be performed.
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The strtoul() prototype is updated.
The strtoull() function is added.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0621 [105], XSH/TC1-2008/0622 [453], and XSH/TC1-2008/0623 [453] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0355 [584] and XSH/TC2-2008/0356 [796] are applied.
Issue 8
Austin Group Defect 700 is applied, clarifying how a subject sequence beginning with  is converted.
Austin Group Defect 1163 is applied, clarifying the handling of white space in the input string.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strlcat.html =====
strlcat
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strlcat, strlcpy — size-bounded string concatenation and copying
SYNOPSIS
[CX]  #include
size_t strlcat(char *restrict dst, const char *restrict src,
size_t dstsize);
size_t strlcpy(char *restrict dst, const char *restrict src,
size_t dstsize);
DESCRIPTION
The strlcpy() and strlcat() functions copy and concatenate strings, stopping when either a NUL terminator in the
source string is encountered or the specified full size of the destination buffer is reached. They NUL terminate the result if
there is room. The application should ensure that room for the NUL terminator is included in dstsize.
The strlcpy() function shall copy not more than dstsize - 1 bytes from the string pointed to by src to the
array pointed to by dst; a NUL byte in src and bytes that follow it shall not be copied. A terminating NUL byte shall
be appended to the result, unless dstsize is 0. If copying takes place between objects that overlap, the behavior is
undefined.
The strlcat() function shall append not more than dstsize - strlen(dst) - 1 bytes from the string
pointed to by src to the end of the string pointed to by dst; a NUL byte in src and bytes that follow it shall
not be appended. The initial byte of src shall overwrite the NUL byte at the end of dst. A terminating NUL byte shall
be appended to the result, unless its location would be at or beyond dst + dstsize. If copying takes place between
objects that overlap, the behavior is undefined.
The strlcpy() and strlcat() functions shall not change the setting of errno on valid input.
RETURN VALUE
Upon successful completion, the strlcpy() function shall return the length of the string pointed to by src; that
is, the number of bytes in the string, not including the terminating NUL byte.
Upon successful completion, the strlcat() function shall return the initial length of the string (if any) pointed to by
dst, as limited by dstsize, plus the length of the string pointed to by src; that is, the value that would be
returned by strnlen(dst, dstsize) + strlen(src) before the strlcat() call.
No return values are reserved to indicate an error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
The following example detects truncation while combining a path prefix (including trailing ) and a filename to
produce a portable pathname:
char *prefix, *filenam, pathnam[_POSIX_PATH_MAX];
if (strlcpy(pathnam, prefix, sizeof pathnam) >= sizeof pathnam ||
strlcat(pathnam, filenam, sizeof pathnam) >= sizeof pathnam)
{
// truncation occurred
...
}
This code ensures there is room for the NUL terminator by:
Calling strlcpy() with a non-zero dstsize argument.
Only calling strlcat() if the return value of strlcpy() indicated that truncation did not occur.
APPLICATION USAGE
The return value of the strlcpy() and strlcat() functions follows the same convention as snprintf(); that is, they return the total length of the string they tried to create. If
the return value is greater than or equal to dstsize, the output string has been truncated.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
fprintf(), strlen(), strncat(), strncpy(), wcslcat()
XBD
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wmemcmp.html =====
wmemcmp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wmemcmp — compare wide characters in memory
SYNOPSIS
#include
int wmemcmp(const wchar_t *ws1, const wchar_t *ws2, size_t n);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The wmemcmp() function shall compare the first n wide characters of the object pointed to by ws1 to the
first n wide characters of the object pointed to by ws2. This function shall not be affected by locale and all
wchar_t values shall be treated identically. The null wide character and wchar_t values not corresponding to valid
characters shall not be treated specially.
If n is zero, the application shall ensure that ws1 and ws2 are valid pointers, and the function shall
behave as if the two objects compare equal.
[CX]  The
wmemcmp() function shall not change the setting of errno on valid input.
RETURN VALUE
The wmemcmp() function shall return an integer greater than, equal to, or less than zero, respectively, as the object
pointed to by ws1 is greater than, equal to, or less than the object pointed to by ws2.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
wmemchr(), wmemcpy(), wmemmove(), wmemset()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E).
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that wmemcmp() does not change the setting of errno on
valid input.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/swprintf.html =====
fwprintf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fwprintf, swprintf, wprintf — print formatted wide-character output
SYNOPSIS
#include
#include
int fwprintf(FILE *restrict stream, const wchar_t *restrict format, ...);
int swprintf(wchar_t *restrict ws, size_t n,
const wchar_t *restrict format, ...);
int wprintf(const wchar_t *restrict format, ...);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The fwprintf() function shall place output on the named output stream. The wprintf() function shall place
output on the standard output stream stdout. The swprintf() function shall place output followed by the null wide
character in consecutive wide characters starting at *ws; no more than n wide characters shall be written, including
a terminating null wide character, which is always added (unless n is zero).
Each of these functions shall convert, format, and print its arguments under control of the format wide-character string.
The format is composed of zero or more directives: ordinary wide-characters, which are simply copied to the output
stream, and conversion specifications, each of which results in the fetching of zero or more arguments. The results are
undefined if there are insufficient arguments for the format. If the format is exhausted while arguments remain, the
excess arguments are evaluated but are otherwise ignored.
[CX]
Conversions can be applied to the nth argument after the format in the argument list, rather than to the next unused
argument. In this case, the conversion specifier wide character % (see below) is replaced by the sequence "%n$",
where n is a decimal integer in the range [1,{NL_ARGMAX}], giving the position of the argument in the argument list. This
feature provides for the definition of format wide-character strings that select arguments in an order appropriate to
specific languages (see the EXAMPLES section).
The format can contain either numbered argument conversion specifications (that is, those introduced by
"%n$" and optionally containing the "*m$" forms of field width and precision), or
unnumbered argument conversion specifications (that is, those introduced by the % character and optionally containing the
* form of field width and precision), but not both. The only exception to this is that %% can be mixed with the
"%n$" form. The results of mixing numbered and unnumbered argument specifications in a format
wide-character string are undefined. When numbered argument specifications are used, specifying the Nth argument requires
that all the leading arguments, from the first to the (N-1)th, are specified in the format wide-character string.
In format wide-character strings containing the "%n$" form of conversion specification, numbered
arguments in the argument list can be referenced from the format wide-character string as many times as required.
In format wide-character strings containing the % form of conversion specification, each argument in the
argument list shall be used exactly once. It is unspecified whether an encoding error occurs if the format string contains
wchar_t values that do not correspond to members of the character set of the current locale and the specified semantics do
not require that value to be processed by wcrtomb().
[CX]  All
forms of the fwprintf() function allow for the insertion of a locale-dependent radix character in the output string, output
as a wide-character value. The radix character is defined in the current locale (category LC_NUMERIC ). In the POSIX locale,
or in a locale where the radix character is not defined, the radix character shall default to a  ('.').
Each conversion specification is introduced by the '%' wide character [CX]   or by the
wide-character sequence "%n$",   after
which the following appear in sequence:
Zero or more flags (in any order), which modify the meaning of the conversion specification.
An optional minimum field width. If the converted value has fewer wide characters than the field width, it shall be
padded with  characters by default on the left; it shall be padded on the right, if the left-adjustment flag
('-'), described below, is given to the field width. The field width takes the form of an  ('*'),
[CX]
or in conversion specifications introduced by "%n$" the "*m$" string,
described below, or a decimal integer.
An optional precision that gives the minimum number of digits to appear for the d, i, o,
u, x, and X conversion specifiers; the number of digits to appear after the radix character for the
a, A, e, E, f, and F conversion specifiers; the maximum number of significant
digits for the g and G conversion specifiers; or the maximum number of wide characters to be printed from a
string in the s conversion specifiers. The precision takes the form of a  ('.') followed either by
an  ('*'), [CX]   or in conversion specifications introduced by "%n$" the
"*m$" string,  described below, or an
optional decimal digit string, where a null digit string is treated as 0. If a precision appears with any other conversion wide
character, the behavior is undefined.
An optional length modifier that specifies the size of the argument.
A conversion specifier wide character that indicates the type of conversion to be applied.
A field width, or precision, or both, may be indicated by an  ('*'). In this case an argument of type
int supplies the field width or precision. Applications shall ensure that arguments specifying field width, or precision, or
both appear in that order before the argument, if any, to be converted. A negative field width is taken as a '-' flag
followed by a positive field width. A negative precision is taken as if the precision were omitted. [CX]   In
format wide-character strings containing conversion specifications introduced by "%n$", in addition
to being indicated by the decimal digit string, a field width may be indicated by the sequence "*m$" and
precision by the sequence ".*m$", where m is a decimal integer in the range [1,{NL_ARGMAX}] giving
the position in the argument list (after the format argument) of an integer argument containing the field width or
precision, for example:
wprintf(L"%1$d:%2$.*3$d:%4$.*3$d\n", hour, min, precision, sec);
The flag wide characters and their meanings are:
'
[CX]
(The .) The integer portion of the result of a decimal conversion (%i, %d, %u,
%f, %F, %g, or %G) shall be formatted with thousands' grouping wide characters. For other
conversions, the behavior is undefined. The numeric grouping wide character is used.
-
The result of the conversion shall be left-justified within the field. The conversion shall be right-justified if this flag is
not specified.
+
The result of a signed conversion shall always begin with a sign ('+' or '-'). The conversion shall begin
with a sign only when a negative value is converted if this flag is not specified.
If the first wide character of a signed conversion is not a sign, or if a signed conversion results in no wide characters, a
shall be prefixed to the result. This means that if the  and '+' flags both appear, the
flag shall be ignored.
#
Specifies that the value is to be converted to an alternative form. For o conversion, it shall increase the precision,
if and only if necessary, to force the first digit of the result to be zero (if the value and precision are both 0, a single 0 is
printed). For x or X conversion specifiers, a non-zero result shall have 0x (or 0X) prefixed to it. For
a, A, e, E, f, F, g, and G conversion specifiers, the
result shall always contain a radix character, even if no digits follow it. Without this flag, a radix character appears in the
result of these conversions only if a digit follows it. For g and G conversion specifiers, trailing zeros shall
not be removed from the result as they normally are. For other conversion specifiers, the behavior is undefined.
0
For d, i, o, u, x, X, a, A, e, E,
f, F, g, and G conversion specifiers, leading zeros (following any indication of sign or base)
are used to pad to the field width rather than performing space padding, except when converting an infinity or NaN. If the
'0' and '-' flags both appear, the '0' flag shall be ignored. For d, i, o,
u, x, and X conversion specifiers, if a precision is specified, the '0' flag shall be ignored.
[CX]
If the '0' and  flags both appear, the grouping wide characters are inserted before zero padding.
For other conversions, the behavior is undefined.
The length modifiers and their meanings are:
hh
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a signed char or unsigned char argument (the argument will have been promoted according to the integer
promotions, but its value shall be converted to signed char or unsigned char before printing); or that a following
n conversion specifier applies to a pointer to a signed char argument.
h
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a short or unsigned short argument (the argument will have been promoted according to the integer
promotions, but its value shall be converted to short or unsigned short before printing); or that a following
n conversion specifier applies to a pointer to a short argument.
l (ell)
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a long or unsigned long argument; that a following n conversion specifier applies to a pointer to
a long argument; that a following c conversion specifier applies to a wint_t argument; that a following
s conversion specifier applies to a pointer to a wchar_t argument; or has no effect on a following a,
A, e, E, f, F, g, or G conversion specifier.
ll (ell-ell)
Specifies that a following d, i, o, u, x, or X conversion specifier applies
to a long long or unsigned long long argument; or that a following n conversion specifier applies to a
pointer to a long long argument.
j
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to an intmax_t or uintmax_t argument; or that a following n conversion specifier applies to a
pointer to an intmax_t argument.
z
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a size_t or the corresponding signed integer type argument; or that a following n conversion specifier
applies to a pointer to a signed integer type corresponding to a size_t argument.
t
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a ptrdiff_t or the corresponding unsigned type argument; or that a following n conversion
specifier applies to a pointer to a ptrdiff_t argument.
L
Specifies that a following a, A, e, E, f, F, g, or G
conversion specifier applies to a long double argument.
If a length modifier appears with any conversion specifier other than as specified above, the behavior is undefined.
The conversion specifiers and their meanings are:
d, i
The int argument shall be converted to a signed decimal in the style "[-]dddd". The precision specifies
the minimum number of digits to appear; if the value being converted can be represented in fewer digits, it shall be expanded with
leading zeros. The default precision shall be 1. The result of converting zero with an explicit precision of zero shall be no wide
characters.
o
The unsigned argument shall be converted to unsigned octal format in the style "dddd". The precision specifies
the minimum number of digits to appear; if the value being converted can be represented in fewer digits, it shall be expanded with
leading zeros. The default precision shall be 1. The result of converting zero with an explicit precision of zero shall be no wide
characters.
u
The unsigned argument shall be converted to unsigned decimal format in the style "dddd". The precision
specifies the minimum number of digits to appear; if the value being converted can be represented in fewer digits, it shall be
expanded with leading zeros. The default precision shall be 1. The result of converting zero with an explicit precision of zero
shall be no wide characters.
x
The unsigned argument shall be converted to unsigned hexadecimal format in the style "dddd"; the letters
"abcdef" are used. The precision specifies the minimum number of digits to appear; if the value being converted can be
represented in fewer digits, it shall be expanded with leading zeros. The default precision shall be 1. The result of converting
zero with an explicit precision of zero shall be no wide characters.
X
Equivalent to the x conversion specifier, except that letters "ABCDEF" are used instead of
"abcdef".
f, F
The double argument shall be converted to decimal notation in the style "[-]ddd.ddd", where the number
of digits after the radix character shall be equal to the precision specification. If the precision is missing, it shall be taken
as 6; if the precision is explicitly zero and no '#' flag is present, no radix character shall appear. If a radix
character appears, at least one digit shall appear before it. The value shall be rounded in an implementation-defined manner to the
appropriate number of digits.
A double argument representing an infinity shall be converted in one of the styles "[-]inf" or
"[-]infinity"; which style is implementation-defined. A double argument representing a NaN shall be converted in
one of the styles "[-]nan" or "[-]nan(n-char-sequence)"; which style, and the meaning of any
n-char-sequence, is implementation-defined. The F conversion specifier produces "INF",
"INFINITY", or "NAN" instead of "inf", "infinity", or "nan", respectively.
e, E
The double argument shall be converted in the style "[-]d.ddde±dd", where there shall be one
digit before the radix character (which is non-zero if the argument is non-zero) and the number of digits after it shall be equal
to the precision; if the precision is missing, it shall be taken as 6; if the precision is zero and no '#' flag is
present, no radix character shall appear. The value shall be rounded in an implementation-defined manner to the appropriate number
of digits. The E conversion wide character shall produce a number with 'E' instead of 'e' introducing
the exponent. The exponent shall always contain at least two digits. If the value is zero, the exponent shall be zero.
A double argument representing an infinity or NaN shall be converted in the style of an f or F
conversion specifier.
g, G
The double argument representing a floating-point number shall be converted in the style f or e (or in
the style F or E in the case of a G conversion specifier), depending on the value converted and the
precision. Let P equal the precision if non-zero, 6 if the precision is omitted, or 1 if the precision is zero. Then, if a
conversion with style E would have an exponent of X:
If P>X>=-4, the conversion shall be with style f (or F) and precision
P-(X+1).
Otherwise, the conversion shall be with style e (or E) and precision P-1.
Finally, unless the '#' flag is used, any trailing zeros shall be removed from the fractional portion of the result and
the decimal-point character shall be removed if there is no fractional portion remaining.
A double argument representing an infinity or NaN shall be converted in the style of an f or F
conversion specifier.
a, A
A double argument representing a floating-point number shall be converted in the style
"[-]0xh.hhhhp±d", where there shall be one hexadecimal digit (which is
non-zero if the argument is a normalized floating-point number and is otherwise unspecified) before the decimal-point wide
character and the number of hexadecimal digits after it shall be equal to the precision; if the precision is missing and FLT_RADIX
is a power of 2, then the precision shall be sufficient for an exact representation of the value; if the precision is missing and
FLT_RADIX is not a power of 2, then the precision shall be sufficient to distinguish values of type double, except that
trailing zeros may be omitted; if the precision is zero and the '#' flag is not specified, no decimal-point wide character
shall appear. The letters "abcdef" are used for a conversion and the letters "ABCDEF" for A
conversion. The A conversion specifier produces a number with 'X' and 'P' instead of 'x' and
'p'. The exponent shall always contain at least one digit, and only as many more digits as necessary to represent the
decimal exponent of 2. If the value is zero, the exponent shall be zero.
A double argument representing an infinity or NaN shall be converted in the style of an f or F
conversion specifier.
c
If no l (ell) qualifier is present, the int argument shall be converted to a wide character as if by calling
the btowc() function and the resulting wide character shall be written. Otherwise, the
wint_t argument shall be converted to wchar_t, and written.
s
If no l (ell) qualifier is present, the application shall ensure that the argument is a pointer to a character array
containing a character sequence beginning in the initial shift state. Characters from the array shall be converted as if by
repeated calls to the mbrtowc() function, with the conversion state described by an
mbstate_t object initialized to zero before the first character is converted, and written up to (but not including) the
terminating null wide character. If the precision is specified, no more than that many wide characters shall be written. If the
precision is not specified, or is greater than the size of the array, the application shall ensure that the array contains a null
wide character.
If an l (ell) qualifier is present, the application shall ensure that the argument is a pointer to an array of type
wchar_t. Wide characters from the array shall be written up to (but not including) a terminating null wide character. If no
precision is specified, or is greater than the size of the array, the application shall ensure that the array contains a null wide
character. If a precision is specified, no more than that many wide characters shall be written.
p
The application shall ensure that the argument is a pointer to void. The value of the pointer shall be converted to a
sequence of printable wide characters in an implementation-defined manner.
n
The application shall ensure that the argument is a pointer to an integer into which is written the number of wide characters
written to the output so far by this call to one of the fwprintf() functions. No argument shall be converted, but one shall
be consumed. If the conversion specification includes any flags, a field width, or a precision, the behavior is undefined.
C
[XSI]
Equivalent to lc.
S
[XSI]
Equivalent to ls.
%
Write a '%' wide character; no argument shall be converted. The application shall ensure that the complete conversion
specification is %%.
If a conversion specification does not match one of the above forms, the behavior is undefined.
In no case does a nonexistent or small field width cause truncation of a field; if the result of a conversion is wider than the
field width, the field shall be expanded to contain the conversion result. Characters generated by fwprintf() and
wprintf() shall be printed as if fputwc() had been called.
For a and A conversions, if FLT_RADIX is not a power of 2 and the result is not exactly representable in the
given precision, the result should be one of the two adjacent numbers in hexadecimal floating style with the given precision, with
the extra stipulation that the error should have a correct sign for the current rounding direction.
For e, E, f, F, g, and G conversion specifiers, if the number of
significant decimal digits is at most DECIMAL_DIG, then the result should be correctly rounded. If the number of significant
decimal digits is more than DECIMAL_DIG but the source value is exactly representable with DECIMAL_DIG digits, then the result
should be an exact representation with trailing zeros. Otherwise, the source value is bounded by two adjacent decimal strings
L , ,
CHANGE HISTORY
First released in Issue 5. Included for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E).
Issue 6
The Open Group Corrigendum U040/1 is applied to the RETURN VALUE section, describing the case if n or more wide
characters are requested to be written using swprintf().
The normative text is updated to avoid use of the term "must" for application requirements.
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The prototypes for fwprintf(), swprintf(), and wprintf() are updated.
The DESCRIPTION is updated.
The hh, ll, j, t, and z length modifiers are added.
The a, A, and F conversion characters are added.
XSI shading is removed from the description of character string representations of infinity and NaN floating-point values.
The DESCRIPTION is updated to use the terms "conversion specifier" and "conversion specification" consistently.
ISO/IEC 9899:1999 standard, Technical Corrigendum 1 is incorporated.
Issue 7
Austin Group Interpretation 1003.1-2001 #161 is applied, updating the DESCRIPTION of the 0 flag.
Austin Group Interpretation 1003.1-2001 #170 is applied.
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #68 (SD5-XSH-ERN-70) is applied, revising the description of g
and G.
Functionality relating to the "%n$" form of conversion specification and the  flag is moved from the
XSI option to the Base.
The [EOVERFLOW] error is added for swprintf().
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0226 [302] and XSH/TC1-2008/0227 [14] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0144 [73], XSH/TC2-2008/0145 [894], XSH/TC2-2008/0146 [557], and
XSH/TC2-2008/0147 [936] are applied.
Issue 8
Austin Group Defect 1021 is applied, changing "output error" to "error" in the RETURN VALUE section and changing the
requirements for [EOVERFLOW].
Austin Group Defect 1137 is applied, clarifying the use of "%n$" and "*m$" in
conversion specifications.
Austin Group Defect 1205 is applied, changing the description of the % conversion specifier.
Austin Group Defect 1219 is applied, changing the swprintf()-specific [EOVERFLOW] error.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/posix_spawnattr_destroy.html =====
posix_spawnattr_destroy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
posix_spawnattr_destroy, posix_spawnattr_init — destroy and initialize spawn attributes object (ADVANCED
REALTIME)
SYNOPSIS
[SPN]  #include
int posix_spawnattr_destroy(posix_spawnattr_t *attr);
int posix_spawnattr_init(posix_spawnattr_t *attr);
DESCRIPTION
The posix_spawnattr_destroy() function shall destroy a spawn attributes object. A destroyed attr attributes object
can be reinitialized using posix_spawnattr_init(); the results of otherwise referencing the object after it has been
destroyed are undefined. An implementation may cause posix_spawnattr_destroy() to set the object referenced by attr
to an invalid value.
The posix_spawnattr_init() function shall initialize a spawn attributes object attr with the default value for all
of the individual attributes used by the implementation. Results are undefined if posix_spawnattr_init() is called
specifying an already initialized attr attributes object.
A spawn attributes object is of type posix_spawnattr_t (defined in ) and is used to specify the inheritance of process attributes across a spawn
operation. POSIX.1-2024 does not define comparison or assignment operators for the type posix_spawnattr_t.
Each implementation shall document the individual attributes it uses and their default values unless these values are defined by
POSIX.1-2024. Attributes not defined by POSIX.1-2024, their default values, and the names of the associated functions to get and
set those attribute values are implementation-defined.
The resulting spawn attributes object (possibly modified by setting individual attribute values), is used to modify the behavior
of posix_spawn() or posix_spawnp(). After a spawn attributes object has been used to spawn a process by a
call to a posix_spawn() or posix_spawnp(), any function affecting the attributes object (including destruction)
shall not affect any process that has been spawned in this way.
RETURN VALUE
Upon successful completion, posix_spawnattr_destroy() and posix_spawnattr_init() shall return zero; otherwise, an
error number shall be returned to indicate the error.
ERRORS
The posix_spawnattr_init() function shall fail if:
[ENOMEM]
Insufficient memory exists to initialize the spawn attributes object.
The posix_spawnattr_destroy() function may fail if:
[EINVAL]
The value specified by attr is invalid.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
These functions are part of the Spawn option and need not be provided on all implementations.
RATIONALE
The original spawn interface proposed in POSIX.1-2024 defined the attributes that specify the inheritance of process attributes
across a spawn operation as a structure. In order to be able to separate optional individual attributes under their appropriate
options (that is, the spawn-schedparam and spawn-schedpolicy attributes depending upon the Process Scheduling
option), and also for extensibility and consistency with the newer POSIX interfaces, the attributes interface has been changed to
an opaque data type. This interface now consists of the type posix_spawnattr_t, representing a spawn attributes object,
together with associated functions to initialize or destroy the attributes object, and to set or get each individual attribute.
Although the new object-oriented interface is more verbose than the original structure, it is simple to use, more extensible, and
easy to implement.
FUTURE DIRECTIONS
None.
SEE ALSO
posix_spawn(), posix_spawnattr_getsigdefault(), posix_spawnattr_getflags(), posix_spawnattr_getpgroup(), posix_spawnattr_getschedparam(), posix_spawnattr_getschedpolicy(), posix_spawnattr_getsigmask()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1d-1999.
IEEE PASC Interpretation 1003.1 #106 is applied, noting that the effect of initializing an already initialized spawn attributes
option is undefined.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/assert.html =====
assert
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
assert — insert program diagnostics
SYNOPSIS
#include
void assert(scalar expression);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The assert() macro shall insert diagnostics into programs; it shall expand to a void expression. When it is
executed, if expression (which shall have a scalar type) is false (that is, compares equal to 0), assert()
shall write information about the particular call that failed on stderr and shall call abort().
The information written about the call that failed shall include the text of the argument, the name of the source file, the
source file line number, and the name of the enclosing function; the latter are, respectively, the values of the preprocessing
macros __FILE__ and __LINE__ and of the identifier __func__.
Forcing a definition of the name NDEBUG, either from the compiler command line or with the preprocessor control statement
#define NDEBUG ahead of the #include  statement, shall
stop assertions from being compiled into the program.
RETURN VALUE
The assert() macro shall not return a value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
abort(), stdin
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The prototype for the expression argument to assert() is changed from int to scalar for alignment
with the ISO/IEC 9899:1999 standard.
The DESCRIPTION of assert() is updated for alignment with the ISO/IEC 9899:1999 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fputc.html =====
fputc
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fputc — put a byte on a stream
SYNOPSIS
#include
int fputc(int c, FILE *stream);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The fputc() function shall write the byte specified by c (converted to an unsigned char) to the output
stream pointed to by stream, at the position indicated by the associated file-position indicator for the stream (if
defined), and shall advance the indicator appropriately. If the file cannot support positioning requests, or if the stream was
opened with append mode, the byte shall be appended to the output stream.
[CX]  The
last data modification and last file status change timestamps of the file shall be marked for update between the successful
execution of fputc() and the next successful completion of a call to fflush()
or fclose() on the same stream or a call to exit() or abort().
RETURN VALUE
Upon successful completion, fputc() shall return the value it has written. Otherwise, it shall return EOF, the error
indicator for the stream shall be set, [CX]   and errno shall be set to indicate the error.
ERRORS
The fputc() function shall fail if either the stream is unbuffered or the stream's buffer needs to be
flushed, and:
[EAGAIN]
[CX]
The O_NONBLOCK flag is set for the file descriptor underlying stream and the thread would be delayed in the write operation.
[EBADF]
[CX]
The file descriptor underlying stream is not a valid file descriptor open for writing.
[EFBIG]
[CX]  An
attempt was made to write to a file that exceeds the maximum file size.
[EFBIG]
[CX]  An
attempt was made to write to a file that exceeds the file size limit of the process.
[XSI]
A SIGXFSZ signal shall also be generated for the thread.
[EFBIG]
[CX]
The file is a regular file and an attempt was made to write at or beyond the offset maximum.
[EINTR]
[CX]
The write operation was terminated due to the receipt of a signal, and no data was transferred.
[EIO]
[CX]  A
physical I/O error has occurred, or the process is a member of a background process group attempting to write to its controlling
terminal, TOSTOP is set, the calling thread is not blocking SIGTTOU, the process is not ignoring SIGTTOU, and the process group of
the process is orphaned. This error may also be returned under implementation-defined conditions.
[ENOSPC]
[CX]
There was no free space remaining on the device containing the file.
[EPIPE]
[CX]  An
attempt is made to write to a pipe or FIFO that is not open for reading by any process. A SIGPIPE signal shall also be sent to the
thread.
The fputc() function may fail if:
[ENOMEM]
[CX]
Insufficient storage space is available.
[ENXIO]
[CX]  A
request was made of a nonexistent device, or the request was outside the capabilities of the device.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, ferror(), fopen(), getrlimit(), putc(), puts(), setbuf()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
Large File Summit extensions are added.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The [EIO] and [EFBIG] mandatory error conditions are added.
The [ENOMEM] and [ENXIO] optional error conditions are added.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/37 is applied, updating the [EAGAIN] error in the ERRORS section
from "the process would be delayed" to "the thread would be delayed".
Issue 7
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0168 [79] and XSH/TC1-2008/0169 [14] are applied.
Issue 8
Austin Group Defect 308 is applied, clarifying the handling of [EFBIG] errors.
Austin Group Defect 1669 is applied, removing XSI shading from part of the [EFBIG] error relating to the file size limit for the
process.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/freeaddrinfo.html =====
freeaddrinfo
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
freeaddrinfo, getaddrinfo — get address information
SYNOPSIS
#include
#include
void freeaddrinfo(struct addrinfo *ai);
int getaddrinfo(const char *restrict nodename,
const char *restrict servname,
const struct addrinfo *restrict hints,
struct addrinfo **restrict res);
DESCRIPTION
The freeaddrinfo() function shall free one or more addrinfo structures returned by getaddrinfo(), along
with any additional storage associated with those structures. If the ai_next field of the structure is not null, the entire
list of structures shall be freed. The freeaddrinfo() function shall support the freeing of arbitrary sublists of an
addrinfo list originally returned by getaddrinfo(). The freeaddrinfo() function shall not modify errno
if ai is a sublist previously returned by getaddrinfo() and not yet freed.
The getaddrinfo() function shall translate the name of a service location (for example, a host name) and/or a service
name and shall return a set of socket addresses and associated information to be used in creating a socket with which to address
the specified service.
Note:
In many cases it is implemented by the Domain Name System, as documented in RFC 1034, RFC 1035, and
RFC 3596.
The freeaddrinfo() and getaddrinfo() functions shall be thread-safe.
The nodename and servname arguments are either null pointers or pointers to null-terminated strings. One or both
of these two arguments shall be supplied by the application as a non-null pointer.
The format of a valid name depends on the address family or families. If a specific family is not given and the name could be
interpreted as valid within multiple supported families, the implementation shall attempt to resolve the name in all supported
families and, in absence of errors, one or more results shall be returned.
If the nodename argument is not null, it can be a descriptive name or can be an address string. If the specified address
family is AF_INET, [IP6]   AF_INET6,  or AF_UNSPEC, valid
descriptive names include host names. If the specified address family is AF_INET or AF_UNSPEC, address strings using Internet
standard dot notation as specified in inet_ntop() are valid.
[IP6]
If the specified address family is AF_INET6 or AF_UNSPEC, standard IPv6 text forms described in inet_ntop() are valid.
If nodename is not null, the requested service location is named by nodename; otherwise, the requested service
location is local to the caller.
If servname is null, the call shall return network-level addresses for the specified nodename. If servname
is not null, it is a null-terminated character string identifying the requested service. This can be either a descriptive name or a
numeric representation suitable for use with the address family or families. If the specified address family is AF_INET,
[IP6]
AF_INET6,  or AF_UNSPEC, the service can be specified as a
string specifying a decimal port number.
If the hints argument is not null, it refers to a structure containing input values that directs the operation by
providing options and by limiting the returned information to a specific socket type, address family, and/or protocol, as described
below. The application shall ensure that each of the ai_addrlen, ai_addr, ai_canonname, and ai_next
members, as well as each of the non-standard additional members, if any, of this hints structure is initialized. If any of
these members has a value other than the value that would result from default initialization, the behavior is
implementation-defined. A value of AF_UNSPEC for ai_family means that the caller shall accept any address family. A value of
zero for ai_socktype means that the caller shall accept any socket type. A value of zero for ai_protocol means that
the caller shall accept any protocol. If hints is a null pointer, the behavior shall be as if it referred to a structure
containing the value zero for the ai_flags, ai_socktype, and ai_protocol fields, and AF_UNSPEC for the
ai_family field.
The ai_flags field to which the hints parameter points shall be set to zero or be the bitwise-inclusive OR of one
or more of the values AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST, AI_NUMERICSERV, AI_V4MAPPED, AI_ALL, and AI_ADDRCONFIG.
If the AI_PASSIVE flag is specified, the returned address information shall be suitable for use in binding a socket for
accepting incoming connections for the specified service. In this case, if the nodename argument is null, then the IP
address portion of the socket address structure shall be set to INADDR_ANY for an IPv4 address or IN6ADDR_ANY_INIT for an IPv6
address. If the AI_PASSIVE flag is not specified, the returned address information shall be suitable for a call to connect() (for a connection-mode protocol) or for a call to connect(), sendto(), or sendmsg() (for a connectionless protocol). In this case, if the nodename argument is
null, then the IP address portion of the socket address structure shall be set to the loopback address. The AI_PASSIVE flag shall
be ignored if the nodename argument is not null.
If the AI_CANONNAME flag is specified and the nodename argument is not null, the function shall attempt to determine the
canonical name corresponding to nodename (for example, if nodename is an alias or shorthand notation for a complete
name).
Note:
Since different implementations use different conceptual models, the terms "canonical name" and "alias" cannot be precisely
defined for the general case. However, Domain Name System implementations are expected to interpret them as they are used in
RFC 1034.
A numeric host address string is not a "name", and thus does not have a "canonical name" form; no address to host name
translation is performed. See below for handling of the case where a canonical name cannot be obtained.
If the AI_NUMERICHOST flag is specified, then a non-null nodename string supplied shall be a numeric host address string.
Otherwise, an [EAI_NONAME] error is returned. This flag shall prevent any type of name resolution service (for example, the DNS)
from being invoked.
If the AI_NUMERICSERV flag is specified, then a non-null servname string supplied shall be a numeric port string.
Otherwise, an [EAI_NONAME] error shall be returned. This flag shall prevent any type of name resolution service (for example, NIS+)
from being invoked.
[IP6]
By default, with an ai_family of AF_INET6, getaddrinfo() shall return only IPv6 addresses. If the AI_V4MAPPED flag is
specified along with an ai_family of AF_INET6, then getaddrinfo() shall return IPv4-mapped IPv6 addresses on finding
no matching IPv6 addresses. The AI_V4MAPPED flag shall be ignored unless ai_family equals AF_INET6. If the AI_ALL flag is
used with the AI_V4MAPPED flag, then getaddrinfo() shall return all matching IPv6 and IPv4 addresses. The AI_ALL flag
without the AI_V4MAPPED flag shall be ignored.
If the AI_ADDRCONFIG flag is specified, IPv4 addresses shall be returned only if an IPv4 address is configured on the local
system, [IP6]   and IPv6 addresses shall be returned only if an IPv6 address is configured on the local system.
The ai_socktype field to which argument hints points specifies the socket type for the service, as defined in
2.10.6 Socket Types. If a specific socket type is not given (for
example, a value of zero) and the service name could be interpreted as valid with multiple supported socket types, the
implementation shall attempt to resolve the service name for all supported socket types and, in the absence of errors, all possible
results shall be returned. A non-zero socket type value shall limit the returned information to values with the specified socket
type.
If the ai_family field to which hints points has the value AF_UNSPEC, addresses shall be returned for use with any
address family that can be used with the specified nodename and/or servname. Otherwise, addresses shall be returned
for use only with the specified address family. If ai_family is not AF_UNSPEC and ai_protocol is not zero, then
addresses shall be returned for use only with the specified address family and protocol; the value of ai_protocol shall be
interpreted as in a call to the socket() function with the corresponding values of
ai_family and ai_protocol.
RETURN VALUE
A zero return value for getaddrinfo() indicates successful completion; a non-zero return value indicates failure. The
possible values for the failures are listed in the ERRORS section.
Upon successful return of getaddrinfo(), the location to which res points shall refer to a linked list of
addrinfo structures, each of which shall specify a socket address and information for use in creating a socket with which to
use that socket address. The list shall include at least one addrinfo structure. The ai_next field of each structure
contains a pointer to the next structure on the list, or a null pointer if it is the last structure on the list. Each structure on
the list shall include values for use with a call to the socket() function, and a
socket address for use with the connect() function or, if the AI_PASSIVE flag was
specified, for use with the bind() function. The fields ai_family,
ai_socktype, and ai_protocol shall be usable as the arguments to the socket() function to create a socket suitable for use with the returned address. The fields
ai_addr and ai_addrlen are usable as the arguments to the connect() or
bind() functions with such a socket, according to the AI_PASSIVE flag.
If nodename is not null, and if requested by the AI_CANONNAME flag, the ai_canonname field of the first returned
addrinfo structure shall point to a null-terminated string containing the canonical name corresponding to the input
nodename; if the canonical name is not available, then ai_canonname shall refer to the nodename argument or a
string with the same contents. The contents of the ai_flags field of the returned structures are undefined.
All fields in socket address structures returned by getaddrinfo() that are not filled in through an explicit argument
(for example, sin6_flowinfo) shall be set to zero.
Note:
This makes it easier to compare socket address structures.
ERRORS
The getaddrinfo() function shall fail and return the corresponding error value if:
[EAI_AGAIN]
The name could not be resolved at this time. Future attempts may succeed.
[EAI_BADFLAGS]
The flags parameter had an invalid value.
[EAI_FAIL]
A non-recoverable error occurred when attempting to resolve the name.
[EAI_FAMILY]
The address family was not recognized.
[EAI_MEMORY]
There was a memory allocation failure when trying to allocate storage for the return value.
[EAI_NONAME]
The name does not resolve for the supplied parameters.
Neither nodename nor servname were supplied. At least one of these shall be supplied.
[EAI_SERVICE]
The service passed was not recognized for the specified socket type.
[EAI_SOCKTYPE]
The intended socket type was not recognized.
[EAI_SYSTEM]
A system error occurred; the error code can be found in errno.
The following sections are informative.
EXAMPLES
The following (incomplete) program demonstrates the use of getaddrinfo() to obtain the socket address structure(s) for
the service named in the program's command-line argument. The program then loops through each of the address structures attempting
to create and bind a socket to the address, until it performs a successful bind().
#include
#include
#include
#include
#include
#include
int
main(int argc, char *argv[])
{
struct addrinfo *result, *rp;
int sfd, s;
if (argc != 2) {
fprintf(stderr, "Usage: %s port\n", argv[0]);
exit(EXIT_FAILURE);
}
struct addrinfo hints = {0};
hints.ai_family = AF_UNSPEC;
hints.ai_socktype = SOCK_DGRAM;
hints.ai_flags = AI_PASSIVE;
hints.ai_protocol = 0;
s = getaddrinfo(NULL, argv[1], &hints, &result);
if (s != 0) {
fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(s));
exit(EXIT_FAILURE);
}
/* getaddrinfo() returns a list of address structures.
Try each address until a successful bind().
If socket(2) (or bind(2)) fails, close the socket
and try the next address. */
for (rp = result; rp != NULL; rp = rp->ai_next) {
sfd = socket(rp->ai_family, rp->ai_socktype,
rp->ai_protocol);
if (sfd == -1)
continue;
if (bind(sfd, rp->ai_addr, rp->ai_addrlen) == 0)
break;            /* Success */
close(sfd);
}
if (rp == NULL) {         /* No address succeeded */
fprintf(stderr, "Could not bind\n");
exit(EXIT_FAILURE);
}
freeaddrinfo(result);     /* No longer needed */
/* ... use socket bound to sfd ... */
}
APPLICATION USAGE
If the caller handles only TCP and not UDP, for example, then the ai_protocol member of the hints structure should
be set to IPPROTO_TCP when getaddrinfo() is called.
If the caller handles only IPv4 and not IPv6, then the ai_family member of the hints structure should be set to
AF_INET when getaddrinfo() is called.
The hints structure can be initialized using memset(&hints, 0, sizeof hints) or by default initialization
(see the APPLICATION USAGE for XBD ).
The term "canonical name" is misleading; it is taken from the Domain Name System (RFC 2181). It should be noted that the
canonical name is a result of alias processing, and not necessarily a unique attribute of a host, address, or set of addresses. See
RFC 2181 for more discussion of this in the Domain Name System context.
The ai_socktype field pointed to by hints is just the socket type; not the socket type and flags that can be
specified when the socket is created. Passing in socket creation flags will cause a failure with [EAI_SOCKTYPE].
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
connect(), endservent(),
gai_strerror(), getnameinfo(), socket()
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
The restrict keyword is added to the getaddrinfo() prototype for alignment with the ISO/IEC 9899:1999
standard.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/19 is applied, adding three notes to the DESCRIPTION and adding
text to the APPLICATION USAGE related to the term "canonical name". A reference to RFC 2181 is also added to the Informative
References.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/20 is applied, making changes for alignment with IPv6. These
include the following:
Adding AI_V4MAPPED, AI_ALL, and AI_ADDRCONFIG to the allowed values for the ai_flags field
Adding a description of AI_ADDRCONFIG
Adding a description of the consequences of ignoring the AI_PASSIVE flag.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/39 is applied, changing "corresponding value" to
"corresponding error value" in the ERRORS section.
Issue 7
Austin Group Interpretation 1003.1-2001 #013 is applied.
Austin Group Interpretation 1003.1-2001 #146 is applied, updating the DESCRIPTION.
An example is added.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0130 [939], XSH/TC2-2008/0131 [979], XSH/TC2-2008/0132 [918], and
XSH/TC2-2008/0133 [934] are applied.
Issue 8
Austin Group Defect 385 is applied, adding a requirement that freeaddrinfo() does not modify errno when passed a
sublist that can be freed.
Austin Group Defect 411 is applied, changing the "socket type" reference and adding a paragraph about
hints->ai_socktype to the APPLICATION USAGE section.
Austin Group Defect 940 is applied, changing text in the APPLICATION USAGE section relating to initialization of the
hints structure.
Austin Group Defect 1102 is applied, replacing a reference to the inet_addr()
page with one to the inet_ntop() page.
Austin Group Defect 1685 is applied, updating RFC references.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/isxdigit_l.html =====
isxdigit
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
isxdigit, isxdigit_l — test for a hexadecimal digit
SYNOPSIS
#include
int isxdigit(int c);
[CX]  int isxdigit_l(int c, locale_t locale);
DESCRIPTION
For isxdigit(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The isxdigit() [CX]   and isxdigit_l()
functions shall test whether c is a character of class xdigit in the current locale, [CX]   or in the
locale represented by locale,  respectively; see XBD 7. Locale.
The c argument is an int, the value of which the application shall ensure is a character representable as an
unsigned char or equal to the value of the macro EOF. If the argument has any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to isxdigit_l() is the special locale object LC_GLOBAL_LOCALE or is not
a valid locale object handle.
RETURN VALUE
The isxdigit() [CX]   and isxdigit_l()
functions shall return non-zero if c is a hexadecimal digit; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
isalnum(), isalpha(), isblank(), iscntrl(), isdigit(), isgraph(), islower(), isprint(), ispunct(), isspace(), isupper()
XBD 7. Locale,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The isxdigit_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0347 [302], XSH/TC1-2008/0348 [283], and XSH/TC1-2008/0349 [283] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strncmp.html =====
strncmp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strncmp — compare part of two strings
SYNOPSIS
#include
int strncmp(const char *s1, const char *s2, size_t n);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The strncmp() function shall compare not more than n bytes (bytes that follow a NUL character are not compared)
from the array pointed to by s1 to the array pointed to by s2.
The sign of a non-zero return value is determined by the sign of the difference between the values of the first pair of bytes
(both interpreted as type unsigned char) that differ in the strings being compared.
[CX]  The
strncmp() function shall not change the setting of errno on valid input.
RETURN VALUE
Upon successful completion, strncmp() shall return an integer greater than, equal to, or less than 0, if the possibly
null-terminated array pointed to by s1 is greater than, equal to, or less than the possibly null-terminated array pointed to
by s2 respectively.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
strcmp()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
Extensions beyond the ISO C standard are marked.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that strncmp() does not change the setting of errno on
valid input.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/vsnprintf.html =====
vfprintf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
vasprintf, vdprintf, vfprintf, vprintf, vsnprintf, vsprintf — format output of a stdarg argument list
SYNOPSIS
#include
#include
[CX]  int vasprintf(char **restrict ptr, const char *restrict format,
va_list ap);
int vdprintf(int fildes, const char *restrict format, va_list ap);
int vfprintf(FILE *restrict stream, const char *restrict format,
va_list ap);
int vprintf(const char *restrict format, va_list ap);
int vsnprintf(char *restrict s, size_t n, const char *restrict format,
va_list ap);
int vsprintf(char *restrict s, const char *restrict format, va_list
ap);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The [CX]
vasprintf(), vdprintf(),  vfprintf(),
vprintf(), vsnprintf(), and vsprintf() functions shall be equivalent to the [CX]  asprintf(), dprintf(),  fprintf(), printf(), snprintf(), and sprintf() functions respectively, except that instead of being called with a variable number
of arguments, they are called with an argument list as defined by .
These functions shall not invoke the va_end macro. As these functions invoke the va_arg macro, the value of
ap after the return is unspecified.
RETURN VALUE
Refer to fprintf().
ERRORS
Refer to fprintf().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications using these functions should call va_end(ap) afterwards to clean up.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fprintf()
XBD ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The vsnprintf() function is added.
Issue 6
The vfprintf(), vprintf(), vsnprintf(), and vsprintf() functions are updated for alignment with the
ISO/IEC 9899:1999 standard.
Issue 7
The vdprintf() function is added to complement the dprintf() function from
The Open Group Technical Standard, 2006, Extended API Set Part 1.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0703 [14] is applied.
Issue 8
Austin Group Defect 1496 is applied, adding the vasprintf() function.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/asprintf.html =====
fprintf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
asprintf, dprintf, fprintf, printf, snprintf, sprintf — print formatted output
SYNOPSIS
#include
[CX]  int asprintf(char **restrict ptr, const char *restrict format,
...);
int dprintf(int fildes, const char *restrict format, ...);
int fprintf(FILE *restrict stream, const char *restrict format, ...);
int printf(const char *restrict format, ...);
int snprintf(char *restrict s, size_t n,
const char *restrict format, ...);
int sprintf(char *restrict s, const char *restrict format, ...);
DESCRIPTION
[CX]  Except for asprintf(), dprintf(), and the behavior of the %lc conversion when passed a null wide
character, the functionality described on this reference page is aligned with the ISO C standard. Any other conflict between
the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard for all fprintf(), printf(), snprintf(), and sprintf() functionality except in relation to the
%lc conversion when passed a null wide character.
The fprintf() function shall place output on the named output stream. The printf() function shall place
output on the standard output stream stdout. The sprintf() function shall place output followed by the null byte,
'\0', in consecutive bytes starting at *s; it is the user's responsibility to ensure that enough space is
available.
[CX]  The
asprintf() function shall be equivalent to sprintf(), except that the output string shall be written to dynamically
allocated memory, allocated as if by a call to malloc(), of sufficient length to hold
the resulting string, including a terminating null byte. If the call to asprintf() is successful, the address of this
dynamically allocated string shall be stored in the location referenced by ptr.
The dprintf() function shall be equivalent to the fprintf() function, except that dprintf() shall write
output to the file associated with the file descriptor specified by the fildes argument rather than place output on a
stream.
The snprintf() function shall be equivalent to sprintf(), with the addition of the n argument which limits
the number of bytes written to the buffer referred to by s. If n is zero, nothing shall be written and s may
be a null pointer. Otherwise, output bytes beyond the n-1st shall be discarded instead of being written to the array, and a
null byte is written at the end of the bytes actually written into the array.
If copying takes place between objects that overlap as a result of a call to sprintf() or snprintf(), the results
are undefined.
Each of these functions converts, formats, and prints its arguments under control of the format. The application shall
ensure that the format is a character string, beginning and ending in its initial shift state, if any. The format is composed of
zero or more directives: ordinary characters, which are simply copied to the output stream, and conversion
specifications, each of which shall result in the fetching of zero or more arguments. The results are undefined if there are
insufficient arguments for the format. If the format is exhausted while arguments remain, the excess arguments shall be evaluated
but are otherwise ignored.
[CX]
Conversions can be applied to the nth argument after the format in the argument list, rather than to the next unused
argument. In this case, the conversion specifier character % (see below) is replaced by the sequence
"%n$", where n is a decimal integer in the range [1,{NL_ARGMAX}], giving the position of the
argument in the argument list. This feature provides for the definition of format strings that select arguments in an order
appropriate to specific languages (see the EXAMPLES section).
The format can contain either numbered argument conversion specifications (that is, those introduced by
"%n$" and optionally containing the "*m$" forms of field width and precision), or
unnumbered argument conversion specifications (that is, those introduced by the % character and optionally containing the
* form of field width and precision), but not both. The only exception to this is that %% can be mixed with the
"%n$" form. The results of mixing numbered and unnumbered argument specifications in a format string are
undefined. When numbered argument specifications are used, specifying the Nth argument requires that all the leading
arguments, from the first to the (N-1)th, are specified in the format string.
In format strings containing the "%n$" form of conversion specification, numbered arguments in the
argument list can be referenced from the format string as many times as required.
In format strings containing the % form of conversion specification, each conversion specification uses the first
unused argument in the argument list.
[CX]  All
forms of the fprintf() functions allow for the insertion of a language-dependent radix character in the output string. The
radix character is defined in the current locale (category LC_NUMERIC ). In the POSIX locale, or in a locale where the radix
character is not defined, the radix character shall default to a  ('.').
Each conversion specification is introduced by the '%' character [CX]   or by the
character sequence "%n$",   after
which the following appear in sequence:
Zero or more flags (in any order), which modify the meaning of the conversion specification.
An optional minimum field width. If the converted value has fewer bytes than the field width, it shall be padded with
characters by default on the left; it shall be padded on the right if the left-adjustment flag ('-'),
described below, is given to the field width. The field width takes the form of an  ('*'), [CX]   or in
conversion specifications introduced by "%n$" the "*m$" string,  described below, or a decimal integer.
An optional precision that gives the minimum number of digits to appear for the d, i, o,
u, x, and X conversion specifiers; the number of digits to appear after the radix character for the
a, A, e, E, f, and F conversion specifiers; the maximum number of significant
digits for the g and G conversion specifiers; or the maximum number of bytes to be printed from a string in the
s [XSI]   and S   conversion specifiers. The
precision takes the form of a  ('.') followed either by an  ('*'), [CX]   or in
conversion specifications introduced by "%n$" the "*m$" string,  described below, or an optional decimal digit string, where a null digit
string is treated as zero. If a precision appears with any other conversion specifier, the behavior is undefined.
An optional length modifier that specifies the size of the argument.
A conversion specifier character that indicates the type of conversion to be applied.
A field width, or precision, or both, may be indicated by an  ('*'). In this case an argument of type
int supplies the field width or precision. Applications shall ensure that arguments specifying field width, or precision, or
both appear in that order before the argument, if any, to be converted. A negative field width is taken as a '-' flag
followed by a positive field width. A negative precision is taken as if the precision were omitted. [CX]   In format
strings containing conversion specifications introduced by "%n$", in addition to being indicated by the
decimal digit string, a field width may be indicated by the sequence "*m$" and precision by the sequence
".*m$", where m is a decimal integer in the range [1,{NL_ARGMAX}] giving the position in the
argument list (after the format argument) of an integer argument containing the field width or precision, for example:
printf("%1$d:%2$.*3$d:%4$.*3$d\n", hour, min, precision, sec);
The flag characters and their meanings are:
'
[CX]
(The .) The integer portion of the result of a decimal conversion (%i, %d, %u,
%f, %F, %g, or %G) shall be formatted with thousands' grouping characters. For other
conversions the behavior is undefined. The non-monetary grouping character is used.
-
The result of the conversion shall be left-justified within the field. The conversion is right-justified if this flag is not
specified.
+
The result of a signed conversion shall always begin with a sign ('+' or '-'). The conversion shall begin
with a sign only when a negative value is converted if this flag is not specified.
If the first character of a signed conversion is not a sign or if a signed conversion results in no characters, a
shall be prefixed to the result. This means that if the  and '+' flags both appear, the  flag
shall be ignored.
#
Specifies that the value is to be converted to an alternative form. For o conversion, it shall increase the precision,
if and only if necessary, to force the first digit of the result to be a zero (if the value and precision are both 0, a single 0 is
printed). For x or X conversion specifiers, a non-zero result shall have 0x (or 0X) prefixed to it. For
a, A, e, E, f, F, g, and G conversion specifiers, the
result shall always contain a radix character, even if no digits follow the radix character. Without this flag, a radix character
appears in the result of these conversions only if a digit follows it. For g and G conversion specifiers,
trailing zeros shall not be removed from the result as they normally are. For other conversion specifiers, the behavior is
undefined.
0
For d, i, o, u, x, X, a, A, e, E,
f, F, g, and G conversion specifiers, leading zeros (following any indication of sign or base)
are used to pad to the field width rather than performing space padding, except when converting an infinity or NaN. If the
'0' and '-' flags both appear, the '0' flag is ignored. For d, i, o,
u, x, and X conversion specifiers, if a precision is specified, the '0' flag shall be ignored.
[CX]
If the '0' and  flags both appear, the grouping characters are inserted before zero padding. For
other conversions, the behavior is undefined.
The length modifiers and their meanings are:
hh
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a signed char or unsigned char argument (the argument will have been promoted according to the integer
promotions, but its value shall be converted to signed char or unsigned char before printing); or that a following
n conversion specifier applies to a pointer to a signed char argument.
h
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a short or unsigned short argument (the argument will have been promoted according to the integer
promotions, but its value shall be converted to short or unsigned short before printing); or that a following
n conversion specifier applies to a pointer to a short argument.
l (ell)
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a long or unsigned long argument; that a following n conversion specifier applies to a pointer to
a long argument; that a following c conversion specifier applies to a wint_t argument; that a following
s conversion specifier applies to a pointer to a wchar_t argument; or has no effect on a following a,
A, e, E, f, F, g, or G conversion specifier.
ll (ell-ell)
Specifies that a following d, i, o, u, x, or X conversion specifier applies
to a long long or unsigned long long argument; or that a following n conversion specifier applies to a
pointer to a long long argument.
j
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to an intmax_t or uintmax_t argument; or that a following n conversion specifier applies to a
pointer to an intmax_t argument.
z
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a size_t or the corresponding signed integer type argument; or that a following n conversion specifier
applies to a pointer to a signed integer type corresponding to a size_t argument.
t
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a ptrdiff_t or the corresponding unsigned type argument; or that a following n conversion
specifier applies to a pointer to a ptrdiff_t argument.
L
Specifies that a following a, A, e, E, f, F, g, or G
conversion specifier applies to a long double argument.
If a length modifier appears with any conversion specifier other than as specified above, the behavior is undefined.
The conversion specifiers and their meanings are:
d, i
The int argument shall be converted to a signed decimal in the style "[-]dddd". The precision
specifies the minimum number of digits to appear; if the value being converted can be represented in fewer digits, it shall be
expanded with leading zeros. The default precision is 1. The result of converting zero with an explicit precision of zero shall be
no characters.
o
The unsigned argument shall be converted to unsigned octal format in the style "dddd". The
precision specifies the minimum number of digits to appear; if the value being converted can be represented in fewer digits, it
shall be expanded with leading zeros. The default precision is 1. The result of converting zero with an explicit precision of zero
shall be no characters.
u
The unsigned argument shall be converted to unsigned decimal format in the style "dddd". The
precision specifies the minimum number of digits to appear; if the value being converted can be represented in fewer digits, it
shall be expanded with leading zeros. The default precision is 1. The result of converting zero with an explicit precision of zero
shall be no characters.
x
The unsigned argument shall be converted to unsigned hexadecimal format in the style "dddd";
the letters "abcdef" are used. The precision specifies the minimum number of digits to appear; if the value being
converted can be represented in fewer digits, it shall be expanded with leading zeros. The default precision is 1. The result of
converting zero with an explicit precision of zero shall be no characters.
X
Equivalent to the x conversion specifier, except that letters "ABCDEF" are used instead of
"abcdef".
f, F
The double argument shall be converted to decimal notation in the style
"[-]ddd.ddd", where the number of digits after the radix character is equal to the
precision specification. If the precision is missing, it shall be taken as 6; if the precision is explicitly zero and no
'#' flag is present, no radix character shall appear. If a radix character appears, at least one digit appears before it.
The low-order digit shall be rounded in an implementation-defined manner.
A double argument representing an infinity shall be converted in one of the styles "[-]inf" or
"[-]infinity"; which style is implementation-defined. A double argument representing a NaN shall be converted in
one of the styles "[-]nan(n-char-sequence)" or "[-]nan"; which style, and the meaning of any
n-char-sequence, is implementation-defined. The F conversion specifier produces "INF",
"INFINITY", or "NAN" instead of "inf", "infinity", or "nan", respectively.
e, E
The double argument shall be converted in the style
"[-]d.ddde±dd", where there is one digit before the radix character (which
is non-zero if the argument is non-zero) and the number of digits after it is equal to the precision; if the precision is missing,
it shall be taken as 6; if the precision is zero and no '#' flag is present, no radix character shall appear. The
low-order digit shall be rounded in an implementation-defined manner. The E conversion specifier shall produce a number
with 'E' instead of 'e' introducing the exponent. The exponent shall always contain at least two digits. If the
value is zero, the exponent shall be zero.
A double argument representing an infinity or NaN shall be converted in the style of an f or F
conversion specifier.
g, G
The double argument representing a floating-point number shall be converted in the style f or e (or in
the style F or E in the case of a G conversion specifier), depending on the value converted and the
precision. Let P equal the precision if non-zero, 6 if the precision is omitted, or 1 if the precision is zero. Then, if a
conversion with style E would have an exponent of X:
If P>X>=-4, the conversion shall be with style f (or F) and precision
P-(X+1).
Otherwise, the conversion shall be with style e (or E) and precision P-1.
Finally, unless the '#' flag is used, any trailing zeros shall be removed from the fractional portion of the result and
the decimal-point character shall be removed if there is no fractional portion remaining.
A double argument representing an infinity or NaN shall be converted in the style of an f or F
conversion specifier.
a, A
A double argument representing a floating-point number shall be converted in the style
"[-]0xh.hhhhp±d", where there is one hexadecimal digit (which shall be
non-zero if the argument is a normalized floating-point number and is otherwise unspecified) before the decimal-point character and
the number of hexadecimal digits after it is equal to the precision; if the precision is missing and FLT_RADIX is a power of 2,
then the precision shall be sufficient for an exact representation of the value; if the precision is missing and FLT_RADIX is not a
power of 2, then the precision shall be sufficient to distinguish values of type double, except that trailing zeros may be
omitted; if the precision is zero and the '#' flag is not specified, no decimal-point character shall appear. The letters
"abcdef" shall be used for a conversion and the letters "ABCDEF" for A conversion. The
A conversion specifier produces a number with 'X' and 'P' instead of 'x' and 'p'. The
exponent shall always contain at least one digit, and only as many more digits as necessary to represent the decimal exponent of 2.
If the value is zero, the exponent shall be zero.
A double argument representing an infinity or NaN shall be converted in the style of an f or F
conversion specifier.
c
The int argument shall be converted to an unsigned char, and the resulting byte shall be written.
If an l (ell) qualifier is present, [CX]   the wint_t argument shall be converted to a multi-byte
sequence as if by a call to wcrtomb() with a pointer to storage of at least
MB_CUR_MAX bytes, the wint_t argument converted to wchar_t, and an initial shift state, and the resulting byte(s)
written.
s
The argument shall be a pointer to an array of char. Bytes from the array shall be written up to (but not including) any
terminating null byte. If the precision is specified, no more than that many bytes shall be written. If the precision is not
specified or is greater than the size of the array, the application shall ensure that the array contains a null byte.
If an l (ell) qualifier is present, the argument shall be a pointer to an array of type wchar_t. Wide characters
from the array shall be converted to characters (each as if by a call to the wcrtomb() function, with the conversion state described by an mbstate_t object
initialized to zero before the first wide character is converted) up to and including a terminating null wide character. The
resulting characters shall be written up to (but not including) the terminating null character (byte). If no precision is
specified, the application shall ensure that the array contains a null wide character. If a precision is specified, no more than
that many characters (bytes) shall be written (including shift sequences, if any), and the array shall contain a null wide
character if, to equal the character sequence length given by the precision, the function would need to access a wide character one
past the end of the array. In no case shall a partial character be written.
p
The argument shall be a pointer to void. The value of the pointer is converted to a sequence of printable characters, in
an implementation-defined manner.
n
The argument shall be a pointer to an integer into which is written the number of bytes written to the output so far by this
call to one of the fprintf() functions. No argument is converted.
C
[XSI]
Equivalent to lc.
S
[XSI]
Equivalent to ls.
%
Write a '%' character; no argument shall be converted. The application shall ensure that the complete conversion
specification is %%.
If a conversion specification does not match one of the above forms, the behavior is undefined. If any argument is not the
correct type for the corresponding conversion specification, the behavior is undefined.
In no case shall a nonexistent or small field width cause truncation of a field; if the result of a conversion is wider than the
field width, the field shall be expanded to contain the conversion result. Characters generated by fprintf() and
printf() are printed as if fputc() had been called.
For the a and A conversion specifiers, if FLT_RADIX is a power of 2, the value shall be correctly rounded to a
hexadecimal floating number with the given precision.
For a and A conversions, if FLT_RADIX is not a power of 2 and the result is not exactly representable in the
given precision, the result should be one of the two adjacent numbers in hexadecimal floating style with the given precision, with
the extra stipulation that the error should have a correct sign for the current rounding direction.
For the e, E, f, F, g, and G conversion specifiers, if the number of
significant decimal digits is at most DECIMAL_DIG, then the result should be correctly rounded. If the number of significant
decimal digits is more than DECIMAL_DIG but the source value is exactly representable with DECIMAL_DIG digits, then the result
should be an exact representation with trailing zeros. Otherwise, the source value is bounded by two adjacent decimal strings
L
#include
#include
#include
char *strperm (mode_t);
...
struct stat statbuf;
struct passwd *pwd;
struct group *grp;
...
printf("%10.10s", strperm (statbuf.st_mode));
printf("%4d", statbuf.st_nlink);
if ((pwd = getpwuid(statbuf.st_uid)) != NULL)
printf(" %-8.8s", pwd->pw_name);
else
printf(" %-8ld", (long) statbuf.st_uid);
if ((grp = getgrgid(statbuf.st_gid)) != NULL)
printf(" %-8.8s", grp->gr_name);
else
printf(" %-8ld", (long) statbuf.st_gid);
printf("%9jd", (intmax_t) statbuf.st_size);
...
Printing a Localized Date String
The following example gets a localized date string. The nl_langinfo()
function shall return the localized date string, which specifies the order and layout of the date. The strftime() function takes this information and, using the tm structure for values,
places the date and time information into datestring. The printf() function then outputs datestring and the
name of the entry.
#include
#include
#include
...
struct dirent *dp;
struct tm *tm;
char datestring[256];
...
strftime(datestring, sizeof(datestring), nl_langinfo (D_T_FMT), tm);
printf(" %s %s\n", datestring, dp->d_name);
...
Printing Error Information
The following example uses fprintf() to write error information to standard error.
In the first group of calls, the program tries to open the password lock file named LOCKFILE. If the file already exists,
this is an error, as indicated by the O_EXCL flag on the open() function. If the call
fails, the program assumes that someone else is updating the password file, and the program exits.
The next group of calls saves a new password file as the current password file by creating a link between LOCKFILE and
the new password file PASSWDFILE.
#include
#include
#include
#include
#include
#include
#include
#include
#define LOCKFILE "/etc/ptmp"
#define PASSWDFILE "/etc/passwd"
...
int pfd;
...
if ((pfd = open(LOCKFILE, O_WRONLY | O_CREAT | O_EXCL,
S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) == -1)
{
fprintf(stderr, "Cannot open /etc/ptmp. Try again later.\n");
exit(1);
}
...
if (link(LOCKFILE,PASSWDFILE) == -1) {
fprintf(stderr, "Link error: %s\n", strerror(errno));
exit(1);
}
...
Printing Usage Information
The following example checks to make sure the program has the necessary arguments, and uses fprintf() to print usage
information if the expected number of arguments is not present.
#include
#include
...
char *Options = "hdbtl";
...
if (argc  ('*') in the format
string; this ensures the correct number of decimal places for the element based on the number of elements requested.
#include
...
long i;
char *keystr;
int elementlen, len;
...
while (len
#include
#include
#include
#include
#include
...
char *pathname;
struct passwd *pw;
size_t len;
...
// digits required for pid_t is number of bits times
// log2(10) = approx 10/33
len = strlen(pw->pw_dir) + 1 + 1+(sizeof(pid_t)*80+32)/33 +
sizeof ".out";
pathname = malloc(len);
if (pathname != NULL)
{
snprintf(pathname, len, "%s/%jd.out", pw->pw_dir,
(intmax_t)getpid());
...
}
Reporting an Event
The following example loops until an event has timed out. The pause() function
waits forever unless it receives a signal. The fprintf() statement should never occur due to the possible return values of
pause().
#include
#include
#include
#include
...
while (!event_complete) {
...
if (pause() != -1 || errno != EINTR)
fprintf(stderr, "pause: unknown error: %s\n", strerror(errno));
}
...
Printing Monetary Information
The following example uses strfmon() to convert a number and store it as a
formatted monetary string named convbuf. If the first number is printed, the program prints the format and the description;
otherwise, it just prints the number.
#include
#include
...
struct tblfmt {
char *format;
char *description;
};
struct tblfmt table[] = {
{ "%n", "default formatting" },
{ "%11n", "right align within an 11 character field" },
{ "%#5n", "aligned columns for values up to 99999" },
{ "%=*#5n", "specify a fill character" },
{ "%=0#5n", "fill characters do not use grouping" },
{ "%^#5n", "disable the grouping separator" },
{ "%^#5.0n", "round off to whole units" },
{ "%^#5.4n", "increase the precision" },
{ "%(#5n", "use an alternative pos/neg style" },
{ "%!(#5n", "disable the currency symbol" },
};
...
float input[3];
int i, j;
char convbuf[100];
...
strfmon(convbuf, sizeof(convbuf), table[i].format, input[j]);
if (j == 0) {
printf("%s  %s      %s\n", table[i].format,
convbuf, table[i].description);
}
else {
printf("    %s\n", convbuf);
}
...
Printing Wide Characters
The following example prints a series of wide characters. Suppose that "L`@`" expands to three bytes:
wchar_t wz [3] = L"@@";       // Zero-terminated
wchar_t wn [3] = L"@@@";      // Unterminated
fprintf (stdout,"%ls", wz);   // Outputs 6 bytes
fprintf (stdout,"%ls", wn);   // Undefined because wn has no terminator
fprintf (stdout,"%4ls", wz);  // Outputs 3 bytes
fprintf (stdout,"%4ls", wn);  // Outputs 3 bytes; no terminator needed
fprintf (stdout,"%9ls", wz);  // Outputs 6 bytes
fprintf (stdout,"%9ls", wn);  // Outputs 9 bytes; no terminator needed
fprintf (stdout,"%10ls", wz); // Outputs 6 bytes
fprintf (stdout,"%10ls", wn); // Undefined because wn has no terminator
In the last line of the example, after processing three characters, nine bytes have been output. The fourth character must then
be examined to determine whether it converts to one byte or more. If it converts to more than one byte, the output is only nine
bytes. Since there is no fourth character in the array, the behavior is undefined.
APPLICATION USAGE
If the application calling fprintf() has any objects of type wint_t or wchar_t, it must also include the
header to have these objects defined.
The space allocated by a successful call to asprintf() should be subsequently freed by a call to free().
RATIONALE
If an implementation detects that there are insufficient arguments for the format, it is recommended that the function should
fail and report an [EINVAL] error.
The behavior specified for the %lc conversion differs slightly from the specification in the ISO C standard, in
that printing the null wide character produces a null byte instead of 0 bytes of output as would be required by a strict reading of
the ISO C standard's direction to behave as if applying the %ls specifier to a wchar_t array whose first
element is the null wide character. Requiring a multi-byte output for every possible wide character, including the null character,
matches historical practice, and provides consistency with %c in fprintf() and with both %c and
%lc in fwprintf(). It is anticipated that a future edition of the
ISO C standard will change to match the behavior specified here.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fputc(), fscanf(), setlocale(), strfmon(), strlcat(), wcrtomb(), wcslcat()
XBD 7. Locale, , ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
Aligned with ISO/IEC 9899:1990/Amendment 1:1995 (E). Specifically, the l (ell) qualifier can now be used with
c and s conversion specifiers.
The snprintf() function is new in Issue 5.
Issue 6
Extensions beyond the ISO C standard are marked.
The normative text is updated to avoid use of the term "must" for application requirements.
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The prototypes for fprintf(), printf(), snprintf(), and sprintf() are updated, and the XSI shading
is removed from snprintf().
The description of snprintf() is aligned with the ISO C standard. Note that this supersedes the snprintf()
description in The Open Group Base Resolution bwg98-006, which changed the behavior from Issue 5.
The DESCRIPTION is updated.
The DESCRIPTION is updated to use the terms "conversion specifier" and "conversion specification" consistently.
ISO/IEC 9899:1999 standard, Technical Corrigendum 1 is incorporated.
An example of printing wide characters is added.
Issue 7
Austin Group Interpretation 1003.1-2001 #161 is applied, updating the DESCRIPTION of the 0 flag.
Austin Group Interpretation 1003.1-2001 #170 is applied.
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #68 (SD5-XSH-ERN-70) is applied, revising the description of g
and G.
SD5-XSH-ERN-174 is applied.
The dprintf() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 1.
Functionality relating to the %n$ form of conversion specification and the  flag is moved from the
XSI option to the Base.
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0163 [302], XSH/TC1-2008/0164 [316], XSH/TC1-2008/0165 [316],
XSH/TC1-2008/0166 [451,291], and XSH/TC1-2008/0167 [14] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0126 [894], XSH/TC2-2008/0127 [557], and XSH/TC2-2008/0128 [936] are
applied.
Issue 8
Austin Group Defect 986 is applied, adding strlcat() and wcslcat() to the SEE ALSO section.
Austin Group Defect 1020 is applied, clarifying that the snprintf() argument n limits the number of bytes written
to s; it is not necessarily the same as the size of s.
Austin Group Defect 1021 is applied, changing "output error" to "error" in the RETURN VALUE section.
Austin Group Defect 1137 is applied, clarifying the use of "%n$" and "*m$" in
conversion specifications.
Austin Group Defect 1205 is applied, changing the description of the % conversion specifier.
Austin Group Defect 1219 is applied, removing the snprintf()-specific [EOVERFLOW] error.
Austin Group Defect 1496 is applied, adding the asprintf() function.
Austin Group Defect 1562 is applied, clarifying that it is the application's responsibility to ensure that the format is a
character string, beginning and ending in its initial shift state, if any.
Austin Group Defect 1647 is applied, changing the description of the c conversion specifier and updating the statement
that this volume of POSIX.1-2024 defers to the ISO C standard so that it excludes the %lc conversion when passed a
null wide character.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/isinf.html =====
isinf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
isinf — test for infinity
SYNOPSIS
#include
int isinf(real-floating x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The isinf() macro shall determine whether its argument value is an infinity (positive or negative). First, an argument
represented in a format wider than its semantic type is converted to its semantic type. Then determination is based on the type of
the argument.
RETURN VALUE
The isinf() macro shall return a non-zero value if and only if its argument has an infinite value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
fpclassify(), isfinite(),
isnan(), isnormal(), signbit()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sched_setscheduler.html =====
sched_setscheduler
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sched_setscheduler — set scheduling policy and parameters (REALTIME)
SYNOPSIS
[PS]  #include
int sched_setscheduler(pid_t pid, int policy,
const struct sched_param *param);
DESCRIPTION
The sched_setscheduler() function shall set the scheduling policy and scheduling parameters of the process specified by
pid to policy and the parameters specified in the sched_param structure pointed to by param,
respectively. The value of the sched_priority member in the sched_param structure shall be any integer within the
inclusive priority range for the scheduling policy specified by policy. If the value of pid is negative, the behavior
of the sched_setscheduler() function is unspecified.
The possible values for the policy parameter are defined in the  header.
If a process specified by pid exists, and if the calling process has permission, the scheduling policy and scheduling
parameters shall be set for the process whose process ID is equal to pid.
If pid is zero, the scheduling policy and scheduling parameters shall be set for the calling process.
The conditions under which one process has appropriate privileges to change the scheduling parameters of another process are
implementation-defined.
Implementations may require that the requesting process have permission to set its own scheduling parameters or those of another
process. Additionally, implementation-defined restrictions may apply as to the appropriate privileges required to set the
scheduling policy of the process, or the scheduling policy of another process, to a particular value.
The sched_setscheduler() function shall be considered successful if it succeeds in setting the scheduling policy and
scheduling parameters of the process specified by pid to the values specified by policy and the structure pointed to
by param, respectively.
See Scheduling Policies for a description on how this function
affects the scheduling of the threads within the target process.
If the current scheduling policy for the target process is not SCHED_FIFO, SCHED_RR, [SS]  or SCHED_SPORADIC,
the result is implementation-defined; this case includes the
SCHED_OTHER policy.
[SS]  The
specified sched_ss_repl_period shall be greater than or equal to the specified sched_ss_init_budget for the function
to succeed; if it is not, then the function shall fail.
The value of sched_ss_max_repl shall be within the inclusive range [1,{SS_REPL_MAX}] for the function to succeed; if not,
the function shall fail. It is unspecified whether the sched_ss_repl_period and sched_ss_init_budget values are
stored as provided by this function or are rounded to align with the resolution of the clock being used.
This function is not atomic with respect to other threads in the process. Threads may continue to execute while this function
call is in the process of changing the scheduling policy and associated scheduling parameters for the underlying kernel-scheduled
entities used by the process contention scope threads.
RETURN VALUE
Upon successful completion, the function shall return the former scheduling policy of the specified process. If the
sched_setscheduler() function fails to complete successfully, the policy and scheduling parameters shall remain unchanged,
and the function shall return a value of -1 and set errno to indicate the error.
ERRORS
The sched_setscheduler() function shall fail if:
[EINVAL]
The value of the policy parameter is invalid, or one or more of the parameters contained in param is outside the
valid range for the specified scheduling policy.
[EPERM]
The requesting process does not have permission to set either or both of the scheduling parameters or the scheduling policy of
the specified process.
[ESRCH]
No process can be found corresponding to that specified by pid.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
Scheduling Policies, sched_getparam(), sched_getscheduler(), sched_setparam()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The sched_setscheduler() function is marked as part of the Process Scheduling option.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Process
Scheduling option.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the DESCRIPTION, the effect of this function on a thread's scheduling parameters is added.
Sections describing two-level scheduling and atomicity of the function are added.
The SCHED_SPORADIC scheduling policy is added for alignment with IEEE Std 1003.1d-1999.
Issue 7
Austin Group Interpretation 1003.1-2001 #061 is applied, updating the DESCRIPTION.
Austin Group Interpretation 1003.1-2001 #119 is applied, clarifying the accuracy requirements for the
sched_ss_repl_period and sched_ss_init_budget values.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/tss_create.html =====
tss_create
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
tss_create — thread-specific data key creation
SYNOPSIS
#include
int tss_create(tss_t *key, tss_dtor_t dtor);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The tss_create() function shall create a thread-specific storage pointer with destructor dtor, which can be
null.
A null pointer value shall be associated with the newly created key in all existing threads. Upon subsequent thread creation,
the value associated with all keys shall be initialized to a null pointer value in the new thread.
Destructors associated with thread-specific storage shall not be invoked at process termination.
The behavior is undefined if the tss_create() function is called from within a destructor.
[CX]  The
tss_create() function shall not be affected if the calling thread executes a signal handler during the call.
RETURN VALUE
If the tss_create() function is successful, it shall set the thread-specific storage pointed to by key to a value
that uniquely identifies the newly created pointer and shall return thrd_success; otherwise, thrd_error shall be
returned and the thread-specific storage pointed to by key has an indeterminate value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The tss_create() function performs no implicit synchronization. It is the responsibility of the application writer to
ensure that it is called exactly once per key before use of the key.
RATIONALE
If the value associated with a key needs to be updated during the lifetime of the thread, it may be necessary to release the
storage associated with the old value before the new value is bound. Although the tss_set() function could do this automatically, this feature is not needed often enough to
justify the added complexity. Instead, the application is responsible for freeing the stale storage:
old = tss_get(key);
new = allocate();
destructor(old);
tss_set(key, new);
There is no notion of a destructor-safe function. If an application does not call thrd_exit() or pthread_exit() from a
signal handler, or if, while calling async-unsafe functions, it blocks any signal whose handler might call thrd_exit() or pthread_exit(), all
functions can be safely called from destructors.
The tss_create() function is not affected by signal handlers for the reasons stated in XRAT B.2.3 Error Numbers.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_exit(), pthread_key_create(), thrd_exit(), tss_delete(), tss_get()
XBD
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mbrtoc32.html =====
mbrtoc16
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mbrtoc16, mbrtoc32 — convert a character to a Unicode character code (restartable)
SYNOPSIS
#include
size_t mbrtoc16(char16_t *restrict pc16, const char *restrict s,
size_t n, mbstate_t *restrict ps);
size_t mbrtoc32(char32_t *restrict pc32, const char *restrict s,
size_t n, mbstate_t *restrict ps);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
If s is a null pointer, the mbrtoc16() function shall be equivalent to the call:
mbrtoc16(NULL, "", 1, ps)
In this case, the values of the parameters pc16 and n are ignored.
If s is not a null pointer, the mbrtoc16() function shall inspect at most n bytes beginning with the byte
pointed to by s to determine the number of bytes needed to complete the next character (including any shift sequences). If
the function determines that the next character is complete and valid, it shall determine the values of the corresponding wide
characters and then, if pc16 is not a null pointer, shall store the value of the first (or only) such character in the
object pointed to by pc16. Subsequent calls shall store successive wide characters without consuming any additional input
until all the characters have been stored. If the corresponding wide character is the null wide character, the resulting state
described shall be the initial conversion state.
If ps is a null pointer, the mbrtoc16() function shall use its own internal mbstate_t object, which shall
be initialized at program start-up to the initial conversion state. Otherwise, the mbstate_t object pointed to by ps
shall be used to completely describe the current conversion state of the associated character sequence.
The behavior of this function is affected by the LC_CTYPE category of the current locale.
The mbrtoc16() function shall not change the setting of errno if successful.
The mbrtoc32() function shall behave the same way as mbrtoc16() except that the first parameter shall point to an
object of type char32_t instead of char16_t. References to pc16 in the above description shall apply as if
they were pc32 when they are being read as describing mbrtoc32().
If called with a null ps argument, the mbrtoc16() function need not be thread-safe; however, such calls shall
avoid data races with calls to mbrtoc16() with a non-null argument and with calls to all other functions.
If called with a null ps argument, the mbrtoc32() function need not be thread-safe; however, such calls shall
avoid data races with calls to mbrtoc32() with a non-null argument and with calls to all other functions.
The implementation shall behave as if no function defined in this volume of POSIX.1-2024 calls mbrtoc16() or
mbrtoc32() with a null pointer for ps.
RETURN VALUE
These functions shall return the first of the following that applies:
0
If the next n or fewer bytes complete the character that corresponds to the null wide character (which is the value
stored).
between 1 and n inclusive
If the next n or fewer bytes complete a valid character (which is the value stored); the value returned shall be the number
of bytes that complete the character.
(size_t)-3
If the next character resulting from a previous call has been stored, in which case no bytes from the input shall be consumed
by the call.
(size_t)-2
If the next n bytes contribute to an incomplete but potentially valid character, and all n bytes have been
processed (no value is stored). When n has at least the value of the {MB_CUR_MAX} macro, this case can only occur if
s points at a sequence of redundant shift sequences (for implementations with state-dependent encodings).
(size_t)-1
If an encoding error occurs, in which case the next n or fewer bytes do not contribute to a complete and valid character
(no value is stored). In this case, [EILSEQ] shall be stored in errno and the conversion state is undefined.
ERRORS
These functions shall fail if:
[EILSEQ]
An invalid character sequence is detected. [CX]   In the POSIX locale an [EILSEQ] error cannot occur since all byte
values are valid characters.
These functions may fail if:
[EINVAL]
[CX]
ps points to an object that contains an invalid conversion state.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
c16rtomb()
XBD
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fgetc.html =====
fgetc
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fgetc — get a byte from a stream
SYNOPSIS
#include
int fgetc(FILE *stream);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
If the end-of-file indicator for the input stream pointed to by stream is not set and a next byte is present, the
fgetc() function shall obtain the next byte as an unsigned char converted to an int, from the input stream
pointed to by stream, and advance the associated file position indicator for the stream (if defined). Since fgetc()
operates on bytes, reading a character consisting of multiple bytes (or "a multi-byte character") may require multiple calls to
fgetc().
[CX]  The
fgetc() function may mark the last data access timestamp of the file associated with stream for update. The last data
access timestamp shall be marked for update by the first successful execution of fgetc(), fgets(), fread(), fscanf(), getc(), getchar(), getdelim(), getline(), or scanf() using stream that
returns data not supplied by a prior call to ungetc().
RETURN VALUE
Upon successful completion, fgetc() shall return the next byte from the input stream pointed to by stream. If the
end-of-file indicator for the stream is set, or if the stream is at end-of-file, the end-of-file indicator for the stream shall be
set and fgetc() shall return EOF. If an error occurs, the error indicator for the stream shall be set, fgetc() shall
return EOF, [CX]   and shall set errno to indicate the error.
ERRORS
The fgetc() function shall fail if data needs to be read and:
[EAGAIN]
[CX]
The O_NONBLOCK flag is set for the file descriptor underlying stream and the thread would be delayed in the fgetc()
operation.
[EBADF]
[CX]
The file descriptor underlying stream is not a valid file descriptor open for reading.
[EINTR]
[CX]
The read operation was terminated due to the receipt of a signal, and no data was transferred.
[EIO]
[CX]  A
physical I/O error has occurred, or the process is in a background process group attempting to read from its controlling terminal,
and either the calling thread is blocking SIGTTIN or the process is ignoring SIGTTIN or the process group of the process is
orphaned. This error may also be generated for implementation-defined reasons.
[EOVERFLOW]
[CX]
The file is a regular file and an attempt was made to read at or beyond the offset maximum associated with the corresponding
stream.
The fgetc() function may fail if:
[ENOMEM]
[CX]
Insufficient storage space is available.
[ENXIO]
[CX]  A
request was made of a nonexistent device, or the request was outside the capabilities of the device.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
If the integer value returned by fgetc() is stored into a variable of type char and then compared against the
integer constant EOF, the comparison may never succeed, because sign-extension of a variable of type char on widening to
integer is implementation-defined.
The ferror() or feof() functions must
be used to distinguish between an error condition and an end-of-file condition.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, feof(), ferror(), fgets(), fread(), fscanf(), getchar(), getc(), ungetc()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
Large File Summit extensions are added.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The [EIO] and [EOVERFLOW] mandatory error conditions are added.
The [ENOMEM] and [ENXIO] optional error conditions are added.
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The DESCRIPTION is updated to clarify the behavior when the end-of-file indicator for the input stream is not set.
The RETURN VALUE section is updated to note that the error indicator shall be set for the stream.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/32 is applied, updating the [EAGAIN] error in the ERRORS section
from "the process would be delayed" to "the thread would be delayed".
Issue 7
Austin Group Interpretation 1003.1-2001 #051 is applied, updating the list of functions that mark the last data access timestamp
for update.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0129 [79] and XSH/TC1-2008/0130 [14] are applied.
Issue 8
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
Austin Group Defect 1624 is applied, changing the RETURN VALUE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/isunordered.html =====
isunordered
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
isunordered — test if arguments are unordered
SYNOPSIS
#include
int isunordered(real-floating x, real-floating y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The isunordered() macro shall determine whether its arguments are unordered.
RETURN VALUE
Upon successful completion, the isunordered() macro shall return 1 if its arguments are unordered, and 0 otherwise.
If x or y is NaN, 1 shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The relational and equality operators support the usual mathematical relationships between numeric values. For any ordered pair
of numeric values, exactly one of the relationships (less, greater, and equal) is true. Relational operators may raise the invalid
floating-point exception when argument values are NaNs. For a NaN and a numeric value, or for two NaNs, just the unordered
relationship is true. This macro is a quiet (non-floating-point exception raising) version of a relational operator. It facilitates
writing efficient code that accounts for NaNs without suffering the invalid floating-point exception. In the SYNOPSIS section,
real-floating indicates that the argument shall be an expression of real-floating type.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
isgreater()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/50 is applied, correcting the RETURN VALUE section when x
or y is NaN.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcpcpy.html =====
wcscpy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcpcpy, wcscpy — copy a wide-character string, returning a pointer to its end
SYNOPSIS
#include
[CX]  wchar_t *wcpcpy(wchar_t *restrict ws1, const wchar_t *restrict ws2);
wchar_t *wcscpy(wchar_t *restrict ws1, const wchar_t *restrict ws2);
DESCRIPTION
For wcscpy(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The [CX]
wcpcpy()   and wcscpy() functions shall copy the
wide-character string pointed to by ws2 (including the terminating null wide-character code) into the array pointed to by
ws1.
The application shall ensure that there is room for at least wcslen(ws2)+1 wide characters in the ws1
array, and that the ws2 and ws1 arrays do not overlap.
If copying takes place between objects that overlap, the behavior is undefined.
[CX]  The
wcscpy() and wcpcpy() functions shall not change the setting of errno on valid input.
RETURN VALUE
[CX]  The
wcpcpy() function shall return a pointer to the terminating null wide-character code copied into the ws1 buffer.
The wcscpy() function shall return ws1.
No return values are reserved to indicate an error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
strcpy(), wcsdup(), wcsncpy()
XBD
CHANGE HISTORY
First released in Issue 4. Derived from the MSE working draft.
Issue 6
The wcscpy() prototype is updated for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
The wcpcpy() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 1.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that wcscpy() and wcpcpy() do not change the setting of
errno on valid input.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mkdtemp.html =====
mkdtemp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mkdtemp, mkostemp, mkstemp — create a unique directory or file
SYNOPSIS
[CX]  #include
char *mkdtemp(char *template);
int mkostemp(char *template, int flag);
int mkstemp(char *template);
DESCRIPTION
The mkdtemp() function shall create a directory with a unique name derived from template. The application shall
ensure that the string provided in template is a pathname ending with at least six trailing 'X' characters. The
mkdtemp() function shall modify the contents of template by replacing six or more 'X' characters at the end
of the pathname with the same number of characters from the portable filename character set. The characters shall be chosen such
that the resulting pathname does not duplicate the name of an existing file at the time of the call to mkdtemp(). The
mkdtemp() function shall use the resulting pathname to create the new directory as if by a call to:
mkdir(pathname, S_IRWXU)
The mkstemp() function shall create a regular file with a unique name derived from template and return a file
descriptor for the file open for reading and writing. The application shall ensure that the string provided in template is a
pathname ending with at least six trailing 'X' characters. The mkstemp() function shall modify the contents of
template by replacing six or more 'X' characters at the end of the pathname with the same number of characters from
the portable filename character set. The characters shall be chosen such that the resulting pathname does not duplicate the name of
an existing file at the time of the call to mkstemp(). The mkstemp() function shall use the resulting pathname to
create the file, and obtain a file descriptor for it, as if by a call to:
open(pathname, O_RDWR|O_CREAT|O_EXCL, S_IRUSR|S_IWUSR)
By behaving as if the O_EXCL flag for open() is set, the function prevents any
possible race condition between testing whether the file exists and opening it for use.
The mkostemp() function shall be equivalent to the mkstemp() function, except that the flag argument can
contain additional flags to be used as if by open(). Behavior is unspecified if the
flag argument contains more than the following flags:
O_APPEND
Set append mode.
O_CLOEXEC
Set the FD_CLOEXEC file descriptor flag.
O_CLOFORK
Set the FD_CLOFORK file descriptor flag.
O_DSYNC
[SIO]
Write according to the synchronized I/O data integrity completion.
O_RSYNC
[SIO]
Synchronized read I/O operations.
O_SYNC
[XSI|SIO]  Write according to synchronized I/O file integrity completion.
RETURN VALUE
Upon successful completion, the mkdtemp() function shall return the value of template. Otherwise, it shall return
a null pointer and shall set errno to indicate the error.
Upon successful completion, the mkstemp() function shall return an open file descriptor. Otherwise, it shall return -1
and shall set errno to indicate the error.
ERRORS
These functions shall fail if:
[EINVAL]
The string pointed to by template does not end in "XXXXXX".
The mkostemp() function may fail if:
[EINVAL]
The value of the flag argument is invalid.
Additional error conditions for the mkdtemp() function are defined in mkdir(). Additional error conditions for the mkstemp() and
mkostemp() functions are defined in open().
The following sections are informative.
EXAMPLES
Generating a Pathname
The following example creates a file with a 10-character name beginning with the characters "file" and opens the file
for reading and writing. The value returned as the value of fd is a file descriptor that identifies the file.
#include
...
char template[] = "/tmp/fileXXXXXX";
int fd;
fd = mkstemp(template);
APPLICATION USAGE
It is possible to run out of letters.
Portable applications should pass exactly six trailing 'X's in the template and no more; implementations may treat any
additional trailing 'X's as either a fixed or replaceable part of the template. To be sure of only passing six, a fixed
string of at least one non-'X' character should precede the six 'X's.
Since 'X' is in the portable filename character set, some of the replacement characters can be 'X's, leaving
part (or even all) of the template effectively unchanged.
RATIONALE
The O_CLOEXEC and O_CLOFORK flags of mkostemp() are necessary to avoid a data race in multi-threaded applications.
Without O_CLOFORK, a file descriptor is leaked into a child process created by one thread in the window between another thread
creating a temporary file descriptor with mkstemp() and then using fcntl() to
set the FD_CLOFORK flag. Without O_CLOEXEC, a temporary file descriptor intentionally inherited by child processes is similarly
leaked into an executed program if FD_CLOEXEC is not set atomically.
Implementations are encouraged to have mkdtemp(), mkostemp(), and mkstemp() report an [EILSEQ] error if the
last component of the pathname in template contains any bytes that have the encoded value of a
character.
FUTURE DIRECTIONS
None.
SEE ALSO
getpid(), mkdir(),
open(), tmpfile(), tmpnam()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 7
Austin Group Interpretation 1003.1-2001 #143 is applied.
SD5-XSH-ERN-168 is applied, clarifying file permissions upon creation.
The mkstemp() function is moved from the XSI option to the Base.
The mkdtemp() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 1.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0380 [291], XSH/TC1-2008/0381 [324], and XSH/TC1-2008/0382 [291] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0215 [567,669] is applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defects 411, 1318, and 1350 are applied, adding mkostemp().
Austin Group Defect 652 is applied, adding the [EINVAL] error for mkstemp().
Austin Group Defect 1734 is applied, replacing the error conditions specified only for mkdtemp() with a reference to
mkdir().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/quick_exit.html =====
quick_exit
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
quick_exit — terminate a process
SYNOPSIS
#include
_Noreturn void quick_exit(int status);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The quick_exit() function shall cause normal process termination to occur. It shall not call functions registered with
atexit() nor any registered signal handlers. If a process calls the
quick_exit() function more than once, or calls the exit() function in addition
to the quick_exit() function, the behavior is undefined. If a signal is raised while the quick_exit() function is
executing, the behavior is undefined.
The quick_exit() function shall first call all functions registered by at_quick_exit(), in the reverse order of their registration, except that a function is
called after any previously registered functions that had already been called at the time it was registered. If, during the call to
any such function, a call to the longjmp() [CX]   or siglongjmp()
function is made that would terminate the call to the registered function, the behavior is undefined.
If a function registered by a call to at_quick_exit() fails to return, the
remaining registered functions shall not be called and the rest of the quick_exit() processing shall not be completed.
Finally, the quick_exit() function shall terminate the process as if by a call to _Exit(status).
RETURN VALUE
The quick_exit() function does not return.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
_Exit(), at_quick_exit(),
atexit(), exit()
XBD
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pow.html =====
pow
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pow, powf, powl — power function
SYNOPSIS
#include
double pow(double x, double y);
float powf(float x, float y);
long double powl(long double x, long double y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the value of x raised to the power y, xy. If
x is negative, the application shall ensure that y is an integer value.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the value of x raised to the power y.
For finite values of x  0, if x is ±0, ±0 shall be returned.
For y > 0 and not an odd integer, if x is ±0, +0 shall be returned.
If x is -1, and y is ±Inf, 1.0 shall be returned.
For |x|  1, if y is -Inf, +0 shall be returned.
For |x|  1, if y is +Inf, +Inf shall be returned.
For y an odd integer  0, if x is -Inf, -Inf shall be returned.
For y > 0 and not an odd integer, if x is -Inf, +Inf shall be returned.
For y  0, if x is +Inf, +Inf shall be returned.
[MXX]
If the correct value would cause underflow, and is representable, a range error may occur and the correct value shall be returned.
ERRORS
These functions shall fail if:
Domain Error
The value of x is negative and y is a finite non-integer.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
Pole Error
[MX]
The value of x is zero and y is negative.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the divide-by-zero floating-point exception shall
be raised.
Range Error
The result overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
These functions may fail if:
Pole Error
The value of x is zero and y is negative.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the divide-by-zero floating-point exception shall
be raised.
Range Error
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
exp(), feclearexcept(),
fetestexcept(), isnan()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
The powf() and powl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/42 is applied, correcting the third paragraph in the RETURN
VALUE section.
Issue 7
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #51 (SD5-XSH-ERN-81) is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0443 [68], XSH/TC1-2008/0444 [148], and XSH/TC1-2008/0445 [68] are
applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/stat.html =====
fstatat
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fstatat, lstat, stat — get file status
SYNOPSIS
[OH] #include
#include
int fstatat(int fd, const char *restrict path,
struct stat *restrict buf, int flag);
int lstat(const char *restrict path, struct stat *restrict buf);
int stat(const char *restrict path, struct stat *restrict buf);
DESCRIPTION
The stat() function shall obtain information about the named file and write it to the area pointed to by the buf
argument. The path argument points to a pathname naming a file. Read, write, or execute permission of the named file is not
required. An implementation that provides additional or alternate file access control mechanisms may, under implementation-defined
conditions, cause stat() to fail. In particular, the system may deny the existence of the file specified by path.
If the named file is a symbolic link, the stat() function shall continue pathname resolution using the contents of the
symbolic link, and shall return information pertaining to the resulting file if the file exists.
The buf argument is a pointer to a stat structure, as defined in the  header, into which information is placed concerning the file.
The stat() function shall update any time-related fields (as described in XBD 4.12 File Times Update), before writing into the stat structure.
[SHM]
If the named file is a shared memory object, the implementation shall update in the stat structure pointed to by the
buf argument the st_uid, st_gid, st_size, and st_mode fields, and only the S_IRUSR, S_IWUSR,
S_IRGRP, S_IWGRP, S_IROTH, and S_IWOTH file permission bits need be valid. The implementation may update other fields and flags.
[TYM]
If the named file is a typed memory object, the implementation shall update in the stat structure pointed to by the
buf argument the st_uid, st_gid, st_size, and st_mode fields, and only the S_IRUSR, S_IWUSR,
S_IRGRP, S_IWGRP, S_IROTH, and S_IWOTH file permission bits need be valid. The implementation may update other fields and flags.
For all other file types defined in this volume of POSIX.1-2024, the structure members st_mode, st_ino,
st_dev, st_uid, st_gid, st_atim, st_ctim, and st_mtim shall have meaningful values and
the value of the member st_nlink shall be set to the number of hard links to the file.
The lstat() function shall be equivalent to stat(), except when path refers to a symbolic link. In that
case lstat() shall return information about the link, while stat() shall return information about the file the link
references.
For symbolic links, the st_mode member shall contain meaningful information when used with the file type macros. The file
mode bits in st_mode are unspecified. The structure members st_ino, st_dev, st_uid, st_gid,
st_atim, st_ctim, and st_mtim shall have meaningful values and the value of the st_nlink member shall
be set to the number of hard links to the symbolic link. The value of the st_size member shall be set to the length of the
pathname contained in the symbolic link not including any terminating null byte.
The fstatat() function shall be equivalent to the stat() or lstat() function, depending on the value of
flag (see below), except in the case where path specifies a relative path. In this case the status shall be retrieved
from a file relative to the directory associated with the file descriptor fd instead of the current working directory. If
the access mode of the open file description associated with the file descriptor is not O_SEARCH, the function shall check whether
directory searches are permitted using the current permissions of the directory underlying the file descriptor. If the access mode
is O_SEARCH, the function shall not perform the check.
Values for flag are constructed by a bitwise-inclusive OR of flags from the following list, defined in :
AT_SYMLINK_NOFOLLOW
If path names a symbolic link, the status of the symbolic link is returned.
If fstatat() is passed the special value AT_FDCWD in the fd parameter, the current working directory shall be used
and the behavior shall be identical to a call to stat() or lstat() respectively, depending on whether or not the
AT_SYMLINK_NOFOLLOW bit is set in flag.
RETURN VALUE
Upon successful completion, these functions shall return 0. Otherwise, these functions shall return -1 and set errno to
indicate the error.
ERRORS
These functions shall fail if:
[EACCES]
Search permission is denied for a component of the path prefix.
[EIO]
An error occurred while reading from the file system.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of path does not name an existing file or path is an empty string.
[ENOTDIR]
A component of the path prefix names an existing file that is neither a directory nor a symbolic link to a directory, or the
path argument contains at least one non- character and ends with one or more trailing  characters
and the last pathname component names an existing file that is neither a directory nor a symbolic link to a directory.
[EOVERFLOW]
The file size in bytes or the number of blocks allocated to the file or the file serial number cannot be represented correctly
in the structure pointed to by buf.
The fstatat() function shall fail if:
[EACCES]
The access mode of the open file description associated with fd is not O_SEARCH and the permissions of the directory
underlying fd do not permit directory searches.
[EBADF]
The path argument does not specify an absolute path and the fd argument is neither AT_FDCWD nor a valid file
descriptor open for reading or searching.
[ENOTDIR]
The path argument is not an absolute path and fd is a file descriptor associated with a non-directory file.
These functions may fail if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
[EOVERFLOW]
A value to be stored would overflow one of the members of the stat structure.
The fstatat() function may fail if:
[EINVAL]
The value of the flag argument is not valid.
The following sections are informative.
EXAMPLES
Obtaining File Status Information
The following example shows how to obtain file status information for a file named /home/cnd/mod1. The structure variable
buffer is defined for the stat structure.
#include
#include
#include
struct stat buffer;
int         status;
...
status = stat("/home/cnd/mod1", &buffer);
Getting Directory Information
The following example fragment gets status information for each entry in a directory. The call to the stat() function
stores file information in the stat structure pointed to by statbuf. The lines that follow the stat() call
format the fields in the stat structure for presentation to the user of the program.
#include
#include
#include
#include
#include
#include
#include
#include
#include
#include
struct dirent  *dp;
struct stat     statbuf;
struct passwd  *pwd;
struct group   *grp;
struct tm      *tm;
char            datestring[256];
...
/* Loop through directory entries. */
while ((dp = readdir(dir)) != NULL) {
/* Get entry's information. */
if (stat(dp->d_name, &statbuf) == -1)
continue;
/* Print out type, permissions, and number of links. */
printf("%10.10s", mode_string(statbuf.st_mode));
printf(" %4ju", (uintmax_t)statbuf.st_nlink);
/* Print out owner's name if it is found using getpwuid(). */
if ((pwd = getpwuid(statbuf.st_uid)) != NULL)
printf(" %-8.8s", pwd->pw_name);
else
printf(" %-8ju", (uintmax_t)statbuf.st_uid);
/* Print out group name if it is found using getgrgid(). */
if ((grp = getgrgid(statbuf.st_gid)) != NULL)
printf(" %-8.8s", grp->gr_name);
else
printf(" %-8ju", (uintmax_t)statbuf.st_gid);
/* Print size of file. */
printf(" %9jd", (intmax_t)statbuf.st_size);
tm = localtime(&statbuf.st_mtime);
/* Get localized date string. */
strftime(datestring, sizeof(datestring), nl_langinfo(D_T_FMT), tm);
printf(" %s %s\n", datestring, dp->d_name);
}
Obtaining Symbolic Link Status Information
The following example shows how to obtain status information for a symbolic link named /modules/pass1. The structure
variable buffer is defined for the stat structure. If the path argument specified the pathname for the file
pointed to by the symbolic link (/home/cnd/mod1), the results of calling the function would be the same as those returned by
a call to the stat() function.
#include
struct stat buffer;
int status;
...
status = lstat("/modules/pass1", &buffer);
APPLICATION USAGE
None.
RATIONALE
The intent of the paragraph describing "additional or alternate file access control mechanisms" is to allow a secure
implementation where a process with a label that does not dominate the file's label cannot perform a stat() function. This
is not related to read permission; a process with a label that dominates the file's label does not need read permission. An
implementation that supports write-up operations could fail fstat() function calls
even though it has a valid file descriptor open for writing.
The purpose of the fstatat() function is to obtain the status of files in directories other than the current working
directory without exposure to race conditions. Any part of the path of a file could be changed in parallel to a call to
stat(), resulting in unspecified behavior. By opening a file descriptor for the target directory and using the
fstatat() function it can be guaranteed that the file for which status is returned is located relative to the desired
directory.
FUTURE DIRECTIONS
None.
SEE ALSO
access(), chmod(),
fdopendir(), fstat(), mknod(), readlink(), symlink()
XBD 4.12 File Times Update, , ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
Large File Summit extensions are added.
Issue 6
In the SYNOPSIS, the optional include of the  header is
removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
The [EIO] mandatory error condition is added.
The [ELOOP] mandatory error condition is added.
The [EOVERFLOW] mandatory error condition is added. This change is to support large files.
The [ENAMETOOLONG] and the second [EOVERFLOW] optional error conditions are added.
The following changes were made to align with the IEEE P1003.1a draft standard:
Details are added regarding the treatment of symbolic links.
The [ELOOP] optional error condition is added.
The normative text is updated to avoid use of the term "must" for application requirements.
The restrict keyword is added to the stat() prototype for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
Austin Group Interpretation 1003.1-2001 #143 is applied.
XSH-SD5-ERN-161 is applied, updating the DESCRIPTION to clarify to which file types st_nlink applies.
The fstatat() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 2.
Changes are made related to support for finegrained timestamps.
The lstat() function is now required to return meaningful data for symbolic links in all stat structure fields,
except for the permission bits of st_mode.
Changes are made to allow a directory to be opened for searching.
The [ENOTDIR] error condition is clarified to cover the condition where the last component of a pathname exists but is not a
directory or a symbolic link to a directory.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0198 [461], XSH/TC1-2008/0199 [324], XSH/TC1-2008/0200 [278],
XSH/TC1-2008/0201 [278], and XSH/TC1-2008/0202 [291] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0136 [591], XSH/TC2-2008/0137 [817], XSH/TC2-2008/0138 [817], and
XSH/TC2-2008/0139 [889] are applied.
Issue 8
Austin Group Defect 1380 is applied, changing text using the term "link" in line with its updated definition.
Austin Group Defect 1409 is applied, changing the EXAMPLES section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fexecve.html =====
exec
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
environ, execl, execle, execlp, execv, execve, execvp, fexecve — execute a file
SYNOPSIS
#include
extern char **environ;
int execl(const char *path, const char *arg0, ... /*, (char *)0 */);
int execle(const char *path, const char *arg0, ... /*,
(char *)0, char *const envp[]*/);
int execlp(const char *file, const char *arg0, ... /*, (char *)0 */);
int execv(const char *path, char *const argv[]);
int execve(const char *path, char *const argv[], char *const envp[]);
int execvp(const char *file, char *const argv[]);
int fexecve(int fd, char *const argv[], char *const envp[]);
DESCRIPTION
The exec family of functions shall replace the current process image with a new process image. The new image shall be
constructed from a regular, executable file called the new process image file. There shall be no return from a successful
exec, because the calling process image is overlaid by the new process image.
The fexecve() function shall be equivalent to the execve() function except that the file to be executed is
determined by the file descriptor fd instead of a pathname. The file offset of fd is ignored.
When a C-language program is executed as a result of a call to one of the exec family of functions, it shall be entered
as a C-language function call as follows:
int main (int argc, char *argv[]);
where argc is the argument count and argv is an array of character pointers to the arguments themselves. In
addition, the following variable, which needs to be declared by the user if it is to be used directly:
extern char **environ;
is initialized as a pointer to an array of character pointers to the environment strings. The argv and environ
arrays are each terminated by a null pointer. The null pointer terminating the argv array is not counted in argc.
Applications can change the entire environment in a single operation by assigning the environ variable to point to an
array of character pointers to the new environment strings. After assigning a new value to environ, applications should not
rely on the new environment strings remaining part of the environment, as a call to getenv(), secure_getenv(),
[XSI]
putenv(),  setenv(), unsetenv(), or any function that is
dependent on an environment variable may, on noticing that environ has changed, copy the environment strings to a new array
and assign environ to point to it.
Any application that directly modifies the pointers to which the environ variable points has undefined behavior.
Conforming multi-threaded applications shall not use the environ variable to access or modify any environment variable
while any other thread is concurrently modifying any environment variable. A call to any function dependent on any environment
variable shall be considered a use of the environ variable to access that environment variable.
The arguments specified by a program with one of the exec functions shall be passed on to the new process image in the
corresponding main() arguments.
For the execl(), execle(), execv(), and execve() functions, the argument path points to a
pathname that identifies the new process image file.
For the execlp() and execvp() functions, the argument file is used to construct a pathname that identifies
the new process image file. If the file argument contains a  character, the file argument shall be used
as the pathname for this file. Otherwise, the path prefix for this file is obtained by a search of the directories passed as the
environment variable PATH (see XBD 8. Environment Variables). If
this environment variable is not present, the results of the search are implementation-defined.
There are two distinct ways in which the contents of the process image file may cause the execution to fail, distinguished by
the setting of errno to either [ENOEXEC] or [EINVAL] (see the ERRORS section). In the cases where the other members of the
exec family of functions would fail and set errno to [ENOEXEC], the execlp() and execvp() functions
shall execute a command interpreter and the environment of the executed command shall be as if the process invoked the sh utility using execl() as follows:
execl(, , file, , (char *)0);
where  is an unspecified pathname for the sh utility,
is an unspecified string, file is the process image file, and where  is zero or more
parameters corresponding to any initial non-null arguments passed after arg0 for execlp() or to any initial non-null
members of argv starting at argv[1] for execvp().
The arguments represented by arg0,... are pointers to null-terminated character strings. These strings shall constitute
the argument list available to the new process image. The list is terminated by a null pointer. The argument arg0 should
point to a filename string that is associated with the process being started by one of the exec functions.
The argument argv is an array of character pointers to null-terminated strings. The application shall ensure that the
last member of this array is a null pointer. These strings shall constitute the argument list available to the new process image.
The value in argv[0] should point to a filename string that is associated with the process being started by one of the
exec functions.
The argument envp is an array of character pointers to null-terminated strings. These strings shall constitute the
environment for the new process image. The envp array is terminated by a null pointer.
For those forms not containing an envp pointer (execl(), execv(),
execlp(), and execvp()), the environment for the new process image shall be taken from the external variable
environ in the calling process.
The number of bytes available for the new process' combined argument and environment lists is {ARG_MAX}. It is
implementation-defined whether null terminators, pointers, and/or any alignment bytes are included in this total.
File descriptors open in the calling process image shall remain open in the new process image, except for those whose
close-on-exec flag FD_CLOEXEC is set. For those file descriptors that remain open, all attributes of the open file
description shall remain unchanged and the FD_CLOFORK file descriptor flag, if set, shall remain set. For any file descriptor that
is closed for this reason, process-owned file locks that the calling process owns on the file associated with the file descriptor
shall be unlocked as a result of the close, as described in close(). File locks that
are not unlocked by closing of file descriptors remain unchanged.
If file descriptor 0, 1, or 2 would otherwise be closed after a successful call to one of the exec family of functions,
implementations may open an unspecified file for the file descriptor in the new process image. If a standard utility or a
conforming application is executed with file descriptor 0 not open for reading or with file descriptor 1 or 2 not open for writing,
the environment in which the utility or application is executed shall be deemed non-conforming, and consequently the utility or
application might not behave as described in this standard.
Directory streams open in the calling process image shall be closed in the new process image.
The state of the floating-point environment in the initial thread of the new process image shall be set to the default.
The state of conversion descriptors and message catalog descriptors in the new process image is undefined.
For the new process image, the equivalent of:
setlocale(LC_ALL, "C")
shall be executed at start-up.
Signals set to the default action (SIG_DFL) in the calling process image shall be set to the default action in the new process
image. Except for SIGCHLD, signals set to be ignored (SIG_IGN) by the calling process image shall be set to be ignored by the new
process image. Signals set to be caught by the calling process image shall be set to the default action in the new process image
(see ).
If the SIGCHLD signal is set to be ignored by the calling process image, it is unspecified whether the SIGCHLD signal is set to
be ignored or to the default action in the new process image.
[XSI]
After a successful call to any of the exec functions, alternate signal stacks are not preserved and the SA_ONSTACK flag
shall be cleared for all signals.
After a successful call to any of the exec functions, any functions previously registered by the atexit(), at_quick_exit(), or pthread_atfork() functions are no longer registered.
[XSI]
If the ST_NOSUID bit is set for the file system containing the new process image file, then the effective user ID, effective group
ID, saved set-user-ID, and saved set-group-ID are unchanged in the new process image. Otherwise,  if the set-user-ID mode bit of the new process image file is set, the effective user ID of the new
process image shall be set to the user ID of the new process image file. Similarly, if the set-group-ID mode bit of the new process
image file is set, the effective group ID of the new process image shall be set to the group ID of the new process image file. The
real user ID, real group ID, and supplementary group IDs of the new process image shall remain the same as those of the calling
process image. The effective user ID and effective group ID of the new process image shall be saved (as the saved set-user-ID and
the saved set-group-ID) for use by setuid().
[XSI]
Any shared memory segments attached to the calling process image shall not be attached to the new process image.
Any named semaphores open in the calling process shall be closed as if by appropriate calls to sem_close(). Any unnamed semaphores open in the calling process shall be destroyed as if
by calls to sem_destroy().
[TYM]
Any blocks of typed memory that were mapped in the calling process are unmapped, as if munmap() was implicitly called to unmap them.
[ML]
Memory locks established by the calling process via calls to mlockall() or mlock() shall be removed. If locked pages in the address space of the calling process are also
mapped into the address spaces of other processes and are locked by those processes, the locks established by the other processes
shall be unaffected by the call by this process to the exec function. If the exec function fails, the effect on
memory locks is unspecified.
Memory mappings created in the process are unmapped before the address space is rebuilt for the new process image.
When the calling process image does not use the SCHED_FIFO, SCHED_RR, [SS]
or SCHED_SPORADIC   scheduling policies, the scheduling policy and parameters of the new process image and the initial
thread in that new process image are implementation-defined.
[PS]
When the calling process image uses the SCHED_FIFO, SCHED_RR, or SCHED_SPORADIC scheduling policies, the process policy and
scheduling parameter settings shall not be changed by a call to an exec function.  [TPS]   The initial thread in the new process image shall inherit the process scheduling policy and
parameters. It shall have the default system contention scope, but shall inherit its allocation domain from the calling process
image.
Per-process timers created by the calling process shall be deleted before replacing the current process image with the new
process image.
[MSG]
All open message queue descriptors in the calling process shall be closed, as described in mq_close().
Any outstanding asynchronous I/O operations may be canceled. Those asynchronous I/O operations that are not canceled shall
complete as if the exec function had not yet occurred, but any associated signal notifications shall be suppressed. It is
unspecified whether the exec function itself blocks awaiting such I/O completion. In no event, however, shall the new
process image created by the exec function be affected by the presence of outstanding asynchronous I/O operations at the
time the exec function is called. Whether any I/O is canceled, and which I/O may be canceled upon exec, is
implementation-defined.
[CPT]
The new process image shall inherit the CPU-time clock of the calling process image. This inheritance means that the process
CPU-time clock of the process being exec-ed shall not be reinitialized or altered as a result of the exec function
other than to reflect the time spent by the process executing the exec function itself.
[TCT]
The initial value of the CPU-time clock of the initial thread of the new process image shall be set to zero.
The thread ID of the initial thread in the new process image is unspecified.
The size and location of the stack on which the initial thread in the new process image runs is unspecified.
The initial thread in the new process image shall have its cancellation type set to PTHREAD_CANCEL_DEFERRED and its cancellation
state set to PTHREAD_CANCEL_ENABLED.
The initial thread in the new process image shall have all thread-specific data values set to NULL and all thread-specific data
keys shall be removed by the call to exec without running destructors.
The initial thread in the new process image shall be joinable, as if created with the detachstate attribute set to
PTHREAD_CREATE_JOINABLE.
The new process shall inherit at least the following attributes from the calling process image:
[XSI]
Nice value (see nice())
[XSI]
semadj values (see semop())
Process ID
Parent process ID
Process group ID
Session membership
Real user ID
Real group ID
Supplementary group IDs
Time left until an alarm clock signal (see alarm())
Current working directory
Root directory
File mode creation mask (see umask())
File size limit (see getrlimit() and setrlimit())
Process signal mask (see pthread_sigmask())
Pending signal (see sigpending())
tms_utime, tms_stime, tms_cutime, and tms_cstime (see times())
Resource limits
Controlling terminal
The initial thread of the new process shall inherit at least the following attributes from the calling thread:
Signal mask (see sigprocmask() and pthread_sigmask())
Pending signals (see sigpending())
All other process attributes defined in this volume of POSIX.1-2024 shall be inherited in the new process image from the old
process image. All other thread attributes defined in this volume of POSIX.1-2024 shall be inherited in the initial thread in the
new process image from the calling thread in the old process image. The inheritance of process or thread attributes not defined by
this volume of POSIX.1-2024 is implementation-defined.
A call to any exec function from a process with more than one thread shall result in all threads being terminated and the
new executable image being loaded and executed. No destructor functions or cleanup handlers shall be called.
Upon successful completion, the exec functions shall mark for update the last data access timestamp of the file. If an
exec function failed but was able to locate the process image file, whether the last data access timestamp is marked for
update is unspecified. Should the exec function succeed, the process image file shall be considered to have been opened with
open(). The corresponding close() shall be
considered to occur at a time after this open, but before process termination or successful completion of a subsequent call to one
of the exec functions, posix_spawn(), or posix_spawnp(). The argv[] and envp[] arrays of pointers and the strings
to which those arrays point shall not be modified by a call to one of the exec functions, except as a consequence of
replacing the process image.
The saved resource limits in the new process image are set to be a copy of the process' corresponding hard and soft limits.
RETURN VALUE
If one of the exec functions returns to the calling process image, an error has occurred; the return value shall be -1,
and errno shall be set to indicate the error.
ERRORS
The exec functions shall fail if:
[E2BIG]
The number of bytes used by the new process image's argument list and environment list is greater than the system-imposed limit
of {ARG_MAX} bytes.
[EACCES]
The new process image file is not a regular file and the implementation does not support execution of files of its type.
[EINVAL]
The new process image file has appropriate privileges and has a recognized executable binary format, but the system does not
support execution of a file with this format.
The exec functions, except for fexecve(), shall fail if:
[EACCES]
Search permission is denied for a directory listed in the new process image file's path prefix, or the new process image file
denies execution permission.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path or file argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of path or file does not name an existing file or path or file is an empty string.
[ENOTDIR]
A component of the new process image file's path prefix names an existing file that is neither a directory nor a symbolic link
to a directory, or the new process image file's pathname contains at least one non- character and ends with one or
more trailing  characters and the last pathname component names an existing file that is neither a directory nor a
symbolic link to a directory.
The exec functions, except for execlp() and execvp(), shall fail if:
[ENOEXEC]
The new process image file has the appropriate access permission but has an unrecognized format.
The fexecve() function shall fail if:
[EBADF]
The fd argument is not a valid file descriptor open for executing.
The exec functions may fail if:
[ENOMEM]
The new process image requires more memory than is allowed by the hardware or system-imposed memory management
constraints.
The exec functions, except for fexecve(), may fail if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path or file argument.
[ENAMETOOLONG]
The length of the path argument or the length of the pathname constructed from the file argument exceeds {PATH_MAX},
or pathname resolution of a symbolic link produced an intermediate result with a length that exceeds {PATH_MAX}.
[ETXTBSY]
The new process image file is a pure procedure (shared text) file that is currently open for writing by some process.
The following sections are informative.
EXAMPLES
Using execl()
The following example executes the ls command, specifying the pathname of the
executable (/bin/ls) and using arguments supplied directly to the command to produce single-column output.
#include
int ret;
...
ret = execl ("/bin/ls", "ls", "-1", (char *)0);
Using execle()
The following example is similar to Using execl(). In addition, it specifies the environment
for the new process image using the env argument.
#include
int ret;
char *env[] = { "HOME=/usr/home", "LOGNAME=home", (char *)0 };
...
ret = execle ("/bin/ls", "ls", "-l", (char *)0, env);
Using execlp()
The following example searches for the location of the ls command among the
directories specified by the PATH environment variable.
#include
int ret;
...
ret = execlp ("ls", "ls", "-l", (char *)0);
Using execv()
The following example passes arguments to the ls command in the cmd array.
#include
int ret;
char *cmd[] = { "ls", "-l", (char *)0 };
...
ret = execv ("/bin/ls", cmd);
Using execve()
The following example passes arguments to the ls command in the cmd array, and
specifies the environment for the new process image using the env argument.
#include
int ret;
char *cmd[] = { "ls", "-l", (char *)0 };
char *env[] = { "HOME=/usr/home", "LOGNAME=home", (char *)0 };
...
ret = execve ("/bin/ls", cmd, env);
Using execvp()
The following example searches for the location of the ls command among the
directories specified by the PATH environment variable, and passes arguments to the ls command in the cmd array.
#include
int ret;
char *cmd[] = { "ls", "-l", (char *)0 };
...
ret = execvp ("ls", cmd);
APPLICATION USAGE
As the state of conversion descriptors and message catalog descriptors in the new process image is undefined, conforming
applications should not rely on their use and should close them prior to calling one of the exec functions.
Applications that require other than the default POSIX locale as the global locale in the new process image should call setlocale() with the appropriate parameters.
When assigning a new value to the environ variable, applications should ensure that the environment to which it will
point contains at least the following:
Any implementation-defined variables required by the implementation to provide a conforming environment. See the _CS_V8_ENV
entry in  and confstr() for details.
A value for PATH which finds conforming versions of all standard utilities before any other versions.
The same constraint applies to the envp array passed to execle() or execve(), in order to ensure that the
new process image is invoked in a conforming environment.
Applications should not execute programs with file descriptor 0 not open for reading or with file descriptor 1 or 2 not open for
writing, as this might cause the executed program to misbehave. In order not to pass on these file descriptors to an executed
program, applications should not just close them but should reopen them on, for example, /dev/null. Some implementations may
reopen them automatically, but applications should not rely on this being done.
If an application wants to perform an integrity test of the file being executed before executing it, the file will need to be
opened with read permission to perform the integrity test.
Since execute permission is checked by fexecve(), the file description fd need not have been opened with the
O_EXEC flag. However, if the file to be executed denies read and write permission for the process preparing to do the exec,
the only way to provide the fd to fexecve() will be to use the O_EXEC flag when opening fd. In this case, the
application will not be able to perform an integrity test since it will not be able to read the contents of the file.
Note that when a file descriptor is opened with O_RDONLY, O_RDWR, or O_WRONLY mode, the file descriptor can be used to read,
read and write, or write the file, respectively, even if the mode of the file changes after the file was opened. Using the O_EXEC
open mode is different; fexecve() will ignore the mode that was used when the file descriptor was opened and the exec
will fail if the mode of the file associated with fd does not grant execute permission to the calling process at the time
fexecve() is called.
RATIONALE
Early proposals required that the value of argc passed to main() be "one or greater". This was driven by the
same requirement in drafts of the ISO C standard. In fact, historical implementations have passed a value of zero when no
arguments are supplied to the caller of the exec functions. This requirement was removed from the ISO C standard and
subsequently removed from this volume of POSIX.1-2024 as well. The wording, in particular the use of the word should,
requires a Strictly Conforming POSIX Application to pass at least one argument to the exec function, thus guaranteeing that
argc be one or greater when invoked by such an application. In fact, this is good practice, since many existing applications
reference argv[0] without first checking the value of argc.
The requirement on a Strictly Conforming POSIX Application also states that the value passed as the first argument be a filename
string associated with the process being started. Although some existing applications pass a pathname rather than a filename string
in some circumstances, a filename string is more generally useful, since the common usage of argv[0] is in printing
diagnostics. In some cases the filename passed is not the actual filename of the file; for example, many implementations of the
login utility use a convention of prefixing a  ('-') to the actual filename, which indicates to
the command interpreter being invoked that it is a "login shell".
Also, note that the test and [ utilities require specific strings for the
argv[0] argument to have deterministic behavior across all implementations.
Historically, there have been two ways that implementations can exec shell scripts.
One common historical implementation is that the execl(), execv(), execle(), and execve() functions
return an [ENOEXEC] error for any file not recognizable as executable, including a shell script. When the execlp() and
execvp() functions encounter such a file, they assume the file to be a shell script and invoke a known command interpreter
to interpret such files. This is now required by POSIX.1-2024. These implementations of execvp() and execlp() only
give the [ENOEXEC] error in the rare case of a problem with the command interpreter's executable file. Because of these
implementations, the [ENOEXEC] error is not mentioned for execlp() or execvp(), although implementations can still
give it.
Another way that some historical implementations handle shell scripts is by recognizing the first two bytes of the file as the
character string "#!" and using the remainder of the first line of the file as the name of the command interpreter to
execute.
One potential source of confusion noted by the standard developers is over how the contents of a process image file affect the
behavior of the exec family of functions. The following is a description of the actions taken:
If the process image file is a valid executable (in a format that is executable and valid and having appropriate privileges) for
this system, then the system executes the file.
If the process image file has appropriate privileges and is in a format that is executable but not valid for this system (such
as a recognized binary for another architecture), then this is an error and errno is set to [EINVAL] (see later RATIONALE on
[EINVAL]).
If the process image file has appropriate privileges but is not otherwise recognized:
If this is a call to execlp() or execvp(), then they invoke a command interpreter assuming that the process image
file is a shell script.
If this is not a call to execlp() or execvp(), then an error occurs and errno is set to [ENOEXEC].
Applications that do not require to access their arguments may use the form:
main(void)
as specified in the ISO C standard. However, the implementation will always provide the two arguments argc and
argv, even if they are not used.
Some implementations provide a third argument to main() called envp. This is defined as a pointer to the
environment. The ISO C standard specifies invoking main() with two arguments, so implementations are required to
support applications written this way. Since this volume of POSIX.1-2024 defines the global variable environ, which is also
provided by historical implementations and can be used anywhere that envp could be used, there is no functional need for the
envp argument. Applications should use the getenv() function rather than
accessing the environment directly via either envp or environ. Implementations are required to support the
two-argument calling sequence, but this does not prohibit an implementation from supporting envp as an optional third
argument.
This volume of POSIX.1-2024 specifies that signals set to SIG_IGN remain set to SIG_IGN, and that the new process image inherits
the signal mask of the thread that called exec in the old process image. This is consistent with historical implementations,
and it permits some useful functionality, such as the nohup command. However, it
should be noted that many existing applications wrongly assume that they start with certain signals set to the default action
and/or unblocked. In particular, applications written with a simpler signal model that does not include blocking of signals, such
as the one in the ISO C standard, may not behave properly if invoked with some signals blocked. Therefore, it is best not to
block or ignore signals across execs without explicit reason to do so, and especially not to block signals across
execs of arbitrary (not closely cooperating) programs.
The exec functions always save the value of the effective user ID and effective group ID of the process at the completion
of the exec, whether or not the set-user-ID or the set-group-ID bit of the process image file is set.
The statement about argv[] and envp[] being constants is included to make explicit to future writers of language
bindings that these objects are completely constant. Due to a limitation of the ISO C standard, it is not possible to state
that idea in standard C. Specifying two levels of const-qualification for the argv[] and envp[]
parameters for the exec functions may seem to be the natural choice, given that these functions do not modify either the
array of pointers or the characters to which the function points, but this would disallow existing correct code. Instead, only the
array of pointers is noted as constant. The table of assignment compatibility for dst=src derived from the ISO C
standard summarizes the compatibility:
dst:
char *[]
const char *[]
char *const[]
const char *const[]
src:
char *[]
VALID
—
VALID
—
const char *[]
—
VALID
—
VALID
char * const []
—
—
VALID
—
const char *const[]
—
—
—
VALID
Since all existing code has a source type matching the first row, the column that gives the most valid combinations
is the third column. The only other possibility is the fourth column, but using it would require a cast on the argv or
envp arguments. It is unfortunate that the fourth column cannot be used, because the declaration a non-expert would
naturally use would be that in the second row.
The ISO C standard and this volume of POSIX.1-2024 do not conflict on the use of environ, but some
historical implementations of environ may cause a conflict. As long as environ is treated in the same way as an entry
point (for example, fork()), it conforms to both standards. A library can contain
fork(), but if there is a user-provided fork(), that fork() is given precedence and no
problem ensues. The situation is similar for environ: the definition in this volume of POSIX.1-2024 is to be used if there
is no user-provided environ to take precedence. At least three implementations are known to exist that solve this
problem.
[E2BIG]
The limit {ARG_MAX} applies not just to the size of the argument list, but to the sum of that and the size of the environment
list.
[EFAULT]
Some historical systems return [EFAULT] rather than [ENOEXEC] when the new process image file is corrupted. They are
non-conforming.
[EINVAL]
This error condition was added to POSIX.1-2024 to allow an implementation to detect executable files generated for different
architectures, and indicate this situation to the application. Historical implementations of shells, execvp(), and
execlp() that encounter an [ENOEXEC] error will execute a shell on the assumption that the file is a shell script. This will
not produce the desired effect when the file is a valid executable for a different architecture. An implementation may now choose
to avoid this problem by returning [EINVAL] when a valid executable for a different architecture is encountered. Some historical
implementations return [EINVAL] to indicate that the path argument contains a character with the high order bit set. The
standard developers chose to deviate from historical practice for the following reasons:
The new utilization of [EINVAL] will provide some measure of utility to the user community.
Historical use of [EINVAL] is not acceptable in an internationalized operating environment.
[ENAMETOOLONG]
Since the file pathname may be constructed by taking elements in the PATH variable and putting them together with the
filename, the [ENAMETOOLONG] error condition could also be reached this way.
[ETXTBSY]
System V returns this error when the executable file is currently open for writing by some process. This volume of POSIX.1-2024
neither requires nor prohibits this behavior.
Other systems (such as System V) may return [EINTR] from exec. This is not addressed by this volume of
POSIX.1-2024, but implementations may have a window between the call to exec and the time that a signal could cause one of
the exec calls to return with [EINTR].
An explicit statement regarding the floating-point environment (as defined in the  header) was added to make it clear that the floating-point environment is set
to its default when a call to one of the exec functions succeeds. The requirements for inheritance or setting to the default
for other process and thread start-up functions is covered by more generic statements in their descriptions and can be summarized
as follows:
posix_spawn()
Set to default.
fork()
Inherit.
pthread_create()
Inherit.
The purpose of the fexecve() function is to enable executing a file which has been verified to be the
intended file. It is possible to actively check the file by reading from the file descriptor and be sure that the file is not
exchanged for another between the reading and the execution. Alternatively, a function like openat() can be used to open a file which has been found by reading the content of a
directory using readdir().
When execlp() or execvp() fall back to invoking sh because
of an [ENOEXEC] condition, the standard leaves the process name (what becomes argv[0] in the resulting sh process) unspecified. Existing implementations vary on whether they pass a variation of
"sh", or preserve the original arg0. There are existing implementations of sh that behave differently depending on the contents of argv[0], such that blindly passing
the original arg0 on to the fallback execution can fail to invoke a compliant shell environment. Because of the requirements
on how sh handles its command line arguments, the shell script will see $0
containing the pathname of the script being executed, regardless of the value of argv[0].
FUTURE DIRECTIONS
None.
SEE ALSO
alarm(), atexit(), chmod(), close(), confstr(), exit(), fcntl(), fork(), fstatvfs(), getenv(), getrlimit(), mknod(), mmap(), nice(), open(), posix_spawn(), pthread_atfork(), pthread_sigmask(), putenv(),
readdir(), semop(), setlocale(), shmat(), sigaction(), sigaltstack(),
sigpending(), system(),
times(), umask()
XBD 8. Environment Variables,
XCU test
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Realtime Extension and the POSIX Threads Extension.
Large File Summit extensions are added.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the DESCRIPTION, behavior is defined for when the process image file is not a valid executable.
In this version, _POSIX_SAVED_IDS is mandated, thus the effective user ID and effective group ID of the new
process image shall be saved (as the saved set-user-ID and the saved set-group-ID) for use by the setuid() function.
The [ELOOP] mandatory error condition is added.
A second [ENAMETOOLONG] is added as an optional error condition.
The [ETXTBSY] optional error condition is added.
The following changes were made to align with the IEEE P1003.1a draft standard:
The [EINVAL] mandatory error condition is added.
The [ELOOP] optional error condition is added.
The description of CPU-time clock semantics is added for alignment with IEEE Std 1003.1d-1999.
The DESCRIPTION is updated for alignment with IEEE Std 1003.1j-2000 by adding semantics for typed
memory.
The normative text is updated to avoid use of the term "must" for application requirements.
The description of tracing semantics is added for alignment with IEEE Std 1003.1q-2000.
IEEE PASC Interpretation 1003.1 #132 is applied.
The DESCRIPTION is updated to make it explicit that the floating-point environment in the new process image is set
to the default.
The DESCRIPTION and RATIONALE are updated to include clarifications of how the contents of a process image file
affect the behavior of the exec functions.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/15 is applied, adding a new paragraph to the
DESCRIPTION and text to the end of the APPLICATION USAGE section. This change addresses a security concern, where implementations
may want to reopen file descriptors 0, 1, and 2 for programs with the set-user-id or set-group-id file mode bits calling the
exec family of functions.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/24 is applied, applying changes to the DESCRIPTION,
addressing which attributes are inherited by threads, and behavioral requirements for threads attributes.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/25 is applied, updating text in the RATIONALE from
"the process signal mask be unchanged across an exec" to "the new process image inherits the signal mask of the thread
that called exec in the old process image".
Issue 7
Austin Group Interpretation 1003.1-2001 #047 is applied, adding the description of _CS_V7_ENV to the APPLICATION USAGE.
Austin Group Interpretation 1003.1-2001 #143 is applied.
The fexecve() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 2.
Functionality relating to the Asynchronous Input and Output, Memory Mapped Files, Threads, and Timers options is
moved to the Base.
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0095 [386], XSH/TC1-2008/0096 [167], XSH/TC1-2008/0097 [291],
XSH/TC1-2008/0098 [173], XSH/TC1-2008/0099 [296], XSH/TC1-2008/00100 [324], XSH/TC1-2008/00101 [296], XSH/TC1-2008/00102 [302],
XSH/TC1-2008/00103 [167], XSH/TC1-2008/00104 [173], and XSH/TC1-2008/00105 [291,429] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0097 [584], XSH/TC2-2008/0098 [898], and XSH/TC2-2008/0099
[734] are applied.
Issue 8
Austin Group Defects 51 and 1669 are applied, moving the getrlimit() and
setrlimit() functions from the XSI option to the Base.
Austin Group Defect 368 is applied, adding a requirement for unnamed semaphores to be destroyed.
Austin Group Defect 768 is applied, adding OFD-owned file locks.
Austin Group Defect 922 is applied, adding the secure_getenv()
function.
Austin Group Defect 1284 is applied, changing "checksum test" to "integrity test" in the APPLICATION USAGE
section.
Austin Group Defect 1318 is applied, adding FD_CLOFORK.
Austin Group Defect 1330 is applied, removing obsolescent interfaces and changing "_V7_" to "_V8_".
Austin Group Defect 1435 is applied, adding function lists to the descriptions of the path and file
arguments.
Austin Group Defect 1645 is applied, making it unspecified what string is passed to the shell in argv[0]
when executed by execlp() or execvp().
Austin Group Defect 1646 is applied, adding at_quick_exit() to
the list of registration functions whose registrations are not inherited across exec.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/setlocale.html =====
setlocale
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
setlocale — set program locale
SYNOPSIS
#include
char *setlocale(int category, const char *locale);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The setlocale() function selects the appropriate piece of the global locale, as specified by the category and
locale arguments, and can be used to change or query the entire global locale or portions thereof. The value LC_ALL for
category names the entire global locale; other values for category name only a part of the global locale:
LC_COLLATE
Affects the behavior of regular expressions and the collation functions.
LC_CTYPE
Affects the behavior of regular expressions, character classification, character conversion functions, and wide-character
functions.
LC_MESSAGES
[CX]
Affects the affirmative and negative response expressions returned by nl_langinfo() and the way message catalogs are located. It may also affect the behavior
of functions that return or write message strings.
LC_MONETARY
Affects the behavior of functions that handle monetary values.
LC_NUMERIC
Affects the behavior of functions that handle numeric values.
LC_TIME
Affects the behavior of the time conversion functions.
The locale argument is a pointer to a character string containing the required setting of category. The contents
of this string are implementation-defined. In addition, the following preset values of locale are defined for all settings
of category:
"POSIX"
[CX]
Specifies the minimal environment for C-language translation called the POSIX locale. The POSIX locale is the default global locale
at entry to main().
"C"
Equivalent to "POSIX".
""
Specifies an implementation-defined native environment. [CX]   The determination of the name of the new locale for the specified
category depends on the value of the associated environment variables, LC_* and LANG ; see XBD 7. Locale and 8. Environment
Variables.
A null pointer
Directs setlocale() to query the current global locale setting and return the name of the locale if category is
not LC_ALL, or a string which encodes the locale name(s) for all of the individual categories if category is LC_ALL.
[CX]
Setting all of the categories of the global locale is similar to successively setting each individual category of the global
locale, except that all error checking is done before any actions are performed. To set all the categories of the global locale,
setlocale() can be invoked as:
setlocale(LC_ALL, "");
In this case, setlocale() shall first verify that the values of all the environment variables it needs according to the
precedence rules (described in XBD 8. Environment Variables) indicate
supported locales. If the value of any of these environment variable searches yields a locale that is not supported (and non-null),
setlocale() shall return a null pointer and the global locale shall not be changed. If all environment variables name
supported locales, setlocale() shall proceed as if it had been called for each category, using the appropriate value from
the associated environment variable or from the implementation-defined default if there is no such value.
The global locale established using setlocale() shall only be used in threads for which no current locale has been set
using uselocale() or whose current locale has been set to the global locale using
uselocale(LC_GLOBAL_LOCALE).
The implementation shall behave as if no function defined in this volume of POSIX.1-2024 calls setlocale().
The setlocale() function need not be thread-safe; however, it shall avoid data races with all function calls that do not
affect and are not affected by the global locale.
RETURN VALUE
Upon successful completion, setlocale() shall return the string associated with the specified category for the new
locale. Otherwise, setlocale() shall return a null pointer and the global locale shall not be changed.
A null pointer for locale shall cause setlocale() to return a pointer to the string associated with the specified
category for the current global locale. The global locale shall not be changed.
The string returned by setlocale() is such that a subsequent call with that string and its associated category
shall restore that part of the global locale. The application shall not modify the string returned. [CX]   The returned
string pointer might be invalidated or   the string content
might be overwritten by a subsequent call to setlocale(). [CX]   The returned pointer might also be invalidated if the calling
thread is terminated.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The following code illustrates how a program can initialize the international environment for one language, while selectively
modifying the global locale such that regular expressions and string operations can be applied to text recorded in a different
language:
setlocale(LC_ALL, "De");
setlocale(LC_COLLATE, "Fr@dict");
Internationalized programs can initiate language operation according to environment variable settings (see XBD 8.2 Internationalization Variables) by calling setlocale() as
follows:
setlocale(LC_ALL, "");
Changing the setting of LC_MESSAGES has no effect on catalogs that have already been opened by calls to catopen().
In order to make use of different locale settings while multiple threads are running, applications should use uselocale() in preference to setlocale().
RATIONALE
References to the international environment or locale in the following text relate to the global locale for the process. This
can be overridden for individual threads using uselocale().
The ISO C standard defines a collection of functions to support internationalization. One of the most significant aspects
of these functions is a facility to set and query the international environment. The international environment is a
repository of information that affects the behavior of certain functionality, namely:
Character handling
Collating
Date/time formatting
Numeric editing
Monetary formatting
Messaging
The setlocale() function provides the application developer with the ability to set all or portions, called
categories, of the international environment. These categories correspond to the areas of functionality mentioned above. The
syntax for setlocale() is as follows:
char *setlocale(int category, const char *locale);
where category is the name of one of following categories, namely:
LC_COLLATE
LC_CTYPE
LC_MESSAGES
LC_MONETARY
LC_NUMERIC
LC_TIME
In addition, a special value called LC_ALL directs setlocale() to set all categories.
There are two primary uses of setlocale():
Querying the international environment to find out what it is set to
Setting the international environment, or locale, to a specific value
The behavior of setlocale() in these two areas is described below. Since it is difficult to describe the behavior in
words, examples are used to illustrate the behavior of specific uses.
To query the international environment, setlocale() is invoked with a specific category and the null pointer as the
locale. The null pointer is a special directive to setlocale() that tells it to query rather than set the international
environment. The following syntax is used to query the name of the international environment:
setlocale({LC_ALL, LC_COLLATE, LC_CTYPE, LC_MESSAGES, LC_MONETARY, \
LC_NUMERIC, LC_TIME},(char *) NULL);
The setlocale() function shall return the string corresponding to the current international environment. This value may
be used by a subsequent call to setlocale() to reset the international environment to this value. However, it should be
noted that the return value from setlocale() may be a pointer to a static area within the function and is not guaranteed to
remain unchanged (that is, it may be modified by a subsequent call to setlocale()). Therefore, if the purpose of calling
setlocale() is to save the value of the current international environment so it can be changed and reset later, the return
value should be copied to an array of char in the calling program.
There are three ways to set the international environment with setlocale():
setlocale(category, string)
This usage sets a specific category in the international environment to a specific value corresponding to the value of the
string. A specific example is provided below:
setlocale(LC_ALL, "fr_FR.ISO-8859-1");
In this example, all categories of the international environment are set to the locale corresponding to the string
"fr_FR.ISO-8859-1", or to the French language as spoken in France using the ISO/IEC 8859-1:1998 standard codeset.
If the string does not correspond to a valid locale, setlocale() shall return a null pointer and the international
environment is not changed. Otherwise, setlocale() shall return the name of the locale just set.
setlocale(category, "C")
The ISO C standard states that one locale must exist on all conforming implementations. The name of the locale is C and
corresponds to a minimal international environment needed to support the C programming language.
setlocale(category, "")
This sets a specific category to an implementation-defined default. This corresponds to the value of the environment
variables.
FUTURE DIRECTIONS
None.
SEE ALSO
catopen(), exec, fprintf(), fscanf(), getlocalename_l(),
isalnum(), isalpha(), isblank(), iscntrl(), isdigit(), isgraph(), islower(), isprint(), ispunct(), isspace(), isupper(), iswalnum(), iswalpha(), iswblank(), iswcntrl(), iswctype(), iswdigit(), iswgraph(), iswlower(), iswprint(), iswpunct(), iswspace(), iswupper(), iswxdigit(), isxdigit(), localeconv(), mblen(), mbstowcs(), mbtowc(), newlocale(), nl_langinfo(), perror(), psiginfo(), strcoll(), strerror(), strfmon(), strsignal(), strtod(), strxfrm(), tolower(), toupper(), towlower(), towupper(), uselocale(), wcscoll(), wcstod(), wcstombs(), wcsxfrm(), wctomb()
XBD 7. Locale, 8.
Environment Variables, ,
CHANGE HISTORY
First released in Issue 3.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Threads Extension.
Issue 6
Extensions beyond the ISO C standard are marked.
The normative text is updated to avoid use of the term "must" for application requirements.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/124 is applied, updating the DESCRIPTION to clarify the behavior
of:
setlocale(LC_ALL, "");
Issue 7
Functionality relating to the Threads option is moved to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0553 [302], XSH/TC1-2008/0554 [303], XSH/TC1-2008/0555 [302],
XSH/TC1-2008/0556 [302], XSH/TC1-2008/0557 [302], XSH/TC1-2008/0558 [302], XSH/TC1-2008/0559 [302], XSH/TC1-2008/0560 [288],
XSH/TC1-2008/0561 [302], XSH/TC1-2008/0562 [302], XSH/TC1-2008/0563 [302], XSH/TC1-2008/0564 [302], XSH/TC1-2008/0565 [302],
XSH/TC1-2008/0566 [302], XSH/TC1-2008/0567 [288], XSH/TC1-2008/0568 [288], and XSH/TC1-2008/0569 [303] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0321 [826], XSH/TC2-2008/0322 [826], and XSH/TC2-2008/0323 [596] are
applied.
Issue 8
Austin Group Defect 1220 is applied, adding getlocalename_l() to the SEE
ALSO section.
Austin Group Defect 1302 is applied, aligning this function with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/exp.html =====
exp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
exp, expf, expl — exponential function
SYNOPSIS
#include
double exp(double x);
float expf(float x);
long double expl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the base-e exponential of x.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the exponential value of x.
If the correct value would cause overflow, a range error shall occur and exp(), expf(), and expl() shall
return the value of the macro HUGE_VAL, HUGE_VALF, and HUGE_VALL, respectively.
If the correct value would cause underflow, [MXX]   and is not representable,  a range error may occur, and exp(), expf(), and expl() shall return [MXX]   0.0, or
(if the IEC 60559 Floating-Point option is not supported) an
implementation-defined value no greater in magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, 1 shall be returned.
If x is -Inf, +0 shall be returned.
If x is +Inf, x shall be returned.
[MXX]
If the correct value would cause underflow, and is representable, a range error may occur and the correct value shall be returned.
ERRORS
These functions shall fail if:
Range Error
The result overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
These functions may fail if:
Range Error
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
Computing the Density of the Standard Normal Distribution
This function shows an implementation for the density of the standard normal distribution using exp(). This example uses
the constant M_PI which is part of the XSI option.
#include
double
normal_density (double x)
{
return exp(-x*x/2) / sqrt (2*M_PI);
}
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), isnan(), log()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The expf() and expl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/26 is applied, adding the example to the EXAMPLES section.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0106 [68] and XSH/TC1-2008/0107 [68] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0101 [630] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fsync.html =====
fsync
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fsync — synchronize changes to a file
SYNOPSIS
[FSC]  #include
int fsync(int fildes);
DESCRIPTION
The fsync() function shall request that all data for the open file descriptor named by fildes is to be transferred
to the storage device associated with the file described by fildes. The nature of the transfer is implementation-defined.
The fsync() function shall not return until the system has completed that action or until an error is detected.
[SIO]
If _POSIX_SYNCHRONIZED_IO is defined, the fsync() function shall force all currently queued I/O operations associated with
the file indicated by file descriptor fildes to the synchronized I/O completion state. All I/O operations shall be completed
as defined for synchronized I/O file integrity completion.
RETURN VALUE
Upon successful completion, fsync() shall return 0. Otherwise, -1 shall be returned and errno set to indicate the
error. If the fsync() function fails, outstanding I/O operations are not guaranteed to have been completed.
ERRORS
The fsync() function shall fail if:
[EBADF]
The fildes argument is not a valid descriptor.
[EINTR]
The fsync() function was interrupted by a signal.
[EINVAL]
The fildes argument does not refer to a file on which this operation is possible.
[EIO]
An I/O error occurred while reading from or writing to the file system.
In the event that any of the queued I/O operations fail, fsync() shall return the error conditions defined for read() and write().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The fsync() function should be used by programs which require modifications to a file to be completed before continuing;
for example, a program which contains a simple transaction facility might use it to ensure that all modifications to a file or
files caused by a transaction are recorded.
An application that modifies a directory, for example, by creating a file in the directory, can invoke fsync() on the
directory to ensure that the directory's entries and file attributes are synchronized. For most applications, synchronizing the
directory's entries should not be necessary (see XBD 4.11 File System
Cache).
RATIONALE
The fsync() function is intended to force a physical write of data from the buffer cache, and to assure that after a
system crash or other failure that all data up to the time of the fsync() call is recorded on the disk. Since the concepts
of "buffer cache", "system crash", "physical write", and "non-volatile storage" are not defined here, the wording has to be
more abstract.
If _POSIX_SYNCHRONIZED_IO is not defined, the wording relies heavily on the conformance document to tell the user what can be
expected from the system. It is explicitly intended that a null implementation is permitted. This could be valid in the case where
the system cannot assure non-volatile storage under any circumstances or when the system is highly fault-tolerant and the
functionality is not required. In the middle ground between these extremes, fsync() might or might not actually cause data
to be written where it is safe from a power failure. The conformance document should identify at least that one configuration
exists (and how to obtain that configuration) where this can be assured for at least some files that the user can select to use for
critical data. It is not intended that an exhaustive list is required, but rather sufficient information is provided so that if
critical data needs to be saved, the user can determine how the system is to be configured to allow the data to be written to
non-volatile storage.
It is reasonable to assert that the key aspects of fsync() are unreasonable to test in a test suite. That does not make
the function any less valuable, just more difficult to test. A formal conformance test should probably force a system crash (power
shutdown) during the test for this condition, but it needs to be done in such a way that automated testing does not require this to
be done except when a formal record of the results is being made. It would also not be unreasonable to omit testing for
fsync(), allowing it to be treated as a quality-of-implementation issue.
FUTURE DIRECTIONS
None.
SEE ALSO
sync()
XBD
CHANGE HISTORY
First released in Issue 3.
Issue 5
Aligned with fsync() in the POSIX Realtime Extension. Specifically, the DESCRIPTION and RETURN VALUE sections are much
expanded, and the ERRORS section is updated to indicate that fsync() can return the error conditions defined for read() and write().
Issue 6
This function is marked as part of the File Synchronization option.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The [EINVAL] and [EIO] mandatory error conditions are added.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/44 is applied, applying an editorial rewording of the
DESCRIPTION. No change in meaning is intended.
Issue 8
Austin Group Defect 672 is applied, changing the APPLICATION USAGE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/posix_spawnattr_setschedpolicy.html =====
posix_spawnattr_getschedpolicy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
posix_spawnattr_getschedpolicy, posix_spawnattr_setschedpolicy — get and set the spawn-schedpolicy attribute of a spawn
attributes object (ADVANCED REALTIME)
SYNOPSIS
[SPN PS]  #include
#include
int posix_spawnattr_getschedpolicy(const posix_spawnattr_t
*restrict attr, int *restrict schedpolicy);
int posix_spawnattr_setschedpolicy(posix_spawnattr_t *attr,
int schedpolicy);
DESCRIPTION
The posix_spawnattr_getschedpolicy() function shall obtain the value of the spawn-schedpolicy attribute from the
attributes object referenced by attr.
The posix_spawnattr_setschedpolicy() function shall set the spawn-schedpolicy attribute in an initialized
attributes object referenced by attr.
The spawn-schedpolicy attribute represents the scheduling policy to be assigned to the new process image in a spawn
operation (if POSIX_SPAWN_SETSCHEDULER is set in the spawn-flags attribute). The default value of this attribute is
unspecified.
RETURN VALUE
Upon successful completion, posix_spawnattr_getschedpolicy() shall return zero and store the value of the
spawn-schedpolicy attribute of attr into the object referenced by the schedpolicy parameter; otherwise, an
error number shall be returned to indicate the error.
Upon successful completion, posix_spawnattr_setschedpolicy() shall return zero; otherwise, an error number shall be
returned to indicate the error.
ERRORS
These functions may fail if:
[EINVAL]
The value specified by attr is invalid.
The posix_spawnattr_setschedpolicy() function may fail if:
[EINVAL]
The value of the attribute being set is not valid.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
These functions are part of the Spawn and Process Scheduling options and need not be provided on all implementations.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
posix_spawn(), posix_spawnattr_destroy(), posix_spawnattr_getsigdefault(), posix_spawnattr_getflags(), posix_spawnattr_getpgroup(), posix_spawnattr_getschedparam(), posix_spawnattr_getsigmask()
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1d-1999.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ftell.html =====
ftell
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ftell, ftello — return a file offset in a stream
SYNOPSIS
#include
long ftell(FILE *stream);
[CX]  off_t ftello(FILE *stream);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The ftell() function shall obtain the current value of the file-position indicator for the stream pointed to by
stream.
The ftell() function shall not change the setting of errno if successful.
[CX]  The
ftello() function shall be equivalent to ftell(), except that the return value is of type off_t and the
ftello() function may change the setting of errno if successful.
RETURN VALUE
Upon successful completion, ftell() [CX]   and ftello()   shall return the current value of the file-position indicator for the stream measured in bytes
from the beginning of the file, [CX]   except in the case of streams opened with open_wmemstream() for which the position shall be measured in wide characters.
Otherwise, ftell() and ftello() shall return -1, and set errno to indicate the error.
ERRORS
The ftell() [CX]   and ftello()  functions
shall fail if:
[EBADF]
[CX]
The file descriptor underlying stream is not an open file descriptor.
[EOVERFLOW]
[CX]
For ftell(), the current file offset cannot be represented correctly in an object of type long.
[EOVERFLOW]
[CX]
For ftello(), the current file offset cannot be represented correctly in an object of type off_t.
[ESPIPE]
[CX]
The file descriptor underlying stream is associated with a pipe, FIFO, or socket.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
For all streams other than those opened by open_wmemstream(),
ftell() and fseek() operate on byte offsets. The behavior with open_wmemstream() streams is intentionally different—ftell() and fseek() operate on wide character
offsets. This is because those streams are unique in that the backing storage is not a multibyte representation but a wide
character array, and it is useful to be able to use the output of ftell() to index into that array.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fgetpos(), fopen(), fseek(), lseek(), open_memstream()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
Large File Summit extensions are added.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The ftello() function is added.
The [EOVERFLOW] error conditions are added.
An additional [ESPIPE] error condition is added for sockets.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0204 [105], XSH/TC1-2008/0205 [421], XSH/TC1-2008/0206 [122],
XSH/TC1-2008/0207 [122], and XSH/TC1-2008/0208 [14] are applied.
Issue 8
Austin Group Defect 1027 is applied, specifying that for streams opened with open_wmemstream() the position is measured in wide characters, not bytes.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/copysignf.html =====
copysign
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
copysign, copysignf, copysignl — number manipulation function
SYNOPSIS
#include
double copysign(double x, double y);
float copysignf(float x, float y);
long double copysignl(long double x, long double y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall produce a value with the magnitude of x and the sign of y. On implementations that represent
a signed zero but do not treat negative zero consistently in arithmetic operations, these functions regard the sign of zero as
positive.
RETURN VALUE
Upon successful completion, these functions shall return a value with the magnitude of x and the sign of y.
[MX]  The
returned value shall be exact and shall be independent of the current rounding direction mode.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
signbit()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ilogbf.html =====
ilogb
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ilogb, ilogbf, ilogbl — return an unbiased exponent
SYNOPSIS
#include
int ilogb(double x);
int ilogbf(float x);
int ilogbl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall return the exponent part of their argument x. Formally, the return value is the integral part of
\(\log _r|x|\) as a signed integral value, for non-zero x, where r is the radix of the machine's floating-point
arithmetic, which is the value of FLT_RADIX defined in .
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the exponent part of x as a signed integer value. They are
equivalent to calling the corresponding logb() function and casting the returned value
to type int.
[MX]
When the correct result is representable in the range of the return type, the returned value shall be exact and shall be
independent of the current rounding direction mode.
If x is 0, the value FP_ILOGB0 shall be returned. [XSI|MX]   On XSI-conformant systems and on systems that support the IEC
60559 Floating-Point option, a domain error shall occur;
otherwise, a
[CX]  domain
error may occur.
If x is ±Inf, the value {INT_MAX} shall be returned. [XSI|MX]
On XSI-conformant systems and on systems that support the
IEC 60559 Floating-Point option, a domain error shall occur;
otherwise, a [CX]   domain   error may occur.
If x is a NaN, the value FP_ILOGBNAN shall be returned. [XSI|MX]
On XSI-conformant systems and on systems that support the
IEC 60559 Floating-Point option, a domain error shall occur;
otherwise, a [CX]   domain   error may occur.
If the correct value is greater than {INT_MAX} or less than {INT_MIN}, an unspecified value shall be returned. [XSI]  On XSI-conformant
systems, a domain error shall occur and {INT_MAX} or {INT_MIN}, respectively, shall be returned;
[MX]  if the IEC 60559 Floating-Point option is supported, a domain error
shall occur;   otherwise, a domain error or range error may
occur.
ERRORS
These functions shall fail if:
Domain Error
[XSI|MX]  The correct value is not representable as an integer.
The x argument is zero, NaN, or ±Inf.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If
the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall
be raised.
These functions may fail if:
Domain Error
The x argument is zero, NaN, or ±Inf.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If
the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall
be raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are
independent of each other, but at least one of them must be non-zero.
RATIONALE
The errors come from taking the expected floating-point value and converting it to int, which is an invalid operation in
IEEE Std 754-1985 (since overflow, infinity, and NaN are not representable in a type int), so should be a domain
error.
There are no known implementations that overflow. For overflow to happen, {INT_MAX} must be less than
LDBL_MAX_EXP*log2(FLT_RADIX) or {INT_MIN} must be greater than LDBL_MIN_EXP*log2(FLT_RADIX) if subnormals are not
supported, or {INT_MIN} must be greater than (LDBL_MIN_EXP-LDBL_MANT_DIG)*log2(FLT_RADIX) if subnormals are supported.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept, fetestexcept, logb, scalbln
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The ilogb() function is no longer marked as an extension.
The ilogbf() and ilogbl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The RETURN VALUE section is revised for alignment with the ISO/IEC 9899:1999 standard.
Functionality relating to the XSI option is marked.
Issue 7
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #48 (SD5-XSH-ERN-71), #49, and #79 (SD5-XSH-ERN-72) are applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/va_end.html =====
va_arg
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
va_arg, va_copy, va_end, va_start — handle variable argument list
SYNOPSIS
#include
type va_arg(va_list ap, type);
void va_copy(va_list dest, va_list src);
void va_end(va_list ap);
void va_start(va_list ap, argN);
DESCRIPTION
Refer to XBD
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcsftime.html =====
wcsftime
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcsftime — convert date and time to a wide-character string
SYNOPSIS
#include
size_t wcsftime(wchar_t *restrict wcs, size_t maxsize,
const wchar_t *restrict format, const struct tm *restrict
timeptr);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The wcsftime() function shall be equivalent to the strftime() function,
except that:
The argument wcs points to the initial element of an array of wide characters into which the generated output is to be
placed.
The argument maxsize indicates the maximum number of wide characters to be placed in the output array.
The argument format is a wide-character string and the conversion specifications are replaced by corresponding sequences
of wide characters. It is unspecified whether an encoding error occurs if the format string contains wchar_t values that do
not correspond to members of the character set of the current locale.
[CX]
Field widths specify the number of wide characters instead of the number of bytes.
The return value indicates the number of wide characters placed in the output array.
If copying takes place between objects that overlap, the behavior is undefined.
RETURN VALUE
If the total number of resulting wide-character codes including the terminating null wide-character code is no more than
maxsize, wcsftime() shall return the number of wide-character codes placed into the array pointed to by wcs,
not including the terminating null wide-character code. Otherwise, zero is returned and the contents of the array are
unspecified.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
strftime()
XBD
CHANGE HISTORY
First released in Issue 4.
Issue 5
Moved from ENHANCED I18N to BASE and the [ENOSYS] error is removed.
Aligned with ISO/IEC 9899:1990/Amendment 1:1995 (E). Specifically, the type of the format argument is changed from
const char * to const wchar_t *.
Issue 6
The wcsftime() prototype is updated for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0388 [73] and XSH/TC2-2008/0389 [740] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_spin_init.html =====
pthread_spin_destroy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_spin_destroy, pthread_spin_init — destroy or initialize a spin lock object
SYNOPSIS
#include
int pthread_spin_destroy(pthread_spinlock_t *lock);
int pthread_spin_init(pthread_spinlock_t *lock, int pshared);
DESCRIPTION
The pthread_spin_destroy() function shall destroy the spin lock referenced by lock and release any resources used
by the lock. The effect of subsequent use of the lock is undefined until the lock is reinitialized by another call to
pthread_spin_init(). The results are undefined if pthread_spin_destroy() is called when a thread holds the lock, or
if this function is called with an uninitialized thread spin lock.
The pthread_spin_init() function shall allocate any resources required to use the spin lock referenced by lock and
initialize the lock to an unlocked state.
[TSH]
If the Thread Process-Shared Synchronization option is supported and the value of pshared is PTHREAD_PROCESS_SHARED, the
implementation shall permit the spin lock to be operated upon by any thread that has access to the memory where the spin lock is
allocated, even if it is allocated in memory that is shared by multiple processes.
See 2.9.9 Synchronization Object Copies and Alternative Mappings
for further requirements.
The results are undefined if pthread_spin_init() is called specifying an already initialized spin lock. The results are
undefined if a spin lock is used without first being initialized.
If the pthread_spin_init() function fails, the lock is not initialized and the contents of lock are undefined.
Only the object referenced by lock may be used for performing synchronization.
The result of referring to copies of that object in calls to pthread_spin_destroy(), pthread_spin_lock(), pthread_spin_trylock(), or pthread_spin_unlock() is undefined.
RETURN VALUE
Upon successful completion, these functions shall return zero; otherwise, an error number shall be returned to indicate the
error.
ERRORS
The pthread_spin_init() function shall fail if:
[EAGAIN]
The system lacks the necessary resources to initialize another spin lock.
[ENOMEM]
Insufficient memory exists to initialize the lock.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
If an implementation detects that the value specified by the lock argument to pthread_spin_destroy() does not
refer to an initialized spin lock object, it is recommended that the function should fail and report an [EINVAL] error.
If an implementation detects that the value specified by the lock argument to pthread_spin_destroy() or
pthread_spin_init() refers to a locked spin lock object, or detects that the value specified by the lock argument to
pthread_spin_init() refers to an already initialized spin lock object, it is recommended that the function should fail and
report an [EBUSY] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_spin_lock(), pthread_spin_unlock()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1j-2000.
In the SYNOPSIS, the inclusion of  is no longer
required.
Issue 7
The pthread_spin_destroy() and pthread_spin_init() functions are moved from the Spin Locks option to the Base.
The [EINVAL] error for an uninitialized spin lock object is removed; this condition results in undefined behavior.
The [EBUSY] error for a locked spin lock object or an already initialized spin lock object is removed; this condition results in
undefined behavior.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0297 [972] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atanhf.html =====
atanh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atanh, atanhf, atanhl — inverse hyperbolic tangent functions
SYNOPSIS
#include
double atanh(double x);
float atanhf(float x);
long double atanhl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the inverse hyperbolic tangent of their argument x.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the inverse hyperbolic tangent of their argument.
If x is ±1, a pole error shall occur, and atanh(), atanhf(), and atanhl() shall return the value of
the macro HUGE_VAL, HUGE_VALF, and HUGE_VALL, respectively, with the same sign as the correct value of the function.
For finite |x|>1, a domain error shall occur, and [MX]   either a NaN (if supported), or   an implementation-defined value shall be returned.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, x shall be returned.
If x is ±Inf, a domain error shall occur, and a NaN shall be returned.
[MXX]
If x is subnormal, x should be returned.
[MX]  If x is subnormal, a range error may occur and, if x is
not returned, atanh(), atanhf(), and atanhl() shall return an implementation-defined value no greater in
magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
ERRORS
These functions shall fail if:
Domain Error
The x argument is finite and not in the range [-1,1], [MX]   or is ±Inf.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
Pole Error
The x argument is ±1.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the divide-by-zero floating-point exception shall
be raised.
These functions may fail if:
Range Error
[MX]
The value of x is subnormal.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), tanh()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The atanh() function is no longer marked as an extension.
The atanhf() and atanhl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0039 [320] and XSH/TC1-2008/0040 [680] are applied.
Issue 8
Austin Group Defect 1382 is applied, rearranging the text describing the behavior when x is subnormal to avoid the need
for two shading changes.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/posix_spawnattr_getpgroup.html =====
posix_spawnattr_getpgroup
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
posix_spawnattr_getpgroup, posix_spawnattr_setpgroup — get and set the spawn-pgroup attribute of a spawn attributes
object (ADVANCED REALTIME)
SYNOPSIS
[SPN]  #include
int posix_spawnattr_getpgroup(const posix_spawnattr_t *restrict attr,
pid_t *restrict pgroup);
int posix_spawnattr_setpgroup(posix_spawnattr_t *attr, pid_t pgroup);
DESCRIPTION
The posix_spawnattr_getpgroup() function shall obtain the value of the spawn-pgroup attribute from the attributes
object referenced by attr.
The posix_spawnattr_setpgroup() function shall set the spawn-pgroup attribute in an initialized attributes object
referenced by attr.
The spawn-pgroup attribute represents the process group to be joined by the new process image in a spawn operation (if
POSIX_SPAWN_SETPGROUP is set in the spawn-flags attribute). The default value of this attribute shall be zero.
RETURN VALUE
Upon successful completion, posix_spawnattr_getpgroup() shall return zero and store the value of the spawn-pgroup
attribute of attr into the object referenced by the pgroup parameter; otherwise, an error number shall be returned to
indicate the error.
Upon successful completion, posix_spawnattr_setpgroup() shall return zero; otherwise, an error number shall be returned
to indicate the error.
ERRORS
These functions may fail if:
[EINVAL]
The value specified by attr is invalid.
The posix_spawnattr_setpgroup() function may fail if:
[EINVAL]
The value of the attribute being set is not valid.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
These functions are part of the Spawn option and need not be provided on all implementations.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
posix_spawn(), posix_spawnattr_destroy(), posix_spawnattr_getsigdefault(), posix_spawnattr_getflags(), posix_spawnattr_getschedparam(), posix_spawnattr_getschedpolicy(), posix_spawnattr_getsigmask()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1d-1999.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcsxfrm.html =====
wcsxfrm
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcsxfrm, wcsxfrm_l — wide-character string transformation
SYNOPSIS
#include
size_t wcsxfrm(wchar_t *restrict ws1, const wchar_t *restrict ws2,
size_t n);
[CX]  size_t wcsxfrm_l(wchar_t *restrict ws1, const wchar_t *restrict
ws2,
size_t n, locale_t locale);
DESCRIPTION
For wcsxfrm(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The wcsxfrm() [CX]   and wcsxfrm_l()
functions shall transform the wide-character string pointed to by ws2 and place the resulting wide-character string
into the array pointed to by ws1. The transformation shall be such that if wcscmp() is applied to two transformed wide strings, it shall return a value greater than,
equal to, or less than 0, corresponding to the result of wcscoll() [CX]   and wcscoll_l()   applied
to the same two original wide-character strings, and the same LC_COLLATE category of the current locale [CX]   or the locale
object locale,   respectively. No more than n
wide-character codes shall be placed into the resulting array pointed to by ws1, including the terminating null
wide-character code. If n is 0, ws1 is permitted to be a null pointer. If copying takes place between objects that
overlap, the behavior is undefined.
[CX]  The
wcsxfrm() and wcsxfrm_l() functions shall not change the setting of errno if successful.
Since no return value is reserved to indicate an error, an application wishing to check for error situations should set
errno to 0, then call wcsxfrm() or wcsxfrm_l(), then check errno.
The behavior is undefined if the locale argument to wcsxfrm_l() is the special locale object LC_GLOBAL_LOCALE or
is not a valid locale object handle.
RETURN VALUE
The wcsxfrm() [CX]   and wcsxfrm_l()
functions shall return the length of the transformed wide-character string (not including the terminating null wide-character
code). If the value returned is n or more, the contents of the array pointed to by ws1 are unspecified.
[CX]  On
error, the wcsxfrm() and wcsxfrm_l() functions may set errno, but no return value is reserved to indicate an
error.
ERRORS
These functions may fail if:
[EINVAL]
[CX]
The wide-character string pointed to by ws2 contains wide-character codes outside the domain of the collating sequence.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The transformation function is such that two transformed wide-character strings can be ordered by wcscmp() as appropriate to collating sequence information in the current locale (category
LC_COLLATE ).
The fact that when n is 0 ws1 is permitted to be a null pointer is useful to determine the size of the ws1
array prior to making the transformation.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
wcscmp(), wcscoll()
XBD
CHANGE HISTORY
First released in Issue 4. Derived from the MSE working draft.
Issue 5
Moved from ENHANCED I18N to BASE and the [ENOSYS] error is removed.
The DESCRIPTION is updated to indicate that errno is not changed if the function is successful.
Issue 6
In earlier versions, this function was required to return -1 on error.
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the RETURN VALUE and ERRORS sections, the [EINVAL] optional error condition is added if no conversion could be performed.
The wcsxfrm() prototype is updated for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
The wcsxfrm_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0728 [302], XSH/TC1-2008/0729 [283], XSH/TC1-2008/0730 [283], and
XSH/TC1-2008/0731 [302] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/cnd_timedwait.html =====
cnd_timedwait
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cnd_timedwait, cnd_wait — wait on a condition
SYNOPSIS
#include
int cnd_timedwait(cnd_t * restrict cond, mtx_t * restrict mtx,
const struct timespec * restrict ts);
int cnd_wait(cnd_t *cond, mtx_t *mtx);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The cnd_timedwait() function shall atomically unlock the mutex pointed to by mtx and block until the condition
variable pointed to by cond is signaled by a call to cnd_signal() or to
cnd_broadcast(), or until after the TIME_UTC-based calendar time pointed to by
ts, or until it is unblocked due to an unspecified reason.
The cnd_wait() function shall atomically unlock the mutex pointed to by mtx and block until the condition variable
pointed to by cond is signaled by a call to cnd_signal() or to cnd_broadcast(), or until it is unblocked due to an unspecified reason.
[CX]
Atomically here means "atomically with respect to access by another thread to the mutex and then the condition variable". That
is, if another thread is able to acquire the mutex after the about-to-block thread has released it, then a subsequent call to
cnd_broadcast() or cnd_signal() in that thread shall behave as if it were issued after the about-to-block
thread has blocked.
When the calling thread becomes unblocked, these functions shall lock the mutex pointed to by mtx before they return. The
application shall ensure that the mutex pointed to by mtx is locked by the calling thread before it calls these
functions.
When using condition variables there is always a Boolean predicate involving shared variables associated with each condition
wait that is true if the thread should proceed. Spurious wakeups from the cnd_timedwait() and cnd_wait() functions
may occur. Since the return from cnd_timedwait() or cnd_wait() does not imply anything about the value of this
predicate, the predicate should be re-evaluated upon such return.
When a thread waits on a condition variable, having specified a particular mutex to either the cnd_timedwait() or the
cnd_wait() operation, a dynamic binding is formed between that mutex and condition variable that remains in effect as long
as at least one thread is blocked on the condition variable. During this time, the effect of an attempt by any thread to wait on
that condition variable using a different mutex is undefined. Once all waiting threads have been unblocked (as by the cnd_broadcast() operation), the next wait operation on that condition variable shall
form a new dynamic binding with the mutex specified by that wait operation. Even though the dynamic binding between condition
variable and mutex might be removed or replaced between the time a thread is unblocked from a wait on the condition variable and
the time that it returns to the caller or begins cancellation cleanup, the unblocked thread shall always re-acquire the mutex
specified in the condition wait operation call from which it is returning.
[CX]  A
condition wait (whether timed or not) is a cancellation point. When the cancelability type of a thread is set to
PTHREAD_CANCEL_DEFERRED, a side-effect of acting upon a cancellation request while in a condition wait is that the mutex is (in
effect) re-acquired before calling the first cancellation cleanup handler. The effect is as if the thread were unblocked, allowed
to execute up to the point of returning from the call to cnd_timedwait() or cnd_wait(), but at that point notices the
cancellation request and instead of returning to the caller of cnd_timedwait() or cnd_wait(), starts the thread
cancellation activities, which includes calling cancellation cleanup handlers.
A thread that has been unblocked because it has been canceled while blocked in a call to cnd_timedwait() or
cnd_wait() shall not consume any condition signal that may be directed concurrently at the condition variable if there are
other threads blocked on the condition variable.
When cnd_timedwait() times out, it shall nonetheless release and re-acquire the mutex referenced by mtx, and may
consume a condition signal directed concurrently at the condition variable.
[CX]
These functions shall not be affected if the calling thread executes a signal handler during the call, except that if a signal is
delivered to a thread waiting for a condition variable, upon return from the signal handler either the thread shall resume waiting
for the condition variable as if it was not interrupted, or it shall return thrd_success due to spurious wakeup.
The behavior is undefined if the value specified by the cond or mtx argument to these functions does not refer to
an initialized condition variable or an initialized mutex object, respectively.
RETURN VALUE
The cnd_timedwait() function shall return thrd_success upon success, or thrd_timedout if the time
specified in the call was reached without acquiring the requested resource, or thrd_error if the request could not be
honored.
The cnd_wait() function shall return thrd_success upon success or thrd_error if the request could not
be honored.
ERRORS
See RETURN VALUE.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
These functions are not affected by signal handlers (except as stated in the DESCRIPTION) for the reasons stated in XRAT
B.2.3 Error Numbers.
FUTURE DIRECTIONS
None.
SEE ALSO
cnd_broadcast(), cnd_destroy(), timespec_get()
XBD 4.15.2 Memory Synchronization,
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcsnlen.html =====
wcslen
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcslen, wcsnlen — get length of a fixed-sized wide-character string
SYNOPSIS
#include
size_t wcslen(const wchar_t *ws);
[CX]  size_t wcsnlen(const wchar_t *ws, size_t maxlen);
DESCRIPTION
For wcslen(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The wcslen() function shall compute the number of wide-character codes in the wide-character string to which ws
points, not including the terminating null wide-character code.
[CX]  The
wcsnlen() function shall compute the smaller of the number of wide characters in the array to which ws points, not
including any terminating null wide-character code, and the value of maxlen. The wcsnlen() function shall never
examine more than the first maxlen characters of the wide-character array pointed to by ws.
[CX]  The
wcslen() and wcsnlen() functions shall not change the setting of errno on valid input.
RETURN VALUE
The wcslen() function shall return the length of ws.
[CX]  The
wcsnlen() function shall return the number of wide characters preceding the first null wide-character code in the array to
which ws points, if ws contains a null wide-character code within the first maxlen wide characters; otherwise,
it shall return maxlen.
No return values are reserved to indicate an error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
strlen(), wcslcat()
XBD
CHANGE HISTORY
First released in Issue 4. Derived from the MSE working draft.
Issue 7
The wcsnlen() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 1.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0390 [560] is applied.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that wcslen() and wcsnlen() do not change the setting of
errno on valid input.
Austin Group Defect 986 is applied, adding wcslcat() to the SEE ALSO section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/exp2.html =====
exp2
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
exp2, exp2f, exp2l — exponential base 2 functions
SYNOPSIS
#include
double exp2(double x);
float exp2f(float x);
long double exp2l(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the base-2 exponential of x.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return 2x.
If the correct value would cause overflow, a range error shall occur and exp2(), exp2f(), and exp2l() shall
return the value of the macro HUGE_VAL, HUGE_VALF, and HUGE_VALL, respectively.
If the correct value would cause underflow, [MXX]   and is not representable,   a range error may occur, and exp2(), exp2f(), and exp2l() shall return
[MXX]
0.0, or   (if the IEC 60559 Floating-Point option is not
supported) an implementation-defined value no greater in magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, 1 shall be returned.
If x is -Inf, +0 shall be returned.
If x is +Inf, x shall be returned.
[MXX]
If the correct value would cause underflow, and is representable, a range error may occur and the correct value shall be returned.
ERRORS
These functions shall fail if:
Range Error
The result overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
These functions may fail if:
Range Error
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
exp(), feclearexcept(),
fetestexcept(), isnan(),
log()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0108 [68] and XSH/TC1-2008/0109 [68] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0102 [630] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/timezone.html =====
tzset
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
daylight, timezone, tzname, tzset — set timezone conversion information
SYNOPSIS
#include
[XSI]  extern int daylight;
extern long timezone;
[CX]  extern char *tzname[2];
void tzset(void);
DESCRIPTION
The tzset() function shall use the value of the environment variable TZ to set time conversion information used by
ctime(), localtime(), mktime(), and strftime(). If TZ is
absent from the environment, implementation-defined default timezone information shall be used.
The tzset() function shall set the external variable tzname as follows:
tzname[0] = "std";
tzname[1] = "dst";
where std and dst are as described in XBD 8. Environment
Variables.
[XSI]
The tzset() function also shall set the external variable daylight to 0 if Daylight Saving Time conversions should
never be applied for the timezone in use; otherwise, non-zero. The external variable timezone shall be set to the
difference, in seconds, between Coordinated Universal Time (UTC) and local standard time.
If a thread accesses tzname, [XSI]  daylight, or timezone   directly while another thread is in a call to tzset(), or to any function that is
required or allowed to set timezone information as if by calling tzset(), the behavior is undefined.
RETURN VALUE
The tzset() function shall not return a value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
Example TZ variables and their timezone differences are given in the table below:
TZ
timezone
EST5EDT
5*60*60
GMT0
0*60*60
JST-9
-9*60*60
MET-1MEST
-1*60*60
MST7MDT
7*60*60
PST8PDT
8*60*60
APPLICATION USAGE
Since the ctime(), localtime(),
mktime(), strftime(), and strftime_l() functions are required to set timezone information as if by calling
tzset(), there is no need for an explicit tzset() call before using these functions. However, portable applications
should call tzset() explicitly before using localtime_r() because setting
timezone information is optional for that function.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
ctime(), localtime(), mktime(), strftime()
XBD 8. Environment Variables,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The example is corrected.
Issue 7
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0377 [880] is applied.
Issue 8
Austin Group Defect 1253 is applied, changing "Daylight Savings" to "Daylight Saving".
Austin Group Defect 1410 is applied, removing the ctime_r() function.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/isprint_l.html =====
isprint
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
isprint, isprint_l — test for a printable character
SYNOPSIS
#include
int isprint(int c);
[CX]  int isprint_l(int c, locale_t locale);
DESCRIPTION
For isprint(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The isprint() [CX]   and isprint_l()
functions shall test whether c is a character of class print in the current locale, [CX]   or in the
locale represented by locale,  respectively; see XBD 7. Locale.
The c argument is an int, the value of which the application shall ensure is a character representable as an
unsigned char or equal to the value of the macro EOF. If the argument has any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to isprint_l() is the special locale object LC_GLOBAL_LOCALE or is not a
valid locale object handle.
RETURN VALUE
The isprint() [CX]   and isprint_l()
functions shall return non-zero if c is a printable character; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
isalnum(), isalpha(), isblank(), iscntrl(), isdigit(), isgraph(), islower(), ispunct(), isspace(), isupper(), isxdigit(), setlocale(), uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The isprint_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0297 [302], XSH/TC1-2008/0298 [283], and XSH/TC1-2008/0299 [283] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/openlog.html =====
closelog
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
closelog, openlog, setlogmask, syslog — control system log
SYNOPSIS
[XSI]  #include
void closelog(void);
void openlog(const char *ident, int logopt, int facility);
int setlogmask(int maskpri);
void syslog(int priority, const char *message, ... /* arguments */);
DESCRIPTION
The syslog() function shall send a message to an implementation-defined logging facility, which may log it in an
implementation-defined system log, write it to the system console, forward it to a list of users, or forward it to the logging
facility on another host over the network. The logged message shall include a message header and a message body. The message header
contains at least a timestamp and a tag string.
The message body is generated from the message and following arguments in the same manner as if these were arguments to
printf(), except that the additional conversion specification %m shall be
recognized; it shall convert no arguments, shall cause the output of the error message string associated with the value of
errno on entry to syslog(), and may be mixed with argument specifications of the "%n$" form.
If a complete conversion specification with the m conversion specifier character is not just %m, the behavior is
undefined. A trailing  may be added if needed.
Values of the priority argument are formed by OR'ing together a severity-level value and an optional facility value. If
no facility value is specified, the current default facility value is used.
Possible values of severity level include:
LOG_EMERG
A panic condition.
LOG_ALERT
A condition that should be corrected immediately, such as a corrupted system database.
LOG_CRIT
Critical conditions, such as hard device errors.
LOG_ERR
Errors.
LOG_WARNING
Warning messages.
LOG_NOTICE
Conditions that are not error conditions, but that may require special handling.
LOG_INFO
Informational messages.
LOG_DEBUG
Messages that contain information normally of use only when debugging a program.
The facility indicates the application or system component generating the message. Possible facility values include:
LOG_USER
Messages generated by arbitrary processes. This is the default facility identifier if none is specified.
LOG_LOCAL0
Reserved for local use.
LOG_LOCAL1
Reserved for local use.
LOG_LOCAL2
Reserved for local use.
LOG_LOCAL3
Reserved for local use.
LOG_LOCAL4
Reserved for local use.
LOG_LOCAL5
Reserved for local use.
LOG_LOCAL6
Reserved for local use.
LOG_LOCAL7
Reserved for local use.
The openlog() function shall set process attributes that affect subsequent calls to syslog(). The ident
argument is a a pointer to a null-terminated identifier that shall be prepended (without the null terminator) to every message. The
application shall ensure that the string pointed to by ident remains valid during the syslog() calls that will
prepend this identifier; however, it is unspecified whether changes made to the string will change the identifier prepended by
later syslog() calls. The logopt argument indicates logging options. Values for logopt are constructed by a
bitwise-inclusive OR of zero or more of the following:
LOG_PID
Log the process ID with each message. This is useful for identifying specific processes.
LOG_CONS
Write messages to the system console if they cannot be sent to the logging facility. The syslog() function ensures that
the process does not acquire the console as a controlling terminal in the process of writing the message.
LOG_NDELAY
Open the connection to the logging facility immediately. Normally the open is delayed until the first message is logged. This
is useful for programs that need to manage the order in which file descriptors are allocated.
LOG_ODELAY
Delay open until syslog() is called.
LOG_NOWAIT
Do not wait for child processes that may have been created during the course of logging the message. This option should be used
by processes that enable notification of child termination using SIGCHLD, since syslog() may otherwise block waiting for a
child whose exit status has already been collected.
The facility argument encodes a default facility to be assigned to all messages that do not have an explicit facility
already encoded. The initial default facility is LOG_USER.
The openlog() and syslog() functions may allocate a file descriptor. It is not necessary to call openlog()
prior to calling syslog(). If a file descriptor is allocated, the FD_CLOEXEC flag shall be set; see .
The closelog() function shall close any open file descriptors allocated by previous calls to openlog() or
syslog().
The setlogmask() function shall set the log priority mask for the current process to maskpri and return the
previous mask. If the maskpri argument is 0, the current log mask is not modified. Calls by the current process to
syslog() with a priority not set in maskpri shall be rejected. The default log mask allows all priorities to be
logged. A call to openlog() is not required prior to calling setlogmask().
The LOG_MASK(pri) and LOG_UPTO(pri) macros can be used to ensure a value or range of severity levels is properly
encoded for the setlogmask() maskpri argument in a portable manner. The masks produced by these macros can be OR'ed
or AND'ed with other priority masks (for example,
LOG_UPTO(LOG_WARNING) | LOG_MASK(LOG_DEBUG)
and
LOG_UPTO(LOG_DEBUG) & ~((LOG_MASK(LOG_NOTICE) | LOG_MASK(LOG_INFO))
would produce the same priority mask).
Symbolic constants for use as values of the logopt, facility, priority, and maskpri arguments are
defined in the  header.
RETURN VALUE
The setlogmask() function shall return the previous log priority mask. The closelog(), openlog(), and
syslog() functions shall not return a value.
ERRORS
The openlog() and syslog() functions may fail if:
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum allowable number of files is currently open in the system.
The following sections are informative.
EXAMPLES
Using openlog()
The following example causes subsequent calls to syslog() to log the process ID with each message, and to write messages
to the system console if they cannot be sent to the logging facility.
#include
char *ident = "Process demo";
int logopt = LOG_PID | LOG_CONS;
int facility = LOG_USER;
...
openlog(ident, logopt, facility);
Using setlogmask()
The following example causes subsequent calls to syslog() to accept error messages, and to reject all other messages.
#include
int result;
int mask = LOG_MASK (LOG_ERR);
...
result = setlogmask(mask);
Using syslog
The following example sends the message "This is a message" to the default logging facility, marking the message as an
error message generated by random processes.
#include
char *message = "This is a message";
int priority = LOG_ERR | LOG_USER;
...
syslog(priority, message);
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
fprintf()
XBD ,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/13 is applied, correcting the EXAMPLES section.
Issue 8
Austin Group Defect 368 is applied, adding a requirement for FD_CLOEXEC to be set if a file descriptor is allocated, and adding
the [EMFILE] and [ENFILE] errors.
Austin Group Defect 1033 is applied, adding the LOG_UPTO macro.
Austin Group Defect 1244 is applied, clarifying the handling of the ident argument.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/localtime.html =====
localtime
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
localtime, localtime_r — convert a time value to a broken-down local time
SYNOPSIS
#include
struct tm *localtime(const time_t *timer);
[CX]  struct tm *localtime_r(const time_t *restrict timer,
struct tm *restrict result);
DESCRIPTION
For localtime(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The localtime() function shall convert the time in seconds since the Epoch pointed to by timer into a broken-down
time, expressed as a local time. The function corrects for the timezone and any seasonal time adjustments. [CX]   Local timezone
information shall be set as though localtime() calls tzset().
The relationship between a time in seconds since the Epoch used as an argument to localtime() and the tm structure
(defined in the  header) is that the result shall be as specified in the
expression given in the definition of seconds since the Epoch (see XBD 4.19
Seconds Since the Epoch) corrected for timezone and any seasonal time adjustments, where the names in the structure and in
the expression correspond.
The same relationship shall apply for localtime_r().
The localtime() function need not be thread-safe; however, localtime() shall avoid data races with all functions
other than itself, asctime(), ctime(),
and gmtime().
The asctime(), ctime(), gmtime(), and localtime() functions shall return values in one of two static objects:
a broken-down time structure and an array of type char. Execution of any of the functions that return a pointer to one of
these object types may overwrite the information in any object of the same type pointed to by the value returned from any previous
call to any of them.
[CX]  The
localtime_r() function shall convert the time in seconds since the Epoch pointed to by timer into a broken-down time
stored in the structure to which result points. The localtime_r() function shall also return a pointer to that same
structure.
Unlike localtime(), the localtime_r() function is not required to set tzname. If localtime_r() sets
tzname, it shall also set daylight and timezone. If localtime_r() does not set tzname, it shall
not set daylight and shall not set timezone. If the tm structure member tm_zone is accessed after the
value of TZ is subsequently modified, the behaviour is undefined.
RETURN VALUE
Upon successful completion, the localtime() function shall return a pointer to the broken-down time structure. If an
error is detected, localtime() shall return a null pointer [CX]
and set errno to indicate the error.
Upon successful completion, localtime_r() shall return a pointer to the structure pointed to by the argument
result. If an error is detected, localtime_r() shall return a null pointer and set errno to indicate the
error.
ERRORS
The localtime() [CX]   and localtime_r()
functions shall fail if:
[EOVERFLOW]
[CX]
The result cannot be represented.
The following sections are informative.
EXAMPLES
Getting the Local Date and Time
The following example uses the time() function to calculate the time elapsed, in
seconds, since January 1, 1970 0:00 UTC (the Epoch), localtime() to convert that value to a broken-down time, and asctime() to convert the broken-down time values into a printable string.
#include
#include
int main(void)
{
time_t result;
result = time(NULL);
printf("%s%ju secs since the Epoch\n",
asctime(localtime(&result)),
(uintmax_t)result);
return(0);
}
This example writes the current time to stdout in a form like this:
Wed Jun 26 10:32:15 1996
835810335 secs since the Epoch
Getting the Modification Time for a File
The following example prints the last data modification timestamp in the local timezone for a given file.
#include
#include
#include
int
print_file_time(const char *pathname)
{
struct stat statbuf;
struct tm *tm;
char timestr[BUFSIZ];
if(stat(pathname, &statbuf) == -1)
return -1;
if((tm = localtime(&statbuf.st_mtime)) == NULL)
return -1;
if(strftime(timestr, sizeof(timestr), "%Y-%m-%d %H:%M:%S", tm) == 0)
return -1;
printf("%s: %s.%09ld\n", pathname, timestr, statbuf.st_mtim.tv_nsec);
return 0;
}
Timing an Event
The following example gets the current time, converts it to a string using localtime() and asctime(), and prints it to standard output using fputs(). It then prints the number of minutes to an event being timed.
#include
#include
...
time_t now;
int minutes_to_event;
...
time(&now);
printf("The time is ");
fputs(asctime(localtime(&now)), stdout);
printf("There are still %d minutes to the event.\n",
minutes_to_event);
...
APPLICATION USAGE
The localtime_r() function is thread-safe and returns values in a user-supplied buffer instead of possibly using a static
data area that may be overwritten by each call.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
asctime(), clock(), ctime(), difftime(), futimens(), getdate(), gmtime(), mktime(), strftime(), strptime(), time(), tzset()
XBD 4.19 Seconds Since the Epoch,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
A note indicating that the localtime() function need not be reentrant is added to the DESCRIPTION.
The localtime_r() function is included for alignment with the POSIX Threads Extension.
Issue 6
The localtime_r() function is marked as part of the Thread-Safe Functions option.
Extensions beyond the ISO C standard are marked.
The APPLICATION USAGE section is updated to include a note on the thread-safe function and its avoidance of possibly using a
static data area.
The restrict keyword is added to the localtime_r() prototype for alignment with the ISO/IEC 9899:1999
standard.
Examples are added.
IEEE Std 1003.1-2001/Cor 1-2002, itemm XSH/TC1/D6/32 is applied, adding the [EOVERFLOW] error.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/55 is applied, updating the error handling for
localtime_r().
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/56 is applied, adding a requirement that if localtime_r()
does not set the tzname variable, it shall not set the daylight or timezone variables. On systems supporting
XSI, the daylight, timezone, and tzname variables should all be set to provide information for the same
timezone. This updates the description of localtime_r() to mention daylight and timezone as well as
tzname. The SEE ALSO section is updated.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
The localtime_r() function is moved from the Thread-Safe Functions option to the Base.
Changes are made to the EXAMPLES section related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0363 [291] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0201 [664] is applied.
Issue 8
Austin Group Defect 1125 is applied, changing "Local timezone information is used" to "Local timezone information shall be
set".
Austin Group Defect 1302 is applied, aligning the localtime() function with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1376 is applied, removing CX shading from some text derived from the ISO C standard and updating it to
match the ISO C standard.
Austin Group Defect 1533 is applied, adding tm_gmtoff and tm_zone to the tm structure.
Austin Group Defect 1570 is applied, removing extra spacing in "==".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/waitpid.html =====
wait
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wait, waitpid — wait for a child process to stop or terminate
SYNOPSIS
#include
pid_t wait(int *stat_loc);
pid_t waitpid(pid_t pid, int *stat_loc, int options);
DESCRIPTION
The wait() and waitpid() functions shall obtain status information (see 2.12 Status Information) pertaining to one of the caller's child processes. The
wait() function obtains status information for process termination from any child process. The waitpid() function
obtains status information for process termination, and optionally process stop and/or continue, from a specified subset of the
child processes.
The wait() function shall cause the calling thread to become blocked until status information generated by child process
termination is made available to the thread, or until delivery of a signal whose action is either to execute a signal-catching
function or to terminate the process, or an error occurs. If termination status information is available prior to the call to
wait(), return shall be immediate. If termination status information is available for two or more child processes, the order
in which their status is reported is unspecified.
As described in 2.12 Status Information, the wait() and
waitpid() functions consume the status information they obtain.
The behavior when multiple threads are blocked in wait(), waitid(), or
waitpid() is described in 2.12 Status Information.
The waitpid() function shall be equivalent to wait() if the pid argument is (pid_t)-1 and the
options argument is 0. Otherwise, its behavior shall be modified by the values of the pid and options
arguments.
The pid argument specifies a set of child processes for which status is requested. The waitpid() function
shall only return the status of a child process from this set:
If pid is equal to (pid_t)-1, status is requested for any child process. In this respect, waitpid()
is then equivalent to wait().
If pid is greater than 0, it specifies the process ID of a single child process for which status is requested.
If pid is 0, status is requested for any child process whose process group ID is equal to that of the calling
process.
If pid is less than (pid_t)-1, status is requested for any child process whose process group ID is equal to
the absolute value of pid.
The options argument is constructed from the bitwise-inclusive OR of zero or more of the following flags, defined in the
header:
WCONTINUED
[XSI]
The waitpid() function shall report the status of any continued child process specified by pid whose status has not
been reported since it continued from a job control stop.
WNOHANG
The waitpid() function shall not suspend execution of the calling thread if status is not immediately available
for one of the child processes specified by pid.
WUNTRACED
The status of any child processes specified by pid that are stopped, and whose status has not yet been reported since
they stopped, shall also be reported to the requesting process.
If wait() or waitpid() return because the status of a child process is available, these functions shall return a
value equal to the process ID of the child process. In this case, if the value of the argument stat_loc is not a null
pointer, information shall be stored in the location pointed to by stat_loc. The value stored at the location pointed to by
stat_loc shall be 0 if and only if the status returned is from a terminated child process that terminated by one of the
following means:
The process returned 0 from main().
The process called _exit() or exit()
with a status argument of 0.
The process was terminated because the last thread in the process terminated.
Regardless of its value, this information may be interpreted using the following macros, which are defined in  and evaluate to integral expressions; the stat_val argument is
the integer value pointed to by stat_loc.
WIFEXITED(stat_val)
Evaluates to a non-zero value if status was returned for a child process that terminated normally.
WEXITSTATUS(stat_val)
If the value of WIFEXITED(stat_val) is non-zero, this macro shall evaluate to the low-order 8 bits of the status
argument that the child process passed to _exit() or exit(), or the value the child process returned from main().
WIFSIGNALED(stat_val)
Evaluates to a non-zero value if status was returned for a child process that terminated due to the receipt of a signal that
was not caught (see ).
WCOREDUMP(stat_val)
If the value of WIFSIGNALED(stat_val) is non-zero, this macro shall evaluate to a non-zero value if the creation of a core
image of the terminated child was attempted.
WTERMSIG(stat_val)
If the value of WIFSIGNALED(stat_val) is non-zero, this macro shall evaluate to the number of the signal that caused the
termination of the child process.
WIFSTOPPED(stat_val)
Evaluates to a non-zero value if status was returned for a child process that stopped due to the receipt of a signal that
was not caught (see ).
WSTOPSIG(stat_val)
If the value of WIFSTOPPED(stat_val) is non-zero, this macro shall evaluate to the number of the signal that caused the
child process to stop.
WIFCONTINUED(stat_val)
[XSI]
Evaluates to a non-zero value if status was returned for a child process that has continued from a job control stop.
[SPN]
It is unspecified whether the status value returned by calls to wait() or waitpid() for processes created by
posix_spawn() or posix_spawnp() can indicate a WIFSTOPPED(stat_val) before subsequent calls to
wait() or waitpid() indicate WIFEXITED(stat_val) as the result of an error detected before the new process
image starts executing.
It is unspecified whether the status value returned by calls to wait() or waitpid() for processes created
by posix_spawn() or posix_spawnp() can indicate a WIFSIGNALED(stat_val) if a signal is sent to the
parent's process group after posix_spawn() or posix_spawnp() is called.
If the information pointed to by stat_loc was stored by a call to waitpid() that specified the WUNTRACED flag
[XSI]
and did not specify the WCONTINUED flag,   exactly one of
the macros WIFEXITED(*stat_loc), WIFSIGNALED(*stat_loc), and WIFSTOPPED(*stat_loc) shall evaluate to a
non-zero value.
[XSI]
If the information pointed to by stat_loc was stored by a call to waitpid() that specified the WUNTRACED and
WCONTINUED flags, exactly one of the macros WIFEXITED(*stat_loc), WIFSIGNALED(*stat_loc),
WIFSTOPPED(*stat_loc), and WIFCONTINUED(*stat_loc) shall evaluate to a non-zero value.
If the information pointed to by stat_loc was stored by a call to waitpid() that did not specify the WUNTRACED
[XSI]
or WCONTINUED   flags, or by a call to the wait()
function, exactly one of the macros WIFEXITED(*stat_loc) and WIFSIGNALED(*stat_loc) shall evaluate to a non-zero
value.
[XSI]
If the information pointed to by stat_loc was stored by a call to waitpid() that did not specify the WUNTRACED flag
and specified the WCONTINUED flag, exactly one of the macros WIFEXITED(*stat_loc), WIFSIGNALED(*stat_loc), and
WIFCONTINUED(*stat_loc) shall evaluate to a non-zero value.
If the implementation queues the SIGCHLD signal, then if wait() or waitpid() returns because the status of a child
process is available, any pending SIGCHLD signal associated with the process ID of the child process shall be discarded. Any other
pending SIGCHLD signals shall remain pending.
Otherwise, if SIGCHLD is blocked, if wait() or waitpid() return because the status of a child process is
available, any pending SIGCHLD signal shall be cleared unless the status of another child process is available.
For all other conditions, it is unspecified whether child status will be available when a SIGCHLD signal is
delivered.
There may be additional implementation-defined circumstances under which wait() or waitpid() report status.
This shall not occur unless the calling process or one of its child processes explicitly makes use of a non-standard extension. In
these cases the interpretation of the reported status is implementation-defined.
If a parent process terminates without waiting for all of its child processes to terminate, the remaining child processes shall
be assigned a new parent process ID corresponding to an implementation-defined system process.
RETURN VALUE
If wait() or waitpid() returns because the status of a child process is available, these functions shall return a
value equal to the process ID of the child process for which status is reported. If wait() or waitpid()
returns due to the delivery of a signal to the calling process, -1 shall be returned and errno set to [EINTR]. If
waitpid() was invoked with WNOHANG set in options, it has at least one child process specified by pid for
which status is not available, and status is not available for any process specified by pid, 0 is returned.
Otherwise, -1 shall be returned, and errno set to indicate the error.
ERRORS
The wait() function shall fail if:
[ECHILD]
The calling process has no existing unwaited-for child processes.
[EINTR]
The function was interrupted by a signal. The value of the location pointed to by stat_loc is undefined.
The waitpid() function shall fail if:
[ECHILD]
The process specified by pid does not exist or is not a child of the calling process, or the process group specified by
pid does not exist or does not have any member process that is a child of the calling process.
[EINTR]
The function was interrupted by a signal. The value of the location pointed to by stat_loc is undefined.
[EINVAL]
The options argument is not valid.
The following sections are informative.
EXAMPLES
Waiting for a Child Process and then Checking its Status
The following example demonstrates the use of waitpid(), fork(), and the
macros used to interpret the status value returned by waitpid() (and wait()). The code segment creates a child
process which does some unspecified work. Meanwhile the parent loops performing calls to waitpid() to monitor the status of
the child. The loop terminates when child termination is detected.
#include
#include
#include
#include
...
pid_t child_pid, wpid;
int status;
child_pid = fork();
if (child_pid == -1) {      /* fork() failed */
perror("fork");
exit(EXIT_FAILURE);
}
if (child_pid == 0) {       /* This is the child */
/* Child does some work and then terminates */
...
} else {                    /* This is the parent */
do {
wpid = waitpid(child_pid, &status, WUNTRACED
#ifdef WCONTINUED       /* Not all implementations support this */
| WCONTINUED
#endif
);
if (wpid == -1) {
perror("waitpid");
exit(EXIT_FAILURE);
}
if (WIFEXITED(status)) {
printf("child exited, status=%d\n", WEXITSTATUS(status));
} else if (WIFSIGNALED(status)) {
printf("child killed (signal %d)\n", WTERMSIG(status));
} else if (WIFSTOPPED(status)) {
printf("child stopped (signal %d)\n", WSTOPSIG(status));
#ifdef WIFCONTINUED     /* Not all implementations support this */
} else if (WIFCONTINUED(status)) {
printf("child continued\n");
#endif
} else {    /* Non-standard case -- may never happen */
printf("Unexpected status (0x%x)\n", status);
}
} while (!WIFEXITED(status) && !WIFSIGNALED(status));
}
Waiting for a Child Process in a Signal Handler for SIGCHLD
The following example demonstrates how to use waitpid() in a signal handler for SIGCHLD without passing -1 as the
pid argument. (See the APPLICATION USAGE section below for the reasons why passing a pid of -1 is not recommended.)
The method used here relies on the standard behavior of waitpid() when SIGCHLD is blocked. On historical non-conforming
systems, the status of some child processes might not be reported.
#include
#include
#include
#include
#include
#include
#define CHILDREN 10
static void
handle_sigchld(int signum, siginfo_t *sinfo, void *unused)
{
int sav_errno = errno;
int status;
/*
* Obtain status information for the child which
* caused the SIGCHLD signal and write its exit code
* to stdout.
*/
if (sinfo->si_code != CLD_EXITED)
{
static char msg[] = "wrong si_code\n";
write(2, msg, sizeof msg - 1);
}
else if (waitpid(sinfo->si_pid, &status, 0) == -1)
{
static char msg[] = "waitpid() failed\n";
write(2, msg, sizeof msg - 1);
}
else if (!WIFEXITED(status))
{
static char msg[] = "WIFEXITED was false\n";
write(2, msg, sizeof msg - 1);
}
else
{
int code = WEXITSTATUS(status);
char buf[2];
buf[0] = '0' + code;
buf[1] = '\n';
write(1, buf, 2);
}
errno = sav_errno;
}
int
main(void)
{
int i;
pid_t pid;
struct sigaction sa;
sa.sa_flags = SA_SIGINFO;
sa.sa_sigaction = handle_sigchld;
sigemptyset(&sa.sa_mask);
if (sigaction(SIGCHLD, &sa, NULL) == -1)
{
perror("sigaction");
exit(EXIT_FAILURE);
}
for (i = 0; i ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Threads Extension.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
The following changes were made to align with the IEEE P1003.1a draft standard:
The processing of the SIGCHLD signal and the [ECHILD] error is clarified.
The semantics of WIFSTOPPED(stat_val), WIFEXITED(stat_val), and WIFSIGNALED(stat_val) are defined with
respect to posix_spawn() or posix_spawnp() for alignment with IEEE Std 1003.1d-1999.
The DESCRIPTION is updated for alignment with the ISO/IEC 9899:1999 standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/145 is applied, adding the example to the EXAMPLES section.
Issue 7
SD5-XSH-ERN-202 is applied.
APPLICATION USAGE is added, recommending that the wait() function not be used.
An additional example for waitpid() is added.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0707 [421], XSH/TC1-2008/0708 [166], XSH/TC1-2008/0709 [166], and
XSH/TC1-2008/0710 [69] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0384 [690], XSH/TC2-2008/0385 [691], and XSH/TC2-2008/0386 [690] are
applied.
Issue 8
Austin Group Defect 1116 is applied, removing text related to the Realtime Signals Extension option that existed in earlier
versions of this standard.
Austin Group Defects 1141 and 1363 are applied, adding WCOREDUMP, changing the description of WIFSTOPPED, and changing the
RATIONALE section.
Austin Group Defect 1570 is applied, removing extra spacing in "==".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/iswprint.html =====
iswprint
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
iswprint, iswprint_l — test for a printable wide-character code
SYNOPSIS
#include
int iswprint(wint_t wc);
[CX]  int iswprint_l(wint_t wc, locale_t locale);
DESCRIPTION
For iswprint(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The iswprint() [CX]   and iswprint_l()
functions shall test whether wc is a wide-character code representing a character of class print in the current
locale, [CX]   or in the locale represented by locale,
respectively; see XBD 7. Locale.
The wc argument is a wint_t, the value of which the application shall ensure is a wide-character code
corresponding to a valid character in the locale used by the function, or equal to the value of the macro WEOF. If the argument has
any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to iswprint_l() is the special locale object LC_GLOBAL_LOCALE or is not
a valid locale object handle.
RETURN VALUE
The iswprint() [CX]   and iswprint_l()
functions shall return non-zero if wc is a printable wide-character code; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
iswalnum(), iswalpha(),
iswcntrl(), iswctype(),
iswdigit(), iswgraph(),
iswlower(), iswpunct(),
iswspace(), iswupper(),
iswxdigit(), setlocale(),
uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 4.
Issue 5
The following change has been made in this version for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E):
The SYNOPSIS has been changed to indicate that this function and associated data types are now made visible by inclusion of the
header rather than .
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The iswprint_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0332 [302], XSH/TC1-2008/0333 [283], and XSH/TC1-2008/0334 [283] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0189 [685] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/roundf.html =====
round
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
round, roundf, roundl — round to the nearest integer value in a floating-point format
SYNOPSIS
#include
double round(double x);
float roundf(float x);
long double roundl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall round their argument to the nearest integer value in floating-point format, rounding halfway cases away
from zero, regardless of the current rounding direction.
[MX]
These functions may raise the inexact floating-point exception for finite non-integer arguments.
RETURN VALUE
Upon successful completion, these functions shall return the rounded integer value. [MX]   The result
shall have the same sign as x.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0 or ±Inf, x shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The integral value returned by these functions need not be expressible as an intmax_t. The return value should be tested
before assigning it to an integer type to avoid the undefined results of an integer overflow.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0520 [346] is applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/realpath.html =====
realpath
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
realpath — resolve a pathname
SYNOPSIS
#include
char *realpath(const char *restrict file_name,
char *restrict resolved_name);
DESCRIPTION
The realpath() function shall derive, from the pathname pointed to by file_name, an absolute pathname that
resolves to the same directory entry, whose resolution does not involve '.', '..', or symbolic links. If
resolved_name is a null pointer, the generated pathname shall be stored as a null-terminated string in a buffer allocated as
if by a call to malloc(). Otherwise, if {PATH_MAX} is defined as a constant in the
header, then the generated pathname shall be stored as a
null-terminated string, up to a maximum of {PATH_MAX} bytes, in the buffer pointed to by resolved_name.
If resolved_name is not a null pointer and {PATH_MAX} is not defined as a constant in the  header, the behavior is undefined.
RETURN VALUE
Upon successful completion, realpath() shall return a pointer to the buffer containing the resolved name. Otherwise,
realpath() shall return a null pointer and set errno to indicate the error.
If the resolved_name argument is a null pointer, the pointer returned by realpath() can be passed to free().
If the resolved_name argument is not a null pointer and the realpath() function fails, the contents of the buffer
pointed to by resolved_name are undefined.
ERRORS
The realpath() function shall fail if:
[EACCES]
Search permission was denied for a component of the path prefix of file_name.
[EINVAL]
The file_name argument is a null pointer.
[EIO]
An error occurred while reading from the file system.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the file_name argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of file_name does not name an existing file or file_name points to an empty string.
[ENOTDIR]
A component of the path prefix names an existing file that is neither a directory nor a symbolic link to a directory, or the
file_name argument contains at least one non- character and ends with one or more trailing
characters and the last pathname component names an existing file that is neither a directory nor a symbolic link to a
directory.
The realpath() function may fail if:
[EACCES]
The file_name argument does not begin with a  and none of the symbolic links (if any) processed during
pathname resolution of file_name had contents that began with a , and either search permission was denied for
the current directory or read or search permission was denied for a directory above the current directory in the file
hierarchy.
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the file_name argument.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
[ENOMEM]
Insufficient storage space is available.
The following sections are informative.
EXAMPLES
Generating an Absolute Pathname
The following example generates an absolute pathname for the file identified by the symlinkpath argument. The generated
pathname is stored in the buffer pointed to by actualpath.
#include
...
char *symlinkpath = "/tmp/symlink/file";
char *actualpath;
actualpath = realpath(symlinkpath, NULL);
if (actualpath != NULL)
{
... use actualpath ...
free(actualpath);
}
else
{
... handle error ...
}
APPLICATION USAGE
For functions that allocate memory as if by malloc(), the application should
release such memory when it is no longer required by a call to free(). For
realpath(), this is the return value.
RATIONALE
Since realpath() has no length argument, if {PATH_MAX} is not defined as a constant in , applications have no way of determining how large a buffer they need to
allocate for it to be safe to pass to realpath(). A {PATH_MAX} value obtained from a prior pathconf() call is out-of-date by the time realpath() is called. Hence the only
reliable way to use realpath() when {PATH_MAX} is not defined in  is to pass a null pointer for resolved_name so that
realpath() will allocate a buffer of the necessary size.
FUTURE DIRECTIONS
None.
SEE ALSO
fpathconf(), free(), getcwd(), sysconf()
XBD ,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The restrict keyword is added to the realpath() prototype for alignment with the ISO/IEC 9899:1999
standard.
The wording of the mandatory [ELOOP] error condition is updated, and a second optional [ELOOP] error condition is added.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/51 is applied, adding new text to the DESCRIPTION for the case
when resolved_name is a null pointer, changing the [EINVAL] error text, adding text to the RATIONALE, and adding text to
FUTURE DIRECTIONS.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/110 is applied, updating the ERRORS section to refer to the
file_name argument, rather than a nonexistent path argument.
Issue 7
Austin Group Interpretation 1003.1-2001 #143 is applied.
This function is updated for passing a null pointer to realpath() for the resolved_name argument.
The APPLICATION USAGE section is updated to clarify that memory is allocated as if by malloc().
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0499 [353], XSH/TC1-2008/0500 [324], and XSH/TC1-2008/0501 [353] are
applied.
Issue 8
Austin Group Defect 1663 is applied, removing XSI shading from realpath().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/cnd_signal.html =====
cnd_broadcast
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cnd_broadcast, cnd_signal — broadcast or signal a condition
SYNOPSIS
#include
int cnd_broadcast(cnd_t *cond);
int cnd_signal(cnd_t *cond);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The cnd_broadcast() function shall, [CX]   as a single atomic operation,   determine which threads, if any, are blocked on the condition variable pointed to by
cond and unblock all of these threads.
The cnd_signal() function shall, [CX]   as a single atomic operation,   determine which threads, if any, are blocked on the condition variable pointed to by
cond and unblock at least one of these threads.
If these functions determine that there are no threads blocked on the condition variable pointed to by cond, they shall
have no effect and shall return thrd_success.
[CX]  If
more than one thread is blocked on a condition variable, the scheduling policy shall determine the order in which threads are
unblocked. When each thread unblocked as a result of a cnd_broadcast() or cnd_signal() returns from its call to
cnd_wait() or cnd_timedwait(),
the thread shall own the mutex with which it called cnd_wait() or cnd_timedwait(). The thread(s) that are unblocked shall contend for the mutex
according to the scheduling policy (if applicable), and as if each had called mtx_lock().
The cnd_broadcast() and cnd_signal() functions can be called by a thread whether or not it currently owns the
mutex that threads calling cnd_wait() or cnd_timedwait() have associated with the condition variable during their waits;
however, if predictable scheduling behavior is required, then that mutex shall be locked by the thread calling
cnd_broadcast() or cnd_signal().
These functions shall not be affected if the calling thread executes a signal handler during the call.
The behavior is undefined if the value specified by the cond argument to cnd_broadcast() or cnd_signal()
does not refer to an initialized condition variable.
RETURN VALUE
These functions shall return thrd_success on success, or thrd_error if the request could not be honored.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
See the APPLICATION USAGE section for pthread_cond_broadcast(),
substituting cnd_broadcast() for pthread_cond_broadcast() and
cnd_signal() for pthread_cond_signal().
RATIONALE
As for pthread_cond_broadcast() and pthread_cond_signal(), spurious wakeups may occur with cnd_broadcast()
and cnd_signal(), necessitating that applications code a predicate-testing-loop around the condition wait. (See the
RATIONALE section for pthread_cond_broadcast().)
These functions are not affected by signal handlers for the reasons stated in XRAT B.2.3 Error Numbers.
FUTURE DIRECTIONS
None.
SEE ALSO
cnd_destroy(), cnd_timedwait(), pthread_cond_broadcast()
XBD 4.15.2 Memory Synchronization,
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/logbf.html =====
logb
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
logb, logbf, logbl — radix-independent exponent
SYNOPSIS
#include
double logb(double x);
float logbf(float x);
long double logbl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the exponent of x, which is the integral part of logr
|x|, as a signed floating-point value, for non-zero x, where r is the radix of the machine's floating-point
arithmetic, which is the value of FLT_RADIX defined in the
header.
If x is subnormal it is treated as though it were normalized; thus for finite positive x:
1 ,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The logb() function is no longer marked as an extension.
The logbf() and logbl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #50 (SD5-XSH-ERN-76) is applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcscasecmp.html =====
wcscasecmp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcscasecmp, wcscasecmp_l, wcsncasecmp, wcsncasecmp_l — case-insensitive wide-character string comparison
SYNOPSIS
[CX]  #include
int wcscasecmp(const wchar_t *ws1, const wchar_t *ws2);
int wcscasecmp_l(const wchar_t *ws1, const wchar_t *ws2,
locale_t locale);
int wcsncasecmp(const wchar_t *ws1, const wchar_t *ws2, size_t n);
int wcsncasecmp_l(const wchar_t *ws1, const wchar_t *ws2,
size_t n, locale_t locale);
DESCRIPTION
The wcscasecmp() and wcsncasecmp() functions are the wide-character equivalent of the strcasecmp() and strncasecmp()
functions, respectively.
The wcscasecmp() and wcscasecmp_l() functions shall compare, while ignoring differences in case, the
wide-character string pointed to by ws1 to the wide-character string pointed to by ws2.
The wcsncasecmp() and wcsncasecmp_l() functions shall compare, while ignoring differences in case, not more than
n wide-characters from the wide-character string pointed to by ws1 to the wide-character string pointed to by
ws2.
The wcscasecmp() and wcsncasecmp() functions use the current locale to determine the case of the wide
characters.
The wcscasecmp_l() and wcsncasecmp_l() functions use the locale represented by locale to determine the case
of the wide characters.
When the LC_CTYPE category of the locale being used is from the POSIX locale, these functions shall behave as if the
wide-character strings had been converted to lowercase and then a comparison of wide-character codes performed. Otherwise, the
results are unspecified.
The information for wcscasecmp_l() and wcsncasecmp_l() about the case of the characters comes from the locale
represented by locale.
The behavior is undefined if the locale argument to wcscasecmp_l() or wcsncasecmp_l() is the special locale
object LC_GLOBAL_LOCALE or is not a valid locale object handle.
RETURN VALUE
Upon completion, the wcscasecmp() and wcscasecmp_l() functions shall return an integer greater than, equal to, or
less than 0 if the wide-character string pointed to by ws1 is, ignoring case, greater than, equal to, or less than the
wide-character string pointed to by ws2, respectively.
Upon completion, the wcsncasecmp() and wcsncasecmp_l() functions shall return an integer greater than, equal to,
or less than 0 if the possibly null wide-character terminated string pointed to by ws1 is, ignoring case, greater than,
equal to, or less than the possibly null wide-character terminated string pointed to by ws2, respectively.
No return values are reserved to indicate an error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
strcasecmp(), wcscmp(),
wcsncmp()
XBD
CHANGE HISTORY
First released in Issue 7.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0716 [294], XSH/TC1-2008/0717 [283], and XSH/TC1-2008/0718 [283] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/llabs.html =====
labs
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
labs, llabs — return a long integer absolute value
SYNOPSIS
#include
long labs(long i);
long long llabs(long long i);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The labs() function shall compute the absolute value of the long integer operand i. The llabs()
function shall compute the absolute value of the long long integer operand i. If the result cannot be represented,
the behavior is undefined.
RETURN VALUE
The labs() function shall return the absolute value of the long integer operand.
The llabs() function shall return the absolute value of the long long integer operand.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Since POSIX.1 requires a two's complement representation of long and long long, the absolute value of the negative
integers with the largest magnitude {LONG_MIN} and {LLONG_MIN} are not representable, thus labs(LONG_MIN) and
llabs(LLONG_MIN) are undefined.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
abs()
XBD
CHANGE HISTORY
First released in Issue 4. Derived from the ISO C standard.
Issue 6
The llabs() function is added for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
SD5-XSH-ERN-152 is applied, correcting the RETURN VALUE section.
Issue 8
Austin Group Defect 1108 is applied, changing the APPLICATION USAGE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/vfscanf.html =====
vfscanf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
vfscanf, vscanf, vsscanf — format input of a stdarg argument list
SYNOPSIS
#include
#include
int vfscanf(FILE *restrict stream, const char *restrict format,
va_list arg);
int vscanf(const char *restrict format, va_list arg);
int vsscanf(const char *restrict s, const char *restrict format,
va_list arg);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The vscanf(), vfscanf(), and vsscanf() functions shall be equivalent to the scanf(), fscanf(), and sscanf() functions, respectively, except that instead of being called with a variable number
of arguments, they are called with an argument list as defined in the  header. These functions shall not invoke the va_end macro. As these
functions invoke the va_arg macro, the value of ap after the return is unspecified.
RETURN VALUE
Refer to fscanf().
ERRORS
Refer to fscanf().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications using these functions should call va_end(ap) afterwards to clean up.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fscanf()
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0704 [14] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/tcdrain.html =====
tcdrain
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
tcdrain — wait for transmission of output
SYNOPSIS
#include
int tcdrain(int fildes);
DESCRIPTION
The tcdrain() function shall block until all output written to the object referred to by fildes is transmitted.
The fildes argument is an open file descriptor associated with a terminal.
Any attempts to use tcdrain() from a process which is a member of a background process group on a fildes
associated with its controlling terminal, shall cause the process group to be sent a SIGTTOU signal. If the calling thread is
blocking SIGTTOU signals or the process is ignoring SIGTTOU signals, the process shall be allowed to perform the operation, and no
signal is sent.
RETURN VALUE
Upon successful completion, 0 shall be returned. Otherwise, -1 shall be returned and errno set to indicate the error.
ERRORS
The tcdrain() function shall fail if:
[EBADF]
The fildes argument is not a valid file descriptor.
[EINTR]
A signal interrupted tcdrain().
[EIO]
The process group of the writing process is orphaned, the calling thread is not blocking SIGTTOU, and the process is not
ignoring SIGTTOU.
[ENOTTY]
The file associated with fildes is not a terminal.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
tcflush()
XBD 11. General Terminal Interface,
CHANGE HISTORY
First released in Issue 3. Included for alignment with the POSIX.1-1988 standard.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the DESCRIPTION, the final paragraph is no longer conditional on _POSIX_JOB_CONTROL. This is a FIPS requirement.
The [EIO] error is added.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0639 [79], XSH/TC1-2008/0640 [79], and XSH/TC1-2008/0641 [79] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/csqrtf.html =====
csqrt
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
csqrt, csqrtf, csqrtl — complex square root functions
SYNOPSIS
#include
double complex csqrt(double complex z);
float complex csqrtf(float complex z);
long double complex csqrtl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex square root of z, with a branch cut along the negative real axis.
RETURN VALUE
These functions shall return the complex square root value, in the range of the right half-plane (including the imaginary
axis).
[MXC]
csqrt(conj(z)), csqrtf(conjf(z)), and csqrtl(conjl(z)) shall return
exactly the same value as conj(csqrt(z)), conjf(csqrtf(z)), and
conjl(csqrtl(z)), respectively, including for the special values of z below.
If z is ±0 + i0, +0 + i0 shall be returned.
If the imaginary part of z is Inf, +Inf + iInf, shall be returned.
If z is x + iNaN where x is finite, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is -Inf + iy where y is positive-signed and finite, +0 + iInf shall be returned.
If z is +Inf + iy where y is positive-signed and finite, +Inf + i0 shall be returned.
If z is -Inf + iNaN, NaN ± iInf shall be returned; the sign of the imaginary part of the result is
unspecified.
If z is +Inf + iNaN, +Inf + iNaN shall be returned.
If z is NaN + iy where y is finite, NaN + iNaN shall be returned and the invalid floating-point
exception may be raised.
If z is NaN + iNaN, NaN + iNaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
cabs(), cpow()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/tsearch.html =====
tdelete
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
tdelete, tfind, tsearch, twalk — manage a binary search tree
SYNOPSIS
[XSI]  #include
void *tdelete(const void *restrict key,
posix_tnode **restrict rootp,
int(*compar)(const void *, const void *));
posix_tnode *tfind(const void *key,
posix_tnode *const *rootp,
int(*compar)(const void *, const void *));
posix_tnode *tsearch(const void *key,
posix_tnode **rootp,
int (*compar)(const void *, const void *));
void twalk(const posix_tnode *root,
void (*action)(const posix_tnode *, VISIT, int));
DESCRIPTION
The tdelete(), tfind(), tsearch(), and twalk() functions manipulate binary search trees. Comparisons
are made with a user-supplied routine, the address of which is passed as the compar argument. This routine is called with
two arguments, which are the pointers to the elements being compared. The application shall ensure that the user-supplied routine
returns an integer less than, equal to, or greater than 0, according to whether the first argument is to be considered less than,
equal to, or greater than the second argument. The comparison function need not compare every byte, so arbitrary data may be
contained in the elements in addition to the values being compared.
The tsearch() function shall build and access the tree. The key argument is a pointer to an element to be accessed
or stored. If there is a node in the tree whose element is equal to the value pointed to by key, a pointer to this found
node shall be returned. Otherwise, the value pointed to by key shall be inserted (that is, a new node is created and the
value of key is copied to this node), and a pointer to this node returned. Only pointers are copied, so the application
shall ensure that the calling routine stores the data. The rootp argument points to a variable that points to the root node
of the tree. A null pointer value for the variable pointed to by rootp denotes an empty tree; in this case, the variable
shall be set to point to the node which shall be at the root of the new tree.
Like tsearch(), tfind() shall search for a node in the tree, returning a pointer to it if found. However, if it is
not found, tfind() shall return a null pointer. The arguments for tfind() are the same as for tsearch().
The tdelete() function shall delete a node from a binary search tree. The arguments are the same as for tsearch().
The variable pointed to by rootp shall be set to a pointer to the new root of the tree if the root of the tree was changed.
If the deleted node was the root of the tree and had no children, the variable pointed to by rootp shall be set to a null
pointer. The tdelete() function shall return a pointer to the parent of the deleted node, or an unspecified non-null pointer
if the deleted node was the root node, or a null pointer if the node is not found.
If tsearch() adds an element to a tree, or tdelete() successfully deletes an element from a tree, the concurrent
use of that tree in another thread, or use of pointers produced by a previous call to tfind() or tsearch(), produces
undefined results.
The twalk() function shall traverse a binary search tree. The root argument is a pointer to the root node of the
tree to be traversed. (Any node in a tree may be used as the root for a walk below that node.) The argument action is the
name of a routine to be invoked at each node. This routine is, in turn, called with three arguments. The first argument shall be
the address of the node being visited. The structure pointed to by this argument is unspecified and shall not be modified by the
application, but it shall be possible to cast a pointer-to-node into a pointer-to-pointer-to-element to access the element stored
in the node. The second argument shall be a value from an enumeration data type:
typedef enum { preorder, postorder, endorder, leaf } VISIT;
(defined in ), depending on whether this is the first, second, or
third time that the node is visited (during a depth-first, left-to-right traversal of the tree), or whether the node is a leaf. The
third argument shall be the level of the node in the tree, with the root being level 0.
If the calling function alters the pointer to the root, the result is undefined.
If the functions pointed to by action or compar (for any of these binary search functions) change the tree, the
results are undefined.
These functions are thread-safe only as long as multiple threads do not access the same tree.
RETURN VALUE
If the node is found, both tsearch() and tfind() shall return a pointer to it. If not, tfind() shall return
a null pointer, and tsearch() shall return a pointer to the inserted item.
A null pointer shall be returned by tsearch() if there is not enough space available to create a new node.
A null pointer shall be returned by tdelete(), tfind(), and tsearch() if rootp is a null pointer on
entry.
The tdelete() function shall return a pointer to the parent of the deleted node, or an unspecified non-null pointer if
the deleted node was the root node, or a null pointer if the node is not found.
The twalk() function shall not return a value.
In all cases where a pointer to a node is returned, the structure pointed to by the return value is unspecified and shall not be
modified by the application, but it shall be possible to cast a pointer-to-node into a pointer-to-pointer-to-element to access the
element stored in the node.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
The following code reads in strings and stores structures containing a pointer to each string and a count of its length. It then
walks the tree, printing out the stored strings and their lengths in alphabetical order.
#include
#include
#include
#include
#include
struct element {      /* Pointers to these are stored in the tree. */
int     count;
char    string[];
};
posix_tnode  *root = NULL;          /* This points to the root. */
int main(void)
{
char   str[_POSIX2_LINE_MAX+1];
int    length = 0;
struct element *elementptr;
posix_tnode *node;
void   print_node(const posix_tnode *, VISIT, int);
int    node_compare(const void *, const void *);
while (fgets(str, sizeof(str), stdin))  {
/* Set element. */
length = strlen(str);
if (str[length-1] == '\n')
str[--length] = '\0';
elementptr = malloc(sizeof(struct element) + length + 1);
strcpy(elementptr->string, str);
elementptr->count = 1;
/* Put element into the tree. */
node = tsearch((void *)elementptr, &root, node_compare);
if (node == NULL) {
fprintf(stderr,
"tsearch: Not enough space available\n");
exit(EXIT_FAILURE);
}
else if (*(struct element **)node != elementptr) {
/* A node containing the element already exists */
(*(struct element **)node)->count++;
free(elementptr);
}
}
twalk(root, print_node);
/* Delete all nodes in the tree */
while (root != NULL) {
elementptr = *(struct element **)root;
printf("deleting node: string = %s,  count = %d\n",
elementptr->string,
elementptr->count);
tdelete((void *)elementptr, &root, node_compare);
free(elementptr);
}
return 0;
}
/*
*  This routine compares two nodes, based on an
*  alphabetical ordering of the string field.
*/
int
node_compare(const void *node1, const void *node2)
{
return strcmp(((const struct element *) node1)->string,
((const struct element *) node2)->string);
}
/*
*  This routine prints out a node, the second time
*  twalk encounters it or if it is a leaf.
*/
void
print_node(const posix_tnode *ptr, VISIT order, int level)
{
const struct element *p = *(const struct element **) ptr;
if (order == postorder || order == leaf)  {
(void) printf("string = %s,  count = %d\n",
p->string, p->count);
}
}
APPLICATION USAGE
The root argument to twalk() is one level of indirection less than the rootp arguments to tdelete()
and tsearch().
There are two nomenclatures used to refer to the order in which tree nodes are visited. The twalk() function uses
preorder, postorder, and endorder to refer respectively to visiting a node before any of its children, after
its left child and before its right, and after both its children. The alternative nomenclature uses preorder,
inorder, and postorder to refer to the same visits, which could result in some confusion over the meaning of
postorder.
Since the return value of tdelete() is an unspecified non-null pointer in the case that the root of the tree has been
deleted, applications should only use the return value of tdelete() as indication of success or failure in this case and
should not assume it can be dereferenced. However, the only way that applications can tell if this case may have occurred is by
checking whether the variable pointed to by rootp changed. Since this variable can change for other reasons (for example,
tree balancing), using the return value of tdelete() as anything other than a boolean indicator is unreliable at best and is
discouraged. Some implementations in this case will return a pointer to the new root of the tree (or to an empty tree if the
deleted root node was the only node in the tree); other implementations return arbitrary non-null pointers.
RATIONALE
Implementations are encouraged to use balanced trees to reduce the depth of the trees that are created and improve tree search
times.
FUTURE DIRECTIONS
None.
SEE ALSO
hcreate(), lsearch()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The last paragraph of the DESCRIPTION was included as an APPLICATION USAGE note in previous issues.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
The restrict keyword is added to the tdelete() prototype for alignment with the ISO/IEC 9899:1999
standard.
Issue 7
Austin Group Interpretation 1003.1-2001 #149 is applied, clarifying concurrent use of the tree in another thread.
Austin Group Interpretation 1003.1-2001 #151 is applied, clarifying behavior for tdelete() when the deleted node is the
root node.
Austin Group Interpretation 1003.1-2001 #153 is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0366 [551] is applied.
Issue 8
Austin Group Defect 1011 is applied, changing some prototypes to use posix_tnode instead of void, and changing the
required behavior for tdelete() when the root of the tree changes.
Austin Group Defect 1470 is applied, changing the EXAMPLES section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/lio_listio.html =====
lio_listio
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
lio_listio — list directed I/O
SYNOPSIS
#include
int lio_listio(int mode, struct aiocb *restrict const list[restrict],
int nent, struct sigevent *restrict sig);
DESCRIPTION
The lio_listio() function shall initiate a list of I/O requests with a single function call.
The mode argument takes one of the values LIO_WAIT or LIO_NOWAIT declared in  and determines whether the function returns when the I/O operations have been
completed, or as soon as the operations have been queued. If the mode argument is LIO_WAIT, the function shall wait until
all I/O is complete and the sig argument shall be ignored.
If the mode argument is LIO_NOWAIT, the function shall return immediately, and asynchronous notification shall occur,
according to the sig argument, when all the I/O operations complete. If sig is NULL, then no asynchronous
notification shall occur. If sig is not NULL, asynchronous notification occurs as specified in 2.4.1 Signal Generation and Delivery when all the requests in list
have completed.
The I/O requests enumerated by list are submitted in an unspecified order.
The list argument is an array of pointers to aiocb structures. The array contains nent elements. The array
may contain NULL elements, which shall be ignored.
If the buffer pointed to by list or the aiocb structures pointed to by the elements of the array list
become illegal addresses before all asynchronous I/O completed and, if necessary, the notification is sent, then the behavior is
undefined. If the buffers pointed to by the aio_buf member of the aiocb structure pointed to by the elements of the
array list become illegal addresses prior to the asynchronous I/O associated with that aiocb structure being
completed, the behavior is undefined.
The aio_lio_opcode field of each aiocb structure specifies the operation to be performed. The supported operations
are LIO_READ, LIO_WRITE, and LIO_NOP; these symbols are defined in . The
LIO_NOP operation causes the list entry to be ignored. If the aio_lio_opcode element is equal to LIO_READ, then an I/O
operation is submitted as if by a call to aio_read() with the aiocbp equal
to the address of the aiocb structure. If the aio_lio_opcode element is equal to LIO_WRITE, then an I/O operation is
submitted as if by a call to aio_write() with the aiocbp equal to the
address of the aiocb structure.
The aio_fildes member specifies the file descriptor on which the operation is to be performed.
The aio_buf member specifies the address of the buffer to or from which the data is transferred.
The aio_nbytes member specifies the number of bytes of data to be transferred.
The members of the aiocb structure further describe the I/O operation to be performed, in a manner identical to that of
the corresponding aiocb structure when used by the aio_read() and aio_write() functions.
The nent argument specifies how many elements are members of the list; that is, the length of the array.
The behavior of this function is altered according to the definitions of synchronized I/O data integrity completion and
synchronized I/O file integrity completion if synchronized I/O is enabled on the file associated with aio_fildes.
For regular files, no data transfer shall occur past the offset maximum established in the open file description associated with
aiocbp->aio_fildes.
If sig->sigev_notify is SIGEV_THREAD and sig->sigev_notify_attributes is a non-null pointer
and the block pointed to by this pointer becomes an illegal address prior to all asynchronous I/O being completed, then the
behavior is undefined.
RETURN VALUE
If the mode argument has the value LIO_NOWAIT, the lio_listio() function shall return the value zero if the I/O
operations are successfully queued; otherwise, the function shall return the value -1 and set errno to indicate the
error.
If the mode argument has the value LIO_WAIT, the lio_listio() function shall return the value zero when all the
indicated I/O has completed successfully. Otherwise, lio_listio() shall return a value of -1 and set errno to
indicate the error.
In either case, the return value only indicates the success or failure of the lio_listio() call itself, not the status of
the individual I/O requests. In some cases one or more of the I/O requests contained in the list may fail. Failure of an individual
request does not prevent completion of any other individual request. To determine the outcome of each I/O request, the application
shall examine the error status associated with each aiocb control block. The error statuses so returned are identical to
those returned as the result of an aio_read() or aio_write() function.
ERRORS
The lio_listio() function shall fail if:
[EAGAIN]
The resources necessary to queue all the I/O requests were not available. The application may check the error status for each
aiocb to determine the individual request(s) that failed.
[EAGAIN]
The number of entries indicated by nent would cause the system-wide limit {AIO_MAX} to be exceeded.
[EINVAL]
The mode argument is not a proper value, or the value of nent was greater than {AIO_LISTIO_MAX}.
[EINTR]
A signal was delivered while waiting for all I/O requests to complete during an LIO_WAIT operation. Note that, since each I/O
operation invoked by lio_listio() may possibly provoke a signal when it completes, this error return may be caused by the
completion of one (or more) of the very I/O operations being awaited. Outstanding I/O requests are not canceled, and the
application shall examine each list element to determine whether the request was initiated, canceled, or completed.
[EIO]
One or more of the individual I/O operations failed. The application may check the error status for each aiocb structure
to determine the individual request(s) that failed.
If the lio_listio() function succeeds or fails with errors of [EAGAIN], [EINTR], or [EIO], then some of the I/O specified
by the list may have been initiated. If the lio_listio() function fails with an error code other than [EAGAIN], [EINTR], or
[EIO], no operations from the list shall have been initiated. The I/O operation indicated by each list element can encounter errors
specific to the individual read or write function being performed. In this event, the error status for each aiocb control
block contains the associated error code. The error codes that can be set are the same as would be set if the I/O operation had
been initiated by an aio_read() or aio_write() function, with the following additional error codes possible:
[EAGAIN]
The requested I/O operation was not queued due to resource limitations.
[EINPROGRESS]
The requested I/O is in progress.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
Although it may appear that there are inconsistencies in the specified circumstances for error codes, the [EIO] error condition
applies when any circumstance relating to an individual operation makes that operation fail. This might be due to a badly
formulated request (for example, the aio_lio_opcode field is invalid, and aio_error() returns [EINVAL]) or might arise from application behavior (for example, the
file descriptor is closed before the operation is initiated, and aio_error()
returns [EBADF]).
The limitation on the set of error codes returned when operations from the list shall have been initiated enables applications
to know when operations have been started and whether aio_error() is valid for a
specific operation.
FUTURE DIRECTIONS
None.
SEE ALSO
aio_read(), aio_write(),
aio_error(), aio_return(),
aio_cancel(), close(), exec, exit(), fork(), lseek(), read()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Large File Summit extensions are added.
Issue 6
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the
Asynchronous Input and Output option.
The lio_listio() function is marked as part of the Asynchronous Input and Output option.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the DESCRIPTION, text is added to indicate that for regular files no data transfer occurs past the offset maximum established
in the open file description associated with aiocbp->aio_fildes. This change is to support large files.
The [EBIG] and [EOVERFLOW] error conditions are defined. This change is to support large files.
The normative text is updated to avoid use of the term "must" for application requirements.
The restrict keyword is added to the lio_listio() prototype for alignment with the ISO/IEC 9899:1999
standard.
Issue 6
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/53 is applied, adding new text for symmetry with the aio_read() and aio_write() functions to
the DESCRIPTION.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/54 is applied, adding text to the DESCRIPTION making it explicit
that the user is required to keep the structure pointed to by sig->sigev_notify_attributes valid until the last
asynchronous operation finished and the notification has been sent.
Issue 7
The lio_listio() function is moved from the Asynchronous Input and Output option to the Base.
Issue 8
Austin Group Defect 308 is applied, clarifying the handling of [EFBIG] errors.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sched_getparam.html =====
sched_getparam
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sched_getparam — get scheduling parameters (REALTIME)
SYNOPSIS
[PS]  #include
int sched_getparam(pid_t pid, struct sched_param *param);
DESCRIPTION
The sched_getparam() function shall return the scheduling parameters of a process specified by pid in the
sched_param structure pointed to by param.
If a process specified by pid exists, and if the calling process has permission, the scheduling parameters for the
process whose process ID is equal to pid shall be returned.
If pid is zero, the scheduling parameters for the calling process shall be returned. The behavior of the
sched_getparam() function is unspecified if the value of pid is negative.
RETURN VALUE
Upon successful completion, the sched_getparam() function shall return zero. If the call to sched_getparam() is
unsuccessful, the function shall return a value of -1 and set errno to indicate the error.
ERRORS
The sched_getparam() function shall fail if:
[EPERM]
The requesting process does not have permission to obtain the scheduling parameters of the specified process.
[ESRCH]
No process can be found corresponding to that specified by pid.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
sched_getscheduler(), sched_setparam(), sched_setscheduler()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The sched_getparam() function is marked as part of the Process Scheduling option.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Process
Scheduling option.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/dbm_open.html =====
dbm_clearerr
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
dbm_clearerr, dbm_close, dbm_delete, dbm_error, dbm_fetch, dbm_firstkey, dbm_nextkey, dbm_open, dbm_store — database
functions
SYNOPSIS
[XSI]  #include
int dbm_clearerr(DBM *db);
void dbm_close(DBM *db);
int dbm_delete(DBM *db, datum key);
int dbm_error(DBM *db);
datum dbm_fetch(DBM *db, datum key);
datum dbm_firstkey(DBM *db);
datum dbm_nextkey(DBM *db);
DBM *dbm_open(const char *file, int open_flags, mode_t file_mode);
int dbm_store(DBM *db, datum key, datum content, int
store_mode);
DESCRIPTION
These functions create, access, and modify a database.
A datum consists of at least two members, dptr and dsize. The dptr member points to an object that
is dsize bytes in length. Arbitrary binary data, as well as character strings, may be stored in the object pointed to by
dptr.
A database shall be stored in one or two files. When one file is used, the name of the database file shall be formed by
appending the suffix .db to the file argument given to dbm_open(). When two files are used, the names of the
database files shall be formed by appending the suffixes .dir and .pag respectively to the file argument.
The dbm_open() function shall open a database. The file argument to the function is the pathname of the database.
Values for the open_flags argument are constructed by a bitwise-inclusive OR of flags from the following list, defined in
. Applications shall specify exactly one of the first three values
(file access modes) below in the value of open_flags:
O_RDONLY
Open the database, and the underlying file(s) used to store the database, for reading only.
O_RDWR
Open the database, and the underlying file(s) used to store the database, for reading and writing.
O_WRONLY
Open the database for writing only. The underlying file(s) used to store the database shall be opened for reading and
writing.
Any combination of the following can be used:
O_CLOEXEC
If set, the FD_CLOEXEC flag for the new file descriptor(s) used to open the underlying file(s) shall be set.
O_CREAT
If the database exists, this flag has no effect except as noted under O_EXCL below. Otherwise, the database shall be created;
the user ID of the underlying file(s) shall be set to the effective user ID of the process; the group ID of the underlying file(s)
shall be set to the group ID of the file's parent directory or to the effective group ID of the process. Implementations shall
provide a way to initialize the group ID to the group ID of the parent directory. Implementations may, but need not, provide an
implementation-defined way to initialize the group ID to the effective group ID of the calling process.
O_DSYNC
[SIO]
Write I/O operations on the file(s) used to store the database shall complete as defined by synchronized I/O data integrity
completion.
O_EXCL
If O_CREAT and O_EXCL are set, dbm_open() shall fail if the database exists according to the following criteria. If the
database is stored in a file with a .db suffix, a check for the existence of the file and the creation of the file if it
does not exist shall be performed as a single atomic operation. If the database is stored in files with .pag and .dir
suffixes, this atomic existence check and creation operation shall be performed for each file, but it is unspecified which file is
first. If the first file is successfully created and the second file is found to exist, the first file should be removed before
dbm_open() returns.
If O_EXCL is set and O_CREAT is not set, the result is undefined.
O_RSYNC
[SIO]
Read I/O operations on the file(s) used to store the database shall complete at the same level of integrity as specified by the
O_DSYNC and O_SYNC flags. If both O_DSYNC and O_RSYNC are set in oflag, all I/O operations on the file(s) shall complete as defined
by synchronized I/O data integrity completion. If both O_SYNC and O_RSYNC are set in flags, all I/O operations on the file(s) shall
complete as defined by synchronized I/O file integrity completion.
O_SYNC
Write I/O operations on the file(s) used to store the database shall complete as defined by synchronized I/O file integrity
completion.
O_TRUNC
If the database exists and is successfully opened O_RDWR or O_WRONLY, it shall be emptied, and the mode and owner of the
underlying file(s) shall be unchanged. The result of using O_TRUNC without either O_RDWR or O_WRONLY is undefined.
The behaviour of other flags described for the flags argument of open() is
unspecified.
The file_mode argument has the same meaning as the third argument of open()
and shall apply to the underlying file(s) used to store the database.
The dbm_open() function need not accept pathnames longer than {PATH_MAX}-4 bytes (including the terminating null), or
pathnames with a last component longer than {NAME_MAX}-4 bytes (excluding the terminating null).
The dbm_close() function shall close a database. The application shall ensure that argument db is a pointer to a
dbm structure that has been returned from a call to dbm_open().
These database functions shall support an internal block size large enough to support key/content pairs of at least 1023
bytes.
The dbm_fetch() function shall read a record from a database. The argument db is a pointer to a database structure
that has been returned from a call to dbm_open(). The argument key is a datum that has been initialized by the
application to the value of the key that matches the key of the record the program is fetching.
The dbm_store() function shall write a record to a database. The argument db is a pointer to a database structure
that has been returned from a call to dbm_open(). The argument key is a datum that has been initialized by the
application to the value of the key that identifies (for subsequent reading, writing, or deleting) the record the application is
writing. The argument content is a datum that has been initialized by the application to the value of the record the
program is writing. The argument store_mode controls whether dbm_store() replaces any pre-existing record that has
the same key that is specified by the key argument. The application shall set store_mode to either DBM_INSERT or
DBM_REPLACE. If the database contains a record that matches the key argument and store_mode is DBM_REPLACE, the
existing record shall be replaced with the new record. If the database contains a record that matches the key argument and
store_mode is DBM_INSERT, the existing record shall be left unchanged and the new record ignored. If the database does not
contain a record that matches the key argument and store_mode is either DBM_INSERT or DBM_REPLACE, the new record
shall be inserted in the database.
If the sum of a key/content pair exceeds the internal block size, the result is unspecified. Moreover, the application shall
ensure that all key/content pairs that hash together fit on a single block. The dbm_store() function shall return an error
in the event that a disk block fills with inseparable data.
The dbm_delete() function shall delete a record and its key from the database. The argument db is a pointer to a
database structure that has been returned from a call to dbm_open(). The argument key is a datum that has been
initialized by the application to the value of the key that identifies the record the program is deleting.
The dbm_firstkey() function shall return the first key in the database. The argument db is a pointer to a database
structure that has been returned from a call to dbm_open().
The dbm_nextkey() function shall return the next key in the database. The argument db is a pointer to a database
structure that has been returned from a call to dbm_open(). The application shall ensure that the dbm_firstkey()
function is called before calling dbm_nextkey(). Subsequent calls to dbm_nextkey() return the next key until all of
the keys in the database have been returned.
The dbm_error() function shall return the error condition of the database. The argument db is a pointer to a
database structure that has been returned from a call to dbm_open().
The dbm_clearerr() function shall clear the error condition of the database. The argument db is a pointer to a
database structure that has been returned from a call to dbm_open().
The dptr pointers returned by these functions may point into static storage that may be changed by subsequent calls.
These functions need not be thread-safe.
RETURN VALUE
The dbm_store() and dbm_delete() functions shall return 0 when they succeed and a negative value when they
fail.
The dbm_store() function shall return 1 if it is called with a flags value of DBM_INSERT and the function finds an
existing record with the same key.
The dbm_error() function shall return 0 if the error condition is not set and return a non-zero value if the error
condition is set.
The return value of dbm_clearerr() is unspecified.
The dbm_firstkey() and dbm_nextkey() functions shall return a key datum. When the end of the database is
reached, the dptr member of the key is a null pointer. If an error is detected, the dptr member of the key shall be a
null pointer and the error condition of the database shall be set.
The dbm_fetch() function shall return a content datum. If no record in the database matches the key or if an error
condition has been detected in the database, the dptr member of the content shall be a null pointer.
The dbm_open() function shall return a pointer to a database structure. If an error is detected during the operation,
dbm_open() shall return a (DBM *)0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The following code can be used to traverse the database:
for(key = dbm_firstkey(db); key.dptr != NULL; key = dbm_nextkey(db))
The dbm_* functions provided in this library should not be confused in any way with those of a general-purpose database
management system. These functions do not provide for multiple search keys per entry, they do not protect against multi-user access
(in other words they do not lock records or files), and they do not provide the many other useful database functions that are found
in more robust database management systems. Creating and updating databases by use of these functions is relatively slow because of
data copies that occur upon hash collisions. These functions are useful for applications requiring fast lookup of relatively static
information that is to be indexed by a single key.
Note that a strictly conforming application is extremely limited by these functions: since there is no way to determine that the
keys in use do not all hash to the same value (although that would be rare), a strictly conforming application cannot be guaranteed
that it can store more than one block's worth of data in the database. As long as a key collision does not occur, additional data
may be stored, but because there is no way to determine whether an error is due to a key collision or some other error condition
(dbm_error() being effectively a Boolean), once an error is detected, the
application is effectively limited to guessing what the error might be if it wishes to continue using these functions.
The dbm_delete() function need not physically reclaim file space, although it does make it available for reuse by the
database.
After calling dbm_store() or dbm_delete() during a pass through the keys by dbm_firstkey() and
dbm_nextkey(), the application should reset the database by calling dbm_firstkey() before again calling
dbm_nextkey(). The contents of these files are unspecified and may not be portable.
Applications should take care that database pathname arguments specified to dbm_open() are not prefixes of unrelated
files. This might be done, for example, by placing databases in a separate directory.
Since some implementations use three characters for a suffix and others use four characters for a suffix, applications should
ensure that the maximum portable pathname length passed to dbm_open() is no greater than {PATH_MAX}-4 bytes, with the last
component of the pathname no greater than {NAME_MAX}-4 bytes.
RATIONALE
and having .dir as its suffix. The second file containing all data and having .pag as its suffix. This has been
changed not to specify the use of the files and to allow newer implementations of the Berkeley DB interface using a single file
that have evolved while remaining compatible with the application programming interface. The standard developers considered
removing the specific suffixes altogether but decided to retain them so as not to pollute the application file name space more than
necessary and to allow for portable backups of the database.
FUTURE DIRECTIONS
A future revision of this standard may mandate the file removal that is currently recommended (by the use of "should") in the
description of O_EXCL.
SEE ALSO
open()
XBD ,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Normative text previously in the APPLICATION USAGE section is moved to the DESCRIPTION.
A note indicating that these functions need not be reentrant is added to the DESCRIPTION.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
Austin Group Interpretation 1003.1-2001 #042 is applied so that the DESCRIPTION permits newer implementations of the Berkeley DB
interface.
Austin Group Interpretation 1003.1-2001 #156 is applied.
Issue 8
Austin Group Defect 1057 is applied, clarifying how the O_ flags defined for use with open() apply to dbm_open().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/FD_ZERO.html =====
pselect
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pselect, select — synchronous I/O multiplexing
SYNOPSIS
#include
int pselect(int nfds, fd_set *restrict readfds,
fd_set *restrict writefds, fd_set *restrict errorfds,
const struct timespec *restrict timeout,
const sigset_t *restrict sigmask);
int select(int nfds, fd_set *restrict readfds,
fd_set *restrict writefds, fd_set *restrict errorfds,
struct timeval *restrict timeout);
void FD_CLR(int fd, fd_set *fdset);
int FD_ISSET(int fd, const fd_set *fdset);
void FD_SET(int fd, fd_set *fdset);
void FD_ZERO(fd_set *fdset);
DESCRIPTION
The pselect() function shall examine the file descriptor sets whose addresses are passed in the readfds,
writefds, and errorfds parameters to see whether some of their descriptors are ready for reading, are ready for
writing, or have an exceptional condition pending, respectively.
The select() function shall be equivalent to the pselect() function, except as follows:
For the select() function, the timeout period is given in seconds and microseconds in an argument of type struct
timeval, whereas for the pselect() function the timeout period is given in seconds and nanoseconds in an argument of
type struct timespec.
The select() function has no sigmask argument; it shall behave as pselect() does when sigmask is a
null pointer.
Upon successful completion, the select() function may modify the object pointed to by the timeout argument.
The pselect() and select() functions shall support regular files, terminal and pseudo-terminal devices, FIFOs,
pipes, and sockets. The behavior of pselect() and select() on file descriptors that refer to other types of file is
unspecified.
The nfds argument specifies the range of descriptors to be tested. The first nfds descriptors shall be checked in
each set; that is, the descriptors from zero through nfds-1 in the descriptor sets shall be examined.
If the readfds argument is not a null pointer, it points to an object of type fd_set that on input specifies the
file descriptors to be checked for being ready to read, and on output indicates which file descriptors are ready to read.
If the writefds argument is not a null pointer, it points to an object of type fd_set that on input specifies the
file descriptors to be checked for being ready to write, and on output indicates which file descriptors are ready to write.
If the errorfds argument is not a null pointer, it points to an object of type fd_set that on input specifies the
file descriptors to be checked for error conditions pending, and on output indicates which file descriptors have error conditions
pending.
Upon successful completion, the pselect() or select() function shall modify the objects pointed to by the
readfds, writefds, and errorfds arguments to indicate which file descriptors are ready for reading, ready for
writing, or have an error condition pending, respectively, and shall return the total number of ready descriptors in all the output
sets. For each file descriptor less than nfds, the corresponding bit shall be set upon successful completion if it was set
on input and the associated condition is true for that file descriptor.
If none of the selected descriptors are ready for the requested operation, the pselect() or select() function
shall block until at least one of the requested operations becomes ready, until the timeout occurs, or until interrupted by
a signal. The timeout parameter controls how long the pselect() or select() function shall take before timing
out. If the timeout parameter is not a null pointer, it specifies a maximum interval to wait for the selection to complete.
If the specified time interval expires without any requested operation becoming ready, the function shall return. If the
timeout parameter is a null pointer, then the call to pselect() or select() shall block indefinitely until at
least one descriptor meets the specified criteria. To effect a poll, the timeout parameter should not be a null pointer, and
should point to a zero-valued timespec structure.
The use of a timeout does not affect any pending timers set up by alarm().
Implementations may place limitations on the maximum timeout interval supported. All implementations shall support a maximum
timeout interval of at least 31 days. If the timeout argument specifies a timeout interval greater than the
implementation-defined maximum value, the maximum value shall be used as the actual timeout value. Implementations may also place
limitations on the granularity of timeout intervals. If the requested timeout interval requires a finer granularity than the
implementation supports, the actual timeout interval shall be rounded up to the next supported value.
If sigmask is not a null pointer, then the pselect() function shall replace the signal mask of the caller by the
set of signals pointed to by sigmask before examining the descriptors, and shall restore the signal mask of the calling
thread before returning. If a signal is unmasked as a result of the signal mask being altered by pselect(), and a
signal-catching function is called for that signal during the execution of the pselect() function, and SA_RESTART is clear
for the interrupting signal, then
If none of the selected file descriptors are ready, pselect() shall immediately fail with the [EINTR] error after the
signal-catching function returns.
If one or more of the selected file descriptors are ready, it is unspecified whether pselect() behaves the same as if
none of the descriptors were ready (failing with [EINTR] as above) or behaves the same as if it was not interrupted (returning the
total number of ready descriptors).
A descriptor shall be considered ready for reading when a call to an input function with O_NONBLOCK clear would not block,
whether or not the function would transfer data successfully. (The function might return data, an end-of-file indication, or an
error other than one indicating that it is blocked, and in each of these cases the descriptor shall be considered ready for
reading.)
A descriptor shall be considered ready for writing when a call to an output function with O_NONBLOCK clear would not block,
whether or not the function would transfer data successfully.
If a socket has a pending error, it shall be considered to have an exceptional condition pending. Otherwise, what constitutes an
exceptional condition is file type-specific. For a file descriptor for use with a socket, it is protocol-specific except as noted
below. For other file types it is implementation-defined. If the operation is meaningless for a particular file type,
pselect() or select() shall indicate that the descriptor is ready for read or write operations, and shall indicate
that the descriptor has no exceptional condition pending.
If a descriptor refers to a socket, the implied input function is the recvmsg()
function with parameters requesting normal and ancillary data, such that the presence of either type shall cause the socket to be
marked as readable. The presence of out-of-band data shall be checked if the socket option SO_OOBINLINE has been enabled, as
out-of-band data is enqueued with normal data. If the socket is currently listening, then it shall be marked as readable if an
incoming connection request has been received, and a call to the accept() or accept4() function shall complete without blocking.
If a descriptor refers to a socket, the implied output function is the sendmsg()
function supplying an amount of normal data equal to the current value of the SO_SNDLOWAT option for the socket. If a non-blocking
call to the connect() function has been made for a socket, and the connection
attempt has either succeeded or failed leaving a pending error, the socket shall be marked as writable.
A socket shall be considered to have an exceptional condition pending if a receive operation with O_NONBLOCK clear for the open
file description and with the MSG_OOB flag set would return out-of-band data without blocking. (It is protocol-specific whether the
MSG_OOB flag would be used to read out-of-band data.) A socket shall also be considered to have an exceptional condition pending if
an out-of-band data mark is present in the receive queue. Other circumstances under which a socket may be considered to have an
exceptional condition pending are protocol-specific and implementation-defined.
If the readfds, writefds, and errorfds arguments are all null pointers and the timeout argument is
not a null pointer, the pselect() or select() function shall block for the time specified, or until interrupted by a
signal. If the readfds, writefds, and errorfds arguments are all null pointers and the timeout argument
is a null pointer, the pselect() or select() function shall block until interrupted by a signal.
File descriptors associated with regular files shall always select true for ready to read, ready to write, and error
conditions.
On failure, the objects pointed to by the readfds, writefds, and errorfds arguments shall not be modified.
If the timeout interval expires without the specified condition being true for any of the specified file descriptors, the objects
pointed to by the readfds, writefds, and errorfds arguments shall have all bits set to 0.
File descriptor masks of type fd_set can be initialized and tested with FD_CLR(), FD_ISSET(),
FD_SET(), and FD_ZERO(). It is unspecified whether each of these is a macro or a function. If a macro definition is
suppressed in order to access an actual function, or a program defines an external identifier with any of these names, the behavior
is undefined.
FD_CLR(fd, fdsetp) shall remove the file descriptor fd from the set pointed to by fdsetp. If
fd is not a member of this set, there shall be no effect on the set, and this shall not be treated as an error.
FD_ISSET(fd, fdsetp) shall evaluate to non-zero if the file descriptor fd is a member of the set
pointed to by fdsetp, and shall evaluate to zero otherwise.
FD_SET(fd, fdsetp) shall add the file descriptor fd to the set pointed to by fdsetp. If the
file descriptor fd is already in this set, there shall be no effect on the set, and this shall not be treated as an
error.
FD_ZERO(fdsetp) shall initialize the descriptor set pointed to by fdsetp to the null set. No error is
returned if the set is not empty at the time FD_ZERO() is invoked.
The behavior of these macros is undefined if the fd argument is less than 0 or greater than or equal to FD_SETSIZE, or if
fd is not a valid file descriptor, or if any of the arguments are expressions with side-effects.
If a thread gets canceled during a pselect() call, the signal mask in effect when executing the registered cleanup
functions is either the original signal mask or the signal mask installed as part of the pselect() call.
RETURN VALUE
Upon successful completion, the pselect() and select() functions shall return the total number of bits set in the
bit masks. Otherwise, -1 shall be returned, and errno shall be set to indicate the error.
FD_CLR(), FD_SET(), and FD_ZERO() do not return a value. FD_ISSET() shall return a non-zero value if
the bit for the file descriptor fd is set in the file descriptor set pointed to by fdset, and 0 otherwise.
ERRORS
Under the following conditions, pselect() and select() shall fail and set errno to:
[EBADF]
One or more of the file descriptor sets specified a file descriptor that is not a valid open file descriptor.
[EINTR]
The function was interrupted by a signal.
If SA_RESTART has been set for the interrupting signal, it is implementation-defined whether the function restarts or returns
with [EINTR].
[EINVAL]
An invalid timeout interval was specified.
[EINVAL]
The nfds argument is less than 0 or greater than FD_SETSIZE.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The use of select() and pselect() requires that the application construct the set of file descriptors to work on
each time through a polling loop, and is inherently limited from operating on file descriptors larger than FD_SETSIZE. Also, the
amount of work to perform scales as nfds increases, even if the number of file descriptors selected within the larger set
remains the same. Thus, applications may wish to consider using poll() and ppoll() instead, for better scaling.
When a pselect() or select() call indicates a file descriptor is ready for reading, this means that if an attempt
to read data had been made at the time that the status of the file descriptor was checked, it would have returned at least one byte
of data, an end-of-file indication, or an error, without blocking (even if O_NONBLOCK is clear). When a pselect() or
select() call indicates that a file descriptor is ready for writing, this means that if an attempt to write one byte of data
had been made at the time that the status of the file descriptor was checked, it would have written that byte or returned an error,
without blocking. However, if an attempt to write more than one byte had been made, it might have blocked (if O_NONBLOCK is clear).
In both cases, by the time the call returns and a subsequent I/O operation is attempted, the state of the file descriptor might
have changed (for example, because another thread read or wrote some data) and, if O_NONBLOCK is clear, there is no guarantee that
the operation will not block (unless it would not block for some other reason, such as setting MIN=0 and TIME=0 for a terminal in
non-canonical mode). Therefore it is recommended that applications always set O_NONBLOCK on file descriptors whose readiness for
I/O they query with pselect() or select().
RATIONALE
In earlier versions of the Single UNIX Specification, the select() function was defined in the  header. This is now changed to . The rationale for this change was as follows: the introduction of
the pselect() function included the  header and the
header defines all the related definitions for the
pselect() and select() functions. Backwards-compatibility to existing XSI implementations is handled by allowing
to include .
Code which wants to avoid the ambiguity of the signal mask for thread cancellation handlers can install an additional
cancellation handler which resets the signal mask to the expected value.
void cleanup(void *arg)
{
sigset_t *ss = (sigset_t *) arg;
pthread_sigmask(SIG_SETMASK, ss, NULL);
}
int call_pselect(int nfds, fd_set *readfds, fd_set *writefds,
fd_set errorfds, const struct timespec *timeout,
const sigset_t *sigmask)
{
sigset_t oldmask;
int result;
pthread_sigmask(SIG_SETMASK, NULL, &oldmask);
pthread_cleanup_push(cleanup, &oldmask);
result = pselect(nfds, readfds, writefds, errorfds, timeout, sigmask);
pthread_cleanup_pop(0);
return result;
}
FUTURE DIRECTIONS
None.
SEE ALSO
accept(), alarm(), connect(), fcntl(), poll(), read(), recvmsg(), sendmsg(), write()
XBD ,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
In the ERRORS section, the text has been changed to indicate that [EINVAL] is returned when nfds is less than 0 or
greater than FD_SETSIZE. It previously stated less than 0, or greater than or equal to FD_SETSIZE.
Text about timeout is moved from the APPLICATION USAGE section to the DESCRIPTION.
Issue 6
The Open Group Corrigendum U026/6 is applied, changing the occurrences of readfs and writefs in the
select() DESCRIPTION to be readfds and writefds.
Text referring to sockets is added to the DESCRIPTION.
The DESCRIPTION and ERRORS sections are updated so that references to STREAMS are marked as part of the XSI STREAMS Option
Group.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
These functions are now mandatory.
The pselect() function is added for alignment with IEEE Std 1003.1g-2000 and additional detail related to
sockets semantics is added to the DESCRIPTION.
The select() function now requires inclusion of .
The restrict keyword is added to the select() prototype for alignment with the ISO/IEC 9899:1999
standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/70 is applied, updating the DESCRIPTION to reference the signal
mask in terms of the calling thread rather than the process.
Issue 7
SD5-XSH-ERN-122 is applied, adding text to the DESCRIPTION for when a thread is canceled during a call to pselect(), and
adding example code to the RATIONALE.
Functionality relating to the XSI STREAMS option is marked obsolescent.
Functionality relating to the Threads option is moved to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0446 [372] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0259 [680] is applied.
Issue 8
Austin Group Defect 220 is applied, adding const to the second parameter of FD_ISSET().
Austin Group Defect 411 is applied, adding accept4().
Austin Group Defect 1186 is applied, clarifying the behavior when the pselect() function is interrupted by a signal.
Austin Group Defect 1263 is applied, changing the APPLICATION USAGE section.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
Austin Group Defect 1448 is applied, changing the APPLICATION USAGE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_barrierattr_getpshared.html =====
pthread_barrierattr_getpshared
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_barrierattr_getpshared, pthread_barrierattr_setpshared — get and set the process-shared attribute of the
barrier attributes object
SYNOPSIS
[TSH]  #include
int pthread_barrierattr_getpshared(const pthread_barrierattr_t
*restrict attr, int *restrict pshared);
int pthread_barrierattr_setpshared(pthread_barrierattr_t *attr,
int pshared);
DESCRIPTION
The pthread_barrierattr_getpshared() function shall obtain the value of the process-shared attribute from the
attributes object referenced by attr. The pthread_barrierattr_setpshared() function shall set the
process-shared attribute in an initialized attributes object referenced by attr.
The process-shared attribute is set to PTHREAD_PROCESS_SHARED to permit a barrier to be operated upon by any thread that
has access to the memory where the barrier is allocated. See 2.9.9
Synchronization Object Copies and Alternative Mappings for further requirements. The default value of the attribute shall
be PTHREAD_PROCESS_PRIVATE. Both constants PTHREAD_PROCESS_SHARED and PTHREAD_PROCESS_PRIVATE are defined in .
Additional attributes, their default values, and the names of the associated functions to get and set those attribute values are
implementation-defined.
The behavior is undefined if the value specified by the attr argument to pthread_barrierattr_getpshared() or
pthread_barrierattr_setpshared() does not refer to an initialized barrier attributes object.
RETURN VALUE
If successful, the pthread_barrierattr_getpshared() function shall return zero and store the value of the
process-shared attribute of attr into the object referenced by the pshared parameter. Otherwise, an error
number shall be returned to indicate the error.
If successful, the pthread_barrierattr_setpshared() function shall return zero; otherwise, an error number shall be
returned to indicate the error.
ERRORS
The pthread_barrierattr_setpshared() function may fail if:
[EINVAL]
The new value specified for the process-shared attribute is not one of the legal values PTHREAD_PROCESS_SHARED or
PTHREAD_PROCESS_PRIVATE.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The pthread_barrierattr_getpshared() and pthread_barrierattr_setpshared() functions are part of the Thread
Process-Shared Synchronization option and need not be provided on all implementations.
RATIONALE
If an implementation detects that the value specified by the attr argument to pthread_barrierattr_getpshared() or
pthread_barrierattr_setpshared() does not refer to an initialized barrier attributes object, it is recommended that the
function should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_barrier_destroy(), pthread_barrierattr_destroy()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1j-2000
Issue 7
The pthread_barrierattr_getpshared() and pthread_barrierattr_setpshared() functions are marked only as part of the
Thread Process-Shared Synchronization option as the Threads option is now part of the Base.
The [EINVAL] error for an uninitialized barrier attributes object is removed; this condition results in undefined behavior.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0266 [972] and XSH/TC2-2008/0267 [757] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/log1p.html =====
log1p
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
log1p, log1pf, log1pl — compute a natural logarithm
SYNOPSIS
#include
double log1p(double x);
float log1pf(float x);
long double log1pl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute loge(1.0 + x).
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the natural logarithm of 1.0 + x.
If x is -1, a pole error shall occur and log1p(), log1pf(), and log1pl() shall return -HUGE_VAL,
-HUGE_VALF, and -HUGE_VALL, respectively.
For finite values of x that are less than -1, [MX]   or if x is -Inf,  a domain error shall occur, and [MX]   either a NaN (if supported), or   an implementation-defined value shall be returned.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, or +Inf, x shall be returned.
[MXX]
If x is subnormal, x should be returned.
[MX]  If x is subnormal, a range error may occur and, if x is
not returned, log1p(), log1pf(), and log1pl() shall return an implementation-defined value no greater in
magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
ERRORS
These functions shall fail if:
Domain Error
The finite value of x is less than -1, [MX]   or x is -Inf.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
Pole Error
The value of x is -1.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the divide-by-zero floating-point exception shall
be raised.
These functions may fail if:
Range Error
[MX]
The value of x is subnormal.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), log()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
The log1p() function is no longer marked as an extension.
The log1pf() and log1pl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0364 [68] is applied.
Issue 8
Austin Group Defect 1382 is applied, rearranging the text describing the behavior when x is subnormal to avoid the need
for two shading changes.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/asinhl.html =====
asinh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
asinh, asinhf, asinhl — inverse hyperbolic sine functions
SYNOPSIS
#include
double asinh(double x);
float asinhf(float x);
long double asinhl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the inverse hyperbolic sine of their argument x.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the inverse hyperbolic sine of their argument.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, or ±Inf, x shall be returned.
[MXX]
If x is subnormal, x should be returned.
[MX]  If x is subnormal, a range error may occur and, if x is
not returned, asinh(), asinhf(), and asinhl() shall return an implementation-defined value no greater in
magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
ERRORS
These functions may fail if:
Range Error
[MX]
The value of x is subnormal.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), sinh()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The asinh() function is no longer marked as an extension.
The asinhf() and asinhl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0036 [68] is applied.
Issue 8
Austin Group Defect 1382 is applied, rearranging the text describing the behavior when x is subnormal to avoid the need
for two shading changes.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ppoll.html =====
poll
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
poll, ppoll — input/output multiplexing
SYNOPSIS
#include
int poll(struct pollfd fds[], nfds_t nfds, int timeout);
int ppoll(struct pollfd fds[], nfds_t nfds,
const struct timespec *restrict timeout,
const sigset_t *restrict sigmask);
DESCRIPTION
The ppoll() function provides applications with a mechanism for multiplexing input/output over a set of file descriptors.
For each member of the array pointed to by fds, ppoll() shall examine the given file descriptor for the event(s)
specified in events. The number of pollfd structures in the fds array is specified by nfds. The
ppoll() function shall identify those file descriptors on which an application can make an attempt to read or write data
without blocking, or on which certain events have occurred.
The poll() function shall be equivalent to the ppoll() function, except as follows:
For the poll() function, the timeout period is given in milliseconds in an argument of type int, whereas for the
ppoll() function the timeout period is given in seconds and nanoseconds via an argument of type pointer to struct
timespec. A timeout of -1 for poll() shall be equivalent to passing a null pointer for the timeout for
ppoll().
The poll() function has no sigmask argument; it shall behave as ppoll() does when sigmask is a null
pointer.
The fds argument specifies the file descriptors to be examined and the events of interest for each file descriptor. It is
a pointer to an array with one member for each open file descriptor of interest. The array's members are pollfd structures
within which fd specifies an open file descriptor and events and revents are bitmasks constructed by OR'ing a
combination of the following event flags:
POLLIN
The file descriptor is ready for reading data other than high-priority data.
POLLRDNORM
The file descriptor is ready for reading normal data.
POLLRDBAND
The file descriptor is ready for reading priority data.
POLLPRI
The file descriptor is ready for reading high-priority data.
POLLOUT
The file descriptor is ready for writing normal data.
POLLWRNORM
Equivalent to POLLOUT.
POLLWRBAND
The file descriptor is ready for writing priority data.
POLLERR
An error condition is present on the file descriptor. All error conditions that arise solely from the state of the object
underlying the open file description and would be diagnosed by a return of -1 from a read() or write() call on the file descriptor
shall be reported as a POLLERR event. This flag is only valid in the revents bitmask; it shall be ignored in the
events member.
POLLHUP
A device has been disconnected, or a pipe or FIFO has been closed by the last process that had it open for writing. Once set,
the hangup state of a FIFO shall persist until some process opens the FIFO for writing or until all read-only file descriptors for
the FIFO are closed. This event and POLLOUT are mutually-exclusive. However, this event and POLLIN, POLLRDNORM, POLLRDBAND, or
POLLPRI are not mutually-exclusive. This flag is only valid in the revents bitmask; it shall be ignored in the events
member.
POLLNVAL
The specified fd value is not an open file descriptor. This flag is only valid in the revents member; it shall be
ignored in the events member.
A file descriptor shall be considered ready for reading when a call to an input function with O_NONBLOCK clear would not block,
whether or not the function would transfer data successfully. (The function might return data, an end-of-file indication, or an
error other than one indicating that it is blocked, and in each of these cases the descriptor is considered ready for reading.) A
file descriptor shall be considered ready for writing when a call to an output function with O_NONBLOCK clear would not block,
whether or not the function would transfer data successfully. How much data could be written without blocking depends upon the
object underlying the open file description and its current state.
The significance and semantics of normal, priority, and high-priority data are file and device-specific. The semantics of device
disconnection are device-specific.
If the value of fd is less than 0, events shall be ignored, and revents shall be set to 0 in that entry on
return from poll() or ppoll().
In each pollfd structure, poll() or ppoll() shall clear the revents member, except that where the
application requested a report on a condition by setting one of the bits of events listed above, poll() or
ppoll() shall set the corresponding bit in revents if the requested condition is true. In addition, poll() or
ppoll() shall set the POLLHUP, POLLERR, and POLLNVAL flag in revents if the condition is true, even if the
application did not set the corresponding bit in events.
The timeout argument controls how long the poll() or ppoll() function shall wait before timing out. If the
timeout argument is positive for poll() or not a null pointer for ppoll(), it specifies a maximum interval to
wait for the poll to complete. If the specified time interval expires without any of the defined events having occurred, the
function shall return. If the timeout argument is -1 for poll() or a null pointer for ppoll(), then the call
shall block indefinitely until at least one descriptor meets the specified criteria or until the call is interrupted. To effect a
poll, the application shall ensure that the timeout argument for poll() is 0, or for ppoll() is not a null
pointer and points to a zero-valued timespec structure.
Implementations may place limitations on the maximum timeout interval supported. All implementations shall support a maximum
timeout interval of at least 31 days for ppoll(). If the timeout argument specifies a timeout interval greater than
the implementation-defined maximum value, the maximum value shall be used as the actual timeout value. Implementations may also
place limitations on the granularity of timeout intervals. If the requested timeout interval requires a finer granularity than the
implementation supports, the actual timeout interval shall be rounded up to the next supported value.
The poll() and ppoll() functions shall not be affected by the O_NONBLOCK flag.
The poll() and ppoll() functions shall support regular files, terminal and pseudo-terminal devices, FIFOs, pipes,
and sockets. The behavior of poll() and ppoll() on elements of fds that refer to other types of file is
unspecified.
Regular files shall always poll TRUE for reading and writing.
A file descriptor for a socket that is listening for connections shall indicate that it is ready for reading, once connections
are available. A file descriptor for a socket that is connecting asynchronously shall indicate that it is ready for writing, once a
connection has been established.
Provided the application does not perform any action that results in unspecified or undefined behavior, the value of the
fd and events members of each element of fds shall not be modified by poll() or ppoll().
If sigmask is not a null pointer, the ppoll() function shall replace the signal mask of the caller by the set of
signals pointed to by sigmask before examining the descriptors, and shall restore the signal mask of the calling thread
before returning. If a signal is unmasked as a result of the signal mask being altered by ppoll(), and a signal-catching
function is called for that signal during the execution of the ppoll() function, and SA_RESTART is clear for the
interrupting signal, then
If none of the defined events have occurred on any selected file descriptor, ppoll() shall immediately fail with the
[EINTR] error after the signal-catching function returns.
If one or more of the defined events have occurred, it is unspecified whether ppoll() behaves the same as if none of the
events had occurred (failing with [EINTR] as above) or behaves the same as if it was not interrupted (returning the total number of
pollfd structures that have selected events).
If a thread is canceled during a ppoll() call, it is unspecified whether the signal mask in effect when executing the
registered cleanup functions is the original signal mask or the signal mask installed as part of the ppoll() call.
RETURN VALUE
Upon successful completion, a non-negative value shall be returned. A positive value shall indicate the total number of
pollfd structures that have selected events (that is, those for which the revents member is non-zero). A value of 0
shall indicate that the call timed out and no file descriptors have been selected. Upon failure, -1 shall be returned and
errno set to indicate the error.
ERRORS
The poll() and ppoll() functions shall fail if:
[EAGAIN]
The allocation of internal data structures failed but a subsequent request may succeed.
[EINTR]
A signal was caught during poll() or ppoll().
[EINVAL]
The nfds argument is greater than {OPEN_MAX}.
The ppoll() function shall fail if:
[EINVAL]
An invalid timeout interval was specified.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Other than the difference in the precision of the requested timeout, the following ppoll() call:
ready = ppoll(&fds, nfds, tmo_p, &sigmask);
is equivalent to atomically executing the following calls:
sigset_t origmask;
int timeout;
timeout = (tmo_p == NULL) ? -1 :
(tmo_p->tv_sec * 1000 + tmo_p->tv_nsec / 1000000);
pthread_sigmask(SIG_SETMASK, &sigmask, &origmask);
ready = poll(&fds, nfds, timeout);
pthread_sigmask(SIG_SETMASK, &origmask, NULL);
When a poll() or ppoll() call indicates a file descriptor is ready for reading, this means that if an attempt to
read data had been made at the time that the status of the file descriptor was checked, it would have returned at least one byte of
data, an end-of-file indication, or an error, without blocking (even if O_NONBLOCK is clear). When a poll() or
ppoll() call indicates that a file descriptor is ready for writing, this means that if an attempt to write one byte of data
had been made at the time that the status of the file descriptor was checked, it would have written that byte or returned an error,
without blocking. However, if an attempt to write more than one byte had been made, it might have blocked (if O_NONBLOCK is clear).
In both cases, by the time the call returns and a subsequent I/O operation is attempted, the state of the file descriptor might
have changed (for example, because another thread read or wrote some data) and, if O_NONBLOCK is clear, there is no guarantee that
the operation will not block (unless it would not block for some other reason, such as setting MIN=0 and TIME=0 for a terminal in
non-canonical mode). Therefore it is recommended that applications always set O_NONBLOCK on file descriptors whose readiness for
I/O they query with poll() or ppoll().
The error conditions specified for read() and write() that are reported as POLLERR events are only those that arise solely from the state of
the object underlying the open file description. They do not include, for example, [EAGAIN] as this relates to the state of the
open file description not (solely) the object underlying it.
Application writers should note that repeating a poll() or ppoll() call which indicated that I/O was possible on
one or more of the file descriptors given, without causing some change to the state, either by altering the fds array or
causing appropriate input or output to occur on at least one file descriptor indicated as ready, will result in "busy waiting"—a
subsequent call will always return immediately indicating the same (or perhaps more) events as the previous one.
RATIONALE
The POLLHUP event does not occur for FIFOs just because the FIFO is not open for writing. It only occurs when the FIFO is closed
by the last writer and persists until some process opens the FIFO for writing or until all read-only file descriptors for the FIFO
are closed.
Code which wants to avoid the ambiguity of the signal mask for thread cancellation handlers can install an additional
cancellation handler which resets the signal mask to the expected value:
void cleanup(void *arg)
{
sigset_t *ss = (sigset_t *) arg;
pthread_sigmask(SIG_SETMASK, ss, NULL);
}
int call_ppoll(struct pollfd fds[], nfds_t nfds,
const struct timespec *restrict timeout,
const sigset_t *restrict sigmask)
{
sigset_t oldmask;
int result;
pthread_sigmask(SIG_SETMASK, NULL, &oldmask);
pthread_cleanup_push(cleanup, &oldmask);
result = ppoll(fds, nfds, timeout, sigmask);
pthread_cleanup_pop(0);
return result;
}
FUTURE DIRECTIONS
None.
SEE ALSO
pselect(), read(),
write()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
The description of POLLWRBAND is updated.
Issue 6
Text referring to sockets is added to the DESCRIPTION.
Functionality relating to the XSI STREAMS Option Group is marked.
The Open Group Corrigendum U055/3 is applied, updating the DESCRIPTION of POLLWRBAND.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/66 is applied, correcting the spacing in the EXAMPLES
section.
Issue 7
Austin Group Interpretation 1003.1-2001 #209 is applied, clarifying the POLLHUP event.
The poll() function is moved from the XSI option to the Base.
Functionality relating to the XSI STREAMS option is marked obsolescent.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0249 [623] and XSH/TC2-2008/0250 [683] are applied.
Issue 8
Austin Group Defect 1263 is applied, adding ppoll().
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
Austin Group Defect 1448 is applied, aligning the wording relating to file descriptor readiness with pselect() and changing the APPLICATION USAGE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/iconv.html =====
iconv
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
iconv — codeset conversion function
SYNOPSIS
#include
size_t iconv(iconv_t cd, char **restrict inbuf,
size_t *restrict inbytesleft, char **restrict outbuf,
size_t *restrict outbytesleft);
DESCRIPTION
The iconv() function shall convert the sequence of characters from one codeset, in the array specified by inbuf,
into a sequence of corresponding characters in another codeset, in the array specified by outbuf. The codesets are those
specified in the iconv_open() call that returned the conversion descriptor,
cd. The inbuf argument points to a variable that points to the first character in the input buffer and
inbytesleft indicates the number of bytes to the end of the buffer to be converted. The outbuf argument points to a
variable that points to the first available byte in the output buffer and outbytesleft indicates the number of the available
bytes to the end of the buffer.
For state-dependent encodings, the conversion descriptor cd is placed into its initial shift state by a call for which
inbuf is a null pointer, or for which inbuf points to a null pointer. When iconv() is called in this way, and
if outbuf is not a null pointer or a pointer to a null pointer, and outbytesleft points to a positive value,
iconv() shall place, into the output buffer, the byte sequence to change the output buffer to its initial shift state. If
the output buffer is not large enough to hold the entire reset sequence, iconv() shall fail and set errno to [E2BIG].
Subsequent calls with inbuf as other than a null pointer or a pointer to a null pointer cause the conversion to take place
from the current state of the conversion descriptor.
If a sequence of input bytes does not form a valid character or shift sequence in the input codeset:
If the //IGNORE indicator suffix was specified when the conversion descriptor cd was opened and the byte sequence is
immediately followed by a valid character or shift sequence, the sequence of bytes shall be discarded and conversion shall continue
from the immediately following valid character or shift sequence. This shall not be treated as an error.
If the //IGNORE indicator suffix was not specified when the conversion descriptor cd was opened, conversion shall stop
after the previous successfully converted character or shift sequence.
If the input buffer ends with an incomplete character or shift sequence, conversion shall stop after the previous successfully
converted bytes. If the output buffer is not large enough to hold the entire converted input, conversion shall stop just prior to
the input bytes that would cause the output buffer to overflow. The variable pointed to by inbuf shall be updated to point
to the byte following the last byte successfully used in the conversion. The value pointed to by inbytesleft shall be
decremented to reflect the number of bytes still not converted in the input buffer. The variable pointed to by outbuf shall
be updated to point to the byte following the last byte of converted output data. The value pointed to by outbytesleft shall
be decremented to reflect the number of bytes still available in the output buffer. For state-dependent encodings, the conversion
descriptor shall be updated to reflect the shift state in effect at the end of the last successfully converted byte sequence.
If iconv() encounters a character in the input buffer that is valid, but for which an identical character does not exist
in the output codeset:
If either the //IGNORE or the //NON_IDENTICAL_DISCARD indicator suffix was specified when the conversion descriptor cd
was opened, the character shall be discarded but shall still be counted in the return value of the iconv() call.
If the //TRANSLIT indicator suffix was specified when the conversion descriptor cd was opened, an implementation-defined
transliteration shall be performed, if possible, to convert the character into one or more characters of the output codeset that
best resemble the input character. The character shall be counted as one character in the return value of the iconv() call,
regardless of the number of output characters.
If no indicator suffix was specified when the conversion descriptor cd was opened, or the //TRANSLIT indicator suffix was
specified but no transliteration of the character is possible, iconv() shall perform an implementation-defined conversion on
the character and it shall be counted in the return value of the iconv() call.
RETURN VALUE
The iconv() function shall update the variables pointed to by the arguments to reflect the extent of the conversion and
shall return the number of input characters that could not be converted to an identical output character. If the entire string in
the input buffer is converted, except for any byte sequences discarded as a result of the //IGNORE indicator suffix, the value
pointed to by inbytesleft shall be 0. If the input conversion is stopped due to any conditions mentioned above, the value
pointed to by inbytesleft shall be non-zero and errno shall be set to indicate the condition. If an error occurs,
iconv() shall return (size_t)-1 and set errno to indicate the error.
ERRORS
The iconv() function shall fail if:
[EILSEQ]
Input conversion stopped due to an input byte that does not belong to the input codeset.
[E2BIG]
Input conversion stopped due to lack of space in the output buffer.
[EINVAL]
Input conversion stopped due to an incomplete character or shift sequence at the end of the input buffer.
The iconv() function may fail if:
[EBADF]
The cd argument is not a valid open conversion descriptor.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The inbuf argument indirectly points to the memory area which contains the conversion input data. The outbuf
argument indirectly points to the memory area which is to contain the result of the conversion. The objects indirectly pointed to
by inbuf and outbuf are not restricted to containing data that is directly representable in the ISO C standard
language char data type. The type of inbuf and outbuf, char **, does not imply that the objects pointed
to are interpreted as null-terminated C strings or arrays of characters. Any interpretation of a byte sequence that represents a
character in a given character set encoding scheme is done internally within the codeset converters. For example, the area pointed
to indirectly by inbuf and/or outbuf can contain all zero octets that are not interpreted as string terminators but
as coded character data according to the respective codeset encoding scheme. The type of the data (char, short,
long, and so on) read or stored in the objects is not specified, but may be inferred for both the input and output data by
the converters determined by the fromcode and tocode arguments of iconv_open().
Regardless of the data type inferred by the converter, the size of the remaining space in both input and output objects (the
intbytesleft and outbytesleft arguments) is always measured in bytes.
For implementations that support the conversion of state-dependent encodings, the conversion descriptor must be able to
accurately reflect the shift-state in effect at the end of the last successful conversion. It is not required that the conversion
descriptor itself be updated, which would require it to be a pointer type. Thus, implementations are free to implement the
descriptor as a handle (other than a pointer type) by which the conversion information can be accessed and updated.
It is the responsibility of the application to ensure that, if the output codeset has a locking-shift encoding, the output
buffer is returned to its initial shift state when conversion is completed. This can be accomplished by calling iconv() with
inbuf as a null pointer, or with inbuf pointing to a null pointer, before calling iconv_close(). Since the standard does not provide a way to query whether a codeset has
a locking-shift encoding, it is recommended that applications always call iconv() in this way before calling iconv_close().
When the //IGNORE indicator suffix was used to open the conversion descriptor, iconv() does not provide any indication of
whether any invalid input byte sequences were discarded. Applications which need to detect the discarding of invalid input byte
sequences can open the conversion descriptor without using //IGNORE and then call iconv() in a loop such that if it returns
an [EILSEQ] error, the application increments the variable pointed to by inbuf and decrements the variable pointed to by
inbytesleft before the next call. This technique can also be used by applications which need to use //TRANSLIT but also
discard invalid input byte sequences.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
iconv_open(), iconv_close(), mbsrtowcs()
XBD
CHANGE HISTORY
First released in Issue 4. Derived from the HP-UX Manual.
Issue 6
The SYNOPSIS has been corrected to align with the  reference
page.
The restrict keyword is added to the iconv() prototype for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
The iconv() function is moved from the XSI option to the Base.
Issue 8
Austin Group Defect 1007 is applied, adding support for indicator suffixes in the tocode argument to iconv_open().
Austin Group Defect 1008 is applied, adding a paragraph about locking-shift encodings to the APPLICATION USAGE section.
Austin Group Defect 1438 is applied, changing "valid character in the specified codeset" to "valid character in the specified
input codeset".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/cfgetispeed.html =====
cfgetispeed
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cfgetispeed — get input baud rate
SYNOPSIS
#include
speed_t cfgetispeed(const struct termios *termios_p);
DESCRIPTION
The cfgetispeed() function shall extract the input baud rate from the termios structure to which the
termios_p argument points.
This function shall return exactly the value in the termios data structure, without interpretation.
RETURN VALUE
Upon successful completion, cfgetispeed() shall return a value of type speed_t representing the input baud
rate.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The term "baud" is used historically here, but is not technically correct. This is properly "bits per second", which may not
be the same as baud. However, the term is used because of the historical usage and understanding.
The cfgetospeed(), cfgetispeed(), cfsetospeed(), and cfsetispeed()
functions do not take arguments as numbers, but rather as symbolic names. There are two reasons for this:
Historically, numbers were not used because of the way the rate was stored in the data structure. This is retained even though a
function is now used.
More importantly, only a limited set of possible rates is at all portable, and this constrains the application to that set.
There is nothing to prevent an implementation accepting as an extension a number (such as 126), and since the encoding of the
Bxxx symbols is not specified, this can be done to avoid introducing ambiguity.
Setting the input baud rate to zero was a mechanism to allow for split baud rates. Clarifications in this volume of POSIX.1-2024
have made it possible to determine whether split rates are supported and to support them without having to treat zero as a special
case. Since this functionality is also confusing, it has been declared obsolescent. The 0 argument referred to is the literal
constant 0, not the symbolic constant B0. This volume of POSIX.1-2024 does not preclude B0 from being defined as the value 0; in
fact, implementations would likely benefit from the two being equivalent. This volume of POSIX.1-2024 does not fully specify
whether the previous cfsetispeed() value is retained after a tcgetattr() as the actual value or as zero. Therefore, conforming applications should
always set both the input speed and output speed when setting either.
In historical implementations, the baud rate information is traditionally kept in c_cflag. Applications should be written
to presume that this might be the case (and thus not blindly copy c_cflag), but not to rely on it in case it is in some
other field of the structure. Setting the c_cflag field absolutely after setting a baud rate is a non-portable action
because of this. In general, the unused parts of the flag fields might be used by the implementation and should not be blindly
copied from the descriptions of one terminal device to another.
FUTURE DIRECTIONS
None.
SEE ALSO
cfgetospeed(), cfsetispeed(), cfsetospeed(),
tcgetattr()
XBD 11. General Terminal Interface,
CHANGE HISTORY
First released in Issue 3. Included for alignment with the POSIX.1-1988 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/casinh.html =====
casinh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
casinh, casinhf, casinhl — complex arc hyperbolic sine functions
SYNOPSIS
#include
double complex casinh(double complex z);
float complex casinhf(float complex z);
long double complex casinhl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex arc hyperbolic sine of z, with branch cuts outside the interval
[-i, +i] along the imaginary axis.
RETURN VALUE
These functions shall return the complex arc hyperbolic sine value, in the range of a strip mathematically unbounded along the
real axis and in the interval [-iℼ/2, +iℼ/2] along the imaginary axis.
[MXC]
casinh(conj(z)), casinhf(conjf(z)), and casinhl(conjl(z)) shall
return exactly the same value as conj(casinh(z)), conjf(casinhf(z)), and
conjl(casinhl(z)), respectively, and casinh(-z), casinhf(-z), and
casinhl(-z) shall return exactly the same value as -casinh(z), -casinhf(z), and
-casinhl(z), respectively, including for the special values of z below.
If z is +0 + i0, 0 + i0 shall be returned.
If z is x + iInf where x is positive-signed and finite, +Inf + iℼ/2 shall be returned.
If z is x + iNaN where x is finite, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is +Inf + iy where y is positive-signed and finite, +Inf + i0 shall be returned.
If z is +Inf + iInf, +Inf + iℼ/4 shall be returned.
If z is +Inf + iNaN, +Inf + iNaN shall be returned.
If z is NaN + i0, NaN + i0 shall be returned.
If z is NaN + iy where y is non-zero and finite, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is NaN + iInf, ±Inf + iNaN shall be returned; the sign of the real part of the result is
unspecified.
If z is NaN + iNaN, NaN + iNaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
csinh()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/csqrt.html =====
csqrt
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
csqrt, csqrtf, csqrtl — complex square root functions
SYNOPSIS
#include
double complex csqrt(double complex z);
float complex csqrtf(float complex z);
long double complex csqrtl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex square root of z, with a branch cut along the negative real axis.
RETURN VALUE
These functions shall return the complex square root value, in the range of the right half-plane (including the imaginary
axis).
[MXC]
csqrt(conj(z)), csqrtf(conjf(z)), and csqrtl(conjl(z)) shall return
exactly the same value as conj(csqrt(z)), conjf(csqrtf(z)), and
conjl(csqrtl(z)), respectively, including for the special values of z below.
If z is ±0 + i0, +0 + i0 shall be returned.
If the imaginary part of z is Inf, +Inf + iInf, shall be returned.
If z is x + iNaN where x is finite, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is -Inf + iy where y is positive-signed and finite, +0 + iInf shall be returned.
If z is +Inf + iy where y is positive-signed and finite, +Inf + i0 shall be returned.
If z is -Inf + iNaN, NaN ± iInf shall be returned; the sign of the imaginary part of the result is
unspecified.
If z is +Inf + iNaN, +Inf + iNaN shall be returned.
If z is NaN + iy where y is finite, NaN + iNaN shall be returned and the invalid floating-point
exception may be raised.
If z is NaN + iNaN, NaN + iNaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
cabs(), cpow()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_mutex_timedlock.html =====
pthread_mutex_clocklock
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_mutex_clocklock, pthread_mutex_timedlock — lock a mutex
SYNOPSIS
#include
int pthread_mutex_clocklock(pthread_mutex_t *restrict mutex,
clockid_t clock_id, const struct timespec *restrict
abstime);
int pthread_mutex_timedlock(pthread_mutex_t *restrict mutex,
const struct timespec *restrict abstime);
DESCRIPTION
The pthread_mutex_clocklock() and pthread_mutex_timedlock() functions shall lock the mutex object referenced by
mutex. If the mutex is already locked, the calling thread shall block until the mutex becomes available as in the pthread_mutex_lock() function. If the mutex cannot be locked without waiting for
another thread to unlock the mutex, this wait shall be terminated when the specified timeout expires.
The timeout shall expire when the absolute time specified by abstime passes, as measured by the clock on which timeouts
are based (that is, when the value of that clock equals or exceeds abstime), or if the absolute time specified by
abstime has already been passed at the time of the call.
For pthread_mutex_timedlock(), the timeout shall be based on the CLOCK_REALTIME clock. For
pthread_mutex_clocklock(), the timeout shall be based on the clock specified by the clock_id argument. The resolution
of the timeout shall be the resolution of the clock on which it is based. Implementations shall support passing CLOCK_REALTIME and
CLOCK_MONOTONIC to pthread_mutex_clocklock() as the clock_id argument.
Under no circumstance shall the function fail with a timeout if the mutex can be locked immediately. The validity of the
abstime parameter need not be checked if the mutex can be locked immediately.
[RPI|TPI]  As a consequence of the priority inheritance rules (for mutexes initialized with the PRIO_INHERIT protocol), if a timed mutex
wait is terminated because its timeout expires, the priority of the owner of the mutex shall be adjusted as necessary to reflect
the fact that this thread is no longer among the threads waiting for the mutex.
If mutex is a robust mutex and the process containing the owning thread terminated while holding the mutex lock, a call
to pthread_mutex_clocklock() or pthread_mutex_timedlock() shall return the error value [EOWNERDEAD]. If mutex
is a robust mutex and the owning thread terminated while holding the mutex lock, a call to pthread_mutex_clocklock() or
pthread_mutex_timedlock() may return the error value [EOWNERDEAD] even if the process in which the owning thread resides has
not terminated. In these cases, the mutex is locked by the thread but the state it protects is marked as inconsistent. The
application should ensure that the state is made consistent for reuse and when that is complete call pthread_mutex_consistent(). If the application is unable to recover the
state, it should unlock the mutex without a prior call to pthread_mutex_consistent(), after which the mutex is marked permanently
unusable.
If mutex does not refer to an initialized mutex object, the behavior is undefined.
RETURN VALUE
If successful, the pthread_mutex_clocklock() and pthread_mutex_timedlock() functions shall return zero; otherwise,
an error number shall be returned to indicate the error.
ERRORS
The pthread_mutex_clocklock() and pthread_mutex_timedlock() functions shall fail if:
[EAGAIN]
The mutex could not be acquired because the maximum number of recursive locks for mutex has been exceeded.
[EAGAIN]
The mutex is a robust mutex and the system resources available for robust mutexes owned would be exceeded.
[EDEADLK]
The mutex type is PTHREAD_MUTEX_ERRORCHECK and the current thread already owns the mutex.
[EINVAL]
The mutex was created with the protocol attribute having the value PTHREAD_PRIO_PROTECT and the calling thread's priority is
higher than the mutex' current priority ceiling.
[EINVAL]
The process or thread would have blocked, and either the abstime parameter specified a nanoseconds field value less than
zero or greater than or equal to 1000 million, or the pthread_mutex_clocklock() function was passed an invalid or
unsupported clock_id value.
[ENOTRECOVERABLE]
The state protected by the mutex is not recoverable.
[EOWNERDEAD]
The mutex is a robust mutex and the process containing the previous owning thread terminated while holding the mutex lock. The
mutex lock shall be acquired by the calling thread and it is up to the new owner to make the state consistent.
[ETIMEDOUT]
The mutex could not be locked before the specified timeout expired.
The pthread_mutex_clocklock() and pthread_mutex_timedlock() functions may fail if:
[EDEADLK]
A deadlock condition was detected.
[EOWNERDEAD]
The mutex is a robust mutex and the previous owning thread terminated while holding the mutex lock. The mutex lock shall be
acquired by the calling thread and it is up to the new owner to make the state consistent.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications that have assumed that non-zero return values are errors will need updating for use with robust mutexes, since a
valid return for a thread acquiring a mutex which is protecting a currently inconsistent state is [EOWNERDEAD]. Applications that
do not check the error returns, due to ruling out the possibility of such errors arising, should not use robust mutexes. If an
application is supposed to work with normal and robust mutexes, it should check all return values for error conditions and if
necessary take appropriate action.
RATIONALE
Refer to pthread_mutex_lock().
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_mutex_destroy(), pthread_mutex_lock(), time()
XBD 4.15.2 Memory Synchronization, ,
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1d-1999.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/99 is applied, marking the last paragraph in the DESCRIPTION as
part of the Thread Priority Inheritance option.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/100 is applied, updating the ERRORS section so that the
[EDEADLK] error includes detection of a deadlock condition.
Issue 7
Changes are made from The Open Group Technical Standard, 2006, Extended API Set Part 3.
The pthread_mutex_timedlock() function is moved from the Timeouts option to the Base.
Functionality relating to the Timers option is moved to the Base.
The DESCRIPTION is updated to clarify the behavior when mutex does not refer to an initialized mutex.
The ERRORS section is updated to account properly for all of the various mutex types.
Issue 8
Austin Group Defect 354 is applied, adding the [EAGAIN] error for exceeding system resources available for robust mutexes
owned.
Austin Group Defect 592 is applied, removing text relating to  from
the SYNOPSIS and DESCRIPTION sections.
Austin Group Defects 1216 and 1472 are applied, adding pthread_mutex_clocklock().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/isalpha_l.html =====
isalpha
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
isalpha, isalpha_l — test for an alphabetic character
SYNOPSIS
#include
int isalpha(int c);
[CX]  int isalpha_l(int c, locale_t locale);
DESCRIPTION
For isalpha(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The isalpha() [CX]   and isalpha_l()
functions shall test whether c is a character of class alpha in the current locale, [CX]   or in the
locale represented by locale,  respectively; see XBD 7. Locale.
The c argument is an int, the value of which the application shall ensure is representable as an unsigned
char or equal to the value of the macro EOF. If the argument has any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to isalpha_l() is the special locale object LC_GLOBAL_LOCALE or is not a
valid locale object handle.
RETURN VALUE
The isalpha() [CX]   and isalpha_l()
functions shall return non-zero if c is an alphabetic character; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
isalnum(), isblank(), iscntrl(), isdigit(), isgraph(), islower(), isprint(), ispunct(), isspace(), isupper(), isxdigit(), setlocale(), uselocale()
XBD 7. Locale, , ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The isalpha_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0277 [302], XSH/TC1-2008/0278 [283], and XSH/TC1-2008/0279 [283] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_rwlock_clockwrlock.html =====
pthread_rwlock_clockwrlock
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_rwlock_clockwrlock, pthread_rwlock_timedwrlock — lock a read-write lock for writing
SYNOPSIS
#include
int pthread_rwlock_clockwrlock(pthread_rwlock_t *restrict rwlock,
clockid_t clock_id, const struct timespec *restrict
abstime);
int pthread_rwlock_timedwrlock(pthread_rwlock_t *restrict rwlock,
const struct timespec *restrict abstime);
DESCRIPTION
The pthread_rwlock_clockwrlock() and pthread_rwlock_timedwrlock() functions shall apply a write lock to the
read-write lock referenced by rwlock as in the pthread_rwlock_wrlock() function. However, if the lock cannot be acquired
without waiting for other threads to unlock the lock, this wait shall be terminated when the specified timeout expires. The timeout
shall expire when the absolute time specified by abstime passes, as measured by the clock on which timeouts are based (that
is, when the value of that clock equals or exceeds abstime), or if the absolute time specified by abstime has already
been passed at the time of the call.
For pthread_rwlock_timedwrlock(), the timeout shall be based on the CLOCK_REALTIME clock. For
pthread_rwlock_clockwrlock(), the timeout shall be based on the clock specified by the clock_id argument. The
resolution of the timeout shall be the resolution of the clock on which it is based. Implementations shall support passing
CLOCK_REALTIME and CLOCK_MONOTONIC to pthread_rwlock_clockwrlock() as the clock_id argument.
Under no circumstances shall the function fail with a timeout if the lock can be acquired immediately. The validity of the
abstime parameter need not be checked if the lock can be immediately acquired.
If a signal that causes a signal handler to be executed is delivered to a thread blocked on a read-write lock via a call to
pthread_rwlock_clockwrlock() or pthread_rwlock_timedwrlock(), upon return from the signal handler the thread shall
resume waiting for the lock as if it was not interrupted.
The calling thread may deadlock if at the time the call is made it holds the read-write lock. The results are undefined if these
functions are called with an uninitialized read-write lock.
RETURN VALUE
The pthread_rwlock_clockwrlock() and pthread_rwlock_timedwrlock() functions shall return zero if the lock for
writing on the read-write lock object referenced by rwlock is acquired. Otherwise, an error number shall be returned to
indicate the error.
ERRORS
The pthread_rwlock_clockwrlock() and pthread_rwlock_timedwrlock() functions shall fail if:
[ETIMEDOUT]
The lock could not be acquired before the specified timeout expired.
The pthread_rwlock_clockwrlock() and pthread_rwlock_timedwrlock() functions may fail if:
[EDEADLK]
A deadlock condition was detected or the calling thread already holds the rwlock.
[EINVAL]
The abstime nanosecond value is less than zero or greater than or equal to 1000 million, or the
pthread_rwlock_clockwrlock() function was passed an invalid or unsupported clock_id value.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications using these functions may be subject to priority inversion, as discussed in XBD 3.275 Priority Inversion.
RATIONALE
If an implementation detects that the value specified by the rwlock argument to pthread_rwlock_clockwrlock() or
pthread_rwlock_timedwrlock() does not refer to an initialized read-write lock object, it is recommended that the function
should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_rwlock_clockrdlock(), pthread_rwlock_destroy(), pthread_rwlock_rdlock(), pthread_rwlock_trywrlock(), pthread_rwlock_unlock()
XBD 3.275 Priority Inversion, 4.15.2 Memory Synchronization, ,
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1j-2000.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/103 is applied, updating the ERRORS section so that the
[EDEADLK] error includes detection of a deadlock condition.
Issue 7
The pthread_rwlock_timedwrlock() function is moved from the Timeouts option to the Base.
The [EINVAL] error for an uninitialized read-write lock object is removed; this condition results in undefined behavior.
Issue 8
Austin Group Defect 592 is applied, removing text relating to  from
the SYNOPSIS and DESCRIPTION sections.
Austin Group Defects 1216 and 1472 are applied, adding pthread_rwlock_clockwrlock().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getlogin.html =====
getlogin
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getlogin, getlogin_r — get login name
SYNOPSIS
#include
char *getlogin(void);
int getlogin_r(char *name, size_t namesize);
DESCRIPTION
The getlogin() function shall return a pointer to a string containing the user name associated by the login activity with
the controlling terminal of the current process. If getlogin() returns a non-null pointer, then that pointer points to the
name that the user logged in under, even if there are several login names with the same user ID.
The getlogin() function need not be thread-safe.
The getlogin_r() function shall put the name associated by the login activity with the controlling terminal of the
current process in the character array pointed to by name. The array is namesize characters long and should have
space for the name and the terminating null character. The maximum size of the login name is {LOGIN_NAME_MAX}.
If getlogin_r() is successful, name points to the name the user used at login, even if there are several login
names with the same user ID.
The getlogin() and getlogin_r() functions may make use of file descriptors 0, 1, and 2 to find the controlling
terminal of the current process, examining each in turn until the terminal is found. If in this case none of these three file
descriptors is open to the controlling terminal, these functions may fail. The method used to find the terminal associated with a
file descriptor may depend on the file descriptor being open to the actual terminal device, not /dev/tty.
RETURN VALUE
Upon successful completion, getlogin() shall return a pointer to the login name or a null pointer if the user's login
name cannot be found. Otherwise, it shall return a null pointer and set errno to indicate the error.
The application shall not modify the string returned. The returned pointer might be invalidated or the string content might be
overwritten by a subsequent call to getlogin(). The returned pointer and the string content might also be invalidated if the
calling thread is terminated.
If successful, the getlogin_r() function shall return zero; otherwise, an error number shall be returned to indicate the
error.
ERRORS
These functions may fail if:
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum allowable number of files is currently open in the system.
[ENOTTY]
None of the file descriptors 0, 1, or 2 is open to the controlling terminal of the current process.
[ENXIO]
The calling process has no controlling terminal.
The getlogin_r() function shall fail if:
[ERANGE]
The value of namesize is smaller than the length of the string to be returned including the terminating null
character.
The following sections are informative.
EXAMPLES
Getting the User Login Name
The following example calls the getlogin() function to obtain the name of the user associated with the calling process,
and passes this information to the getpwnam() function to get the associated user
database information.
#include
#include
#include
#include
...
char *lgn;
struct passwd *pw;
...
if ((lgn = getlogin()) == NULL || (pw = getpwnam(lgn)) == NULL) {
fprintf(stderr, "Get of user information failed.\n"); exit(1);
}
APPLICATION USAGE
Three names associated with the current process can be determined: getpwuid(geteuid()) shall return the name associated with the effective user ID of the process;
getlogin() shall return the name associated with the current login activity; and getpwuid(getuid()) shall return the name associated with the real user ID of the process.
The getlogin_r() function is thread-safe and returns values in a user-supplied buffer instead of possibly using a static
data area that may be overwritten by each call.
RATIONALE
The getlogin() function returns a pointer to the user's login name. The same user ID may be shared by several login
names. If it is desired to get the user database entry that is used during login, the result of getlogin() should be used to
provide the argument to the getpwnam() function. (This might be used to determine
the user's login shell, particularly where a single user has multiple login shells with distinct login names, but the same user
ID.)
The information provided by the cuserid() function, which was originally defined in the POSIX.1-1988 standard and
subsequently removed, can be obtained by the following:
getpwuid(geteuid())
while the information provided by historical implementations of cuserid() can be obtained by:
getpwuid(getuid())
The thread-safe version of this function places the user name in a user-supplied buffer and returns a non-zero value if it
fails. The non-thread-safe version may return the name in a static data area that may be overwritten by each call.
FUTURE DIRECTIONS
None.
SEE ALSO
getpwnam(), getpwuid(),
geteuid(), getuid()
XBD ,
CHANGE HISTORY
First released in Issue 1. Derived from System V Release 2.0.
Issue 5
Normative text previously in the APPLICATION USAGE section is moved to the RETURN VALUE section.
The getlogin_r() function is included for alignment with the POSIX Threads Extension.
A note indicating that the getlogin() function need not be reentrant is added to the DESCRIPTION.
Issue 6
The getlogin_r() function is marked as part of the Thread-Safe Functions option.
In the DESCRIPTION, the note about reentrancy is expanded to cover thread-safety.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the RETURN VALUE section, the requirement to set errno on error is added.
The [EMFILE], [ENFILE], and [ENXIO] optional error conditions are added.
The APPLICATION USAGE section is updated to include a note on the thread-safe function and its avoidance of possibly using a
static data area.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
SD5-XBD-ERN-4 is applied, changing the definition of the [EMFILE] error.
The getlogin_r() function is moved from the Thread-Safe Functions option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0243 [172], XSH/TC1-2008/0244 [75], and XSH/TC1-2008/0245 [172] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0168 [656] is applied.
Issue 8
Austin Group Defect 398 is applied, changing the [ERANGE] error from "may fail" to "shall fail".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/time.html =====
time
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
time — get time
SYNOPSIS
#include
time_t time(time_t *tloc);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The time() function shall return the value of time [CX]   in seconds since the Epoch.
The tloc argument points to an area where the return value is also stored. If tloc is a null pointer, no value is
stored.
RETURN VALUE
Upon successful completion, time() shall return the value of time. Otherwise, (time_t)-1 shall be returned.
ERRORS
The time() function may fail if:
[EOVERFLOW]
[CX]
The number of seconds since the Epoch will not fit in an object of type time_t.
The following sections are informative.
EXAMPLES
Getting the Current Time
The following example uses the time() function to calculate the time elapsed, in seconds, since the Epoch, localtime() to convert that value to a broken-down time, and asctime() to convert the broken-down time values into a printable string.
#include
#include
int main(void)
{
time_t result;
result = time(NULL);
printf("%s%ju secs since the Epoch\n",
asctime(localtime(&result)),
(uintmax_t)result);
return(0);
}
This example writes the current time to stdout in a form like this:
Wed Jun 26 10:32:15 1996
835810335 secs since the Epoch
Timing an Event
The following example gets the current time, prints it out in the user's format, and prints the number of minutes to an event
being timed.
#include
#include
...
time_t now;
int minutes_to_event;
...
time(&now);
minutes_to_event = ...;
printf("The time is ");
puts(asctime(localtime(&now)));
printf("There are %d minutes to the event.\n",
minutes_to_event);
...
APPLICATION USAGE
None.
RATIONALE
The time() function returns a value in seconds while clock_gettime()
returns a struct timespec (seconds and nanoseconds) and is therefore capable of returning more precise times. The times() function is also capable of more precision than time() as it returns a value in
clock ticks, although it returns the elapsed time since an arbitrary point such as system boot time, not since the epoch.
Earlier versions of this standard allowed the width of time_t to be less than 64 bits. A 32-bit signed integer (as used
in many historical implementations) fails in the year 2038, and although a 32-bit unsigned integer does not fail until 2106 the
preferred solution is to make time_t wider rather than to make it unsigned.
On some systems the time() function is implemented using a system call that does not return an error condition in
addition to the return value. On these systems it is impossible to differentiate between valid and invalid return values and hence
overflow conditions cannot be reliably detected.
The use of the  header instead of  allows compatibility with the ISO C standard.
Many historical implementations (including Version 7) and the 1984 /usr/group standard use long instead of time_t.
This volume of POSIX.1-2024 uses the latter type in order to agree with the ISO C standard.
FUTURE DIRECTIONS
None.
SEE ALSO
asctime(), clock(), clock_getres(), ctime(), difftime(), futimens(), gmtime(), localtime(), mktime(), strftime(), strptime(), times()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
Extensions beyond the ISO C standard are marked.
The EXAMPLES, RATIONALE, and FUTURE DIRECTIONS sections are added.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0663 [106], XSH/TC1-2008/0664 [350], XSH/TC1-2008/0665 [106],
XSH/TC1-2008/0666 [350], and XSH/TC1-2008/0667 [350] are applied.
Issue 8
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
Austin Group Defect 1462 is applied, changing the RATIONALE and FUTURE DIRECTIONS sections.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcslcat.html =====
wcslcat
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcslcat, wcslcpy — size-bounded wide string concatenation and copying
SYNOPSIS
[CX]  #include
size_t wcslcat(wchar_t *restrict dst, const wchar_t *restrict src,
size_t dstsize);
size_t wcslcpy(wchar_t *restrict dst, const wchar_t *restrict src,
size_t dstsize);
DESCRIPTION
The wcslcpy() and wcslcat() functions copy and concatenate wide strings, stopping when either a terminating null
wide-character code in the source wide string is encountered or the specified full size (in wide-character codes) of the
destination buffer is reached. They null terminate the result if there is room. The application should ensure that room for the
terminating null wide-character code is included in dstsize.
The wcslcpy() function shall copy not more than dstsize - 1 wide-character codes from the wide string pointed to
by src to the array pointed to by dst; a terminating null wide-character code in src and wide-character codes
that follow it shall not be copied. A terminating null wide-character code shall be appended to the result, unless dstsize
is 0. If copying takes place between objects that overlap, the behavior is undefined.
The wcslcat() function shall append not more than dstsize - wcslen(dst) - 1 wide-character codes
from the wide string pointed to by src to the end of the wide string pointed to by dst; a terminating null
wide-character code in src and wide-character codes that follow it shall not be appended. The initial wide-character code of
src shall overwrite the null wide-character code at the end of dst. A terminating null wide-character code shall be
appended to the result, unless its location would be at or beyond dst + dstsize. If copying takes place between
objects that overlap, the behavior is undefined.
The wcslcpy() and wcslcat() functions shall not change the setting of errno on valid input.
RETURN VALUE
Upon successful completion, the wcslcpy() function shall return the length of the wide string pointed to by src;
that is, the number of wide-character codes in the wide string, not including the terminating null wide-character code.
Upon successful completion, the wcslcat() function shall return the initial length of the wide string pointed to by
dst plus the length of the wide string pointed to by src.
No return values are reserved to indicate an error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The return value of the wcslcpy() and wcslcat() functions follows the same convention as snprintf(); that is, they return the total length (in wide-character codes) of the wide
string they tried to create. If the return value is greater than or equal to dstsize, the output wide string has been
truncated.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
fprintf(), strlcat(), wcslen(), wcsncat(), wcsncpy()
XBD
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/stdin.html =====
stdin
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
stderr, stdin, stdout — standard I/O streams
SYNOPSIS
#include
extern FILE *stderr, *stdin, *stdout;
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
A file with associated buffering is called a stream and is declared to be a pointer to a defined type FILE. The
fopen() function shall create certain descriptive data for a stream and return a
pointer to designate the stream in all further transactions. Normally, there are three open streams with constant pointers declared
in the  header and associated with the standard open files.
At program start-up, three streams shall be predefined and already open: stdin (standard input, for conventional input)
for reading, stdout (standard output, for conventional output) for writing, and stderr (standard error, for
diagnostic output) for writing. When opened, stderr shall not be fully buffered; stdin and stdout shall be
fully buffered if and only if [CX]   the file descriptor associated with the stream is determined not to be associated with an
interactive device.
[CX]  The
following symbolic values in  define the file descriptors that shall
be associated with the C-language stdin, stdout, and stderr when the application is started:
STDIN_FILENO
Standard input value, stdin. Its value is 0.
STDOUT_FILENO
Standard output value, stdout. Its value is 1.
STDERR_FILENO
Standard error value, stderr. Its value is 2.
These file descriptors are often all associated with a single open file description which has access mode O_RDWR (e.g., in the
case of a terminal device for a login shell). However, the stderr, stdin, and stdout streams need not be
opened for both reading and writing at program start-up in this case.
RETURN VALUE
None.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
fclose(), feof(), ferror(), fileno(), fopen(), fprintf(), fread(), fscanf(), fseek(), getc(), isatty(), popen(), putc(), puts(), read(), setbuf(), setvbuf(), tmpfile(), ungetc(), vfprintf()
XBD ,
CHANGE HISTORY
First released in Issue 1.
Issue 6
Extensions beyond the ISO C standard are marked.
A note that stderr is expected to be open for reading and writing is added to the DESCRIPTION.
Issue 8
Austin Group Defect 1347 is applied, clarifying the requirements for how stderr, stdin, and stdout are
opened at program start-up.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_condattr_setpshared.html =====
pthread_condattr_getpshared
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_condattr_getpshared, pthread_condattr_setpshared — get and set the process-shared condition variable
attributes
SYNOPSIS
[TSH]  #include
int pthread_condattr_getpshared(const pthread_condattr_t *restrict attr,
int *restrict pshared);
int pthread_condattr_setpshared(pthread_condattr_t *attr,
int pshared);
DESCRIPTION
The pthread_condattr_getpshared() function shall obtain the value of the process-shared attribute from the
attributes object referenced by attr.
The pthread_condattr_setpshared() function shall set the process-shared attribute in an initialized attributes
object referenced by attr.
The process-shared attribute is set to PTHREAD_PROCESS_SHARED to permit a condition variable to be operated upon by any
thread that has access to the memory where the condition variable is allocated, even if the condition variable is allocated in
memory that is shared by multiple processes. See 2.9.9 Synchronization Object
Copies and Alternative Mappings for further requirements. The default value of the attribute is
PTHREAD_PROCESS_PRIVATE.
The behavior is undefined if the value specified by the attr argument to pthread_condattr_getpshared() or
pthread_condattr_setpshared() does not refer to an initialized condition variable attributes object.
RETURN VALUE
If successful, the pthread_condattr_setpshared() function shall return zero; otherwise, an error number shall be returned
to indicate the error.
If successful, the pthread_condattr_getpshared() function shall return zero and store the value of the
process-shared attribute of attr into the object referenced by the pshared parameter. Otherwise, an error
number shall be returned to indicate the error.
ERRORS
The pthread_condattr_setpshared() function may fail if:
[EINVAL]
The new value specified for the attribute is outside the range of legal values for that attribute.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
If an implementation detects that the value specified by the attr argument to pthread_condattr_getpshared() or
pthread_condattr_setpshared() does not refer to an initialized condition variable attributes object, it is recommended that
the function should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_create(), pthread_cond_destroy(), pthread_condattr_destroy(), pthread_mutex_destroy()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_condattr_getpshared() and pthread_condattr_setpshared() functions are marked as part of the Threads
and Thread Process-Shared Synchronization options.
The restrict keyword is added to the pthread_condattr_getpshared() prototype for alignment with the
ISO/IEC 9899:1999 standard.
Issue 7
The pthread_condattr_getpshared() and pthread_condattr_setpshared() functions are marked only as part of the
Thread Process-Shared Synchronization option as the Threads option is now part of the Base.
The [EINVAL] error for an uninitialized condition variable attributes object is removed; this condition results in undefined
behavior.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0272 [972] and XSH/TC2-2008/0273 [757] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/msync.html =====
msync
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
msync — synchronize memory with physical storage
SYNOPSIS
[XSI|SIO]  #include
int msync(void *addr, size_t len, int flags);
DESCRIPTION
The msync() function shall write all modified data to permanent storage locations, if any, in those whole pages
containing any part of the address space of the process starting at address addr and continuing for len bytes. If no
such storage exists, msync() need not have any effect. If requested, the msync() function shall then invalidate
cached copies of data.
The implementation may require that addr be a multiple of the page size as returned by sysconf().
For mappings to files, the msync() function shall ensure that all write operations are completed as defined for
synchronized I/O data integrity completion. It is unspecified whether the implementation also writes out other file attributes.
When the msync() function is called on MAP_PRIVATE mappings, any modified data shall not be written to the underlying object
and shall not cause such data to be made visible to other processes. It is unspecified whether data in MAP_PRIVATE mappings has any
permanent storage locations. The effect of msync() on an anonymous memory object, [SHM]   shared
memory object,  or
[TYM]
typed memory object  is unspecified. The behavior of this function
is unspecified if the mapping was not established by a call to mmap().
The flags argument is constructed from the bitwise-inclusive OR of one or more of the following flags defined in the
header:
Symbolic Constant
Description
MS_ASYNC
Perform asynchronous writes.
MS_SYNC
Perform synchronous writes.
MS_INVALIDATE
Invalidate cached data.
When MS_ASYNC is specified, msync() shall return immediately once all the write operations are initiated or
queued for servicing; when MS_SYNC is specified, msync() shall not return until all write operations are completed as
defined for synchronized I/O data integrity completion. Either MS_ASYNC or MS_SYNC shall be specified, but not both.
When MS_INVALIDATE is specified, msync() shall invalidate all cached copies of mapped data that are
inconsistent with the permanent storage locations such that subsequent references shall obtain data that was consistent with the
permanent storage locations sometime between the call to msync() and the first subsequent memory reference to the data.
If msync() causes any write to a file, the file's last data modification and last file status change
timestamps shall be marked for update.
RETURN VALUE
Upon successful completion, msync() shall return 0; otherwise, it shall return -1 and set errno to indicate the
error.
ERRORS
The msync() function shall fail if:
[EBUSY]
Some or all of the addresses in the range starting at addr and continuing for len bytes are locked, and
MS_INVALIDATE is specified.
[EINVAL]
The value of flags is invalid.
[ENOMEM]
The addresses in the range starting at addr and continuing for len bytes are outside the range allowed for the
address space of a process or specify one or more pages that are not mapped.
The msync() function may fail if:
[EINVAL]
The value of addr is not a multiple of the page size as returned by sysconf().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The msync() function is only supported if the Synchronized Input and Output option is supported, and thus need not be
available on all implementations.
The msync() function should be used by programs that require a memory object to be in a known state; for
example, in building transaction facilities.
Normal system activity can cause pages to be written to disk. Therefore, there are no guarantees that
msync() is the only control over when pages are or are not written to disk.
RATIONALE
The msync() function writes out data in a mapped region to the permanent storage for the underlying object. The call to
msync() ensures data integrity of the file.
After the data is written out, any cached data may be invalidated if the MS_INVALIDATE flag was specified. This is
useful on systems that do not support read/write consistency.
FUTURE DIRECTIONS
None.
SEE ALSO
mmap(), sysconf()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Aligned with msync() in the POSIX Realtime Extension as follows:
The DESCRIPTION is extensively reworded.
[EBUSY] and a new form of [EINVAL] are added as mandatory error conditions.
Issue 6
The msync() function is marked as part of the Memory Mapped Files and Synchronized Input and Output options.
The following changes are made for alignment with the ISO POSIX-1:1996 standard:
The [EBUSY] mandatory error condition is added.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX
Specification:
The DESCRIPTION is updated to state that implementations require addr to be a multiple of the page
size.
The second [EINVAL] error condition is made mandatory.
The DESCRIPTION is updated for alignment with IEEE Std 1003.1j-2000 by adding reference to typed memory
objects.
Issue 7
Austin Group Interpretation 1003.1-2001 #078 is applied, clarifying page alignment requirements.
SD5-XSH-ERN-110 is applied.
The msync() function is marked as part of the Synchronized Input and Output option or XSI option as the
Memory Mapped Files is moved to the Base.
Changes are made related to support for finegrained timestamps.
Issue 8
Austin Group Defect 850 is applied, adding anonymous memory objects.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/scalbln.html =====
scalbln
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
scalbln, scalblnf, scalblnl, scalbn, scalbnf, scalbnl — compute exponent using FLT_RADIX
SYNOPSIS
#include
double scalbln(double x, long n);
float scalblnf(float x, long n);
long double scalblnl(long double x, long n);
double scalbn(double x, int n);
float scalbnf(float x, int n);
long double scalbnl(long double x, int n);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute x * FLT_RADIXn efficiently, not normally by
computing FLT_RADIXn explicitly.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return x * FLT_RADIXn.
[MX]  If
the calculation does not overflow or underflow, the returned value shall be exact and shall be independent of the current rounding
direction mode.
If the result would cause overflow, a range error shall occur and these functions shall return ±HUGE_VAL, ±HUGE_VALF, and
±HUGE_VALL (according to the sign of x) as appropriate for the return type of the function.
If the correct value would cause underflow, [MXX]   and is not representable,   a range error may occur, and scalbln(), scalblnf(), scalblnl(),
scalbn(), scalbnf(), and scalbnl() shall return [MXX]
0.0, or   (if IEC 60559 Floating-Point is not supported) an implementation-defined value no greater in
magnitude than DBL_MIN, FLT_MIN, LDBL_MIN, DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0 or ±Inf, x shall be returned.
If n is 0, x shall be returned.
[MXX]
If the correct value would cause underflow, and is representable, a range error may occur and the correct value shall be returned.
ERRORS
These functions shall fail if:
Range Error
The result overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
These functions may fail if:
Range Error
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
These functions are named so as to avoid conflicting with the historical definition of the scalb() function from the
Single UNIX Specification. The difference is that the scalb() function has a second argument of double instead of
int. The scalb() function is not part of the ISO C standard. The three functions whose second type is
long are provided because the factor required to scale from the smallest positive floating-point value to the largest finite
one, on many implementations, is too large to represent in the minimum-width int format.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0521 [68] and XSH/TC1-2008/0522 [68] are applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ftello.html =====
ftell
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ftell, ftello — return a file offset in a stream
SYNOPSIS
#include
long ftell(FILE *stream);
[CX]  off_t ftello(FILE *stream);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The ftell() function shall obtain the current value of the file-position indicator for the stream pointed to by
stream.
The ftell() function shall not change the setting of errno if successful.
[CX]  The
ftello() function shall be equivalent to ftell(), except that the return value is of type off_t and the
ftello() function may change the setting of errno if successful.
RETURN VALUE
Upon successful completion, ftell() [CX]   and ftello()   shall return the current value of the file-position indicator for the stream measured in bytes
from the beginning of the file, [CX]   except in the case of streams opened with open_wmemstream() for which the position shall be measured in wide characters.
Otherwise, ftell() and ftello() shall return -1, and set errno to indicate the error.
ERRORS
The ftell() [CX]   and ftello()  functions
shall fail if:
[EBADF]
[CX]
The file descriptor underlying stream is not an open file descriptor.
[EOVERFLOW]
[CX]
For ftell(), the current file offset cannot be represented correctly in an object of type long.
[EOVERFLOW]
[CX]
For ftello(), the current file offset cannot be represented correctly in an object of type off_t.
[ESPIPE]
[CX]
The file descriptor underlying stream is associated with a pipe, FIFO, or socket.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
For all streams other than those opened by open_wmemstream(),
ftell() and fseek() operate on byte offsets. The behavior with open_wmemstream() streams is intentionally different—ftell() and fseek() operate on wide character
offsets. This is because those streams are unique in that the backing storage is not a multibyte representation but a wide
character array, and it is useful to be able to use the output of ftell() to index into that array.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fgetpos(), fopen(), fseek(), lseek(), open_memstream()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
Large File Summit extensions are added.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The ftello() function is added.
The [EOVERFLOW] error conditions are added.
An additional [ESPIPE] error condition is added for sockets.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0204 [105], XSH/TC1-2008/0205 [421], XSH/TC1-2008/0206 [122],
XSH/TC1-2008/0207 [122], and XSH/TC1-2008/0208 [14] are applied.
Issue 8
Austin Group Defect 1027 is applied, specifying that for streams opened with open_wmemstream() the position is measured in wide characters, not bytes.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/csin.html =====
csin
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
csin, csinf, csinl — complex sine functions
SYNOPSIS
#include
double complex csin(double complex z);
float complex csinf(float complex z);
long double complex csinl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex sine of z.
RETURN VALUE
These functions shall return the complex sine value.
[MXC]
csin(conj(iz)), csinf(conjf(iz)), and csinl(conjl(iz)) shall return
exactly the same value as conj(csin(iz)), conjf(csinf(iz)), and
conjl(csinl(iz)), respectively, and csin(-iz), csinf(-iz), and
csinl(-iz) shall return exactly the same value as -csin(iz), -csinf(iz), and
-csinl(iz), respectively, including for the special values of iz below.
If iz is +0 + i0, -i (+0 + i0) shall be returned.
If iz is +0 + iInf, -i (±0 + iNaN) shall be returned and the invalid floating-point exception shall
be raised; the sign of the imaginary part of the result is unspecified.
If iz is +0 + iNaN, -i (±0 + iNaN) shall be returned; the sign of the imaginary part of the result
is unspecified.
If iz is x + iInf where x is positive and finite, -i (NaN + iNaN) shall be returned and the
invalid floating-point exception shall be raised.
If iz is x + iNaN where x is non-zero and finite, -i (NaN + iNaN) shall be returned and the
invalid floating-point exception may be raised.
If iz is +Inf + i0, -i (+Inf + i0) shall be returned.
If iz is +Inf + iy where y is positive and finite, -iInf (cos(y) +
isin(y)) shall be returned.
If iz is +Inf + iInf, -i (±Inf + iNaN) shall be returned and the invalid floating-point exception
shall be raised; the sign of the imaginary part of the result is unspecified.
If iz is +Inf + iNaN, -i (±Inf + iNaN) shall be returned; the sign of the imaginary part of the
result is unspecified.
If iz is NaN + i0, -i (NaN + i0) shall be returned.
If iz is NaN + iy where y is any non-zero number, -i (NaN + iNaN) shall be returned and the
invalid floating-point exception may be raised.
If iz is NaN + iNaN, -i (NaN + iNaN) shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The MXC special cases for csin() are derived from those for csinh() by
applying the formula csin(z) = -icsinh(iz).
FUTURE DIRECTIONS
None.
SEE ALSO
casin(), csinh()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/endpwent.html =====
endpwent
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
endpwent, getpwent, setpwent — user database functions
SYNOPSIS
[XSI]  #include
void endpwent(void);
struct passwd *getpwent(void);
void setpwent(void);
DESCRIPTION
These functions shall retrieve information about users.
The getpwent() function shall return a pointer to a structure containing the broken-out fields of an entry in the user
database. Each entry in the user database contains a passwd structure. If the user database is not already open,
getpwent() shall open it and return a pointer to a passwd structure containing the first entry in the database.
Thereafter, it shall return a pointer to a passwd structure containing the next entry in the user database. Successive calls
can be used to search the entire user database.
If an end-of-file or an error is encountered on reading, getpwent() shall return a null pointer.
An implementation that provides extended security controls may impose further implementation-defined restrictions on accessing
the user database. In particular, the system may deny the existence of some or all of the user database entries associated with
users other than the caller.
The setpwent() function shall rewind the user database so that the next getpwent() call returns the first entry,
allowing repeated searches.
The endpwent() function shall close the user database.
The setpwent() and endpwent() functions shall not change the setting of errno if successful.
On error, the setpwent() and endpwent() functions shall set errno to indicate the error.
Since no value is returned by the setpwent() and endpwent() functions, an application wishing to check for error
situations should set errno to 0, then call the function, then check errno.
These functions need not be thread-safe.
RETURN VALUE
On successful completion, getpwent() shall return a pointer to a passwd structure. On end-of-file,
getpwent() shall return a null pointer and shall not change the setting of errno. On error, getpwent() shall
return a null pointer and errno shall be set to indicate the error.
The application shall not modify the structure to which the return value points, nor any storage areas pointed to by pointers
within the structure. The returned pointer, and pointers within the structure, might be invalidated or the structure or the storage
areas might be overwritten by a subsequent call to getpwuid(), getpwnam(), or getpwent(). The returned pointer, and pointers within the structure,
might also be invalidated if the calling thread is terminated.
ERRORS
These functions may fail if:
[EINTR]
A signal was caught during the operation.
[EIO]
An I/O error has occurred.
In addition, getpwent() and setpwent() may fail if:
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum allowable number of files is currently open in the system.
The following sections are informative.
EXAMPLES
Searching the User Database
The following example uses the getpwent() function to get successive entries in the user database, returning a pointer to
a passwd structure that contains information about each user. The call to endpwent() closes the user database and
cleans up.
#include
#include
void printname(uid_t uid)
{
struct passwd *pwd;
setpwent();
while((pwd = getpwent()) != NULL) {
if (pwd->pw_uid == uid) {
printf("name=%s\n",pwd->pw_name);
break;
}
}
endpwent();
}
APPLICATION USAGE
These functions are provided due to their historical usage. Applications should avoid dependencies on fields in the password
database, whether the database is a single file, or where in the file system name space the database resides. Applications should
use getpwuid() whenever possible because it avoids these dependencies.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
endgrent(), getlogin(),
getpwnam(), getpwuid()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Normative text previously in the APPLICATION USAGE section is moved to the RETURN VALUE section.
A note indicating that these functions need not be reentrant is added to the DESCRIPTION.
Issue 6
In the DESCRIPTION, the note about reentrancy is expanded to cover thread-safety.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
SD5-XBD-ERN-4 is applied, changing the definition of the [EMFILE] error.
The EXAMPLES section is revised.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0087 [75] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0092 [493], XSH/TC2-2008/0093 [656], and XSH/TC2-2008/0094 [493] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/csinf.html =====
csin
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
csin, csinf, csinl — complex sine functions
SYNOPSIS
#include
double complex csin(double complex z);
float complex csinf(float complex z);
long double complex csinl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex sine of z.
RETURN VALUE
These functions shall return the complex sine value.
[MXC]
csin(conj(iz)), csinf(conjf(iz)), and csinl(conjl(iz)) shall return
exactly the same value as conj(csin(iz)), conjf(csinf(iz)), and
conjl(csinl(iz)), respectively, and csin(-iz), csinf(-iz), and
csinl(-iz) shall return exactly the same value as -csin(iz), -csinf(iz), and
-csinl(iz), respectively, including for the special values of iz below.
If iz is +0 + i0, -i (+0 + i0) shall be returned.
If iz is +0 + iInf, -i (±0 + iNaN) shall be returned and the invalid floating-point exception shall
be raised; the sign of the imaginary part of the result is unspecified.
If iz is +0 + iNaN, -i (±0 + iNaN) shall be returned; the sign of the imaginary part of the result
is unspecified.
If iz is x + iInf where x is positive and finite, -i (NaN + iNaN) shall be returned and the
invalid floating-point exception shall be raised.
If iz is x + iNaN where x is non-zero and finite, -i (NaN + iNaN) shall be returned and the
invalid floating-point exception may be raised.
If iz is +Inf + i0, -i (+Inf + i0) shall be returned.
If iz is +Inf + iy where y is positive and finite, -iInf (cos(y) +
isin(y)) shall be returned.
If iz is +Inf + iInf, -i (±Inf + iNaN) shall be returned and the invalid floating-point exception
shall be raised; the sign of the imaginary part of the result is unspecified.
If iz is +Inf + iNaN, -i (±Inf + iNaN) shall be returned; the sign of the imaginary part of the
result is unspecified.
If iz is NaN + i0, -i (NaN + i0) shall be returned.
If iz is NaN + iy where y is any non-zero number, -i (NaN + iNaN) shall be returned and the
invalid floating-point exception may be raised.
If iz is NaN + iNaN, -i (NaN + iNaN) shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The MXC special cases for csin() are derived from those for csinh() by
applying the formula csin(z) = -icsinh(iz).
FUTURE DIRECTIONS
None.
SEE ALSO
casin(), csinh()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sigwaitinfo.html =====
sigtimedwait
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sigtimedwait, sigwaitinfo — wait for queued signals
SYNOPSIS
[CX]  #include
int sigtimedwait(const sigset_t *restrict set,
siginfo_t *restrict info,
const struct timespec *restrict timeout);
int sigwaitinfo(const sigset_t *restrict set,
siginfo_t *restrict info);
DESCRIPTION
The sigtimedwait() function shall be equivalent to sigwaitinfo() except that if none of the signals specified by
set are pending, sigtimedwait() shall wait for the time interval specified in the timespec structure
referenced by timeout. If the timespec structure pointed to by timeout is zero-valued and if none of the
signals specified by set are pending, then sigtimedwait() shall return immediately with an error. If timeout
is the null pointer, the behavior is unspecified. The CLOCK_MONOTONIC clock shall be used to measure the time interval specified by
the timeout argument.
The sigwaitinfo() function selects the pending signal from the set specified by set. Should any of multiple
pending signals in the range SIGRTMIN to SIGRTMAX be selected, it shall be the lowest numbered one. The selection order between
realtime and non-realtime signals, or between multiple pending non-realtime signals, is unspecified. If no signal in set is
pending at the time of the call, the calling thread shall be suspended until one or more signals in set become pending or
until it is interrupted by an unblocked, caught signal.
The sigwaitinfo() function shall be equivalent to the sigwait() function,
except that the return value and the error reporting method are different (see RETURN VALUE), and that if the info argument
is non-NULL, the selected signal number shall be stored in the si_signo member, and the cause of the signal shall be stored
in the si_code member. If any value is queued to the selected signal, the first such queued value shall be dequeued and, if
the info argument is non-NULL, the value shall be stored in the si_value member of info. The system resource
used to queue the signal shall be released and returned to the system for other use. If no value is queued, the content of the
si_value member is undefined. If no further signals are queued for the selected signal, the pending indication for that
signal shall be reset.
RETURN VALUE
Upon successful completion (that is, one of the signals specified by set is pending or is generated) sigwaitinfo()
and sigtimedwait() shall return the selected signal number. Otherwise, the function shall return a value of -1 and set
errno to indicate the error.
ERRORS
The sigtimedwait() function shall fail if:
[EAGAIN]
No signal specified by set was generated within the specified timeout period.
The sigtimedwait() and sigwaitinfo() functions may fail if:
[EINTR]
The wait was interrupted by an unblocked, caught signal. It shall be documented in system documentation whether this error
causes these functions to fail.
The sigtimedwait() function may also fail if:
[EINVAL]
The timeout argument specified a tv_nsec value less than zero or greater than or equal to 1000 million.
An implementation should only check for this error if no signal is pending in set and it is necessary to wait.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The sigtimedwait() function times out and returns an [EAGAIN] error. Application developers should note that this is
inconsistent with other functions such as pthread_cond_timedwait()
that return [ETIMEDOUT].
Note that in order to ensure that generated signals are queued and signal values passed to sigqueue() are available in si_value, applications which use sigwaitinfo() or
sigtimedwait() need to set the SA_SIGINFO flag for each signal in the set (see 2.4 Signal Concepts). This means setting each signal to be handled by a
three-argument signal-catching function, even if the handler will never be called. It is not possible (portably) to set a signal
handler to SIG_DFL while setting the SA_SIGINFO flag, because assigning to the sa_handler member of struct sigaction
instead of the sa_sigaction member would result in undefined behavior, and SIG_DFL need not be assignment-compatible with
sa_sigaction. Even if an assignment of SIG_DFL to sa_sigaction is accepted by the compiler, the implementation need
not treat this value as special—it could just be taken as the address of a signal-catching function.
RATIONALE
Existing programming practice on realtime systems uses the ability to pause waiting for a selected set of events and handle the
first event that occurs in-line instead of in a signal-handling function. This allows applications to be written in an
event-directed style similar to a state machine. This style of programming is useful for largescale transaction processing in which
the overall throughput of an application and the ability to clearly track states are more important than the ability to minimize
the response time of individual event handling.
It is possible to construct a signal-waiting macro function out of the realtime signal function mechanism defined in this volume
of POSIX.1-2024. However, such a macro has to include the definition of a generalized handler for all signals to be waited on. A
significant portion of the overhead of handler processing can be avoided if the signal-waiting function is provided by the kernel.
This volume of POSIX.1-2024 therefore provides two signal-waiting functions—one that waits indefinitely and one with a timeout—as
part of the overall realtime signal function specification.
The specification of a function with a timeout allows an application to be written that can be broken out of a wait after a set
period of time if no event has occurred. It was argued that setting a timer event before the wait and recognizing the timer event
in the wait would also implement the same functionality, but at a lower performance level. Because of the performance degradation
associated with the user-level specification of a timer event and the subsequent cancellation of that timer event after the wait
completes for a valid event, and the complexity associated with handling potential race conditions associated with the user-level
method, the separate function has been included.
Note that the semantics of the sigwaitinfo() function are nearly identical to that of the sigwait() function defined by this volume of POSIX.1-2024. The only difference is that
sigwaitinfo() returns the queued signal value in the value argument. The return of the queued value is required so
that applications can differentiate between multiple events queued to the same signal number.
The two distinct functions are being maintained because some implementations may choose to implement the POSIX Threads Extension
functions and not implement the queued signals extensions. Note, though, that sigwaitinfo() does not return the queued value
if the value argument is NULL, so the POSIX Threads Extension sigwait()
function can be implemented as a macro on sigwaitinfo().
The sigtimedwait() function was separated from the sigwaitinfo() function to address concerns regarding the
overloading of the timeout pointer to indicate indefinite wait (no timeout), timed wait, and immediate return, and concerns
regarding consistency with other functions where the conditional and timed waits were separate functions from the pure blocking
function. The semantics of sigtimedwait() are specified such that sigwaitinfo() could be implemented as a macro with
a null pointer for timeout.
The sigwait functions provide a synchronous mechanism for threads to wait for asynchronously-generated signals. One
important question was how many threads that are suspended in a call to a sigwait()
function for a signal should return from the call when the signal is sent. Four choices were considered:
Return an error for multiple simultaneous calls to sigwait functions for the same signal.
One or more threads return.
All waiting threads return.
Exactly one thread returns.
Prohibiting multiple calls to sigwait() for the same signal was felt to be overly
restrictive. The "one or more" behavior made implementation of conforming packages easy at the expense of forcing POSIX threads
clients to protect against multiple simultaneous calls to sigwait() in application
code in order to achieve predictable behavior. There was concern that the "all waiting threads" behavior would result in "signal
broadcast storms", consuming excessive CPU resources by replicating the signals in the general case. Furthermore, no convincing
examples could be presented that delivery to all was either simpler or more powerful than delivery to one.
Thus, the consensus was that exactly one thread that was suspended in a call to a sigwait function for a signal should
return when that signal occurs. This is not an onerous restriction as:
A multi-way signal wait can be built from the single-way wait.
Signals should only be handled by application-level code, as library routines cannot guess what the application wants to do with
signals generated for the entire process.
Applications can thus arrange for a single thread to wait for any given signal and call any needed routines upon its
arrival.
In an application that is using signals for interprocess communication, signal processing is typically done in one place.
Alternatively, if the signal is being caught so that process cleanup can be done, the signal handler thread can call separate
process cleanup routines for each portion of the application. Since the application main line started each portion of the
application, it is at the right abstraction level to tell each portion of the application to clean up.
Certainly, there exist programming styles where it is logical to consider waiting for a single signal in multiple threads. A
simple sigwait_multiple() routine can be constructed to achieve this goal. A possible implementation would be to have each
sigwait_multiple() caller registered as having expressed interest in a set of signals. The caller then waits on a
thread-specific condition variable. A single server thread calls a sigwait()
function on the union of all registered signals. When the sigwait() function
returns, the appropriate state is set and condition variables are broadcast. New sigwait_multiple() callers may cause the
pending sigwait() call to be canceled and reissued in order to update the set of
signals being waited for.
FUTURE DIRECTIONS
None.
SEE ALSO
2.4 Signal Concepts, 2.8.1 Realtime Signals, pause(), pthread_sigmask(),
sigaction(), sigpending(),
sigsuspend(), sigwait()
XBD ,
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension and the POSIX Threads Extension.
Issue 6
These functions are marked as part of the Realtime Signals Extension option.
The Open Group Corrigendum U035/3 is applied. The SYNOPSIS of the sigwaitinfo() function has been corrected so that the
second argument is of type siginfo_t *.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Realtime
Signals Extension option.
The DESCRIPTION is updated for alignment with IEEE Std 1003.1j-2000 by specifying that the CLOCK_MONOTONIC clock, if
supported, is used to measure timeout intervals.
The restrict keyword is added to the sigtimedwait() and sigwaitinfo() prototypes for alignment with the
ISO/IEC 9899:1999 standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/130 is applied, restoring wording in the RETURN VALUE section to
that in the original base document ("An implementation should only check for this error if no signal is pending in set and
it is necessary to wait").
Issue 7
The sigtimedwait() and sigwaitinfo() functions are moved from the Realtime Signals Extension option to the
Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0583 [392] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0333 [815] is applied.
Issue 8
Austin Group Defect 1346 is applied, requiring support for Monotonic Clock.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_attr_getscope.html =====
pthread_attr_getscope
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_attr_getscope, pthread_attr_setscope — get and set the contentionscope attribute (REALTIME
THREADS)
SYNOPSIS
[TPS]  #include
int pthread_attr_getscope(const pthread_attr_t *restrict attr,
int *restrict contentionscope);
int pthread_attr_setscope(pthread_attr_t *attr, int contentionscope);
DESCRIPTION
The pthread_attr_getscope() and pthread_attr_setscope() functions, respectively, shall get and set the
contentionscope attribute in the attr object.
The contentionscope attribute may have the values PTHREAD_SCOPE_SYSTEM, signifying system scheduling contention scope, or
PTHREAD_SCOPE_PROCESS, signifying process scheduling contention scope. The symbols PTHREAD_SCOPE_SYSTEM and PTHREAD_SCOPE_PROCESS
are defined in the  header.
The behavior is undefined if the value specified by the attr argument to pthread_attr_getscope() or
pthread_attr_setscope() does not refer to an initialized thread attributes object.
RETURN VALUE
If successful, the pthread_attr_getscope() and pthread_attr_setscope() functions shall return zero; otherwise, an
error number shall be returned to indicate the error.
ERRORS
The pthread_attr_setscope() function shall fail if:
[ENOTSUP]
An attempt was made to set the attribute to an unsupported value.
The pthread_attr_setscope() function may fail if:
[EINVAL]
The value of contentionscope is not valid.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
After these attributes have been set, a thread can be created with the specified attributes using pthread_create(). Using these routines does not affect the current running
thread.
See 2.9.4 Thread Scheduling for further details on thread
scheduling attributes and their default settings.
RATIONALE
If an implementation detects that the value specified by the attr argument to pthread_attr_getscope() or
pthread_attr_setscope() does not refer to an initialized thread attributes object, it is recommended that the function
should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_attr_destroy(), pthread_attr_getinheritsched(), pthread_attr_getschedpolicy(), pthread_attr_getschedparam(), pthread_create()
XBD ,
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Marked as part of the Realtime Threads Feature Group.
Issue 6
The pthread_attr_getscope() and pthread_attr_setscope() functions are marked as part of the Threads and Thread
Execution Scheduling options.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Thread
Execution Scheduling option.
The restrict keyword is added to the pthread_attr_getscope() prototype for alignment with the
ISO/IEC 9899:1999 standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/81 is applied, adding a reference to 2.9.4 Thread Scheduling in the APPLICATION USAGE section.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/82 is applied, updating the ERRORS section to include optional
errors for the case when attr refers to an uninitialized thread attribute object.
Issue 7
The pthread_attr_getscope() and pthread_attr_setscope() functions are marked only as part of the Thread Execution
Scheduling option as the Threads option is now part of the Base.
The [EINVAL] error for an uninitialized thread attributes object is removed; this condition results in undefined behavior.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0453 [314] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0264 [757] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pread.html =====
read
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pread, read — read from a file
SYNOPSIS
#include
ssize_t pread(int fildes, void *buf, size_t nbyte, off_t
offset);
ssize_t read(int fildes, void *buf, size_t nbyte);
DESCRIPTION
The read() function shall attempt to read nbyte bytes from the file associated with the open file descriptor,
fildes, into the buffer pointed to by buf. The behavior of multiple concurrent reads on the same pipe, FIFO, or
terminal device is unspecified.
Before any action described below is taken, and if nbyte is zero, the read() function may detect and return errors
as described below. In the absence of errors, or if error detection is not performed, the read() function shall return zero
and have no other results.
On files that support seeking (for example, a regular file), the read() shall start at a position in the file given by
the file offset associated with fildes. The file offset shall be incremented by the number of bytes actually read.
Files that do not support seeking—for example, terminals—always read from the current position. The value of a file offset
associated with such a file is undefined.
No data transfer shall occur past the current end-of-file. If the starting position is at or after the end-of-file, 0 shall be
returned. If the file refers to a device special file, the result of subsequent read() requests is
implementation-defined.
If the value of nbyte is greater than {SSIZE_MAX}, the result is implementation-defined.
When attempting to read from an empty pipe or FIFO:
If no process has the pipe open for writing, read() shall return 0 to indicate end-of-file.
If some process has the pipe open for writing and O_NONBLOCK is set, read() shall return -1 and set errno to
[EAGAIN].
If some process has the pipe open for writing and O_NONBLOCK is clear, read() shall block the calling thread until some
data is written or the pipe is closed by all processes that had the pipe open for writing.
When attempting to read a file (other than a pipe or FIFO) that supports non-blocking reads and has no data currently
available:
If O_NONBLOCK is set, read() shall return -1 and set errno to [EAGAIN].
If O_NONBLOCK is clear, read() shall block the calling thread until some data becomes available.
The use of the O_NONBLOCK flag has no effect if there is some data available.
The read() function reads data previously written to a file. If any portion of a regular file prior to the end-of-file
has not been written, read() shall return bytes with value 0. For example, lseek() allows the file offset to be set beyond the end of existing data in the file. If data
is later written at this point, subsequent reads in the gap between the previous end of data and the newly written data shall
return bytes with value 0 until data is written into the gap.
Upon successful completion, where nbyte is greater than 0, read() shall mark for update the last data access
timestamp of the file, and shall return the number of bytes read. This number shall never be greater than nbyte. The value
returned may be less than nbyte if the number of bytes left in the file is less than nbyte, if the read()
request was interrupted by a signal, or if the file is a pipe or FIFO or special file and has fewer than nbyte bytes
immediately available for reading. For example, a read() from a file associated with a terminal may return one typed line of
data.
If a read() is interrupted by a signal before it reads any data, it shall return -1 with errno set to [EINTR].
If a read() is interrupted by a signal after it has successfully read some data, it shall return the number of bytes
read.
For regular files, no data transfer shall occur past the offset maximum established in the open file description associated with
fildes.
If fildes refers to a socket, read() shall be equivalent to recv()
with no flags set.
[SIO]
If the O_DSYNC and O_RSYNC bits have been set, read I/O operations on the file descriptor shall complete as defined by synchronized
I/O data integrity completion. If the O_SYNC and O_RSYNC bits have been set, read I/O operations on the file descriptor shall
complete as defined by synchronized I/O file integrity completion.
[SHM]
If fildes refers to a shared memory object, the result of the read() function is unspecified.
[TYM]
If fildes refers to a typed memory object, the result of the read() function is unspecified.
The pread() function shall be equivalent to read(), except that it shall read from a given position in the file
without changing the file offset. The first three arguments to pread() are the same as read() with the addition of a
fourth argument offset for the desired position inside the file. An attempt to perform a pread() on a file that is
incapable of seeking shall result in an error.
RETURN VALUE
Upon successful completion, these functions shall return a non-negative integer indicating the number of bytes actually read.
Otherwise, the functions shall return -1 and set errno to indicate the error.
ERRORS
These functions shall fail if:
[EAGAIN]
The file is neither a pipe, nor a FIFO, nor a socket, the O_NONBLOCK flag is set for the file descriptor, and the thread would
be delayed in the read operation.
[EBADF]
The fildes argument is not a valid file descriptor open for reading.
[EINTR]
The read operation was terminated due to the receipt of a signal, and no data was transferred.
[EIO]
The process is a member of a background process group attempting to read from its controlling terminal, and either the calling
thread is blocking SIGTTIN or the process is ignoring SIGTTIN or the process group of the process is orphaned. This error may also
be generated for implementation-defined reasons.
[EISDIR]
[XSI]
The fildes argument refers to a directory and the implementation does not allow the directory to be read using read()
or pread(). The readdir() function should be used instead.
[EOVERFLOW]
The file is a regular file, nbyte is greater than 0, the starting position is before the end-of-file, and the starting
position is greater than or equal to the offset maximum established in the open file description associated with
fildes.
The pread() function shall fail if:
[EINVAL]
The file is a regular file or block special file, and the offset argument is negative. The file offset shall remain
unchanged.
[ESPIPE]
The file is incapable of seeking.
The read() function shall fail if:
[EAGAIN]
The file is a pipe or FIFO, the O_NONBLOCK flag is set for the file descriptor, and the thread would be delayed in the read
operation.
[EAGAIN] or [EWOULDBLOCK]
The file is a socket, the O_NONBLOCK flag is set for the file descriptor, and the thread would be delayed in the read
operation.
[ECONNRESET]
A read was attempted on a socket and the connection was forcibly closed by its peer.
[ENOTCONN]
A read was attempted on a socket that is not connected.
[ETIMEDOUT]
A read was attempted on a socket and a transmission timeout occurred.
These functions may fail if:
[EIO]
A physical I/O error has occurred.
[ENOBUFS]
Insufficient resources were available in the system to perform the operation.
[ENOMEM]
Insufficient memory was available to fulfill the request.
[ENXIO]
A request was made of a nonexistent device, or the request was outside the capabilities of the device.
The following sections are informative.
EXAMPLES
Reading Data into a Buffer
The following example reads data from the file associated with the file descriptor fd into the buffer pointed to by
buf.
#include
#include
...
char buf[20];
size_t nbytes;
ssize_t bytes_read;
int fd;
...
nbytes = sizeof(buf);
bytes_read = read(fd, buf, nbytes);
...
APPLICATION USAGE
None.
RATIONALE
This volume of POSIX.1-2024 does not specify the value of the file offset after an error is returned; there are too many cases.
For programming errors, such as [EBADF], the concept is meaningless since no file is involved. For errors that are detected
immediately, such as [EAGAIN], clearly the offset should not change. After an interrupt or hardware error, however, an updated
value would be very useful and is the behavior of many implementations.
Note that a read() of zero bytes does not modify the last data access timestamp. A read() that requests more than
zero bytes, but returns zero, is required to modify the last data access timestamp.
Implementations are allowed, but not required, to perform error checking for read() requests of zero bytes.
Input and Output
The use of I/O with large byte counts has always presented problems. Ideas such as lread() and lwrite() (using and
returning longs) were considered at one time. The current solution is to use abstract types on the ISO C standard
function to read() and write(). The abstract types can be declared so that
existing functions work, but can also be declared so that larger types can be represented in future implementations. It is presumed
that whatever constraints limit the maximum range of size_t also limit portable I/O requests to the same range. This volume
of POSIX.1-2024 also limits the range further by requiring that the byte count be limited so that a signed return value remains
meaningful. Since the return type is also a (signed) abstract type, the byte count can be defined by the implementation to be
larger than an int can hold.
The standard developers considered adding atomicity requirements to a pipe or FIFO, but recognized that due to the nature of
pipes and FIFOs there could be no guarantee of atomicity of reads of {PIPE_BUF} or any other size that would be an aid to
applications portability.
This volume of POSIX.1-2024 requires that no action be taken for read() or write() when nbyte is zero. This is not intended to take precedence over detection of
errors (such as invalid buffer pointers or file descriptors). This is consistent with the rest of this volume of POSIX.1-2024, but
the phrasing here could be misread to require detection of the zero case before any other errors. A value of zero is to be
considered a correct value, for which the semantics are a no-op.
I/O is intended to be atomic to ordinary files and pipes and FIFOs. Atomic means that all the bytes from a single operation that
started out together end up together, without interleaving from other I/O operations. It is a known attribute of terminals that
this is not honored, and terminals are explicitly (and implicitly permanently) excepted, making the behavior unspecified. The
behavior for other device types is also left unspecified, but the wording is intended to imply that future standards might choose
to specify atomicity (or not).
There were recommendations to add format parameters to read() and write() in
order to handle networked transfers among heterogeneous file system and base hardware types. Such a facility may be required for
support by the OSI presentation of layer services. However, it was determined that this should correspond with similar C-language
facilities, and that is beyond the scope of this volume of POSIX.1-2024. The concept was suggested to the developers of the
ISO C standard for their consideration as a possible area for future work.
In 4.3 BSD, a read() or write() that is interrupted by a signal before
transferring any data does not by default return an [EINTR] error, but is restarted. In 4.2 BSD, 4.3 BSD, and the Eighth Edition,
there is an additional function, select(), whose purpose is to pause until specified
activity (data to read, space to write, and so on) is detected on specified file descriptors. It is common in applications written
for those systems for select() to be used before read() in situations (such as
keyboard input) where interruption of I/O due to a signal is desired.
The issue of which files or file types are interruptible is considered an implementation design issue. This is often affected
primarily by hardware and reliability issues.
There are no references to actions taken following an "unrecoverable error". It is considered beyond the scope of this volume
of POSIX.1-2024 to describe what happens in the case of hardware errors.
Earlier versions of this standard allowed two very different behaviors with regard to the handling of interrupts. In order to
minimize the resulting confusion, it was decided that POSIX.1-2024 should support only one of these behaviors. Historical practice
on AT&T-derived systems was to have read() and write() return -1 and set
errno to [EINTR] when interrupted after some, but not all, of the data requested had been transferred. However, the US
Department of Commerce FIPS 151-1 and FIPS 151-2 require the historical BSD behavior, in which read() and write() return the number of bytes actually transferred before the interrupt. If -1 is
returned when any data is transferred, it is difficult to recover from the error on a seekable device and impossible on a
non-seekable device. Most new implementations support this behavior. The behavior required by POSIX.1-2024 is to return the number
of bytes transferred.
POSIX.1-2024 does not specify when an implementation that buffers read()s actually moves the data into the user-supplied
buffer, so an implementation may choose to do this at the latest possible moment. Therefore, an interrupt arriving earlier may not
cause read() to return a partial byte count, but rather to return -1 and set errno to [EINTR].
Consideration was also given to combining the two previous options, and setting errno to [EINTR] while returning a short
count. However, not only is there no existing practice that implements this, it is also contradictory to the idea that when
errno is set, the function responsible shall return -1.
This volume of POSIX.1-2024 intentionally does not specify any pread() errors related to pipes, FIFOs, and sockets other
than [ESPIPE].
FUTURE DIRECTIONS
None.
SEE ALSO
fcntl(), lseek(), open(), pipe(), readv()
XBD 11. General Terminal Interface, ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Realtime Extension and the POSIX Threads Extension.
Large File Summit extensions are added.
The pread() function is added.
Issue 6
The DESCRIPTION and ERRORS sections are updated so that references to STREAMS are marked as part of the XSI STREAMS Option
Group.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The DESCRIPTION now states that if read() is interrupted by a signal after it has successfully read some data, it returns
the number of bytes read. In Issue 3, it was optional whether read() returned the number of bytes read, or whether it
returned -1 with errno set to [EINTR]. This is a FIPS requirement.
In the DESCRIPTION, text is added to indicate that for regular files, no data transfer occurs past the offset maximum
established in the open file description associated with fildes. This change is to support large files.
The [EOVERFLOW] mandatory error condition is added.
The [ENXIO] optional error condition is added.
Text referring to sockets is added to the DESCRIPTION.
The following changes were made to align with the IEEE P1003.1a draft standard:
The effect of reading zero bytes is clarified.
The DESCRIPTION is updated for alignment with IEEE Std 1003.1j-2000 by specifying that read() results are
unspecified for typed memory objects.
New RATIONALE is added to explain the atomicity requirements for input and output operations.
The following error conditions are added for operations on sockets: [EAGAIN], [ECONNRESET], [ENOTCONN], and [ETIMEDOUT].
The [EIO] error is made optional.
The following error conditions are added for operations on sockets: [ENOBUFS] and [ENOMEM].
The readv() function is split out into a separate reference page.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/108 is applied, updating the [EAGAIN] error in the ERRORS
section from "the process would be delayed" to "the thread would be delayed".
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/109 is applied, making an editorial correction in the RATIONALE
section.
Issue 7
The pread() function is moved from the XSI option to the Base.
Functionality relating to the XSI STREAMS option is marked obsolescent.
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0480 [218], XSH/TC1-2008/0481 [79], XSH/TC1-2008/0482 [218],
XSH/TC1-2008/0483 [218], XSH/TC1-2008/0484 [218], and XSH/TC1-2008/0485 [218,428] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0302 [710] and XSH/TC2-2008/0303 [676,710] are applied.
Issue 8
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcsncasecmp_l.html =====
wcscasecmp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcscasecmp, wcscasecmp_l, wcsncasecmp, wcsncasecmp_l — case-insensitive wide-character string comparison
SYNOPSIS
[CX]  #include
int wcscasecmp(const wchar_t *ws1, const wchar_t *ws2);
int wcscasecmp_l(const wchar_t *ws1, const wchar_t *ws2,
locale_t locale);
int wcsncasecmp(const wchar_t *ws1, const wchar_t *ws2, size_t n);
int wcsncasecmp_l(const wchar_t *ws1, const wchar_t *ws2,
size_t n, locale_t locale);
DESCRIPTION
The wcscasecmp() and wcsncasecmp() functions are the wide-character equivalent of the strcasecmp() and strncasecmp()
functions, respectively.
The wcscasecmp() and wcscasecmp_l() functions shall compare, while ignoring differences in case, the
wide-character string pointed to by ws1 to the wide-character string pointed to by ws2.
The wcsncasecmp() and wcsncasecmp_l() functions shall compare, while ignoring differences in case, not more than
n wide-characters from the wide-character string pointed to by ws1 to the wide-character string pointed to by
ws2.
The wcscasecmp() and wcsncasecmp() functions use the current locale to determine the case of the wide
characters.
The wcscasecmp_l() and wcsncasecmp_l() functions use the locale represented by locale to determine the case
of the wide characters.
When the LC_CTYPE category of the locale being used is from the POSIX locale, these functions shall behave as if the
wide-character strings had been converted to lowercase and then a comparison of wide-character codes performed. Otherwise, the
results are unspecified.
The information for wcscasecmp_l() and wcsncasecmp_l() about the case of the characters comes from the locale
represented by locale.
The behavior is undefined if the locale argument to wcscasecmp_l() or wcsncasecmp_l() is the special locale
object LC_GLOBAL_LOCALE or is not a valid locale object handle.
RETURN VALUE
Upon completion, the wcscasecmp() and wcscasecmp_l() functions shall return an integer greater than, equal to, or
less than 0 if the wide-character string pointed to by ws1 is, ignoring case, greater than, equal to, or less than the
wide-character string pointed to by ws2, respectively.
Upon completion, the wcsncasecmp() and wcsncasecmp_l() functions shall return an integer greater than, equal to,
or less than 0 if the possibly null wide-character terminated string pointed to by ws1 is, ignoring case, greater than,
equal to, or less than the possibly null wide-character terminated string pointed to by ws2, respectively.
No return values are reserved to indicate an error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
strcasecmp(), wcscmp(),
wcsncmp()
XBD
CHANGE HISTORY
First released in Issue 7.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0716 [294], XSH/TC1-2008/0717 [283], and XSH/TC1-2008/0718 [283] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ferror.html =====
ferror
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ferror — test error indicator on a stream
SYNOPSIS
#include
int ferror(FILE *stream);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The ferror() function shall test the error indicator for the stream pointed to by stream.
[CX]  The
ferror() function shall not change the setting of errno if stream is valid.
RETURN VALUE
The ferror() function shall return non-zero if and only if the error indicator is set for stream.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
clearerr(), feof(), fopen()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0125 [401] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/vfwprintf.html =====
vfwprintf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
vfwprintf, vswprintf, vwprintf — wide-character formatted output of a stdarg argument list
SYNOPSIS
#include
#include
#include
int vfwprintf(FILE *restrict stream, const wchar_t *restrict format,
va_list arg);
int vswprintf(wchar_t *restrict ws, size_t n,
const wchar_t *restrict format, va_list arg);
int vwprintf(const wchar_t *restrict format, va_list arg);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The vfwprintf(), vswprintf(), and vwprintf() functions shall be equivalent to fwprintf(), swprintf(), and wprintf() respectively, except that instead of being called with a variable number of
arguments, they are called with an argument list as defined by .
These functions shall not invoke the va_end macro. However, as these functions do invoke the va_arg macro, the
value of ap after the return is unspecified.
RETURN VALUE
Refer to fwprintf().
ERRORS
Refer to fwprintf().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications using these functions should call va_end(ap) afterwards to clean up.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fwprintf()
XBD , ,
CHANGE HISTORY
First released in Issue 5. Included for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E).
Issue 6
The vfwprintf(), vswprintf(), and vwprintf() prototypes are updated for alignment with the
ISO/IEC 9899:1999 standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0705 [14] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/cacosl.html =====
cacos
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cacos, cacosf, cacosl — complex arc cosine functions
SYNOPSIS
#include
double complex cacos(double complex z);
float complex cacosf(float complex z);
long double complex cacosl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex arc cosine of z, with branch cuts outside the interval [-1, +1] along the
real axis.
RETURN VALUE
These functions shall return the complex arc cosine value, in the range of a strip mathematically unbounded along the imaginary
axis and in the interval [0, ℼ] along the real axis.
[MXC]
cacos(conj(z)), cacosf(conjf(z)), and cacosl(conjl(z)) shall return
exactly the same value as conj(cacos(z)), conjf(cacosf(z)), and
conjl(cacosl(z)), respectively, including for the special values of z below.
If z is ±0 + i0, ℼ/2 - i0 shall be returned.
If z is ±0 + iNaN, ℼ/2 + iNaN shall be returned.
If z is x + iInf where x is finite, ℼ/2 - iInf shall be returned.
If z is x + iNaN where x is non-zero and finite, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is -Inf + iy where y is positive-signed and finite, ℼ - iInf shall be returned.
If z is +Inf + iy where y is positive-signed and finite, +0 - iInf shall be returned.
If z is -Inf + iInf, 3ℼ/4 - iInf shall be returned.
If z is +Inf + iInf, ℼ/4 - iInf shall be returned.
If z is ±Inf + iNaN, NaN ± iInf shall be returned; the sign of the imaginary part of the result is
unspecified.
If z is NaN + iy where y is finite, NaN + iNaN shall be returned and the invalid floating-point
exception may be raised.
If z is NaN + iInf, NaN - iInf shall be returned.
If z is NaN + iNaN, NaN - iNaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
ccos()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getutxline.html =====
endutxent
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
endutxent, getutxent, getutxid, getutxline, pututxline, setutxent — user accounting database functions
SYNOPSIS
[XSI]  #include
void endutxent(void);
struct utmpx *getutxent(void);
struct utmpx *getutxid(const struct utmpx *id);
struct utmpx *getutxline(const struct utmpx *line);
struct utmpx *pututxline(const struct utmpx *utmpx);
void setutxent(void);
DESCRIPTION
These functions shall provide access to the user accounting database.
The getutxent() function shall read the next entry from the user accounting database. If the database is not already
open, it shall open it. If it reaches the end of the database, it shall fail.
The getutxid() function shall search forward from the current point in the database. If the ut_type value of the
utmpx structure pointed to by id is BOOT_TIME, OLD_TIME, or NEW_TIME, then it shall stop when it finds an entry with
a matching ut_type value. If the ut_type value is INIT_PROCESS, LOGIN_PROCESS, USER_PROCESS, or DEAD_PROCESS, then it
shall stop when it finds an entry whose type is one of these four and whose ut_id member matches the ut_id member of
the utmpx structure pointed to by id. If the end of the database is reached without a match, getutxid() shall
fail.
The getutxline() function shall search forward from the current point in the database until it finds an entry of the type
LOGIN_PROCESS or USER_PROCESS which also has a ut_line value matching that in the utmpx structure pointed to by
line. If the end of the database is reached without a match, getutxline() shall fail.
The getutxid() or getutxline() function may cache data. For this reason, to use getutxline() to search for
multiple occurrences, the application shall zero out the static data after each success, or getutxline() may return a
pointer to the same utmpx structure.
There is one exception to the rule about clearing the structure before further reads are done. The implicit read done by
pututxline() (if it finds that it is not already at the correct place in the user accounting database) shall not modify the
static structure returned by getutxent(), getutxid(), or getutxline(), if the application has modified this
structure and passed the pointer back to pututxline().
For all entries that match a request, the ut_type member indicates the type of the entry. Other members of the entry
shall contain meaningful data based on the value of the ut_type member as follows:
ut_type Member
Other Members with Meaningful Data
EMPTY
No others
BOOT_TIME
ut_tv
OLD_TIME
ut_tv
NEW_TIME
ut_tv
USER_PROCESS
ut_id, ut_user (login name of the user), ut_line, ut_pid, ut_tv
INIT_PROCESS
ut_id, ut_pid, ut_tv
LOGIN_PROCESS
ut_id, ut_user (implementation-defined name of the login process), ut_line, ut_pid,
ut_tv
DEAD_PROCESS
ut_id, ut_pid, ut_tv
An implementation that provides extended security controls may impose implementation-defined restrictions on
accessing the user accounting database. In particular, the system may deny the existence of some or all of the user accounting
database entries associated with users other than the caller.
If the process has appropriate privileges, the pututxline() function shall write out the structure into the
user accounting database. It shall search for a record as if by getutxid() that satisfies the request. If this search
succeeds, then the entry shall be replaced. Otherwise, a new entry shall be made at the end of the user accounting database.
The endutxent() function shall close the user accounting database.
The setutxent() function shall reset the input to the beginning of the database. This should be done before
each search for a new entry if it is desired that the entire database be examined.
These functions need not be thread-safe.
RETURN VALUE
Upon successful completion, getutxent(), getutxid(), and getutxline() shall return a pointer to a
utmpx structure containing a copy of the requested entry in the user accounting database. Otherwise, a null pointer shall be
returned.
The return value may point to a static area which is overwritten by a subsequent call to getutxid() or
getutxline().
Upon successful completion, pututxline() shall return a pointer to a utmpx structure containing a
copy of the entry added to the user accounting database. Otherwise, a null pointer shall be returned.
The endutxent() and setutxent() functions shall not return a value.
ERRORS
No errors are defined for the endutxent(), getutxent(), getutxid(), getutxline(), and
setutxent() functions.
The pututxline() function may fail if:
[EPERM]
The process does not have appropriate privileges.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The sizes of the arrays in the structure can be found using the sizeof operator.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Normative text previously in the APPLICATION USAGE section is moved to the DESCRIPTION.
A note indicating that these functions need not be reentrant is added to the DESCRIPTION.
Issue 6
In the DESCRIPTION, the note about reentrancy is expanded to cover thread-safety.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0090 [213,428] and XSH/TC1-2008/0091 [213] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcspbrk.html =====
wcspbrk
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcspbrk — scan a wide-character string for a wide-character code
SYNOPSIS
#include
wchar_t *wcspbrk(const wchar_t *ws1, const wchar_t *ws2);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The wcspbrk() function shall locate the first occurrence in the wide-character string pointed to by ws1 of any
wide-character code from the wide-character string pointed to by ws2.
[CX]  The
wcspbrk() function shall not change the setting of errno on valid input.
RETURN VALUE
Upon successful completion, wcspbrk() shall return a pointer to the wide-character code or a null pointer if no
wide-character code from ws2 occurs in ws1.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
wcschr(), wcsrchr()
XBD
CHANGE HISTORY
First released in Issue 4. Derived from the MSE working draft.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that wcspbrk() does not change the setting of errno on
valid input.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/isalnum_l.html =====
isalnum
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
isalnum, isalnum_l — test for an alphanumeric character
SYNOPSIS
#include
int isalnum(int c);
[CX]  int isalnum_l(int c, locale_t locale);
DESCRIPTION
For isalnum(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The isalnum() [CX]   and isalnum_l()
functions shall test whether c is a character of class alpha or digit in the current locale,
[CX]
or in the locale represented by locale,  respectively;
see XBD 7. Locale.
The c argument is an int, the value of which the application shall ensure is representable as an unsigned
char or equal to the value of the macro EOF. If the argument has any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to isalnum_l() is the special locale object LC_GLOBAL_LOCALE or is not a
valid locale object handle.
RETURN VALUE
The isalnum() [CX]   and isalnum_l()
functions shall return non-zero if c is an alphanumeric character; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
isalpha(), isblank(), iscntrl(), isdigit(), isgraph(), islower(), isprint(), ispunct(), isspace(), isupper(), isxdigit(), setlocale(), uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The isalnum_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0274 [302], XSH/TC1-2008/0275 [283], and XSH/TC1-2008/0276 [283] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/tcsetattr.html =====
tcsetattr
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
tcsetattr — set the parameters associated with the terminal
SYNOPSIS
#include
int tcsetattr(int fildes, int optional_actions,
const struct termios *termios_p);
DESCRIPTION
The tcsetattr() function shall set the parameters associated with the terminal referred to by the open file descriptor
fildes (an open file descriptor associated with a terminal) from the termios structure referenced by termios_p
as follows:
If optional_actions is TCSANOW, the change shall occur immediately.
If optional_actions is TCSADRAIN, the change shall occur after all output written to fildes is transmitted. This
function should be used when changing parameters that affect output.
If optional_actions is TCSAFLUSH, the change shall occur after all output written to fildes is transmitted, and
all input so far received but not read shall be discarded before the change is made.
If the output baud rate stored in the termios structure pointed to by termios_p is the zero baud rate, B0, the
modem control lines shall no longer be asserted. Normally, this shall disconnect the line.
If the input baud rate stored in the termios structure pointed to by termios_p is 0, the input baud rate given to
the hardware is the same as the output baud rate stored in the termios structure.
The tcsetattr() function shall return successfully if it was able to perform any of the requested actions, even if some
of the requested actions could not be performed. It shall set all the attributes that the implementation supports as requested and
leave all the attributes not supported by the implementation unchanged. If no part of the request can be honored, it shall return
-1 and set errno to [EINVAL]. If the input and output baud rates differ and are a combination that is not supported, neither
baud rate shall be changed. A subsequent call to tcgetattr() shall return the
actual state of the terminal device (reflecting both the changes made and not made in the previous tcsetattr() call). The
tcsetattr() function shall not change the values found in the termios structure under any circumstances.
The effect of tcsetattr() is undefined if the value of the termios structure pointed to by termios_p was
not derived from the result of a call to tcgetattr() on fildes; an
application should modify only fields and flags defined by this volume of POSIX.1-2024 between the call to tcgetattr() and tcsetattr(), leaving all other fields and flags unmodified.
No actions defined by this volume of POSIX.1-2024, other than a call to tcsetattr(), a close of the last file descriptor
in the system associated with this terminal device, or an open of the first file descriptor in the system associated with this
terminal device (using the O_TTY_INIT flag if it is non-zero and the device is not a pseudo-terminal), shall cause any of the
terminal attributes defined by this volume of POSIX.1-2024 to change.
If tcsetattr() is called from a process which is a member of a background process group on a fildes associated
with its controlling terminal:
If the calling thread is blocking SIGTTOU signals or the process is ignoring SIGTTOU signals, the operation completes normally
and no signal is sent.
Otherwise, a SIGTTOU signal shall be sent to the process group.
RETURN VALUE
Upon successful completion, 0 shall be returned. Otherwise, -1 shall be returned and errno set to indicate the error.
ERRORS
The tcsetattr() function shall fail if:
[EBADF]
The fildes argument is not a valid file descriptor.
[EINTR]
A signal interrupted tcsetattr().
[EINVAL]
The optional_actions argument is not a supported value, or an attempt was made to change an attribute represented in the
termios structure to an unsupported value.
[EIO]
The process group of the writing process is orphaned, the calling thread is not blocking SIGTTOU, and the process is not
ignoring SIGTTOU.
[ENOTTY]
The file associated with fildes is not a terminal.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
If trying to change baud rates, applications should call tcsetattr() then call tcgetattr() in order to determine what baud rates were actually selected.
In general, there are two reasons for an application to change the parameters associated with a terminal device:
The device already has working parameter settings but the application needs a different behavior, such as non-canonical mode
instead of canonical mode. The application sets (or clears) only a few flags or c_cc[] values. Typically, the terminal
device in this case is either the controlling terminal for the process or a pseudo-terminal.
The device is a modem or similar piece of equipment connected by a serial line, and it was not open before the application
opened it. In this case, the application needs to initialize all of the parameter settings "from scratch". However, since the
termios structure may include both standard and non-standard parameters, the application cannot just initialize the whole
structure in an arbitrary way (e.g., using memset()) as this may cause some of the
non-standard parameters to be set incorrectly, resulting in non-conforming behavior of the terminal device. Conversely, the
application cannot just set the standard parameters, assuming that the non-standard parameters will already have suitable values,
as the device might previously have been used with non-conforming parameter settings (and some implementations retain the settings
from one use to the next). The solution is to open the terminal device using the O_TTY_INIT flag to initialize the terminal device
to have conforming parameter settings, obtain those settings using tcgetattr(),
and then set all of the standard parameters to the desired settings.
RATIONALE
The tcsetattr() function can be interrupted in the following situations:
It is interrupted while waiting for output to drain.
It is called from a process in a background process group and SIGTTOU is caught.
See also the RATIONALE section in tcgetattr().
FUTURE DIRECTIONS
Using an input baud rate of 0 to set the input rate equal to the output rate may not necessarily be supported in a future
version of this volume of POSIX.1-2024.
SEE ALSO
cfgetispeed(), tcgetattr()
XBD 11. General Terminal Interface,
CHANGE HISTORY
First released in Issue 3. Included for alignment with the POSIX.1-1988 standard.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the DESCRIPTION, text previously conditional on _POSIX_JOB_CONTROL is now mandated. This is a FIPS requirement.
The [EIO] error is added.
In the DESCRIPTION, the text describing use of tcsetattr() from a process which is a member of a background process group
is clarified.
Issue 7
Austin Group Interpretation 1003.1-2001 #144 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0652 [79], XSH/TC1-2008/0653 [79], and XSH/TC1-2008/0654 [79] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_mutex_clocklock.html =====
pthread_mutex_clocklock
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_mutex_clocklock, pthread_mutex_timedlock — lock a mutex
SYNOPSIS
#include
int pthread_mutex_clocklock(pthread_mutex_t *restrict mutex,
clockid_t clock_id, const struct timespec *restrict
abstime);
int pthread_mutex_timedlock(pthread_mutex_t *restrict mutex,
const struct timespec *restrict abstime);
DESCRIPTION
The pthread_mutex_clocklock() and pthread_mutex_timedlock() functions shall lock the mutex object referenced by
mutex. If the mutex is already locked, the calling thread shall block until the mutex becomes available as in the pthread_mutex_lock() function. If the mutex cannot be locked without waiting for
another thread to unlock the mutex, this wait shall be terminated when the specified timeout expires.
The timeout shall expire when the absolute time specified by abstime passes, as measured by the clock on which timeouts
are based (that is, when the value of that clock equals or exceeds abstime), or if the absolute time specified by
abstime has already been passed at the time of the call.
For pthread_mutex_timedlock(), the timeout shall be based on the CLOCK_REALTIME clock. For
pthread_mutex_clocklock(), the timeout shall be based on the clock specified by the clock_id argument. The resolution
of the timeout shall be the resolution of the clock on which it is based. Implementations shall support passing CLOCK_REALTIME and
CLOCK_MONOTONIC to pthread_mutex_clocklock() as the clock_id argument.
Under no circumstance shall the function fail with a timeout if the mutex can be locked immediately. The validity of the
abstime parameter need not be checked if the mutex can be locked immediately.
[RPI|TPI]  As a consequence of the priority inheritance rules (for mutexes initialized with the PRIO_INHERIT protocol), if a timed mutex
wait is terminated because its timeout expires, the priority of the owner of the mutex shall be adjusted as necessary to reflect
the fact that this thread is no longer among the threads waiting for the mutex.
If mutex is a robust mutex and the process containing the owning thread terminated while holding the mutex lock, a call
to pthread_mutex_clocklock() or pthread_mutex_timedlock() shall return the error value [EOWNERDEAD]. If mutex
is a robust mutex and the owning thread terminated while holding the mutex lock, a call to pthread_mutex_clocklock() or
pthread_mutex_timedlock() may return the error value [EOWNERDEAD] even if the process in which the owning thread resides has
not terminated. In these cases, the mutex is locked by the thread but the state it protects is marked as inconsistent. The
application should ensure that the state is made consistent for reuse and when that is complete call pthread_mutex_consistent(). If the application is unable to recover the
state, it should unlock the mutex without a prior call to pthread_mutex_consistent(), after which the mutex is marked permanently
unusable.
If mutex does not refer to an initialized mutex object, the behavior is undefined.
RETURN VALUE
If successful, the pthread_mutex_clocklock() and pthread_mutex_timedlock() functions shall return zero; otherwise,
an error number shall be returned to indicate the error.
ERRORS
The pthread_mutex_clocklock() and pthread_mutex_timedlock() functions shall fail if:
[EAGAIN]
The mutex could not be acquired because the maximum number of recursive locks for mutex has been exceeded.
[EAGAIN]
The mutex is a robust mutex and the system resources available for robust mutexes owned would be exceeded.
[EDEADLK]
The mutex type is PTHREAD_MUTEX_ERRORCHECK and the current thread already owns the mutex.
[EINVAL]
The mutex was created with the protocol attribute having the value PTHREAD_PRIO_PROTECT and the calling thread's priority is
higher than the mutex' current priority ceiling.
[EINVAL]
The process or thread would have blocked, and either the abstime parameter specified a nanoseconds field value less than
zero or greater than or equal to 1000 million, or the pthread_mutex_clocklock() function was passed an invalid or
unsupported clock_id value.
[ENOTRECOVERABLE]
The state protected by the mutex is not recoverable.
[EOWNERDEAD]
The mutex is a robust mutex and the process containing the previous owning thread terminated while holding the mutex lock. The
mutex lock shall be acquired by the calling thread and it is up to the new owner to make the state consistent.
[ETIMEDOUT]
The mutex could not be locked before the specified timeout expired.
The pthread_mutex_clocklock() and pthread_mutex_timedlock() functions may fail if:
[EDEADLK]
A deadlock condition was detected.
[EOWNERDEAD]
The mutex is a robust mutex and the previous owning thread terminated while holding the mutex lock. The mutex lock shall be
acquired by the calling thread and it is up to the new owner to make the state consistent.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications that have assumed that non-zero return values are errors will need updating for use with robust mutexes, since a
valid return for a thread acquiring a mutex which is protecting a currently inconsistent state is [EOWNERDEAD]. Applications that
do not check the error returns, due to ruling out the possibility of such errors arising, should not use robust mutexes. If an
application is supposed to work with normal and robust mutexes, it should check all return values for error conditions and if
necessary take appropriate action.
RATIONALE
Refer to pthread_mutex_lock().
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_mutex_destroy(), pthread_mutex_lock(), time()
XBD 4.15.2 Memory Synchronization, ,
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1d-1999.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/99 is applied, marking the last paragraph in the DESCRIPTION as
part of the Thread Priority Inheritance option.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/100 is applied, updating the ERRORS section so that the
[EDEADLK] error includes detection of a deadlock condition.
Issue 7
Changes are made from The Open Group Technical Standard, 2006, Extended API Set Part 3.
The pthread_mutex_timedlock() function is moved from the Timeouts option to the Base.
Functionality relating to the Timers option is moved to the Base.
The DESCRIPTION is updated to clarify the behavior when mutex does not refer to an initialized mutex.
The ERRORS section is updated to account properly for all of the various mutex types.
Issue 8
Austin Group Defect 354 is applied, adding the [EAGAIN] error for exceeding system resources available for robust mutexes
owned.
Austin Group Defect 592 is applied, removing text relating to  from
the SYNOPSIS and DESCRIPTION sections.
Austin Group Defects 1216 and 1472 are applied, adding pthread_mutex_clocklock().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_mutexattr_gettype.html =====
pthread_mutexattr_gettype
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_mutexattr_gettype, pthread_mutexattr_settype — get and set the mutex type attribute
SYNOPSIS
#include
int pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict attr,
int *restrict type);
int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int type);
DESCRIPTION
The pthread_mutexattr_gettype() and pthread_mutexattr_settype() functions, respectively, shall get and set the
mutex type attribute. This attribute is set in the type parameter to these functions. The default value of the
type attribute is PTHREAD_MUTEX_DEFAULT.
The type of mutex is contained in the type attribute of the mutex attributes. Valid mutex types include:
PTHREAD_MUTEX_NORMAL
PTHREAD_MUTEX_ERRORCHECK
PTHREAD_MUTEX_RECURSIVE
PTHREAD_MUTEX_DEFAULT
The mutex type affects the behavior of calls which lock and unlock the mutex. See pthread_mutex_lock() for details. An implementation may map
PTHREAD_MUTEX_DEFAULT to one of the other mutex types.
The behavior is undefined if the value specified by the attr argument to pthread_mutexattr_gettype() or
pthread_mutexattr_settype() does not refer to an initialized mutex attributes object.
RETURN VALUE
Upon successful completion, the pthread_mutexattr_gettype() function shall return zero and store the value of the
type attribute of attr into the object referenced by the type parameter. Otherwise, an error shall be returned
to indicate the error.
If successful, the pthread_mutexattr_settype() function shall return zero; otherwise, an error number shall be returned
to indicate the error.
ERRORS
The pthread_mutexattr_settype() function shall fail if:
[EINVAL]
The value type is invalid.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
It is advised that an application should not use a PTHREAD_MUTEX_RECURSIVE mutex with condition variables because the implicit
unlock performed in a pthread_cond_clockwait(), pthread_cond_timedwait(), or pthread_cond_wait() call may not actually release the mutex (if it had been locked
multiple times). If this happens, no other thread can satisfy the condition of the predicate.
RATIONALE
If an implementation detects that the value specified by the attr argument to pthread_mutexattr_gettype() or
pthread_mutexattr_settype() does not refer to an initialized mutex attributes object, it is recommended that the function
should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_cond_clockwait(), pthread_mutex_lock()
XBD
CHANGE HISTORY
First released in Issue 5.
Issue 6
The Open Group Corrigendum U033/3 is applied. The SYNOPSIS for pthread_mutexattr_gettype() is updated so that the first
argument is of type const pthread_mutexattr_t *.
The restrict keyword is added to the pthread_mutexattr_gettype() prototype for alignment with the
ISO/IEC 9899:1999 standard.
Issue 7
The pthread_mutexattr_gettype() and pthread_mutexattr_settype() functions are moved from the XSI option to the
Base.
The [EINVAL] error for an uninitialized mutex attributes object is removed; this condition results in undefined behavior.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0464 [121] is applied.
Issue 8
Austin Group Defect 1216 is applied, adding pthread_cond_clockwait().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/aio_error.html =====
aio_error
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
aio_error — retrieve errors status for an asynchronous I/O operation
SYNOPSIS
#include
int aio_error(const struct aiocb *aiocbp);
DESCRIPTION
The aio_error() function shall return the error status associated with the aiocb structure referenced by the
aiocbp argument. The error status for an asynchronous I/O operation is the errno value that would be set by the
corresponding read(), write(),
[SIO]
fdatasync(),  or
fsync() operation. If the operation has not yet completed, then the error status shall
be equal to [EINPROGRESS].
If the aiocb structure pointed to by aiocbp is not associated with an operation that has been scheduled, the
results are undefined.
RETURN VALUE
If the asynchronous I/O operation has completed successfully, then 0 shall be returned. If the asynchronous operation has
completed unsuccessfully, then the error status, as described for read(), write(), [SIO]  fdatasync(),  and fsync(), shall be returned.
If the asynchronous I/O operation has not yet completed, then [EINPROGRESS] shall be returned.
If the aio_error() function fails, it shall return -1 and set errno to indicate the error.
ERRORS
The aio_error() function may fail if:
[EINVAL]
The aiocbp argument does not refer to an asynchronous operation whose return status has not yet been retrieved.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
aio_cancel(), aio_fsync()
, aio_read(), aio_return(),
aio_write(), close(), exec, exit(), fork(), lio_listio(), lseek(), read()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the
Asynchronous Input and Output option.
The APPLICATION USAGE section is added.
Issue 7
Austin Group Interpretation 1003.1-2001 #045 is applied.
SD5-XSH-ERN-148 is applied.
The aio_error() function is moved from the Asynchronous Input and Output option to the Base.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atanl.html =====
atan
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atan, atanf, atanl — arc tangent function
SYNOPSIS
#include
double atan(double x);
float atanf(float x);
long double atanl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the principal value of the arc tangent of their argument x.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the arc tangent of x in the range [-ℼ/2,ℼ/2] radians.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, x shall be returned.
If x is ±Inf, ±ℼ/2 shall be returned.
[MXX]
If x is subnormal, x should be returned.
[MX]  If x is subnormal, a range error may occur and, if x is
not returned, atan(), atanf(), and atanl() shall return an implementation-defined value no greater in
magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
ERRORS
These functions may fail if:
Range Error
[MX]
The value of x is subnormal.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
atan2(), feclearexcept(),
fetestexcept(), isnan(),
tan()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The atanf() and atanl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0037 [68] is applied.
Issue 8
Austin Group Defect 1382 is applied, rearranging the text describing the behavior when x is subnormal to avoid the need
for two shading changes.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/qsort.html =====
qsort
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
qsort, qsort_r — sort a table of data
SYNOPSIS
#include
void qsort(void *base, size_t nel, size_t width,
int (*compar)(const void *, const void *));
[CX]  void qsort_r(void *base, size_t nel, size_t width,
int (*compar)(const void *, const void *, void *), void *arg);
DESCRIPTION
For qsort(): [CX]  The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The qsort() function shall sort an array of nel objects, the initial element of which is pointed to by
base. The size of each object, in bytes, is specified by the width argument. If the nel argument has the value
zero, the comparison function pointed to by compar shall not be called and no rearrangement shall take place.
The application shall ensure that the comparison function pointed to by compar does not alter the contents of the array.
The implementation may reorder elements of the array between calls to the comparison function, but shall not alter the contents of
any individual element.
When the same objects (consisting of width bytes, irrespective of their current positions in the array) are passed more than
once to the comparison function, the results shall be consistent with one another. That is, they shall define a total ordering on
the array.
The contents of the array shall be sorted in ascending order according to a comparison function. The compar argument is a
pointer to the comparison function, which is called with two arguments that point to the elements being compared. The application
shall ensure that the function returns an integer less than, equal to, or greater than 0, if the first argument is considered
respectively less than, equal to, or greater than the second. If two members compare as equal, their order in the sorted array is
unspecified.
[CX]  The
qsort_r() function shall be identical to qsort() except that the comparison function compar takes a third
argument. The arg opaque pointer passed to qsort_r() shall in turn be passed as the third argument to the comparison
function.
RETURN VALUE
These functions shall not return a value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The comparison function need not compare every byte, so arbitrary data may be contained in the elements in addition to the
values being compared.
If the compar callback function requires any additional state outside of the items being sorted, it can only access this
state through global variables, making it potentially unsafe to use qsort() with the same compar function from
separate threads at the same time. The qsort_r() function was added with the ability to pass through arbitrary arguments to
the comparator, which avoids the need to access global variables and thus making it possible to safely share a stateful comparator
across threads.
RATIONALE
The requirement that each argument (hereafter referred to as p) to the comparison function is a pointer to elements of
the array implies that for every call, for each argument separately, all of the following expressions are non-zero:
((char *)p - (char *)base) % width == 0
(char *)p >= (char *)base
(char *)p
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/49 is applied, adding the last sentence to the first non-shaded
paragraph in the DESCRIPTION, and the following two paragraphs. The RATIONALE is also updated. These changes are for alignment with
the ISO C standard.
Issue 8
Austin Group Defect 900 is applied, adding the qsort_r() function.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/cnd_init.html =====
cnd_destroy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cnd_destroy, cnd_init — destroy and initialize condition variables
SYNOPSIS
#include
void cnd_destroy(cnd_t *cond);
int cnd_init(cnd_t *cond);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The cnd_destroy() function shall release all resources used by the condition variable pointed to by cond. It shall
be safe to destroy an initialized condition variable upon which no threads are currently blocked. Attempting to destroy a condition
variable upon which other threads are currently blocked results in undefined behavior. A destroyed condition variable object can be
reinitialized using cnd_init(); the results of otherwise referencing the object after it has been destroyed are undefined.
The behavior is undefined if the value specified by the cond argument to cnd_destroy() does not refer to an
initialized condition variable.
The cnd_init() function shall initialize a condition variable. If it succeeds it shall set the variable pointed to by
cond to a value that uniquely identifies the newly initialized condition variable. Attempting to initialize an already
initialized condition variable results in undefined behavior. A thread that calls cnd_wait() on a newly initialized condition variable shall block.
[CX]  See
2.9.9 Synchronization Object Copies and Alternative Mappings for
further requirements.
These functions shall not be affected if the calling thread executes a signal handler during the call.
RETURN VALUE
The cnd_destroy() function shall not return a value.
The cnd_init() function shall return thrd_success on success, or thrd_nomem if no memory could be
allocated for the newly created condition variable, or thrd_error if the request could not be honored.
ERRORS
See RETURN VALUE.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
These functions are not affected by signal handlers for the reasons stated in XRAT B.2.3 Error Numbers.
FUTURE DIRECTIONS
None.
SEE ALSO
cnd_broadcast(), cnd_timedwait()
XBD
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/llrintl.html =====
llrint
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
llrint, llrintf, llrintl — round to the nearest integer value using current rounding direction
SYNOPSIS
#include
long long llrint(double x);
long long llrintf(float x);
long long llrintl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall round their argument to the nearest integer value, rounding according to the current rounding
direction.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the rounded integer value.
[MX]  If
x is NaN, a domain error shall occur, and an unspecified value is returned.
If x is +Inf, a domain error shall occur and an unspecified value is returned.
If x is -Inf, a domain error shall occur and an unspecified value is returned.
If the correct value is positive and too large to represent as a long long, an unspecified value shall be returned.
[MX]
On systems that support the IEC 60559 Floating-Point option, a domain error shall occur;   otherwise, a [CX]   domain  error may occur.
If the correct value is negative and too large to represent as a long long, an unspecified value shall be returned.
[MX]
On systems that support the IEC 60559 Floating-Point option, a domain error shall occur;   otherwise, a [CX]   domain  error may occur.
ERRORS
These functions shall fail if:
Domain Error
[MX]
The x argument is NaN or ±Inf, or the correct value is not representable as an integer.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
These functions may fail if:
Domain Error
The correct value is not representable as an integer.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
These functions provide floating-to-integer conversions. They round according to the current rounding direction. If the rounded
value is outside the range of the return type, the numeric result is unspecified and the invalid floating-point exception is
raised. When they raise no other floating-point exception and the result differs from the argument, they raise the inexact
floating-point exception.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), lrint()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #53 is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getpid.html =====
getpid
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getpid — get the process ID
SYNOPSIS
#include
pid_t getpid(void);
DESCRIPTION
The getpid() function shall return the process ID of the calling process.
RETURN VALUE
The getpid() function shall always be successful and no return value is reserved to indicate an error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
exec, fork(), getpgrp(), getppid(), kill(), mkdtemp(), setpgid(), setsid()
XBD ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
In the SYNOPSIS, the optional include of the  header is
removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/localeconv.html =====
localeconv
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
localeconv — return locale-specific information
SYNOPSIS
#include
struct lconv *localeconv(void);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The localeconv() function shall set the components of an object with the type struct lconv with the values
appropriate for the formatting of numeric quantities (monetary and otherwise) according to the rules of the current locale.
The members of the structure with type char * are pointers to strings, any of which (except decimal_point) can
point to "", to indicate that the value is not available in the current locale or is of zero length. The members with type
char are non-negative numbers, any of which can be {CHAR_MAX} to indicate that the value is not available in the current
locale.
The members include the following:
char *decimal_point
The radix character used to format non-monetary quantities.
char *thousands_sep
The character used to separate groups of digits before the decimal-point character in formatted non-monetary quantities.
char *grouping
A string whose elements taken as one-byte integer values indicate the size of each group of digits in formatted non-monetary
quantities.
char *int_curr_symbol
The international currency symbol applicable to the current locale. The first three characters contain the alphabetic international
currency symbol in accordance with those specified in the ISO 4217:2015 standard. The fourth character (immediately preceding
the null byte) is the character used to separate the international currency symbol from the monetary quantity.
char *currency_symbol
The local currency symbol applicable to the current locale.
char *mon_decimal_point
The radix character used to format monetary quantities.
char *mon_thousands_sep
The separator for groups of digits before the decimal-point in formatted monetary quantities.
char *mon_grouping
A string whose elements taken as one-byte integer values indicate the size of each group of digits in formatted monetary
quantities.
char *positive_sign
The string used to indicate a non-negative valued formatted monetary quantity.
char *negative_sign
The string used to indicate a negative valued formatted monetary quantity.
char int_frac_digits
The number of fractional digits (those after the decimal-point) to be displayed in an internationally formatted monetary
quantity.
char frac_digits
The number of fractional digits (those after the decimal-point) to be displayed in a formatted monetary quantity.
char p_cs_precedes
Set to 1 if the currency_symbol precedes the value for a non-negative formatted monetary quantity. Set to 0 if the symbol
succeeds the value.
char p_sep_by_space
Set to a value indicating the separation of the currency_symbol, the sign string, and the value for a non-negative formatted
monetary quantity.
char n_cs_precedes
Set to 1 if the currency_symbol precedes the value for a negative formatted monetary quantity. Set to 0 if the symbol
succeeds the value.
char n_sep_by_space
Set to a value indicating the separation of the currency_symbol, the sign string, and the value for a negative formatted
monetary quantity.
char p_sign_posn
Set to a value indicating the positioning of the positive_sign for a non-negative formatted monetary quantity.
char n_sign_posn
Set to a value indicating the positioning of the negative_sign for a negative formatted monetary quantity.
char int_p_cs_precedes
Set to 1 or 0 if the int_curr_symbol respectively precedes or succeeds the value for a non-negative internationally
formatted monetary quantity.
char int_n_cs_precedes
Set to 1 or 0 if the int_curr_symbol respectively precedes or succeeds the value for a negative internationally formatted
monetary quantity.
char int_p_sep_by_space
Set to a value indicating the separation of the int_curr_symbol, the sign string, and the value for a non-negative
internationally formatted monetary quantity.
char int_n_sep_by_space
Set to a value indicating the separation of the int_curr_symbol, the sign string, and the value for a negative
internationally formatted monetary quantity.
char int_p_sign_posn
Set to a value indicating the positioning of the positive_sign for a non-negative internationally formatted monetary
quantity.
char int_n_sign_posn
Set to a value indicating the positioning of the negative_sign for a negative internationally formatted monetary
quantity.
The elements of grouping and mon_grouping are interpreted according to the following:
{CHAR_MAX}
No further grouping is to be performed.
0
The previous element is to be repeatedly used for the remainder of the digits.
other
The integer value is the number of digits that comprise the current group. The next element is examined to determine the size
of the next group of digits before the current group.
The values of p_sep_by_space, n_sep_by_space, int_p_sep_by_space, and int_n_sep_by_space are
interpreted according to the following:
0
No space separates the currency symbol and value.
1
If the currency symbol and sign string are adjacent, a space separates them from the value; otherwise, a space separates the
currency symbol from the value.
2
If the currency symbol and sign string are adjacent, a space separates them; otherwise, a space separates the sign string from
the value.
For int_p_sep_by_space and int_n_sep_by_space, the fourth character of int_curr_symbol is used instead of a
space.
The values of p_sign_posn, n_sign_posn, int_p_sign_posn, and int_n_sign_posn are interpreted
according to the following:
0
Parentheses surround the quantity and currency_symbol or int_curr_symbol.
1
The sign string precedes the quantity and currency_symbol or int_curr_symbol.
2
The sign string succeeds the quantity and currency_symbol or int_curr_symbol.
3
The sign string immediately precedes the currency_symbol or int_curr_symbol.
4
The sign string immediately succeeds the currency_symbol or int_curr_symbol.
The implementation shall behave as if no function in this volume of POSIX.1-2024 calls localeconv().
The localeconv() function need not be thread-safe; however, localeconv() shall avoid data races with all other
functions.
RETURN VALUE
The localeconv() function shall return a pointer to the filled-in object. The application shall not modify the structure
to which the return value points, [CX]   nor any storage areas pointed to by pointers within the structure. The returned pointer, and
pointers within the structure, might be invalidated or   the
structure [CX]   or the storage areas   might be overwritten by a
subsequent call to localeconv(). In addition, [CX]   the returned pointer, and pointers within the structure, might be
invalidated or   the structure [CX]   or the storage
areas   might be overwritten by subsequent calls to setlocale() with the categories LC_ALL, LC_MONETARY, or LC_NUMERIC, [CX]   or by calls to
uselocale() which change the categories LC_MONETARY or LC_NUMERIC. The returned
pointer, pointers within the structure, the structure, and the storage areas might also be invalidated if the calling thread is
terminated.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The following table illustrates the rules which may be used by four countries to format monetary quantities.
Country
Positive Format
Negative Format
International Format
Italy
€.1.230
-€.1.230
EUR.1.230
Netherlands
€ 1.234,56
€ -1.234,56
EUR 1.234,56
Norway
kr1.234,56
kr1.234,56-
NOK 1.234,56
Switzerland
SFrs.1,234.56
SFrs.1,234.56C
CHF 1,234.56
For these four countries, the respective values for the monetary members of the structure returned by
localeconv() are:
Italy
Netherlands
Norway
Switzerland
int_curr_symbol
"EUR."
"EUR "
"NOK "
"CHF "
currency_symbol
"€."
"€"
"kr"
"SFrs."
mon_decimal_point
""
","
","
"."
mon_thousands_sep
"."
"."
"."
","
mon_grouping
"\3"
"\3"
"\3"
"\3"
positive_sign
""
""
""
""
negative_sign
"-"
"-"
"-"
"C"
int_frac_digits
0
2
2
2
frac_digits
0
2
2
2
p_cs_precedes
1
1
1
1
p_sep_by_space
0
1
0
0
n_cs_precedes
1
1
1
1
n_sep_by_space
0
1
0
0
p_sign_posn
1
1
1
1
n_sign_posn
1
4
2
2
int_p_cs_precedes
1
1
1
1
int_n_cs_precedes
1
1
1
1
int_p_sep_by_space
0
0
0
0
int_n_sep_by_space
0
0
0
0
int_p_sign_posn
1
1
1
1
int_n_sign_posn
1
4
4
2
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
fprintf(), fscanf(), isalpha(), nl_langinfo(), setlocale(), strcat(), strchr(), strcmp(), strcoll(), strcpy(), strftime(), strlen(), strpbrk(), strspn(), strtok(), strxfrm(), strtod(), uselocale()
XBD ,
CHANGE HISTORY
First released in Issue 4. Derived from the ANSI C standard.
Issue 6
A note indicating that this function need not be reentrant is added to the DESCRIPTION.
The RETURN VALUE section is rewritten to avoid use of the term "must".
This reference page is updated for alignment with the ISO/IEC 9899:1999 standard.
ISO/IEC 9899:1999 standard, Technical Corrigendum 1 is incorporated.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/31 is applied, removing references to
int_curr_symbol and updating the descriptions of p_sep_by_space and n_sep_by_space. These changes are for
alignment with the ISO C standard.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
The definitions of int_curr_symbol and currency_symbol are updated.
The examples in the APPLICATION USAGE section are updated.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0362 [75] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0200 [656] is applied.
Issue 8
Austin Group Defect 1302 is applied, aligning this function with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/div.html =====
div
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
div — compute the quotient and remainder of an integer division
SYNOPSIS
#include
div_t div(int numer, int denom);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The div() function shall compute the quotient and remainder of the division of the numerator numer by the
denominator denom. If the division is inexact, the resulting quotient is the integer of lesser magnitude that is the nearest
to the algebraic quotient. If the result cannot be represented, the behavior is undefined; otherwise,
quot*denom+rem shall equal numer.
RETURN VALUE
The div() function shall return a structure of type div_t, comprising both the quotient and the remainder. The
structure includes the following members, in any order:
int  quot;  /* quotient */
int  rem;   /* remainder */
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
ldiv()
XBD
CHANGE HISTORY
First released in Issue 4. Derived from the ISO C standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/tss_get.html =====
tss_get
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
tss_get, tss_set — thread-specific data management
SYNOPSIS
#include
void *tss_get(tss_t key);
int tss_set(tss_t key, void *val);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The tss_get() function shall return the value for the current thread held in the thread-specific storage identified by
key.
The tss_set() function shall set the value for the current thread held in the thread-specific storage identified by
key to val. This action shall not invoke the destructor associated with the key on the value being
replaced.
The application shall ensure that the tss_get() and tss_set() functions are only called with a value for
key that was returned by a call to tss_create() before the thread
commenced executing destructors.
The effect of calling tss_get() or tss_set() after key has been deleted with tss_delete() is undefined.
[CX]
Both tss_get() and tss_set() can be called from a thread-specific data destructor function. A call to
tss_get() for the thread-specific data key being destroyed shall return a null pointer, unless the value is changed (after
the destructor starts) by a call to tss_set(). Calling tss_set() from a thread-specific data destructor function may
result either in lost storage (after at least {PTHREAD_DESTRUCTOR_ITERATIONS} attempts at destruction) or in an infinite loop.
These functions shall not be affected if the calling thread executes a signal handler during the call.
RETURN VALUE
The tss_get() function shall return the value for the current thread. If no thread-specific data value is associated with
key, then a null pointer shall be returned.
The tss_set() function shall return thrd_success on success or thrd_error if the request could not be
honored.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
These functions are not affected by signal handlers for the reasons stated in XRAT B.2.3 Error Numbers.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_getspecific(), tss_create()
XBD
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ilogb.html =====
ilogb
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ilogb, ilogbf, ilogbl — return an unbiased exponent
SYNOPSIS
#include
int ilogb(double x);
int ilogbf(float x);
int ilogbl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall return the exponent part of their argument x. Formally, the return value is the integral part of
\(\log _r|x|\) as a signed integral value, for non-zero x, where r is the radix of the machine's floating-point
arithmetic, which is the value of FLT_RADIX defined in .
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the exponent part of x as a signed integer value. They are
equivalent to calling the corresponding logb() function and casting the returned value
to type int.
[MX]
When the correct result is representable in the range of the return type, the returned value shall be exact and shall be
independent of the current rounding direction mode.
If x is 0, the value FP_ILOGB0 shall be returned. [XSI|MX]   On XSI-conformant systems and on systems that support the IEC
60559 Floating-Point option, a domain error shall occur;
otherwise, a
[CX]  domain
error may occur.
If x is ±Inf, the value {INT_MAX} shall be returned. [XSI|MX]
On XSI-conformant systems and on systems that support the
IEC 60559 Floating-Point option, a domain error shall occur;
otherwise, a [CX]   domain   error may occur.
If x is a NaN, the value FP_ILOGBNAN shall be returned. [XSI|MX]
On XSI-conformant systems and on systems that support the
IEC 60559 Floating-Point option, a domain error shall occur;
otherwise, a [CX]   domain   error may occur.
If the correct value is greater than {INT_MAX} or less than {INT_MIN}, an unspecified value shall be returned. [XSI]  On XSI-conformant
systems, a domain error shall occur and {INT_MAX} or {INT_MIN}, respectively, shall be returned;
[MX]  if the IEC 60559 Floating-Point option is supported, a domain error
shall occur;   otherwise, a domain error or range error may
occur.
ERRORS
These functions shall fail if:
Domain Error
[XSI|MX]  The correct value is not representable as an integer.
The x argument is zero, NaN, or ±Inf.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If
the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall
be raised.
These functions may fail if:
Domain Error
The x argument is zero, NaN, or ±Inf.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If
the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall
be raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are
independent of each other, but at least one of them must be non-zero.
RATIONALE
The errors come from taking the expected floating-point value and converting it to int, which is an invalid operation in
IEEE Std 754-1985 (since overflow, infinity, and NaN are not representable in a type int), so should be a domain
error.
There are no known implementations that overflow. For overflow to happen, {INT_MAX} must be less than
LDBL_MAX_EXP*log2(FLT_RADIX) or {INT_MIN} must be greater than LDBL_MIN_EXP*log2(FLT_RADIX) if subnormals are not
supported, or {INT_MIN} must be greater than (LDBL_MIN_EXP-LDBL_MANT_DIG)*log2(FLT_RADIX) if subnormals are supported.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept, fetestexcept, logb, scalbln
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The ilogb() function is no longer marked as an extension.
The ilogbf() and ilogbl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The RETURN VALUE section is revised for alignment with the ISO/IEC 9899:1999 standard.
Functionality relating to the XSI option is marked.
Issue 7
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #48 (SD5-XSH-ERN-71), #49, and #79 (SD5-XSH-ERN-72) are applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mtx_destroy.html =====
mtx_destroy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mtx_destroy, mtx_init — destroy and initialize a mutex
SYNOPSIS
#include
void mtx_destroy(mtx_t *mtx);
int mtx_init(mtx_t *mtx, int type);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The mtx_destroy() function shall release any resources used by the mutex pointed to by mtx. A destroyed mutex
object can be reinitialized using mtx_init(); the results of otherwise referencing the object after it has been destroyed
are undefined. It shall be safe to destroy an initialized mutex that is unlocked. Attempting to destroy a locked mutex, or a mutex
that another thread is attempting to lock, or a mutex that is being used in a cnd_timedwait() or cnd_wait() call by
another thread, results in undefined behavior. The behavior is undefined if the value specified by the mtx argument to
mtx_destroy() does not refer to an initialized mutex.
The mtx_init() function shall initialize a mutex object with properties indicated by type, whose valid values
include:
mtx_plain
for a simple non-recursive mutex,
mtx_timed
for a non-recursive mutex that supports timeout,
mtx_plain|mtx_recursive
for a simple recursive mutex, or
mtx_timed|mtx_recursive
for a recursive mutex that supports timeout.
If the mtx_init() function succeeds, it shall set the mutex pointed to by mtx to a value that uniquely identifies
the newly initialized mutex. Upon successful initialization, the state of the mutex shall become initialized and unlocked.
Attempting to initialize an already initialized mutex results in undefined behavior.
[CX]  See
2.9.9 Synchronization Object Copies and Alternative Mappings for
further requirements.
These functions shall not be affected if the calling thread executes a signal handler during the call.
RETURN VALUE
The mtx_destroy() function shall not return a value.
The mtx_init() function shall return thrd_success on success or thrd_error if the request could not be
honored.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
A mutex can be destroyed immediately after it is unlocked. However, since attempting to destroy a locked mutex, or a mutex that
another thread is attempting to lock, or a mutex that is being used in a cnd_timedwait() or cnd_wait() call by
another thread results in undefined behavior, care must be taken to ensure that no other thread may be referencing the mutex.
RATIONALE
These functions are not affected by signal handlers for the reasons stated in XRAT B.2.3 Error Numbers.
FUTURE DIRECTIONS
None.
SEE ALSO
cnd_timedwait(), mtx_lock()
XBD
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcsncmp.html =====
wcsncmp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcsncmp — compare part of two wide-character strings
SYNOPSIS
#include
int wcsncmp(const wchar_t *ws1, const wchar_t *ws2, size_t n);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The wcsncmp() function shall compare not more than n wide-character codes (wide-character codes that follow a null
wide-character code are not compared) from the array pointed to by ws1 to the array pointed to by ws2.
The sign of a non-zero return value shall be determined by the sign of the difference between the values of the first pair of
wide-character codes that differ in the objects being compared.
[CX]  The
wcsncmp() function shall not change the setting of errno on valid input.
RETURN VALUE
Upon successful completion, wcsncmp() shall return an integer greater than, equal to, or less than 0, if the possibly
null-terminated array pointed to by ws1 is greater than, equal to, or less than the possibly null-terminated array pointed
to by ws2, respectively.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
wcscasecmp(), wcscmp()
XBD
CHANGE HISTORY
First released in Issue 4. Derived from the MSE working draft.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that wcsncmp() does not change the setting of errno on
valid input.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/execve.html =====
exec
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
environ, execl, execle, execlp, execv, execve, execvp, fexecve — execute a file
SYNOPSIS
#include
extern char **environ;
int execl(const char *path, const char *arg0, ... /*, (char *)0 */);
int execle(const char *path, const char *arg0, ... /*,
(char *)0, char *const envp[]*/);
int execlp(const char *file, const char *arg0, ... /*, (char *)0 */);
int execv(const char *path, char *const argv[]);
int execve(const char *path, char *const argv[], char *const envp[]);
int execvp(const char *file, char *const argv[]);
int fexecve(int fd, char *const argv[], char *const envp[]);
DESCRIPTION
The exec family of functions shall replace the current process image with a new process image. The new image shall be
constructed from a regular, executable file called the new process image file. There shall be no return from a successful
exec, because the calling process image is overlaid by the new process image.
The fexecve() function shall be equivalent to the execve() function except that the file to be executed is
determined by the file descriptor fd instead of a pathname. The file offset of fd is ignored.
When a C-language program is executed as a result of a call to one of the exec family of functions, it shall be entered
as a C-language function call as follows:
int main (int argc, char *argv[]);
where argc is the argument count and argv is an array of character pointers to the arguments themselves. In
addition, the following variable, which needs to be declared by the user if it is to be used directly:
extern char **environ;
is initialized as a pointer to an array of character pointers to the environment strings. The argv and environ
arrays are each terminated by a null pointer. The null pointer terminating the argv array is not counted in argc.
Applications can change the entire environment in a single operation by assigning the environ variable to point to an
array of character pointers to the new environment strings. After assigning a new value to environ, applications should not
rely on the new environment strings remaining part of the environment, as a call to getenv(), secure_getenv(),
[XSI]
putenv(),  setenv(), unsetenv(), or any function that is
dependent on an environment variable may, on noticing that environ has changed, copy the environment strings to a new array
and assign environ to point to it.
Any application that directly modifies the pointers to which the environ variable points has undefined behavior.
Conforming multi-threaded applications shall not use the environ variable to access or modify any environment variable
while any other thread is concurrently modifying any environment variable. A call to any function dependent on any environment
variable shall be considered a use of the environ variable to access that environment variable.
The arguments specified by a program with one of the exec functions shall be passed on to the new process image in the
corresponding main() arguments.
For the execl(), execle(), execv(), and execve() functions, the argument path points to a
pathname that identifies the new process image file.
For the execlp() and execvp() functions, the argument file is used to construct a pathname that identifies
the new process image file. If the file argument contains a  character, the file argument shall be used
as the pathname for this file. Otherwise, the path prefix for this file is obtained by a search of the directories passed as the
environment variable PATH (see XBD 8. Environment Variables). If
this environment variable is not present, the results of the search are implementation-defined.
There are two distinct ways in which the contents of the process image file may cause the execution to fail, distinguished by
the setting of errno to either [ENOEXEC] or [EINVAL] (see the ERRORS section). In the cases where the other members of the
exec family of functions would fail and set errno to [ENOEXEC], the execlp() and execvp() functions
shall execute a command interpreter and the environment of the executed command shall be as if the process invoked the sh utility using execl() as follows:
execl(, , file, , (char *)0);
where  is an unspecified pathname for the sh utility,
is an unspecified string, file is the process image file, and where  is zero or more
parameters corresponding to any initial non-null arguments passed after arg0 for execlp() or to any initial non-null
members of argv starting at argv[1] for execvp().
The arguments represented by arg0,... are pointers to null-terminated character strings. These strings shall constitute
the argument list available to the new process image. The list is terminated by a null pointer. The argument arg0 should
point to a filename string that is associated with the process being started by one of the exec functions.
The argument argv is an array of character pointers to null-terminated strings. The application shall ensure that the
last member of this array is a null pointer. These strings shall constitute the argument list available to the new process image.
The value in argv[0] should point to a filename string that is associated with the process being started by one of the
exec functions.
The argument envp is an array of character pointers to null-terminated strings. These strings shall constitute the
environment for the new process image. The envp array is terminated by a null pointer.
For those forms not containing an envp pointer (execl(), execv(),
execlp(), and execvp()), the environment for the new process image shall be taken from the external variable
environ in the calling process.
The number of bytes available for the new process' combined argument and environment lists is {ARG_MAX}. It is
implementation-defined whether null terminators, pointers, and/or any alignment bytes are included in this total.
File descriptors open in the calling process image shall remain open in the new process image, except for those whose
close-on-exec flag FD_CLOEXEC is set. For those file descriptors that remain open, all attributes of the open file
description shall remain unchanged and the FD_CLOFORK file descriptor flag, if set, shall remain set. For any file descriptor that
is closed for this reason, process-owned file locks that the calling process owns on the file associated with the file descriptor
shall be unlocked as a result of the close, as described in close(). File locks that
are not unlocked by closing of file descriptors remain unchanged.
If file descriptor 0, 1, or 2 would otherwise be closed after a successful call to one of the exec family of functions,
implementations may open an unspecified file for the file descriptor in the new process image. If a standard utility or a
conforming application is executed with file descriptor 0 not open for reading or with file descriptor 1 or 2 not open for writing,
the environment in which the utility or application is executed shall be deemed non-conforming, and consequently the utility or
application might not behave as described in this standard.
Directory streams open in the calling process image shall be closed in the new process image.
The state of the floating-point environment in the initial thread of the new process image shall be set to the default.
The state of conversion descriptors and message catalog descriptors in the new process image is undefined.
For the new process image, the equivalent of:
setlocale(LC_ALL, "C")
shall be executed at start-up.
Signals set to the default action (SIG_DFL) in the calling process image shall be set to the default action in the new process
image. Except for SIGCHLD, signals set to be ignored (SIG_IGN) by the calling process image shall be set to be ignored by the new
process image. Signals set to be caught by the calling process image shall be set to the default action in the new process image
(see ).
If the SIGCHLD signal is set to be ignored by the calling process image, it is unspecified whether the SIGCHLD signal is set to
be ignored or to the default action in the new process image.
[XSI]
After a successful call to any of the exec functions, alternate signal stacks are not preserved and the SA_ONSTACK flag
shall be cleared for all signals.
After a successful call to any of the exec functions, any functions previously registered by the atexit(), at_quick_exit(), or pthread_atfork() functions are no longer registered.
[XSI]
If the ST_NOSUID bit is set for the file system containing the new process image file, then the effective user ID, effective group
ID, saved set-user-ID, and saved set-group-ID are unchanged in the new process image. Otherwise,  if the set-user-ID mode bit of the new process image file is set, the effective user ID of the new
process image shall be set to the user ID of the new process image file. Similarly, if the set-group-ID mode bit of the new process
image file is set, the effective group ID of the new process image shall be set to the group ID of the new process image file. The
real user ID, real group ID, and supplementary group IDs of the new process image shall remain the same as those of the calling
process image. The effective user ID and effective group ID of the new process image shall be saved (as the saved set-user-ID and
the saved set-group-ID) for use by setuid().
[XSI]
Any shared memory segments attached to the calling process image shall not be attached to the new process image.
Any named semaphores open in the calling process shall be closed as if by appropriate calls to sem_close(). Any unnamed semaphores open in the calling process shall be destroyed as if
by calls to sem_destroy().
[TYM]
Any blocks of typed memory that were mapped in the calling process are unmapped, as if munmap() was implicitly called to unmap them.
[ML]
Memory locks established by the calling process via calls to mlockall() or mlock() shall be removed. If locked pages in the address space of the calling process are also
mapped into the address spaces of other processes and are locked by those processes, the locks established by the other processes
shall be unaffected by the call by this process to the exec function. If the exec function fails, the effect on
memory locks is unspecified.
Memory mappings created in the process are unmapped before the address space is rebuilt for the new process image.
When the calling process image does not use the SCHED_FIFO, SCHED_RR, [SS]
or SCHED_SPORADIC   scheduling policies, the scheduling policy and parameters of the new process image and the initial
thread in that new process image are implementation-defined.
[PS]
When the calling process image uses the SCHED_FIFO, SCHED_RR, or SCHED_SPORADIC scheduling policies, the process policy and
scheduling parameter settings shall not be changed by a call to an exec function.  [TPS]   The initial thread in the new process image shall inherit the process scheduling policy and
parameters. It shall have the default system contention scope, but shall inherit its allocation domain from the calling process
image.
Per-process timers created by the calling process shall be deleted before replacing the current process image with the new
process image.
[MSG]
All open message queue descriptors in the calling process shall be closed, as described in mq_close().
Any outstanding asynchronous I/O operations may be canceled. Those asynchronous I/O operations that are not canceled shall
complete as if the exec function had not yet occurred, but any associated signal notifications shall be suppressed. It is
unspecified whether the exec function itself blocks awaiting such I/O completion. In no event, however, shall the new
process image created by the exec function be affected by the presence of outstanding asynchronous I/O operations at the
time the exec function is called. Whether any I/O is canceled, and which I/O may be canceled upon exec, is
implementation-defined.
[CPT]
The new process image shall inherit the CPU-time clock of the calling process image. This inheritance means that the process
CPU-time clock of the process being exec-ed shall not be reinitialized or altered as a result of the exec function
other than to reflect the time spent by the process executing the exec function itself.
[TCT]
The initial value of the CPU-time clock of the initial thread of the new process image shall be set to zero.
The thread ID of the initial thread in the new process image is unspecified.
The size and location of the stack on which the initial thread in the new process image runs is unspecified.
The initial thread in the new process image shall have its cancellation type set to PTHREAD_CANCEL_DEFERRED and its cancellation
state set to PTHREAD_CANCEL_ENABLED.
The initial thread in the new process image shall have all thread-specific data values set to NULL and all thread-specific data
keys shall be removed by the call to exec without running destructors.
The initial thread in the new process image shall be joinable, as if created with the detachstate attribute set to
PTHREAD_CREATE_JOINABLE.
The new process shall inherit at least the following attributes from the calling process image:
[XSI]
Nice value (see nice())
[XSI]
semadj values (see semop())
Process ID
Parent process ID
Process group ID
Session membership
Real user ID
Real group ID
Supplementary group IDs
Time left until an alarm clock signal (see alarm())
Current working directory
Root directory
File mode creation mask (see umask())
File size limit (see getrlimit() and setrlimit())
Process signal mask (see pthread_sigmask())
Pending signal (see sigpending())
tms_utime, tms_stime, tms_cutime, and tms_cstime (see times())
Resource limits
Controlling terminal
The initial thread of the new process shall inherit at least the following attributes from the calling thread:
Signal mask (see sigprocmask() and pthread_sigmask())
Pending signals (see sigpending())
All other process attributes defined in this volume of POSIX.1-2024 shall be inherited in the new process image from the old
process image. All other thread attributes defined in this volume of POSIX.1-2024 shall be inherited in the initial thread in the
new process image from the calling thread in the old process image. The inheritance of process or thread attributes not defined by
this volume of POSIX.1-2024 is implementation-defined.
A call to any exec function from a process with more than one thread shall result in all threads being terminated and the
new executable image being loaded and executed. No destructor functions or cleanup handlers shall be called.
Upon successful completion, the exec functions shall mark for update the last data access timestamp of the file. If an
exec function failed but was able to locate the process image file, whether the last data access timestamp is marked for
update is unspecified. Should the exec function succeed, the process image file shall be considered to have been opened with
open(). The corresponding close() shall be
considered to occur at a time after this open, but before process termination or successful completion of a subsequent call to one
of the exec functions, posix_spawn(), or posix_spawnp(). The argv[] and envp[] arrays of pointers and the strings
to which those arrays point shall not be modified by a call to one of the exec functions, except as a consequence of
replacing the process image.
The saved resource limits in the new process image are set to be a copy of the process' corresponding hard and soft limits.
RETURN VALUE
If one of the exec functions returns to the calling process image, an error has occurred; the return value shall be -1,
and errno shall be set to indicate the error.
ERRORS
The exec functions shall fail if:
[E2BIG]
The number of bytes used by the new process image's argument list and environment list is greater than the system-imposed limit
of {ARG_MAX} bytes.
[EACCES]
The new process image file is not a regular file and the implementation does not support execution of files of its type.
[EINVAL]
The new process image file has appropriate privileges and has a recognized executable binary format, but the system does not
support execution of a file with this format.
The exec functions, except for fexecve(), shall fail if:
[EACCES]
Search permission is denied for a directory listed in the new process image file's path prefix, or the new process image file
denies execution permission.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path or file argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of path or file does not name an existing file or path or file is an empty string.
[ENOTDIR]
A component of the new process image file's path prefix names an existing file that is neither a directory nor a symbolic link
to a directory, or the new process image file's pathname contains at least one non- character and ends with one or
more trailing  characters and the last pathname component names an existing file that is neither a directory nor a
symbolic link to a directory.
The exec functions, except for execlp() and execvp(), shall fail if:
[ENOEXEC]
The new process image file has the appropriate access permission but has an unrecognized format.
The fexecve() function shall fail if:
[EBADF]
The fd argument is not a valid file descriptor open for executing.
The exec functions may fail if:
[ENOMEM]
The new process image requires more memory than is allowed by the hardware or system-imposed memory management
constraints.
The exec functions, except for fexecve(), may fail if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path or file argument.
[ENAMETOOLONG]
The length of the path argument or the length of the pathname constructed from the file argument exceeds {PATH_MAX},
or pathname resolution of a symbolic link produced an intermediate result with a length that exceeds {PATH_MAX}.
[ETXTBSY]
The new process image file is a pure procedure (shared text) file that is currently open for writing by some process.
The following sections are informative.
EXAMPLES
Using execl()
The following example executes the ls command, specifying the pathname of the
executable (/bin/ls) and using arguments supplied directly to the command to produce single-column output.
#include
int ret;
...
ret = execl ("/bin/ls", "ls", "-1", (char *)0);
Using execle()
The following example is similar to Using execl(). In addition, it specifies the environment
for the new process image using the env argument.
#include
int ret;
char *env[] = { "HOME=/usr/home", "LOGNAME=home", (char *)0 };
...
ret = execle ("/bin/ls", "ls", "-l", (char *)0, env);
Using execlp()
The following example searches for the location of the ls command among the
directories specified by the PATH environment variable.
#include
int ret;
...
ret = execlp ("ls", "ls", "-l", (char *)0);
Using execv()
The following example passes arguments to the ls command in the cmd array.
#include
int ret;
char *cmd[] = { "ls", "-l", (char *)0 };
...
ret = execv ("/bin/ls", cmd);
Using execve()
The following example passes arguments to the ls command in the cmd array, and
specifies the environment for the new process image using the env argument.
#include
int ret;
char *cmd[] = { "ls", "-l", (char *)0 };
char *env[] = { "HOME=/usr/home", "LOGNAME=home", (char *)0 };
...
ret = execve ("/bin/ls", cmd, env);
Using execvp()
The following example searches for the location of the ls command among the
directories specified by the PATH environment variable, and passes arguments to the ls command in the cmd array.
#include
int ret;
char *cmd[] = { "ls", "-l", (char *)0 };
...
ret = execvp ("ls", cmd);
APPLICATION USAGE
As the state of conversion descriptors and message catalog descriptors in the new process image is undefined, conforming
applications should not rely on their use and should close them prior to calling one of the exec functions.
Applications that require other than the default POSIX locale as the global locale in the new process image should call setlocale() with the appropriate parameters.
When assigning a new value to the environ variable, applications should ensure that the environment to which it will
point contains at least the following:
Any implementation-defined variables required by the implementation to provide a conforming environment. See the _CS_V8_ENV
entry in  and confstr() for details.
A value for PATH which finds conforming versions of all standard utilities before any other versions.
The same constraint applies to the envp array passed to execle() or execve(), in order to ensure that the
new process image is invoked in a conforming environment.
Applications should not execute programs with file descriptor 0 not open for reading or with file descriptor 1 or 2 not open for
writing, as this might cause the executed program to misbehave. In order not to pass on these file descriptors to an executed
program, applications should not just close them but should reopen them on, for example, /dev/null. Some implementations may
reopen them automatically, but applications should not rely on this being done.
If an application wants to perform an integrity test of the file being executed before executing it, the file will need to be
opened with read permission to perform the integrity test.
Since execute permission is checked by fexecve(), the file description fd need not have been opened with the
O_EXEC flag. However, if the file to be executed denies read and write permission for the process preparing to do the exec,
the only way to provide the fd to fexecve() will be to use the O_EXEC flag when opening fd. In this case, the
application will not be able to perform an integrity test since it will not be able to read the contents of the file.
Note that when a file descriptor is opened with O_RDONLY, O_RDWR, or O_WRONLY mode, the file descriptor can be used to read,
read and write, or write the file, respectively, even if the mode of the file changes after the file was opened. Using the O_EXEC
open mode is different; fexecve() will ignore the mode that was used when the file descriptor was opened and the exec
will fail if the mode of the file associated with fd does not grant execute permission to the calling process at the time
fexecve() is called.
RATIONALE
Early proposals required that the value of argc passed to main() be "one or greater". This was driven by the
same requirement in drafts of the ISO C standard. In fact, historical implementations have passed a value of zero when no
arguments are supplied to the caller of the exec functions. This requirement was removed from the ISO C standard and
subsequently removed from this volume of POSIX.1-2024 as well. The wording, in particular the use of the word should,
requires a Strictly Conforming POSIX Application to pass at least one argument to the exec function, thus guaranteeing that
argc be one or greater when invoked by such an application. In fact, this is good practice, since many existing applications
reference argv[0] without first checking the value of argc.
The requirement on a Strictly Conforming POSIX Application also states that the value passed as the first argument be a filename
string associated with the process being started. Although some existing applications pass a pathname rather than a filename string
in some circumstances, a filename string is more generally useful, since the common usage of argv[0] is in printing
diagnostics. In some cases the filename passed is not the actual filename of the file; for example, many implementations of the
login utility use a convention of prefixing a  ('-') to the actual filename, which indicates to
the command interpreter being invoked that it is a "login shell".
Also, note that the test and [ utilities require specific strings for the
argv[0] argument to have deterministic behavior across all implementations.
Historically, there have been two ways that implementations can exec shell scripts.
One common historical implementation is that the execl(), execv(), execle(), and execve() functions
return an [ENOEXEC] error for any file not recognizable as executable, including a shell script. When the execlp() and
execvp() functions encounter such a file, they assume the file to be a shell script and invoke a known command interpreter
to interpret such files. This is now required by POSIX.1-2024. These implementations of execvp() and execlp() only
give the [ENOEXEC] error in the rare case of a problem with the command interpreter's executable file. Because of these