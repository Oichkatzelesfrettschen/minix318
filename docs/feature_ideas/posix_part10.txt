Domain Error
The finite value of x is negative, [MX]   or x is -Inf.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
Pole Error
The value of x is zero.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the divide-by-zero floating-point exception shall
be raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), isnan(), log(), pow()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
The log10f() and log10l() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/CMPLXF.html =====
CMPLX
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
CMPLX, CMPLXF, CMPLXL — make a complex value
SYNOPSIS
#include
double complex CMPLX(double x, double y);
float complex CMPLXF(float x, float y);
long double complex CMPLXL(long double x, long double y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The CMPLX macros shall expand to an expression of the specified complex type, with the real part having the (converted) value of
x and the imaginary part having the (converted) value of y. The resulting expression shall be suitable for use as an
initializer for an object with static or thread storage duration, provided both arguments are likewise suitable.
RETURN VALUE
The CMPLX macros return the complex value x + i y (where i is the imaginary unit).
These macros shall behave as if the implementation supported imaginary types and the definitions were:
#define CMPLX(x, y)  ((double complex)((double)(x) + \
_Imaginary_I * (double)(y)))
#define CMPLXF(x, y) ((float complex)((float)(x) + \
_Imaginary_I * (float)(y)))
#define CMPLXL(x, y) ((long double complex)((long double)(x) + \
_Imaginary_I * (long double)(y)))
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/llroundf.html =====
llround
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
llround, llroundf, llroundl — round to nearest integer value
SYNOPSIS
#include
long long llround(double x);
long long llroundf(float x);
long long llroundl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall round their argument to the nearest integer value, rounding halfway cases away from zero, regardless of
the current rounding direction.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the rounded integer value.
[MX]  If
x is NaN, a domain error shall occur, and an unspecified value is returned.
If x is +Inf, a domain error shall occur and an unspecified value is returned.
If x is -Inf, a domain error shall occur and an unspecified value is returned.
If the correct value is positive and too large to represent as a long long, an unspecified value shall be returned.
[MX]
On systems that support the IEC 60559 Floating-Point option, a domain error shall occur;   otherwise, a [CX]   domain  error may occur.
If the correct value is negative and too large to represent as a long long, an unspecified value shall be returned.
[MX]
On systems that support the IEC 60559 Floating-Point option, a domain error shall occur;   otherwise, a [CX]   domain  error may occur.
ERRORS
These functions shall fail if:
Domain Error
[MX]
The x argument is NaN or ±Inf, or the correct value is not representable as an integer.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
These functions may fail if:
Domain Error
The correct value is not representable as an integer.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
These functions differ from the llrint() functions in that the default rounding
direction for the llround() functions round halfway cases away from zero and need not raise the inexact floating-point
exception for non-integer arguments that round to within the range of the return type.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), lround()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #54 (SD5-XSH-ERN-75) is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/nan.html =====
nan
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
nan, nanf, nanl — return quiet NaN
SYNOPSIS
#include
double nan(const char *tagp);
float nanf(const char *tagp);
long double nanl(const char *tagp);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The function call nan("n-char-sequence") shall be equivalent to:
strtod("NAN(n-char-sequence)", (char **) NULL);
The function call nan("") shall be equivalent to:
strtod("NAN()", (char **) NULL)
If tagp does not point to an n-char sequence or an empty string, the function call shall be equivalent
to:
strtod("NAN", (char **) NULL)
Function calls to nanf() and nanl() are equivalent to the corresponding function calls to strtof() and strtold().
RETURN VALUE
These functions shall return a quiet NaN, if available, with content indicated through tagp.
[MX]  The
returned value shall be exact and shall be independent of the current rounding direction mode.
If the implementation does not support quiet NaNs, these functions shall return zero.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
strtod()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/setuid.html =====
setuid
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
setuid — set user ID
SYNOPSIS
#include
int setuid(uid_t uid);
DESCRIPTION
If the process has appropriate privileges, setuid() shall set the real user ID, effective user ID, and the saved
set-user-ID of the calling process to uid.
If the process does not have appropriate privileges, but uid is equal to the real user ID or the saved set-user-ID,
setuid() shall set the effective user ID to uid; the real user ID and saved set-user-ID shall remain unchanged.
The setuid() function shall not affect the supplementary group list in any way.
RETURN VALUE
Upon successful completion, 0 shall be returned. Otherwise, -1 shall be returned and errno set to indicate the error.
ERRORS
The setuid() function shall fail, return -1, and set errno to the corresponding value if one or more of the
following are true:
[EINVAL]
The value of the uid argument is invalid and not supported by the implementation.
[EPERM]
The process does not have appropriate privileges and uid does not match the real user ID or the saved set-user-ID.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The various behaviors of the setuid() and setgid() functions when called by
non-privileged processes reflect the behavior of different historical implementations. For portability, it is recommended that new
non-privileged applications use the seteuid() and setegid() functions instead.
The saved set-user-ID capability allows a program to regain the effective user ID established at the last exec call. Similarly, the saved set-group-ID capability allows a program to regain the effective
group ID established at the last exec call. These capabilities are derived from System
V. Without them, a program might have to run as superuser in order to perform the same functions, because superuser can write on
the user's files. This is a problem because such a program can write on any user's files, and so must be carefully written to
emulate the permissions of the calling process properly. In System V, these capabilities have traditionally been implemented only
via the setuid() and setgid() functions for non-privileged processes. The fact
that the behavior of those functions was different for privileged processes made them difficult to use. The POSIX.1-1990 standard
defined the setuid() function to behave differently for privileged and unprivileged users. When the caller had appropriate
privileges, the function set the real user ID, effective user ID, and saved set-user ID of the calling process on implementations
that supported it. When the caller did not have appropriate privileges, the function set only the effective user ID, subject to
permission checks. The former use is generally needed for utilities like login and su, which are not conforming
applications and thus outside the scope of POSIX.1-2024. These utilities wish to change the user ID irrevocably to a new value,
generally that of an unprivileged user. The latter use is needed for conforming applications that are installed with the
set-user-ID bit and need to perform operations using the real user ID.
POSIX.1-2024 augments the latter functionality with a mandatory feature named _POSIX_SAVED_IDS. This feature permits a
set-user-ID application to switch its effective user ID back and forth between the values of its exec-time real user ID and effective user ID. Unfortunately, the POSIX.1-1990 standard did not
permit a conforming application using this feature to work properly when it happened to be executed with (implementation-defined)
appropriate privileges. Furthermore, the application did not even have a means to tell whether it had this privilege. Since the
saved set-user-ID feature is quite desirable for applications, as evidenced by the fact that NIST required it in FIPS 151-2, it has
been mandated by POSIX.1-2024. However, there are implementors who have been reluctant to support it given the limitation described
above.
The 4.3BSD system handles the problem by supporting separate functions: setuid() (which always sets both the real and
effective user IDs, like setuid() in POSIX.1-2024 for privileged users), and seteuid() (which always sets just the effective user ID, like setuid() in
POSIX.1-2024 for non-privileged users). This separation of functionality into distinct functions seems desirable. 4.3BSD does not
support the saved set-user-ID feature. It supports similar functionality of switching the effective user ID back and forth via
setreuid(), which permits reversing the real and effective user IDs. This model
seems less desirable than the saved set-user-ID because the real user ID changes as a side-effect. The current 4.4BSD includes
saved effective IDs and uses them for seteuid() and setegid() as described above. The setreuid()
and setregid() functions will be deprecated or removed.
The solution here is:
Require that all implementations support the functionality of the saved set-user-ID, which is set by the exec functions and by privileged calls to setuid().
Add the seteuid() and setegid()
functions as portable alternatives to setuid() and setgid() for non-privileged
and privileged processes.
Historical systems have provided two mechanisms for a set-user-ID process to change its effective user ID to be the same as its
real user ID in such a way that it could return to the original effective user ID: the use of the setuid() function in the
presence of a saved set-user-ID, or the use of the BSD setreuid() function, which
was able to swap the real and effective user IDs. The changes included in POSIX.1-2024 provide a new mechanism using seteuid() in conjunction with a saved set-user-ID. Thus, all implementations with the new
seteuid() mechanism will have a saved set-user-ID for each process, and most of the
behavior controlled by _POSIX_SAVED_IDS has been changed to agree with the case where the option was defined. The kill() function is an exception. Implementors of the new seteuid() mechanism will generally be required to maintain compatibility with the older
mechanisms previously supported by their systems. However, compatibility with this use of setreuid() and with the _POSIX_SAVED_IDS behavior of kill() is unfortunately complicated. If an implementation with a saved set-user-ID allows a
process to use setreuid() to swap its real and effective user IDs, but were to
leave the saved set-user-ID unmodified, the process would then have an effective user ID equal to the original real user ID, and
both real and saved set-user-ID would be equal to the original effective user ID. In that state, the real user would be unable to
kill the process, even though the effective user ID of the process matches that of the real user, if the kill() behavior of _POSIX_SAVED_IDS was used. This is obviously not acceptable. The alternative
choice, which is used in at least one implementation, is to change the saved set-user-ID to the effective user ID during most calls
to setreuid(). The standard developers considered that alternative to be less
correct than the retention of the old behavior of kill() in such systems. Current
conforming applications shall accommodate either behavior from kill(), and there
appears to be no strong reason for kill() to check the saved set-user-ID rather than
the effective user ID.
FUTURE DIRECTIONS
None.
SEE ALSO
exec, getegid(), geteuid(), getgid(), getresgid(), getresuid(), getuid(), setegid(), seteuid(), setgid(), setregid(), setresgid(), setresuid(), setreuid()
XBD ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
In the SYNOPSIS, the optional include of the  header is
removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
The functionality associated with _POSIX_SAVED_IDS is now mandatory. This is a FIPS requirement.
The following changes were made to align with the IEEE P1003.1a draft standard:
The effects of setuid() in processes without appropriate privileges are changed.
A requirement that the supplementary group list is not affected is added.
Issue 8
Austin Group Defect 1344 is applied, adding getresgid(), getresuid(), setresgid(), and setresuid() to SEE ALSO.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/open.html =====
open
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
open, openat — open file
SYNOPSIS
[OH] #include
#include
int open(const char *path, int oflag, ...);
int openat(int fd, const char *path, int oflag, ...);
DESCRIPTION
The open() function shall establish the connection between a file and a file descriptor. It shall create an open file
description that refers to a file and a file descriptor that refers to that open file description. The file descriptor is used by
other I/O functions to refer to that file. The path argument points to a pathname naming the file.
The open() function shall return a file descriptor for the named file, allocated as described in 2.6 File Descriptor Allocation. The open file description is new, and therefore
the file descriptor shall not share it with any other process in the system. The FD_CLOEXEC file descriptor flag associated with
the new file descriptor shall be cleared unless the O_CLOEXEC flag is set in oflag. The FD_CLOFORK file descriptor flag
associated with the new file descriptor shall be cleared unless the O_CLOFORK flag is set in oflag.
The file offset used to mark the current position within the file shall be set to the beginning of the file.
The file status flags and file access modes of the open file description shall be set according to the value of
oflag.
Values for oflag are constructed by a bitwise-inclusive OR of flags from the following list, defined in . Applications shall specify exactly one of the first five values (file access
modes) below in the value of oflag:
O_EXEC
Open for execute only (non-directory files). If path names a directory and O_EXEC is not the same value as O_SEARCH,
open() shall fail.
O_RDONLY
Open for reading only.
O_RDWR
Open for reading and writing. If path names a FIFO, and the implementation does not support opening a FIFO for
simultaneous read and write, then open() shall fail.
O_SEARCH
Open directory for search only. If path names a non-directory file and O_SEARCH is not the same value as O_EXEC,
open() shall fail.
O_WRONLY
Open for writing only.
Any combination of the following may be used:
O_APPEND
If set, the file offset shall be set to the end of the file prior to each write.
O_CLOEXEC
If set, the FD_CLOEXEC flag for the new file descriptor shall be set.
O_CLOFORK
If set, the FD_CLOFORK flag for the new file descriptor shall be set.
O_CREAT
If the file exists, this flag has no effect except as noted under O_EXCL below. Otherwise, if O_DIRECTORY is not set the file
shall be created as a regular file; the user ID of the file shall be set to the effective user ID of the process; the group ID of
the file shall be set to the group ID of the file's parent directory or to the effective group ID of the process; and the access
permission bits (see ) of the file mode shall be set to the
value of the argument following the oflag argument taken as type mode_t modified as follows: a bitwise AND is
performed on the file-mode bits and the corresponding bits in the complement of the process' file mode creation mask. Thus, all
bits in the file mode whose corresponding bit in the file mode creation mask is set are cleared. When bits other than the file
permission bits are set, the effect is unspecified. The argument following the oflag argument does not affect whether the
file is open for reading, writing, or for both. Implementations shall provide a way to initialize the file's group ID to the group
ID of the parent directory. Implementations may, but need not, provide an implementation-defined way to initialize the file's group
ID to the effective group ID of the calling process.
O_DIRECTORY
If path resolves to a non-directory file, fail and set errno to [ENOTDIR].
O_DSYNC
[SIO]
Write I/O operations on the file descriptor shall complete as defined by synchronized I/O data integrity completion.
O_EXCL
If O_CREAT and O_EXCL are set, open() shall fail if the file exists. The check for the existence of the file and the
creation of the file if it does not exist shall be atomic with respect to other threads executing open() naming the same
filename in the same directory with O_EXCL and O_CREAT set. If O_EXCL and O_CREAT are set, and path names a symbolic link,
open() shall fail and set errno to [EEXIST], regardless of the contents of the symbolic link. If O_EXCL is set and
O_CREAT is not set, the result is undefined.
O_NOCTTY
If set and path identifies a terminal device, open() shall not cause the terminal device to become the
controlling terminal for the process. If path does not identify a terminal device, O_NOCTTY shall be ignored.
O_NOFOLLOW
If path names a symbolic link, fail and set errno to [ELOOP].
O_NONBLOCK
When opening a FIFO with O_RDONLY or O_WRONLY set:
If O_NONBLOCK is set, an open() for reading-only shall return without delay. An open() for writing-only shall
return an error if no process currently has the file open for reading.
If O_NONBLOCK is clear, an open() for reading-only shall block the calling thread until a thread opens the file for
writing. An open() for writing-only shall block the calling thread until a thread opens the file for reading.
When opening a block special or character special file that supports non-blocking opens:
If O_NONBLOCK is set, the open() function shall return without blocking for the device to be ready or available.
Subsequent behavior of the device is device-specific.
If O_NONBLOCK is clear, the open() function shall block the calling thread until the device is ready or available before
returning.
Otherwise, the O_NONBLOCK flag shall not cause an error, but it is unspecified whether the file status flags will include the
O_NONBLOCK flag.
O_RSYNC
[SIO]
Read I/O operations on the file descriptor shall complete at the same level of integrity as specified by the O_DSYNC and O_SYNC
flags. If both O_DSYNC and O_RSYNC are set in oflag, all I/O operations on the file descriptor shall complete as defined by
synchronized I/O data integrity completion. If both O_SYNC and O_RSYNC are set in flags, all I/O operations on the file descriptor
shall complete as defined by synchronized I/O file integrity completion.
O_SYNC
[XSI|SIO]  Write I/O operations on the file descriptor shall complete as defined by synchronized I/O file integrity completion.
[XSI]
The O_SYNC flag shall be supported for regular files, even if the Synchronized Input and Output option is not supported.
O_TRUNC
If the file exists and is a regular file, and the file is successfully opened O_RDWR or O_WRONLY, its length shall be truncated
to 0, and the mode and owner shall be unchanged. It shall have no effect on FIFO special files or terminal device files. Its effect
on other file types is implementation-defined. The result of using O_TRUNC without either O_RDWR or O_WRONLY is undefined.
O_TTY_INIT
If path identifies a terminal device other than a pseudo-terminal, the device is not already open in any process, and
either O_TTY_INIT is set in oflag or O_TTY_INIT has the value zero, open() shall set any non-standard termios
structure terminal parameters to a state that provides conforming behavior (see XBD 11.2 Parameters that Can be Set) and initialize the winsize structure
associated with the terminal to appropriate default settings. It is unspecified whether O_TTY_INIT has any effect if the device is
already open in any process. If path identifies the subsidiary side of a pseudo-terminal that is not already open in any
process, open() shall set any non-standard termios structure terminal parameters to a state that provides conforming
behavior and initialize the winsize structure associated with the terminal to appropriate default settings, regardless of
whether O_TTY_INIT is set. If path does not identify a terminal device, O_TTY_INIT shall be ignored.
If O_CREAT and O_DIRECTORY are set and the requested access mode is neither O_WRONLY nor O_RDWR, the result is unspecified.
If O_CREAT is set and the file did not previously exist, upon successful completion, open() shall mark for update the
last data access, last data modification, and last file status change timestamps of the file and the last data modification and
last file status change timestamps of the parent directory.
If O_TRUNC is set and the file did previously exist, upon successful completion, open() shall mark for update the last
data modification and last file status change timestamps of the file.
[SIO]
If both the O_SYNC and O_DSYNC flags are set, the effect is as if only the O_SYNC flag was set.
The application shall ensure that it specifies the O_TTY_INIT flag on the first open of a terminal device since system boot or
since the device was closed by the process that last had it open. The application need not specify the O_TTY_INIT flag when opening
pseudo-terminals. [XSI]   If path names the manager side of a pseudo-terminal device, then it is unspecified
whether open() locks the subsidiary side so that it cannot be opened. Conforming applications shall call unlockpt() before opening the subsidiary side.
The largest value that can be represented correctly in an object of type off_t shall be established as the offset maximum
in the open file description.
The openat() function shall be equivalent to the open() function except in the case where path specifies a
relative path. In this case the file to be opened is determined relative to the directory associated with the file descriptor
fd instead of the current working directory. If the access mode of the open file description associated with the file
descriptor is not O_SEARCH, the function shall check whether directory searches are permitted using the current permissions of the
directory underlying the file descriptor. If the access mode is O_SEARCH, the function shall not perform the check.
The oflag parameter and the optional fourth parameter correspond exactly to the parameters of open().
If openat() is passed the special value AT_FDCWD in the fd parameter, the current working directory shall be used
and the behavior shall be identical to a call to open().
RETURN VALUE
Upon successful completion, these functions shall open the file and return a non-negative integer representing the file
descriptor. Otherwise, these functions shall return -1 and set errno to indicate the error. If -1 is returned, no files
shall be created or modified.
ERRORS
These functions shall fail if:
[EACCES]
Search permission is denied on a component of the path prefix, or the file exists and the permissions specified by oflag
are denied, or the file does not exist and write permission is denied for the parent directory of the file to be created, or
O_TRUNC is specified and write permission is denied.
[EEXIST]
O_CREAT and O_EXCL are set, and the named file exists.
[EILSEQ]
O_CREAT was specified, the file did not exist, and the last pathname component of path is not a portable filename and
cannot be created in the target directory.
[EINTR]
A signal was caught during open().
[EINVAL]
The path argument names a FIFO, O_RDWR was specified, and the implementation considers this an error; [SIO]   or
synchronized I/O flags were specified and the implementation does not support synchronized I/O for the file.
[EISDIR]
The named file is a directory and oflag includes O_WRONLY or O_RDWR, or includes O_CREAT without O_DIRECTORY, or
includes O_EXEC when O_EXEC is not the same value as O_SEARCH.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path argument, or O_NOFOLLOW was specified and the
path argument names a symbolic link.
[EMFILE]
All file descriptors available to the process are currently open.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENFILE]
The maximum allowable number of files is currently open in the system.
[ENOENT]
O_CREAT is not set and a component of path does not name an existing file, or O_CREAT is set and a component of the path
prefix of path does not name an existing file, or path points to an empty string.
[ENOENT] or [ENOTDIR]
O_CREAT is set, and the path argument contains at least one non- character and ends with one or more trailing
characters. If path without the trailing  characters would name an existing file, an [ENOENT]
error shall not occur.
[ENOSPC]
The directory or file system that would contain the new file cannot be expanded, the file does not exist, and O_CREAT is
specified.
[ENOTDIR]
A component of the path prefix names an existing file that is neither a directory nor a symbolic link to a directory; or
O_CREAT and O_EXCL are not specified, the path argument contains at least one non- character and ends with one
or more trailing  characters, and the last pathname component names an existing file that is neither a directory nor a
symbolic link to a directory; or O_DIRECTORY was specified and the path argument names a non-directory file; or the
path argument names a non-directory file and O_SEARCH was specified when O_SEARCH is not the same value as O_EXEC.
[ENXIO]
O_NONBLOCK is set, the named file is a FIFO, O_WRONLY is set, and no process has the file open for reading.
[ENXIO]
The named file is a character special or block special file, and the device associated with this special file does not
exist.
[EOVERFLOW]
The named file is a regular file and the size of the file cannot be represented correctly in an object of type
off_t.
[EROFS]
The named file resides on a read-only file system and either O_WRONLY, O_RDWR, O_CREAT (if the file does not exist), or O_TRUNC
is set in the oflag argument.
The openat() function shall fail if:
[EACCES]
The access mode of the open file description associated with fd is not O_SEARCH and the permissions of the directory
underlying fd do not permit directory searches.
[EBADF]
The path argument does not specify an absolute path and the fd argument is neither AT_FDCWD nor a valid file
descriptor open for reading or searching.
[ENOTDIR]
The path argument is not an absolute path and fd is a file descriptor associated with a non-directory file.
These functions may fail if:
[EAGAIN]
[XSI]
The path argument names the subsidiary side of a pseudo-terminal device that is locked.
[EINVAL]
The value of the oflag argument is not valid.
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
[EOPNOTSUPP]
The path argument names a socket.
[ETXTBSY]
The file is a pure procedure (shared text) file that is being executed and oflag is O_WRONLY or O_RDWR.
The following sections are informative.
EXAMPLES
Opening a File for Writing by the Owner
The following example opens the file /tmp/file, either by creating it (if it does not already exist), or by truncating
its length to 0 (if it does exist). In the former case, if the call creates a new file, the access permission bits in the file mode
of the file are set to permit reading and writing by the owner, and to permit reading only by group members and others.
If the call to open() is successful, the file is opened for writing.
#include
...
int fd;
mode_t mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
char *pathname = "/tmp/file";
...
fd = open(pathname, O_WRONLY | O_CREAT | O_TRUNC, mode);
...
Opening a File Using an Existence Check
The following example uses the open() function to try to create the LOCKFILE file and open it for writing. Since
the open() function specifies the O_EXCL flag, the call fails if the file already exists. In that case, the program assumes
that someone else is updating the password file and exits.
#include
#include
#include
#define LOCKFILE "/etc/ptmp"
...
int pfd; /* Integer for file descriptor returned by open() call. */
...
if ((pfd = open(LOCKFILE, O_WRONLY | O_CREAT | O_EXCL,
S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) == -1)
{
fprintf(stderr, "Cannot open /etc/ptmp. Try again later.\n");
exit(1);
}
...
Opening a File for Writing
The following example opens a file for writing, creating the file if it does not already exist. If the file does exist, the
system truncates the file to zero bytes.
#include
#include
#include
#define LOCKFILE "/etc/ptmp"
...
int pfd;
char pathname[PATH_MAX+1];
...
if ((pfd = open(pathname, O_WRONLY | O_CREAT | O_TRUNC,
S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) == -1)
{
perror("Cannot open output file\n"); exit(1);
}
...
APPLICATION USAGE
POSIX.1-2024 does not require that terminal parameters be automatically set to any state on first open, nor that they be reset
after the last close. It is possible for a non-conforming application to leave a terminal device in a state where the next process
to use that device finds it in a non-conforming state, but has no way of determining this. To ensure that the device is set to a
conforming initial state, applications which perform a first open of a terminal (other than a pseudo-terminal) should do so using
the O_TTY_INIT flag to set the parameters associated with the terminal to a conforming state.
Except as specified in this volume of POSIX.1-2024, the flags allowed in oflag are not mutually-exclusive and any number
of them may be used simultaneously. Not all combinations of flags make sense. For example, using O_SEARCH | O_CREAT will
successfully open a pre-existing directory for searching, but if there is no existing file by that name, then it is unspecified
whether a regular file will be created. Likewise, if a non-directory file descriptor is successfully returned, it is unspecified
whether that descriptor will have execute permissions as if by O_EXEC (note that it is unspecified whether O_EXEC and O_SEARCH have
the same value).
The O_CLOEXEC and O_CLOFORK flags of open() are necessary to avoid a data race in multi-threaded applications. Without
O_CLOFORK, a file descriptor is leaked into a child process created by one thread in the window between another thread creating a
file descriptor with open() and then using fcntl() to set the FD_CLOFORK flag.
Without O_CLOEXEC, a file descriptor intentionally inherited by child processes is similarly leaked into an executed program if
FD_CLOEXEC is not set atomically.
RATIONALE
Some implementations permit opening FIFOs with O_RDWR. Since FIFOs could be implemented in other ways, and since two file
descriptors can be used to the same effect, an implementation is allowed to reject the use of O_RDWR on a FIFO.
See getgroups() about the group of a newly created file.
The use of open() to create a regular file is preferable to the use of creat(), because the latter is redundant and included only for historical reasons.
The use of the O_TRUNC flag on FIFOs and directories (pipes cannot be open()-ed) must be permissible without unexpected
side-effects (for example, creat() on a FIFO must not remove data). Since terminal
special files might have type-ahead data stored in the buffer, O_TRUNC should not affect their content, particularly if a program
that normally opens a regular file should open the current controlling terminal instead. Other file types, particularly
implementation-defined ones, are left implementation-defined.
POSIX.1-2024 permits [EACCES] to be returned for conditions other than those explicitly listed.
The O_NOCTTY flag was added to allow applications to avoid unintentionally acquiring a controlling terminal as a side-effect of
opening a terminal file. This volume of POSIX.1-2024 does not specify how a controlling terminal is acquired, but it allows an
implementation to provide this on open() if the O_NOCTTY flag is not set and other conditions specified in XBD 11. General Terminal Interface are met.
In historical implementations the value of O_RDONLY is zero. Because of that, it is not possible to detect the presence of
O_RDONLY and another option. Future implementations should encode O_RDONLY and O_WRONLY as bit flags so that:
O_RDONLY | O_WRONLY == O_RDWR
O_EXEC and O_SEARCH are specified as two of the five file access modes. Since O_EXEC does not apply to directories, and O_SEARCH
only applies to directories, their values need not be distinct. Although this standard requires open() to fail on an attempt
to use O_EXEC on a directory, or O_SEARCH on a non-directory, this only applies in implementations where the two modes have
distinct values. Since O_RDONLY has historically had the value zero, implementations are not able to distinguish between O_SEARCH
and O_SEARCH | O_RDONLY, and similarly for O_EXEC.
In general, the open() function follows the symbolic link if path names a symbolic link. However, the
open() function, when called with O_CREAT and O_EXCL, is required to fail with [EEXIST] if path names an existing
symbolic link, even if the symbolic link refers to a nonexistent file. This behavior is required so that privileged applications
can create a new file in a known location without the possibility that a symbolic link might cause the file to be created in a
different location.
For example, a privileged application that must create a file with a predictable name in a user-writable directory, such as the
user's home directory, could be compromised if the user creates a symbolic link with that name that refers to a nonexistent file in
a system directory. If the user can influence the contents of a file, the user could compromise the system by creating a new system
configuration or spool file that would then be interpreted by the system. The test for a symbolic link which refers to a
nonexisting file must be atomic with the creation of a new file.
In addition, the open() function refuses to open non-directories if the O_DIRECTORY flag is set. This avoids race
conditions whereby a user might compromise the system by substituting a hard link to a sensitive file (e.g., a device or a FIFO)
while a privileged application is running, where opening a file even for read access might have undesirable side-effects.
In addition, the open() function does not follow symbolic links if the O_NOFOLLOW flag is set. This avoids race
conditions whereby a user might compromise the system by substituting a symbolic link to a sensitive file (e.g., a device) while a
privileged application is running, where opening a file even for read access might have undesirable side-effects.
The POSIX.1-1990 standard required that the group ID of a newly created file be set to the group ID of its parent directory or
to the effective group ID of the creating process. FIPS 151-2 required that implementations provide a way to have the group ID be
set to the group ID of the containing directory, but did not prohibit implementations also supporting a way to set the group ID to
the effective group ID of the creating process. Conforming applications should not assume which group ID will be used. If it
matters, an application can use chown() to set the group ID after the file is created,
or determine under what conditions the implementation will set the desired group ID.
The purpose of the openat() function is to enable opening files in directories other than the current working directory
without exposure to race conditions. Any part of the path of a file could be changed in parallel to a call to open(),
resulting in unspecified behavior. By opening a file descriptor for the target directory and using the openat() function it
can be guaranteed that the opened file is located relative to the desired directory. Some implementations use the openat()
function for other purposes as well. In some cases, if the oflag parameter has the O_XATTR bit set, the returned file
descriptor provides access to extended attributes. This functionality is not standardized here.
Implementations are encouraged to have open() and openat() report an [EILSEQ] error if oflag includes
O_CREAT, the file did not previously exist, and the last component of path contains any bytes that have the encoded value of
a  character.
FUTURE DIRECTIONS
A future version of this standard may add an O_NOCLOBBER flag, specified as follows, for use by shells when the noclobber
option is set (see XRAT C.2.7.2 Redirecting Output):
O_NOCLOBBER
If O_CREAT and O_NOCLOBBER are set, open() shall fail if the file exists and is either a regular file or a symbolic link
that resolves to a regular file. The check for the existence and type of the file and the creation of the file if it does not exist
shall be atomic with respect to other threads executing open() naming the same filename in the same directory with
O_NOCLOBBER and O_CREAT set or with O_EXCL and O_CREAT set. If O_NOCLOBBER and O_CREAT are set, and the file exists and is either a
non-regular file or a symbolic link that resolves to a non-regular file, the file shall be opened as if neither flag was set. If
O_NOCLOBBER and O_CREAT are set, and path names a symbolic link that does not resolve to an existing file, an empty file
shall be created such that path resolves to the newly created file. If O_NOCLOBBER is set and O_CREAT is not set, the result
is undefined.
SEE ALSO
chmod(), close(),
creat(), dirfd(), dup(), exec, fcntl(), fdopendir(), link(), lseek(), mkdtemp(), mknod(), read(), symlink(), umask(), unlockpt(), write()
XBD 11. General Terminal Interface, , ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Realtime Extension and the POSIX Threads Extension.
Large File Summit extensions are added.
Issue 6
In the SYNOPSIS, the optional include of the  header is
removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
In the DESCRIPTION, O_CREAT is amended to state that the group ID of the file is set to the group ID of the file's parent
directory or to the effective group ID of the process. This is a FIPS requirement.
In the DESCRIPTION, text is added to indicate setting of the offset maximum in the open file description. This change is to
support large files.
In the ERRORS section, the [EOVERFLOW] condition is added. This change is to support large files.
The [ENXIO] mandatory error condition is added.
The [EINVAL], [ENAMETOOLONG], and [ETXTBSY] optional error conditions are added.
The DESCRIPTION and ERRORS sections are updated so that items related to the optional XSI STREAMS Option Group are marked.
The following changes were made to align with the IEEE P1003.1a draft standard:
An explanation is added of the effect of the O_CREAT and O_EXCL flags when the path refers to a symbolic link.
The [ELOOP] optional error condition is added.
The normative text is updated to avoid use of the term "must" for application requirements.
The DESCRIPTION of O_EXCL is updated in response to IEEE PASC Interpretation 1003.1c #48.
Issue 7
Austin Group Interpretations 1003.1-2001 #113 and #143 are applied.
Austin Group Interpretation 1003.1-2001 #144 is applied, adding the O_TTY_INIT flag.
Austin Group Interpretation 1003.1-2001 #171 is applied, adding support to set the FD_CLOEXEC flag atomically at open(),
and adding the F_DUPFD_CLOEXEC flag.
SD5-XBD-ERN-4 is applied, changing the definition of the [EMFILE] error.
This page is revised and the openat() function is added from The Open Group Technical Standard, 2006, Extended API Set
Part 2.
Functionality relating to the XSI STREAMS option is marked obsolescent.
Changes are made related to support for finegrained timestamps.
Changes are made to allow a directory to be opened for searching.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0418 [292], XSH/TC1-2008/0419 [141], XSH/TC1-2008/0420 [461],
XSH/TC1-2008/0421 [390], XSH/TC1-2008/0422 [146], XSH/TC1-2008/0423 [324], XSH/TC1-2008/0424 [292], XSH/TC1-2008/0425 [278],
XSH/TC1-2008/0426 [278], XSH/TC1-2008/0427 [291], and XSH/TC1-2008/0428 [307] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0235 [873], XSH/TC2-2008/0236 [835], XSH/TC2-2008/0237 [847],
XSH/TC2-2008/0238 [817], XSH/TC2-2008/0239 [835], XSH/TC2-2008/0240 [847], XSH/TC2-2008/0241 [822], XSH/TC2-2008/0242 [817], and
XSH/TC2-2008/0243 [943] are applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defect 293 is applied, adding the [EILSEQ] error.
Austin Group Defects 658 and 1665 are applied, restricting the allowed behaviors when O_EXEC is used on a directory, or O_SEARCH
on a non-directory file, or O_RDWR on a FIFO, so that the requirements for O_EXCL still apply.
Austin Group Defect 1016 is applied, changing the FUTURE DIRECTIONS section.
Austin Group Defect 1151 is applied, changing the description of O_TTY_INIT to include requirements relating to the
winsize structure.
Austin Group Defect 1318 is applied, adding FD_CLOFORK and O_CLOFORK.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
Austin Group Defect 1466 is applied, changing the terminology used for pseudo-terminal devices.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/jrand48.html =====
drand48
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
drand48, erand48, jrand48, lcong48, lrand48, mrand48, nrand48, seed48, srand48 — generate uniformly distributed
pseudo-random numbers
SYNOPSIS
[XSI]  #include
double drand48(void);
double erand48(unsigned short xsubi[3]);
long jrand48(unsigned short xsubi[3]);
void lcong48(unsigned short param[7]);
long lrand48(void);
long mrand48(void);
long nrand48(unsigned short xsubi[3]);
unsigned short *seed48(unsigned short seed16v[3]);
void srand48(long seedval);
DESCRIPTION
This family of functions shall generate pseudo-random numbers using a linear congruential algorithm and 48-bit integer
arithmetic.
The drand48() and erand48() functions shall return non-negative, double-precision, floating-point values,
uniformly distributed over the interval [0.0,1.0).
The lrand48() and nrand48() functions shall return non-negative, long integers, uniformly distributed over the
interval [0,231).
The mrand48() and jrand48() functions shall return signed long integers uniformly distributed over the interval
[-231,231).
The srand48(), seed48(), and lcong48() functions are initialization entry points, one of which should be
invoked before either drand48(), lrand48(), or mrand48() is called. (Although it is not recommended practice,
constant default initializer values shall be supplied automatically if drand48(), lrand48(), or mrand48() is
called without a prior call to an initialization entry point.) The erand48(), nrand48(), and jrand48()
functions do not require an initialization entry point to be called first.
All the routines work by generating a sequence of 48-bit integer values,
\(X_{i}\),
according to the linear congruential formula:
\(X_{n+1}=\left(a X_n+c\right)_{\bmod m} \quad n \geq 0\)
The parameter m=248; hence 48-bit integer arithmetic is performed. Unless lcong48() is invoked, the multiplier
value a and the addend value c are given by:
\(
\begin{aligned}
& a= \text { 5DEECE66D }_{16}=273673163155_8 \\
& c=\mathrm{B}_{16}=13_8
\end{aligned}
\)
The value returned by any of the drand48(), erand48(), jrand48(), lrand48(), mrand48(), or
nrand48() functions is computed by first generating the next 48-bit \(X_{i}\) in the sequence. \(X_{i}\) is then converted
to the return value as follows:
For drand48() and erand48() the value shall be 2-48 times \(X_{i}\).
For jrand48() and mrand48() the value shall be the largest integer not greater than 2-16 times \(X_{i}\).
For lrand48() and nrand48() the value shall be the largest integer not greater than 2-17 times \(X_{i}\).
The drand48(), lrand48(), and mrand48() functions store the last 48-bit \(X_{i}\) generated in an internal
buffer; that is why the application shall ensure that these are initialized prior to being invoked. The erand48(),
nrand48(), and jrand48() functions require the calling program to provide storage for the successive \(X_{i}\) values
in the array specified as an argument when the functions are invoked. That is why these routines do not have to be initialized; the
calling program merely has to place the desired initial value of \(X_{i}\) into the array and pass it as an argument. By using
different arguments, erand48(), nrand48(), and jrand48() allow separate modules of a large program to generate
several independent streams of pseudo-random numbers; that is, the sequence of numbers in each stream shall not
depend upon how many times the routines are called to generate numbers for the other streams.
The initializer function srand48() sets the high-order 32 bits of \(X_{i}\) to the low-order 32 bits contained in its
argument. The low-order 16 bits of \(X_{i}\) are set to the arbitrary value 330E16.
The initializer function seed48() sets the value of \(X_{i}\) to the 48-bit value specified in the argument array. The
low-order 16 bits of \(X_{i}\) are set to the low-order 16 bits of seed16v[0]. The mid-order 16 bits of \(X_{i}\) are
set to the low-order 16 bits of seed16v[1]. The high-order 16 bits of \(X_{i}\) are set to the low-order 16 bits of
seed16v[2]. In addition, the previous value of \(X_{i}\) is copied into a 48-bit internal buffer, used only by
seed48(), and a pointer to this buffer is the value returned by seed48(). This returned pointer, which can just be
ignored if not needed, is useful if a program is to be restarted from a given point at some future time—use the pointer to get at
and store the last \(X_{i}\) value, and then use this value to reinitialize via seed48() when the program is restarted.
The initializer function lcong48() allows the user to specify the initial \(X_{i}\), the multiplier value a, and the
addend value c. Argument array elements param[0-2] specify \(X_{i}\), param[3-5] specify the
multiplier a, and param[6] specifies the 16-bit addend c. After lcong48() is called, a subsequent call to
either srand48() or seed48() shall restore the standard multiplier and addend values, a and c,
specified above.
The drand48(), lrand48(), and mrand48() functions need not be thread-safe.
RETURN VALUE
As described in the DESCRIPTION above.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
The following program tests that the required pseudo-random number generator is used by these functions.
#include
#include
int main() {
{
unsigned short xsubi[3] = {37174, 64810, 11603};
double d = erand48(xsubi);
assert(d >= 0.896);
assert(d = 0.337);
assert(d = 0.647);
assert(d = 0.500);
assert(d = 0.506);
assert(d
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
A note indicating that the drand48(), lrand48(), and mrand48() functions need not be reentrant is added to
the DESCRIPTION.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0083 [743] is applied.
Issue 8
Austin Group Defect 1107 is applied, clarifying how the return value is calculated from  \(X_{i}\) for each function.
Austin Group Defect 1134 is applied, adding getentropy().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/shutdown.html =====
shutdown
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
shutdown — shut down socket send and receive operations
SYNOPSIS
#include
int shutdown(int socket, int how);
DESCRIPTION
The shutdown() function shall cause all or part of a full-duplex connection on the socket associated with the file
descriptor socket to be shut down.
The shutdown() function takes the following arguments:
socket
Specifies the file descriptor of the socket.
how
Specifies the type of shutdown. The values are as follows:
SHUT_RD
Disables further receive operations.
SHUT_WR
Disables further send operations.
SHUT_RDWR
Disables further send and receive operations.
The shutdown() function disables subsequent send and/or receive operations on a socket, depending on the value of the
how argument.
RETURN VALUE
Upon successful completion, shutdown() shall return 0; otherwise, -1 shall be returned and errno set to indicate
the error.
ERRORS
The shutdown() function shall fail if:
[EBADF]
The socket argument is not a valid file descriptor.
[EINVAL]
The how argument is invalid.
[ENOTCONN]
The socket is not connected.
[ENOTSOCK]
The socket argument does not refer to a socket.
The shutdown() function may fail if:
[ENOBUFS]
Insufficient resources were available in the system to perform the operation.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The file descriptor remains open after shutdown() returns to the calling application.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
close(), getsockopt(),
pselect(), read(),
recv(), recvfrom(), recvmsg(), send(), sendto(), setsockopt(), socket(), write()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
Issue 8
Austin Group Defect 1475 is applied, changing the APPLICATION USAGE section and adding close() to the SEE ALSO section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/rewind.html =====
rewind
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
rewind — reset the file position indicator in a stream
SYNOPSIS
#include
void rewind(FILE *stream);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The call:
rewind(stream)
shall be equivalent to:
(void) fseek(stream, 0L, SEEK_SET)
except that rewind() shall also ensure the error indicator is clear when the function returns.
[CX]
Since rewind() does not return a value, an application wishing to detect errors should clear errno, then call
rewind(), and if errno is non-zero, assume an error has occurred.
RETURN VALUE
The rewind() function shall not return a value.
ERRORS
[CX]
Refer to fseek() with the exception of [EINVAL] which does not apply.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fseek()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
Extensions beyond the ISO C standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0513 [14] is applied.
Issue 8
Austin Group Defect 1414 is applied, clarifying that rewind() ensures the error indicator is clear when the function
returns.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/iswalnum_l.html =====
iswalnum
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
iswalnum, iswalnum_l — test for an alphanumeric wide-character code
SYNOPSIS
#include
int iswalnum(wint_t wc);
[CX]  int iswalnum_l(wint_t wc, locale_t locale);
DESCRIPTION
For iswalnum(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The iswalnum() [CX]   and iswalnum_l()
functions shall test whether wc is a wide-character code representing a character of class alpha or
digit in the current locale, [CX]   or in the locale represented by locale,  respectively; see XBD 7. Locale.
The wc argument is a wint_t, the value of which the application shall ensure is a wide-character code
corresponding to a valid character in the locale used by the function, or equal to the value of the macro WEOF. If the argument has
any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to iswalnum_l() is the special locale object LC_GLOBAL_LOCALE or is not
a valid locale object handle.
RETURN VALUE
The iswalnum() [CX]   and iswalnum_l()
functions shall return non-zero if wc is an alphanumeric wide-character code; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
iswalpha(), iswcntrl(),
iswctype(), iswdigit(),
iswgraph(), iswlower(),
iswprint(), iswpunct(),
iswspace(), iswupper(),
iswxdigit(), setlocale(),
uselocale()
XBD 7. Locale, , ,
CHANGE HISTORY
First released as a World-wide Portability Interface in Issue 4.
Issue 5
The following change has been made in this version for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E):
The SYNOPSIS has been changed to indicate that this function and associated data types are now made visible by inclusion of the
header rather than .
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The iswalnum_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0309 [302], XSH/TC1-2008/0310 [283], and XSH/TC1-2008/0311 [283] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0180 [685] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ftok.html =====
ftok
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ftok — generate an IPC key
SYNOPSIS
[XSI]  #include
key_t ftok(const char *path, int id);
DESCRIPTION
The ftok() function shall return a key based on path and id that is usable in subsequent calls to msgget(), semget(), and shmget(). The application shall ensure that the path argument is the pathname of an
existing file that the process is able to stat(), with the exception that if stat() would fail with [EOVERFLOW] due to file size, ftok() shall still succeed.
The ftok() function shall return the same key value for all paths that name the same file, when called with the same
id value, and should return different key values when called with different id values or with paths that name
different files existing on the same file system at the same time. It is unspecified whether ftok() shall return the same
key value when called again after the file named by path is removed and recreated with the same name.
Only the low-order 8-bits of id are significant. The behavior of ftok() is unspecified if these bits are 0.
RETURN VALUE
Upon successful completion, ftok() shall return a key. Otherwise, ftok() shall return (key_t)-1 and set
errno to indicate the error.
ERRORS
The ftok() function shall fail if:
[EACCES]
Search permission is denied for a component of the path prefix.
[EIO]
An error occurred while reading from the file system.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of path does not name an existing file or path is an empty string.
[ENOTDIR]
A component of the path prefix names an existing file that is neither a directory nor a symbolic link to a directory, or the
path argument contains at least one non- character and ends with one or more trailing  characters
and the last pathname component names an existing file that is neither a directory nor a symbolic link to a directory.
The ftok() function may fail if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
The following sections are informative.
EXAMPLES
Getting an IPC Key
The following example gets a key based on the pathname /tmp and the ID value a. It also assigns the value of the
resulting key to the semkey variable so that it will be available to a later call to semget(), msgget(), or shmget().
#include
...
key_t semkey;
if ((semkey = ftok("/tmp", 'a')) == (key_t) -1) {
perror("IPC error: ftok"); exit(1);
}
APPLICATION USAGE
For maximum portability, id should be a single-byte character.
Applications should not assume that the resulting key value is unique.
RATIONALE
None.
FUTURE DIRECTIONS
Future versions of this standard may add new interfaces to provide unique keys.
SEE ALSO
msgget(), semget(), shmget()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
The wording of the mandatory [ELOOP] error condition is updated, and a second optional [ELOOP] error condition is added.
Issue 7
Austin Group Interpretation 1003.1-2001 #143 is applied.
The [ENOTDIR] error condition is clarified to cover the condition where the last component of a pathname exists but is not a
directory or a symbolic link to a directory.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0209 [343], XSH/TC1-2008/0210 [366], XSH/TC1-2008/0211 [343],
XSH/TC1-2008/0212 [324], XSH/TC1-2008/0213 [366], XSH/TC1-2008/0214 [366], XSH/TC1-2008/0215 [366], and XSH/TC1-2008/0216 [366] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/islessequal.html =====
isgreater
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
isgreater, isgreaterequal, isless, islessequal, islessgreater — real-floating relational tests
SYNOPSIS
#include
int isgreater(real-floating x, real-floating y);
int isgreaterequal(real-floating x, real-floating y);
int isless(real-floating x, real-floating y);
int islessequal(real-floating x, real-floating y);
int islessgreater(real-floating x, real-floating y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The isgreater() macro shall determine whether its first argument is greater than its second argument. The value of
isgreater(x, y) shall be equal to (x) > (y); however, unlike
(x) > (y), isgreater(x, y) shall not raise the invalid floating-point exception
when x and y are unordered.
The isgreaterequal() macro shall determine whether its first argument is greater than or equal to its second argument.
The value of isgreaterequal(x, y) shall be equal to (x) >= (y); however, unlike
(x) >= (y), isgreaterequal(x, y) shall not raise the invalid floating-point
exception when x and y are unordered.
The isless() macro shall determine whether its first argument is less than its second argument. The value of
isless(x, y) shall be equal to (x)  (y); however, islessgreater(x,
y) shall not raise the invalid floating-point exception when x and y are unordered (nor shall it evaluate
x and y twice).
[MX]
Relational operators and their corresponding comparison macros shall produce equivalent result values, even if argument values are
represented in wider formats. Thus, comparison macro arguments represented in formats wider than their semantic types shall not be
converted to the semantic types, unless the wide evaluation method converts operands of relational operators to their semantic
types. The standard wide evaluation methods characterized by FLT_EVAL_METHOD equal to 1 or 2 (see ) do not convert operands of relational operators to their semantic types.
RETURN VALUE
Upon successful completion, the isgreater() macro shall return the value of (x) > (y).
Upon successful completion, the isgreaterequal() macro shall return the value of
(x) >= (y).
Upon successful completion, the isless() macro shall return the value of (x)  (y).
If x or y is NaN, these functions shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The relational and equality operators support the usual mathematical relationships between numeric values. For any ordered pair
of numeric values, exactly one of the relationships (less, greater, and equal) is true. Relational operators may raise the invalid
floating-point exception when argument values are NaNs. For a NaN and a numeric value, or for two NaNs, just the unordered
relationship is true. This macro is a quiet (non-floating-point exception raising) version of a relational operator. It facilitates
writing efficient code that accounts for NaNs without suffering the invalid floating-point exception. In the SYNOPSIS section,
real-floating indicates that the argument shall be an expression of real-floating type.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
isunordered()
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
The individual pages for these functions have been merged to form a single page, to reduce duplication.
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/readlinkat.html =====
readlink
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
readlink, readlinkat — read the contents of a symbolic link
SYNOPSIS
#include
ssize_t readlink(const char *restrict path, char *restrict buf,
size_t bufsize);
[OH] #include
ssize_t readlinkat(int fd, const char *restrict path,
char *restrict buf, size_t bufsize);
DESCRIPTION
The readlink() function shall place the contents of the symbolic link referred to by path in the buffer buf
which has size bufsize. If the number of bytes in the symbolic link is less than bufsize, the contents of the
remainder of buf are unspecified. If the buf argument is not large enough to contain the link content, the first
bufsize bytes shall be placed in buf.
If the value of bufsize is greater than {SSIZE_MAX}, the result is implementation-defined.
Upon successful completion, readlink() shall mark for update the last data access timestamp of the symbolic link.
The readlinkat() function shall be equivalent to the readlink() function except in the case where path
specifies a relative path. In this case the symbolic link whose content is read is relative to the directory associated with the
file descriptor fd instead of the current working directory. If the access mode of the open file description associated with
the file descriptor is not O_SEARCH, the function shall check whether directory searches are permitted using the current
permissions of the directory underlying the file descriptor. If the access mode is O_SEARCH, the function shall not perform the
check.
If readlinkat() is passed the special value AT_FDCWD in the fd parameter, the current working directory shall be
used and the behavior shall be identical to a call to readlink().
RETURN VALUE
Upon successful completion, these functions shall return the count of bytes placed in the buffer. Otherwise, these functions
shall return a value of -1, leave the buffer unchanged, and set errno to indicate the error.
ERRORS
These functions shall fail if:
[EACCES]
Search permission is denied for a component of the path prefix of path.
[EINVAL]
The path argument names a file that is not a symbolic link.
[EIO]
An I/O error occurred while reading from the file system.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of path does not name an existing file or path is an empty string.
[ENOTDIR]
A component of the path prefix names an existing file that is neither a directory nor a symbolic link to a directory, or the
path argument contains at least one non- character and ends with one or more trailing  characters
and the last pathname component names an existing file that is neither a directory nor a symbolic link to a directory.
The readlinkat() function shall fail if:
[EACCES]
The access mode of the open file description associated with fd is not O_SEARCH and the permissions of the directory
underlying fd do not permit directory searches.
[EBADF]
The path argument does not specify an absolute path and the fd argument is neither AT_FDCWD nor a valid file
descriptor open for reading or searching.
[ENOTDIR]
The path argument is not an absolute path and fd is a file descriptor associated with a non-directory file.
These functions may fail if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
The following sections are informative.
EXAMPLES
Reading the Name of a Symbolic Link
The following example shows how to read the name of a symbolic link named /modules/pass1.
#include
char buf[1024];
ssize_t len;
...
if ((len = readlink("/modules/pass1", buf, sizeof(buf)-1)) != -1)
buf[len] = '\0';
APPLICATION USAGE
Conforming applications should not assume that the returned contents of the symbolic link are null-terminated.
RATIONALE
The type associated with bufsiz is a size_t in order to be consistent with both the ISO C standard and the
definition of read(). The behavior specified for readlink() when bufsiz
is zero represents historical practice. For this case, the standard developers considered a change whereby readlink() would
return the number of non-null bytes contained in the symbolic link with the buffer buf remaining unchanged; however, since
the stat structure member st_size value can be used to determine the size of buffer necessary to contain the contents
of the symbolic link as returned by readlink(), this proposal was rejected, and the historical practice retained.
The purpose of the readlinkat() function is to read the content of symbolic links in directories other than the current
working directory without exposure to race conditions. Any part of the path of a file could be changed in parallel to a call to
readlink(), resulting in unspecified behavior. By opening a file descriptor for the target directory and using the
readlinkat() function it can be guaranteed that the symbolic link read is located relative to the desired directory.
FUTURE DIRECTIONS
None.
SEE ALSO
fstatat(), symlink()
XBD ,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The return type is changed to ssize_t, to align with the IEEE P1003.1a draft standard.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
This function is made mandatory.
In this function it is possible for the return value to exceed the range of the type ssize_t (since size_t has a
larger range of positive values than ssize_t). A sentence restricting the size of the size_t object is added to the
description to resolve this conflict.
The following changes are made for alignment with the ISO POSIX-1:1996 standard:
The FUTURE DIRECTIONS section is changed to None.
The following changes were made to align with the IEEE P1003.1a draft standard:
The [ELOOP] optional error condition is added.
The restrict keyword is added to the readlink() prototype for alignment with the ISO/IEC 9899:1999
standard.
Issue 7
Austin Group Interpretation 1003.1-2001 #143 is applied.
SD5-XSH-ERN-189 is applied, updating the ERRORS section.
The readlinkat() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 2.
The [EACCES] error is removed from the "may fail" error conditions.
Changes are made to allow a directory to be opened for searching.
The [ENOTDIR] error condition is clarified to cover the condition where the last component of a pathname exists but is not a
directory or a symbolic link to a directory.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0487 [120], XSH/TC1-2008/0488 [461], XSH/TC1-2008/0489 [143],
XSH/TC1-2008/0490 [324], XSH/TC1-2008/0491 [278], XSH/TC1-2008/0492 [278], XSH/TC1-2008/0493 [455], and XSH/TC1-2008/0494 [151,231]
are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0305 [591], XSH/TC2-2008/0306 [817], XSH/TC2-2008/0307 [817], and
XSH/TC2-2008/0308 [591] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/kill.html =====
kill
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
kill — send a signal to a process or a group of processes
SYNOPSIS
[CX]  #include
int kill(pid_t pid, int sig);
DESCRIPTION
The kill() function shall send a signal to a process or a group of processes specified by pid. The signal to be
sent is specified by sig and is either one from the list given in  or 0. If sig is 0 (the null signal), error checking is performed but
no signal is actually sent. The null signal can be used to check the validity of pid.
For a process to have permission to send a signal to a process designated by pid, unless the sending process has
appropriate privileges, the real or effective user ID of the sending process shall match the real or saved set-user-ID of the
receiving process.
If pid is greater than 0, sig shall be sent to the process whose process ID is equal to pid.
If pid is 0, sig shall be sent to all processes (excluding an unspecified set of system processes) whose process
group ID is equal to the process group ID of the sender, and for which the process has permission to send a signal.
If pid is -1, sig shall be sent to all processes (excluding an unspecified set of system processes) for which the
process has permission to send that signal.
If pid is negative, but not -1, sig shall be sent to all processes (excluding an unspecified set of system
processes) whose process group ID is equal to the absolute value of pid, and for which the process has permission to send a
signal.
If the value of pid causes sig to be generated for the sending process, and if sig is not blocked for the
calling thread and if no other thread has sig unblocked or is waiting in a sigwait() function for sig, either sig or at least one pending unblocked
signal shall be delivered to the sending thread before kill() returns.
The user ID tests described above shall not be applied when sending SIGCONT to a process that is a member of the same session as
the sending process.
An implementation that provides extended security controls may impose further implementation-defined restrictions on the sending
of signals, including the null signal. In particular, the system may deny the existence of some or all of the processes specified
by pid.
The kill() function is successful if the process has permission to send sig to any of the processes specified by
pid. If kill() fails, no signal shall be sent.
RETURN VALUE
Upon successful completion, 0 shall be returned. Otherwise, -1 shall be returned and errno set to indicate the error.
ERRORS
The kill() function shall fail if:
[EINVAL]
The value of the sig argument is an invalid or unsupported signal number.
[EPERM]
The process does not have permission to send the signal to any receiving process.
[ESRCH]
No process or process group can be found corresponding to that specified by pid.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The semantics for permission checking for kill() differed between System V and most other implementations, such as
Version 7 or 4.3 BSD. The semantics chosen for this volume of POSIX.1-2024 agree with System V. Specifically, a set-user-ID process
cannot protect itself against signals (or at least not against SIGKILL) unless it changes its real user ID. This choice allows the
user who starts an application to send it signals even if it changes its effective user ID. The other semantics give more power to
an application that wants to protect itself from the user who ran it.
Some implementations provide semantic extensions to the kill() function when the absolute value of pid is greater
than some maximum, or otherwise special, value. Negative values are a flag to kill(). Since most implementations return
[ESRCH] in this case, this behavior is not included in this volume of POSIX.1-2024, although a conforming implementation could
provide such an extension.
The unspecified processes to which a signal cannot be sent may include the scheduler or init.
There was initially strong sentiment to specify that, if pid specifies that a signal be sent to the calling process and
that signal is not blocked, that signal would be delivered before kill() returns. This would permit a process to call
kill() and be guaranteed that the call never return. However, historical implementations that provide only the signal() function make only the weaker guarantee in this volume of POSIX.1-2024, because they
only deliver one signal each time a process enters the kernel. Modifications to such implementations to support the sigaction() function generally require entry to the kernel following return from a
signal-catching function, in order to restore the signal mask. Such modifications have the effect of satisfying the stronger
requirement, at least when sigaction() is used, but not necessarily when signal() is used. The standard developers considered making the stronger requirement except
when signal() is used, but felt this would be unnecessarily complex. Implementors are
encouraged to meet the stronger requirement whenever possible. In practice, the weaker requirement is the same, except in the rare
case when two signals arrive during a very short window. This reasoning also applies to a similar requirement for sigprocmask().
In 4.2 BSD, the SIGCONT signal can be sent to any descendant process regardless of user-ID security checks. This allows a job
control shell to continue a job even if processes in the job have altered their user IDs (as in the su command). In keeping
with the addition of the concept of sessions, similar functionality is provided by allowing the SIGCONT signal to be sent to any
process in the same session regardless of user ID security checks. This is less restrictive than BSD in the sense that ancestor
processes (in the same session) can now be the recipient. It is more restrictive than BSD in the sense that descendant processes
that form new sessions are now subject to the user ID checks. A similar relaxation of security is not necessary for the other job
control signals since those signals are typically sent by the terminal driver in recognition of special characters being typed; the
terminal driver bypasses all security checks.
In secure implementations, a process may be restricted from sending a signal to a process having a different security label. In
order to prevent the existence or nonexistence of a process from being used as a covert channel, such processes should appear
nonexistent to the sender; that is, [ESRCH] should be returned, rather than [EPERM], if pid refers only to such
processes.
Historical implementations varied on the result of a kill() with pid indicating a zombie process. Some indicated
success on such a call (subject to permission checking), while others gave an error of [ESRCH]. Since the definition of process
lifetime in this volume of POSIX.1-2024 covers zombie processes, the [ESRCH] error as described is inappropriate in this case and
implementations that give this error do not conform. This means that an application cannot have a parent process check for
termination of a particular child by sending it the null signal with kill(), but must instead use waitpid() or waitid().
There is some belief that the name kill() is misleading, since the function is not always intended to cause process
termination. However, the name is common to all historical implementations, and any change would be in conflict with the goal of
minimal changes to existing application code.
FUTURE DIRECTIONS
None.
SEE ALSO
getpid(), raise(), setsid(), sig2str(), sigaction(), sigqueue(), wait()
XBD ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Threads Extension.
Issue 6
In the SYNOPSIS, the optional include of the  header is
removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the DESCRIPTION, the second paragraph is reworded to indicate that the saved set-user-ID of the calling process is checked in
place of its effective user ID. This is a FIPS requirement.
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
The behavior when pid is -1 is now specified. It was previously explicitly unspecified in the POSIX.1-1988 standard.
The normative text is updated to avoid use of the term "must" for application requirements.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/51 is applied, correcting the RATIONALE section.
Issue 7
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0194 [765] is applied.
Issue 8
Austin Group Defect 1138 is applied, adding sig2str() to the SEE ALSO
section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/remainderl.html =====
remainder
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
remainder, remainderf, remainderl — remainder function
SYNOPSIS
#include
double remainder(double x, double y);
float remainderf(float x, float y);
long double remainderl(long double x, long double y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall return the floating-point remainder r=x-ny when y is non-zero. The value
n is the integral value nearest the exact value x/y. When |n-x/y|=½, the value n
is chosen to be even.
The behavior of remainder() shall be independent of the rounding mode.
RETURN VALUE
Upon successful completion, these functions shall return the floating-point remainder r=x-ny when y
is non-zero.
[MX]
When subnormal results are supported, the returned value shall be exact.
On systems that do not support the IEC 60559 Floating-Point option, if y is zero, it is implementation-defined whether a
domain error occurs or zero is returned.
[MX]  If
x or y is NaN, a NaN shall be returned.
If x is infinite or y is 0 and the other is non-NaN, a domain error shall occur, and a NaN shall be returned.
ERRORS
These functions shall fail if:
Domain Error
[MX]
The x argument is ±Inf, or the y argument is ±0 and the other argument is non-NaN.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
These functions may fail if:
Domain Error
The y argument is zero.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
abs(), div(), feclearexcept(), fetestexcept()
, ldiv()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The remainder() function is no longer marked as an extension.
The remainderf() and remainderl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #55 (SD5-XSH-ERN-82) is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0506 [320] is applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/dcgettext.html =====
gettext
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
dgettext, dgettext_l, dcgettext, dcgettext_l, gettext, gettext_l, ngettext, ngettext_l, dngettext, dngettext_l,
dcngettext, dcngettext_l — message handling functions
SYNOPSIS
#include
char *dgettext(const char *domainname, const char *msgid);
char *dgettext_l(const char *domainname, const char *msgid,
locale_t locale);
char *dcgettext(const char *domainname, const char *msgid,
int category);
char *dcgettext_l(const char *domainname, const char *msgid,
int category, locale_t locale);
char *dngettext(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n);
char *dngettext_l(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n,
locale_t locale);
char *dcngettext(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n,
int category);
char *dcngettext_l(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n,
int category, locale_t locale);
char *gettext(const char *msgid);
char *gettext_l(const char *msgid, locale_t locale);
char *ngettext(const char *msgid, const char *msgid_plural,
unsigned long int n);
char *ngettext_l(const char *msgid, const char *msgid_plural,
unsigned long int n, locale_t locale);
DESCRIPTION
The gettext() function shall:
attempt to locate a suitable messages object (described in detail below) for the LC_MESSAGES category in the current
locale, and for the current text domain (see bindtextdomain()), containing
the string identified by msgid,
retrieve the string identified by msgid from the messages object,
convert the string to the output codeset if necessary (described in detail below), and
return the result.
If the locale name in effect is "POSIX" or "C" (i.e. the name associated with the LC_MESSAGES locale
category in the current locale), or if no suitable messages object exists, or if no string identified by msgid exists in the
messages object, or if an error occurs, msgid shall be returned.
The dgettext() function shall be equivalent to gettext(), except domainname shall be used instead of the
current text domain to locate the messages object.
The dcgettext() function shall be equivalent to dgettext(), except the locale category identified by
category shall be used instead of LC_MESSAGES .
The ngettext() function shall be equivalent to gettext(), except:
The string to retrieve shall be identified by a combination of msgid and n (see msgfmt).
If the locale name in effect is "POSIX" or "C", or if no suitable messages object exists, or if no string
identified by the combination of msgid and n exists in the messages object, or if an error occurs, the return value
shall be msgid if n is 1, otherwise msgid_plural.
The dngettext() function shall be equivalent to ngettext(), except domainname shall be used instead of the
current text domain to locate the messages object.
The dcngettext() function shall be equivalent to dngettext(), except the locale category identified by
category shall be used instead of LC_MESSAGES .
The *_l() functions shall be equivalent to their counterparts without the _l suffix, except locale shall be
used instead of the current locale. If locale is the special locale object LC_GLOBAL_LOCALE or is not a valid locale object
handle, the behavior is undefined.
The application shall ensure that the msgid and msgid_plural arguments are strings. If either msgid or
msgid_plural is an empty string, or contains characters not in the portable character set, the results are unspecified. If
the category argument is LC_ALL , the results are unspecified.
The location of the messages object shall be determined according to the following criteria, stopping when the first messages
object is found:
[XSI]
If the NLSPATH environment variable is set to a non-empty string, an NLSPATH search shall be performed as described
in XBD 8.2 Internationalization Variables. If NLSPATH identifies
more than one template to use, each template in turn shall be used until a valid messages object is found.
If the LANGUAGE environment variable is set to a non-empty string, a LANGUAGE search shall be performed as
described below. If LANGUAGE identifies more than one directory to search, each directory shall be searched until a valid
messages object is found.
A single-locale search shall be performed as described below.
For [XSI]   the NLSPATH search and   the single-locale search,
the single locale name used to locate the messages object shall be the locale name associated with the selected locale category
from the current locale, or the provided locale object if calling one of the *_l() functions; additional searches of locale
names without .codeset (if present), without _territory (if present), and without @modifier (if present) may
be performed.
For the LANGUAGE search, the value of the LANGUAGE environment variable shall be a list of one or more locale
names separated by a  (':') character. Each locale name shall be tried in the specified order. If a messages
object for the locale does not exist, or cannot be opened, or is unsuitable for implementation-defined reasons (such as security),
the next locale name (if any) shall be tried. If:
a messages object for the locale can be opened but cannot be processed without error, or
the messages object does not contain a string identified by msgid, or msgid and n for the ngettext
functions,
it is unspecified whether the next locale name (if any) is tried. In all other cases, the messages object for the locale shall
be used.
For each locale name in LANGUAGE , or if LANGUAGE is not set or is empty, or no suitable messages object is found
in processing LANGUAGE , the pathname used to locate the messages object shall be
dirname/localename/categoryname/textdomainname.mo, where:
The dirname part is the dirname argument of the most recent successful call to bindtextdomain() that had textdomainname as the domainname argument;
any trailing  characters in dirname shall be discarded. If a successful call to bindtextdomain() has not been made for textdomainname, an
implementation-defined default directory shall be used.
For the LANGUAGE search, the localename part is each locale name from LANGUAGE in turn; if a locale name
has the format language[_territory][.codeset][@modifier], additional
searches of locale names without .codeset (if present), without _territory (if present), and without @modifier
(if present) may be performed; if .codeset is not present, additional searches of locale names with an added .codeset
may be performed. For the single-locale search, the localename part is the name of the current locale, or the locale
specified in an *_l() function call, for the category named by categoryname. Spellings of codeset names are not
standardized, and implementations may attempt to use different commonly known spellings, for example "utf8" and
"UTF-8".
The categoryname part is the string "LC_MESSAGES" if gettext(), dgettext(), ngettext(), or
dngettext() is called, or the locale category name corresponding to the category argument to dcgettext() or
dcngettext(). Likewise for the *_l() variants of all these functions.
For gettext(), gettext_l(), ngettext(), and ngettext_l(), the textdomainname part is the text
domain set by the last successful call to textdomain(). For dgettext(),
dcgettext(), dngettext(), dcngettext(), and the *_l() variants of these functions,
textdomainname is the text domain specified by the domainname argument. The domainname argument shall be
equivalent in syntax and meaning to the domainname argument to textdomain(), except that the selection of the text domain shall affect only the
dgettext(), dcgettext(), dngettext(), and dcngettext() function calls and their *_l() variants.
If the domainname argument is a null pointer, the text domain set by the last successful call to textdomain() shall be used. For all of these functions, if a successful call to textdomain() has not been made the default text domain "messages" shall be
used.
Resolution of the messages object pathname shall be performed the first time one of the gettext family of functions is
called for a given combination of dirname, localename, categoryname, and textdomainname. It is
unspecified whether the pathname is re-resolved if the combination has been used before in a call to one of the gettext
family of functions. If bindtextdomain() performs pathname resolution of its
dirname argument, only the part of the messages object pathname after dirname shall be resolved by the gettext
family of functions.
When one of the gettext family of functions returns a message string that was found in a messages object, it shall
convert the codeset of the message string to the output codeset if a codeset is specified in the messages object (see msgfmt) and the output codeset is not the same as that codeset. If a successful call to
bind_textdomain_codeset() has been made with the text domain of the
messages object as the domainname argument and a non-null codeset argument, the output codeset shall be the
codeset argument from the most recent such call. Otherwise, the output codeset shall be the codeset of characters in the
current locale, or the provided locale object if calling one of the *_l() functions, as specified by the LC_CTYPE
category of the locale. The conversion shall be performed as if by a call to iconv()
using a conversion descriptor returned by iconv_open(, ),
except that if the return value of iconv() would be greater than zero, the
non-identical conversions performed by the gettext family of functions need not be the same as those that such an iconv() call would perform. If an error prevents the codeset conversion from being performed,
the gettext family of functions shall behave as if no message string was found in the messages object. If at least one
non-identical conversion is performed that results in a fallback character (one that does not provide any information about the
character it was converted from, for example, a  or "replacement-character"), the gettext family of
functions may behave as if no message string was found in the messages object.
RETURN VALUE
The gettext(), gettext_l(), dgettext(), dgettext_l(), dcgettext(), and dcgettext_l()
functions shall return the message string described in DESCRIPTION if successful. Otherwise, they shall return msgid.
The ngettext(), ngettext_l(), dngettext(), dngettext_l(), dcngettext(), and
dcngettext_l() functions shall return the message string described in DESCRIPTION if successful. Otherwise, msgid
shall be returned if n is equal to 1, or msgid_plural if n is not equal to 1.
The application shall ensure that it does not modify the returned string. A subsequent call to a gettext family function
shall not overwrite or invalidate the returned string. The returned string may be invalidated by a subsequent call to bind_textdomain_codeset(), bindtextdomain(), setlocale(), or
textdomain() in the same process, except for calls that only query values. The
returned string shall not be invalidated by a subsequent call to uselocale().
ERRORS
The gettext family of functions shall not modify errno. If an error occurs these functions shall return a string
as described in RETURN VALUE.
The following sections are informative.
EXAMPLES
The example code below assumes the following:
The implementation-defined default directory is /system/gettextlib.
The following locales are available on the target system: en_US, en_GB, de_DE. The codeset used for all of these locales is
UTF-8.
The en_AU locale is not available on the target system.
The target system supports conversion from ISO/IEC 8859-1 to UTF-8.
The codeset used for the POSIX locale is ASCII.
The target system does not support conversion from ISO/IEC 8859-1 to ASCII.
Furthermore, the following .mo files (and only the following .mo files) are installed:
/system/gettextlib/en_US/LC_MESSAGES/mail.mo
/messagecatalogs/example/en_US/LC_MESSAGES/mail.mo
These are compiled from a portable messages object source file (dot-po file) with the following ISO/IEC 8859-1 encoded contents
(see the EXTENDED DESCRIPTION of the msgfmt utility for a description of the dot-po
file format):
msgid ""
msgstr ""
"Content-Type: text/plain; charset=ISO_8859-1\n"
"Plural-Forms: nplurals=4; plural= n==1?0: (n>1&&n1&&n1&&n,
XCU gettext, msgfmt,
xgettext
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getgrnam_r.html =====
getgrnam
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getgrnam, getgrnam_r — search group database for a name
SYNOPSIS
#include
struct group *getgrnam(const char *name);
int getgrnam_r(const char *name, struct group *grp, char *buffer,
size_t bufsize, struct group **result);
DESCRIPTION
The getgrnam() function shall search the group database for an entry with a matching name.
The getgrnam() function need not be thread-safe.
Applications wishing to check for error situations should set errno to 0 before calling getgrnam(). If
getgrnam() returns a null pointer and errno is set to non-zero, an error occurred.
The getgrnam_r() function shall update the group structure pointed to by grp and store a pointer to that
structure at the location pointed to by result. The structure shall contain an entry from the group database with a matching
name. Storage referenced by the group structure is allocated from the memory provided with the buffer
parameter, which is bufsize bytes in size. A call to sysconf(_SC_GETGR_R_SIZE_MAX) returns either -1 without changing
errno or an initial value suggested for the size of this buffer. A null pointer is returned at the location pointed to by
result on error or if the requested entry is not found.
RETURN VALUE
The getgrnam() function shall return a pointer to a struct group with the structure defined in  with a matching entry if one is found. The getgrnam() function shall
return a null pointer if either the requested entry was not found, or an error occurred. If the requested entry was not found,
errno shall not be changed. On error, errno shall be set to indicate the error.
The application shall not modify the structure to which the return value points, nor any storage areas pointed to by pointers
within the structure. The returned pointer, and pointers within the structure, might be invalidated or the structure or the storage
areas might be overwritten by a subsequent call to getgrent(), getgrgid(), or getgrnam(). The returned pointer, and pointers within the structure,
might also be invalidated if the calling thread is terminated.
The getgrnam_r() function shall return zero on success or if the requested entry was not found and no error has occurred.
If any error has occurred, an error number shall be returned to indicate the error.
ERRORS
The getgrnam() and getgrnam_r() functions may fail if:
[EIO]
An I/O error has occurred.
[EINTR]
A signal was caught during getgrnam().
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum allowable number of files is currently open in the system.
The getgrnam_r() function shall fail if:
[ERANGE]
Insufficient storage was supplied via buffer and bufsize to contain the data to be referenced by the resulting
group structure.
The following sections are informative.
EXAMPLES
Note that sysconf(_SC_GETGR_R_SIZE_MAX) may return -1 if there is no hard limit on the size of the buffer needed to store
all the groups returned. This example shows how an application can allocate a buffer of sufficient size to work with
getgrnam_r().
long int initlen = sysconf(_SC_GETGR_R_SIZE_MAX);
size_t len;
if (initlen == -1)
/* Default initial length. */
len = 1024;
else
len = (size_t) initlen;
struct group result;
struct group *resultp;
char *buffer = malloc(len);
if (buffer == NULL)
...handle error...
int e;
while ((e = getgrnam_r("somegroup", &result, buffer, len, &resultp))
== ERANGE)
{
size_t newlen = 2 * len;
if (newlen ,
CHANGE HISTORY
First released in Issue 1. Derived from System V Release 2.0.
Issue 5
Normative text previously in the APPLICATION USAGE section is moved to the RETURN VALUE section.
The getgrnam_r() function is included for alignment with the POSIX Threads Extension.
A note indicating that the getgrnam() function need not be reentrant is added to the DESCRIPTION.
Issue 6
The getgrnam_r() function is marked as part of the Thread-Safe Functions option.
In the DESCRIPTION, the note about reentrancy is expanded to cover thread-safety.
In the SYNOPSIS, the optional include of the  header is
removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
In the RETURN VALUE section, the requirement to set errno on error is added.
The [EIO], [EINTR], [EMFILE], and [ENFILE] optional error conditions are added.
The APPLICATION USAGE section is updated to include a note on the thread-safe function and its avoidance of possibly using a
static data area.
IEEE PASC Interpretation 1003.1 #116 is applied, changing the description of the size of the buffer from bufsize
characters to bytes.
Issue 7
Austin Group Interpretation 1003.1-2001 #081 is applied, clarifying the RETURN VALUE section.
Austin Group Interpretation 1003.1-2001 #156 is applied.
SD5-XBD-ERN-4 is applied, changing the definition of the [EMFILE] error.
SD5-XSH-ERN-166 is applied.
The getgrnam_r() function is moved from the Thread-Safe Functions option to the Base.
A minor addition is made to the EXAMPLES section, reminding the application developer to free memory allocated as if by malloc().
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0242 [75] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0164 [808], XSH/TC2-2008/0165 [808], XSH/TC2-2008/0166 [656], and
XSH/TC2-2008/0167 [808] are applied.
Issue 8
Austin Group Defect 398 is applied, changing the [ERANGE] error from "may fail" to "shall fail".
Austin Group Defect 1570 is applied, removing extra spacing in "==".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fputs.html =====
fputs
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fputs — put a string on a stream
SYNOPSIS
#include
int fputs(const char *restrict s, FILE *restrict stream);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The fputs() function shall write the null-terminated string pointed to by s to the stream pointed to by
stream. The terminating null byte shall not be written.
[CX]  The
last data modification and last file status change timestamps of the file shall be marked for update between the successful
execution of fputs() and the next successful completion of a call to fflush()
or fclose() on the same stream or a call to exit() or abort().
RETURN VALUE
Upon successful completion, fputs() shall return a non-negative number. Otherwise, it shall return EOF, set an error
indicator for the stream, [CX]   and set errno to indicate the error.
ERRORS
Refer to fputc().
The following sections are informative.
EXAMPLES
Printing to Standard Output
The following example gets the current time, converts it to a string using localtime() and asctime(), and prints it to
standard output using fputs(). It then prints the number of minutes to an event for which it is waiting.
#include
#include
...
time_t now;
int minutes_to_event;
...
time(&now);
printf("The time is ");
fputs(asctime(localtime(&now)), stdout);
printf("There are still %d minutes to the event.\n",
minutes_to_event);
...
APPLICATION USAGE
The puts() function appends a  while fputs() does not.
This volume of POSIX.1-2024 requires that successful completion simply return a non-negative integer. There are at least three
known different implementation conventions for this requirement:
Return a constant value.
Return the last character written.
Return the number of bytes written. Note that this implementation convention cannot be adhered to for strings longer than
{INT_MAX} bytes as the value would not be representable in the return type of the function. For backwards-compatibility,
implementations can return the number of bytes for strings of up to {INT_MAX} bytes, and return {INT_MAX} for all longer
strings.
RATIONALE
The fputs() function is one whose source code was specified in the referenced The C Programming Language. In the
original edition, the function had no defined return value, yet many practical implementations would, as a side-effect, return the
value of the last character written as that was the value remaining in the accumulator used as a return value. In the second
edition of the book, either the fixed value 0 or EOF would be returned depending upon the return value of ferror(); however, for compatibility with extant implementations, several implementations
would, upon success, return a positive value representing the last byte written.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fopen(), putc(), puts()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
Extensions beyond the ISO C standard are marked.
The fputs() prototype is updated for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0170 [174,412], XSH/TC1-2008/0171 [412], and XSH/TC1-2008/0172 [14] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fsetpos.html =====
fsetpos
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fsetpos — set current file position
SYNOPSIS
#include
int fsetpos(FILE *stream, const fpos_t *pos);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The fsetpos() function shall set the mbstate_t object (if any) and file position indicator for the stream pointed
to by stream according to the value of the object pointed to by pos, which the application shall ensure is a value
obtained from an earlier call to fgetpos() on the same stream. If a read or write
error occurs, the error indicator for the stream shall be set and fsetpos() fails.
A successful call to the fsetpos() function shall undo any effects of the ungetc() function on the stream, clear the end-of-file indicator for the stream, and then
establish the new parse state and position. After a successful fsetpos() call, the next operation on an update stream can be
either input or output.
[CX]  The
behavior of fsetpos() on devices which are incapable of seeking is implementation-defined. The value of the file offset
associated with such a device is undefined.
If the stream has an underlying file description and is writable, and buffered data has not been written to the underlying file,
fsetpos() shall cause the unwritten data to be written to the file and shall mark the last data modification and last file
status change timestamps of the file for update.
If the stream was created by fmemopen(), open_memstream(), or open_wmemstream() and the stream is writable, and if the stream is buffered and data
in the stream's buffer has not been written to the underlying memory buffer, fsetpos() shall cause the unwritten data to be
written to the underlying memory buffer.
The fsetpos() function shall not change the setting of errno if successful.
RETURN VALUE
The fsetpos() function shall return 0 if it succeeds; otherwise, it shall return a non-zero value and set errno to
indicate the error.
ERRORS
The fsetpos() function shall fail if, [CX]   either the stream is unbuffered or the stream's
buffer needed to be flushed, and the call to fsetpos() causes an underlying lseek() or write() to be invoked, and:
[EAGAIN]
[CX]
The O_NONBLOCK flag is set for the file descriptor and the thread would be delayed in the write operation.
[EBADF]
[CX]
The file descriptor underlying the stream file is not open for writing or the stream's buffer needed to be flushed and the file is
not open.
[EFBIG]
[CX]  An
attempt was made to write a file that exceeds the maximum file size.
[EFBIG]
[CX]  An
attempt was made to write a file that exceeds the file size limit of the process.
[XSI]
A SIGXFSZ signal shall also be generated for the thread.
[EFBIG]
[CX]
The file is a regular file and an attempt was made to write at or beyond the offset maximum associated with the corresponding
stream.
[EINTR]
[CX]
The write operation was terminated due to the receipt of a signal, and no data was transferred.
[EIO]
[CX]  A
physical I/O error has occurred, or the process is a member of a background process group attempting to perform a write() to its controlling terminal, TOSTOP is set, the calling thread is not blocking
SIGTTOU, the process is not ignoring SIGTTOU, and the process group of the process is orphaned. This error may also be returned
under implementation-defined conditions.
[ENOMEM]
[CX]
The stream was created by open_memstream() or open_wmemstream() and insufficient memory is available.
[ENOSPC]
[CX]
There was no free space remaining on the device containing the file or in the buffer used by the fmemopen() function.
[EPIPE]
[CX]  An
attempt was made to write to a pipe or FIFO that is not open for reading by any process; a SIGPIPE signal shall also be sent to the
thread.
[ESPIPE]
[CX]
The file descriptor underlying stream is associated with a pipe, FIFO, or socket.
The fsetpos() function may fail if:
[ENXIO]
[CX]  A
request was made of a nonexistent device, or the request was outside the capabilities of the device.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The ERRORS section does not include an [EINVAL] error equivalent to the one for fseek() because applications are required to obtain the fpos_t value using fgetpos(), in which case the file position to be set will always be valid. Directly
manipulating the fpos_t object to set a position results in undefined behavior. However, if an implementation detects that
the requested file position would be a negative value, or would be beyond the end of the underlying memory buffer of a stream that
was created by fmemopen(), it is recommended that fsetpos() returns a
non-zero value and sets errno to [EINVAL].
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fopen(), fmemopen(), ftell(), lseek(), open_memstream(), rewind(),
ungetc(), write()
XBD
CHANGE HISTORY
First released in Issue 4. Derived from the ISO C standard.
Issue 6
Extensions beyond the ISO C standard are marked.
The normative text is updated to avoid use of the term "must" for application requirements.
The DESCRIPTION is updated to clarify that the error indicator is set for the stream on a read or write error. This is for
alignment with the ISO/IEC 9899:1999 standard.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/21 is applied, deleting an erroneous [EINVAL] error case from
the ERRORS section.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/43 is applied, updating the [EAGAIN] error in the ERRORS section
from "the process would be delayed" to "the thread would be delayed".
Issue 7
SD5-XSH-ERN-220 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0192 [105], XSH/TC1-2008/0193 [79], XSH/TC1-2008/0194 [225],
XSH/TC1-2008/0195 [450], XSH/TC1-2008/0196 [450], and XSH/TC1-2008/0197 [14] are applied.
Issue 8
Austin Group Defect 308 is applied, clarifying the handling of [EFBIG] errors.
Austin Group Defect 1225 is applied, aligning the CX requirements with fseek().
Austin Group Defect 1249 is applied, correcting some text mismatches with the ISO C standard.
Austin Group Defect 1669 is applied, removing XSI shading from part of the [EFBIG] error relating to the file size limit for the
process.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getcwd.html =====
getcwd
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getcwd — get the pathname of the current working directory
SYNOPSIS
#include
char *getcwd(char *buf, size_t size);
DESCRIPTION
The getcwd() function shall place an absolute pathname of the current working directory in the array pointed to by
buf, and return buf. The pathname shall contain no components that are dot or dot-dot, or are symbolic links.
If there are multiple pathnames that getcwd() could place in the array pointed to by buf, one beginning with a
single  character and one or more beginning with two  characters, then getcwd() shall place the
pathname beginning with a single  character in the array. The pathname shall not contain any unnecessary
characters after the leading one or two  characters.
The size argument is the size in bytes of the character array pointed to by the buf argument. If buf is a
null pointer, the behavior of getcwd() is unspecified.
RETURN VALUE
Upon successful completion, getcwd() shall return the buf argument. Otherwise, getcwd() shall return a null
pointer and set errno to indicate the error. The contents of the array pointed to by buf are then undefined.
ERRORS
The getcwd() function shall fail if:
[EINVAL]
The size argument is 0.
[ERANGE]
The size argument is greater than 0, but is smaller than the length of the string +1.
The getcwd() function may fail if:
[EACCES]
Search permission was denied for the current directory, or read or search permission was denied for a directory above the
current directory in the file hierarchy.
[ENOMEM]
Insufficient storage space is available.
The following sections are informative.
EXAMPLES
The following example uses {PATH_MAX} as the initial buffer size (unless it is indeterminate or very large), and calls
getcwd() with progressively larger buffers until it does not give an [ERANGE] error.
#include
#include
#include
...
long path_max;
size_t size;
char *buf;
char *ptr;
path_max = pathconf(".", _PC_PATH_MAX);
if (path_max == -1)
size = 1024;
else if (path_max > 10240)
size = 10240;
else
size = path_max;
for (buf = ptr = NULL; ptr == NULL; size *= 2)
{
if ((buf = realloc(buf, size)) == NULL)
{
... handle error ...
}
ptr = getcwd(buf, size);
if (ptr == NULL && errno != ERANGE)
{
... handle error ...
}
}
...
free (buf);
APPLICATION USAGE
If the pathname obtained from getcwd() is longer than {PATH_MAX} bytes, it could produce an [ENAMETOOLONG] error if
passed to chdir(). Therefore, in order to return to that directory it may be necessary
to break the pathname into sections shorter than {PATH_MAX} bytes and call chdir() on
each section in turn (the first section being an absolute pathname and subsequent sections being relative pathnames). A simpler way
to handle saving and restoring the working directory when it may be deeper than {PATH_MAX} bytes in the file hierarchy is to use a
file descriptor and fchdir(), rather than getcwd() and chdir(). However, the two methods do have some differences. The fchdir() approach causes the program to restore a working directory even if it has been
renamed in the meantime, whereas the chdir() approach restores to a directory with the
same name as the original, even if the directories were renamed in the meantime. Since the fchdir() approach does not access parent directories, it can succeed when getcwd()
would fail due to permissions problems. In applications conforming to earlier versions of this standard, it was not possible to use
the fchdir() approach when the working directory is searchable but not readable, as
the only way to open a directory was with O_RDONLY, whereas the getcwd() approach can succeed in this case.
RATIONALE
Having getcwd() take no arguments and instead use the malloc() function to
produce space for the returned argument was considered. The advantage is that getcwd() knows how big the working directory
pathname is and can allocate an appropriate amount of space. But the programmer would have to use the free() function to free the resulting object, or each use of getcwd() would further
reduce the available memory. Finally, getcwd() is taken from the SVID where it has the two arguments used in this volume of
POSIX.1-2024.
The older function getwd() was rejected for use in this context because it had only a buffer argument and no size
argument, and thus had no way to prevent overwriting the buffer, except to depend on the programmer to provide a large enough
buffer.
On some implementations, if buf is a null pointer, getcwd() may obtain size bytes of memory using malloc(). In this case, the pointer returned by getcwd() may be used as the argument
in a subsequent call to free(). Invoking getcwd() with buf as a null
pointer is not recommended in conforming applications.
Earlier implementations of getcwd() sometimes generated pathnames like "../../../subdirname" internally, using
them to explore the path of ancestor directories back to the root. If one of these internal pathnames exceeded {PATH_MAX} in
length, the implementation could fail with errno set to [ENAMETOOLONG]. This is no longer allowed.
If a program is operating in a directory where some (grand)parent directory does not permit reading, getcwd() may fail,
as in most implementations it must read the directory to determine the name of the file. This can occur if search, but not read,
permission is granted in an intermediate directory, or if the program is placed in that directory by some more privileged process
(for example, login). Including the [EACCES] error condition makes the reporting of the error consistent and warns the application
developer that getcwd() can fail for reasons beyond the control of the application developer or user. Some implementations
can avoid this occurrence (for example, by implementing getcwd() using pwd, where
pwd is a set-user-root process), thus the error was made optional. Since this volume of
POSIX.1-2024 permits the addition of other errors, this would be a common addition and yet one that applications could not be
expected to deal with without this addition.
FUTURE DIRECTIONS
None.
SEE ALSO
malloc()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The [ENOMEM] optional error condition is added.
Issue 7
Austin Group Interpretation 1003.1-2001 #140 is applied, changing the text for consistency with the pwd utility, adding text to address the case where the current directory is deeper in the file
hierarchy than {PATH_MAX} bytes, and adding the requirements relating to pathnames beginning with two  characters.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_setspecific.html =====
pthread_getspecific
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_getspecific, pthread_setspecific — thread-specific data management
SYNOPSIS
#include
void *pthread_getspecific(pthread_key_t key);
int pthread_setspecific(pthread_key_t key, const void *value);
DESCRIPTION
The pthread_getspecific() function shall return the value currently bound to the specified key on behalf of the
calling thread.
The pthread_setspecific() function shall associate a thread-specific value with a key obtained via a
previous call to pthread_key_create(). Different threads may bind
different values to the same key. These values are typically pointers to blocks of dynamically allocated memory that have been
reserved for use by the calling thread.
The effect of calling pthread_getspecific() or pthread_setspecific() with a key value not obtained from
pthread_key_create() or after key has been deleted with pthread_key_delete() is undefined.
Both pthread_getspecific() and pthread_setspecific() may be called from a thread-specific data destructor
function. A call to pthread_getspecific() for the thread-specific data key being destroyed shall return the value NULL,
unless the value is changed (after the destructor starts) by a call to pthread_setspecific(). Calling
pthread_setspecific() from a thread-specific data destructor routine may result either in lost storage (after at least
PTHREAD_DESTRUCTOR_ITERATIONS attempts at destruction) or in an infinite loop.
Both functions may be implemented as macros.
RETURN VALUE
The pthread_getspecific() function shall return the thread-specific data value associated with the given key. If
no thread-specific data value is associated with key, then the value NULL shall be returned.
If successful, the pthread_setspecific() function shall return zero; otherwise, an error number shall be returned to
indicate the error.
ERRORS
No errors are returned from pthread_getspecific().
The pthread_setspecific() function shall fail if:
[ENOMEM]
Insufficient memory exists to associate the non-NULL value with the key.
The pthread_setspecific() function shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
Performance and ease-of-use of pthread_getspecific() are critical for functions that rely on maintaining state in
thread-specific data. Since no errors are required to be detected by it, and since the only error that could be detected is the use
of an invalid key, the function to pthread_getspecific() has been designed to favor speed and simplicity over error
reporting.
If an implementation detects that the value specified by the key argument to pthread_setspecific() does not refer
to a a key value obtained from pthread_key_create() or refers to a key
that has been deleted with pthread_key_delete(), it is recommended that
the function should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_key_create()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_getspecific() and pthread_setspecific() functions are marked as part of the Threads option.
IEEE PASC Interpretation 1003.1c #3 (Part 6) is applied, updating the DESCRIPTION.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/96 is applied, updating the ERRORS section so that the [ENOMEM]
error case is changed from "to associate the value with the key" to "to associate the non-NULL value with the key".
Issue 7
Austin Group Interpretation 1003.1-2001 #063 is applied, updating the ERRORS section.
The pthread_getspecific() and pthread_setspecific() functions are moved from the Threads option to the Base.
The [EINVAL] error for a key value not obtained from pthread_key_create() or a key deleted with pthread_key_delete() is removed; this condition results in undefined
behavior.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ftrylockfile.html =====
flockfile
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
flockfile, ftrylockfile, funlockfile — stdio locking functions
SYNOPSIS
[CX]  #include
void flockfile(FILE *file);
int ftrylockfile(FILE *file);
void funlockfile(FILE *file);
DESCRIPTION
These functions shall provide for explicit application-level locking of the locks associated with standard I/O streams (see
2.5 Standard I/O Streams). These functions can be used by a thread to
delineate a sequence of I/O statements that are executed as a unit.
The flockfile() function shall acquire for a thread ownership of a (FILE *) object.
The ftrylockfile() function shall acquire for a thread ownership of a (FILE *) object if the object is available;
ftrylockfile() is a non-blocking version of flockfile().
The funlockfile() function shall relinquish the ownership granted to the thread. The behavior is undefined if a thread
other than the current owner calls the funlockfile() function.
The functions shall behave as if there is a lock count associated with each (FILE *) object. This count is implicitly
initialized to zero when the (FILE *) object is created. The (FILE *) object is unlocked when the count is zero. When
the count is positive, a single thread owns the (FILE *) object. When the flockfile() function is called, if the
count is zero or if the count is positive and the caller owns the (FILE *) object, the count shall be incremented.
Otherwise, the calling thread shall be suspended, waiting for the count to return to zero. Each call to funlockfile() shall
decrement the count. This allows matching calls to flockfile() (or successful calls to ftrylockfile()) and
funlockfile() to be nested.
RETURN VALUE
None for flockfile() and funlockfile().
The ftrylockfile() function shall return zero for success and non-zero to indicate that the lock cannot be acquired.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications using these functions may be subject to priority inversion, as discussed in XBD 3.275 Priority Inversion.
A call to exit() can block until locked streams are unlocked because a thread having
ownership of a (FILE*) object blocks all function calls that reference that (FILE*) object (except those with names
ending in _unlocked) from other threads, including calls to exit().
Note: a FILE lock is not a file lock (see XBD 3.143 File Lock
).
RATIONALE
The flockfile() and funlockfile() functions provide an orthogonal mutual-exclusion lock for each FILE. The
ftrylockfile() function provides a non-blocking attempt to acquire a FILE lock, analogous to pthread_mutex_trylock().
These locks behave as if they are the same as those used internally by stdio for thread-safety. This both provides
thread-safety of these functions without requiring a second level of internal locking and allows functions in stdio to be
implemented in terms of other stdio functions.
Application developers and implementors should be aware that there are potential deadlock problems on FILE objects. For
example, the line-buffered flushing semantics of stdio (requested via {_IOLBF}) require that certain input operations
sometimes cause the buffered contents of implementation-defined line-buffered output streams to be flushed. If two threads each
hold the lock on the other's FILE, deadlock ensues. This type of deadlock can be avoided by acquiring FILE locks in a
consistent order. In particular, the line-buffered output stream deadlock can typically be avoided by acquiring locks on input
streams before locks on output streams if a thread would be acquiring both.
In summary, threads sharing stdio streams with other threads can use flockfile() and funlockfile() to cause
sequences of I/O performed by a single thread to be kept bundled. The only case where the use of flockfile() and
funlockfile() is required is to provide a scope protecting uses of the *_unlocked functions/macros. This moves the
cost/performance tradeoff to the optimal point.
FUTURE DIRECTIONS
None.
SEE ALSO
exit(), getc_unlocked()
XBD 3.275 Priority Inversion,
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
These functions are marked as part of the Thread-Safe Functions option.
Issue 7
The flockfile(), ftrylockfile(), and funlockfile() functions are moved from the Thread-Safe Functions
option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0140 [118] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0116 [611] is applied.
Issue 8
Austin Group Defect 1118 is applied, clarifying that a FILE lock is not a file lock.
Austin Group Defect 1302 is applied, replacing parts of the text with a reference to 2.5 Standard I/O Streams.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getlogin_r.html =====
getlogin
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getlogin, getlogin_r — get login name
SYNOPSIS
#include
char *getlogin(void);
int getlogin_r(char *name, size_t namesize);
DESCRIPTION
The getlogin() function shall return a pointer to a string containing the user name associated by the login activity with
the controlling terminal of the current process. If getlogin() returns a non-null pointer, then that pointer points to the
name that the user logged in under, even if there are several login names with the same user ID.
The getlogin() function need not be thread-safe.
The getlogin_r() function shall put the name associated by the login activity with the controlling terminal of the
current process in the character array pointed to by name. The array is namesize characters long and should have
space for the name and the terminating null character. The maximum size of the login name is {LOGIN_NAME_MAX}.
If getlogin_r() is successful, name points to the name the user used at login, even if there are several login
names with the same user ID.
The getlogin() and getlogin_r() functions may make use of file descriptors 0, 1, and 2 to find the controlling
terminal of the current process, examining each in turn until the terminal is found. If in this case none of these three file
descriptors is open to the controlling terminal, these functions may fail. The method used to find the terminal associated with a
file descriptor may depend on the file descriptor being open to the actual terminal device, not /dev/tty.
RETURN VALUE
Upon successful completion, getlogin() shall return a pointer to the login name or a null pointer if the user's login
name cannot be found. Otherwise, it shall return a null pointer and set errno to indicate the error.
The application shall not modify the string returned. The returned pointer might be invalidated or the string content might be
overwritten by a subsequent call to getlogin(). The returned pointer and the string content might also be invalidated if the
calling thread is terminated.
If successful, the getlogin_r() function shall return zero; otherwise, an error number shall be returned to indicate the
error.
ERRORS
These functions may fail if:
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum allowable number of files is currently open in the system.
[ENOTTY]
None of the file descriptors 0, 1, or 2 is open to the controlling terminal of the current process.
[ENXIO]
The calling process has no controlling terminal.
The getlogin_r() function shall fail if:
[ERANGE]
The value of namesize is smaller than the length of the string to be returned including the terminating null
character.
The following sections are informative.
EXAMPLES
Getting the User Login Name
The following example calls the getlogin() function to obtain the name of the user associated with the calling process,
and passes this information to the getpwnam() function to get the associated user
database information.
#include
#include
#include
#include
...
char *lgn;
struct passwd *pw;
...
if ((lgn = getlogin()) == NULL || (pw = getpwnam(lgn)) == NULL) {
fprintf(stderr, "Get of user information failed.\n"); exit(1);
}
APPLICATION USAGE
Three names associated with the current process can be determined: getpwuid(geteuid()) shall return the name associated with the effective user ID of the process;
getlogin() shall return the name associated with the current login activity; and getpwuid(getuid()) shall return the name associated with the real user ID of the process.
The getlogin_r() function is thread-safe and returns values in a user-supplied buffer instead of possibly using a static
data area that may be overwritten by each call.
RATIONALE
The getlogin() function returns a pointer to the user's login name. The same user ID may be shared by several login
names. If it is desired to get the user database entry that is used during login, the result of getlogin() should be used to
provide the argument to the getpwnam() function. (This might be used to determine
the user's login shell, particularly where a single user has multiple login shells with distinct login names, but the same user
ID.)
The information provided by the cuserid() function, which was originally defined in the POSIX.1-1988 standard and
subsequently removed, can be obtained by the following:
getpwuid(geteuid())
while the information provided by historical implementations of cuserid() can be obtained by:
getpwuid(getuid())
The thread-safe version of this function places the user name in a user-supplied buffer and returns a non-zero value if it
fails. The non-thread-safe version may return the name in a static data area that may be overwritten by each call.
FUTURE DIRECTIONS
None.
SEE ALSO
getpwnam(), getpwuid(),
geteuid(), getuid()
XBD ,
CHANGE HISTORY
First released in Issue 1. Derived from System V Release 2.0.
Issue 5
Normative text previously in the APPLICATION USAGE section is moved to the RETURN VALUE section.
The getlogin_r() function is included for alignment with the POSIX Threads Extension.
A note indicating that the getlogin() function need not be reentrant is added to the DESCRIPTION.
Issue 6
The getlogin_r() function is marked as part of the Thread-Safe Functions option.
In the DESCRIPTION, the note about reentrancy is expanded to cover thread-safety.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the RETURN VALUE section, the requirement to set errno on error is added.
The [EMFILE], [ENFILE], and [ENXIO] optional error conditions are added.
The APPLICATION USAGE section is updated to include a note on the thread-safe function and its avoidance of possibly using a
static data area.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
SD5-XBD-ERN-4 is applied, changing the definition of the [EMFILE] error.
The getlogin_r() function is moved from the Thread-Safe Functions option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0243 [172], XSH/TC1-2008/0244 [75], and XSH/TC1-2008/0245 [172] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0168 [656] is applied.
Issue 8
Austin Group Defect 398 is applied, changing the [ERANGE] error from "may fail" to "shall fail".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/truncate.html =====
truncate
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
truncate — truncate a file to a specified length
SYNOPSIS
#include
int truncate(const char *path, off_t length);
DESCRIPTION
The truncate() function shall cause the regular file named by path to have a size which shall be equal to
length bytes.
If the file previously was larger than length, the extra data is discarded. If the file was previously shorter than
length, its size is increased, and the extended area appears as if it were zero-filled.
The application shall ensure that the process has write permission for the file.
If the request would cause the file size to exceed the soft file size limit for the process, the request shall fail
[XSI]
and the implementation shall generate a SIGXFSZ signal for the thread.
The truncate() function shall not modify the file offset for any open file descriptions associated with the file. Upon
successful completion, truncate() shall mark for update the last data modification and last file status change timestamps of
the file, and the S_ISUID and S_ISGID bits of the file mode may be cleared.
RETURN VALUE
Upon successful completion, truncate() shall return 0. Otherwise, -1 shall be returned, and errno set to indicate
the error.
ERRORS
The truncate() function shall fail if:
[EACCES]
A component of the path prefix denies search permission, or write permission is denied on the file.
[EFBIG] or [EINVAL]
The length argument is greater than the maximum file size.
[EFBIG]
The length argument exceeds the file size limit of the process. [XSI]   A SIGFSZ
signal shall also be generated for the thread.
[EINTR]
A signal was caught during execution.
[EINVAL]
The length argument is less than 0 or the path argument refers to a file, other than a directory, on which this
operation is not possible (for example, a FIFO or socket).
[EIO]
An I/O error occurred while reading from or writing to a file system.
[EISDIR]
The named file is a directory.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of path does not name an existing file or path is an empty string.
[ENOTDIR]
A component of the path prefix names an existing file that is neither a directory nor a symbolic link to a directory, or the
path argument contains at least one non- character and ends with one or more trailing  characters
and the last pathname component names an existing file that is neither a directory nor a symbolic link to a directory.
[EROFS]
The named file resides on a read-only file system.
The truncate() function may fail if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
open()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Large File Summit extensions are added.
Issue 6
This reference page is split out from the ftruncate() reference page.
The normative text is updated to avoid use of the term "must" for application requirements.
The wording of the mandatory [ELOOP] error condition is updated, and a second optional [ELOOP] error condition is added.
Issue 7
Austin Group Interpretation 1003.1-2001 #143 is applied.
The truncate() function is moved from the XSI option to the Base.
Changes are made related to support for finegrained timestamps.
The [ENOTDIR] error condition is clarified to cover the condition where the last component of a pathname exists but is not a
directory or a symbolic link to a directory.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0685 [324] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0375 [489] is applied.
Issue 8
Austin Group Defects 308 and 1087 are applied, clarifying the handling of [EFBIG] errors.
Austin Group Defect 1381 is applied, adding a second condition to the [EINVAL] error and rearranging the ERRORS section into
alphabetical order.
Austin Group Defect 1669 is applied, removing XSI shading from part of the [EFBIG] error relating to the file size limit for the
process.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/optopt.html =====
getopt
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getopt, optarg, opterr, optind, optopt — command option parsing
SYNOPSIS
#include
int getopt(int argc, char * const argv[], const char *optstring);
extern char *optarg;
extern int opterr, optind, optopt;
DESCRIPTION
The getopt() function is a command-line parser that shall follow Utility Syntax Guidelines 3, 4, 5, 6, 7, 9, and 10 in
XBD 12.2 Utility Syntax Guidelines.
The parameters argc and argv are the argument count and argument array as passed to main() (see exec()). The argument optstring is a string of recognized option characters; if a
character is followed by a , the option takes an argument. All option characters allowed by Utility Syntax Guideline 3
are allowed in optstring. The optstring argument can optionally start with a  ('+'), which
shall have no effect on behavior in a conforming environment. If a  occurs anywhere besides the first character of
optstring, the behavior is unspecified. The implementation may accept other characters as an extension.
The variable optind is the index of the next element of the argv[] vector to be processed. It shall be initialized
to 1 by the system, and getopt() shall update it when it finishes with each element of argv[]. If the application
sets optind to zero before calling getopt(), the behavior is unspecified. When an element of argv[] contains
multiple option characters, it is unspecified how getopt() determines which options have already been processed.
The getopt() function shall return the next option character (if one is found) from argv that matches a character
in optstring (excluding an optional leading ), if there is one that matches. If the option takes an
argument, getopt() shall set the variable optarg to point to the option-argument as follows:
If the option was the last character in the string pointed to by an element of argv, then optarg shall contain the
next element of argv, and optind shall be incremented by 2. If the resulting value of optind is greater than
argc, this indicates a missing option-argument, and getopt() shall return an error indication.
Otherwise, optarg shall point to the string following the option character in that element of argv, and
optind shall be incremented by 1.
If, when getopt() is called, any of the following is true:
argv[optind]  is a null pointer
*argv[optind]  is not the character '-'
argv[optind]  points to the string "-"
getopt() shall return -1 without changing optind. If:
argv[optind]   points to the string "--"
getopt() shall return -1 after incrementing optind.
If getopt() encounters a  as an option character, or an option character that is not contained in
optstring after an optional leading , it shall return the  ('?') character.
If it detects a missing option-argument, it shall return the  character (':') if the first character of
optstring after an optional  was a , or a  character ('?')
otherwise. In either case, getopt() shall set the variable optopt to the option character that caused the error. If
the application has not set the variable opterr to 0, and the first character of optstring after an optional
is not a , getopt() shall also print a diagnostic message to stderr in the format
specified for the getopts utility, unless the stderr stream has wide
orientation, in which case the behavior is undefined.
The getopt() function need not be thread-safe.
RETURN VALUE
The getopt() function shall return the next option character specified on the command line.
A  (':') shall be returned if getopt() detects a missing argument and the first character of
optstring after an optional  was a  (':').
A  ('?') shall be returned if getopt() encounters a  as an option character,
encounters an option character not in optstring, or detects a missing argument and the first character of optstring
after an optional  was not a  (':').
Otherwise, getopt() shall return -1 when all command line options are parsed.
ERRORS
If the application has not set the variable opterr to 0, the first character of optstring is not a ,
and a write error occurs while getopt() is printing a diagnostic message to stderr, then the error indicator for
stderr shall be set; but getopt() shall still succeed and the value of errno after getopt() is
unspecified.
The following sections are informative.
EXAMPLES
Parsing Command Line Options
The following code fragment shows how you might process the arguments for a utility that can take the mutually-exclusive options
a and b and the options f and o, both of which require arguments:
#include
#include
#include
int
main(int argc, char *argv[ ])
{
int c;
int bflg = 0, aflg = 0, errflg = 0;
char *ifile;
char *ofile;
. . .
while ((c = getopt(argc, argv, ":abf:o:")) != -1) {
switch(c) {
case 'a':
if (bflg)
errflg++;
else
aflg++;
break;
case 'b':
if (aflg)
errflg++;
else
bflg++;
break;
case 'f':
ifile = optarg;
break;
case 'o':
ofile = optarg;
break;
case ':':       /* -f or -o without operand */
fprintf(stderr,
"Option -%c requires an operand\n", optopt);
errflg++;
break;
case '?':
fprintf(stderr,
"Unrecognized option: '-%c'\n", optopt);
errflg++;
}
}
if (errflg) {
fprintf(stderr, "usage: . . . ");
exit(2);
}
for ( ; optind
#include
...
const char *Options = "hdbtl";
...
int dbtype, c;
char *st;
...
dbtype = 0;
while ((c = getopt(argc, argv, Options)) != -1) {
if ((st = strchr(Options, c)) != NULL) {
dbtype = st - Options;
break;
}
}
APPLICATION USAGE
The getopt() function is only required to support option characters included in Utility Syntax Guideline 3. Many
historical implementations of getopt() support other characters as options. This is an allowed extension, but applications
that use extensions are not maximally portable. Note that support for multi-byte option characters is only possible when such
characters can be represented as type int.
Applications which use wide-character output functions with stderr should ensure that any calls to getopt() do not
write to stderr, either by setting opterr to 0 or by ensuring the first character of optstring is always a
.
While ferror(stderr) may be used to detect failures to write a diagnostic to stderr when getopt()
returns '?', the value of errno is unspecified in such a condition. Applications desiring more control over
handling write failures should set opterr to 0 and independently perform output to stderr, rather than relying on
getopt() to do the output.
RATIONALE
The optopt variable represents historical practice and allows the application to obtain the identity of the invalid
option.
The description has been written to make it clear that getopt(), like the getopts utility, deals with option-arguments whether separated from the option by
characters or not. Note that the requirements on getopt() and getopts are more stringent than the Utility Syntax Guidelines.
The getopt() function shall return -1, rather than EOF, so that  is not required.
The special significance of a  as the first character of optstring makes getopt() consistent with the
getopts utility. It allows an application to make a distinction between a missing
argument and an incorrect option letter without having to examine the option letter. It is true that a missing argument can only be
detected in one case, but that is a case that has to be considered.
In some non-conforming environments, the use of a leading  in optstring forces getopt() to behave
in a conforming way, when it would otherwise have non-conforming behavior. Its use has been standardized to allow applications to
be written that can guarantee behavior consistent with this specification even in an otherwise non-conforming environment. If both
and  are used at the beginning of optstring, the  must be first.
Note that the use of a leading  in optstring is only standardized for getopt(). Use of a
is intentionally left unspecified for the getopts utility, where
historical implementations did not require a leading  for conforming behavior, and because some historical
getopts implementations used a leading  for a different
extension.
FUTURE DIRECTIONS
None.
SEE ALSO
exec
XBD 12.2 Utility Syntax Guidelines,
XCU getopts
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
A note indicating that the getopt() function need not be reentrant is added to the DESCRIPTION.
Issue 6
IEEE PASC Interpretation 1003.2 #150 is applied.
Austin Group Interpretation 1003.1-2001 #156 is applied.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0248 [318], XSH/TC1-2008/0249 [460], XSH/TC1-2008/0250 [189],
XSH/TC1-2008/0251 [189], XSH/TC1-2008/0252 [189], and XSH/TC1-2008/0253 [460] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0169 [608] is applied.
Issue 8
Austin Group Defect 191 is applied, allowing a leading  in optstring.
Austin Group Defect 1179 is applied, adding some missing '}' characters at the end of the example code.
Austin Group Defect 1523 is applied, clarifying the conditions under which getopt() returns -1 without changing
optind.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/iswalpha_l.html =====
iswalpha
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
iswalpha, iswalpha_l — test for an alphabetic wide-character code
SYNOPSIS
#include
int iswalpha(wint_t wc);
[CX]  int iswalpha_l(wint_t wc, locale_t locale);
DESCRIPTION
For iswalpha(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The iswalpha() [CX]   and iswalpha_l()
functions shall test whether wc is a wide-character code representing a character of class alpha in the current
locale, [CX]   or in the locale represented by locale,
respectively; see XBD 7. Locale.
The wc argument is a wint_t, the value of which the application shall ensure is a wide-character code
corresponding to a valid character in the locale used by the function, or equal to the value of the macro WEOF. If the argument has
any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to iswalpha_l() is the special locale object LC_GLOBAL_LOCALE or is not
a valid locale object handle.
RETURN VALUE
The iswalpha() [CX]   and iswalpha_l()
functions shall return non-zero if wc is an alphabetic wide-character code; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
iswalnum(), iswcntrl(),
iswctype(), iswdigit(),
iswgraph(), iswlower(),
iswprint(), iswpunct(),
iswspace(), iswupper(),
iswxdigit(), setlocale(),
uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 4.
Issue 5
The following change has been made in this version for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E):
The SYNOPSIS has been changed to indicate that this function and associated data types are now made visible by inclusion of the
header rather than .
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The iswalpha_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0312 [302], XSH/TC1-2008/0313 [283], and XSH/TC1-2008/0314 [283] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0181 [685] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/islessgreater.html =====
isgreater
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
isgreater, isgreaterequal, isless, islessequal, islessgreater — real-floating relational tests
SYNOPSIS
#include
int isgreater(real-floating x, real-floating y);
int isgreaterequal(real-floating x, real-floating y);
int isless(real-floating x, real-floating y);
int islessequal(real-floating x, real-floating y);
int islessgreater(real-floating x, real-floating y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The isgreater() macro shall determine whether its first argument is greater than its second argument. The value of
isgreater(x, y) shall be equal to (x) > (y); however, unlike
(x) > (y), isgreater(x, y) shall not raise the invalid floating-point exception
when x and y are unordered.
The isgreaterequal() macro shall determine whether its first argument is greater than or equal to its second argument.
The value of isgreaterequal(x, y) shall be equal to (x) >= (y); however, unlike
(x) >= (y), isgreaterequal(x, y) shall not raise the invalid floating-point
exception when x and y are unordered.
The isless() macro shall determine whether its first argument is less than its second argument. The value of
isless(x, y) shall be equal to (x)  (y); however, islessgreater(x,
y) shall not raise the invalid floating-point exception when x and y are unordered (nor shall it evaluate
x and y twice).
[MX]
Relational operators and their corresponding comparison macros shall produce equivalent result values, even if argument values are
represented in wider formats. Thus, comparison macro arguments represented in formats wider than their semantic types shall not be
converted to the semantic types, unless the wide evaluation method converts operands of relational operators to their semantic
types. The standard wide evaluation methods characterized by FLT_EVAL_METHOD equal to 1 or 2 (see ) do not convert operands of relational operators to their semantic types.
RETURN VALUE
Upon successful completion, the isgreater() macro shall return the value of (x) > (y).
Upon successful completion, the isgreaterequal() macro shall return the value of
(x) >= (y).
Upon successful completion, the isless() macro shall return the value of (x)  (y).
If x or y is NaN, these functions shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The relational and equality operators support the usual mathematical relationships between numeric values. For any ordered pair
of numeric values, exactly one of the relationships (less, greater, and equal) is true. Relational operators may raise the invalid
floating-point exception when argument values are NaNs. For a NaN and a numeric value, or for two NaNs, just the unordered
relationship is true. This macro is a quiet (non-floating-point exception raising) version of a relational operator. It facilitates
writing efficient code that accounts for NaNs without suffering the invalid floating-point exception. In the SYNOPSIS section,
real-floating indicates that the argument shall be an expression of real-floating type.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
isunordered()
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
The individual pages for these functions have been merged to form a single page, to reduce duplication.
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/dcngettext.html =====
gettext
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
dgettext, dgettext_l, dcgettext, dcgettext_l, gettext, gettext_l, ngettext, ngettext_l, dngettext, dngettext_l,
dcngettext, dcngettext_l — message handling functions
SYNOPSIS
#include
char *dgettext(const char *domainname, const char *msgid);
char *dgettext_l(const char *domainname, const char *msgid,
locale_t locale);
char *dcgettext(const char *domainname, const char *msgid,
int category);
char *dcgettext_l(const char *domainname, const char *msgid,
int category, locale_t locale);
char *dngettext(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n);
char *dngettext_l(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n,
locale_t locale);
char *dcngettext(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n,
int category);
char *dcngettext_l(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n,
int category, locale_t locale);
char *gettext(const char *msgid);
char *gettext_l(const char *msgid, locale_t locale);
char *ngettext(const char *msgid, const char *msgid_plural,
unsigned long int n);
char *ngettext_l(const char *msgid, const char *msgid_plural,
unsigned long int n, locale_t locale);
DESCRIPTION
The gettext() function shall:
attempt to locate a suitable messages object (described in detail below) for the LC_MESSAGES category in the current
locale, and for the current text domain (see bindtextdomain()), containing
the string identified by msgid,
retrieve the string identified by msgid from the messages object,
convert the string to the output codeset if necessary (described in detail below), and
return the result.
If the locale name in effect is "POSIX" or "C" (i.e. the name associated with the LC_MESSAGES locale
category in the current locale), or if no suitable messages object exists, or if no string identified by msgid exists in the
messages object, or if an error occurs, msgid shall be returned.
The dgettext() function shall be equivalent to gettext(), except domainname shall be used instead of the
current text domain to locate the messages object.
The dcgettext() function shall be equivalent to dgettext(), except the locale category identified by
category shall be used instead of LC_MESSAGES .
The ngettext() function shall be equivalent to gettext(), except:
The string to retrieve shall be identified by a combination of msgid and n (see msgfmt).
If the locale name in effect is "POSIX" or "C", or if no suitable messages object exists, or if no string
identified by the combination of msgid and n exists in the messages object, or if an error occurs, the return value
shall be msgid if n is 1, otherwise msgid_plural.
The dngettext() function shall be equivalent to ngettext(), except domainname shall be used instead of the
current text domain to locate the messages object.
The dcngettext() function shall be equivalent to dngettext(), except the locale category identified by
category shall be used instead of LC_MESSAGES .
The *_l() functions shall be equivalent to their counterparts without the _l suffix, except locale shall be
used instead of the current locale. If locale is the special locale object LC_GLOBAL_LOCALE or is not a valid locale object
handle, the behavior is undefined.
The application shall ensure that the msgid and msgid_plural arguments are strings. If either msgid or
msgid_plural is an empty string, or contains characters not in the portable character set, the results are unspecified. If
the category argument is LC_ALL , the results are unspecified.
The location of the messages object shall be determined according to the following criteria, stopping when the first messages
object is found:
[XSI]
If the NLSPATH environment variable is set to a non-empty string, an NLSPATH search shall be performed as described
in XBD 8.2 Internationalization Variables. If NLSPATH identifies
more than one template to use, each template in turn shall be used until a valid messages object is found.
If the LANGUAGE environment variable is set to a non-empty string, a LANGUAGE search shall be performed as
described below. If LANGUAGE identifies more than one directory to search, each directory shall be searched until a valid
messages object is found.
A single-locale search shall be performed as described below.
For [XSI]   the NLSPATH search and   the single-locale search,
the single locale name used to locate the messages object shall be the locale name associated with the selected locale category
from the current locale, or the provided locale object if calling one of the *_l() functions; additional searches of locale
names without .codeset (if present), without _territory (if present), and without @modifier (if present) may
be performed.
For the LANGUAGE search, the value of the LANGUAGE environment variable shall be a list of one or more locale
names separated by a  (':') character. Each locale name shall be tried in the specified order. If a messages
object for the locale does not exist, or cannot be opened, or is unsuitable for implementation-defined reasons (such as security),
the next locale name (if any) shall be tried. If:
a messages object for the locale can be opened but cannot be processed without error, or
the messages object does not contain a string identified by msgid, or msgid and n for the ngettext
functions,
it is unspecified whether the next locale name (if any) is tried. In all other cases, the messages object for the locale shall
be used.
For each locale name in LANGUAGE , or if LANGUAGE is not set or is empty, or no suitable messages object is found
in processing LANGUAGE , the pathname used to locate the messages object shall be
dirname/localename/categoryname/textdomainname.mo, where:
The dirname part is the dirname argument of the most recent successful call to bindtextdomain() that had textdomainname as the domainname argument;
any trailing  characters in dirname shall be discarded. If a successful call to bindtextdomain() has not been made for textdomainname, an
implementation-defined default directory shall be used.
For the LANGUAGE search, the localename part is each locale name from LANGUAGE in turn; if a locale name
has the format language[_territory][.codeset][@modifier], additional
searches of locale names without .codeset (if present), without _territory (if present), and without @modifier
(if present) may be performed; if .codeset is not present, additional searches of locale names with an added .codeset
may be performed. For the single-locale search, the localename part is the name of the current locale, or the locale
specified in an *_l() function call, for the category named by categoryname. Spellings of codeset names are not
standardized, and implementations may attempt to use different commonly known spellings, for example "utf8" and
"UTF-8".
The categoryname part is the string "LC_MESSAGES" if gettext(), dgettext(), ngettext(), or
dngettext() is called, or the locale category name corresponding to the category argument to dcgettext() or
dcngettext(). Likewise for the *_l() variants of all these functions.
For gettext(), gettext_l(), ngettext(), and ngettext_l(), the textdomainname part is the text
domain set by the last successful call to textdomain(). For dgettext(),
dcgettext(), dngettext(), dcngettext(), and the *_l() variants of these functions,
textdomainname is the text domain specified by the domainname argument. The domainname argument shall be
equivalent in syntax and meaning to the domainname argument to textdomain(), except that the selection of the text domain shall affect only the
dgettext(), dcgettext(), dngettext(), and dcngettext() function calls and their *_l() variants.
If the domainname argument is a null pointer, the text domain set by the last successful call to textdomain() shall be used. For all of these functions, if a successful call to textdomain() has not been made the default text domain "messages" shall be
used.
Resolution of the messages object pathname shall be performed the first time one of the gettext family of functions is
called for a given combination of dirname, localename, categoryname, and textdomainname. It is
unspecified whether the pathname is re-resolved if the combination has been used before in a call to one of the gettext
family of functions. If bindtextdomain() performs pathname resolution of its
dirname argument, only the part of the messages object pathname after dirname shall be resolved by the gettext
family of functions.
When one of the gettext family of functions returns a message string that was found in a messages object, it shall
convert the codeset of the message string to the output codeset if a codeset is specified in the messages object (see msgfmt) and the output codeset is not the same as that codeset. If a successful call to
bind_textdomain_codeset() has been made with the text domain of the
messages object as the domainname argument and a non-null codeset argument, the output codeset shall be the
codeset argument from the most recent such call. Otherwise, the output codeset shall be the codeset of characters in the
current locale, or the provided locale object if calling one of the *_l() functions, as specified by the LC_CTYPE
category of the locale. The conversion shall be performed as if by a call to iconv()
using a conversion descriptor returned by iconv_open(, ),
except that if the return value of iconv() would be greater than zero, the
non-identical conversions performed by the gettext family of functions need not be the same as those that such an iconv() call would perform. If an error prevents the codeset conversion from being performed,
the gettext family of functions shall behave as if no message string was found in the messages object. If at least one
non-identical conversion is performed that results in a fallback character (one that does not provide any information about the
character it was converted from, for example, a  or "replacement-character"), the gettext family of
functions may behave as if no message string was found in the messages object.
RETURN VALUE
The gettext(), gettext_l(), dgettext(), dgettext_l(), dcgettext(), and dcgettext_l()
functions shall return the message string described in DESCRIPTION if successful. Otherwise, they shall return msgid.
The ngettext(), ngettext_l(), dngettext(), dngettext_l(), dcngettext(), and
dcngettext_l() functions shall return the message string described in DESCRIPTION if successful. Otherwise, msgid
shall be returned if n is equal to 1, or msgid_plural if n is not equal to 1.
The application shall ensure that it does not modify the returned string. A subsequent call to a gettext family function
shall not overwrite or invalidate the returned string. The returned string may be invalidated by a subsequent call to bind_textdomain_codeset(), bindtextdomain(), setlocale(), or
textdomain() in the same process, except for calls that only query values. The
returned string shall not be invalidated by a subsequent call to uselocale().
ERRORS
The gettext family of functions shall not modify errno. If an error occurs these functions shall return a string
as described in RETURN VALUE.
The following sections are informative.
EXAMPLES
The example code below assumes the following:
The implementation-defined default directory is /system/gettextlib.
The following locales are available on the target system: en_US, en_GB, de_DE. The codeset used for all of these locales is
UTF-8.
The en_AU locale is not available on the target system.
The target system supports conversion from ISO/IEC 8859-1 to UTF-8.
The codeset used for the POSIX locale is ASCII.
The target system does not support conversion from ISO/IEC 8859-1 to ASCII.
Furthermore, the following .mo files (and only the following .mo files) are installed:
/system/gettextlib/en_US/LC_MESSAGES/mail.mo
/messagecatalogs/example/en_US/LC_MESSAGES/mail.mo
These are compiled from a portable messages object source file (dot-po file) with the following ISO/IEC 8859-1 encoded contents
(see the EXTENDED DESCRIPTION of the msgfmt utility for a description of the dot-po
file format):
msgid ""
msgstr ""
"Content-Type: text/plain; charset=ISO_8859-1\n"
"Plural-Forms: nplurals=4; plural= n==1?0: (n>1&&n1&&n1&&n,
XCU gettext, msgfmt,
xgettext
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_rwlockattr_getpshared.html =====
pthread_rwlockattr_getpshared
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_rwlockattr_getpshared, pthread_rwlockattr_setpshared — get and set the process-shared attribute of the
read-write lock attributes object
SYNOPSIS
[TSH]  #include
int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t
*restrict attr, int *restrict pshared);
int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *attr,
int pshared);
DESCRIPTION
The pthread_rwlockattr_getpshared() function shall obtain the value of the process-shared attribute from the
initialized attributes object referenced by attr. The pthread_rwlockattr_setpshared() function shall set the
process-shared attribute in an initialized attributes object referenced by attr.
The process-shared attribute shall be set to PTHREAD_PROCESS_SHARED to permit a read-write lock to be operated upon by
any thread that has access to the memory where the read-write lock is allocated, even if the read-write lock is allocated in memory
that is shared by multiple processes. See 2.9.9 Synchronization Object Copies
and Alternative Mappings for further requirements. The default value of the process-shared attribute shall be
PTHREAD_PROCESS_PRIVATE.
Additional attributes, their default values, and the names of the associated functions to get and set those attribute values are
implementation-defined.
The behavior is undefined if the value specified by the attr argument to pthread_rwlockattr_getpshared() or
pthread_rwlockattr_setpshared() does not refer to an initialized read-write lock attributes object.
RETURN VALUE
Upon successful completion, the pthread_rwlockattr_getpshared() function shall return zero and store the value of the
process-shared attribute of attr into the object referenced by the pshared parameter. Otherwise, an error
number shall be returned to indicate the error.
If successful, the pthread_rwlockattr_setpshared() function shall return zero; otherwise, an error number shall be
returned to indicate the error.
ERRORS
The pthread_rwlockattr_setpshared() function may fail if:
[EINVAL]
The new value specified for the attribute is outside the range of legal values for that attribute.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_rwlock_destroy(), pthread_rwlockattr_destroy()
XBD
CHANGE HISTORY
First released in Issue 5.
Issue 6
The following changes are made for alignment with IEEE Std 1003.1j-2000:
The margin code in the SYNOPSIS is changed to THR TSH to indicate that the functionality is now part of the Threads option
(previously it was part of the Read-Write Locks option in IEEE Std 1003.1j-2000 and also part of the XSI extension).
The DESCRIPTION notes that additional attributes are implementation-defined.
The SEE ALSO section is updated.
The restrict keyword is added to the pthread_rwlockattr_getpshared() prototype for alignment with the
ISO/IEC 9899:1999 standard.
Issue 7
The pthread_rwlockattr_getpshared() and pthread_rwlockattr_setpshared() functions are marked only as part of the
Thread Process-Shared Synchronization option as the Threads option is now part of the Base.
The [EINVAL] error for an uninitialized read-write lock attributes object is removed; this condition results in undefined
behavior.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0292 [972] and XSH/TC2-2008/0293 [757] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/tanhl.html =====
tanh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
tanh, tanhf, tanhl — hyperbolic tangent functions
SYNOPSIS
#include
double tanh(double x);
float tanhf(float x);
long double tanhl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the hyperbolic tangent of their argument x.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the hyperbolic tangent of x.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, x shall be returned.
If x is ±Inf, ±1 shall be returned.
[MXX]
If x is subnormal, x should be returned.
[MX]  If x is subnormal, a range error may occur and, if x is
not returned, tanh(), tanhf(), and tanhl() shall return an implementation-defined value no greater in
magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
ERRORS
These functions may fail if:
Range Error
[MX]
The value of x is subnormal.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
atanh(), feclearexcept(),
fetestexcept(), isnan(),
tan()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The tanhf() and tanhl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0638 [68] is applied.
Issue 8
Austin Group Defect 1382 is applied, rearranging the text describing the behavior when x is subnormal to avoid the need
for two shading changes.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getgid.html =====
getgid
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getgid — get the real group ID
SYNOPSIS
#include
gid_t getgid(void);
DESCRIPTION
The getgid() function shall return the real group ID of the calling process. The getgid() function shall not
modify errno.
RETURN VALUE
The getgid() function shall always be successful and no return value is reserved to indicate an error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
In a conforming environment, getgid() will always succeed. It is possible for implementations to provide an extension
where a process in a non-conforming environment will not be associated with a user or group ID. It is recommended that such
implementations return (gid_t)-1 and set errno to indicate such an environment; doing so does not violate this
standard, since such an environment is already an extension.
FUTURE DIRECTIONS
None.
SEE ALSO
getegid(), geteuid(), getresgid(), getresuid(), getuid(), setegid(), seteuid(), setgid(), setregid(), setresgid(), setresuid(), setreuid(), setuid()
XBD ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
In the SYNOPSIS, the optional include of the  header is
removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
Issue 7
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0159 [511] is applied.
Issue 8
Austin Group Defect 1344 is applied, adding getresgid(), getresuid(), setresgid(), and setresuid() to SEE ALSO.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atomic_init.html =====
atomic_init
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atomic_init — initialize an atomic object
SYNOPSIS
#include
void atomic_init(volatile A *obj, C value);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
Implementations that define the macro __STDC_NO_ATOMICS__ need not provide the  header nor support these generic functions.
The atomic_init() generic function shall initialize the atomic object pointed to by obj to the value value,
while also initializing any additional state that the implementation might need to carry for the atomic object.
Although this function initializes an atomic object, it does not avoid data races; concurrent access to the variable being
initialized, even via an atomic operation, constitutes a data race.
RETURN VALUE
The atomic_init() generic function shall not return a value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
atomic_int guide;
atomic_init(&guide, 42);
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/recvmsg.html =====
recvmsg
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
recvmsg — receive a message from a socket
SYNOPSIS
#include
ssize_t recvmsg(int socket, struct msghdr *message, int flags);
DESCRIPTION
The recvmsg() function shall receive a message from a connection-mode or connectionless-mode socket. It is normally used
with connectionless-mode sockets because it permits the application to retrieve the source address of received data.
The recvmsg() function takes the following arguments:
socket
Specifies the socket file descriptor.
message
Points to a msghdr structure, containing both the buffer to store the source address and the buffers for the incoming
message. The length and format of the address depend on the address family of the socket. The msg_flags member is ignored on
input, but may contain meaningful values on output.
flags
Specifies the type of message reception. Values of this argument are formed by logically OR'ing zero or more of the following
values:
MSG_OOB
Requests out-of-band data. The significance and semantics of out-of-band data are protocol-specific.
MSG_PEEK
Peeks at the incoming message.
MSG_WAITALL
On SOCK_STREAM sockets this requests that the function block until the full amount of data can be returned. The function may
return the smaller amount of data if the socket is a message-based socket, if a signal is caught, if the connection is terminated,
if MSG_PEEK was specified, or if an error is pending for the socket.
MSG_CMSG_CLOEXEC
On sockets that permit a cmsg_type of SCM_RIGHTS in the msg_control ancillary data as a means of copying file
descriptors into the process, the file descriptors shall be created with the FD_CLOEXEC flag atomically set.
MSG_CMSG_CLOFORK
On sockets that permit a cmsg_type of SCM_RIGHTS in the msg_control ancillary data as a means of copying file
descriptors into the process, the file descriptors shall be created with the FD_CLOFORK flag atomically set.
The recvmsg() function shall receive messages from unconnected or connected sockets and shall return the length of the
message.
The recvmsg() function shall return the total length of the message. For message-based sockets, such as SOCK_DGRAM and
SOCK_SEQPACKET, the entire message shall be read in a single operation. If a message is too long to fit in the supplied buffers,
and MSG_PEEK is not set in the flags argument, the excess bytes shall be discarded, and MSG_TRUNC shall be set in the
msg_flags member of the msghdr structure. For stream-based sockets, such as SOCK_STREAM, message boundaries shall be
ignored. In this case, data shall be returned to the user as soon as it becomes available, and no data shall be discarded.
If the MSG_WAITALL flag is not set, data shall be returned only up to the end of the first message.
If no messages are available at the socket and O_NONBLOCK is not set on the socket's file descriptor, recvmsg() shall
block until a message arrives or a timeout occurs (see SO_RCVTIMEO in 2.10.16
Use of Options). If no messages are available at the socket and O_NONBLOCK is set on the socket's file descriptor, the
recvmsg() function shall fail and set errno to [EAGAIN] or [EWOULDBLOCK].
In the msghdr structure, the msg_name member may be a null pointer if the source address is not required.
Otherwise, if the socket is unconnected, the msg_name member points to a sockaddr structure in which the source
address is to be stored, and the msg_namelen member on input specifies the length of the supplied sockaddr structure
and on output specifies the length of the source address. If the actual length of the address is greater than the length of the
supplied sockaddr structure, the stored address shall be truncated. If the socket is connected, the msg_name and
msg_namelen members shall be ignored. The msg_iov and msg_iovlen fields are used to specify where the received
data shall be stored. The msg_iov member points to an array of iovec structures; the msg_iovlen member shall
be set to the dimension of this array. In each iovec structure, the iov_base field specifies a storage area and the
iov_len field gives its size in bytes. Each storage area indicated by msg_iov is filled with received data in turn
until all of the received data is stored or all of the areas have been filled.
Upon successful completion, the msg_flags member of the message header shall be the bitwise-inclusive OR of all of the
following flags that indicate conditions detected for the received message:
MSG_EOR
End-of-record was received (if supported by the protocol).
MSG_OOB
Out-of-band data was received.
MSG_TRUNC
Normal data was truncated.
MSG_CTRUNC
Control data was truncated.
RETURN VALUE
Upon successful completion, recvmsg() shall return the length of the message in bytes. If no messages are available to be
received and the peer has performed an orderly shutdown, recvmsg() shall return 0. Otherwise, -1 shall be returned and
errno set to indicate the error.
ERRORS
The recvmsg() function shall fail if:
[EAGAIN] or [EWOULDBLOCK]
The socket's file descriptor is marked O_NONBLOCK and no data is waiting to be received; or MSG_OOB is set and no out-of-band data
is available and either the socket's file descriptor is marked O_NONBLOCK or the socket does not support blocking to await
out-of-band data. See also SO_RCVTIMEO in 2.10.16 Use of Options
.
[EBADF]
The socket argument is not a valid open file descriptor.
[ECONNRESET]
A connection was forcibly closed by a peer.
[EINTR]
This function was interrupted by a signal before any data was available.
[EINVAL]
The sum of the iov_len values overflows a ssize_t, or the MSG_OOB flag is set and no out-of-band data is
available.
[EMSGSIZE]
The msg_iovlen member of the msghdr structure pointed to by message is less than or equal to 0, or is
greater than {IOV_MAX}.
[ENOTCONN]
A receive is attempted on a connection-mode socket that is not connected.
[ENOTSOCK]
The socket argument does not refer to a socket.
[EOPNOTSUPP]
The specified flags are not supported for this socket type.
[ETIMEDOUT]
The connection timed out during connection establishment, or due to a transmission timeout on active connection.
The recvmsg() function may fail if:
[EIO]
An I/O error occurred while reading from or writing to the file system.
[ENOBUFS]
Insufficient resources were available in the system to perform the operation.
[ENOMEM]
Insufficient memory was available to fulfill the request.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The select() and poll() functions can
be used to determine when data is available to be received.
RATIONALE
The use of the MSG_CMSG_CLOEXEC and MSG_CMSG_CLOFORK flags to recvmsg() when using SCM_RIGHTS to receive file descriptors
via ancillary data is necessary to avoid a data race in multi-threaded applications. Without MSG_CMSG_CLOFORK, a file descriptor is
leaked into a child process created by one thread in the window between another thread calling recvmsg() and using fcntl() to set the FD_CLOFORK flag. Without MSG_CMSG_CLOEXEC, a file descriptor intentionally
inherited by child processes is similarly leaked into an executed program if FD_CLOEXEC is not set atomically.
FUTURE DIRECTIONS
None.
SEE ALSO
poll(), pselect(), recv(), recvfrom(), send(), sendmsg(), sendto(), setsockopt(), shutdown(), socket()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0504 [464] is applied.
Issue 8
Austin Group Defects 411 and 1318 are applied, adding MSG_CMSG_CLOEXEC and MSG_CMSG_CLOFORK.
Austin Group Defect 1429 is applied, clarifying the behavior on timeout by adding references to 2.10.16 Use of Options.
Austin Group Defect 1565 is applied, changing the description of msg_namelen.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_attr_init.html =====
pthread_attr_destroy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_attr_destroy, pthread_attr_init — destroy and initialize the thread attributes object
SYNOPSIS
#include
int pthread_attr_destroy(pthread_attr_t *attr);
int pthread_attr_init(pthread_attr_t *attr);
DESCRIPTION
The pthread_attr_destroy() function shall destroy a thread attributes object. An implementation may cause
pthread_attr_destroy() to set attr to an implementation-defined invalid value. A destroyed attr attributes
object can be reinitialized using pthread_attr_init(); the results of otherwise referencing the object after it has been
destroyed are undefined.
The pthread_attr_init() function shall initialize a thread attributes object attr with the default value for all
of the individual attributes used by a given implementation.
The resulting attributes object (possibly modified by setting individual attribute values) when used by pthread_create() defines the attributes of the thread created. A single attributes
object can be used in multiple simultaneous calls to pthread_create().
Results are undefined if pthread_attr_init() is called specifying an already initialized attr attributes object.
The behavior is undefined if the value specified by the attr argument to pthread_attr_destroy() does not refer to
an initialized thread attributes object.
RETURN VALUE
Upon successful completion, pthread_attr_destroy() and pthread_attr_init() shall return a value of 0; otherwise,
an error number shall be returned to indicate the error.
ERRORS
The pthread_attr_init() function shall fail if:
[ENOMEM]
Insufficient memory exists to initialize the thread attributes object.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
Attributes objects are provided for threads, mutexes, and condition variables as a mechanism to support probable future
standardization in these areas without requiring that the function itself be changed.
Attributes objects provide clean isolation of the configurable aspects of threads. For example, "stack size" is an important
attribute of a thread, but it cannot be expressed portably. When porting a threaded program, stack sizes often need to be adjusted.
The use of attributes objects can help by allowing the changes to be isolated in a single place, rather than being spread across
every instance of thread creation.
Attributes objects can be used to set up "classes' of threads with similar attributes; for example, "threads with large stacks
and high priority" or "threads with minimal stacks". These classes can be defined in a single place and then referenced wherever
threads need to be created. Changes to "class" decisions become straightforward, and detailed analysis of each pthread_create() call is not required.
The attributes objects are defined as opaque types as an aid to extensibility. If these objects had been specified as
structures, adding new attributes would force recompilation of all multi-threaded programs when the attributes objects are
extended; this might not be possible if different program components were supplied by different vendors.
Additionally, opaque attributes objects present opportunities for improving performance. Argument validity can be checked once
when attributes are set, rather than each time a thread is created. Implementations often need to cache kernel objects that are
expensive to create. Opaque attributes objects provide an efficient mechanism to detect when cached objects become invalid due to
attribute changes.
Since assignment is not necessarily defined on a given opaque type, implementation-defined default values cannot be defined in a
portable way. The solution to this problem is to allow attributes objects to be initialized dynamically by attributes object
initialization functions, so that default values can be supplied automatically by the implementation.
The following proposal was provided as a suggested alternative to the supplied attributes:
Maintain the style of passing a parameter formed by the bitwise-inclusive OR of flags to the initialization routines (pthread_create(), pthread_mutex_init(), pthread_cond_init()). The parameter containing the flags should be an opaque type
for extensibility. If no flags are set in the parameter, then the objects are created with default characteristics. An
implementation may specify implementation-defined flag values and associated behavior.
If further specialization of mutexes and condition variables is necessary, implementations may specify additional procedures
that operate on the pthread_mutex_t and pthread_cond_t objects (instead of on attributes objects).
The difficulties with this solution are:
A bitmask is not opaque if bits have to be set into bitvector attributes objects using explicitly-coded bitwise-inclusive OR
operations. If the set of options exceeds an int, application programmers need to know the location of each bit. If bits are
set or read by encapsulation (that is, get and set functions), then the bitmask is merely an implementation of attributes objects
as currently defined and should not be exposed to the programmer.
Many attributes are not Boolean or very small integral values. For example, scheduling policy may be placed in 3-bit or 4-bit,
but priority requires 5-bit or more, thereby taking up at least 8 bits out of a possible 16 bits on machines with 16-bit integers.
Because of this, the bitmask can only reasonably control whether particular attributes are set or not, and it cannot serve as the
repository of the value itself. The value needs to be specified as a function parameter (which is non-extensible), or by setting a
structure field (which is non-opaque), or by get and set functions (making the bitmask a redundant addition to the attributes
objects).
Stack size is defined as an optional attribute because the very notion of a stack is inherently machine-dependent. Some
implementations may not be able to change the size of the stack, for example, and others may not need to because stack pages may be
discontiguous and can be allocated and released on demand.
The attribute mechanism has been designed in large measure for extensibility. Future extensions to the attribute mechanism or to
any attributes object defined in this volume of POSIX.1-2024 has to be done with care so as not to affect binary-compatibility.
Attributes objects, even if allocated by means of dynamic allocation functions such as malloc(), may have their size fixed at compile time. This means, for example, a pthread_create() in an implementation with extensions to pthread_attr_t cannot
look beyond the area that the binary application assumes is valid. This suggests that implementations should maintain a size field
in the attributes object, as well as possibly version information, if extensions in different directions (possibly by different
vendors) are to be accommodated.
If an implementation detects that the value specified by the attr argument to pthread_attr_destroy() does not
refer to an initialized thread attributes object, it is recommended that the function should fail and report an [EINVAL] error.
If an implementation detects that the value specified by the attr argument to pthread_attr_init() refers to an
already initialized thread attributes object, it is recommended that the function should fail and report an [EBUSY] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_attr_getstacksize(), pthread_attr_getdetachstate(), pthread_create()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_attr_destroy() and pthread_attr_init() functions are marked as part of the Threads option.
IEEE PASC Interpretation 1003.1 #107 is applied, noting that the effect of initializing an already initialized thread attributes
object is undefined.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/71 is applied, updating the ERRORS section to add the optional
[EINVAL] error for the pthread_attr_destroy() function, and the optional [EBUSY] error for the pthread_attr_init()
function.
Issue 7
The pthread_attr_destroy() and pthread_attr_init() functions are moved from the Threads option to the Base.
The [EINVAL] error for an uninitialized thread attributes object is removed; this condition results in undefined behavior.
The [EBUSY] error for an already initialized thread attributes object is removed; this condition results in undefined
behavior.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fnmatch.html =====
fnmatch
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fnmatch — match a filename string or a pathname
SYNOPSIS
#include
int fnmatch(const char *pattern, const char *string, int flags);
DESCRIPTION
The fnmatch() function shall match patterns as described in XCU 2.14.1 Patterns Matching a Single Character and 2.14.2 Patterns Matching Multiple Characters. It checks the string specified
by the string argument to see if it matches the pattern specified by the pattern argument.
The flags argument shall modify the interpretation of pattern and string. It is the bitwise-inclusive OR of
zero or more of the flags defined in . If the FNM_PATHNAME flag is
set in flags, then a  character ('/') in string shall be explicitly matched by a
in pattern; it shall not be matched by either the  or  special characters, nor by a
bracket expression. If the FNM_PATHNAME flag is not set, the  character shall be treated as an ordinary character.
If FNM_NOESCAPE is not set in flags, a  character can be used as an escape character as described in XCU
2.14.1 Patterns Matching a Single Character. If pattern ends
with an unescaped , the behavior is unspecified. If FNM_NOESCAPE is set, a  character shall be
treated as an ordinary character.
If FNM_PERIOD is set in flags, then a leading  ('.') in string shall match a
in pattern; as described by rule 2 in XCU 2.14.3 Patterns Used for
Filename Expansion where the location of "leading" is indicated by the value of FNM_PATHNAME:
If FNM_PATHNAME is set, a  is "leading" if it is the first character in string or if it immediately
follows a .
If FNM_PATHNAME is not set, a  is "leading" only if it is the first character of string.
If FNM_PERIOD is not set, then no special restrictions are placed on matching a period.
If FNM_CASEFOLD or FNM_IGNORECASE is set, string and pattern shall be compared in a case-insensitive manner. See
XBD 4.1 Case Insensitive Comparisons.
RETURN VALUE
If string matches the pattern specified by pattern, then fnmatch() shall return 0. If there is no match,
fnmatch() shall return FNM_NOMATCH, which is defined in .
If an error occurs, fnmatch() shall return another non-zero value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The fnmatch() function has two major uses. It could be used by an application or utility that needs to read a directory
and apply a pattern against each entry. The find utility is an example of this. It can
also be used by the pax utility to process its pattern operands, or by
applications that need to match strings in a similar manner.
The name fnmatch() is intended to imply filename match, rather than pathname match. The default action of
this function is to match filename strings, rather than pathnames, since it gives no special significance to the
character. With the FNM_PATHNAME flag, fnmatch() does match pathnames, but without tilde expansion, parameter expansion, or
special treatment for a  at the beginning of a filename.
RATIONALE
This function replaced the REG_FILENAME flag of regcomp() in early proposals of
this volume of POSIX.1-2024. It provides virtually the same functionality as the regcomp() and regexec() functions using the
REG_FILENAME and REG_FSLASH flags (the REG_FSLASH flag was proposed for regcomp(),
and would have had the opposite effect from FNM_PATHNAME), but with a simpler function and less system overhead.
FUTURE DIRECTIONS
None.
SEE ALSO
glob(), wordexp()
XBD
CHANGE HISTORY
First released in Issue 4. Derived from the ISO POSIX-2 standard.
Issue 5
Moved from POSIX2 C-language Binding to BASE.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0154 [291] and XSH/TC1-2008/0155 [291] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0121 [806] is applied.
Issue 8
Austin Group Defect 1031 is applied, adding FNM_CASEFOLD and FNM_IGNORECASE.
Austin Group Defect 1287 is applied, changing the description of how  is handled (if FNM_NOESCAPE is not set)
to refer to XCU 2.14.1 Patterns Matching a Single Character.
Austin Group Defect 1444 is applied, correcting cross-references to wordexp().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sendto.html =====
sendto
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sendto — send a message on a socket
SYNOPSIS
#include
ssize_t sendto(int socket, const void *message, size_t length,
int flags, const struct sockaddr *dest_addr,
socklen_t dest_len);
DESCRIPTION
The sendto() function shall send a message through a connection-mode or connectionless-mode socket.
If the socket is a connectionless-mode socket, the message shall be sent to the address specified by dest_addr if no
pre-specified peer address has been set. If a peer address has been pre-specified, either the message shall be sent to the address
specified by dest_addr (overriding the pre-specified peer address), or the function shall return -1 and set errno to
[EISCONN].
If the socket is connection-mode, dest_addr shall be ignored.
The sendto() function takes the following arguments:
socket
Specifies the socket file descriptor.
message
Points to a buffer containing the message to be sent.
length
Specifies the size of the message in bytes.
flags
Specifies the type of message transmission. Values of this argument are formed by logically OR'ing zero or more of the
following flags:
MSG_EOR
Terminates a record (if supported by the protocol).
MSG_OOB
Sends out-of-band data on sockets that support out-of-band data. The significance and semantics of out-of-band data are
protocol-specific.
MSG_NOSIGNAL
Requests not to send the SIGPIPE signal if an attempt to send is made on a stream-oriented socket that is no longer connected.
The [EPIPE] error shall still be returned.
dest_addr
Points to a sockaddr structure containing the destination address. The length and format of the address depend on the
address family of the socket.
dest_len
Specifies the length of the sockaddr structure pointed to by the dest_addr argument.
If the address family of the socket is AF_UNIX, the application shall ensure that a null terminator after the pathname is
included in the sun_path member of dest_addr as a sockaddr_un structure, and that dest_len is at least
offsetof(struct sockaddr_un, sun_path) + 1 plus the length of the pathname.
If the socket protocol supports broadcast and the specified address is a broadcast address for the socket protocol,
sendto() shall fail if the SO_BROADCAST option is not set for the socket.
The dest_addr argument specifies the address of the target.
The length argument specifies the length of the message.
Successful completion of a call to sendto() does not guarantee delivery of the message. A return value of -1 indicates
only locally-detected errors.
If space is not available at the sending socket to hold the message to be transmitted and the socket file descriptor does not
have O_NONBLOCK set, sendto() shall block until space is available or a timeout occurs (see SO_SNDTIMEO in 2.10.16 Use of Options). If space is not available at the sending socket to
hold the message to be transmitted and the socket file descriptor does have O_NONBLOCK set, sendto() shall fail.
The socket in use may require the process to have appropriate privileges to use the sendto() function.
RETURN VALUE
Upon successful completion, sendto() shall return the number of bytes sent. Otherwise, -1 shall be returned and
errno set to indicate the error.
ERRORS
The sendto() function shall fail if:
[EAFNOSUPPORT]
Addresses in the specified address family cannot be used with this socket.
[EAGAIN] or [EWOULDBLOCK]
The socket's file descriptor is marked O_NONBLOCK and the requested operation would block. See also SO_SNDTIMEO in 2.10.16 Use of Options.
[EBADF]
The socket argument is not a valid file descriptor.
[ECONNRESET]
A connection was forcibly closed by a peer.
[EINTR]
A signal interrupted sendto() before any data was transmitted.
[EMSGSIZE]
The message is too large to be sent all at once, as the socket requires.
[ENOTCONN]
The socket is connection-mode but is not connected.
[ENOTSOCK]
The socket argument does not refer to a socket.
[EOPNOTSUPP]
The socket argument is associated with a socket that does not support one or more of the values set in
flags.
[EPIPE]
The socket is shut down for writing, or the socket is connection-mode and is no longer connected. In the latter case, and if
the socket is of type SOCK_STREAM or SOCK_SEQPACKET and the MSG_NOSIGNAL flag is not set, the SIGPIPE signal is generated to the
calling thread.
If the address family of the socket is AF_UNIX, then sendto() shall fail if:
[EIO]
An I/O error occurred while reading from or writing to the file system.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the pathname in the socket address.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of the pathname does not name an existing file or the pathname is an empty string.
[ENOTDIR]
A component of the path prefix of the pathname in the socket address names an existing file that is neither a directory nor a
symbolic link to a directory, or the pathname in the socket address contains at least one non- character and ends with
one or more trailing  characters and the last pathname component names an existing file that is neither a directory
nor a symbolic link to a directory.
The sendto() function may fail if:
[EACCES]
Search permission is denied for a component of the path prefix; or write access to the named socket is denied.
[EDESTADDRREQ]
The socket is not connection-mode and does not have its peer address set, and no destination address was specified.
[EHOSTUNREACH]
The destination host cannot be reached (probably because the host is down or a remote router cannot reach it).
[EINVAL]
The dest_len argument is not a valid length for the address family.
[EIO]
An I/O error occurred while reading from or writing to the file system.
[EISCONN]
A destination address was specified and the socket is already connected.
[ENETDOWN]
The local network interface used to reach the destination is down.
[ENETUNREACH]
No route to the network is present.
[ENOBUFS]
Insufficient resources were available in the system to perform the operation.
[ENOMEM]
Insufficient memory was available to fulfill the request.
If the address family of the socket is AF_UNIX, then sendto() may fail if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the pathname in the socket address.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The select() and poll() functions can
be used to determine when it is possible to send more data.
For AF_UNIX sockets, some implementations support an extension where dest_len does not have to include a null terminator
for the pathname stored in sun_path, which in turn allows a pathname to be one byte longer. However, such usage is not
portable, and carries a risk of accessing beyond the intended bounds of the pathname length.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
getsockopt(), poll(), pselect(), recv(), recvfrom(), recvmsg(), send(), sendmsg(), setsockopt(), shutdown(), socket()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
The wording of the mandatory [ELOOP] error condition is updated, and a second optional [ELOOP] error condition is added.
Issue 7
Austin Group Interpretations 1003.1-2001 #035 and #073 are applied, updating the [EISCONN] error and the DESCRIPTION.
Austin Group Interpretation 1003.1-2001 #143 is applied, clarifying the [ENAMETOOLONG] error condition.
The MSG_NOSIGNAL flag is added from The Open Group Technical Standard, 2006, Extended API Set Part 2.
The [EPIPE] error is modified.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0545 [324] is applied.
Issue 8
Austin Group Defect 561 is applied, changing the requirements for the sun_path member of the sockaddr_un
structure.
Austin Group Defect 1429 is applied, clarifying the behavior on timeout by adding references to 2.10.16 Use of Options.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fstatat.html =====
fstatat
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fstatat, lstat, stat — get file status
SYNOPSIS
[OH] #include
#include
int fstatat(int fd, const char *restrict path,
struct stat *restrict buf, int flag);
int lstat(const char *restrict path, struct stat *restrict buf);
int stat(const char *restrict path, struct stat *restrict buf);
DESCRIPTION
The stat() function shall obtain information about the named file and write it to the area pointed to by the buf
argument. The path argument points to a pathname naming a file. Read, write, or execute permission of the named file is not
required. An implementation that provides additional or alternate file access control mechanisms may, under implementation-defined
conditions, cause stat() to fail. In particular, the system may deny the existence of the file specified by path.
If the named file is a symbolic link, the stat() function shall continue pathname resolution using the contents of the
symbolic link, and shall return information pertaining to the resulting file if the file exists.
The buf argument is a pointer to a stat structure, as defined in the  header, into which information is placed concerning the file.
The stat() function shall update any time-related fields (as described in XBD 4.12 File Times Update), before writing into the stat structure.
[SHM]
If the named file is a shared memory object, the implementation shall update in the stat structure pointed to by the
buf argument the st_uid, st_gid, st_size, and st_mode fields, and only the S_IRUSR, S_IWUSR,
S_IRGRP, S_IWGRP, S_IROTH, and S_IWOTH file permission bits need be valid. The implementation may update other fields and flags.
[TYM]
If the named file is a typed memory object, the implementation shall update in the stat structure pointed to by the
buf argument the st_uid, st_gid, st_size, and st_mode fields, and only the S_IRUSR, S_IWUSR,
S_IRGRP, S_IWGRP, S_IROTH, and S_IWOTH file permission bits need be valid. The implementation may update other fields and flags.
For all other file types defined in this volume of POSIX.1-2024, the structure members st_mode, st_ino,
st_dev, st_uid, st_gid, st_atim, st_ctim, and st_mtim shall have meaningful values and
the value of the member st_nlink shall be set to the number of hard links to the file.
The lstat() function shall be equivalent to stat(), except when path refers to a symbolic link. In that
case lstat() shall return information about the link, while stat() shall return information about the file the link
references.
For symbolic links, the st_mode member shall contain meaningful information when used with the file type macros. The file
mode bits in st_mode are unspecified. The structure members st_ino, st_dev, st_uid, st_gid,
st_atim, st_ctim, and st_mtim shall have meaningful values and the value of the st_nlink member shall
be set to the number of hard links to the symbolic link. The value of the st_size member shall be set to the length of the
pathname contained in the symbolic link not including any terminating null byte.
The fstatat() function shall be equivalent to the stat() or lstat() function, depending on the value of
flag (see below), except in the case where path specifies a relative path. In this case the status shall be retrieved
from a file relative to the directory associated with the file descriptor fd instead of the current working directory. If
the access mode of the open file description associated with the file descriptor is not O_SEARCH, the function shall check whether
directory searches are permitted using the current permissions of the directory underlying the file descriptor. If the access mode
is O_SEARCH, the function shall not perform the check.
Values for flag are constructed by a bitwise-inclusive OR of flags from the following list, defined in :
AT_SYMLINK_NOFOLLOW
If path names a symbolic link, the status of the symbolic link is returned.
If fstatat() is passed the special value AT_FDCWD in the fd parameter, the current working directory shall be used
and the behavior shall be identical to a call to stat() or lstat() respectively, depending on whether or not the
AT_SYMLINK_NOFOLLOW bit is set in flag.
RETURN VALUE
Upon successful completion, these functions shall return 0. Otherwise, these functions shall return -1 and set errno to
indicate the error.
ERRORS
These functions shall fail if:
[EACCES]
Search permission is denied for a component of the path prefix.
[EIO]
An error occurred while reading from the file system.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of path does not name an existing file or path is an empty string.
[ENOTDIR]
A component of the path prefix names an existing file that is neither a directory nor a symbolic link to a directory, or the
path argument contains at least one non- character and ends with one or more trailing  characters
and the last pathname component names an existing file that is neither a directory nor a symbolic link to a directory.
[EOVERFLOW]
The file size in bytes or the number of blocks allocated to the file or the file serial number cannot be represented correctly
in the structure pointed to by buf.
The fstatat() function shall fail if:
[EACCES]
The access mode of the open file description associated with fd is not O_SEARCH and the permissions of the directory
underlying fd do not permit directory searches.
[EBADF]
The path argument does not specify an absolute path and the fd argument is neither AT_FDCWD nor a valid file
descriptor open for reading or searching.
[ENOTDIR]
The path argument is not an absolute path and fd is a file descriptor associated with a non-directory file.
These functions may fail if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
[EOVERFLOW]
A value to be stored would overflow one of the members of the stat structure.
The fstatat() function may fail if:
[EINVAL]
The value of the flag argument is not valid.
The following sections are informative.
EXAMPLES
Obtaining File Status Information
The following example shows how to obtain file status information for a file named /home/cnd/mod1. The structure variable
buffer is defined for the stat structure.
#include
#include
#include
struct stat buffer;
int         status;
...
status = stat("/home/cnd/mod1", &buffer);
Getting Directory Information
The following example fragment gets status information for each entry in a directory. The call to the stat() function
stores file information in the stat structure pointed to by statbuf. The lines that follow the stat() call
format the fields in the stat structure for presentation to the user of the program.
#include
#include
#include
#include
#include
#include
#include
#include
#include
#include
struct dirent  *dp;
struct stat     statbuf;
struct passwd  *pwd;
struct group   *grp;
struct tm      *tm;
char            datestring[256];
...
/* Loop through directory entries. */
while ((dp = readdir(dir)) != NULL) {
/* Get entry's information. */
if (stat(dp->d_name, &statbuf) == -1)
continue;
/* Print out type, permissions, and number of links. */
printf("%10.10s", mode_string(statbuf.st_mode));
printf(" %4ju", (uintmax_t)statbuf.st_nlink);
/* Print out owner's name if it is found using getpwuid(). */
if ((pwd = getpwuid(statbuf.st_uid)) != NULL)
printf(" %-8.8s", pwd->pw_name);
else
printf(" %-8ju", (uintmax_t)statbuf.st_uid);
/* Print out group name if it is found using getgrgid(). */
if ((grp = getgrgid(statbuf.st_gid)) != NULL)
printf(" %-8.8s", grp->gr_name);
else
printf(" %-8ju", (uintmax_t)statbuf.st_gid);
/* Print size of file. */
printf(" %9jd", (intmax_t)statbuf.st_size);
tm = localtime(&statbuf.st_mtime);
/* Get localized date string. */
strftime(datestring, sizeof(datestring), nl_langinfo(D_T_FMT), tm);
printf(" %s %s\n", datestring, dp->d_name);
}
Obtaining Symbolic Link Status Information
The following example shows how to obtain status information for a symbolic link named /modules/pass1. The structure
variable buffer is defined for the stat structure. If the path argument specified the pathname for the file
pointed to by the symbolic link (/home/cnd/mod1), the results of calling the function would be the same as those returned by
a call to the stat() function.
#include
struct stat buffer;
int status;
...
status = lstat("/modules/pass1", &buffer);
APPLICATION USAGE
None.
RATIONALE
The intent of the paragraph describing "additional or alternate file access control mechanisms" is to allow a secure
implementation where a process with a label that does not dominate the file's label cannot perform a stat() function. This
is not related to read permission; a process with a label that dominates the file's label does not need read permission. An
implementation that supports write-up operations could fail fstat() function calls
even though it has a valid file descriptor open for writing.
The purpose of the fstatat() function is to obtain the status of files in directories other than the current working
directory without exposure to race conditions. Any part of the path of a file could be changed in parallel to a call to
stat(), resulting in unspecified behavior. By opening a file descriptor for the target directory and using the
fstatat() function it can be guaranteed that the file for which status is returned is located relative to the desired
directory.
FUTURE DIRECTIONS
None.
SEE ALSO
access(), chmod(),
fdopendir(), fstat(), mknod(), readlink(), symlink()
XBD 4.12 File Times Update, , ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
Large File Summit extensions are added.
Issue 6
In the SYNOPSIS, the optional include of the  header is
removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
The [EIO] mandatory error condition is added.
The [ELOOP] mandatory error condition is added.
The [EOVERFLOW] mandatory error condition is added. This change is to support large files.
The [ENAMETOOLONG] and the second [EOVERFLOW] optional error conditions are added.
The following changes were made to align with the IEEE P1003.1a draft standard:
Details are added regarding the treatment of symbolic links.
The [ELOOP] optional error condition is added.
The normative text is updated to avoid use of the term "must" for application requirements.
The restrict keyword is added to the stat() prototype for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
Austin Group Interpretation 1003.1-2001 #143 is applied.
XSH-SD5-ERN-161 is applied, updating the DESCRIPTION to clarify to which file types st_nlink applies.
The fstatat() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 2.
Changes are made related to support for finegrained timestamps.
The lstat() function is now required to return meaningful data for symbolic links in all stat structure fields,
except for the permission bits of st_mode.
Changes are made to allow a directory to be opened for searching.
The [ENOTDIR] error condition is clarified to cover the condition where the last component of a pathname exists but is not a
directory or a symbolic link to a directory.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0198 [461], XSH/TC1-2008/0199 [324], XSH/TC1-2008/0200 [278],
XSH/TC1-2008/0201 [278], and XSH/TC1-2008/0202 [291] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0136 [591], XSH/TC2-2008/0137 [817], XSH/TC2-2008/0138 [817], and
XSH/TC2-2008/0139 [889] are applied.
Issue 8
Austin Group Defect 1380 is applied, changing text using the term "link" in line with its updated definition.
Austin Group Defect 1409 is applied, changing the EXAMPLES section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/feholdexcept.html =====
feholdexcept
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
feholdexcept — save current floating-point environment
SYNOPSIS
#include
int feholdexcept(fenv_t *envp);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The feholdexcept() function shall save the current floating-point environment in the object pointed to by envp,
clear the floating-point status flags, and then install a non-stop (continue on floating-point exceptions) mode, if available, for
all floating-point exceptions.
RETURN VALUE
The feholdexcept() function shall return zero if and only if non-stop floating-point exception handling was successfully
installed.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The feholdexcept() function should be effective on typical IEC 60559:1989 standard implementations which have the
default non-stop mode and at least one other mode for trap handling or aborting. If the implementation provides only the non-stop
mode, then installing the non-stop mode is trivial.
FUTURE DIRECTIONS
None.
SEE ALSO
fegetenv(), feupdateenv()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atan2.html =====
atan2
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atan2, atan2f, atan2l — arc tangent functions
SYNOPSIS
#include
double atan2(double y, double x);
float atan2f(float y, float x);
long double atan2l(long double y, long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the principal value of the arc tangent of y/x, using the signs of both arguments to
determine the quadrant of the return value.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the arc tangent of y/x in the range [-ℼ,ℼ] radians.
If y is ±0 and x is  0, ±0 shall be returned.
If y is  0 and x is ±0, ℼ/2 shall be returned.
If x is 0, a pole error shall not occur.
[MX]  If
either x or y is NaN, a NaN shall be returned.
If the correct value would cause underflow, a range error may occur, and atan(),
atan2f(), and atan2l() shall return an implementation-defined value no greater in magnitude than DBL_MIN, FLT_MIN,
and LDBL_MIN, respectively. [MXX]   If the IEC 60559 Floating-Point option is supported, y/x should be returned.
[MX]  If
y is ±0 and x is -0, ±ℼ shall be returned.
If y is ±0 and x is +0, ±0 shall be returned.
For finite values of ±y > 0, if x is -Inf, ±ℼ shall be returned.
For finite values of ±y > 0, if x is +Inf, ±0 shall be returned.
For finite values of x, if y is ±Inf, ±ℼ/2 shall be returned.
If y is ±Inf and x is -Inf, ±3ℼ/4 shall be returned.
If y is ±Inf and x is +Inf, ±ℼ/4 shall be returned.
If both arguments are 0, a domain error shall not occur.
ERRORS
These functions may fail if:
Range Error
[MX]
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
Converting Cartesian to Polar Coordinates System
The function below uses atan2() to convert a 2d vector expressed in cartesian coordinates (x,y) to the
polar coordinates (rho,theta). There are other ways to compute the angle theta, using asin() acos(), or atan(). However, atan2() presents here two advantages:
The angle's quadrant is automatically determined.
The singular cases (0,y) are taken into account.
Finally, this example uses hypot() rather than sqrt() since it is better for special cases; see hypot() for more information.
#include
void
cartesian_to_polar(const double x, const double y,
double *rho, double *theta
)
{
*rho   = hypot (x,y); /* better than sqrt(x*x+y*y) */
*theta = atan2 (y,x);
}
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
acos(), asin(), atan(), feclearexcept(), fetestexcept(), hypot(), isnan(), sqrt(), tan()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The atan2f() and atan2l() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard, and the IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/18 is applied, adding to the EXAMPLES section.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0038 [68,428] is applied.
Issue 8
Austin Group Defect 1178 is applied, removing MX shading from a paragraph in the RETURN VALUE section and joining it with the
following paragraph.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcsxfrm_l.html =====
wcsxfrm
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcsxfrm, wcsxfrm_l — wide-character string transformation
SYNOPSIS
#include
size_t wcsxfrm(wchar_t *restrict ws1, const wchar_t *restrict ws2,
size_t n);
[CX]  size_t wcsxfrm_l(wchar_t *restrict ws1, const wchar_t *restrict
ws2,
size_t n, locale_t locale);
DESCRIPTION
For wcsxfrm(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The wcsxfrm() [CX]   and wcsxfrm_l()
functions shall transform the wide-character string pointed to by ws2 and place the resulting wide-character string
into the array pointed to by ws1. The transformation shall be such that if wcscmp() is applied to two transformed wide strings, it shall return a value greater than,
equal to, or less than 0, corresponding to the result of wcscoll() [CX]   and wcscoll_l()   applied
to the same two original wide-character strings, and the same LC_COLLATE category of the current locale [CX]   or the locale
object locale,   respectively. No more than n
wide-character codes shall be placed into the resulting array pointed to by ws1, including the terminating null
wide-character code. If n is 0, ws1 is permitted to be a null pointer. If copying takes place between objects that
overlap, the behavior is undefined.
[CX]  The
wcsxfrm() and wcsxfrm_l() functions shall not change the setting of errno if successful.
Since no return value is reserved to indicate an error, an application wishing to check for error situations should set
errno to 0, then call wcsxfrm() or wcsxfrm_l(), then check errno.
The behavior is undefined if the locale argument to wcsxfrm_l() is the special locale object LC_GLOBAL_LOCALE or
is not a valid locale object handle.
RETURN VALUE
The wcsxfrm() [CX]   and wcsxfrm_l()
functions shall return the length of the transformed wide-character string (not including the terminating null wide-character
code). If the value returned is n or more, the contents of the array pointed to by ws1 are unspecified.
[CX]  On
error, the wcsxfrm() and wcsxfrm_l() functions may set errno, but no return value is reserved to indicate an
error.
ERRORS
These functions may fail if:
[EINVAL]
[CX]
The wide-character string pointed to by ws2 contains wide-character codes outside the domain of the collating sequence.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The transformation function is such that two transformed wide-character strings can be ordered by wcscmp() as appropriate to collating sequence information in the current locale (category
LC_COLLATE ).
The fact that when n is 0 ws1 is permitted to be a null pointer is useful to determine the size of the ws1
array prior to making the transformation.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
wcscmp(), wcscoll()
XBD
CHANGE HISTORY
First released in Issue 4. Derived from the MSE working draft.
Issue 5
Moved from ENHANCED I18N to BASE and the [ENOSYS] error is removed.
The DESCRIPTION is updated to indicate that errno is not changed if the function is successful.
Issue 6
In earlier versions, this function was required to return -1 on error.
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the RETURN VALUE and ERRORS sections, the [EINVAL] optional error condition is added if no conversion could be performed.
The wcsxfrm() prototype is updated for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
The wcsxfrm_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0728 [302], XSH/TC1-2008/0729 [283], XSH/TC1-2008/0730 [283], and
XSH/TC1-2008/0731 [302] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/iswprint_l.html =====
iswprint
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
iswprint, iswprint_l — test for a printable wide-character code
SYNOPSIS
#include
int iswprint(wint_t wc);
[CX]  int iswprint_l(wint_t wc, locale_t locale);
DESCRIPTION
For iswprint(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The iswprint() [CX]   and iswprint_l()
functions shall test whether wc is a wide-character code representing a character of class print in the current
locale, [CX]   or in the locale represented by locale,
respectively; see XBD 7. Locale.
The wc argument is a wint_t, the value of which the application shall ensure is a wide-character code
corresponding to a valid character in the locale used by the function, or equal to the value of the macro WEOF. If the argument has
any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to iswprint_l() is the special locale object LC_GLOBAL_LOCALE or is not
a valid locale object handle.
RETURN VALUE
The iswprint() [CX]   and iswprint_l()
functions shall return non-zero if wc is a printable wide-character code; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
iswalnum(), iswalpha(),
iswcntrl(), iswctype(),
iswdigit(), iswgraph(),
iswlower(), iswpunct(),
iswspace(), iswupper(),
iswxdigit(), setlocale(),
uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 4.
Issue 5
The following change has been made in this version for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E):
The SYNOPSIS has been changed to indicate that this function and associated data types are now made visible by inclusion of the
header rather than .
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The iswprint_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0332 [302], XSH/TC1-2008/0333 [283], and XSH/TC1-2008/0334 [283] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0189 [685] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/vfwscanf.html =====
vfwscanf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
vfwscanf, vswscanf, vwscanf — wide-character formatted input of a stdarg argument list
SYNOPSIS
#include
#include
#include
int vfwscanf(FILE *restrict stream, const wchar_t *restrict format,
va_list arg);
int vswscanf(const wchar_t *restrict ws, const wchar_t *restrict format,
va_list arg);
int vwscanf(const wchar_t *restrict format, va_list arg);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The vfwscanf(), vswscanf(), and vwscanf() functions shall be equivalent to the fwscanf(), swscanf(), and wscanf() functions, respectively, except that instead of being called with a variable number
of arguments, they are called with an argument list as defined in the  header. These functions shall not invoke the va_end macro. As these
functions invoke the va_arg macro, the value of ap after the return is unspecified.
RETURN VALUE
Refer to fwscanf().
ERRORS
Refer to fwscanf().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications using these functions should call va_end(ap) afterwards to clean up.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fwscanf()
XBD , ,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0706 [14] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fminf.html =====
fmin
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fmin, fminf, fminl — determine minimum numeric value of two floating-point numbers
SYNOPSIS
#include
double fmin(double x, double y);
float fminf(float x, float y);
long double fminl(long double x, long double y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall determine the minimum numeric value of their arguments. [MX]   NaN arguments
shall be treated as missing data: if one argument is a NaN and the other numeric, then these functions shall choose the numeric
value.
RETURN VALUE
Upon successful completion, these functions shall return the minimum numeric value of their arguments.
[MX]  The
returned value shall be exact and shall be independent of the current rounding direction mode.
If just one argument is a NaN, the other argument shall be returned.
If x and y are NaN, a NaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
fdim(), fmax()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
Austin Group Interpretation 1003.1-2001 #008 is applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/aio_read.html =====
aio_read
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
aio_read — asynchronous read from a file
SYNOPSIS
#include
int aio_read(struct aiocb *aiocbp);
DESCRIPTION
The aio_read() function shall read aiocbp->aio_nbytes from the file associated with
aiocbp->aio_fildes into the buffer pointed to by aiocbp->aio_buf. The function call shall return
when the read request has been initiated or queued to the file or device (even when the data cannot be delivered immediately).
[PIO]
If prioritized I/O is supported for this file, then the asynchronous operation shall be submitted at a priority equal to a base
scheduling priority minus aiocbp->aio_reqprio. If Thread Execution Scheduling is not supported, then the base
scheduling priority is that of the calling process;
[PIO
TPS]  otherwise, the base scheduling priority is that
of the calling thread.
The aiocbp value may be used as an argument to aio_error() and aio_return() in order to determine the error status and return status, respectively, of
the asynchronous operation while it is proceeding. If an error condition is encountered during queuing, the function call shall
return without having initiated or queued the request. The requested operation takes place at the absolute position in the file as
given by aio_offset, as if lseek() were called immediately prior to the
operation with an offset equal to aio_offset and a whence equal to SEEK_SET. After a successful call to
enqueue an asynchronous I/O operation, the value of the file offset for the file is unspecified.
The aio_sigevent member specifies the notification which occurs when the request is completed.
The aiocbp->aio_lio_opcode field shall be ignored by aio_read().
The aiocbp argument points to an aiocb structure. If the buffer pointed to by aiocbp->aio_buf or
the control block pointed to by aiocbp becomes an illegal address prior to asynchronous I/O completion, then the behavior is
undefined.
Simultaneous asynchronous operations using the same aiocbp produce undefined results.
[SIO]
If synchronized I/O is enabled on the file associated with aiocbp->aio_fildes, the behavior of this function shall
be according to the definitions of synchronized I/O data integrity completion and synchronized I/O file integrity completion.
For any system action that changes the process memory space while an asynchronous I/O is outstanding to the address range being
changed, the result of that action is undefined.
For regular files, no data transfer shall occur past the offset maximum established in the open file description associated with
aiocbp->aio_fildes.
RETURN VALUE
The aio_read() function shall return the value zero if the I/O operation is successfully queued; otherwise, the function
shall return the value -1 and set errno to indicate the error.
ERRORS
The aio_read() function shall fail if:
[EAGAIN]
The requested asynchronous I/O operation was not queued due to system resource limitations.
Each of the following conditions may be detected synchronously at the time of the call to aio_read(), or asynchronously.
If any of the conditions below are detected synchronously, the aio_read() function shall return -1 and set errno to
the corresponding value. If any of the conditions below are detected asynchronously, the return status of the asynchronous
operation is set to -1, and the error status of the asynchronous operation is set to the corresponding value.
[EBADF]
The aiocbp->aio_fildes argument is not a valid file descriptor open for reading.
[EINVAL]
The file offset value implied by aiocbp->aio_offset would be invalid,
[PIO]
aiocbp->aio_reqprio is not a valid value,   or
aiocbp->aio_nbytes is an invalid value.
In the case that the aio_read() successfully queues the I/O operation but the operation is subsequently canceled or
encounters an error, the return status of the asynchronous operation is one of the values normally returned by the read() function call. In addition, the error status of the asynchronous operation is set to one
of the error statuses normally set by the read() function call, or one of the following
values:
[EBADF]
The aiocbp->aio_fildes argument is not a valid file descriptor open for reading.
[ECANCELED]
The requested I/O was canceled before the I/O completed due to an explicit aio_cancel() request.
[EINVAL]
The file offset value implied by aiocbp->aio_offset would be invalid.
The following condition may be detected synchronously or asynchronously:
[EOVERFLOW]
The file is a regular file, aiobcp->aio_nbytes is greater than 0, and the starting offset in
aiobcp->aio_offset is before the end-of-file and is at or beyond the offset maximum in the open file description
associated with aiocbp->aio_fildes.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
aio_cancel(), aio_error()
, lio_listio(), aio_return()
, aio_write(), close(), exec, exit(), fork(), lseek(), read()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Large File Summit extensions are added.
Issue 6
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the
Asynchronous Input and Output option.
The APPLICATION USAGE section is added.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the DESCRIPTION, text is added to indicate setting of the offset maximum in the open file description. This change is to
support large files.
In the ERRORS section, the [EOVERFLOW] condition is added. This change is to support large files.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/12 is applied, rewording the DESCRIPTION when prioritized I/O is
supported to account for threads, and removing the words "to the calling process" in the RETURN VALUE section.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/13 is applied, updating the [EINVAL] error, so that detection of
an [EINVAL] error for an invalid value of aiocbp->aio_reqprio is only required if the Prioritized Input and Output
option is supported.
Issue 7
Austin Group Interpretation 1003.1-2001 #082 is applied.
The aio_read() function is moved from the Asynchronous Input and Output option to the Base.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/putwc.html =====
putwc
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
putwc — put a wide character on a stream
SYNOPSIS
#include
#include
wint_t putwc(wchar_t wc, FILE *stream);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The putwc() function shall be equivalent to fputwc(), except that if it is
implemented as a macro it may evaluate stream more than once, so the argument should never be an expression with
side-effects.
RETURN VALUE
Refer to fputwc().
ERRORS
Refer to fputwc().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Since it may be implemented as a macro, putwc() may treat a stream argument with side-effects incorrectly. In
particular, putwc(wc,*f++) need not work correctly. Therefore, use of this function is not recommended;
fputwc() should be used instead.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fputwc()
XBD ,
CHANGE HISTORY
First released as a World-wide Portability Interface in Issue 4.
Issue 5
Aligned with ISO/IEC 9899:1990/Amendment 1:1995 (E). Specifically, the type of argument wc is changed from
wint_t to wchar_t.
The Optional Header (OH) marking is removed from .
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0478 [14] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mprotect.html =====
mprotect
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mprotect — set protection of memory mapping
SYNOPSIS
#include
int mprotect(void *addr, size_t len, int prot);
DESCRIPTION
The mprotect() function shall change the access protections to be that specified by prot for those whole pages
containing any part of the address space of the process starting at address addr and continuing for len bytes. The
parameter prot determines whether read, write, execute, or some combination of accesses are permitted to the data being
mapped. The prot argument should be either PROT_NONE or the bitwise-inclusive OR of one or more of PROT_READ, PROT_WRITE,
and PROT_EXEC.
If an implementation cannot support the combination of access types specified by prot, the call to mprotect()
shall fail.
An implementation may permit accesses other than those specified by prot; however, no implementation shall permit a write
to succeed where PROT_WRITE has not been set or shall permit any access where PROT_NONE alone has been set. Implementations shall
support at least the following values of prot: PROT_NONE, PROT_READ, PROT_WRITE, and the bitwise-inclusive OR of PROT_READ
and PROT_WRITE. If PROT_WRITE is specified, the application shall ensure that it has opened the mapped objects in the specified
address range with write permission, unless MAP_PRIVATE was specified in the original mapping, regardless of whether the file
descriptors used to map the objects have since been closed.
The implementation may require that addr be a multiple of the page size as returned by sysconf().
The behavior of this function is unspecified if the mapping was not established by a call to mmap().
When mprotect() fails for reasons other than [EINVAL], the protections on some of the pages in the range
[addr,addr+len) may have been changed.
RETURN VALUE
Upon successful completion, mprotect() shall return 0; otherwise, it shall return -1 and set errno to indicate the
error.
ERRORS
The mprotect() function shall fail if:
[EACCES]
The prot argument specifies a protection that violates the access permission the process has to the underlying memory
object.
[EAGAIN]
The prot argument specifies PROT_WRITE over a MAP_PRIVATE mapping and there are insufficient memory resources to reserve
for locking the private page.
[ENOMEM]
Addresses in the range [addr,addr+len) are invalid for the address space of a process, or specify one or
more pages which are not mapped.
[ENOMEM]
The prot argument specifies PROT_WRITE on a MAP_PRIVATE mapping, and it would require more space than the system is able
to supply for locking the private pages, if required.
[ENOTSUP]
The implementation does not support the combination of accesses requested in the prot argument.
The mprotect() function may fail if:
[EINVAL]
The addr argument is not a multiple of the page size as returned by sysconf().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Most implementations require that addr is a multiple of the page size as returned by sysconf().
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
mmap(), sysconf()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Aligned with mprotect() in the POSIX Realtime Extension as follows:
The DESCRIPTION is largely reworded.
[ENOTSUP] and a second form of [ENOMEM] are added as mandatory error conditions.
[EAGAIN] is moved from the optional to the mandatory error conditions.
Issue 6
The mprotect() function is marked as part of the Memory Protection option.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The DESCRIPTION is updated to state that implementations require addr to be a multiple of the page size as returned by
sysconf().
The [EINVAL] error condition is added.
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
SD5-XSH-ERN-22 is applied, deleting erroneous APPLICATION USAGE.
Austin Group Interpretation 1003.1-2001 #078 is applied, clarifying page alignment requirements.
The mprotect() function is moved from the Memory Protection option to the Base.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/tmpfile.html =====
tmpfile
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
tmpfile — create a temporary file
SYNOPSIS
#include
FILE *tmpfile(void);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The tmpfile() function shall create a temporary file and open a corresponding stream. The file shall be automatically
deleted when all references to the file are closed. The file shall be opened as in fopen() for update (wb+), except that implementations may restrict the permissions,
either by clearing the file mode bits or setting them to the value S_IRUSR | S_IWUSR.
[CX]  In
some implementations, a permanent file may be left behind if the process calling tmpfile() is killed while it is processing
a call to tmpfile().
An error message may be written to standard error if the stream cannot be opened.
RETURN VALUE
Upon successful completion, tmpfile() shall return a pointer to the stream of the file that is created. Otherwise, it
shall return a null pointer [CX]   and set errno to indicate the error.
ERRORS
The tmpfile() function shall fail if:
[EINTR]
[CX]  A
signal was caught during tmpfile().
[EMFILE]
[CX]
All file descriptors available to the process are currently open.
[EMFILE]
[CX]
{STREAM_MAX} streams are currently open in the calling process.
[ENFILE]
[CX]
The maximum allowable number of files is currently open in the system.
[ENOSPC]
[CX]
The directory or file system which would contain the new file cannot be expanded.
The tmpfile() function may fail if:
[EMFILE]
[CX]
{FOPEN_MAX} streams are currently open in the calling process.
[ENOMEM]
[CX]
Insufficient storage space is available.
The following sections are informative.
EXAMPLES
Creating a Temporary File
The following example creates a temporary file for update, and returns a pointer to a stream for the created file in the
fp variable.
#include
...
FILE *fp;
fp = tmpfile ();
APPLICATION USAGE
It should be possible to open at least {TMP_MAX} temporary files during the lifetime of the program (this limit may be shared
with tmpnam()) and there should be no limit on the number simultaneously open other
than this limit and any limit on the number of open file descriptors or streams ({OPEN_MAX}, {FOPEN_MAX}, {STREAM_MAX}).
In multi-threaded applications, the tmpfile() function can leak file descriptors into child processes. Applications
should instead use mkostemp() with the O_CLOEXEC or O_CLOFORK flag, or both,
followed by fdopen(), to avoid the leak.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fopen(), mkdtemp(), tmpnam(), unlink()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
Large File Summit extensions are added.
The last two paragraphs of the DESCRIPTION were included as APPLICATION USAGE notes in previous issues.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the ERRORS section, the [EOVERFLOW] condition is added. This change is to support large files.
The [EMFILE] optional error condition is added.
The APPLICATION USAGE section is added for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
Austin Group Interpretation 1003.1-2001 #025 is applied, clarifying that implementations may restrict the permissions of the
file created.
SD5-XBD-ERN-4 is applied, changing the definition of the [EMFILE] error.
SD5-XSH-ERN-149 is applied, adding the mandatory [EMFILE] error condition for {STREAM_MAX} streams open.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0668 [14] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0372 [678] is applied.
Issue 8
Austin Group Defects 411 and 1318 are applied, changing the APPLICATION USAGE section.
Austin Group Defect 1296 is applied, removing [EOVERFLOW] from the ERRORS section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/writev.html =====
writev
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
writev — write a vector
SYNOPSIS
[XSI]  #include
ssize_t writev(int fildes, const struct iovec *iov, int iovcnt);
DESCRIPTION
The writev() function shall be equivalent to write(), except as described
below. The writev() function shall gather output data from the iovcnt buffers specified by the members of the
iov array: iov[0], iov[1], ..., iov[iovcnt-1]. The iovcnt argument is valid if greater
than 0 and less than or equal to {IOV_MAX}, as defined in .
Each iovec entry specifies the base address and length of an area in memory from which data should be written. The
writev() function shall always write a complete area before proceeding to the next.
If fildes refers to a regular file and all of the iov_len members in the array pointed to by iov are 0,
writev() shall return 0 and have no other effect. For other file types, the behavior is unspecified.
If the sum of the iov_len values is greater than {SSIZE_MAX}, the operation shall fail and no data shall be
transferred.
RETURN VALUE
Upon successful completion, writev() shall return the number of bytes actually written. Otherwise, it shall return a
value of -1, the file-pointer shall remain unchanged, and errno shall be set to indicate an error.
ERRORS
Refer to write().
In addition, the writev() function shall fail if:
[EINVAL]
The sum of the iov_len values in the iov array would overflow an ssize_t.
The writev() function may fail and set errno to:
[EINVAL]
The iovcnt argument was less than or equal to 0, or greater than {IOV_MAX}.
The following sections are informative.
EXAMPLES
Writing Data from an Array
The following example writes data from the buffers specified by members of the iov array to the file associated with the
file descriptor fd.
#include
#include
#include
...
ssize_t bytes_written;
int fd;
char *buf0 = "short string\n";
char *buf1 = "This is a longer string\n";
char *buf2 = "This is the longest string in this example\n";
int iovcnt;
struct iovec iov[3];
iov[0].iov_base = buf0;
iov[0].iov_len = strlen(buf0);
iov[1].iov_base = buf1;
iov[1].iov_len = strlen(buf1);
iov[2].iov_base = buf2;
iov[2].iov_len = strlen(buf2);
...
iovcnt = sizeof(iov) / sizeof(struct iovec);
bytes_written = writev(fd, iov, iovcnt);
...
APPLICATION USAGE
None.
RATIONALE
Refer to write().
FUTURE DIRECTIONS
None.
SEE ALSO
readv(), write()
XBD ,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 6
Split out from the write() reference page.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fabs.html =====
fabs
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fabs, fabsf, fabsl — absolute value function
SYNOPSIS
#include
double fabs(double x);
float fabsf(float x);
long double fabsl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the absolute value of their argument x,|x|.
RETURN VALUE
Upon successful completion, these functions shall return the absolute value of x.
[MX]  The
returned value shall be exact and shall be independent of the current rounding direction mode.
If x is NaN, a NaN shall be returned.
If x is ±0, +0 shall be returned.
If x is ±Inf, +Inf shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
Computing the 1-Norm of a Floating-Point Vector
This example shows the use of fabs() to compute the 1-norm of a vector defined as follows:
norm1(v) = |v[0]| + |v[1]| + ... + |v[n-1]|
where |x| denotes the absolute value of x, n denotes the vector's dimension v[i] denotes the
i-th component of v (0
double
norm1(const double v[], const int n)
{
int     i;
double  n1_v;  /* 1-norm of v */
n1_v = 0;
for (i=0; i
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The fabsf() and fabsl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/27 is applied, adding the example to the EXAMPLES section.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/acos.html =====
acos
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
acos, acosf, acosl — arc cosine functions
SYNOPSIS
#include
double acos(double x);
float acosf(float x);
long double acosl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the principal value of the arc cosine of their argument x. The value of x should be
in the range [-1,1].
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the arc cosine of x, in the range [0,ℼ] radians.
For finite values of x not in the range [-1,1], a domain error shall occur, and [MX]   either a NaN
(if supported), or   an implementation-defined value shall be
returned.
[MX]  If
x is NaN, a NaN shall be returned.
If x is +1, +0 shall be returned.
If x is ±Inf, a domain error shall occur, and a NaN shall be returned.
ERRORS
These functions shall fail if:
Domain Error
The x argument is finite and is not in the range [-1,1], [MX]
or is ±Inf.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
cos(), feclearexcept(),
fetestexcept(), isnan()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The acosf() and acosl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0024 [320] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/shmdt.html =====
shmdt
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
shmdt — XSI shared memory detach operation
SYNOPSIS
[XSI]  #include
int shmdt(const void *shmaddr);
DESCRIPTION
The shmdt() function operates on XSI shared memory (see XBD 3.332
Shared Memory Object). It is unspecified whether this function interoperates with the realtime interprocess communication
facilities defined in 2.8 Realtime.
The shmdt() function detaches the shared memory segment located at the address specified by shmaddr from the
address space of the calling process.
RETURN VALUE
Upon successful completion, shmdt() shall decrement the value of shm_nattch in the data structure associated with
the shared memory ID of the attached shared memory segment and return 0. Also, the shm_dtime timestamp shall be set to the
current time, as described in 2.7.1 IPC General Description.
Otherwise, the shared memory segment shall not be detached, shmdt() shall return -1, and errno shall be set to
indicate the error.
ERRORS
The shmdt() function shall fail if:
[EINVAL]
The value of shmaddr is not the data segment start address of a shared memory segment.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The POSIX Realtime Extension defines alternative interfaces for interprocess communication. Application developers who need to
use IPC should design their applications so that modules using the IPC routines described in 2.7 XSI Interprocess Communication can be easily modified to use the alternative
interfaces.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.7 XSI Interprocess Communication, 2.8 Realtime, exec, exit(), fork(), shmat(), shmctl(), shmget(), shm_open(), shm_unlink()
XBD 3.332 Shared Memory Object,
CHANGE HISTORY
First released in Issue 2. Derived from Issue 2 of the SVID.
Issue 5
Moved from SHARED MEMORY to BASE.
The note about use of POSIX Realtime Extension IPC routines has been moved from FUTURE DIRECTIONS to a new APPLICATION USAGE
section.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0574 [345] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sinhf.html =====
sinh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sinh, sinhf, sinhl — hyperbolic sine functions
SYNOPSIS
#include
double sinh(double x);
float sinhf(float x);
long double sinhl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the hyperbolic sine of their argument x.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the hyperbolic sine of x.
If the result would cause an overflow, a range error shall occur and ±HUGE_VAL, ±HUGE_VALF, and ±HUGE_VALL (with the same sign
as x) shall be returned as appropriate for the type of the function.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0 or ±Inf, x shall be returned.
[MXX]
If x is subnormal, x should be returned.
[MX]  If x is subnormal, a range error may occur and, if x is
not returned, sinh(), sinhf(), and sinhl() shall return an implementation-defined value no greater in
magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
ERRORS
These functions shall fail if:
Range Error
The result would cause an overflow.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
These functions may fail if:
Range Error
[MX]
The value x is subnormal.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
asinh(), cosh(), feclearexcept(), fetestexcept()
, isnan(), tanh()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The sinhf() and sinhl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0587 [68] is applied.
Issue 8
Austin Group Defect 1382 is applied, rearranging the text describing the behavior when x is subnormal to avoid the need
for two shading changes.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fmal.html =====
fma
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fma, fmaf, fmal — floating-point multiply-add
SYNOPSIS
#include
double fma(double x, double y, double z);
float fmaf(float x, float y, float z);
long double fmal(long double x, long double y, long double z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute (x * y) + z, rounded as one ternary operation: they shall
compute the value (as if) to infinite precision and round once to the result format, according to the rounding mode characterized
by the value of FLT_ROUNDS.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return (x * y) + z, rounded as one ternary
operation.
If the result overflows or underflows, a range error may occur. [MX]
On systems that support the IEC 60559 Floating-Point
option, if the result overflows a range error shall occur.
If x or y are NaN, a NaN shall be returned.
If x multiplied by y is an exact infinity and z is also an infinity but with the opposite sign, a domain
error shall occur, and either a NaN (if supported), or an implementation-defined value shall be returned.
If one of x and y is infinite, the other is zero, and z is not a NaN, a domain error shall occur, and
either a NaN (if supported), or an implementation-defined value shall be returned.
If one of x and y is infinite, the other is zero, and z is a NaN, a NaN shall be returned and a domain
error may occur.
If x*y is not 0*Inf nor Inf*0 and z is a NaN, a NaN shall be returned.
ERRORS
These functions shall fail if:
Domain Error
[MX]
The value of x*y+z is invalid, or the value x*y is invalid and z is not a NaN.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
Range Error
[MX]
The result overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
These functions may fail if:
Domain Error
[MX]
The value x*y is invalid and z is a NaN.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
Range Error
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
Range Error
The result overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
In many cases, clever use of floating (fused) multiply-add leads to much improved code; but its unexpected use by the
compiler can undermine carefully written code. The FP_CONTRACT macro can be used to disallow use of floating multiply-add; and the
fma() function guarantees its use where desired. Many current machines provide hardware floating multiply-add instructions;
software implementation can be used for others.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #57 (SD5-XSH-ERN-69) is applied, adding a "may fail" range error for
non-MX systems.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_cond_broadcast.html =====
pthread_cond_broadcast
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_cond_broadcast, pthread_cond_signal — broadcast or signal a condition
SYNOPSIS
#include
int pthread_cond_broadcast(pthread_cond_t *cond);
int pthread_cond_signal(pthread_cond_t *cond);
DESCRIPTION
These functions shall unblock threads blocked on a condition variable.
The pthread_cond_broadcast() function shall, as a single atomic operation, determine which threads, if any, are blocked
on the specified condition variable cond and unblock all of these threads.
The pthread_cond_signal() function shall, as a single atomic operation, determine which threads, if any, are blocked on
the specified condition variable cond and unblock at least one of these threads.
If more than one thread is blocked on a condition variable, the scheduling policy shall determine the order in which threads are
unblocked. When each thread unblocked as a result of a pthread_cond_broadcast() or pthread_cond_signal() returns from
its call to pthread_cond_clockwait(), pthread_cond_timedwait(), or pthread_cond_wait(), the thread shall own the mutex with which it called pthread_cond_clockwait(), pthread_cond_timedwait(), or pthread_cond_wait(). The thread(s) that are unblocked shall contend for the mutex
according to the scheduling policy (if applicable), and as if each had called pthread_mutex_lock().
The pthread_cond_broadcast() or pthread_cond_signal() functions may be called by a thread whether or not it
currently owns the mutex that threads calling pthread_cond_clockwait(), pthread_cond_timedwait(), or pthread_cond_wait() have associated with the condition variable during their
waits; however, if predictable scheduling behavior is required, then that mutex shall be locked by the thread calling
pthread_cond_broadcast() or pthread_cond_signal().
The pthread_cond_broadcast() and pthread_cond_signal() functions shall have no effect if they determine that there
are no threads blocked on cond.
The behavior is undefined if the value specified by the cond argument to pthread_cond_broadcast() or
pthread_cond_signal() does not refer to an initialized condition variable.
RETURN VALUE
If successful, the pthread_cond_broadcast() and pthread_cond_signal() functions shall return zero; otherwise, an
error number shall be returned to indicate the error.
ERRORS
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The pthread_cond_broadcast() function is used whenever the shared-variable state has been changed in a way that more than
one thread can proceed with its task. Consider a single producer/multiple consumer problem, where the producer can insert multiple
items on a list that is accessed one item at a time by the consumers. By calling the pthread_cond_broadcast() function, the
producer would notify all consumers that might be waiting, and thereby the application would receive more throughput on a
multi-processor. In addition, pthread_cond_broadcast() makes it easier to implement a read-write lock. The
pthread_cond_broadcast() function is needed in order to wake up all waiting readers when a writer releases its lock.
Finally, the two-phase commit algorithm can use this broadcast function to notify all clients of an impending transaction
commit.
It is not safe to use the pthread_cond_signal() function in a signal handler that is invoked asynchronously. Even if it
were safe, there would still be a race between the test of the Boolean pthread_cond_wait() that could not be efficiently eliminated.
Mutexes and condition variables are thus not suitable for releasing a waiting thread by signaling from code running in a signal
handler.
RATIONALE
If an implementation detects that the value specified by the cond argument to pthread_cond_broadcast() or
pthread_cond_signal() does not refer to an initialized condition variable, it is recommended that the function should fail
and report an [EINVAL] error.
Multiple Awakenings by Condition Signal
On a multi-processor, it may be impossible for an implementation of pthread_cond_signal() to avoid the unblocking of more
than one thread blocked on a condition variable. For example, consider the following partial implementation of pthread_cond_wait() and pthread_cond_signal(), executed by two threads in
the order given. One thread is trying to wait on the condition variable, another is concurrently executing
pthread_cond_signal(), while a third thread is already waiting.
pthread_cond_wait(mutex, cond):
value = cond->value; /* 1 */
pthread_mutex_unlock(mutex); /* 2 */
pthread_mutex_lock(cond->mutex); /* 10 */
if (value == cond->value) { /* 11 */
me->next_cond = cond->waiter;
cond->waiter = me;
pthread_mutex_unlock(cond->mutex);
unable_to_run(me);
} else
pthread_mutex_unlock(cond->mutex); /* 12 */
pthread_mutex_lock(mutex); /* 13 */
pthread_cond_signal(cond):
pthread_mutex_lock(cond->mutex); /* 3 */
cond->value++; /* 4 */
if (cond->waiter) { /* 5 */
sleeper = cond->waiter; /* 6 */
cond->waiter = sleeper->next_cond; /* 7 */
able_to_run(sleeper); /* 8 */
}
pthread_mutex_unlock(cond->mutex); /* 9 */
The effect is that more than one thread can return from its call to pthread_cond_clockwait(), pthread_cond_timedwait(), or pthread_cond_wait() as a result of one call to pthread_cond_signal(). This
effect is called "spurious wakeup". Note that the situation is self-correcting in that the number of threads that are so awakened
is finite; for example, the next thread to call pthread_cond_wait() after
the sequence of events above blocks.
While this problem could be resolved, the loss of efficiency for a fringe condition that occurs only rarely is unacceptable,
especially given that one has to check the predicate associated with a condition variable anyway. Correcting this problem would
unnecessarily reduce the degree of concurrency in this basic building block for all higher-level synchronization operations.
An added benefit of allowing spurious wakeups is that applications are forced to code a predicate-testing-loop around the
condition wait. This also makes the application tolerate superfluous condition broadcasts or signals on the same condition variable
that may be coded in some other part of the application. The resulting applications are thus more robust. Therefore, POSIX.1-2024
explicitly documents that spurious wakeups may occur.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_cond_clockwait(), pthread_cond_destroy()
XBD 4.15.2 Memory Synchronization,
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_cond_broadcast() and pthread_cond_signal() functions are marked as part of the Threads option.
The APPLICATION USAGE section is added.
Issue 7
The pthread_cond_broadcast() and pthread_cond_signal() functions are moved from the Threads option to the
Base.
The [EINVAL] error for an uninitialized condition variable is removed; this condition results in undefined behavior.
Issue 8
Austin Group Defect 609 is applied, adding atomicity requirements.
Austin Group Defect 1216 is applied, adding pthread_cond_clockwait().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getprotoent.html =====
endprotoent
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
endprotoent, getprotobyname, getprotobynumber, getprotoent, setprotoent — network protocol database
functions
SYNOPSIS
#include
void endprotoent(void);
struct protoent *getprotobyname(const char *name);
struct protoent *getprotobynumber(int proto);
struct protoent *getprotoent(void);
void setprotoent(int stayopen);
DESCRIPTION
These functions shall retrieve information about protocols. This information is considered to be stored in a database that can
be accessed sequentially or randomly. The implementation of this database is unspecified.
The setprotoent() function shall open a connection to the database, and set the next entry to the first entry. If the
stayopen argument is non-zero, the connection to the network protocol database shall not be closed after each call to
getprotoent() (either directly, or indirectly through one of the other getproto*() functions), and the implementation
may maintain an open file descriptor for the database. If a file descriptor is used, the FD_CLOEXEC flag shall be set; see .
The getprotobyname() function shall search the database from the beginning and find the first entry for which the
protocol name specified by name matches the p_name member, opening and closing a connection to the database as
necessary.
The getprotobynumber() function shall search the database from the beginning and find the first entry for which the
protocol number specified by proto matches the p_proto member, opening and closing a connection to the database as
necessary.
The getprotoent() function shall read the next entry of the database, opening and closing a connection to the database as
necessary.
The getprotobyname(), getprotobynumber(), and getprotoent() functions shall each return a pointer to a
protoent structure, the members of which shall contain the fields of an entry in the network protocol database.
The endprotoent() function shall close the connection to the database, releasing any open file descriptor.
These functions need not be thread-safe.
RETURN VALUE
Upon successful completion, getprotobyname(), getprotobynumber(), and getprotoent() return a pointer to a
protoent structure if the requested entry was found, and a null pointer if the end of the database was reached or the
requested entry was not found. Otherwise, a null pointer is returned.
The application shall not modify the structure to which the return value points, nor any storage areas pointed to by pointers
within the structure. The returned pointer, and pointers within the structure, might be invalidated or the structure or the storage
areas might be overwritten by a subsequent call to getprotobyname(), getprotobynumber(), or getprotoent(). The
returned pointer, and pointers within the structure, might also be invalidated if the calling thread is terminated.
ERRORS
The getprotobyname(), getprotobynumber(), getprotoent(), and setprotoent() functions may fail
if:
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum allowable number of files is currently open in the system.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0085 [75] and XSH/TC1-2008/0086 [75] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0091 [656] is applied.
Issue 8
Austin Group Defect 368 is applied, adding a requirement for FD_CLOEXEC to be set if a file descriptor is used, and adding the
[EMFILE] and [ENFILE] errors.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/nextafterf.html =====
nextafter
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
nextafter, nextafterf, nextafterl, nexttoward, nexttowardf, nexttowardl — next representable floating-point
number
SYNOPSIS
#include
double nextafter(double x, double y);
float nextafterf(float x, float y);
long double nextafterl(long double x, long double y);
double nexttoward(double x, long double y);
float nexttowardf(float x, long double y);
long double nexttowardl(long double x, long double y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The nextafter(), nextafterf(), and nextafterl() functions shall compute the next representable
floating-point value following x in the direction of y. Thus, if y is less than x, nextafter()
shall return the largest representable floating-point number less than x. The nextafter(), nextafterf(), and
nextafterl() functions shall return y if x equals y.
The nexttoward(), nexttowardf(), and nexttowardl() functions shall be equivalent to the corresponding
nextafter() functions, except that the second parameter shall have type long double and the functions shall return
y converted to the type of the function if x equals y.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the next representable floating-point value following x in the
direction of y.
If x==y, y (of the type x) shall be returned.
[MX]
Even though underflow or overflow can occur, the returned value shall be independent of the current rounding direction mode.
If x is finite and the correct function value would overflow, a range error shall occur and ±HUGE_VAL, ±HUGE_VALF, and
±HUGE_VALL (with the same sign as x) shall be returned as appropriate for the return type of the function.
[MX]  If
x or y is NaN, a NaN shall be returned.
[MX]  If
x!=y and the correct function value is subnormal, zero, or underflows, a range error shall occur, and
[MXX]
the correct function value (if representable) or
[MX]  0.0 shall be returned.
ERRORS
These functions shall fail if:
Range Error
The correct value overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
Range Error
[MX]
The correct value is subnormal or underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
When  is included, note that the return type of
nextafter() depends on the generic typing deduced from both arguments, while the return type of nexttoward() depends
only on the generic typing of the first argument.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The nextafter() function is no longer marked as an extension.
The nextafterf(), nextafterl(), nexttoward(), nexttowardf(), and nexttowardl() functions are
added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0407 [68] and XSH/TC1-2008/0408 [357] are applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/setbuf.html =====
setbuf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
setbuf — assign buffering to a stream
SYNOPSIS
#include
void setbuf(FILE *restrict stream, char *restrict buf);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
Except that it returns no value, the function call:
setbuf(stream, buf)
shall be equivalent to:
setvbuf(stream, buf, _IOFBF, BUFSIZ)
if buf is not a null pointer, or to:
setvbuf(stream, buf, _IONBF, BUFSIZ)
if buf is a null pointer.
RETURN VALUE
The setbuf() function shall not return a value.
ERRORS
Although the setvbuf() interface may set errno in defined ways, the value
of errno after a call to setbuf() is unspecified.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
A common source of error is allocating buffer space as an "automatic" variable in a code block, and then failing to close the
stream in the same block.
With setbuf(), allocating a buffer of BUFSIZ bytes does not necessarily imply that all of BUFSIZ bytes are used for the
buffer area.
Since errno is not required to be unchanged on success, in order to correctly detect and possibly recover from errors,
applications should use setvbuf() instead of setbuf().
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fopen(), setvbuf()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The prototype for setbuf() is updated for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0546 [397], XSH/TC1-2008/0547 [397], and XSH/TC1-2008/0548 [14] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/lcong48.html =====
drand48
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
drand48, erand48, jrand48, lcong48, lrand48, mrand48, nrand48, seed48, srand48 — generate uniformly distributed
pseudo-random numbers
SYNOPSIS
[XSI]  #include
double drand48(void);
double erand48(unsigned short xsubi[3]);
long jrand48(unsigned short xsubi[3]);
void lcong48(unsigned short param[7]);
long lrand48(void);
long mrand48(void);
long nrand48(unsigned short xsubi[3]);
unsigned short *seed48(unsigned short seed16v[3]);
void srand48(long seedval);
DESCRIPTION
This family of functions shall generate pseudo-random numbers using a linear congruential algorithm and 48-bit integer
arithmetic.
The drand48() and erand48() functions shall return non-negative, double-precision, floating-point values,
uniformly distributed over the interval [0.0,1.0).
The lrand48() and nrand48() functions shall return non-negative, long integers, uniformly distributed over the
interval [0,231).
The mrand48() and jrand48() functions shall return signed long integers uniformly distributed over the interval
[-231,231).
The srand48(), seed48(), and lcong48() functions are initialization entry points, one of which should be
invoked before either drand48(), lrand48(), or mrand48() is called. (Although it is not recommended practice,
constant default initializer values shall be supplied automatically if drand48(), lrand48(), or mrand48() is
called without a prior call to an initialization entry point.) The erand48(), nrand48(), and jrand48()
functions do not require an initialization entry point to be called first.
All the routines work by generating a sequence of 48-bit integer values,
\(X_{i}\),
according to the linear congruential formula:
\(X_{n+1}=\left(a X_n+c\right)_{\bmod m} \quad n \geq 0\)
The parameter m=248; hence 48-bit integer arithmetic is performed. Unless lcong48() is invoked, the multiplier
value a and the addend value c are given by:
\(
\begin{aligned}
& a= \text { 5DEECE66D }_{16}=273673163155_8 \\
& c=\mathrm{B}_{16}=13_8
\end{aligned}
\)
The value returned by any of the drand48(), erand48(), jrand48(), lrand48(), mrand48(), or
nrand48() functions is computed by first generating the next 48-bit \(X_{i}\) in the sequence. \(X_{i}\) is then converted
to the return value as follows:
For drand48() and erand48() the value shall be 2-48 times \(X_{i}\).
For jrand48() and mrand48() the value shall be the largest integer not greater than 2-16 times \(X_{i}\).
For lrand48() and nrand48() the value shall be the largest integer not greater than 2-17 times \(X_{i}\).
The drand48(), lrand48(), and mrand48() functions store the last 48-bit \(X_{i}\) generated in an internal
buffer; that is why the application shall ensure that these are initialized prior to being invoked. The erand48(),
nrand48(), and jrand48() functions require the calling program to provide storage for the successive \(X_{i}\) values
in the array specified as an argument when the functions are invoked. That is why these routines do not have to be initialized; the
calling program merely has to place the desired initial value of \(X_{i}\) into the array and pass it as an argument. By using
different arguments, erand48(), nrand48(), and jrand48() allow separate modules of a large program to generate
several independent streams of pseudo-random numbers; that is, the sequence of numbers in each stream shall not
depend upon how many times the routines are called to generate numbers for the other streams.
The initializer function srand48() sets the high-order 32 bits of \(X_{i}\) to the low-order 32 bits contained in its
argument. The low-order 16 bits of \(X_{i}\) are set to the arbitrary value 330E16.
The initializer function seed48() sets the value of \(X_{i}\) to the 48-bit value specified in the argument array. The
low-order 16 bits of \(X_{i}\) are set to the low-order 16 bits of seed16v[0]. The mid-order 16 bits of \(X_{i}\) are
set to the low-order 16 bits of seed16v[1]. The high-order 16 bits of \(X_{i}\) are set to the low-order 16 bits of
seed16v[2]. In addition, the previous value of \(X_{i}\) is copied into a 48-bit internal buffer, used only by
seed48(), and a pointer to this buffer is the value returned by seed48(). This returned pointer, which can just be
ignored if not needed, is useful if a program is to be restarted from a given point at some future time—use the pointer to get at
and store the last \(X_{i}\) value, and then use this value to reinitialize via seed48() when the program is restarted.
The initializer function lcong48() allows the user to specify the initial \(X_{i}\), the multiplier value a, and the
addend value c. Argument array elements param[0-2] specify \(X_{i}\), param[3-5] specify the
multiplier a, and param[6] specifies the 16-bit addend c. After lcong48() is called, a subsequent call to
either srand48() or seed48() shall restore the standard multiplier and addend values, a and c,
specified above.
The drand48(), lrand48(), and mrand48() functions need not be thread-safe.
RETURN VALUE
As described in the DESCRIPTION above.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
The following program tests that the required pseudo-random number generator is used by these functions.
#include
#include
int main() {
{
unsigned short xsubi[3] = {37174, 64810, 11603};
double d = erand48(xsubi);
assert(d >= 0.896);
assert(d = 0.337);
assert(d = 0.647);
assert(d = 0.500);
assert(d = 0.506);
assert(d
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
A note indicating that the drand48(), lrand48(), and mrand48() functions need not be reentrant is added to
the DESCRIPTION.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0083 [743] is applied.
Issue 8
Austin Group Defect 1107 is applied, clarifying how the return value is calculated from  \(X_{i}\) for each function.
Austin Group Defect 1134 is applied, adding getentropy().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strrchr.html =====
strrchr
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strrchr — string scanning operation
SYNOPSIS
#include
char *strrchr(const char *s, int c);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The strrchr() function shall locate the last occurrence of c (converted to a char) in the string pointed to
by s. The terminating NUL character is considered to be part of the string.
[CX]  The
strrchr() function shall not change the setting of errno on valid input.
RETURN VALUE
Upon successful completion, strrchr() shall return a pointer to the byte or a null pointer if c does not occur in
the string.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
Finding the Base Name of a File
The following example uses strrchr() to get a pointer to the base name of a file. The strrchr() function searches
backwards through the name of the file to find the last '/' character in name. This pointer (plus one) will point
to the base name of the file.
#include
...
const char *name;
char *basename;
...
basename = strrchr(name, '/') + 1;
...
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
strchr()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that strrchr() does not change the setting of errno on
valid input.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/telldir.html =====
telldir
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
telldir — current location of a named directory stream
SYNOPSIS
[XSI]  #include
long telldir(DIR *dirp);
DESCRIPTION
The telldir() function shall obtain the current location associated with the directory stream specified by
dirp.
If the most recent operation on the directory stream was a seekdir(), the
directory position returned from the telldir() shall be the same as that supplied as a loc argument for seekdir().
RETURN VALUE
Upon successful completion, telldir() shall return the current location of the specified directory stream.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
fdopendir(), readdir(),
seekdir()
XBD
CHANGE HISTORY
First released in Issue 2.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getsid.html =====
getsid
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getsid — get the process group ID of a session leader
SYNOPSIS
#include
pid_t getsid(pid_t pid);
DESCRIPTION
The getsid() function shall obtain the process group ID of the process that is the session leader of the process
specified by pid. If pid is (pid_t)0, it specifies the calling process.
RETURN VALUE
Upon successful completion, getsid() shall return the process group ID of the session leader of the specified process.
Otherwise, it shall return -1 and set errno to indicate the error.
ERRORS
The getsid() function shall fail if:
[EPERM]
The process specified by pid is not in the same session as the calling process, and the implementation does not allow
access to the process group ID of the session leader of that process from the calling process.
[ESRCH]
There is no process with a process ID equal to pid.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
exec, fork(), getpid(), getpgid(), setpgid(), setsid()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 7
The getsid() function is moved from the XSI option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0258 [421] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/crealf.html =====
creal
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
creal, crealf, creall — complex real functions
SYNOPSIS
#include
double creal(double complex z);
float crealf(float complex z);
long double creall(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the real part of z.
RETURN VALUE
These functions shall return the real part value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
For a variable z of type complex:
z == creal(z) + cimag(z)*I
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
carg(), cimag(), conj(), cproj()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/closedir.html =====
closedir
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
closedir — close a directory stream
SYNOPSIS
#include
int closedir(DIR *dirp);
DESCRIPTION
The closedir() function shall close the directory stream referred to by the argument dirp. Upon return, the value
of dirp may no longer point to an accessible object of the type DIR. If there is a file descriptor associated with
the stream (whether opened by opendir() or dirfd(), or passed to fdopendir() when
creating the stream), that file descriptor shall be closed by closedir().
RETURN VALUE
Upon successful completion, closedir() shall return 0; otherwise, -1 shall be returned and errno set to indicate
the error.
ERRORS
The closedir() function may fail if:
[EBADF]
The dirp argument does not refer to an open directory stream.
[EINTR]
The closedir() function was interrupted by a signal.
The following sections are informative.
EXAMPLES
Closing a Directory Stream
The following program fragment demonstrates how the closedir() function is used.
...
DIR *dir;
struct dirent *dp;
...
if ((dir = opendir (".")) == NULL) {
...
}
while ((dp = readdir (dir)) != NULL) {
...
}
closedir(dir);
...
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
dirfd(), fdopendir()
XBD
CHANGE HISTORY
First released in Issue 2.
Issue 6
In the SYNOPSIS, the optional include of the  header is
removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
The [EINTR] error condition is added as an optional error condition.
Issue 8
Austin Group Defect 1360 is applied, clarifying that type DIR always has the ability to store a file descriptor; what is
optional is whether one is opened by opendir().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/setreuid.html =====
setreuid
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
setreuid — set real and effective user IDs
SYNOPSIS
[XSI]  #include
int setreuid(uid_t ruid, uid_t euid);
DESCRIPTION
The setreuid() function shall set the real and effective user IDs of the current process to the values specified by the
ruid and euid arguments. If ruid or euid is -1, the corresponding effective or real user ID of the
current process shall be left unchanged.
A process with appropriate privileges can set either ID to any value. An unprivileged process can only set the effective user ID
if the euid argument is equal to either the real, effective, or saved user ID of the process.
If the real user ID is being set (ruid is not -1), or the effective user ID is being set to a value not equal to the real
user ID, then the saved set-user-ID of the current process shall be set equal to the new effective user ID.
It is unspecified whether a process without appropriate privileges is permitted to change the real user ID to match the current
effective user ID or saved set-user-ID of the process.
RETURN VALUE
Upon successful completion, 0 shall be returned. Otherwise, -1 shall be returned and errno set to indicate the error.
ERRORS
The setreuid() function shall fail if:
[EINVAL]
The value of the ruid or euid argument is invalid or out-of-range.
[EPERM]
The current process does not have appropriate privileges, and either an attempt was made to change the effective user ID to a
value other than the real user ID or the saved set-user-ID or an attempt was made to change the real user ID to a value not
permitted by the implementation.
The following sections are informative.
EXAMPLES
Setting the Effective User ID to the Real User ID
The following example sets the effective user ID of the calling process to the real user ID, so that files created later will be
owned by the current user. It also sets the saved set-user-ID to the real user ID, so any future attempt to set the effective user
ID back to its previous value will fail.
#include
#include
...
setreuid(getuid(), getuid());
...
APPLICATION USAGE
None.
RATIONALE
Earlier versions of this standard did not specify whether the saved set-user-ID was affected by setreuid() calls. This
version specifies common existing practice that constitutes an important security feature. The ability to set both the effective
user ID and saved set-user-ID to be the same as the real user ID means that any security weakness in code that is executed after
that point cannot result in malicious code being executed with the previous effective user ID. Privileged applications could
already do this using just setuid(), but for non-privileged applications the only
standard method available is to use this feature of setreuid().
FUTURE DIRECTIONS
None.
SEE ALSO
getegid(), geteuid(), getgid(), getresgid(), getresuid(), getuid(), setegid(), seteuid(), setgid(), setregid(), setresgid(), setresuid(), setuid()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 7
SD5-XSH-ERN-177 is applied, adding the ability to set both the effective user ID and the saved set-user-ID to be the same as the
real user ID.
Issue 8
Austin Group Defect 1344 is applied, adding getresgid(), getresuid(), setresgid(), and setresuid() to SEE ALSO.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/cimagl.html =====
cimag
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cimag, cimagf, cimagl — complex imaginary functions
SYNOPSIS
#include
double cimag(double complex z);
float cimagf(float complex z);
long double cimagl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the imaginary part of z.
RETURN VALUE
These functions shall return the imaginary part value (as a real).
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
For a variable z of complex type:
z == creal(z) + cimag(z)*I
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
carg(), conj(), cproj(), creal()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sockatmark.html =====
sockatmark
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sockatmark — determine whether a socket is at the out-of-band mark
SYNOPSIS
#include
int sockatmark(int s);
DESCRIPTION
The sockatmark() function shall determine whether the socket specified by the descriptor s is at the out-of-band
data mark (see 2.10.12 Socket Out-of-Band Data State). If the
protocol for the socket supports out-of-band data by marking the stream with an out-of-band data mark, the sockatmark()
function shall return 1 when all data preceding the mark has been read and the out-of-band data mark is the first element in the
receive queue. The sockatmark() function shall not remove the mark from the stream.
RETURN VALUE
Upon successful completion, the sockatmark() function shall return a value indicating whether the socket is at an
out-of-band data mark. If the protocol has marked the data stream and all data preceding the mark has been read, the return value
shall be 1; if there is no mark, or if data precedes the mark in the receive queue, the sockatmark() function shall return
0. Otherwise, it shall return a value of -1 and set errno to indicate the error.
ERRORS
The sockatmark() function shall fail if:
[EBADF]
The s argument is not a valid file descriptor.
[ENOTTY]
The file associated with the s argument is not a socket.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The use of this function between receive operations allows an application to determine which received data precedes the
out-of-band data and which follows the out-of-band data.
There is an inherent race condition in the use of this function. On an empty receive queue, the current read of the location
might well be at the "mark", but the system has no way of knowing that the next data segment that will arrive from the network
will carry the mark, and sockatmark() will return false, and the next read operation will silently consume the mark.
Hence, this function can only be used reliably when the application already knows that the out-of-band data has been seen by the
system or that it is known that there is data waiting to be read at the socket (via SIGURG or select()). See 2.10.11 Socket Receive
Queue, 2.10.12 Socket Out-of-Band Data State, 2.10.14 Signals, and pselect() for details.
RATIONALE
The sockatmark() function replaces the historical SIOCATMARK command to ioctl() which implemented the same
functionality on many implementations. Using a wrapper function follows the adopted conventions to avoid specifying commands to the
ioctl() function. The sockatmark() function could be implemented as follows:
#include
int sockatmark(int s)
{
int val;
if (ioctl(s,SIOCATMARK,&val)==-1)
return(-1);
return(val);
}
The use of [ENOTTY] to indicate an incorrect descriptor type matches the historical behavior of SIOCATMARK.
FUTURE DIRECTIONS
None.
SEE ALSO
2.10.12 Socket Out-of-Band Data State, pselect(), recv(), recvmsg()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1g-2000.
Issue 7
SD5-XSH-ERN-100 is applied, correcting the definition of the [ENOTTY] error condition.
Issue 8
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/conjl.html =====
conj
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
conj, conjf, conjl — complex conjugate functions
SYNOPSIS
#include
double complex conj(double complex z);
float complex conjf(float complex z);
long double complex conjl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex conjugate of z, by reversing the sign of its imaginary part.
RETURN VALUE
These functions return the complex conjugate value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
carg(), cimag(), cproj(), creal()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getpgid.html =====
getpgid
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getpgid — get the process group ID for a process
SYNOPSIS
#include
pid_t getpgid(pid_t pid);
DESCRIPTION
The getpgid() function shall return the process group ID of the process whose process ID is equal to pid. If
pid is equal to 0, getpgid() shall return the process group ID of the calling process.
RETURN VALUE
Upon successful completion, getpgid() shall return a process group ID. Otherwise, it shall return (pid_t)-1 and
set errno to indicate the error.
ERRORS
The getpgid() function shall fail if:
[EPERM]
The process whose process ID is equal to pid is not in the same session as the calling process, and the implementation
does not allow access to the process group ID of that process from the calling process.
[ESRCH]
There is no process with a process ID equal to pid.
The getpgid() function may fail if:
[EINVAL]
The value of the pid argument is invalid.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
exec, fork(), getpgrp(), getpid(), getsid(), setpgid(), setsid()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 7
The getpgid() function is moved from the XSI option to the Base.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/floor.html =====
floor
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
floor, floorf, floorl — floor function
SYNOPSIS
#include
double floor(double x);
float floorf(float x);
long double floorl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the largest integral value not greater than x.
[MX]
These functions may raise the inexact floating-point exception for finite non-integer arguments.
RETURN VALUE
[MX]  The
returned value shall be independent of the current rounding direction mode and shall have the same sign as x.
Upon successful completion, these functions shall return the largest integral value not greater than x, expressed as a
double, float, or long double, as appropriate for the return type of the function.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0 or ±Inf, x shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The integral value returned by these functions might not be expressible as an intmax_t. The return value should be tested
before assigning it to an integer type to avoid the undefined results of an integer overflow.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
ceil(), feclearexcept(),
fetestexcept(), isnan()
4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The floorf() and floorl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0141 [346] is applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wordexp.html =====
wordexp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wordexp, wordfree — perform word expansions
SYNOPSIS
#include
int wordexp(const char *restrict words, wordexp_t *restrict pwordexp,
int flags);
void wordfree(wordexp_t *pwordexp);
DESCRIPTION
The wordexp() function shall perform word expansions as described in XCU 2.6 Word Expansions, subject to quoting as described in XCU 2.2 Quoting, and place the list of expanded words into the structure pointed to
by pwordexp.
The words argument is a pointer to a string containing one or more words to be expanded. The expansions shall be the same
as would be performed by the command line interpreter if words were the part of a command line representing the arguments to
a utility. Therefore, the application shall ensure that words does not contain an unquoted  character or any
of the unquoted shell special characters '|', '&', ';', '' except in
the context of command substitution as specified in XCU 2.6.3 Command
Substitution. It also shall not contain unquoted parentheses or braces, except in the context of command or variable
substitution. The application shall ensure that every member of words which it expects to have expanded by wordexp()
does not contain an unquoted initial comment character. The application shall also ensure that any words which it intends to be
ignored (because they begin or continue a comment) are deleted from words. If the argument words contains an unquoted
comment character () that is the beginning of a token, wordexp() shall either treat the comment character
as a regular character, or interpret it as a comment indicator and ignore the remainder of words.
The structure type wordexp_t is defined in the  header
and includes at least the following members:
Member Type
Member Name
Description
size_t
we_wordc
Count of words matched by words.
char **
we_wordv
Pointer to list of expanded words.
size_t
we_offs
Slots to reserve at the beginning of pwordexp->we_wordv.
The wordexp() function shall store the number of generated words into pwordexp->we_wordc
and a pointer to a list of pointers to words in pwordexp->we_wordv. Each individual field created during field
splitting (see XCU 2.6.5 Field Splitting) or pathname expansion (see
XCU 2.6.6 Pathname Expansion) shall be a separate word in the
pwordexp->we_wordv list. The words shall be in order as described in XCU 2.6 Word Expansions. The first pointer after the last word pointer shall be a
null pointer. The expansion of special parameters described in XCU 2.5.2
Special Parameters is unspecified.
It is the caller's responsibility to allocate the storage pointed to by pwordexp. The wordexp()
function shall allocate other space as needed, including memory pointed to by pwordexp->we_wordv. The
wordfree() function shall free any memory associated with pwordexp from a previous call to wordexp(). The
wordfree() function shall not modify errno if pwordexp was previously modified by wordexp() and not yet
freed.
The flags argument is used to control the behavior of wordexp(). The value of flags is the
bitwise-inclusive OR of zero or more of the following constants, which are defined in :
WRDE_APPEND
Append words generated to the ones from a previous call to wordexp().
WRDE_DOOFFS
Make use of pwordexp->we_offs. If this flag is set, pwordexp->we_offs is used to specify how
many null pointers to add to the beginning of pwordexp->we_wordv. In other words,
pwordexp->we_wordv shall point to pwordexp->we_offs null pointers, followed by
pwordexp->we_wordc word pointers, followed by a null pointer.
WRDE_NOCMD
If the implementation supports the utilities defined in the Shell and Utilities volume of POSIX.1-2024, fail if command
substitution, as specified in XCU 2.6.3 Command Substitution, is
requested.
WRDE_REUSE
The pwordexp argument was passed to a previous successful call to wordexp(), and has not been passed to
wordfree(). The result shall be the same as if the application had called wordfree() and then called wordexp()
without WRDE_REUSE.
WRDE_SHOWERR
Do not redirect stderr to /dev/null.
WRDE_UNDEF
Report error on an attempt to expand an undefined shell variable.
The WRDE_APPEND flag can be used to append a new set of words to those generated by a previous call to
wordexp(). The following rules apply to applications when two or more calls to wordexp() are made with the same value
of pwordexp and without intervening calls to wordfree():
The first such call shall not set WRDE_APPEND. All subsequent calls shall set it.
All of the calls shall set WRDE_DOOFFS, or all shall not set it.
After the second and each subsequent call, pwordexp->we_wordv shall point to a list containing
the following:
Zero or more null pointers, as specified by WRDE_DOOFFS and pwordexp->we_offs
Pointers to the words that were in the pwordexp->we_wordv list before the call, in the same order
as before
Pointers to the new words generated by the latest call, in the specified order
The count returned in pwordexp->we_wordc shall be the total number of words from all of the
calls.
The application can change any of the fields after a call to wordexp(), but if it does it shall reset them
to the original value before a subsequent call, using the same pwordexp value, to wordfree() or wordexp() with
the WRDE_APPEND or WRDE_REUSE flag.
If the implementation supports the utilities defined in the Shell and Utilities volume of POSIX.1-2024, and
words contains an unquoted character—, '|', '&', ';', '', '(', ')', '{', '}'—in an inappropriate context, wordexp() shall fail,
and the number of expanded words shall be 0.
Unless WRDE_SHOWERR is set in flags, wordexp() shall redirect stderr to /dev/null for
any utilities executed as a result of command substitution while expanding words. If WRDE_SHOWERR is set, wordexp()
may write messages to stderr if syntax errors are detected while expanding words, unless the stderr stream has
wide orientation in which case the behavior is undefined. It is unspecified whether any write errors encountered while outputting
such messages will affect the stderr error indicator or the value of errno.
The application shall ensure that if WRDE_DOOFFS is set, then pwordexp->we_offs has the same value
for each wordexp() call and wordfree() call using a given pwordexp.
The results are unspecified if WRDE_APPEND and WRDE_REUSE are both specified.
The following constants are defined as error return values:
WRDE_BADCHAR
One of the unquoted characters—, '|', '&', ';', '',
'(', ')', '{', '}'—appears in words in an inappropriate context.
WRDE_BADVAL
Reference to undefined shell variable when WRDE_UNDEF is set in flags.
WRDE_CMDSUB
Command substitution requested when WRDE_NOCMD was set in flags.
WRDE_NOSPACE
Attempt to allocate memory failed.
WRDE_SYNTAX
Shell syntax error, such as unbalanced parentheses or unterminated string.
RETURN VALUE
Upon successful completion, wordexp() shall return 0. Otherwise, a non-zero value, as described in , shall be returned to indicate an error. If wordexp() returns the
value WRDE_NOSPACE, then pwordexp->we_wordc and pwordexp->we_wordv shall be updated to reflect
any words that were successfully expanded. In other error cases, if the WRDE_APPEND flag was specified,
pwordexp->we_wordc and pwordexp->we_wordv shall not be modified.
The wordfree() function shall not return a value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The wordexp() function is intended to be used by an application that wants to do all of the shell's expansions on a word
or words obtained from a user. For example, if the application prompts for a pathname (or list of pathnames) and then uses
wordexp() to process the input, the user could respond with anything that would be valid as input to the shell.
The WRDE_NOCMD flag is provided for applications that, for security or other reasons, want to prevent a user from
executing shell commands. Disallowing unquoted shell special characters also prevents unwanted side-effects, such as executing a
command or writing a file.
POSIX.1-2024 does not require the wordexp() function to be thread-safe if passed an expression referencing
an environment variable while any other thread is concurrently modifying any environment variable; see exec.
Even though the WRDE_SHOWERR flag allows the implementation to write messages to stderr during command
substitution or syntax errors, this standard does not provide any way to detect write failures during the output of such
messages.
Applications which use wide-character output functions with stderr should ensure that any calls to
wordexp() do not write to stderr, by avoiding use of the WRDE_SHOWERR flag.
RATIONALE
This function was included as an alternative to glob(). There had been continuing
controversy over exactly what features should be included in glob(). It is hoped that
by providing wordexp() (which provides all of the shell word expansions, but which may be slow to execute) and glob() (which is faster, but which only performs pathname expansion, without tilde or parameter
expansion) this will satisfy the majority of applications.
While wordexp() could be implemented entirely as a library routine, it is expected that most implementations
run a shell in a subprocess to do the expansion.
Two different approaches have been proposed for how the required information might be presented to the shell and
the results returned. They are presented here as examples.
One proposal is to extend the echo utility by adding a -q
option. This option would cause echo to add a  before each
and  that occurs within an argument. The wordexp() function could then invoke the shell as
follows:
(void) strcpy(buffer, "echo -q");
(void) strcat(buffer, words);
if ((flags & WRDE_SHOWERR) == 0)
(void) strcat(buffer, "2>/dev/null");
f = popen(buffer, "r");
The wordexp() function would read the resulting output, remove unquoted  characters, and
break into words at unquoted  characters. If the WRDE_NOCMD flag was set, wordexp() would have to scan
words before starting the subshell to make sure that there would be no command substitution. In any case, it would have to
scan words for unquoted special characters.
Another proposal is to add the following options to sh:
-w wordlist
This option provides a wordlist expansion service to applications. The words in wordlist shall be expanded and the following
written to standard output:
The count of the number of words after expansion, in decimal, followed by a null byte
The number of bytes needed to represent the expanded words (not including null separators), in decimal, followed
by a null byte
The expanded words, each terminated by a null byte
If an error is encountered during word expansion, sh exits with a
non-zero status after writing the former to report any words successfully expanded
-P
Run in "protected" mode. If specified with the -w option, no command substitution shall be performed.
With these options, wordexp() could be implemented fairly simply by creating a subprocess using fork() and executing sh using the line:
execl(, "sh", "-P", "-w", words, (char *)0);
after directing standard error to /dev/null.
It seemed objectionable for a library routine to write messages to standard error, unless explicitly requested, so
wordexp() is required to redirect standard error to /dev/null to ensure that no messages are generated, even for
commands executed for command substitution. The WRDE_SHOWERR flag can be specified to request that error messages be written.
The WRDE_REUSE flag allows the implementation to avoid the expense of freeing and reallocating memory, if that is
possible. A minimal implementation can call wordfree() when WRDE_REUSE is set.
FUTURE DIRECTIONS
None.
SEE ALSO
exec, fnmatch(), glob()
XBD
XCU 2. Shell Command Language
CHANGE HISTORY
First released in Issue 4. Derived from the ISO POSIX-2 standard.
Issue 5
Moved from POSIX2 C-language Binding to BASE.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
The restrict keyword is added to the wordexp() prototype for alignment with the
ISO/IEC 9899:1999 standard.
Issue 7
Austin Group Interpretation 1003.1-2001 #148 is applied, adding APPLICATION USAGE.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0739 [460], XSH/TC1-2008/0740 [291], and XSH/TC1-2008/0741
[460] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0397 [608], XSH/TC2-2008/0398 [704], XSH/TC2-2008/0399 [704],
and XSH/TC2-2008/0400 [608] are applied.
Issue 8
Austin Group Defect 385 is applied, adding a requirement that wordfree() does not modify errno when passed a
pointer to a wordexp_t that can be freed.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/tcgetsid.html =====
tcgetsid
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
tcgetsid — get the process group ID for the session leader for the controlling terminal
SYNOPSIS
#include
pid_t tcgetsid(int fildes);
DESCRIPTION
The tcgetsid() function shall obtain the process group ID of the session for which the terminal specified by
fildes is the controlling terminal.
RETURN VALUE
Upon successful completion, tcgetsid() shall return the process group ID of the session associated with the terminal.
Otherwise, a value of -1 shall be returned and errno set to indicate the error.
ERRORS
The tcgetsid() function shall fail if:
[EBADF]
The fildes argument is not a valid file descriptor.
[ENOTTY]
The calling process does not have a controlling terminal, or the file is not the controlling terminal.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
The [EACCES] error has been removed from the list of mandatory errors, and the description of [ENOTTY] has been reworded.
Issue 7
SD5-XSH-ERN-180 is applied, clarifying the RETURN VALUE section.
The tcgetsid() function is moved from the XSI option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0648 [421] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/lround.html =====
lround
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
lround, lroundf, lroundl — round to nearest integer value
SYNOPSIS
#include
long lround(double x);
long lroundf(float x);
long lroundl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall round their argument to the nearest integer value, rounding halfway cases away from zero, regardless of
the current rounding direction.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the rounded integer value.
[MX]  If
x is NaN, a domain error shall occur and an unspecified value is returned.
If x is +Inf, a domain error shall occur and an unspecified value is returned.
If x is -Inf, a domain error shall occur and an unspecified value is returned.
If the correct value is positive and too large to represent as a long, an unspecified value shall be returned.
[MX]
On systems that support the IEC 60559 Floating-Point option, a domain shall occur;  otherwise, a [CX]   domain  error may occur.
If the correct value is negative and too large to represent as a long, an unspecified value shall be returned.
[MX]
On systems that support the IEC 60559 Floating-Point option, a domain shall occur;  otherwise, a [CX]   domain  error may occur.
ERRORS
These functions shall fail if:
Domain Error
[MX]
The x argument is NaN or ±Inf, or the correct value is not representable as an integer.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
These functions may fail if:
Domain Error
The correct value is not representable as an integer.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
These functions differ from the lrint() functions in the default rounding
direction, with the lround() functions rounding halfway cases away from zero and needing not to raise the inexact
floating-point exception for non-integer arguments that round to within the range of the return type.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), llround()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #54 (SD5-XSH-ERN-78) is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/frexpf.html =====
frexp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
frexp, frexpf, frexpl — extract significand and exponent from a double precision number
SYNOPSIS
#include
double frexp(double num, int *exp);
float frexpf(float num, int *exp);
long double frexpl(long double num, int *exp);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall break a floating-point number num into a normalized fraction and an integral power of 2. The
integer exponent shall be stored in the int object pointed to by exp; if the integer exponent is outside the range of
int, the results are unspecified.
RETURN VALUE
For finite arguments, these functions shall return the value x, such that x has a magnitude in the interval [½,1)
or 0, and num equals x times 2 raised to the power *exp.
[MX]
When the radix of the argument is a power of 2, the returned value shall be exact and shall be independent of the current rounding
direction mode.
If num is NaN, a NaN shall be returned, and the value of *exp is unspecified.
If num is ±0, ±0 shall be returned, and the value of *exp shall be 0.
If num is ±Inf, num shall be returned, and the value of *exp is unspecified.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
isnan(), ldexp(), modf()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The frexpf() and frexpl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1753 is applied, changing the NAME section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/log2f.html =====
log2
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
log2, log2f, log2l — compute base 2 logarithm functions
SYNOPSIS
#include
double log2(double x);
float log2f(float x);
long double log2l(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the base 2 logarithm of their argument x, log2(x).
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the base 2 logarithm of x.
If x is ±0, a pole error shall occur and log2(), log2f(), and log2l() shall return -HUGE_VAL,
-HUGE_VALF, and -HUGE_VALL, respectively.
For finite values of x that are less than 0, [MX]   or if x is -Inf,  a domain error shall occur, and [MX]   either a NaN (if supported), or   an implementation-defined value shall be returned.
[MX]  If
x is NaN, a NaN shall be returned.
If x is 1, +0 shall be returned.
If x is +Inf, x shall be returned.
ERRORS
These functions shall fail if:
Domain Error
The finite value of x is less than zero, [MX]   or x is -Inf.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
Pole Error
The value of x is zero.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the divide-by-zero floating-point exception shall
be raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), log()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atomic_load.html =====
atomic_load
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atomic_load, atomic_load_explicit — atomically obtain the value of an object
SYNOPSIS
#include
C atomic_load(const volatile A *object); C atomic_load_explicit(const
volatile A *object, memory_order order);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
Implementations that define the macro __STDC_NO_ATOMICS__ need not provide the  header nor support these generic functions.
The atomic_load_explicit() generic function shall atomically obtain the value pointed to by object. Memory shall
be affected according to the value of order, which the application shall ensure is not memory_order_release nor
memory_order_acq_rel.
The atomic_load() generic function shall be equivalent to atomic_load_explicit() called with order set to
memory_order_seq_cst.
RETURN VALUE
These generic functions shall return the value pointed to by object.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD 4.15.1 Memory Ordering,
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_mutex_getprioceiling.html =====
pthread_mutex_getprioceiling
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_mutex_getprioceiling, pthread_mutex_setprioceiling — get and set the priority ceiling of a mutex (REALTIME
THREADS)
SYNOPSIS
[RPP|TPP]  #include
int pthread_mutex_getprioceiling(const pthread_mutex_t *restrict mutex,
int *restrict prioceiling);
int pthread_mutex_setprioceiling(pthread_mutex_t *restrict mutex,
int prioceiling, int *restrict old_ceiling);
DESCRIPTION
The pthread_mutex_getprioceiling() function shall return the current priority ceiling of the mutex.
The pthread_mutex_setprioceiling() function shall attempt to lock the mutex as if by a call to pthread_mutex_lock(), except that the process of locking the mutex need not
adhere to the priority protect protocol. On acquiring the mutex it shall change the mutex's priority ceiling and then release the
mutex as if by a call to pthread_mutex_unlock(). When the change is
successful, the previous value of the priority ceiling shall be returned in old_ceiling.
If the pthread_mutex_setprioceiling() function fails, the mutex priority ceiling shall not be changed.
RETURN VALUE
If successful, the pthread_mutex_getprioceiling() and pthread_mutex_setprioceiling() functions shall return zero;
otherwise, an error number shall be returned to indicate the error.
ERRORS
These functions shall fail if:
[EINVAL]
The protocol attribute of mutex is PTHREAD_PRIO_NONE.
[EPERM]
The implementation requires appropriate privileges to perform the operation and the caller does not have appropriate
privileges.
The pthread_mutex_setprioceiling() function shall fail if:
[EAGAIN]
The mutex could not be acquired because the maximum number of recursive locks for mutex has been exceeded.
[EAGAIN]
The mutex is a robust mutex and the system resources available for robust mutexes owned would be exceeded.
[EDEADLK]
The mutex type is PTHREAD_MUTEX_ERRORCHECK and the current thread already owns the mutex.
[EINVAL]
The mutex was created with the protocol attribute having the value PTHREAD_PRIO_PROTECT and the calling thread's priority is
higher than the mutex's current priority ceiling, and the implementation adheres to the priority protect protocol in the process of
locking the mutex.
[ENOTRECOVERABLE]
The mutex is a robust mutex and the state protected by the mutex is not recoverable.
[EOWNERDEAD]
The mutex is a robust mutex and the process containing the previous owning thread terminated while holding the mutex lock. The
mutex lock shall be acquired by the calling thread and it is up to the new owner to make the state consistent (see pthread_mutex_lock()).
The pthread_mutex_setprioceiling() function may fail if:
[EDEADLK]
A deadlock condition was detected.
[EINVAL]
The priority requested by prioceiling is out of range.
[EOWNERDEAD]
The mutex is a robust mutex and the previous owning thread terminated while holding the mutex lock. The mutex lock shall be
acquired by the calling thread and it is up to the new owner to make the state consistent (see pthread_mutex_lock()).
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_mutex_clocklock(), pthread_mutex_destroy(), pthread_mutex_lock()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Marked as part of the Realtime Threads Feature Group.
Issue 6
The pthread_mutex_getprioceiling() and pthread_mutex_setprioceiling() functions are marked as part of the Threads
and Thread Priority Protection options.
The [ENOSYS] error conditions have been removed.
The pthread_mutex_timedlock() function is added to the SEE ALSO
section for alignment with IEEE Std 1003.1d-1999.
The restrict keyword is added to the pthread_mutex_getprioceiling() and pthread_mutex_setprioceiling()
prototypes for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
SD5-XSH-ERN-39 is applied.
Austin Group Interpretation 1003.1-2001 #052 is applied, adding [EDEADLK] as a "may fail" error.
SD5-XSH-ERN-158 is applied, updating the ERRORS section to include a "shall fail" error case for when the protocol attribute
of mutex is PTHREAD_PRIO_NONE.
The pthread_mutex_getprioceiling() and pthread_mutex_setprioceiling() functions are moved from the Threads option
to require support of either the Robust Mutex Priority Protection option or the Non-Robust Mutex Priority Protection
option.
The DESCRIPTION and ERRORS sections are updated to account properly for all of the various mutex types.
Issue 8
Austin Group Defect 354 is applied, adding the [EAGAIN] error for exceeding system resources available for robust mutexes
owned.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/cargf.html =====
carg
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
carg, cargf, cargl — complex argument functions
SYNOPSIS
#include
double carg(double complex z);
float cargf(float complex z);
long double cargl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the argument (also called phase angle) of z, with a branch cut along the negative real
axis.
RETURN VALUE
These functions shall return the value of the argument in the interval [-ℼ, +ℼ].
[MXC]
If z is -0 ± i0, ±ℼ shall be returned.
If z is +0 ± i0, ±0 shall be returned.
If z is x ± i0 where x is negative, ±ℼ shall be returned.
If z is x ± i0 where x is positive, ±0 shall be returned.
If z is ±0 + iy where y is negative, -ℼ/2 shall be returned.
If z is ±0 + iy where y is positive, ℼ/2 shall be returned.
If z is -Inf ± iy where y is positive and finite, ±ℼ shall be returned.
If z is +Inf ± iy where y is positive and finite, ±0 shall be returned.
If z is x ± iInf where x is finite, ±ℼ/2 shall be returned.
If z is -Inf ± iInf, ±3ℼ/4 shall be returned.
If z is +Inf ± iInf, ±ℼ/4 shall be returned.
If the real or imaginary part of z is NaN, NaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
cimag(), conj(), cproj()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fabsf.html =====
fabs
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fabs, fabsf, fabsl — absolute value function
SYNOPSIS
#include
double fabs(double x);
float fabsf(float x);
long double fabsl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the absolute value of their argument x,|x|.
RETURN VALUE
Upon successful completion, these functions shall return the absolute value of x.
[MX]  The
returned value shall be exact and shall be independent of the current rounding direction mode.
If x is NaN, a NaN shall be returned.
If x is ±0, +0 shall be returned.
If x is ±Inf, +Inf shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
Computing the 1-Norm of a Floating-Point Vector
This example shows the use of fabs() to compute the 1-norm of a vector defined as follows:
norm1(v) = |v[0]| + |v[1]| + ... + |v[n-1]|
where |x| denotes the absolute value of x, n denotes the vector's dimension v[i] denotes the
i-th component of v (0
double
norm1(const double v[], const int n)
{
int     i;
double  n1_v;  /* 1-norm of v */
n1_v = 0;
for (i=0; i
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The fabsf() and fabsl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/27 is applied, adding the example to the EXAMPLES section.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/dgettext_l.html =====
gettext
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
dgettext, dgettext_l, dcgettext, dcgettext_l, gettext, gettext_l, ngettext, ngettext_l, dngettext, dngettext_l,
dcngettext, dcngettext_l — message handling functions
SYNOPSIS
#include
char *dgettext(const char *domainname, const char *msgid);
char *dgettext_l(const char *domainname, const char *msgid,
locale_t locale);
char *dcgettext(const char *domainname, const char *msgid,
int category);
char *dcgettext_l(const char *domainname, const char *msgid,
int category, locale_t locale);
char *dngettext(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n);
char *dngettext_l(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n,
locale_t locale);
char *dcngettext(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n,
int category);
char *dcngettext_l(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n,
int category, locale_t locale);
char *gettext(const char *msgid);
char *gettext_l(const char *msgid, locale_t locale);
char *ngettext(const char *msgid, const char *msgid_plural,
unsigned long int n);
char *ngettext_l(const char *msgid, const char *msgid_plural,
unsigned long int n, locale_t locale);
DESCRIPTION
The gettext() function shall:
attempt to locate a suitable messages object (described in detail below) for the LC_MESSAGES category in the current
locale, and for the current text domain (see bindtextdomain()), containing
the string identified by msgid,
retrieve the string identified by msgid from the messages object,
convert the string to the output codeset if necessary (described in detail below), and
return the result.
If the locale name in effect is "POSIX" or "C" (i.e. the name associated with the LC_MESSAGES locale
category in the current locale), or if no suitable messages object exists, or if no string identified by msgid exists in the
messages object, or if an error occurs, msgid shall be returned.
The dgettext() function shall be equivalent to gettext(), except domainname shall be used instead of the
current text domain to locate the messages object.
The dcgettext() function shall be equivalent to dgettext(), except the locale category identified by
category shall be used instead of LC_MESSAGES .
The ngettext() function shall be equivalent to gettext(), except:
The string to retrieve shall be identified by a combination of msgid and n (see msgfmt).
If the locale name in effect is "POSIX" or "C", or if no suitable messages object exists, or if no string
identified by the combination of msgid and n exists in the messages object, or if an error occurs, the return value
shall be msgid if n is 1, otherwise msgid_plural.
The dngettext() function shall be equivalent to ngettext(), except domainname shall be used instead of the
current text domain to locate the messages object.
The dcngettext() function shall be equivalent to dngettext(), except the locale category identified by
category shall be used instead of LC_MESSAGES .
The *_l() functions shall be equivalent to their counterparts without the _l suffix, except locale shall be
used instead of the current locale. If locale is the special locale object LC_GLOBAL_LOCALE or is not a valid locale object
handle, the behavior is undefined.
The application shall ensure that the msgid and msgid_plural arguments are strings. If either msgid or
msgid_plural is an empty string, or contains characters not in the portable character set, the results are unspecified. If
the category argument is LC_ALL , the results are unspecified.
The location of the messages object shall be determined according to the following criteria, stopping when the first messages
object is found:
[XSI]
If the NLSPATH environment variable is set to a non-empty string, an NLSPATH search shall be performed as described
in XBD 8.2 Internationalization Variables. If NLSPATH identifies
more than one template to use, each template in turn shall be used until a valid messages object is found.
If the LANGUAGE environment variable is set to a non-empty string, a LANGUAGE search shall be performed as
described below. If LANGUAGE identifies more than one directory to search, each directory shall be searched until a valid
messages object is found.
A single-locale search shall be performed as described below.
For [XSI]   the NLSPATH search and   the single-locale search,
the single locale name used to locate the messages object shall be the locale name associated with the selected locale category
from the current locale, or the provided locale object if calling one of the *_l() functions; additional searches of locale
names without .codeset (if present), without _territory (if present), and without @modifier (if present) may
be performed.
For the LANGUAGE search, the value of the LANGUAGE environment variable shall be a list of one or more locale
names separated by a  (':') character. Each locale name shall be tried in the specified order. If a messages
object for the locale does not exist, or cannot be opened, or is unsuitable for implementation-defined reasons (such as security),
the next locale name (if any) shall be tried. If:
a messages object for the locale can be opened but cannot be processed without error, or
the messages object does not contain a string identified by msgid, or msgid and n for the ngettext
functions,
it is unspecified whether the next locale name (if any) is tried. In all other cases, the messages object for the locale shall
be used.
For each locale name in LANGUAGE , or if LANGUAGE is not set or is empty, or no suitable messages object is found
in processing LANGUAGE , the pathname used to locate the messages object shall be
dirname/localename/categoryname/textdomainname.mo, where:
The dirname part is the dirname argument of the most recent successful call to bindtextdomain() that had textdomainname as the domainname argument;
any trailing  characters in dirname shall be discarded. If a successful call to bindtextdomain() has not been made for textdomainname, an
implementation-defined default directory shall be used.
For the LANGUAGE search, the localename part is each locale name from LANGUAGE in turn; if a locale name
has the format language[_territory][.codeset][@modifier], additional
searches of locale names without .codeset (if present), without _territory (if present), and without @modifier
(if present) may be performed; if .codeset is not present, additional searches of locale names with an added .codeset
may be performed. For the single-locale search, the localename part is the name of the current locale, or the locale
specified in an *_l() function call, for the category named by categoryname. Spellings of codeset names are not
standardized, and implementations may attempt to use different commonly known spellings, for example "utf8" and
"UTF-8".
The categoryname part is the string "LC_MESSAGES" if gettext(), dgettext(), ngettext(), or
dngettext() is called, or the locale category name corresponding to the category argument to dcgettext() or
dcngettext(). Likewise for the *_l() variants of all these functions.
For gettext(), gettext_l(), ngettext(), and ngettext_l(), the textdomainname part is the text
domain set by the last successful call to textdomain(). For dgettext(),
dcgettext(), dngettext(), dcngettext(), and the *_l() variants of these functions,
textdomainname is the text domain specified by the domainname argument. The domainname argument shall be
equivalent in syntax and meaning to the domainname argument to textdomain(), except that the selection of the text domain shall affect only the
dgettext(), dcgettext(), dngettext(), and dcngettext() function calls and their *_l() variants.
If the domainname argument is a null pointer, the text domain set by the last successful call to textdomain() shall be used. For all of these functions, if a successful call to textdomain() has not been made the default text domain "messages" shall be
used.
Resolution of the messages object pathname shall be performed the first time one of the gettext family of functions is
called for a given combination of dirname, localename, categoryname, and textdomainname. It is
unspecified whether the pathname is re-resolved if the combination has been used before in a call to one of the gettext
family of functions. If bindtextdomain() performs pathname resolution of its
dirname argument, only the part of the messages object pathname after dirname shall be resolved by the gettext
family of functions.
When one of the gettext family of functions returns a message string that was found in a messages object, it shall
convert the codeset of the message string to the output codeset if a codeset is specified in the messages object (see msgfmt) and the output codeset is not the same as that codeset. If a successful call to
bind_textdomain_codeset() has been made with the text domain of the
messages object as the domainname argument and a non-null codeset argument, the output codeset shall be the
codeset argument from the most recent such call. Otherwise, the output codeset shall be the codeset of characters in the
current locale, or the provided locale object if calling one of the *_l() functions, as specified by the LC_CTYPE
category of the locale. The conversion shall be performed as if by a call to iconv()
using a conversion descriptor returned by iconv_open(, ),
except that if the return value of iconv() would be greater than zero, the
non-identical conversions performed by the gettext family of functions need not be the same as those that such an iconv() call would perform. If an error prevents the codeset conversion from being performed,
the gettext family of functions shall behave as if no message string was found in the messages object. If at least one
non-identical conversion is performed that results in a fallback character (one that does not provide any information about the
character it was converted from, for example, a  or "replacement-character"), the gettext family of
functions may behave as if no message string was found in the messages object.
RETURN VALUE
The gettext(), gettext_l(), dgettext(), dgettext_l(), dcgettext(), and dcgettext_l()
functions shall return the message string described in DESCRIPTION if successful. Otherwise, they shall return msgid.
The ngettext(), ngettext_l(), dngettext(), dngettext_l(), dcngettext(), and
dcngettext_l() functions shall return the message string described in DESCRIPTION if successful. Otherwise, msgid
shall be returned if n is equal to 1, or msgid_plural if n is not equal to 1.
The application shall ensure that it does not modify the returned string. A subsequent call to a gettext family function
shall not overwrite or invalidate the returned string. The returned string may be invalidated by a subsequent call to bind_textdomain_codeset(), bindtextdomain(), setlocale(), or
textdomain() in the same process, except for calls that only query values. The
returned string shall not be invalidated by a subsequent call to uselocale().
ERRORS
The gettext family of functions shall not modify errno. If an error occurs these functions shall return a string
as described in RETURN VALUE.
The following sections are informative.
EXAMPLES
The example code below assumes the following:
The implementation-defined default directory is /system/gettextlib.
The following locales are available on the target system: en_US, en_GB, de_DE. The codeset used for all of these locales is
UTF-8.
The en_AU locale is not available on the target system.
The target system supports conversion from ISO/IEC 8859-1 to UTF-8.
The codeset used for the POSIX locale is ASCII.
The target system does not support conversion from ISO/IEC 8859-1 to ASCII.
Furthermore, the following .mo files (and only the following .mo files) are installed:
/system/gettextlib/en_US/LC_MESSAGES/mail.mo
/messagecatalogs/example/en_US/LC_MESSAGES/mail.mo
These are compiled from a portable messages object source file (dot-po file) with the following ISO/IEC 8859-1 encoded contents
(see the EXTENDED DESCRIPTION of the msgfmt utility for a description of the dot-po
file format):
msgid ""
msgstr ""
"Content-Type: text/plain; charset=ISO_8859-1\n"
"Plural-Forms: nplurals=4; plural= n==1?0: (n>1&&n1&&n1&&n,
XCU gettext, msgfmt,
xgettext
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/unlink.html =====
unlink
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
unlink, unlinkat — remove a directory entry
SYNOPSIS
#include
int unlink(const char *path);
[OH] #include
int unlinkat(int fd, const char *path, int flag);
DESCRIPTION
The unlink() function shall remove the directory entry named by path and shall decrement the link count of the
file referenced by the directory entry. If path names a symbolic link, unlink() shall remove the symbolic link and
shall not affect any file named by the contents of the symbolic link.
When the file's link count becomes 0 and no process has a reference to the file via an open file descriptor or a memory mapping
(see mmap()), the space occupied by the file shall be freed and the file shall no
longer be accessible. If one or more processes have such a reference to the file when the last link is removed, the link shall be
removed before unlink() returns, but the removal of the file contents shall be postponed until there are no such references
to the file. When the space occupied by the file has been freed, the file's serial number (st_ino), and therefore the file
identity (see XBD ), shall become available for reuse.
The path argument shall not name a directory unless the process has appropriate privileges and the implementation
supports using unlink() on directories.
Upon successful completion, unlink() shall mark for update the last data modification and last file status change
timestamps of the parent directory. Also, if the file's link count is not 0, the last file status change timestamp of the file
shall be marked for update.
The unlinkat() function shall be equivalent to the unlink() or rmdir() function except in the case where path specifies a relative path. In this case
the directory entry to be removed is determined relative to the directory associated with the file descriptor fd instead of
the current working directory. If the access mode of the open file description associated with the file descriptor is not O_SEARCH,
the function shall check whether directory searches are permitted using the current permissions of the directory underlying the
file descriptor. If the access mode is O_SEARCH, the function shall not perform the check.
Values for flag are constructed by a bitwise-inclusive OR of flags from the following list, defined in :
AT_REMOVEDIR
Remove the directory entry specified by fd and path as a directory, not a normal file.
If unlinkat() is passed the special value AT_FDCWD in the fd parameter, the current working directory shall be
used and the behavior shall be identical to a call to unlink() or rmdir()
respectively, depending on whether or not the AT_REMOVEDIR bit is set in flag.
RETURN VALUE
Upon successful completion, these functions shall return 0. Otherwise, these functions shall return -1 and set errno to
indicate the error. If -1 is returned, the named file shall not be changed.
ERRORS
These functions shall fail and shall not unlink the file if:
[EACCES]
Search permission is denied for a component of the path prefix, or write permission is denied on the directory containing the
directory entry to be removed.
[EBUSY]
The file named by the path argument cannot be unlinked because it is being used by the system or another process and the
implementation considers this an error.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of path does not name an existing file or path is an empty string.
[ENOTDIR]
A component of the path prefix names an existing file that is neither a directory nor a symbolic link to a directory, or the
path argument contains at least one non- character and ends with one or more trailing  characters
and the last pathname component names an existing file that is neither a directory nor a symbolic link to a directory.
[EPERM] or [EACCES]
[XSI]
The S_ISVTX flag is set on the directory containing the file referred to by the path argument and the process does not
satisfy the criteria specified in XBD 4.5 Directory Protection.
[EROFS]
The directory entry to be unlinked is part of a read-only file system.
The unlink() function shall fail and shall not unlink the file if:
[EPERM]
The file named by path is a directory, and either the calling process does not have appropriate privileges or the
implementation prohibits using unlink() on directories.
The unlinkat() function shall fail and shall not unlink the file if:
[EACCES]
The access mode of the open file description associated with fd is not O_SEARCH and the permissions of the directory
underlying fd do not permit directory searches.
[EBADF]
The path argument does not specify an absolute path and the fd argument is neither AT_FDCWD nor a valid file
descriptor open for reading or searching.
[ENOTDIR]
The path argument is not an absolute path and fd is a file descriptor associated with a non-directory file.
[EEXIST] or [ENOTEMPTY]
The flag parameter has the AT_REMOVEDIR bit set and the path argument names a directory that is not an empty
directory, or there are hard links to the directory other than dot or a single entry in dot-dot.
[ENOTDIR]
The flag parameter has the AT_REMOVEDIR bit set and path does not name a directory.
[EPERM]
The file named by path is a directory, the flag parameter does not have the AT_REMOVEDIR bit set, and either the
calling process does not have appropriate privileges or the implementation prohibits using unlink() on directories.
These functions may fail and not unlink the file if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
[ETXTBSY]
The entry to be unlinked is the last directory entry to a pure procedure (shared text) file that is being executed.
The unlinkat() function may fail and not unlink the file if:
[EINVAL]
The value of the flag argument is not valid.
The following sections are informative.
EXAMPLES
Removing a Link to a File
The following example shows how to remove a link to a file named /home/cnd/mod1 by removing the entry named
/modules/pass1.
#include
char *path = "/modules/pass1";
int   status;
...
status = unlink(path);
Checking for an Error
The following example fragment creates a temporary password lock file named LOCKFILE, which is defined as
/etc/ptmp, and gets a file descriptor for it. If the file cannot be opened for writing, unlink() is used to remove
the link between the file descriptor and LOCKFILE.
#include
#include
#include
#include
#include
#include
#define LOCKFILE "/etc/ptmp"
int pfd;  /* Integer for file descriptor returned by open call. */
FILE *fpfd;  /* File pointer for use in putpwent(). */
...
/* Open password Lock file. If it exists, this is an error. */
if ((pfd = open(LOCKFILE, O_WRONLY| O_CREAT | O_EXCL, S_IRUSR
| S_IWUSR | S_IRGRP | S_IROTH)) == -1)  {
fprintf(stderr, "Cannot open /etc/ptmp. Try again later.\n");
exit(1);
}
/* Lock file created; proceed with fdopen of lock file so that
putpwent() can be used.
*/
if ((fpfd = fdopen(pfd, "w")) == NULL) {
close(pfd);
unlink(LOCKFILE);
exit(1);
}
Replacing Files
The following example fragment uses unlink() to discard links to files, so that they can be replaced with new versions of
the files. The first call removes the link to LOCKFILE if an error occurs. Successive calls remove the links to
SAVEFILE and PASSWDFILE so that new links can be created, then removes the link to LOCKFILE when it is no
longer needed.
#include
#include
#include
#include
#include
#include
#define LOCKFILE "/etc/ptmp"
#define PASSWDFILE "/etc/passwd"
#define SAVEFILE "/etc/opasswd"
...
/* If no change was made, assume error and leave passwd unchanged. */
if (!valid_change) {
fprintf(stderr, "Could not change password for user %s\n", user);
unlink(LOCKFILE);
exit(1);
}
/* Change permissions on new password file. */
chmod(LOCKFILE, S_IRUSR | S_IRGRP | S_IROTH);
/* Remove saved password file. */
unlink(SAVEFILE);
/* Save current password file. */
link(PASSWDFILE, SAVEFILE);
/* Remove current password file. */
unlink(PASSWDFILE);
/* Save new password file as current password file. */
link(LOCKFILE,PASSWDFILE);
/* Remove lock file. */
unlink(LOCKFILE);
exit(0);
APPLICATION USAGE
Applications should use rmdir() to remove a directory.
RATIONALE
Unlinking a directory is restricted to the superuser in many historical implementations for reasons given in link() (see also rename()).
The meaning of [EBUSY] in historical implementations is "mount point busy". Since this volume of POSIX.1-2024 does not cover
the system administration concepts of mounting and unmounting, the description of the error was changed to "resource busy". (This
meaning is used by some device drivers when a second process tries to open an exclusive use device.) The wording is also intended
to allow implementations to refuse to remove a directory if it is the root or current working directory of any process.
The standard developers reviewed TR 24715-2006 and noted that LSB-conforming implementations may return [EISDIR] instead of
[EPERM] when unlinking a directory. A change to permit this behavior by changing the requirement for [EPERM] to [EPERM] or [EISDIR]
was considered, but decided against since it would break existing strictly conforming and conforming applications. Applications
written for portability to both POSIX.1-2024 and the LSB should be prepared to handle either error code.
The purpose of the unlinkat() function is to remove directory entries in directories other than the current working
directory without exposure to race conditions. Any part of the path of a file could be changed in parallel to a call to
unlink(), resulting in unspecified behavior. By opening a file descriptor for the target directory and using the
unlinkat() function it can be guaranteed that the removed directory entry is located relative to the desired directory.
FUTURE DIRECTIONS
None.
SEE ALSO
close(), link(), remove(), rename(), rmdir(), symlink()
XBD 4.5 Directory Protection, , ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The [EBUSY] error is added to the optional part of the ERRORS section.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the DESCRIPTION, the effect is specified if path specifies a symbolic link.
The [ELOOP] mandatory error condition is added.
A second [ENAMETOOLONG] is added as an optional error condition.
The [ETXTBSY] optional error condition is added.
The following changes were made to align with the IEEE P1003.1a draft standard:
The [ELOOP] optional error condition is added.
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
Austin Group Interpretation 1003.1-2001 #143 is applied.
Austin Group Interpretation 1003.1-2001 #181 is applied, updating the requirements for operations when the S_ISVTX bit is
set.
Text arising from the LSB Conflicts TR is added to the RATIONALE about the use of [EPERM] and [EISDIR].
The unlinkat() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 2.
Changes are made related to support for finegrained timestamps.
Changes are made to allow a directory to be opened for searching.
The [ENOTDIR] error condition is clarified to cover the condition where the last component of a pathname exists but is not a
directory or a symbolic link to a directory.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0693 [461], XSH/TC1-2008/0694 [324], XSH/TC1-2008/0695 [278], and
XSH/TC1-2008/0696 [278] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0378 [873], XSH/TC2-2008/0379 [591], XSH/TC2-2008/0380 [817], and
XSH/TC2-2008/0381 [817] are applied.
Issue 8
Austin Group Defect 1314 is applied, clarifying that file identities become available for reuse after the space occupied by the
file has been freed.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
Austin Group Defect 1380 is applied, changing text using the term "link" in line with its updated definition.
Austin Group Defect 1385 is applied, clarifying that the file contents are not removed until there are no references to the file
via open file descriptors or memory mappings.
Austin Group Defect 1574 is applied, splitting the [EPERM] error into separate entries for unlink() and
unlinkat().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/gai_strerror.html =====
gai_strerror
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
gai_strerror — address and name information error description
SYNOPSIS
#include
const char *gai_strerror(int ecode);
DESCRIPTION
The gai_strerror() function shall return a text string describing an error value for the getaddrinfo() and getnameinfo()
functions listed in the  header.
When the ecode argument is one of the following values listed in the  header:
[EAI_AGAIN]
[EAI_BADFLAGS]
[EAI_FAIL]
[EAI_FAMILY]
[EAI_MEMORY]
[EAI_NONAME]
[EAI_OVERFLOW]
[EAI_SERVICE]
[EAI_SOCKTYPE]
[EAI_SYSTEM]
the function return value shall point to a string describing the error. If the argument is not one of those values,
the function shall return a pointer to a string whose contents indicate an unknown error.
RETURN VALUE
Upon successful completion, gai_strerror() shall return a pointer to an implementation-defined string.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
freeaddrinfo()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
The Open Group Base Resolution bwg2001-009 is applied, which changes the return type from char * to const
char *. This is for coordination with the IPnG Working Group.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/22 is applied, adding the [EAI_OVERFLOW] error
code.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/psiginfo.html =====
psiginfo
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
psiginfo, psignal — write signal information to standard error
SYNOPSIS
[CX]  #include
void psiginfo(const siginfo_t *pinfo, const char *message);
void psignal(int signum, const char *message);
DESCRIPTION
The psiginfo() and psignal() functions shall write a language-dependent message associated with a signal number to
the standard error stream as follows:
First, if message is not a null pointer and is not the empty string, the string pointed to by the message argument
shall be written, followed by a  and a .
Then the signal description string associated with signum or with the signal indicated by pinfo shall be written,
followed by a .
For psiginfo(), the application shall ensure that the argument pinfo references a valid siginfo_t
structure. For psignal(), if signum is not a valid signal number, the behavior is implementation-defined.
The psiginfo() and psignal() functions shall not change the orientation of the standard error stream.
The psiginfo() and psignal() functions shall mark for update the last data modification and last file status
change timestamps of the file associated with the standard error stream at some time between their successful completion and
exit(), abort(), or the completion of
fflush() or fclose() on
stderr.
The psiginfo() and psignal() functions shall not change the setting of errno if successful.
On error, the psiginfo() and psignal() functions shall set the error indicator for the stream to which
stderr points, and shall set errno to indicate the error.
Since no value is returned, an application wishing to check for error situations should set errno to 0, then call
psiginfo() or psignal(), then check errno.
RETURN VALUE
These functions shall not return a value.
ERRORS
Refer to fputc().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
As an alternative to setting errno to zero before the call and checking if it is non-zero afterwards, applications can
use ferror() to detect whether psiginfo() or psignal() encountered an
error.
An application wishing to use this method to check for error situations should call clearerr(stderr) before
calling psiginfo() or psignal(), then if ferror(stderr) returns non-zero, the value of errno
indicates which error occurred.
RATIONALE
System V historically has psignal() and psiginfo() in  . However, the
header is not specified in the Base Definitions volume of POSIX.1-2024, and the type siginfo_t is
defined in .
FUTURE DIRECTIONS
None.
SEE ALSO
fputc(), perror(), strsignal()
XBD
CHANGE HISTORY
First released in Issue 7.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0447 [399,428], XSH/TC1-2008/0448 [399], and XSH/TC1-2008/0449 [399,401] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0260 [629] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getegid.html =====
getegid
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getegid — get the effective group ID
SYNOPSIS
#include
gid_t getegid(void);
DESCRIPTION
The getegid() function shall return the effective group ID of the calling process. The getegid() function shall
not modify errno.
RETURN VALUE
The getegid() function shall always be successful and no return value is reserved to indicate an error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
In a conforming environment, getegid() will always succeed. It is possible for implementations to provide an extension
where a process in a non-conforming environment will not be associated with a user or group ID. It is recommended that such
implementations return (gid_t)-1 and set errno to indicate such an environment; doing so does not violate this
standard, since such an environment is already an extension.
FUTURE DIRECTIONS
None.
SEE ALSO
geteuid(), getgid(), getresgid(), getresuid(), getuid(), setegid(), seteuid(), setgid(), setregid(), setresgid(), setresuid(), setreuid(), setuid()
XBD ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
In the SYNOPSIS, the optional include of the  header is
removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
Issue 7
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0156 [511] is applied.
Issue 8
Austin Group Defect 1344 is applied, adding getresgid(), getresuid(), setresgid(), and setresuid() to SEE ALSO.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/alphasort.html =====
alphasort
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
alphasort, scandir — scan a directory
SYNOPSIS
#include
int alphasort(const struct dirent **d1, const struct dirent **d2);
int scandir(const char *dir, struct dirent ***namelist,
int (*sel)(const struct dirent *),
int (*compar)(const struct dirent **, const struct dirent **));
DESCRIPTION
The alphasort() function can be used as the comparison function for the scandir() function to sort the directory
entries, d1 and d2, into alphabetical order. Sorting happens as if by calling the strcoll() function on the d_name element of the dirent structures passed as
the two parameters. If the strcoll() function fails, the return value of
alphasort() is unspecified.
The alphasort() function shall not change the setting of errno if successful. Since no return value is reserved to
indicate an error, an application wishing to check for error situations should set errno to 0, then call alphasort(),
then check errno.
The scandir() function shall scan the directory dir, calling the function referenced by sel on each
directory entry. Entries for which the function referenced by sel returns non-zero shall be stored in strings allocated as
if by a call to malloc(), and sorted as if by a call to qsort() with the comparison function compar, except that compar need not provide
total ordering. The strings are collected in array namelist which shall be allocated as if by a call to malloc(). If sel is a null pointer, all entries shall be selected. If the comparison
function compar does not provide total ordering, the order in which the directory entries are stored is unspecified.
RETURN VALUE
Upon successful completion, the alphasort() function shall return an integer greater than, equal to, or less than 0,
according to whether the name of the directory entry pointed to by d1 is lexically greater than, equal to, or less than the
directory pointed to by d2 when both are interpreted as appropriate to the current locale. There is no return value reserved
to indicate an error.
Upon successful completion, the scandir() function shall return the number of entries in the array and a pointer to the
array through the parameter namelist. Otherwise, the scandir() function shall return -1.
ERRORS
The scandir() function shall fail if:
[EACCES]
Search permission is denied for the component of the path prefix of dir or read permission is denied for
dir.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the dir argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of dir does not name an existing directory or dir is an empty string.
[ENOMEM]
Insufficient storage space is available.
[ENOTDIR]
A component of dir names an existing file that is neither a directory nor a symbolic link to a directory.
[EOVERFLOW]
One of the values to be returned or passed to a callback function cannot be represented correctly.
The scandir() function may fail if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the dir argument.
[EMFILE]
All file descriptors available to the process are currently open.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
[ENFILE]
Too many files are currently open in the system.
The following sections are informative.
EXAMPLES
An example to print the files in the current directory:
#include
#include
#include
...
struct dirent **namelist;
int i,n;
n = scandir(".", &namelist, 0, alphasort);
if (n d_name);
free(namelist[i]);
}
}
free(namelist);
...
APPLICATION USAGE
If dir contains filenames that do not form character strings, or which contain characters outside the domain of the
collating sequence of the current locale, the alphasort() function need not provide a total ordering. This condition is not
possible if all filenames within the directory consist only of characters from the portable filename character set.
The scandir() function may allocate dynamic storage during its operation. If scandir() is forcibly terminated,
such as by longjmp() or siglongjmp() being executed by the function pointed to by sel or compar, or
by an interrupt routine, scandir() does not have a chance to free that storage, so it remains permanently allocated. A safe
way to handle interrupts is to store the fact that an interrupt has occurred, then wait until scandir() returns to act on
the interrupt.
For functions that allocate memory as if by malloc(), the application should
release such memory when it is no longer required by a call to free(). For
scandir(), this is namelist (including all of the individual strings in namelist).
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
qsort(), strcoll()
XBD
CHANGE HISTORY
First released in Issue 7.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0029 [324], XSH/TC1-2008/0030 [404], XSH/TC1-2008/0031 [393], and
XSH/TC1-2008/0032 [291] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/iswxdigit.html =====
iswxdigit
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
iswxdigit, iswxdigit_l — test for a hexadecimal digit wide-character code
SYNOPSIS
#include
int iswxdigit(wint_t wc);
[CX]  int iswxdigit_l(wint_t wc, locale_t locale);
DESCRIPTION
For iswxdigit(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The iswxdigit() [CX]   and iswxdigit_l()
functions shall test whether wc is a wide-character code representing a character of class xdigit in the
current locale, [CX]   or in the locale represented by locale,
respectively; see XBD 7. Locale.
The wc argument is a wint_t, the value of which the application shall ensure is a wide-character code
corresponding to a valid character in the locale used by the function, or equal to the value of the macro WEOF. If the argument has
any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to iswxdigit_l() is the special locale object LC_GLOBAL_LOCALE or is not
a valid locale object handle.
RETURN VALUE
The iswxdigit() [CX]   and iswxdigit_l()
functions shall return non-zero if wc is a hexadecimal digit wide-character code; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
iswalnum(), iswalpha(),
iswcntrl(), iswctype(),
iswdigit(), iswgraph(),
iswlower(), iswprint(),
iswpunct(), iswspace(),
iswupper(), setlocale(),
uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 4.
Issue 5
The following change has been made in this version for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E):
The SYNOPSIS has been changed to indicate that this function and associated data types are now made visible by inclusion of the
header rather than .
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The iswxdigit_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0344 [302], XSH/TC1-2008/0345 [283], and XSH/TC1-2008/0346 [283] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0193 [685] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/erfc.html =====
erfc
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
erfc, erfcf, erfcl — complementary error functions
SYNOPSIS
#include
double erfc(double x);
float erfcf(float x);
long double erfcl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complementary error function 1.0 - erf(x).
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the value of the complementary error function.
If the correct value would cause underflow, [MXX]   and is not representable,   a range error may occur, and erfc(), erfcf(), and erfcl() shall return
[MXX]
0.0, or   (if the IEC 60559 Floating-Point option is not
supported) an implementation-defined value no greater in magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, +1 shall be returned.
If x is -Inf, +2 shall be returned.
If x is +Inf, +0 shall be returned.
[MXX]
If the correct value would cause underflow and is representable, a range error may occur and the correct value shall be returned.
ERRORS
These functions may fail if:
Range Error
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The erfc() function is provided because of the extreme loss of relative accuracy if erf(x) is called for
large x and the result subtracted from 1.0.
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
erf(), feclearexcept(),
fetestexcept(), isnan()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The erfc() function is no longer marked as an extension.
These functions are split out from the erf() reference page.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0093 [68] and XSH/TC1-2008/0094 [68] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0096 [630] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fmin.html =====
fmin
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fmin, fminf, fminl — determine minimum numeric value of two floating-point numbers
SYNOPSIS
#include
double fmin(double x, double y);
float fminf(float x, float y);
long double fminl(long double x, long double y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall determine the minimum numeric value of their arguments. [MX]   NaN arguments
shall be treated as missing data: if one argument is a NaN and the other numeric, then these functions shall choose the numeric
value.
RETURN VALUE
Upon successful completion, these functions shall return the minimum numeric value of their arguments.
[MX]  The
returned value shall be exact and shall be independent of the current rounding direction mode.
If just one argument is a NaN, the other argument shall be returned.
If x and y are NaN, a NaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
fdim(), fmax()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
Austin Group Interpretation 1003.1-2001 #008 is applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wordfree.html =====
wordexp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wordexp, wordfree — perform word expansions
SYNOPSIS
#include
int wordexp(const char *restrict words, wordexp_t *restrict pwordexp,
int flags);
void wordfree(wordexp_t *pwordexp);
DESCRIPTION
The wordexp() function shall perform word expansions as described in XCU 2.6 Word Expansions, subject to quoting as described in XCU 2.2 Quoting, and place the list of expanded words into the structure pointed to
by pwordexp.
The words argument is a pointer to a string containing one or more words to be expanded. The expansions shall be the same
as would be performed by the command line interpreter if words were the part of a command line representing the arguments to
a utility. Therefore, the application shall ensure that words does not contain an unquoted  character or any
of the unquoted shell special characters '|', '&', ';', '' except in
the context of command substitution as specified in XCU 2.6.3 Command
Substitution. It also shall not contain unquoted parentheses or braces, except in the context of command or variable
substitution. The application shall ensure that every member of words which it expects to have expanded by wordexp()
does not contain an unquoted initial comment character. The application shall also ensure that any words which it intends to be
ignored (because they begin or continue a comment) are deleted from words. If the argument words contains an unquoted
comment character () that is the beginning of a token, wordexp() shall either treat the comment character
as a regular character, or interpret it as a comment indicator and ignore the remainder of words.
The structure type wordexp_t is defined in the  header
and includes at least the following members:
Member Type
Member Name
Description
size_t
we_wordc
Count of words matched by words.
char **
we_wordv
Pointer to list of expanded words.
size_t
we_offs
Slots to reserve at the beginning of pwordexp->we_wordv.
The wordexp() function shall store the number of generated words into pwordexp->we_wordc
and a pointer to a list of pointers to words in pwordexp->we_wordv. Each individual field created during field
splitting (see XCU 2.6.5 Field Splitting) or pathname expansion (see
XCU 2.6.6 Pathname Expansion) shall be a separate word in the
pwordexp->we_wordv list. The words shall be in order as described in XCU 2.6 Word Expansions. The first pointer after the last word pointer shall be a
null pointer. The expansion of special parameters described in XCU 2.5.2
Special Parameters is unspecified.
It is the caller's responsibility to allocate the storage pointed to by pwordexp. The wordexp()
function shall allocate other space as needed, including memory pointed to by pwordexp->we_wordv. The
wordfree() function shall free any memory associated with pwordexp from a previous call to wordexp(). The
wordfree() function shall not modify errno if pwordexp was previously modified by wordexp() and not yet
freed.
The flags argument is used to control the behavior of wordexp(). The value of flags is the
bitwise-inclusive OR of zero or more of the following constants, which are defined in :
WRDE_APPEND
Append words generated to the ones from a previous call to wordexp().
WRDE_DOOFFS
Make use of pwordexp->we_offs. If this flag is set, pwordexp->we_offs is used to specify how
many null pointers to add to the beginning of pwordexp->we_wordv. In other words,
pwordexp->we_wordv shall point to pwordexp->we_offs null pointers, followed by
pwordexp->we_wordc word pointers, followed by a null pointer.
WRDE_NOCMD
If the implementation supports the utilities defined in the Shell and Utilities volume of POSIX.1-2024, fail if command
substitution, as specified in XCU 2.6.3 Command Substitution, is
requested.
WRDE_REUSE
The pwordexp argument was passed to a previous successful call to wordexp(), and has not been passed to
wordfree(). The result shall be the same as if the application had called wordfree() and then called wordexp()
without WRDE_REUSE.
WRDE_SHOWERR
Do not redirect stderr to /dev/null.
WRDE_UNDEF
Report error on an attempt to expand an undefined shell variable.
The WRDE_APPEND flag can be used to append a new set of words to those generated by a previous call to
wordexp(). The following rules apply to applications when two or more calls to wordexp() are made with the same value
of pwordexp and without intervening calls to wordfree():
The first such call shall not set WRDE_APPEND. All subsequent calls shall set it.
All of the calls shall set WRDE_DOOFFS, or all shall not set it.
After the second and each subsequent call, pwordexp->we_wordv shall point to a list containing
the following:
Zero or more null pointers, as specified by WRDE_DOOFFS and pwordexp->we_offs
Pointers to the words that were in the pwordexp->we_wordv list before the call, in the same order
as before
Pointers to the new words generated by the latest call, in the specified order
The count returned in pwordexp->we_wordc shall be the total number of words from all of the
calls.
The application can change any of the fields after a call to wordexp(), but if it does it shall reset them
to the original value before a subsequent call, using the same pwordexp value, to wordfree() or wordexp() with
the WRDE_APPEND or WRDE_REUSE flag.
If the implementation supports the utilities defined in the Shell and Utilities volume of POSIX.1-2024, and
words contains an unquoted character—, '|', '&', ';', '', '(', ')', '{', '}'—in an inappropriate context, wordexp() shall fail,
and the number of expanded words shall be 0.
Unless WRDE_SHOWERR is set in flags, wordexp() shall redirect stderr to /dev/null for
any utilities executed as a result of command substitution while expanding words. If WRDE_SHOWERR is set, wordexp()
may write messages to stderr if syntax errors are detected while expanding words, unless the stderr stream has
wide orientation in which case the behavior is undefined. It is unspecified whether any write errors encountered while outputting
such messages will affect the stderr error indicator or the value of errno.
The application shall ensure that if WRDE_DOOFFS is set, then pwordexp->we_offs has the same value
for each wordexp() call and wordfree() call using a given pwordexp.
The results are unspecified if WRDE_APPEND and WRDE_REUSE are both specified.
The following constants are defined as error return values:
WRDE_BADCHAR
One of the unquoted characters—, '|', '&', ';', '',
'(', ')', '{', '}'—appears in words in an inappropriate context.
WRDE_BADVAL
Reference to undefined shell variable when WRDE_UNDEF is set in flags.
WRDE_CMDSUB
Command substitution requested when WRDE_NOCMD was set in flags.
WRDE_NOSPACE
Attempt to allocate memory failed.
WRDE_SYNTAX
Shell syntax error, such as unbalanced parentheses or unterminated string.
RETURN VALUE
Upon successful completion, wordexp() shall return 0. Otherwise, a non-zero value, as described in , shall be returned to indicate an error. If wordexp() returns the
value WRDE_NOSPACE, then pwordexp->we_wordc and pwordexp->we_wordv shall be updated to reflect
any words that were successfully expanded. In other error cases, if the WRDE_APPEND flag was specified,
pwordexp->we_wordc and pwordexp->we_wordv shall not be modified.
The wordfree() function shall not return a value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The wordexp() function is intended to be used by an application that wants to do all of the shell's expansions on a word
or words obtained from a user. For example, if the application prompts for a pathname (or list of pathnames) and then uses
wordexp() to process the input, the user could respond with anything that would be valid as input to the shell.
The WRDE_NOCMD flag is provided for applications that, for security or other reasons, want to prevent a user from
executing shell commands. Disallowing unquoted shell special characters also prevents unwanted side-effects, such as executing a
command or writing a file.
POSIX.1-2024 does not require the wordexp() function to be thread-safe if passed an expression referencing
an environment variable while any other thread is concurrently modifying any environment variable; see exec.
Even though the WRDE_SHOWERR flag allows the implementation to write messages to stderr during command
substitution or syntax errors, this standard does not provide any way to detect write failures during the output of such
messages.
Applications which use wide-character output functions with stderr should ensure that any calls to
wordexp() do not write to stderr, by avoiding use of the WRDE_SHOWERR flag.
RATIONALE
This function was included as an alternative to glob(). There had been continuing
controversy over exactly what features should be included in glob(). It is hoped that
by providing wordexp() (which provides all of the shell word expansions, but which may be slow to execute) and glob() (which is faster, but which only performs pathname expansion, without tilde or parameter
expansion) this will satisfy the majority of applications.
While wordexp() could be implemented entirely as a library routine, it is expected that most implementations
run a shell in a subprocess to do the expansion.
Two different approaches have been proposed for how the required information might be presented to the shell and
the results returned. They are presented here as examples.
One proposal is to extend the echo utility by adding a -q
option. This option would cause echo to add a  before each
and  that occurs within an argument. The wordexp() function could then invoke the shell as
follows:
(void) strcpy(buffer, "echo -q");
(void) strcat(buffer, words);
if ((flags & WRDE_SHOWERR) == 0)
(void) strcat(buffer, "2>/dev/null");
f = popen(buffer, "r");
The wordexp() function would read the resulting output, remove unquoted  characters, and
break into words at unquoted  characters. If the WRDE_NOCMD flag was set, wordexp() would have to scan
words before starting the subshell to make sure that there would be no command substitution. In any case, it would have to
scan words for unquoted special characters.
Another proposal is to add the following options to sh:
-w wordlist
This option provides a wordlist expansion service to applications. The words in wordlist shall be expanded and the following
written to standard output:
The count of the number of words after expansion, in decimal, followed by a null byte
The number of bytes needed to represent the expanded words (not including null separators), in decimal, followed
by a null byte
The expanded words, each terminated by a null byte
If an error is encountered during word expansion, sh exits with a
non-zero status after writing the former to report any words successfully expanded
-P
Run in "protected" mode. If specified with the -w option, no command substitution shall be performed.
With these options, wordexp() could be implemented fairly simply by creating a subprocess using fork() and executing sh using the line:
execl(, "sh", "-P", "-w", words, (char *)0);
after directing standard error to /dev/null.
It seemed objectionable for a library routine to write messages to standard error, unless explicitly requested, so
wordexp() is required to redirect standard error to /dev/null to ensure that no messages are generated, even for
commands executed for command substitution. The WRDE_SHOWERR flag can be specified to request that error messages be written.
The WRDE_REUSE flag allows the implementation to avoid the expense of freeing and reallocating memory, if that is
possible. A minimal implementation can call wordfree() when WRDE_REUSE is set.
FUTURE DIRECTIONS
None.
SEE ALSO
exec, fnmatch(), glob()
XBD
XCU 2. Shell Command Language
CHANGE HISTORY
First released in Issue 4. Derived from the ISO POSIX-2 standard.
Issue 5
Moved from POSIX2 C-language Binding to BASE.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
The restrict keyword is added to the wordexp() prototype for alignment with the
ISO/IEC 9899:1999 standard.
Issue 7
Austin Group Interpretation 1003.1-2001 #148 is applied, adding APPLICATION USAGE.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0739 [460], XSH/TC1-2008/0740 [291], and XSH/TC1-2008/0741
[460] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0397 [608], XSH/TC2-2008/0398 [704], XSH/TC2-2008/0399 [704],
and XSH/TC2-2008/0400 [608] are applied.
Issue 8
Austin Group Defect 385 is applied, adding a requirement that wordfree() does not modify errno when passed a
pointer to a wordexp_t that can be freed.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/rand.html =====
rand
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
rand, srand — pseudo-random number generator
SYNOPSIS
#include
int rand(void);
void srand(unsigned seed);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The rand() function shall compute a sequence of pseudo-random integers in the range [0,{RAND_MAX}] [XSI]   with a
period of at least 232.
The rand() function need not be thread-safe; however, rand() shall avoid data races with all functions other than
non-thread-safe pseudo-random sequence generation functions.
The srand() function uses the argument as a seed for a new sequence of pseudo-random numbers to be returned by subsequent
calls to rand(). If srand() is then called with the same seed value, the sequence of pseudo-random numbers shall be
repeated. If rand() is called before any calls to srand() are made, the same sequence shall be generated as when
srand() is first called with a seed value of 1.
The srand() function need not be thread-safe; however, srand() shall avoid data races with all functions other
than non-thread-safe pseudo-random sequence generation functions.
The implementation shall behave as if no function defined in this volume of POSIX.1-2024 calls rand() or
srand().
RETURN VALUE
The rand() function shall return the next pseudo-random number in the sequence.
The srand() function shall not return a value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
Generating a Pseudo-Random Number Sequence
The following example demonstrates how to generate a sequence of pseudo-random numbers.
#include
#include
...
long count, i;
char *keystr;
int elementlen, len;
char c;
...
/* Initial random number generator. */
srand(1);
/* Create keys using only lowercase characters */
len = 0;
for (i=0; i
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The rand_r() function is included for alignment with the POSIX Threads Extension.
A note indicating that the rand() function need not be reentrant is added to the DESCRIPTION.
Issue 6
Extensions beyond the ISO C standard are marked.
The rand_r() function is marked as part of the Thread-Safe Functions option.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
The rand_r() function is marked obsolescent.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0301 [743] is applied.
Issue 8
Austin Group Defect 1134 is applied, adding getentropy().
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_rwlock_unlock.html =====
pthread_rwlock_unlock
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_rwlock_unlock — unlock a read-write lock object
SYNOPSIS
#include
int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
DESCRIPTION
The pthread_rwlock_unlock() function shall release a lock held on the read-write lock object referenced by rwlock.
Results are undefined if the read-write lock rwlock is not held by the calling thread.
If this function is called to release a read lock from the read-write lock object and there are other read locks currently held
on this read-write lock object, the read-write lock object remains in the read locked state. If this function releases the last
read lock for this read-write lock object, the read-write lock object shall be put in the unlocked state with no owners.
If this function is called to release a write lock for this read-write lock object, the read-write lock object shall be put in
the unlocked state.
If there are threads blocked on the lock when it becomes available, the scheduling policy shall determine which thread(s) shall
acquire the lock. [TPS]   If the Thread Execution Scheduling option is supported, when threads executing with the
scheduling policies SCHED_FIFO, SCHED_RR, or SCHED_SPORADIC are waiting on the lock, they shall acquire the lock in priority order
when the lock becomes available. For equal priority threads, write locks shall take precedence over read locks.  If the Thread Execution Scheduling option is not supported, it is
implementation-defined whether write locks take precedence over read locks.
Results are undefined if this function is called with an uninitialized read-write lock.
RETURN VALUE
If successful, the pthread_rwlock_unlock() function shall return zero; otherwise, an error number shall be returned to
indicate the error.
ERRORS
The pthread_rwlock_unlock() function shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
If an implementation detects that the value specified by the rwlock argument to pthread_rwlock_unlock() does not
refer to an initialized read-write lock object, it is recommended that the function should fail and report an [EINVAL] error.
If an implementation detects that the value specified by the rwlock argument to pthread_rwlock_unlock() refers to
a read-write lock object for which the current thread does not hold a lock, it is recommended that the function should fail and
report an [EPERM] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_rwlock_clockrdlock(), pthread_rwlock_clockwrlock(), pthread_rwlock_destroy(), pthread_rwlock_rdlock(), pthread_rwlock_trywrlock()
XBD 4.15.2 Memory Synchronization,
CHANGE HISTORY
First released in Issue 5.
Issue 6
The following changes are made for alignment with IEEE Std 1003.1j-2000:
The margin code in the SYNOPSIS is changed to THR to indicate that the functionality is now part of the Threads option
(previously it was part of the Read-Write Locks option in IEEE Std 1003.1j-2000 and also part of the XSI extension).
The DESCRIPTION is updated as follows:
The conditions under which writers have precedence over readers are specified.
The concept of read-write lock owner is deleted.
The SEE ALSO section is updated.
Issue 7
SD5-XSH-ERN-183 is applied.
The pthread_rwlock_unlock() function is moved from the Threads option to the Base.
The [EINVAL] error for an uninitialized read-write lock object is removed; this condition results in undefined behavior.
The [EPERM] error for a read-write lock object for which the current thread does not hold a lock is removed; this condition
results in undefined behavior.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fdim.html =====
fdim
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fdim, fdimf, fdiml — compute positive difference between two floating-point numbers
SYNOPSIS
#include
double fdim(double x, double y);
float fdimf(float x, float y);
long double fdiml(long double x, long double y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall determine the positive difference between their arguments. If x is greater than y,
x-y is returned. If x is less than or equal to y, +0 is returned.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the positive difference value.
If x-y is positive and overflows, a range error shall occur and fdim(), fdimf(), and fdiml()
shall return the value of the macro HUGE_VAL, HUGE_VALF, and HUGE_VALL, respectively.
If the correct value would cause underflow, a range error may occur, and fdim(), fdimf(), and fdiml() shall
return [MXX]   the correct value, or   (if the IEC 60559
Floating-Point option is not supported) an implementation-defined value no greater in magnitude than DBL_MIN, FLT_MIN, and
LDBL_MIN, respectively.
[MX]  If
x or y is NaN, a NaN shall be returned.
ERRORS
The fdim() function shall fail if:
Range Error
The result overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
The fdim() function may fail if:
Range Error
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), fmax(), fmin()
4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0119 [68,428] and XSH/TC1-2008/0120 [68,428] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/feclearexcept.html =====
feclearexcept
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
feclearexcept — clear floating-point exception
SYNOPSIS
#include
int feclearexcept(int excepts);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The feclearexcept() function shall attempt to clear the supported floating-point exceptions represented by
excepts.
RETURN VALUE
If the argument is zero or if all the specified exceptions were successfully cleared, feclearexcept() shall return zero.
Otherwise, it shall return a non-zero value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
fegetexceptflag(), feraiseexcept(), fetestexcept()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
ISO/IEC 9899:1999 standard, Technical Corrigendum 1 is incorporated.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_rwlock_wrlock.html =====
pthread_rwlock_trywrlock
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_rwlock_trywrlock, pthread_rwlock_wrlock — lock a read-write lock object for writing
SYNOPSIS
#include
int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
DESCRIPTION
The pthread_rwlock_trywrlock() function shall apply a write lock like the pthread_rwlock_wrlock() function, with
the exception that the function shall fail if any thread currently holds rwlock (for reading or writing).
The pthread_rwlock_wrlock() function shall apply a write lock to the read-write lock referenced by rwlock. The
calling thread shall acquire the write lock if no thread (reader or writer) holds the read-write lock rwlock. Otherwise, if
another thread holds the read-write lock rwlock, the calling thread shall block until it can acquire the lock. If a deadlock
condition occurs or the calling thread already owns the read-write lock for writing or reading, the call shall either deadlock or
return [EDEADLK].
Results are undefined if any of these functions are called with an uninitialized read-write lock.
If a signal is delivered to a thread waiting for a read-write lock for writing, upon return from the signal handler the thread
resumes waiting for the read-write lock for writing as if it was not interrupted.
RETURN VALUE
The pthread_rwlock_trywrlock() function shall return zero if the lock for writing on the read-write lock object
referenced by rwlock is acquired. Otherwise, an error number shall be returned to indicate the error.
If successful, the pthread_rwlock_wrlock() function shall return zero; otherwise, an error number shall be returned to
indicate the error.
ERRORS
The pthread_rwlock_trywrlock() function shall fail if:
[EBUSY]
The read-write lock could not be acquired for writing because it was already locked for reading or writing.
The pthread_rwlock_wrlock() function may fail if:
[EDEADLK]
A deadlock condition was detected or the current thread already owns the read-write lock for writing or reading.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications using these functions may be subject to priority inversion, as discussed in XBD 3.275 Priority Inversion.
RATIONALE
If an implementation detects that the value specified by the rwlock argument to pthread_rwlock_trywrlock() or
pthread_rwlock_wrlock() does not refer to an initialized read-write lock object, it is recommended that the function should
fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_rwlock_clockrdlock(), pthread_rwlock_clockwrlock(), pthread_rwlock_destroy(), pthread_rwlock_rdlock(), pthread_rwlock_unlock()
XBD 3.275 Priority Inversion, 4.15.2 Memory Synchronization,
CHANGE HISTORY
First released in Issue 5.
Issue 6
The following changes are made for alignment with IEEE Std 1003.1j-2000:
The margin code in the SYNOPSIS is changed to THR to indicate that the functionality is now part of the Threads option
(previously it was part of the Read-Write Locks option in IEEE Std 1003.1j-2000 and also part of the XSI extension).
The [EDEADLK] error is deleted as a pthread_rwlock_trywrlock() error.
The SEE ALSO section is updated.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/104 is applied, updating the ERRORS section so that the
[EDEADLK] error includes detection of a deadlock condition.
Issue 7
The pthread_rwlock_trywrlock() and pthread_rwlock_wrlock() functions are moved from the Threads option to the
Base.
The [EINVAL] error for an uninitialized read-write lock object is removed; this condition results in undefined behavior.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0290 [720] and XSH/TC2-2008/0291 [722] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/lchown.html =====
lchown
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
lchown — change the owner and group of a symbolic link
SYNOPSIS
#include
int lchown(const char *path, uid_t owner, gid_t group);
DESCRIPTION
The lchown() function shall be equivalent to chown(), except in the case
where the named file is a symbolic link. In this case, lchown() shall change the ownership of the symbolic link file itself,
while chown() changes the ownership of the file or directory to which the symbolic
link refers.
RETURN VALUE
Upon successful completion, lchown() shall return 0. Otherwise, it shall return -1 and set errno to indicate an
error.
ERRORS
The lchown() function shall fail if:
[EACCES]
Search permission is denied on a component of the path prefix of path.
[EINVAL]
The owner or group ID is not a value supported by the implementation.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of path does not name an existing file or path is an empty string.
[ENOTDIR]
A component of the path prefix names an existing file that is neither a directory nor a symbolic link to a directory, or the
path argument contains at least one non- character and ends with one or more trailing  characters
and the last pathname component names an existing file that is neither a directory nor a symbolic link to a directory.
[EPERM]
The effective user ID does not match the owner of the file and the process does not have appropriate privileges.
[EROFS]
The file resides on a read-only file system.
The lchown() function may fail if:
[EIO]
An I/O error occurred while reading or writing to the file system.
[EINTR]
A signal was caught during execution of the function.
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
The following sections are informative.
EXAMPLES
Changing the Current Owner of a File
The following example shows how to change the ownership of the symbolic link named /modules/pass1 to the user ID
associated with "jones" and the group ID associated with "cnd".
The numeric value for the user ID is obtained by using the getpwnam() function.
The numeric value for the group ID is obtained by using the getgrnam()
function.
#include
#include
#include
#include
struct passwd *pwd;
struct group  *grp;
char          *path = "/modules/pass1";
...
pwd = getpwnam("jones");
grp = getgrnam("cnd");
lchown(path, pwd->pw_uid, grp->gr_gid);
APPLICATION USAGE
On implementations which support symbolic links as directory entries rather than files, lchown() may fail.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
chown(), symlink()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The wording of the mandatory [ELOOP] error condition is updated, and a second optional [ELOOP] error condition is added.
The Open Group Base Resolution bwg2001-013 is applied, adding wording to the APPLICATION USAGE.
Issue 7
Austin Group Interpretation 1003.1-2001 #143 is applied.
The lchown() function is moved from the XSI option to the Base.
The [EOPNOTSUPP] error is removed.
The [ENOTDIR] error condition is clarified to cover the condition where the last component of a pathname exists but is not a
directory or a symbolic link to a directory.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0351 [324] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ungetwc.html =====
ungetwc
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ungetwc — push wide-character code back into the input stream
SYNOPSIS
#include
#include
wint_t ungetwc(wint_t wc, FILE *stream);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The ungetwc() function shall push the character corresponding to the wide-character code specified by wc back onto
the input stream pointed to by stream. The pushed-back characters shall be returned by subsequent reads on that stream in
the reverse order of their pushing. A successful intervening call (with the stream pointed to by stream) to a
file-positioning function (fseek(), [CX]   fseeko(),  fsetpos(), or rewind()) [CX]  or fflush()   shall discard
any pushed-back characters for the stream. The external storage corresponding to the stream is unchanged.
At least one character of push-back shall be provided. If ungetwc() is called too many times on the same stream without
an intervening read or file-positioning operation on that stream, the operation may fail.
If the value of wc equals that of the macro WEOF, the operation shall fail and the input stream shall be left
unchanged.
A successful call to ungetwc() shall clear the end-of-file indicator for the stream. The value of the file-position
indicator for the stream after a successful call to ungetwc() is unspecified until all pushed-back wide characters are read
or discarded; its value after all pushed-back wide characters have been read shall be the same as it was before the wide characters
were pushed back.
RETURN VALUE
Upon successful completion, ungetwc() shall return the wide-character code corresponding to the pushed-back character.
Otherwise, it shall return WEOF.
ERRORS
The ungetwc() function may fail if:
[EILSEQ]
[CX]  An
invalid character sequence is detected, or a wide-character code does not correspond to a valid character.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The ISO C standard includes the text "The value of the file position indicator for the stream after reading or discarding
all pushed-back wide characters shall be the same as it was before the wide characters were pushed back." POSIX.1 omits "or
discarding" from this because it is redundant—in the ISO C standard the discarding is done by file positioning functions and
does not affect the position set by those functions. In particular, a relative seek using fseek() or fseeko() with SEEK_CUR adjusts the
position relative to the position on entry to the function, not the position after the pushed-back wide characters have been
discarded. POSIX.1 also requires fflush() to discard pushed back wide characters in
situations where the ISO C standard says the behavior of fflush() is
undefined.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fseek(), fsetpos(), read(), rewind(), setbuf()
XBD ,
CHANGE HISTORY
First released in Issue 4. Derived from the MSE working draft.
Issue 5
The Optional Header (OH) marking is removed from .
Issue 6
The [EILSEQ] optional error condition is marked CX.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0690 [87,93], XSH/TC1-2008/0691 [87], and XSH/TC1-2008/0692 [14] are
applied.
Issue 8
Austin Group Defect 701 is applied, clarifying how the file-position indicator for the stream is updated.
Austin Group Defect 1374 is applied, correcting a conflict with the ISO C standard regarding the value of the file-position
indicator for the stream after a successful call to ungetwc().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/yn.html =====
y0
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
y0, y1, yn — Bessel functions of the second kind
SYNOPSIS
[XSI]  #include
double y0(double x);
double y1(double x);
double yn(int n, double x);
DESCRIPTION
The y0(), y1(), and yn() functions shall compute Bessel functions of x of the second kind of orders
0, 1, and n, respectively. y0(x) shall be equivalent to yn(0, x), and y1(x) shall
be equivalent to yn(1, x).
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the relevant Bessel value of x of the second kind.
[MXX]
If x is NaN, NaN shall be returned.
If the x argument to these functions is negative, [MXX]   either NaN (if supported) or  the same return value as when x is 0.0 (see below) shall be returned, and a domain error may
occur.
If x is 0.0, y0() and y1() shall return -HUGE_VAL and a pole error may occur. If x is 0.0 and
n is not both negative and odd, yn() shall return -HUGE_VAL and a pole error may occur. If x is 0.0 and
n is negative and odd, yn() shall return +HUGE_VAL and a pole error may occur.
[MXX]
If x is +Inf, +0 shall be returned.
If the correct result would cause underflow [MXX]   and is not representable,  a range error may occur, and the function shall return [MXX]   0.0, or
(if the IEC 60559 Floating-Point option is not supported) an
implementation-defined value no greater in magnitude than DBL_MIN.
[MXX]  If
the correct result would cause underflow, and is representable, a range error may occur and the correct value shall be returned.
If the correct result of calling y1() would cause overflow, -HUGE_VAL shall be returned and a range error may occur. If
n is not both negative and odd, and the correct result of calling yn() would cause overflow, -HUGE_VAL shall be
returned and a range error may occur. If n is negative and odd, and the correct result of calling yn() would cause
overflow, +HUGE_VAL shall be returned and a range error may occur.
ERRORS
These functions may fail if:
Domain Error
The value of x is negative.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
Pole Error
The value of x is zero.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the divide-by-zero floating-point exception shall
be raised.
Range Error
The value of x is too large in magnitude, or the correct result would cause underflow.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The y1() and yn() functions may fail if:
Range Error
The correct result would cause overflow.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), isnan(), j0()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
The RETURN VALUE and ERRORS sections are reworked for alignment of the error handling with the ISO/IEC 9899:1999
standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/148 is applied, updating the RETURN VALUE and ERRORS sections.
The changes are made for consistency with the general rules stated in "Treatment of Error Conditions for Mathematical Functions"
in the Base Definitions volume of POSIX.1-2024.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0746 [68] is applied.
Issue 8
Austin Group Defect 714 is applied, changing the behavior of these functions for special cases to be a better match for their
mathematical behavior.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/unlinkat.html =====
unlink
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
unlink, unlinkat — remove a directory entry
SYNOPSIS
#include
int unlink(const char *path);
[OH] #include
int unlinkat(int fd, const char *path, int flag);
DESCRIPTION
The unlink() function shall remove the directory entry named by path and shall decrement the link count of the
file referenced by the directory entry. If path names a symbolic link, unlink() shall remove the symbolic link and
shall not affect any file named by the contents of the symbolic link.
When the file's link count becomes 0 and no process has a reference to the file via an open file descriptor or a memory mapping
(see mmap()), the space occupied by the file shall be freed and the file shall no
longer be accessible. If one or more processes have such a reference to the file when the last link is removed, the link shall be
removed before unlink() returns, but the removal of the file contents shall be postponed until there are no such references
to the file. When the space occupied by the file has been freed, the file's serial number (st_ino), and therefore the file
identity (see XBD ), shall become available for reuse.
The path argument shall not name a directory unless the process has appropriate privileges and the implementation
supports using unlink() on directories.
Upon successful completion, unlink() shall mark for update the last data modification and last file status change
timestamps of the parent directory. Also, if the file's link count is not 0, the last file status change timestamp of the file
shall be marked for update.
The unlinkat() function shall be equivalent to the unlink() or rmdir() function except in the case where path specifies a relative path. In this case
the directory entry to be removed is determined relative to the directory associated with the file descriptor fd instead of
the current working directory. If the access mode of the open file description associated with the file descriptor is not O_SEARCH,
the function shall check whether directory searches are permitted using the current permissions of the directory underlying the
file descriptor. If the access mode is O_SEARCH, the function shall not perform the check.
Values for flag are constructed by a bitwise-inclusive OR of flags from the following list, defined in :
AT_REMOVEDIR
Remove the directory entry specified by fd and path as a directory, not a normal file.
If unlinkat() is passed the special value AT_FDCWD in the fd parameter, the current working directory shall be
used and the behavior shall be identical to a call to unlink() or rmdir()
respectively, depending on whether or not the AT_REMOVEDIR bit is set in flag.
RETURN VALUE
Upon successful completion, these functions shall return 0. Otherwise, these functions shall return -1 and set errno to
indicate the error. If -1 is returned, the named file shall not be changed.
ERRORS
These functions shall fail and shall not unlink the file if:
[EACCES]
Search permission is denied for a component of the path prefix, or write permission is denied on the directory containing the
directory entry to be removed.
[EBUSY]
The file named by the path argument cannot be unlinked because it is being used by the system or another process and the
implementation considers this an error.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of path does not name an existing file or path is an empty string.
[ENOTDIR]
A component of the path prefix names an existing file that is neither a directory nor a symbolic link to a directory, or the
path argument contains at least one non- character and ends with one or more trailing  characters
and the last pathname component names an existing file that is neither a directory nor a symbolic link to a directory.
[EPERM] or [EACCES]
[XSI]
The S_ISVTX flag is set on the directory containing the file referred to by the path argument and the process does not
satisfy the criteria specified in XBD 4.5 Directory Protection.
[EROFS]
The directory entry to be unlinked is part of a read-only file system.
The unlink() function shall fail and shall not unlink the file if:
[EPERM]
The file named by path is a directory, and either the calling process does not have appropriate privileges or the
implementation prohibits using unlink() on directories.
The unlinkat() function shall fail and shall not unlink the file if:
[EACCES]
The access mode of the open file description associated with fd is not O_SEARCH and the permissions of the directory
underlying fd do not permit directory searches.
[EBADF]
The path argument does not specify an absolute path and the fd argument is neither AT_FDCWD nor a valid file
descriptor open for reading or searching.
[ENOTDIR]
The path argument is not an absolute path and fd is a file descriptor associated with a non-directory file.
[EEXIST] or [ENOTEMPTY]
The flag parameter has the AT_REMOVEDIR bit set and the path argument names a directory that is not an empty
directory, or there are hard links to the directory other than dot or a single entry in dot-dot.
[ENOTDIR]
The flag parameter has the AT_REMOVEDIR bit set and path does not name a directory.
[EPERM]
The file named by path is a directory, the flag parameter does not have the AT_REMOVEDIR bit set, and either the
calling process does not have appropriate privileges or the implementation prohibits using unlink() on directories.
These functions may fail and not unlink the file if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
[ETXTBSY]
The entry to be unlinked is the last directory entry to a pure procedure (shared text) file that is being executed.
The unlinkat() function may fail and not unlink the file if:
[EINVAL]
The value of the flag argument is not valid.
The following sections are informative.
EXAMPLES
Removing a Link to a File
The following example shows how to remove a link to a file named /home/cnd/mod1 by removing the entry named
/modules/pass1.
#include
char *path = "/modules/pass1";
int   status;
...
status = unlink(path);
Checking for an Error
The following example fragment creates a temporary password lock file named LOCKFILE, which is defined as
/etc/ptmp, and gets a file descriptor for it. If the file cannot be opened for writing, unlink() is used to remove
the link between the file descriptor and LOCKFILE.
#include
#include
#include
#include
#include
#include
#define LOCKFILE "/etc/ptmp"
int pfd;  /* Integer for file descriptor returned by open call. */
FILE *fpfd;  /* File pointer for use in putpwent(). */
...
/* Open password Lock file. If it exists, this is an error. */
if ((pfd = open(LOCKFILE, O_WRONLY| O_CREAT | O_EXCL, S_IRUSR
| S_IWUSR | S_IRGRP | S_IROTH)) == -1)  {
fprintf(stderr, "Cannot open /etc/ptmp. Try again later.\n");
exit(1);
}
/* Lock file created; proceed with fdopen of lock file so that
putpwent() can be used.
*/
if ((fpfd = fdopen(pfd, "w")) == NULL) {
close(pfd);
unlink(LOCKFILE);
exit(1);
}
Replacing Files
The following example fragment uses unlink() to discard links to files, so that they can be replaced with new versions of
the files. The first call removes the link to LOCKFILE if an error occurs. Successive calls remove the links to
SAVEFILE and PASSWDFILE so that new links can be created, then removes the link to LOCKFILE when it is no
longer needed.
#include
#include
#include
#include
#include
#include
#define LOCKFILE "/etc/ptmp"
#define PASSWDFILE "/etc/passwd"
#define SAVEFILE "/etc/opasswd"
...
/* If no change was made, assume error and leave passwd unchanged. */
if (!valid_change) {
fprintf(stderr, "Could not change password for user %s\n", user);
unlink(LOCKFILE);
exit(1);
}
/* Change permissions on new password file. */
chmod(LOCKFILE, S_IRUSR | S_IRGRP | S_IROTH);
/* Remove saved password file. */
unlink(SAVEFILE);
/* Save current password file. */
link(PASSWDFILE, SAVEFILE);
/* Remove current password file. */
unlink(PASSWDFILE);
/* Save new password file as current password file. */
link(LOCKFILE,PASSWDFILE);
/* Remove lock file. */
unlink(LOCKFILE);
exit(0);
APPLICATION USAGE
Applications should use rmdir() to remove a directory.
RATIONALE
Unlinking a directory is restricted to the superuser in many historical implementations for reasons given in link() (see also rename()).
The meaning of [EBUSY] in historical implementations is "mount point busy". Since this volume of POSIX.1-2024 does not cover
the system administration concepts of mounting and unmounting, the description of the error was changed to "resource busy". (This
meaning is used by some device drivers when a second process tries to open an exclusive use device.) The wording is also intended
to allow implementations to refuse to remove a directory if it is the root or current working directory of any process.
The standard developers reviewed TR 24715-2006 and noted that LSB-conforming implementations may return [EISDIR] instead of
[EPERM] when unlinking a directory. A change to permit this behavior by changing the requirement for [EPERM] to [EPERM] or [EISDIR]
was considered, but decided against since it would break existing strictly conforming and conforming applications. Applications
written for portability to both POSIX.1-2024 and the LSB should be prepared to handle either error code.
The purpose of the unlinkat() function is to remove directory entries in directories other than the current working
directory without exposure to race conditions. Any part of the path of a file could be changed in parallel to a call to
unlink(), resulting in unspecified behavior. By opening a file descriptor for the target directory and using the
unlinkat() function it can be guaranteed that the removed directory entry is located relative to the desired directory.
FUTURE DIRECTIONS
None.
SEE ALSO
close(), link(), remove(), rename(), rmdir(), symlink()
XBD 4.5 Directory Protection, , ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The [EBUSY] error is added to the optional part of the ERRORS section.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the DESCRIPTION, the effect is specified if path specifies a symbolic link.
The [ELOOP] mandatory error condition is added.
A second [ENAMETOOLONG] is added as an optional error condition.
The [ETXTBSY] optional error condition is added.
The following changes were made to align with the IEEE P1003.1a draft standard:
The [ELOOP] optional error condition is added.
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
Austin Group Interpretation 1003.1-2001 #143 is applied.
Austin Group Interpretation 1003.1-2001 #181 is applied, updating the requirements for operations when the S_ISVTX bit is
set.
Text arising from the LSB Conflicts TR is added to the RATIONALE about the use of [EPERM] and [EISDIR].
The unlinkat() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 2.
Changes are made related to support for finegrained timestamps.
Changes are made to allow a directory to be opened for searching.
The [ENOTDIR] error condition is clarified to cover the condition where the last component of a pathname exists but is not a
directory or a symbolic link to a directory.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0693 [461], XSH/TC1-2008/0694 [324], XSH/TC1-2008/0695 [278], and
XSH/TC1-2008/0696 [278] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0378 [873], XSH/TC2-2008/0379 [591], XSH/TC2-2008/0380 [817], and
XSH/TC2-2008/0381 [817] are applied.
Issue 8
Austin Group Defect 1314 is applied, clarifying that file identities become available for reuse after the space occupied by the
file has been freed.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
Austin Group Defect 1380 is applied, changing text using the term "link" in line with its updated definition.
Austin Group Defect 1385 is applied, clarifying that the file contents are not removed until there are no references to the file
via open file descriptors or memory mappings.
Austin Group Defect 1574 is applied, splitting the [EPERM] error into separate entries for unlink() and
unlinkat().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_condattr_setclock.html =====
pthread_condattr_getclock
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_condattr_getclock, pthread_condattr_setclock — get and set the clock selection condition variable
attribute
SYNOPSIS
#include
int pthread_condattr_getclock(const pthread_condattr_t *restrict attr,
clockid_t *restrict clock_id);
int pthread_condattr_setclock(pthread_condattr_t *attr,
clockid_t clock_id);
DESCRIPTION
The pthread_condattr_getclock() function shall obtain the value of the clock attribute from the attributes object
referenced by attr.
The pthread_condattr_setclock() function shall set the clock attribute in an initialized attributes object
referenced by attr. If pthread_condattr_setclock() is called with a clock_id argument that refers to a
CPU-time clock, the call shall fail.
The clock attribute is the clock ID of the clock that shall be used to measure the timeout service of pthread_cond_timedwait(). The default value of the clock attribute
shall refer to the system clock. The clock attribute shall have no effect on the pthread_cond_clockwait() function.
The behavior is undefined if the value specified by the attr argument to pthread_condattr_getclock() or
pthread_condattr_setclock() does not refer to an initialized condition variable attributes object.
RETURN VALUE
If successful, the pthread_condattr_getclock() function shall return zero and store the value of the clock attribute of
attr into the object referenced by the clock_id argument. Otherwise, an error number shall be returned to indicate
the error.
If successful, the pthread_condattr_setclock() function shall return zero; otherwise, an error number shall be returned
to indicate the error.
ERRORS
The pthread_condattr_setclock() function may fail if:
[EINVAL]
The value specified by clock_id does not refer to a known clock, or is a CPU-time clock.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
If an implementation detects that the value specified by the attr argument to pthread_condattr_getclock() or
pthread_condattr_setclock() does not refer to an initialized condition variable attributes object, it is recommended that
the function should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_cond_clockwait(), pthread_cond_destroy(), pthread_condattr_destroy(), pthread_condattr_getpshared(), pthread_create(), pthread_mutex_destroy()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1j-2000.
Issue 7
The pthread_condattr_getclock() and pthread_condattr_setclock() functions are moved from the Clock Selection
option to the Base.
The [EINVAL] error for an uninitialized condition variable attributes object is removed; this condition results in undefined
behavior.
Issue 8
Austin Group Defect 1216 is applied, adding pthread_cond_clockwait().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atomic_fetch_add_explicit.html =====
atomic_fetch_add
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atomic_fetch_add, atomic_fetch_add_explicit, atomic_fetch_and, atomic_fetch_and_explicit, atomic_fetch_or,
atomic_fetch_or_explicit, atomic_fetch_sub, atomic_fetch_sub_explicit, atomic_fetch_xor, atomic_fetch_xor_explicit — atomically
replace the value of an object with the result of a computation
SYNOPSIS
#include
C atomic_fetch_add(volatile A *object, M operand); C
atomic_fetch_add_explicit(volatile A *object, M operand,
memory_order order); C atomic_fetch_and(volatile A
*object, M operand); C atomic_fetch_and_explicit(volatile A
*object, M operand,
memory_order order); C atomic_fetch_or(volatile A
*object, M operand); C atomic_fetch_or_explicit(volatile A
*object, M operand,
memory_order order); C atomic_fetch_sub(volatile A
*object, M operand); C atomic_fetch_sub_explicit(volatile A
*object, M operand,
memory_order order); C atomic_fetch_xor(volatile A
*object, M operand); C atomic_fetch_xor_explicit(volatile A
*object, M operand,
memory_order order);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
Implementations that define the macro __STDC_NO_ATOMICS__ need not provide the  header nor support these generic functions.
The atomic_fetch_add_explicit() generic function shall atomically replace the value pointed to by object with the
result of adding operand to this value. This operation shall be an atomic read-modify-write operation (see XBD 4.15.1 Memory Ordering). Memory shall be affected according to the value of
order.
The atomic_fetch_add() generic function shall be equivalent to atomic_fetch_add_explicit() called with
order set to memory_order_seq_cst.
The other atomic_fetch_*() generic functions shall be equivalent to atomic_fetch_add_explicit() if their name ends
with explicit, or to atomic_fetch_add() if it does not, respectively, except that they perform the computation
indicated in their name, instead of addition:
sub
subtraction
or
bitwise inclusive OR
xor
bitwise exclusive OR
and
bitwise AND
For addition and subtraction, the application shall ensure that A is an atomic integer type or an atomic pointer type and is not
atomic_bool. For the other operations, the application shall ensure that A is an atomic integer type and is not
atomic_bool.
For signed integer types, the computation shall silently wrap around on overflow; there are no undefined results. For pointer
types, the result can be an undefined address, but the computations otherwise have no undefined behavior.
RETURN VALUE
These generic functions shall return the value pointed to by object immediately before the effects.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The operation of these generic functions is nearly equivalent to the operation of the corresponding compound assignment
operators +=, -=, etc. The only differences are that the compound assignment operators are not guaranteed to
operate atomically, and the value yielded by a compound assignment operator is the updated value of the object, whereas the value
returned by these generic functions is the previous value of the atomic object.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD 4.15.1 Memory Ordering,
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/posix_spawn_file_actions_addopen.html =====
posix_spawn_file_actions_addclose
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
posix_spawn_file_actions_addclose, posix_spawn_file_actions_addopen — add close or open action to spawn file actions
object (ADVANCED REALTIME)
SYNOPSIS
[SPN]  #include
int posix_spawn_file_actions_addclose(posix_spawn_file_actions_t
*file_actions, int fildes);
int posix_spawn_file_actions_addopen(posix_spawn_file_actions_t
*restrict file_actions, int fildes,
const char *restrict path, int oflag, mode_t
mode);
DESCRIPTION
These functions shall add a close or open action to a spawn file actions object.
A spawn file actions object is of type posix_spawn_file_actions_t (defined in ) and is used to specify a series of actions to be performed by a posix_spawn() or posix_spawnp()
operation in order to arrive at the set of open file descriptors for the child process given the set of open file descriptors of
the parent. POSIX.1-2024 does not define comparison or assignment operators for the type posix_spawn_file_actions_t.
A spawn file actions object, when passed to posix_spawn() or posix_spawnp(), shall specify how the set of open file descriptors in the calling
process is transformed into a set of potentially open file descriptors for the spawned process. This transformation shall be as if
the specified sequence of actions was performed exactly once, in the context of the spawned process (prior to execution of the new
process image), in the order in which the actions were added to the object; additionally, when the new process image is executed,
any file descriptor (from this new set) which has its FD_CLOEXEC flag set shall be closed (see posix_spawn()).
The posix_spawn_file_actions_addclose() function shall add a close action to the object referenced by
file_actions that shall cause the file descriptor fildes to be closed (as if close(fildes) had been
called) when a new process is spawned using this file actions object, except that a non-negative fildes less than {OPEN_MAX}
that is already closed at the time when the new process is spawned shall be ignored rather than failing with [EBADF].
The posix_spawn_file_actions_addopen() function shall add an open action to the object referenced by
file_actions that shall cause the file named by path to be opened (as if open(path, oflag,
mode) had been called, and the returned file descriptor, if not fildes, had been changed to fildes) when a new
process is spawned using this file actions object. If fildes was already an open file descriptor, it shall be closed before
the new file is opened. A relative path shall be interpreted in relation to the working directory determined by any prior
actions.
The string pointed to by path shall be copied by the posix_spawn_file_actions_addopen() function.
RETURN VALUE
Upon successful completion, these functions shall return zero; otherwise, an error number shall be returned to indicate the
error.
ERRORS
The posix_spawn_file_actions_addopen() function shall fail if:
[EBADF]
The value specified by fildes is negative or greater than or equal to {OPEN_MAX}.
The posix_spawn_file_actions_addclose() function shall fail if:
[EBADF]
The value specified by fildes is negative.
These functions shall fail if:
[ENOMEM]
Insufficient memory exists to add to the spawn file actions object.
These functions may fail if:
[EINVAL]
The value specified by file_actions is invalid.
It shall not be considered an error for the fildes argument passed to these functions to specify a file descriptor for
which the specified operation could not be performed at the time of the call. Any such error shall be detected when the associated
file actions object is later used during a posix_spawn() or posix_spawnp() operation.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
These functions are part of the Spawn option and need not be provided on all implementations.
Implementations may use file descriptors that must be inherited into child processes for the child process to remain conforming,
such as for message catalog or tracing purposes. Therefore, an application that calls posix_spawn_file_actions_addclose()
with an arbitrary integer risks non-conforming behavior, and this function can only portably be used to close file descriptor
values that the application has obtained through explicit actions, or for the three file descriptors corresponding to the standard
file streams. In order to avoid a race condition of leaking an unintended file descriptor into a child process or executed program,
an application should consider opening all file descriptors with the FD_CLOFORK or FD_CLOEXEC flag, or both flags, set unless the
file descriptor is intended to be inherited by child processes or executed programs, respectively.
RATIONALE
A spawn file actions object may be initialized to contain an ordered sequence of chdir(), close(), dup2(), fchdir(), and open() operations to be used by posix_spawn() or posix_spawnp() to
arrive at the set of open file descriptors and current working directory inherited by the spawned process from the set of open file
descriptors and current working directory in the parent at the time of the posix_spawn() or posix_spawnp()
call. It had been suggested that the close() and dup2() operations alone are sufficient to rearrange file descriptors, and that files which need
to be opened for use by the spawned process can be handled either by having the calling process open them before the posix_spawn() or posix_spawnp() call
(and close them after), or by passing pathnames to the spawned process (in argv) so that it may open them itself. The
standard developers recommend that applications use one of these two methods when practical, since detailed error status on a
failed open operation is always available to the application this way. However, the standard developers feel that allowing a spawn
file actions object to specify open operations is still appropriate because:
It is consistent with equivalent POSIX.5 (Ada) functionality.
It supports the I/O redirection paradigm commonly employed by POSIX programs designed to be invoked from a shell. When such a
program is the child process, it may not be designed to open files on its own.
It allows file opens that might otherwise fail or violate file ownership/access rights if executed by the parent process.
Regarding 2. above, note that the spawn open file action provides to posix_spawn() and posix_spawnp() the
same capability that the shell redirection operators provide to system(), only
without the intervening execution of a shell; for example:
system ("myprog
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1d-1999.
IEEE PASC Interpretation 1003.1 #105 is applied, adding a note to the DESCRIPTION that the string pointed to by path is
copied by the posix_spawn_file_actions_addopen() function.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0436 [418], XSH/TC1-2008/0437 [149], XSH/TC1-2008/0438 [291], and
XSH/TC1-2008/0439 [418] are applied.
Issue 8
Austin Group Defect 370 is applied, requiring that attempting to close a file descriptor that is in range, but already closed at
the time when the new process is spawned, is not treated as an error.
Austin Group Defect 1208 is applied, adding posix_spawn_file_actions_addchdir() and posix_spawn_file_actions_addfchdir().
Austin Group Defect 1318 is applied, adding FD_CLOFORK.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/thrd_yield.html =====
thrd_yield
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
thrd_yield — yield the processor
SYNOPSIS
#include
void thrd_yield(void);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
[CX]  The
thrd_yield() function shall force the running thread to relinquish the processor until it again becomes the head of its
thread list.
RETURN VALUE
This function shall not return a value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
See the APPLICATION USAGE section for sched_yield().
RATIONALE
The thrd_yield() function is identical to the sched_yield() function
except that it does not return a value.
FUTURE DIRECTIONS
None.
SEE ALSO
sched_yield()
XBD
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/cacoshl.html =====
cacosh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cacosh, cacoshf, cacoshl — complex arc hyperbolic cosine functions
SYNOPSIS
#include
double complex cacosh(double complex z);
float complex cacoshf(float complex z);
long double complex cacoshl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex arc hyperbolic cosine of z, with a branch cut at values less than 1 along the
real axis.
RETURN VALUE
These functions shall return the complex arc hyperbolic cosine value, in the range of a half-strip of non-negative values along
the real axis and in the interval [-iℼ, +iℼ] along the imaginary axis.
[MXC]
cacosh(conj(z)), cacoshf(conjf(z)), and cacoshl(conjl(z)) shall
return exactly the same value as conj(cacosh(z)), conjf(cacoshf(z)), and
conjl(cacoshl(z)), respectively, including for the special values of z below.
If z is ±0 + i0, +0 + iℼ/2 shall be returned.
If z is x + iInf where x is finite, +Inf + iℼ/2 shall be returned.
If z is 0 + iNaN, NaN ± iℼ/2 shall be returned; the sign of the imaginary part of the result is
unspecified.
If z is x + iNaN where x is non-zero and finite, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is -Inf + iy where y is positive-signed and finite, +Inf + iℼ shall be returned.
If z is +Inf + iy where y is positive-signed and finite, +Inf + i0 shall be returned.
If z is -Inf + iInf, +Inf + i3ℼ/4 shall be returned.
If z is +Inf + iInf, +Inf + iℼ/4 shall be returned.
If z is ±Inf + iNaN, +Inf + iNaN shall be returned.
If z is NaN + iy where y is finite, NaN + iNaN shall be returned and the invalid floating-point
exception may be raised.
If z is NaN + iInf, +Inf + iNaN shall be returned.
If z is NaN + iNaN, NaN + iNaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
ccosh()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ctanhf.html =====
ctanh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ctanh, ctanhf, ctanhl — complex hyperbolic tangent functions
SYNOPSIS
#include
double complex ctanh(double complex z);
float complex ctanhf(float complex z);
long double complex ctanhl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex hyperbolic tangent of z.
RETURN VALUE
These functions shall return the complex hyperbolic tangent value.
[MXC]
ctanh(conj(z)), ctanhf(conjf(z)), and ctanhl(conjl(z)) shall return
exactly the same value as conj(ctanh(z)), conjf(ctanhf(z)), and
conjl(ctanhl(z)), respectively, and ctanh(-z), ctanhf(-z), and
ctanhl(-z) shall return exactly the same value as -ctanh(z), -ctanhf(z), and
-ctanhl(z), respectively, including for the special values of z below.
If z is +0 + i0, +0 + i0 shall be returned.
If z is 0 + iInf, 0 + iNaN shall be returned and the invalid floating-point exception shall be raised.
If z is x + iInf where x is non-zero and finite, NaN + iNaN shall be returned and the invalid
floating-point exception shall be raised.
If z is 0 + iNaN, 0 + iNaN shall be returned.
If z is x + iNaN where x is non-zero and finite, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is +Inf + iy where y is positive-signed and finite, 1 + i0 sin(2y) shall be
returned.
If z is +Inf + iInf, 1 ± i0 shall be returned; the sign of the imaginary part of the result is
unspecified.
If z is +Inf + iNaN, 1 ± i0 shall be returned; the sign of the imaginary part of the result is
unspecified.
If z is NaN + i0, NaN + i0 shall be returned.
If z is NaN + iy where y is any non-zero number, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is NaN + iNaN, NaN + iNaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
catanh()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_join.html =====
pthread_join
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_join — wait for thread termination
SYNOPSIS
#include
int pthread_join(pthread_t thread, void **value_ptr);
DESCRIPTION
The pthread_join() function shall suspend execution of the calling thread until the target thread terminates,
unless the target thread has already terminated. On return from a successful pthread_join() call with a non-NULL
value_ptr argument, the value passed to pthread_exit() by the
terminating thread shall be made available in the location referenced by value_ptr. When a pthread_join() returns
successfully, the target thread has been terminated. The results of multiple simultaneous calls to pthread_join() specifying
the same target thread are undefined. If the thread calling pthread_join() is canceled, then the target thread shall not be
detached.
It is unspecified whether a zombie thread counts against {PTHREAD_THREADS_MAX}.
The behavior is undefined if the value specified by the thread argument to pthread_join() does not refer to a
joinable thread.
The behavior is undefined if the value specified by the thread argument to pthread_join() refers to the calling
thread.
If thread refers to a thread that was created using thrd_create() and
the thread terminates, or has already terminated, by returning from its start routine, the behavior of pthread_join() is
undefined. If thread refers to a thread that terminates, or has already terminated, by calling thrd_exit(), the behavior of pthread_join() is undefined.
RETURN VALUE
If successful, the pthread_join() function shall return zero; otherwise, an error number shall be returned to indicate
the error.
ERRORS
The pthread_join() function may fail if:
[EDEADLK]
A deadlock was detected.
The pthread_join() function shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
An example of thread creation and deletion follows:
typedef struct {
int *ar;
long n;
} subarray;
void *
incer(void *arg)
{
long i;
for (i = 0; i n; i++)
((subarray *)arg)->ar[i]++;
}
int main(void)
{
int        ar[1000000];
pthread_t  th1, th2;
subarray   sb1, sb2;
sb1.ar = &ar[0];
sb1.n  = 500000;
(void) pthread_create(&th1, NULL, incer, &sb1);
sb2.ar = &ar[500000];
sb2.n  = 500000;
(void) pthread_create(&th2, NULL, incer, &sb2);
(void) pthread_join(th1, NULL);
(void) pthread_join(th2, NULL);
return 0;
}
APPLICATION USAGE
None.
RATIONALE
The pthread_join() function is a convenience that has proven useful in multi-threaded applications. It is true that a
programmer could simulate this function if it were not provided by passing extra state as part of the argument to the
start_routine(). The terminating thread would set a flag to indicate termination and broadcast a condition that is part of
that state; a joining thread would wait on that condition variable. While such a technique would allow a thread to wait on more
complex conditions (for example, waiting for multiple threads to terminate), waiting on individual thread termination is considered
widely useful. Also, including the pthread_join() function in no way precludes a programmer from coding such complex waits.
Thus, while not a primitive, including pthread_join() in this volume of POSIX.1-2024 was considered valuable.
The pthread_join() function provides a simple mechanism allowing an application to wait for a thread to terminate. After
the thread terminates, the application may then choose to clean up resources that were used by the thread. For instance, after
pthread_join() returns, any application-provided stack storage could be reclaimed.
The pthread_join() or pthread_detach() function should eventually
be called for every thread that is created with the detachstate attribute set to PTHREAD_CREATE_JOINABLE so that storage
associated with the thread may be reclaimed.
The interaction between pthread_join() and cancellation is well-defined for the following reasons:
The pthread_join() function, like all other non-async-cancel-safe functions, can only be called with deferred
cancelability type.
Cancellation cannot occur in the disabled cancelability state.
Thus, only the default cancelability state need be considered. As specified, either the pthread_join() call is canceled,
or it succeeds, but not both. The difference is obvious to the application, since either a cancellation handler is run or
pthread_join() returns. There are no race conditions since pthread_join() was called in the deferred cancelability
state.
If an implementation detects that the value specified by the thread argument to pthread_join() does not refer to a
joinable thread, it is recommended that the function should fail and report an [EINVAL] error.
If an implementation detects that the value specified by the thread argument to pthread_join() refers to the
calling thread, it is recommended that the function should fail and report an [EDEADLK] error.
If an implementation detects use of a thread ID after the end of its lifetime, it is recommended that the function should fail
and report an [ESRCH] error.
The pthread_join() function cannot be used to obtain the exit status of a thread that was created using thrd_create() and which terminates by returning from its start routine, or of a thread
that terminates by calling thrd_exit(), because such threads have an int
exit status, instead of the void * that pthread_join() returns via its value_ptr argument.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_create(), thrd_create(), thrd_exit(),
wait()
XBD 4.15.2 Memory Synchronization,
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_join() function is marked as part of the Threads option.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/97 is applied, updating the ERRORS section so that the [EINVAL]
error is made optional and the words "the implementation has detected" are removed from it.
Issue 7
The pthread_join() function is moved from the Threads option to the Base.
Austin Group Interpretation 1003.1-2001 #142 is applied, removing the [ESRCH] error condition.
The [EINVAL] error for a non-joinable thread is removed; this condition results in undefined behavior.
The [EDEADLK] error for the calling thread is removed; this condition results in undefined behavior.
Issue 8
Austin Group Defect 792 is applied, changing "a thread that has exited but remains unjoined" to "a zombie thread".
Austin Group Defect 1302 is applied, updating the page to account for the addition of  interfaces.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcsncpy.html =====
wcsncpy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcpncpy, wcsncpy — copy a fixed-size wide-character string, returning a pointer to its end
SYNOPSIS
#include
[CX]  wchar_t *wcpncpy(wchar_t restrict *ws1, const wchar_t *restrict
ws2,
size_t n);
wchar_t *wcsncpy(wchar_t *restrict ws1, const wchar_t *restrict ws2,
size_t n);
DESCRIPTION
For wcsncpy(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The [CX]
wcpncpy()  and wcsncpy() functions shall copy not more
than n wide-character codes (wide-character codes that follow a null wide-character code are not copied) from the array
pointed to by ws2 to the array pointed to by ws1. If copying takes place between objects that overlap, the behavior
is undefined.
If the array pointed to by ws2 is a wide-character string that is shorter than n wide-character codes, null
wide-character codes shall be appended to the copy in the array pointed to by ws1, until n wide-character codes in
all are written.
[CX]  The
wcsncpy() and wcpncpy() functions shall not change the setting of errno on valid input.
RETURN VALUE
[CX]  If
any null wide-character codes were written into the destination, the wcpncpy() function shall return the address of the
first such null wide-character code. Otherwise, it shall return &ws1[n].
The wcsncpy() function shall return ws1.
No return values are reserved to indicate an error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
If there is no null wide-character code in the first n wide-character codes of the array pointed to by ws2, the
result is not null-terminated.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
strncpy(), wcscpy(), wcslcat()
XBD
CHANGE HISTORY
First released in Issue 4. Derived from the MSE working draft.
Issue 6
The wcsncpy() prototype is updated for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
The wcpncpy() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 1.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that wcsncpy() and wcpncpy() do not change the setting of
errno on valid input.
Austin Group Defect 986 is applied, adding wcslcat() to the SEE ALSO section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getchar.html =====
getchar
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getchar — get a byte from a stdin stream
SYNOPSIS
#include
int getchar(void);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The getchar() function shall be equivalent to getc(stdin).
RETURN VALUE
Refer to fgetc().
ERRORS
Refer to fgetc().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
If the integer value returned by getchar() is stored into a variable of type char and then compared against the
integer constant EOF, the comparison may never succeed, because sign-extension of a variable of type char on widening to
integer is implementation-defined.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, getc()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0236 [14] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/iswcntrl_l.html =====
iswcntrl
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
iswcntrl, iswcntrl_l — test for a control wide-character code
SYNOPSIS
#include
int iswcntrl(wint_t wc);
[CX]  int iswcntrl_l(wint_t wc, locale_t locale);
DESCRIPTION
For iswcntrl(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The iswcntrl() [CX]   and iswcntrl_l()
functions shall test whether wc is a wide-character code representing a character of class cntrl in the current
locale, [CX]   or in the locale represented by locale,
respectively; see XBD 7. Locale.
The wc argument is a wint_t, the value of which the application shall ensure is a wide-character code
corresponding to a valid character in the locale used by the function, or equal to the value of the macro WEOF. If the argument has
any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to iswcntrl_l() is the special locale object LC_GLOBAL_LOCALE or is not
a valid locale object handle.
RETURN VALUE
The iswcntrl() [CX]   and iswcntrl_l()
functions shall return non-zero if wc is a control wide-character code; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
iswalnum(), iswalpha(),
iswctype(), iswdigit(),
iswgraph(), iswlower(),
iswprint(), iswpunct(),
iswspace(), iswupper(),
iswxdigit(), setlocale(),
uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 4.
Issue 5
The following change has been made in this version for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E):
The SYNOPSIS has been changed to indicate that this function and associated data types are now made visible by inclusion of the
header rather than .
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The iswcntrl_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0318 [302], XSH/TC1-2008/0319 [283], and XSH/TC1-2008/0320 [283] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0183 [685] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/scalbnf.html =====
scalbln
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
scalbln, scalblnf, scalblnl, scalbn, scalbnf, scalbnl — compute exponent using FLT_RADIX
SYNOPSIS
#include
double scalbln(double x, long n);
float scalblnf(float x, long n);
long double scalblnl(long double x, long n);
double scalbn(double x, int n);
float scalbnf(float x, int n);
long double scalbnl(long double x, int n);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute x * FLT_RADIXn efficiently, not normally by
computing FLT_RADIXn explicitly.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return x * FLT_RADIXn.
[MX]  If
the calculation does not overflow or underflow, the returned value shall be exact and shall be independent of the current rounding
direction mode.
If the result would cause overflow, a range error shall occur and these functions shall return ±HUGE_VAL, ±HUGE_VALF, and
±HUGE_VALL (according to the sign of x) as appropriate for the return type of the function.
If the correct value would cause underflow, [MXX]   and is not representable,   a range error may occur, and scalbln(), scalblnf(), scalblnl(),
scalbn(), scalbnf(), and scalbnl() shall return [MXX]
0.0, or   (if IEC 60559 Floating-Point is not supported) an implementation-defined value no greater in
magnitude than DBL_MIN, FLT_MIN, LDBL_MIN, DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0 or ±Inf, x shall be returned.
If n is 0, x shall be returned.
[MXX]
If the correct value would cause underflow, and is representable, a range error may occur and the correct value shall be returned.
ERRORS
These functions shall fail if:
Range Error
The result overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
These functions may fail if:
Range Error
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
These functions are named so as to avoid conflicting with the historical definition of the scalb() function from the
Single UNIX Specification. The difference is that the scalb() function has a second argument of double instead of
int. The scalb() function is not part of the ISO C standard. The three functions whose second type is
long are provided because the factor required to scale from the smallest positive floating-point value to the largest finite
one, on many implementations, is too large to represent in the minimum-width int format.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0521 [68] and XSH/TC1-2008/0522 [68] are applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_attr_getschedpolicy.html =====
pthread_attr_getschedpolicy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_attr_getschedpolicy, pthread_attr_setschedpolicy — get and set the schedpolicy attribute (REALTIME
THREADS)
SYNOPSIS
[TPS]  #include
int pthread_attr_getschedpolicy(const pthread_attr_t *restrict attr,
int *restrict policy);
int pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy);
DESCRIPTION
The pthread_attr_getschedpolicy() and pthread_attr_setschedpolicy() functions, respectively, shall get and set the
schedpolicy attribute in the attr argument.
The supported values of policy shall include SCHED_FIFO, SCHED_RR, and SCHED_OTHER, which are defined in the  header. When threads executing with the scheduling policy SCHED_FIFO,
SCHED_RR, [TSP]   or SCHED_SPORADIC  are waiting on a mutex, they
shall acquire the mutex in priority order when the mutex is unlocked.
The behavior is undefined if the value specified by the attr argument to pthread_attr_getschedpolicy() or
pthread_attr_setschedpolicy() does not refer to an initialized thread attributes object.
RETURN VALUE
If successful, the pthread_attr_getschedpolicy() and pthread_attr_setschedpolicy() functions shall return zero;
otherwise, an error number shall be returned to indicate the error.
ERRORS
The pthread_attr_setschedpolicy() function shall fail if:
[ENOTSUP]
An attempt was made to set the attribute to an unsupported value.
The pthread_attr_setschedpolicy() function may fail if:
[EINVAL]
The value of policy is not valid.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
After these attributes have been set, a thread can be created with the specified attributes using pthread_create(). Using these routines does not affect the current running
thread.
See 2.9.4 Thread Scheduling for further details on thread
scheduling attributes and their default settings.
RATIONALE
If an implementation detects that the value specified by the attr argument to pthread_attr_getschedpolicy() or
pthread_attr_setschedpolicy() does not refer to an initialized thread attributes object, it is recommended that the function
should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_attr_destroy(), pthread_attr_getscope(), pthread_attr_getinheritsched(), pthread_attr_getschedparam(), pthread_create()
XBD ,
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Marked as part of the Realtime Threads Feature Group.
Issue 6
The pthread_attr_getschedpolicy() and pthread_attr_setschedpolicy() functions are marked as part of the Threads
and Thread Execution Scheduling options.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Thread
Execution Scheduling option.
The SCHED_SPORADIC scheduling policy is added for alignment with IEEE Std 1003.1d-1999.
The restrict keyword is added to the pthread_attr_getschedpolicy() prototype for alignment with the
ISO/IEC 9899:1999 standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/79 is applied, adding a reference to 2.9.4 Thread Scheduling in the APPLICATION USAGE section.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/80 is applied, updating the ERRORS section to include optional
errors for the case when attr refers to an uninitialized thread attribute object.
Issue 7
The pthread_attr_getschedpolicy() and pthread_attr_setschedpolicy() functions are marked only as part of the
Thread Execution Scheduling option as the Threads option is now part of the Base.
The [EINVAL] error for an uninitialized thread attributes object is removed; this condition results in undefined behavior.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0452 [314] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0263 [757] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sig2str.html =====
sig2str
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sig2str, str2sig — translate between signal names and numbers
SYNOPSIS
[CX]  #include
int sig2str(int signum, char *str);
int str2sig(const char *restrict str, int *restrict pnum);
DESCRIPTION
The sig2str() function shall translate the signal number specified by signum to a signal name and shall store this
string in the location specified by str. The application shall ensure that str points to a location that can store
the string including the terminating null byte. The symbolic constant SIG2STR_MAX defined in  gives the maximum number of bytes required.
If signum is equal to 0, the behavior is unspecified.
If signum is equal to one of the symbolic constants listed in the table of signal numbers in , the stored signal name shall be the name of the symbolic constant without
the SIG prefix.
If signum is equal to SIGRTMIN or SIGRTMAX, the stored string shall be "RTMIN" or "RTMAX",
respectively.
If signum is between SIGRTMIN+1 and (SIGRTMIN+SIGRTMAX)/2 inclusive, the stored string shall be of the form
"RTMIN+n", where n is the shortest decimal representation of the value of
signum-SIGRTMIN.
If signum is between (SIGRTMIN+SIGRTMAX)/2 + 1 and SIGRTMAX-1 inclusive, the stored string shall be either of the form
"RTMIN+n" or of the form "RTMAX-m", where n is the shortest decimal
representation of the value of signum-SIGRTMIN and m is the shortest decimal representation of the value of
SIGRTMAX-signum.
If signum is a valid, supported signal number, is either less than SIGRTMIN or greater than SIGRTMAX, and is not equal to
one of the symbolic constants listed in the table of signal numbers in , the stored string shall uniquely identify the signal number signum
in an unspecified manner.
The str2sig() function shall translate the signal name in the string pointed to by str to a signal number and
shall store this value in the location specified by pnum.
If str points to a string containing the name of one of the symbolic constants listed in the table of signal numbers in
, without the SIG prefix, the stored signal number shall be
equal to the value of the symbolic constant.
If str points to the string "RTMIN" or "RTMAX", the stored value shall be equal to SIGRTMIN or
SIGRTMAX, respectively.
If str points to a string of the form "RTMIN+n", where n is a decimal representation of a
number between 1 and SIGRTMAX-SIGRTMIN-1 inclusive, the stored value shall be equal to SIGRTMIN+n.
If str points to a string of the form "RTMAX-n", where n is a decimal representation of a
number between 1 and SIGRTMAX-SIGRTMIN-1 inclusive, the stored value shall be equal to SIGRTMAX-n.
If str points to a string containing a decimal representation of a valid, supported signal number, the value stored in
the location pointed to by pnum shall be equal to that number.
If str points to a string containing a decimal representation of the value 0 and the string was not returned by a
previous successful call to sig2str() with a signum argument of 0, the behavior is unspecified.
If str points to a string returned by a previous successful call to sig2str(signum,str), the value
stored in the location pointed to by pnum shall be equal to signum.
If str points to a string that does not meet any of the above criteria, str2sig() shall store a value in the
location pointed to by pnum if and only if it recognizes the string as an additional implementation-dependent form of signal
name.
RETURN VALUE
If signum is a valid, supported signal number (that is, one for which kill()
does not return -1 with errno set to [EINVAL]), the sig2str() function shall return 0; otherwise, if signum is
not equal to 0, it shall return -1.
If str2sig() stores a value in the location pointed to by pnum, it shall return 0; otherwise, it shall return
-1.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
Historical versions of these functions translated a signum value 0 to "EXIT" (and vice versa), so that they
could be used by the shell for the trap utility. When adding the functions to this
standard, the standard developers felt that they should be aimed at more general-purpose use, and consequently requiring this
behavior did not seem appropriate and so the behavior in this case has been made unspecified.
FUTURE DIRECTIONS
None.
SEE ALSO
kill(), sigaction(),
strsignal()
XBD
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcstof.html =====
wcstod
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcstod, wcstof, wcstold — convert a wide-character string to a double-precision number
SYNOPSIS
#include
double wcstod(const wchar_t *restrict nptr, wchar_t **restrict endptr);
float wcstof(const wchar_t *restrict nptr, wchar_t **restrict endptr);
long double wcstold(const wchar_t *restrict nptr,
wchar_t **restrict endptr);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall convert the initial portion of the wide-character string pointed to by nptr to double,
float, and long double representation, respectively. First, they shall decompose the input wide-character string into
three parts:
An initial, possibly empty, sequence of white-space wide characters
A subject sequence interpreted as a floating-point constant or representing infinity or NaN
A final wide-character string of one or more unrecognized wide-character codes, including the terminating null wide-character
code of the input wide-character string
Then they shall attempt to convert the subject sequence to a floating-point number, and return the result.
The expected form of the subject sequence is an optional '+' or '-' sign, then one of the following:
A non-empty sequence of decimal digits optionally containing a radix character; then an optional exponent part consisting of the
wide character 'e' or the wide character 'E', optionally followed by a '+' or '-' wide
character, and then followed by one or more decimal digits
A 0x or 0X, then a non-empty sequence of hexadecimal digits optionally containing a radix character; then an optional binary
exponent part consisting of the wide character 'p' or the wide character 'P', optionally followed by a
'+' or '-' wide character, and then followed by one or more decimal digits
One of INF or INFINITY, or any other wide string equivalent except for case
One of NAN or NAN(n-wchar-sequenceopt), or any other wide string ignoring case in the NAN part,
where:
n-wchar-sequence:
digit
nondigit
n-wchar-sequence digit
n-wchar-sequence nondigit
The subject sequence is defined as the longest initial subsequence of the input wide string, starting with the first
non-white-space wide character, that is of the expected form. The subject sequence contains no wide characters if the input wide
string is not of the expected form.
If the subject sequence has the expected form for a floating-point number, the sequence of wide characters starting with the
first digit or the radix character (whichever occurs first) shall be interpreted as a floating constant according to the rules of
the C language, except that the radix character shall be used in place of a period, and that if neither an exponent part nor a
radix character appears in a decimal floating-point number, or if a binary exponent part does not appear in a hexadecimal
floating-point number, an exponent part of the appropriate type with value zero shall be assumed to follow the last digit in the
string. If the subject sequence begins with a , the sequence shall be interpreted as negated. A wide-character
sequence INF or INFINITY shall be interpreted as an infinity, if representable in the return type, else as if it were a floating
constant that is too large for the range of the return type. A wide-character sequence NAN or
NAN(n-wchar-sequenceopt) shall be interpreted as a quiet NaN, if supported in the return type,
else as if it were a subject sequence part that does not have the expected form; the meaning of the n-wchar sequences is
implementation-defined. A pointer to the final wide string shall be stored in the object pointed to by endptr, provided that
endptr is not a null pointer.
If the subject sequence has the hexadecimal form and FLT_RADIX is a power of 2, the conversion shall be rounded in an
implementation-defined manner.
[CX]  The
radix character shall be as defined in the current locale (category LC_NUMERIC ). In the POSIX locale, or in a locale where
the radix character is not defined, the radix character shall default to a  ('.').
In other than the C [CX]   or POSIX  locale, additional
locale-specific subject sequence forms may be accepted.
If the subject sequence is empty or does not have the expected form, no conversion shall be performed; the value of nptr
shall be stored in the object pointed to by endptr, provided that endptr is not a null pointer.
These functions shall not change the setting of errno if successful.
Since 0 is returned on error and is also a valid return on success, an application wishing to check for error situations should
set errno to 0, then call wcstod(), wcstof(), or wcstold(), then check errno.
RETURN VALUE
Upon successful completion, these functions shall return the converted value. If no conversion could be performed, 0 shall be
returned [CX]   and errno may be set to [EINVAL].
If the correct value would cause an overflow and default rounding is in effect, ±HUGE_VAL, ±HUGE_VALF, or ±HUGE_VALL shall be
returned (according to the sign of the value), and errno shall be set to [ERANGE].
If the correct value would cause underflow, a value whose magnitude is no greater than the smallest normalized positive number
in the return type shall be returned [CX]   and errno set to [ERANGE].
ERRORS
The wcstod() function shall fail if:
[ERANGE]
The value to be returned would cause overflow and default rounding is in effect [CX]   or the value
to be returned would cause underflow.
The wcstod() function may fail if:
[EINVAL]
[CX]  No
conversion could be performed.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
If the subject sequence has the hexadecimal form and FLT_RADIX is not a power of 2, and the result is not exactly representable,
the result should be one of the two numbers in the appropriate internal format that are adjacent to the hexadecimal floating source
value, with the extra stipulation that the error should have a correct sign for the current rounding direction.
If the subject sequence has the decimal form and at most DECIMAL_DIG (defined in ) significant digits, the result should be correctly rounded. If the subject
sequence D has the decimal form and more than DECIMAL_DIG significant digits, consider the two bounding, adjacent decimal
strings L and U, both having DECIMAL_DIG significant digits, such that the values of L, D, and U
satisfy "L ,
CHANGE HISTORY
First released in Issue 4. Derived from the MSE working draft.
Issue 5
The DESCRIPTION is updated to indicate that errno is not changed if the function is successful.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the RETURN VALUE and ERRORS sections, the [EINVAL] optional error condition is added if no conversion could be performed.
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The wcstod() prototype is updated.
The wcstof() and wcstold() functions are added.
If the correct value for wcstod() would cause underflow, the return value changed from 0 (as specified in Issue 5) to the
smallest normalized positive number.
The DESCRIPTION, RETURN VALUE, and APPLICATION USAGE sections are extensively updated.
ISO/IEC 9899:1999 standard, Technical Corrigendum 1 is incorporated.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/66 is applied, correcting the second paragraph in the RETURN
VALUE section.
Issue 7
Austin Group Interpretation 1003.1-2001 #015 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0723 [302] and XSH/TC1-2008/0724 [105] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0391 [584] and XSH/TC2-2008/0392 [796] are applied.
Issue 8
Austin Group Defect 1163 is applied, clarifying the handling of white space in the input string.
Austin Group Defect 1686 is applied, addressing some inconsistencies with strtod().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/FD_CLR.html =====
pselect
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pselect, select — synchronous I/O multiplexing
SYNOPSIS
#include
int pselect(int nfds, fd_set *restrict readfds,
fd_set *restrict writefds, fd_set *restrict errorfds,
const struct timespec *restrict timeout,
const sigset_t *restrict sigmask);
int select(int nfds, fd_set *restrict readfds,
fd_set *restrict writefds, fd_set *restrict errorfds,
struct timeval *restrict timeout);
void FD_CLR(int fd, fd_set *fdset);
int FD_ISSET(int fd, const fd_set *fdset);
void FD_SET(int fd, fd_set *fdset);
void FD_ZERO(fd_set *fdset);
DESCRIPTION
The pselect() function shall examine the file descriptor sets whose addresses are passed in the readfds,
writefds, and errorfds parameters to see whether some of their descriptors are ready for reading, are ready for
writing, or have an exceptional condition pending, respectively.
The select() function shall be equivalent to the pselect() function, except as follows:
For the select() function, the timeout period is given in seconds and microseconds in an argument of type struct
timeval, whereas for the pselect() function the timeout period is given in seconds and nanoseconds in an argument of
type struct timespec.
The select() function has no sigmask argument; it shall behave as pselect() does when sigmask is a
null pointer.
Upon successful completion, the select() function may modify the object pointed to by the timeout argument.
The pselect() and select() functions shall support regular files, terminal and pseudo-terminal devices, FIFOs,
pipes, and sockets. The behavior of pselect() and select() on file descriptors that refer to other types of file is
unspecified.
The nfds argument specifies the range of descriptors to be tested. The first nfds descriptors shall be checked in
each set; that is, the descriptors from zero through nfds-1 in the descriptor sets shall be examined.
If the readfds argument is not a null pointer, it points to an object of type fd_set that on input specifies the
file descriptors to be checked for being ready to read, and on output indicates which file descriptors are ready to read.
If the writefds argument is not a null pointer, it points to an object of type fd_set that on input specifies the
file descriptors to be checked for being ready to write, and on output indicates which file descriptors are ready to write.
If the errorfds argument is not a null pointer, it points to an object of type fd_set that on input specifies the
file descriptors to be checked for error conditions pending, and on output indicates which file descriptors have error conditions
pending.
Upon successful completion, the pselect() or select() function shall modify the objects pointed to by the
readfds, writefds, and errorfds arguments to indicate which file descriptors are ready for reading, ready for
writing, or have an error condition pending, respectively, and shall return the total number of ready descriptors in all the output
sets. For each file descriptor less than nfds, the corresponding bit shall be set upon successful completion if it was set
on input and the associated condition is true for that file descriptor.
If none of the selected descriptors are ready for the requested operation, the pselect() or select() function
shall block until at least one of the requested operations becomes ready, until the timeout occurs, or until interrupted by
a signal. The timeout parameter controls how long the pselect() or select() function shall take before timing
out. If the timeout parameter is not a null pointer, it specifies a maximum interval to wait for the selection to complete.
If the specified time interval expires without any requested operation becoming ready, the function shall return. If the
timeout parameter is a null pointer, then the call to pselect() or select() shall block indefinitely until at
least one descriptor meets the specified criteria. To effect a poll, the timeout parameter should not be a null pointer, and
should point to a zero-valued timespec structure.
The use of a timeout does not affect any pending timers set up by alarm().
Implementations may place limitations on the maximum timeout interval supported. All implementations shall support a maximum
timeout interval of at least 31 days. If the timeout argument specifies a timeout interval greater than the
implementation-defined maximum value, the maximum value shall be used as the actual timeout value. Implementations may also place
limitations on the granularity of timeout intervals. If the requested timeout interval requires a finer granularity than the
implementation supports, the actual timeout interval shall be rounded up to the next supported value.
If sigmask is not a null pointer, then the pselect() function shall replace the signal mask of the caller by the
set of signals pointed to by sigmask before examining the descriptors, and shall restore the signal mask of the calling
thread before returning. If a signal is unmasked as a result of the signal mask being altered by pselect(), and a
signal-catching function is called for that signal during the execution of the pselect() function, and SA_RESTART is clear
for the interrupting signal, then
If none of the selected file descriptors are ready, pselect() shall immediately fail with the [EINTR] error after the
signal-catching function returns.
If one or more of the selected file descriptors are ready, it is unspecified whether pselect() behaves the same as if
none of the descriptors were ready (failing with [EINTR] as above) or behaves the same as if it was not interrupted (returning the
total number of ready descriptors).
A descriptor shall be considered ready for reading when a call to an input function with O_NONBLOCK clear would not block,
whether or not the function would transfer data successfully. (The function might return data, an end-of-file indication, or an
error other than one indicating that it is blocked, and in each of these cases the descriptor shall be considered ready for
reading.)
A descriptor shall be considered ready for writing when a call to an output function with O_NONBLOCK clear would not block,
whether or not the function would transfer data successfully.
If a socket has a pending error, it shall be considered to have an exceptional condition pending. Otherwise, what constitutes an
exceptional condition is file type-specific. For a file descriptor for use with a socket, it is protocol-specific except as noted
below. For other file types it is implementation-defined. If the operation is meaningless for a particular file type,
pselect() or select() shall indicate that the descriptor is ready for read or write operations, and shall indicate
that the descriptor has no exceptional condition pending.
If a descriptor refers to a socket, the implied input function is the recvmsg()
function with parameters requesting normal and ancillary data, such that the presence of either type shall cause the socket to be
marked as readable. The presence of out-of-band data shall be checked if the socket option SO_OOBINLINE has been enabled, as
out-of-band data is enqueued with normal data. If the socket is currently listening, then it shall be marked as readable if an
incoming connection request has been received, and a call to the accept() or accept4() function shall complete without blocking.
If a descriptor refers to a socket, the implied output function is the sendmsg()
function supplying an amount of normal data equal to the current value of the SO_SNDLOWAT option for the socket. If a non-blocking
call to the connect() function has been made for a socket, and the connection
attempt has either succeeded or failed leaving a pending error, the socket shall be marked as writable.
A socket shall be considered to have an exceptional condition pending if a receive operation with O_NONBLOCK clear for the open
file description and with the MSG_OOB flag set would return out-of-band data without blocking. (It is protocol-specific whether the
MSG_OOB flag would be used to read out-of-band data.) A socket shall also be considered to have an exceptional condition pending if
an out-of-band data mark is present in the receive queue. Other circumstances under which a socket may be considered to have an
exceptional condition pending are protocol-specific and implementation-defined.
If the readfds, writefds, and errorfds arguments are all null pointers and the timeout argument is
not a null pointer, the pselect() or select() function shall block for the time specified, or until interrupted by a
signal. If the readfds, writefds, and errorfds arguments are all null pointers and the timeout argument
is a null pointer, the pselect() or select() function shall block until interrupted by a signal.
File descriptors associated with regular files shall always select true for ready to read, ready to write, and error
conditions.
On failure, the objects pointed to by the readfds, writefds, and errorfds arguments shall not be modified.
If the timeout interval expires without the specified condition being true for any of the specified file descriptors, the objects
pointed to by the readfds, writefds, and errorfds arguments shall have all bits set to 0.
File descriptor masks of type fd_set can be initialized and tested with FD_CLR(), FD_ISSET(),
FD_SET(), and FD_ZERO(). It is unspecified whether each of these is a macro or a function. If a macro definition is
suppressed in order to access an actual function, or a program defines an external identifier with any of these names, the behavior
is undefined.
FD_CLR(fd, fdsetp) shall remove the file descriptor fd from the set pointed to by fdsetp. If
fd is not a member of this set, there shall be no effect on the set, and this shall not be treated as an error.
FD_ISSET(fd, fdsetp) shall evaluate to non-zero if the file descriptor fd is a member of the set
pointed to by fdsetp, and shall evaluate to zero otherwise.
FD_SET(fd, fdsetp) shall add the file descriptor fd to the set pointed to by fdsetp. If the
file descriptor fd is already in this set, there shall be no effect on the set, and this shall not be treated as an
error.
FD_ZERO(fdsetp) shall initialize the descriptor set pointed to by fdsetp to the null set. No error is
returned if the set is not empty at the time FD_ZERO() is invoked.
The behavior of these macros is undefined if the fd argument is less than 0 or greater than or equal to FD_SETSIZE, or if
fd is not a valid file descriptor, or if any of the arguments are expressions with side-effects.
If a thread gets canceled during a pselect() call, the signal mask in effect when executing the registered cleanup
functions is either the original signal mask or the signal mask installed as part of the pselect() call.
RETURN VALUE
Upon successful completion, the pselect() and select() functions shall return the total number of bits set in the
bit masks. Otherwise, -1 shall be returned, and errno shall be set to indicate the error.
FD_CLR(), FD_SET(), and FD_ZERO() do not return a value. FD_ISSET() shall return a non-zero value if
the bit for the file descriptor fd is set in the file descriptor set pointed to by fdset, and 0 otherwise.
ERRORS
Under the following conditions, pselect() and select() shall fail and set errno to:
[EBADF]
One or more of the file descriptor sets specified a file descriptor that is not a valid open file descriptor.
[EINTR]
The function was interrupted by a signal.
If SA_RESTART has been set for the interrupting signal, it is implementation-defined whether the function restarts or returns
with [EINTR].
[EINVAL]
An invalid timeout interval was specified.
[EINVAL]
The nfds argument is less than 0 or greater than FD_SETSIZE.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The use of select() and pselect() requires that the application construct the set of file descriptors to work on
each time through a polling loop, and is inherently limited from operating on file descriptors larger than FD_SETSIZE. Also, the
amount of work to perform scales as nfds increases, even if the number of file descriptors selected within the larger set
remains the same. Thus, applications may wish to consider using poll() and ppoll() instead, for better scaling.
When a pselect() or select() call indicates a file descriptor is ready for reading, this means that if an attempt
to read data had been made at the time that the status of the file descriptor was checked, it would have returned at least one byte
of data, an end-of-file indication, or an error, without blocking (even if O_NONBLOCK is clear). When a pselect() or
select() call indicates that a file descriptor is ready for writing, this means that if an attempt to write one byte of data
had been made at the time that the status of the file descriptor was checked, it would have written that byte or returned an error,
without blocking. However, if an attempt to write more than one byte had been made, it might have blocked (if O_NONBLOCK is clear).
In both cases, by the time the call returns and a subsequent I/O operation is attempted, the state of the file descriptor might
have changed (for example, because another thread read or wrote some data) and, if O_NONBLOCK is clear, there is no guarantee that
the operation will not block (unless it would not block for some other reason, such as setting MIN=0 and TIME=0 for a terminal in
non-canonical mode). Therefore it is recommended that applications always set O_NONBLOCK on file descriptors whose readiness for
I/O they query with pselect() or select().
RATIONALE
In earlier versions of the Single UNIX Specification, the select() function was defined in the  header. This is now changed to . The rationale for this change was as follows: the introduction of
the pselect() function included the  header and the
header defines all the related definitions for the
pselect() and select() functions. Backwards-compatibility to existing XSI implementations is handled by allowing
to include .
Code which wants to avoid the ambiguity of the signal mask for thread cancellation handlers can install an additional
cancellation handler which resets the signal mask to the expected value.
void cleanup(void *arg)
{
sigset_t *ss = (sigset_t *) arg;
pthread_sigmask(SIG_SETMASK, ss, NULL);
}
int call_pselect(int nfds, fd_set *readfds, fd_set *writefds,
fd_set errorfds, const struct timespec *timeout,
const sigset_t *sigmask)
{
sigset_t oldmask;
int result;
pthread_sigmask(SIG_SETMASK, NULL, &oldmask);
pthread_cleanup_push(cleanup, &oldmask);
result = pselect(nfds, readfds, writefds, errorfds, timeout, sigmask);
pthread_cleanup_pop(0);
return result;
}
FUTURE DIRECTIONS
None.
SEE ALSO
accept(), alarm(), connect(), fcntl(), poll(), read(), recvmsg(), sendmsg(), write()
XBD ,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
In the ERRORS section, the text has been changed to indicate that [EINVAL] is returned when nfds is less than 0 or
greater than FD_SETSIZE. It previously stated less than 0, or greater than or equal to FD_SETSIZE.
Text about timeout is moved from the APPLICATION USAGE section to the DESCRIPTION.
Issue 6
The Open Group Corrigendum U026/6 is applied, changing the occurrences of readfs and writefs in the
select() DESCRIPTION to be readfds and writefds.
Text referring to sockets is added to the DESCRIPTION.
The DESCRIPTION and ERRORS sections are updated so that references to STREAMS are marked as part of the XSI STREAMS Option
Group.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
These functions are now mandatory.
The pselect() function is added for alignment with IEEE Std 1003.1g-2000 and additional detail related to
sockets semantics is added to the DESCRIPTION.
The select() function now requires inclusion of .
The restrict keyword is added to the select() prototype for alignment with the ISO/IEC 9899:1999
standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/70 is applied, updating the DESCRIPTION to reference the signal
mask in terms of the calling thread rather than the process.
Issue 7
SD5-XSH-ERN-122 is applied, adding text to the DESCRIPTION for when a thread is canceled during a call to pselect(), and
adding example code to the RATIONALE.
Functionality relating to the XSI STREAMS option is marked obsolescent.
Functionality relating to the Threads option is moved to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0446 [372] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0259 [680] is applied.
Issue 8
Austin Group Defect 220 is applied, adding const to the second parameter of FD_ISSET().
Austin Group Defect 411 is applied, adding accept4().
Austin Group Defect 1186 is applied, clarifying the behavior when the pselect() function is interrupted by a signal.
Austin Group Defect 1263 is applied, changing the APPLICATION USAGE section.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
Austin Group Defect 1448 is applied, changing the APPLICATION USAGE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/htonl.html =====
htonl
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
htonl, htons, ntohl, ntohs — convert values between host and network byte order
SYNOPSIS
#include
uint32_t htonl(uint32_t hostlong);
uint16_t htons(uint16_t hostshort);
uint32_t ntohl(uint32_t netlong);
uint16_t ntohs(uint16_t netshort);
DESCRIPTION
These functions shall convert 16-bit and 32-bit quantities between network byte order and host byte order.
On some implementations, these functions are defined as macros.
The uint32_t and uint16_t types are defined in .
RETURN VALUE
The htonl() and htons() functions shall return the argument value converted from host to network byte order.
The ntohl() and ntohs() functions shall return the argument value converted from network to host byte order.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
These functions are most often used in conjunction with IPv4 addresses and ports as returned by gethostent() and getservent().
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
be16toh(), endhostent(),
endservent()
XBD , ,
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
Issue 8
Austin Group Defect 162 is applied, adding be16toh() and  to the SEE ALSO section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/alarm.html =====
alarm
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
alarm — schedule an alarm signal
SYNOPSIS
#include
unsigned alarm(unsigned seconds);
DESCRIPTION
The alarm() function shall cause the system to generate a SIGALRM signal for the process after the number of realtime
seconds specified by seconds have elapsed. Processor scheduling delays may prevent the process from handling the signal as
soon as it is generated.
If seconds is 0, a pending alarm request, if any, is canceled.
Alarm requests are not stacked; only one SIGALRM generation can be scheduled in this manner. If the SIGALRM signal has not yet
been generated, the call shall result in rescheduling the time at which the SIGALRM signal is generated.
RETURN VALUE
If there is a previous alarm() request with time remaining, alarm() shall return a non-zero value that is the
number of seconds until the previous request would have generated a SIGALRM signal. Otherwise, alarm() shall return 0.
ERRORS
The alarm() function is always successful, and no return value is reserved to indicate an error.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The fork() function clears pending alarms in the child process. A new process image
created by one of the exec functions inherits the time left to an alarm signal in the
image of the old process.
Application developers should note that the type of the argument seconds and the return value of alarm() is
unsigned. That means that a Strictly Conforming POSIX System Interfaces Application cannot pass a value greater than the
minimum guaranteed value for {UINT_MAX}, which the ISO C standard sets as 65535, and any application passing a larger value is
restricting its portability. A different type was considered, but historical implementations, including those with a 16-bit
int type, consistently use either unsigned or int.
Application developers should be aware of possible interactions when the same process uses both the alarm() and sleep() functions.
RATIONALE
Many historical implementations (including Version 7 and System V) allow an alarm to occur up to a second early. Other
implementations allow alarms up to half a second or one clock tick early or do not allow them to occur early at all. The latter is
considered most appropriate, since it gives the most predictable behavior, especially since the signal can always be delayed for an
indefinite amount of time due to scheduling. Applications can thus choose the seconds argument as the minimum amount of time
they wish to have elapse before the signal.
The term "realtime" here and elsewhere (sleep(), times()) is intended to mean "wall clock" time as common English usage, and has nothing to
do with "realtime operating systems". It is in contrast to virtual time, which could be misinterpreted if just time
were used.
In some implementations, including 4.3 BSD, very large values of the seconds argument are silently rounded down to an
implementation-specific maximum value. This maximum is large enough (to the order of several months) that the effect is not
noticeable.
There were two possible choices for alarm generation in multi-threaded applications: generation for the calling thread or
generation for the process. The first option would not have been particularly useful since the alarm state is maintained on a
per-process basis and the alarm that is established by the last invocation of alarm() is the only one that would be
active.
Furthermore, allowing generation of an asynchronous signal for a thread would have introduced an exception to the overall signal
model. This requires a compelling reason in order to be justified.
FUTURE DIRECTIONS
None.
SEE ALSO
alarm, exec, fork(), pause(), sigaction(), sleep(), timer_create()
XBD ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The DESCRIPTION is updated to indicate that interactions with the setitimer(), ualarm(), and usleep()
functions are unspecified.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/16 is applied, replacing "an implementation-defined maximum
value" with "an implementation-specific maximum value" in the RATIONALE.
Issue 8
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/msgsnd.html =====
msgsnd
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
msgsnd — XSI message send operation
SYNOPSIS
[XSI]  #include
int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
DESCRIPTION
The msgsnd() function operates on XSI message queues (see XBD 3.206
Message Queue). It is unspecified whether this function interoperates with the realtime interprocess communication
facilities defined in 2.8 Realtime.
The msgsnd() function shall send a message to the queue associated with the message queue identifier specified by
msqid.
The application shall ensure that the argument msgp points to a user-defined buffer that contains first a field of type
long specifying the type of the message, and then a data portion that holds the data bytes of the message. The structure
below is an example of what this user-defined buffer might look like:
struct mymsg {
long   mtype;       /* Message type. */
char   mtext[1];    /* Message text. */
}
The structure member mtype is a non-zero positive type long that can be used by the receiving process for message
selection.
The structure member mtext is any text of length msgsz bytes. The argument msgsz can range from 0 to a
system-imposed maximum.
The argument msgflg specifies the action to be taken if one or more of the following is true:
The number of bytes already on the queue is equal to msg_qbytes; see .
The total number of messages on all queues system-wide is equal to the system-imposed limit.
These actions are as follows:
If (msgflg & IPC_NOWAIT) is non-zero, the message shall not be sent and the calling thread shall return immediately.
If (msgflg & IPC_NOWAIT) is 0, the calling thread shall suspend execution until one of the following occurs:
The condition responsible for the suspension no longer exists, in which case the message is sent.
The message queue identifier msqid is removed from the system; when this occurs, errno shall be set to [EIDRM] and
-1 shall be returned.
The calling thread receives a signal that is to be caught; in this case the message is not sent and the calling thread resumes
execution in the manner prescribed in sigaction().
Upon successful completion, the following actions are taken with respect to the data structure associated with msqid; see
:
msg_qnum shall be incremented by 1.
msg_lspid shall be set to the process ID of the calling process.
msg_stime shall be set to the current time, as described in 2.7.1
IPC General Description.
RETURN VALUE
Upon successful completion, msgsnd() shall return 0; otherwise, no message shall be sent, msgsnd() shall return
-1, and errno shall be set to indicate the error.
ERRORS
The msgsnd() function shall fail if:
[EACCES]
Operation permission is denied to the calling process; see 2.7 XSI
Interprocess Communication.
[EAGAIN]
The message cannot be sent for one of the reasons cited above and (msgflg & IPC_NOWAIT) is non-zero.
[EIDRM]
The message queue identifier msqid is removed from the system.
[EINTR]
The msgsnd() function was interrupted by a signal.
[EINVAL]
The value of msqid is not a valid message queue identifier, or the value of mtype is less than 1; or the value of
msgsz is greater than the system-imposed limit.
The following sections are informative.
EXAMPLES
Sending a Message
The following example sends a message to the queue identified by the msqid argument (assuming that value has previously
been set). This call specifies that an error should be reported if no message is available. The message size is calculated directly
using the sizeof operator.
#include
...
int result;
int msqid;
struct message {
long type;
char text[20];
} msg;
msg.type = 1;
strcpy(msg.text, "This is message 1");
...
result = msgsnd(msqid, (void *) &msg, sizeof(msg.text), IPC_NOWAIT);
APPLICATION USAGE
The POSIX Realtime Extension defines alternative interfaces for interprocess communication (IPC). Application developers who
need to use IPC should design their applications so that modules using the IPC routines described in 2.7 XSI Interprocess Communication can be easily modified to use the alternative
interfaces.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.7 XSI Interprocess Communication, 2.8 Realtime, mq_close(),
mq_getattr(), mq_notify(),
mq_open(), mq_receive(),
mq_send(), mq_setattr(),
mq_unlink(), msgctl(), msgget(), msgrcv(), sigaction()
XBD 3.206 Message Queue,
CHANGE HISTORY
First released in Issue 2. Derived from Issue 2 of the SVID.
Issue 5
The note about use of POSIX Realtime Extension IPC routines has been moved from FUTURE DIRECTIONS to a new APPLICATION USAGE
section.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0400 [345] and XSH/TC1-2008/0401 [359] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/endservent.html =====
endservent
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
endservent, getservbyname, getservbyport, getservent, setservent — network services database functions
SYNOPSIS
#include
void endservent(void);
struct servent *getservbyname(const char *name, const char *proto);
struct servent *getservbyport(int port, const char *proto);
struct servent *getservent(void);
void setservent(int stayopen);
DESCRIPTION
These functions shall retrieve information about network services. This information is considered to be stored in a database
that can be accessed sequentially or randomly. The implementation of this database is unspecified.
The setservent() function shall open a connection to the database, and set the next entry to the first entry. If the
stayopen argument is non-zero, the net database shall not be closed after each call to the getservent()
function (either directly, or indirectly through one of the other getserv*() functions), and the implementation may maintain
an open file descriptor for the database. If a file descriptor is used, the FD_CLOEXEC flag shall be set; see .
The getservent() function shall read the next entry of the database, opening and closing a connection to the database as
necessary.
The getservbyname() function shall search the database from the beginning and find the first entry for which the service
name specified by name matches the s_name member and the protocol name specified by proto matches the
s_proto member, opening and closing a connection to the database as necessary. If proto is a null pointer, any value
of the s_proto member shall be matched.
The getservbyport() function shall search the database from the beginning and find the first entry for which the port
specified by port matches the s_port member and the protocol name specified by proto matches the
s_proto member, opening and closing a connection to the database as necessary. If proto is a null pointer, any value
of the s_proto member shall be matched. The port argument shall be a value obtained by converting a uint16_t
in network byte order to int.
The getservbyname(), getservbyport(), and getservent() functions shall each return a pointer to a
servent structure, the members of which shall contain the fields of an entry in the network services database.
The endservent() function shall close the database, releasing any open file descriptor.
These functions need not be thread-safe.
RETURN VALUE
Upon successful completion, getservbyname(), getservbyport(), and getservent() return a pointer to a
servent structure if the requested entry was found, and a null pointer if the end of the database was reached or the
requested entry was not found. Otherwise, a null pointer is returned.
The application shall not modify the structure to which the return value points, nor any storage areas pointed to by pointers
within the structure. The returned pointer, and pointers within the structure, might be invalidated or the structure or the storage
areas might be overwritten by a subsequent call to getservbyname(), getservbyport(), or getservent(). The
returned pointer, and pointers within the structure, might also be invalidated if the calling thread is terminated.
ERRORS
The getservbyname(), getservbyport(), getservent(), and setservent() functions may fail if:
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum allowable number of files is currently open in the system.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The port argument of getservbyport() need not be compatible with the port values of all address families.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
endhostent(), endprotoent(), htonl(), inet_addr()
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
SD5-XBD-ERN-14 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0088 [75] and XSH/TC1-2008/0089 [75] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0095 [656] is applied.
Issue 8
Austin Group Defect 368 is applied, adding a requirement for FD_CLOEXEC to be set if a file descriptor is used, and adding the
[EMFILE] and [ENFILE] errors.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/posix_memalign.html =====
posix_memalign
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
posix_memalign — aligned memory allocation (ADVANCED REALTIME)
SYNOPSIS
[ADV]  #include
int posix_memalign(void **memptr, size_t alignment, size_t size);
DESCRIPTION
The posix_memalign() function shall allocate size bytes aligned on a boundary specified by alignment, and
shall return a pointer to the allocated memory in memptr. The value of alignment shall be a power of two multiple of
sizeof(void *).
Upon successful completion, the value pointed to by memptr shall be a multiple of alignment.
If the size of the space requested is 0, the behavior is implementation-defined: either a null pointer shall be returned in
memptr, or the behavior shall be as if the size were some non-zero value, except that the behavior is undefined if the the
value returned in memptr is used to access an object.
[CX]  The
free() function shall deallocate memory that has previously been allocated by
posix_memalign().
For purposes of determining the existence of a data race, posix_memalign() shall behave as though it accessed only memory
locations accessible through its argument and not other static duration storage. The function may, however, visibly modify the
storage that it allocates. Calls to aligned_alloc(), calloc(), free(), malloc(), posix_memalign(), reallocarray(), and realloc() that
allocate or deallocate a particular region of memory shall occur in a single total order (see 4.15.1 Memory Ordering), and each such deallocation call shall synchronize
with the next allocation (if any) in this order.
RETURN VALUE
Upon successful completion, posix_memalign() shall return zero; otherwise, an error number shall be returned to indicate
the error and the contents of memptr shall either be left unmodified or be set to a null pointer.
If size is 0, either:
posix_memalign() shall not attempt to allocate any space, in which case either an implementation-defined error number
shall be returned, or zero shall be returned with a null pointer returned in memptr, or
posix_memalign() shall attempt to allocate some space and, if the allocation succeeds, zero shall be returned and a
pointer to the allocated space shall be returned in memptr. The application shall ensure that the pointer is not used to
access an object.
ERRORS
The posix_memalign() function shall fail if:
[EINVAL]
The value of the alignment parameter is not a power of two multiple of sizeof(void *).
[ENOMEM]
There is insufficient memory available with the requested alignment.
The following sections are informative.
EXAMPLES
The following example shows how applications can obtain consistent behavior on error by setting *memptr to be a null
pointer before calling posix_memalign().
void *ptr = NULL;
...
//do some work, which might goto error
if (posix_memalign(&ptr, align, size))
goto error;
//do some more work, which might goto error
...
error:
free(ptr);
//more cleanup;
APPLICATION USAGE
The posix_memalign() function is part of the Advisory Information option and need not be provided on all
implementations.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
aligned_alloc(), free(),
malloc()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1d-1999.
In the SYNOPSIS, the inclusion of  is no longer
required.
Issue 7
Austin Group Interpretation 1003.1-2001 #058 is applied, clarifying the value of the alignment argument in the
DESCRIPTION.
Austin Group Interpretation 1003.1-2001 #152 is applied, clarifying the behavior when the size of the space requested is 0.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0251 [526] and XSH/TC2-2008/0252 [520,526] are applied.
Issue 8
Austin Group Defect 1302 is applied, aligning this function with the requirements of the ISO/IEC 9899:2018 standard on
other memory allocation functions.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/posix_spawnattr_getflags.html =====
posix_spawnattr_getflags
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
posix_spawnattr_getflags, posix_spawnattr_setflags — get and set the spawn-flags attribute of a spawn attributes object
(ADVANCED REALTIME)
SYNOPSIS
[SPN]  #include
int posix_spawnattr_getflags(const posix_spawnattr_t *restrict attr,
short *restrict flags);
int posix_spawnattr_setflags(posix_spawnattr_t *attr, short flags);
DESCRIPTION
The posix_spawnattr_getflags() function shall obtain the value of the spawn-flags attribute from the attributes
object referenced by attr.
The posix_spawnattr_setflags() function shall set the spawn-flags attribute in an initialized attributes object
referenced by attr.
The spawn-flags attribute is used to indicate which process attributes are to be changed in the new process image when
invoking posix_spawn() or posix_spawnp(). It is the bitwise-inclusive OR of zero or more of the following
flags:
POSIX_SPAWN_RESETIDS
POSIX_SPAWN_SETPGROUP
[PS]
POSIX_SPAWN_SETSCHEDPARAM
POSIX_SPAWN_SETSCHEDULER
POSIX_SPAWN_SETSID
POSIX_SPAWN_SETSIGDEF
POSIX_SPAWN_SETSIGMASK
These flags are defined in . The default value of this attribute
shall be as if no flags were set.
RETURN VALUE
Upon successful completion, posix_spawnattr_getflags() shall return zero and store the value of the spawn-flags
attribute of attr into the object referenced by the flags parameter; otherwise, an error number shall be returned to
indicate the error.
Upon successful completion, posix_spawnattr_setflags() shall return zero; otherwise, an error number shall be returned to
indicate the error.
ERRORS
These functions may fail if:
[EINVAL]
The value specified by attr is invalid.
The posix_spawnattr_setflags() function may fail if:
[EINVAL]
The value of the attribute being set is not valid.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
These functions are part of the Spawn option and need not be provided on all implementations.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
posix_spawn(), posix_spawnattr_destroy(), posix_spawnattr_getsigdefault(), posix_spawnattr_getpgroup(), posix_spawnattr_getschedparam(), posix_spawnattr_getschedpolicy(), posix_spawnattr_getsigmask()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1d-1999.
Issue 8
Austin Group Defect 1044 is applied, adding POSIX_SPAWN_SETSID.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/setresuid.html =====
setresuid
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
setresuid — set real user ID, effective user ID, and saved set-user-ID
SYNOPSIS
[XSI]  #include
int setresuid(uid_t ruid, uid_t euid, uid_t suid);
DESCRIPTION
The setresuid() function shall set the real user ID, effective user ID, and saved set-user-ID of the calling process to
the values specified by ruid, euid, and suid, respectively.
If an argument is -1, the corresponding ID shall not be changed.
Only a process with appropriate privileges can set the real user ID, effective user ID, and saved set-user-ID to any valid
value.
A non-privileged process can set its real user ID, effective user ID, and saved set-user-ID, each to one of the values that it
currently holds in its real user ID, effective user ID, or saved set-user-ID.
The real user ID, effective user ID, and saved set-user-ID can be set to different values in the same call.
RETURN VALUE
Upon successful completion, 0 shall be returned. Otherwise, -1 shall be returned and errno set to indicate the error, and
none of the IDs shall be changed.
ERRORS
The setresuid() function shall fail if:
[EINVAL]
The value of the ruid, euid, or suid argument is invalid or out-of-range.
[EPERM]
The calling process does not have appropriate privileges and an attempt was made to change the real user ID, effective user ID,
or saved set-user-ID to a value that is not currently present in one of those IDs or an attempt was made to change the real user ID
to a value not permitted by the implementation.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
exec, getegid(), geteuid(), getgid(), getresgid(), getresuid(), getuid(), setegid(), seteuid(), setgid(), setregid(), setresgid(), setreuid(), setuid()
XBD
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/dcgettext_l.html =====
gettext
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
dgettext, dgettext_l, dcgettext, dcgettext_l, gettext, gettext_l, ngettext, ngettext_l, dngettext, dngettext_l,
dcngettext, dcngettext_l — message handling functions
SYNOPSIS
#include
char *dgettext(const char *domainname, const char *msgid);
char *dgettext_l(const char *domainname, const char *msgid,
locale_t locale);
char *dcgettext(const char *domainname, const char *msgid,
int category);
char *dcgettext_l(const char *domainname, const char *msgid,
int category, locale_t locale);
char *dngettext(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n);
char *dngettext_l(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n,
locale_t locale);
char *dcngettext(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n,
int category);
char *dcngettext_l(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n,
int category, locale_t locale);
char *gettext(const char *msgid);
char *gettext_l(const char *msgid, locale_t locale);
char *ngettext(const char *msgid, const char *msgid_plural,
unsigned long int n);
char *ngettext_l(const char *msgid, const char *msgid_plural,
unsigned long int n, locale_t locale);
DESCRIPTION
The gettext() function shall:
attempt to locate a suitable messages object (described in detail below) for the LC_MESSAGES category in the current
locale, and for the current text domain (see bindtextdomain()), containing
the string identified by msgid,
retrieve the string identified by msgid from the messages object,
convert the string to the output codeset if necessary (described in detail below), and
return the result.
If the locale name in effect is "POSIX" or "C" (i.e. the name associated with the LC_MESSAGES locale
category in the current locale), or if no suitable messages object exists, or if no string identified by msgid exists in the
messages object, or if an error occurs, msgid shall be returned.
The dgettext() function shall be equivalent to gettext(), except domainname shall be used instead of the
current text domain to locate the messages object.
The dcgettext() function shall be equivalent to dgettext(), except the locale category identified by
category shall be used instead of LC_MESSAGES .
The ngettext() function shall be equivalent to gettext(), except:
The string to retrieve shall be identified by a combination of msgid and n (see msgfmt).
If the locale name in effect is "POSIX" or "C", or if no suitable messages object exists, or if no string
identified by the combination of msgid and n exists in the messages object, or if an error occurs, the return value
shall be msgid if n is 1, otherwise msgid_plural.
The dngettext() function shall be equivalent to ngettext(), except domainname shall be used instead of the
current text domain to locate the messages object.
The dcngettext() function shall be equivalent to dngettext(), except the locale category identified by
category shall be used instead of LC_MESSAGES .
The *_l() functions shall be equivalent to their counterparts without the _l suffix, except locale shall be
used instead of the current locale. If locale is the special locale object LC_GLOBAL_LOCALE or is not a valid locale object
handle, the behavior is undefined.
The application shall ensure that the msgid and msgid_plural arguments are strings. If either msgid or
msgid_plural is an empty string, or contains characters not in the portable character set, the results are unspecified. If
the category argument is LC_ALL , the results are unspecified.
The location of the messages object shall be determined according to the following criteria, stopping when the first messages
object is found:
[XSI]
If the NLSPATH environment variable is set to a non-empty string, an NLSPATH search shall be performed as described
in XBD 8.2 Internationalization Variables. If NLSPATH identifies
more than one template to use, each template in turn shall be used until a valid messages object is found.
If the LANGUAGE environment variable is set to a non-empty string, a LANGUAGE search shall be performed as
described below. If LANGUAGE identifies more than one directory to search, each directory shall be searched until a valid
messages object is found.
A single-locale search shall be performed as described below.
For [XSI]   the NLSPATH search and   the single-locale search,
the single locale name used to locate the messages object shall be the locale name associated with the selected locale category
from the current locale, or the provided locale object if calling one of the *_l() functions; additional searches of locale
names without .codeset (if present), without _territory (if present), and without @modifier (if present) may
be performed.
For the LANGUAGE search, the value of the LANGUAGE environment variable shall be a list of one or more locale
names separated by a  (':') character. Each locale name shall be tried in the specified order. If a messages
object for the locale does not exist, or cannot be opened, or is unsuitable for implementation-defined reasons (such as security),
the next locale name (if any) shall be tried. If:
a messages object for the locale can be opened but cannot be processed without error, or
the messages object does not contain a string identified by msgid, or msgid and n for the ngettext
functions,
it is unspecified whether the next locale name (if any) is tried. In all other cases, the messages object for the locale shall
be used.
For each locale name in LANGUAGE , or if LANGUAGE is not set or is empty, or no suitable messages object is found
in processing LANGUAGE , the pathname used to locate the messages object shall be
dirname/localename/categoryname/textdomainname.mo, where:
The dirname part is the dirname argument of the most recent successful call to bindtextdomain() that had textdomainname as the domainname argument;
any trailing  characters in dirname shall be discarded. If a successful call to bindtextdomain() has not been made for textdomainname, an
implementation-defined default directory shall be used.
For the LANGUAGE search, the localename part is each locale name from LANGUAGE in turn; if a locale name
has the format language[_territory][.codeset][@modifier], additional
searches of locale names without .codeset (if present), without _territory (if present), and without @modifier
(if present) may be performed; if .codeset is not present, additional searches of locale names with an added .codeset
may be performed. For the single-locale search, the localename part is the name of the current locale, or the locale
specified in an *_l() function call, for the category named by categoryname. Spellings of codeset names are not
standardized, and implementations may attempt to use different commonly known spellings, for example "utf8" and
"UTF-8".
The categoryname part is the string "LC_MESSAGES" if gettext(), dgettext(), ngettext(), or
dngettext() is called, or the locale category name corresponding to the category argument to dcgettext() or
dcngettext(). Likewise for the *_l() variants of all these functions.
For gettext(), gettext_l(), ngettext(), and ngettext_l(), the textdomainname part is the text
domain set by the last successful call to textdomain(). For dgettext(),
dcgettext(), dngettext(), dcngettext(), and the *_l() variants of these functions,
textdomainname is the text domain specified by the domainname argument. The domainname argument shall be
equivalent in syntax and meaning to the domainname argument to textdomain(), except that the selection of the text domain shall affect only the
dgettext(), dcgettext(), dngettext(), and dcngettext() function calls and their *_l() variants.
If the domainname argument is a null pointer, the text domain set by the last successful call to textdomain() shall be used. For all of these functions, if a successful call to textdomain() has not been made the default text domain "messages" shall be
used.
Resolution of the messages object pathname shall be performed the first time one of the gettext family of functions is
called for a given combination of dirname, localename, categoryname, and textdomainname. It is
unspecified whether the pathname is re-resolved if the combination has been used before in a call to one of the gettext
family of functions. If bindtextdomain() performs pathname resolution of its
dirname argument, only the part of the messages object pathname after dirname shall be resolved by the gettext
family of functions.
When one of the gettext family of functions returns a message string that was found in a messages object, it shall
convert the codeset of the message string to the output codeset if a codeset is specified in the messages object (see msgfmt) and the output codeset is not the same as that codeset. If a successful call to
bind_textdomain_codeset() has been made with the text domain of the
messages object as the domainname argument and a non-null codeset argument, the output codeset shall be the
codeset argument from the most recent such call. Otherwise, the output codeset shall be the codeset of characters in the
current locale, or the provided locale object if calling one of the *_l() functions, as specified by the LC_CTYPE
category of the locale. The conversion shall be performed as if by a call to iconv()
using a conversion descriptor returned by iconv_open(, ),
except that if the return value of iconv() would be greater than zero, the
non-identical conversions performed by the gettext family of functions need not be the same as those that such an iconv() call would perform. If an error prevents the codeset conversion from being performed,
the gettext family of functions shall behave as if no message string was found in the messages object. If at least one
non-identical conversion is performed that results in a fallback character (one that does not provide any information about the
character it was converted from, for example, a  or "replacement-character"), the gettext family of
functions may behave as if no message string was found in the messages object.
RETURN VALUE
The gettext(), gettext_l(), dgettext(), dgettext_l(), dcgettext(), and dcgettext_l()
functions shall return the message string described in DESCRIPTION if successful. Otherwise, they shall return msgid.
The ngettext(), ngettext_l(), dngettext(), dngettext_l(), dcngettext(), and
dcngettext_l() functions shall return the message string described in DESCRIPTION if successful. Otherwise, msgid
shall be returned if n is equal to 1, or msgid_plural if n is not equal to 1.
The application shall ensure that it does not modify the returned string. A subsequent call to a gettext family function
shall not overwrite or invalidate the returned string. The returned string may be invalidated by a subsequent call to bind_textdomain_codeset(), bindtextdomain(), setlocale(), or
textdomain() in the same process, except for calls that only query values. The
returned string shall not be invalidated by a subsequent call to uselocale().
ERRORS
The gettext family of functions shall not modify errno. If an error occurs these functions shall return a string
as described in RETURN VALUE.
The following sections are informative.
EXAMPLES
The example code below assumes the following:
The implementation-defined default directory is /system/gettextlib.
The following locales are available on the target system: en_US, en_GB, de_DE. The codeset used for all of these locales is
UTF-8.
The en_AU locale is not available on the target system.
The target system supports conversion from ISO/IEC 8859-1 to UTF-8.
The codeset used for the POSIX locale is ASCII.
The target system does not support conversion from ISO/IEC 8859-1 to ASCII.
Furthermore, the following .mo files (and only the following .mo files) are installed:
/system/gettextlib/en_US/LC_MESSAGES/mail.mo
/messagecatalogs/example/en_US/LC_MESSAGES/mail.mo
These are compiled from a portable messages object source file (dot-po file) with the following ISO/IEC 8859-1 encoded contents
(see the EXTENDED DESCRIPTION of the msgfmt utility for a description of the dot-po
file format):
msgid ""
msgstr ""
"Content-Type: text/plain; charset=ISO_8859-1\n"
"Plural-Forms: nplurals=4; plural= n==1?0: (n>1&&n1&&n1&&n,
XCU gettext, msgfmt,
xgettext
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_attr_setstack.html =====
pthread_attr_getstack
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_attr_getstack, pthread_attr_setstack — get and set stack attributes
SYNOPSIS
[TSA TSS]  #include
int pthread_attr_getstack(const pthread_attr_t *restrict attr,
void **restrict stackaddr, size_t *restrict stacksize);
int pthread_attr_setstack(pthread_attr_t *attr, void *stackaddr,
size_t stacksize);
DESCRIPTION
The pthread_attr_getstack() and pthread_attr_setstack() functions, respectively, shall get and set the thread
creation stack attributes stackaddr and stacksize in the attr object.
The stack attributes specify the area of storage to be used for the created thread's stack. The base (lowest addressable byte)
of the storage shall be stackaddr, and the size of the storage shall be stacksize bytes. The stacksize shall
be at least {PTHREAD_STACK_MIN}. The pthread_attr_setstack() function may fail with [EINVAL] if stackaddr does not
meet implementation-defined alignment requirements. All pages within the stack described by stackaddr and stacksize
shall be both readable and writable by the thread.
If the pthread_attr_getstack() function is called before the stackaddr attribute has been set, the behavior is
unspecified.
The behavior is undefined if the value specified by the attr argument to pthread_attr_getstack() or
pthread_attr_setstack() does not refer to an initialized thread attributes object.
RETURN VALUE
Upon successful completion, these functions shall return a value of 0; otherwise, an error number shall be returned to indicate
the error.
The pthread_attr_getstack() function shall store the stack attribute values in stackaddr and stacksize if
successful.
ERRORS
The pthread_attr_setstack() function shall fail if:
[EINVAL]
The value of stacksize is less than {PTHREAD_STACK_MIN} or exceeds an implementation-defined limit.
The pthread_attr_setstack() function may fail if:
[EINVAL]
The value of stackaddr does not have proper alignment to be used as a stack, or ((char *)stackaddr +
stacksize) lacks proper alignment.
[EACCES]
The stack page(s) described by stackaddr and stacksize are not both readable and writable by the thread.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
These functions are appropriate for use by applications in an environment where the stack for a thread must be placed in some
particular region of memory.
While it might seem that an application could detect stack overflow by providing a protected page outside the specified stack
region, this cannot be done portably. Implementations are free to place the thread's initial stack pointer anywhere within the
specified region to accommodate the machine's stack pointer behavior and allocation requirements. Furthermore, on some
architectures, such as the IA-64, "overflow" might mean that two separate stack pointers allocated within the region will overlap
somewhere in the middle of the region.
After a successful call to pthread_attr_setstack(), the storage area specified by the stackaddr parameter is under
the control of the implementation, as described in 2.9.8 Use of
Application-Managed Thread Stacks.
The specification of the stackaddr attribute presents several ambiguities that make portable use of these functions
impossible. For example, the standard allows implementations to impose arbitrary alignment requirements on stackaddr.
Applications cannot assume that a buffer obtained from malloc() is suitably aligned.
Note that although the stacksize value passed to pthread_attr_setstack() must satisfy alignment requirements, the
same is not true for pthread_attr_setstacksize() where the
implementation must increase the specified size if necessary to achieve the proper alignment.
RATIONALE
If an implementation detects that the value specified by the attr argument to pthread_attr_getstack() or
pthread_attr_setstack() does not refer to an initialized thread attributes object, it is recommended that the function
should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_attr_destroy(), pthread_attr_getdetachstate(), pthread_attr_getstacksize(), pthread_create()
XBD ,
CHANGE HISTORY
First released in Issue 6. Developed as part of the XSI option and brought into the BASE by IEEE PASC Interpretation 1003.1
#101.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/83 is applied, updating the APPLICATION USAGE section to refer
to 2.9.8 Use of Application-Managed Thread Stacks.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC/D6/84 is applied, updating the ERRORS section to include optional
errors for the case when attr refers to an uninitialized thread attribute object.
Issue 7
SD5-XSH-ERN-66 is applied, correcting the use of attr in the [EINVAL] error condition.
Austin Group Interpretation 1003.1-2001 #057 is applied, clarifying the behavior if the function is called before the
stackaddr attribute is set.
SD5-XSH-ERN-157 is applied, updating the APPLICATION USAGE section.
The description of the stackaddr attribute is updated in the DESCRIPTION and APPLICATION USAGE sections.
The [EINVAL] error for an uninitialized thread attributes object is removed; this condition results in undefined behavior.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/rintl.html =====
rint
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
rint, rintf, rintl — round-to-nearest integral value
SYNOPSIS
#include
double rint(double x);
float rintf(float x);
long double rintl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall return the integral value (represented as a double) nearest x in the direction of the
current rounding mode. The current rounding mode is implementation-defined.
If the current rounding mode rounds toward negative infinity, then rint() shall be equivalent to floor(). If the current rounding mode rounds toward positive infinity, then rint()
shall be equivalent to ceil(). If the current rounding mode rounds towards zero, then
rint() shall be equivalent to trunc(). [MX]   If the current
rounding mode rounds towards nearest, then rint() differs from round() in that
halfway cases are rounded to even rather than away from zero.
These functions differ from the nearbyint(), nearbyintf(), and nearbyintl()
functions only in that they may raise the inexact floating-point exception if the result differs in value from the argument.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the integer (represented as a double precision number) nearest x
in the direction of the current rounding mode. [MX]   The result shall have the same sign as x.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0 or ±Inf, x shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The integral value returned by these functions need not be expressible as an intmax_t. The return value should be tested
before assigning it to an integer type to avoid the undefined results of an integer overflow.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
abs(), ceil(), feclearexcept(), fetestexcept()
, floor(), isnan(), nearbyint()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The rintf() and rintl() functions are added.
The rint() function is no longer marked as an extension.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0514 [346], XSH/TC1-2008/0515 [346], XSH/TC1-2008/0516 [346],
XSH/TC1-2008/0517 [346], and XSH/TC1-2008/0518 [346] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/putchar_unlocked.html =====
getc_unlocked
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getc_unlocked, getchar_unlocked, putc_unlocked, putchar_unlocked — stdio with explicit client locking
SYNOPSIS
[CX]  #include
int getc_unlocked(FILE *stream);
int getchar_unlocked(void);
int putc_unlocked(int c, FILE *stream);
int putchar_unlocked(int c);
DESCRIPTION
Versions of the functions getc(), getchar(), putc(), and putchar() respectively named getc_unlocked(), getchar_unlocked(),
putc_unlocked(), and putchar_unlocked() shall be provided which are functionally equivalent to the original versions,
with the exception that they are not required to be implemented in a fully thread-safe manner. They shall be thread-safe when used
within a scope protected by flockfile() (or ftrylockfile()) and funlockfile().
These functions can safely be used in a multi-threaded program if and only if they are called while the invoking thread owns the
(FILE *) object, as is the case after a successful call to the flockfile()
or ftrylockfile() functions.
If getc_unlocked() or putc_unlocked() are implemented as macros they may evaluate stream more than once, so
the stream argument should never be an expression with side-effects.
RETURN VALUE
See getc(), getchar(), putc(), and putchar().
ERRORS
See getc(), getchar(), putc(), and putchar().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Since they may be implemented as macros, getc_unlocked() and putc_unlocked() may treat incorrectly a stream
argument with side-effects. In particular, getc_unlocked(*f++) and putc_unlocked(c,*f++) do not necessarily work as
expected. Therefore, use of these functions in such situations should be preceded by the following statement as appropriate:
#undef getc_unlocked
#undef putc_unlocked
RATIONALE
Some I/O functions are typically implemented as macros for performance reasons (for example, putc() and getc()). For safety, they need to be
synchronized, but it is often too expensive to synchronize on every character. Nevertheless, it was felt that the safety concerns
were more important; consequently, the getc(), getchar(), putc(), and putchar() functions are required to be thread-safe. However, unlocked versions are also
provided with names that clearly indicate the unsafe nature of their operation but can be used to exploit their higher performance.
These unlocked versions can be safely used only within explicitly locked program regions, using exported locking primitives. In
particular, a sequence such as:
flockfile(fileptr);
putc_unlocked('1', fileptr);
putc_unlocked('\n', fileptr);
fprintf(fileptr, "Line 2\n");
funlockfile(fileptr);
is permissible, and results in the text sequence:
1
Line 2
being printed without being interspersed with output from other threads.
It would be wrong to have the standard names such as getc(), putc(), and so on, map to the "faster, but unsafe" rather than the "slower, but safe"
versions. In either case, you would still want to inspect all uses of getc(), putc(), and so on, by hand when converting existing code. Choosing the safe bindings as the
default, at least, results in correct code and maintains the "atomicity at the function" invariant. To do otherwise would
introduce gratuitous synchronization errors into converted code. Other routines that modify the stdio (FILE *)
structures or buffers are also safely synchronized.
Note that there is no need for functions of the form getc_locked(), putc_locked(), and so on, since this is the
functionality of getc(), putc(), et
al. It would be inappropriate to use a feature test macro to switch a macro definition of getc() between getc_locked() and getc_unlocked(), since the ISO C standard
requires an actual function to exist, a function whose behavior could not be changed by the feature test macro. Also, providing
both the xxx_locked() and xxx_unlocked() forms leads to the confusion of whether the suffix describes the behavior of
the function or the circumstances under which it should be used.
Three additional routines, flockfile(), ftrylockfile(), and funlockfile()
(which may be macros), are provided to allow the user to delineate a sequence of I/O statements that are executed
synchronously.
The ungetc() function is infrequently called relative to the other
functions/macros so no unlocked variation is needed.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, flockfile(), getc(), getchar(), putc(), putchar()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
These functions are marked as part of the Thread-Safe Functions option.
The Open Group Corrigendum U030/2 is applied, adding APPLICATION USAGE describing how applications should be written to avoid
the case when the functions are implemented as macros.
Issue 7
The getc_unlocked(), getchar_unlocked(), putc_unlocked(), and putchar_unlocked() functions are moved
from the Thread-Safe Functions option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0232 [395], XSH/TC1-2008/0233 [395], XSH/TC1-2008/0234 [395], and
XSH/TC1-2008/0235 [14] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0151 [826] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/csinhl.html =====
csinh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
csinh, csinhf, csinhl — complex hyperbolic sine functions
SYNOPSIS
#include
double complex csinh(double complex z);
float complex csinhf(float complex z);
long double complex csinhl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex hyperbolic sine of z.
RETURN VALUE
These functions shall return the complex hyperbolic sine value.
[MXC]
csinh(conj(z)), csinhf(conjf(z)), and csinhl(conjl(z)) shall return
exactly the same value as conj(csinh(z)), conjf(csinhf(z)), and
conjl(csinhl(z)), respectively, and csinh(-z), csinhf(-z), and
csinhl(-z) shall return exactly the same value as -csinh(z), -csinhf(z), and
-csinhl(z), respectively, including for the special values of z below.
If z is +0 + i0, +0 + i0 shall be returned.
If z is +0 + iInf, ±0 + iNaN shall be returned and the invalid floating-point exception shall be raised;
the sign of the real part of the result is unspecified.
If z is +0 + iNaN, ±0 + iNaN shall be returned; the sign of the real part of the result is unspecified.
If z is x + iInf where x is positive and finite, NaN + iNaN shall be returned and the invalid
floating-point exception shall be raised.
If z is x + iNaN where x is non-zero and finite, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is +Inf + i0, +Inf + i0 shall be returned.
If z is +Inf + iy where y is positive and finite, +Inf (cos(y) + isin(y)) shall
be returned.
If z is +Inf + iInf, ±Inf + iNaN shall be returned and the invalid floating-point exception shall be
raised; the sign of the real part of the result is unspecified.
If z is +Inf + iNaN, ±Inf + iNaN shall be returned; the sign of the real part of the result is
unspecified.
If z is NaN + i0, NaN + i0 shall be returned.
If z is NaN + iy where y is any non-zero number, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is NaN + iNaN, NaN + iNaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
casinh()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/setkey.html =====
setkey
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
setkey — set encoding key (CRYPT)
SYNOPSIS
[OB XSI]  #include
void setkey(const char *key);
DESCRIPTION
The setkey() function provides access to an implementation-defined encoding algorithm. The argument of setkey() is
an array of length 64 bytes containing only the bytes with numerical value of 0 and 1. If this string is divided into groups of 8,
the low-order bit in each group is ignored; this gives a 56-bit key which is used by the algorithm. This is the key that shall be
used with the algorithm to encode a string block passed to encrypt().
The setkey() function shall not change the setting of errno if successful. An application wishing to check for
error situations should set errno to 0 before calling setkey(). If errno is non-zero on return, an error has
occurred.
The setkey() function need not be thread-safe.
RETURN VALUE
No values are returned.
ERRORS
The setkey() function shall fail if:
[ENOSYS]
The functionality is not supported on this implementation.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Decoding need not be implemented in all environments. This is related to government restrictions in some countries on encryption
and decryption routines. Historical practice has been to ship a different version of the encryption library without the decryption
feature in the routines supplied. Thus the exported version of encrypt() does
encoding but not decoding.
RATIONALE
None.
FUTURE DIRECTIONS
The setkey() function may be removed in a future version.
SEE ALSO
crypt(), encrypt()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate that errno is not changed if the function is successful.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0320 [899] is applied.
Issue 8
Austin Group Defect 1192 is applied, marking the setkey() function as obsolescent.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fmax.html =====
fmax
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fmax, fmaxf, fmaxl — determine maximum numeric value of two floating-point numbers
SYNOPSIS
#include
double fmax(double x, double y);
float fmaxf(float x, float y);
long double fmaxl(long double x, long double y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall determine the maximum numeric value of their arguments. [MX]   NaN arguments
shall be treated as missing data: if one argument is a NaN and the other numeric, then these functions shall choose the numeric
value.
RETURN VALUE
Upon successful completion, these functions shall return the maximum numeric value of their arguments.
[MX]  The
returned value shall be exact and shall be independent of the current rounding direction mode.
If just one argument is a NaN, the other argument shall be returned.
If x and y are NaN, a NaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
fdim(), fmin()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
Austin Group Interpretation 1003.1-2001 #007 is applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/posix_spawn_file_actions_addclose.html =====
posix_spawn_file_actions_addclose
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
posix_spawn_file_actions_addclose, posix_spawn_file_actions_addopen — add close or open action to spawn file actions
object (ADVANCED REALTIME)
SYNOPSIS
[SPN]  #include
int posix_spawn_file_actions_addclose(posix_spawn_file_actions_t
*file_actions, int fildes);
int posix_spawn_file_actions_addopen(posix_spawn_file_actions_t
*restrict file_actions, int fildes,
const char *restrict path, int oflag, mode_t
mode);
DESCRIPTION
These functions shall add a close or open action to a spawn file actions object.
A spawn file actions object is of type posix_spawn_file_actions_t (defined in ) and is used to specify a series of actions to be performed by a posix_spawn() or posix_spawnp()
operation in order to arrive at the set of open file descriptors for the child process given the set of open file descriptors of
the parent. POSIX.1-2024 does not define comparison or assignment operators for the type posix_spawn_file_actions_t.
A spawn file actions object, when passed to posix_spawn() or posix_spawnp(), shall specify how the set of open file descriptors in the calling
process is transformed into a set of potentially open file descriptors for the spawned process. This transformation shall be as if
the specified sequence of actions was performed exactly once, in the context of the spawned process (prior to execution of the new
process image), in the order in which the actions were added to the object; additionally, when the new process image is executed,
any file descriptor (from this new set) which has its FD_CLOEXEC flag set shall be closed (see posix_spawn()).
The posix_spawn_file_actions_addclose() function shall add a close action to the object referenced by
file_actions that shall cause the file descriptor fildes to be closed (as if close(fildes) had been
called) when a new process is spawned using this file actions object, except that a non-negative fildes less than {OPEN_MAX}
that is already closed at the time when the new process is spawned shall be ignored rather than failing with [EBADF].
The posix_spawn_file_actions_addopen() function shall add an open action to the object referenced by
file_actions that shall cause the file named by path to be opened (as if open(path, oflag,
mode) had been called, and the returned file descriptor, if not fildes, had been changed to fildes) when a new
process is spawned using this file actions object. If fildes was already an open file descriptor, it shall be closed before
the new file is opened. A relative path shall be interpreted in relation to the working directory determined by any prior
actions.
The string pointed to by path shall be copied by the posix_spawn_file_actions_addopen() function.
RETURN VALUE
Upon successful completion, these functions shall return zero; otherwise, an error number shall be returned to indicate the
error.
ERRORS
The posix_spawn_file_actions_addopen() function shall fail if:
[EBADF]
The value specified by fildes is negative or greater than or equal to {OPEN_MAX}.
The posix_spawn_file_actions_addclose() function shall fail if:
[EBADF]
The value specified by fildes is negative.
These functions shall fail if:
[ENOMEM]
Insufficient memory exists to add to the spawn file actions object.
These functions may fail if:
[EINVAL]
The value specified by file_actions is invalid.
It shall not be considered an error for the fildes argument passed to these functions to specify a file descriptor for
which the specified operation could not be performed at the time of the call. Any such error shall be detected when the associated
file actions object is later used during a posix_spawn() or posix_spawnp() operation.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
These functions are part of the Spawn option and need not be provided on all implementations.
Implementations may use file descriptors that must be inherited into child processes for the child process to remain conforming,
such as for message catalog or tracing purposes. Therefore, an application that calls posix_spawn_file_actions_addclose()
with an arbitrary integer risks non-conforming behavior, and this function can only portably be used to close file descriptor
values that the application has obtained through explicit actions, or for the three file descriptors corresponding to the standard
file streams. In order to avoid a race condition of leaking an unintended file descriptor into a child process or executed program,
an application should consider opening all file descriptors with the FD_CLOFORK or FD_CLOEXEC flag, or both flags, set unless the
file descriptor is intended to be inherited by child processes or executed programs, respectively.
RATIONALE
A spawn file actions object may be initialized to contain an ordered sequence of chdir(), close(), dup2(), fchdir(), and open() operations to be used by posix_spawn() or posix_spawnp() to
arrive at the set of open file descriptors and current working directory inherited by the spawned process from the set of open file
descriptors and current working directory in the parent at the time of the posix_spawn() or posix_spawnp()
call. It had been suggested that the close() and dup2() operations alone are sufficient to rearrange file descriptors, and that files which need
to be opened for use by the spawned process can be handled either by having the calling process open them before the posix_spawn() or posix_spawnp() call
(and close them after), or by passing pathnames to the spawned process (in argv) so that it may open them itself. The
standard developers recommend that applications use one of these two methods when practical, since detailed error status on a
failed open operation is always available to the application this way. However, the standard developers feel that allowing a spawn
file actions object to specify open operations is still appropriate because:
It is consistent with equivalent POSIX.5 (Ada) functionality.
It supports the I/O redirection paradigm commonly employed by POSIX programs designed to be invoked from a shell. When such a
program is the child process, it may not be designed to open files on its own.
It allows file opens that might otherwise fail or violate file ownership/access rights if executed by the parent process.
Regarding 2. above, note that the spawn open file action provides to posix_spawn() and posix_spawnp() the
same capability that the shell redirection operators provide to system(), only
without the intervening execution of a shell; for example:
system ("myprog
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1d-1999.
IEEE PASC Interpretation 1003.1 #105 is applied, adding a note to the DESCRIPTION that the string pointed to by path is
copied by the posix_spawn_file_actions_addopen() function.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0436 [418], XSH/TC1-2008/0437 [149], XSH/TC1-2008/0438 [291], and
XSH/TC1-2008/0439 [418] are applied.
Issue 8
Austin Group Defect 370 is applied, requiring that attempting to close a file descriptor that is in range, but already closed at
the time when the new process is spawned, is not treated as an error.
Austin Group Defect 1208 is applied, adding posix_spawn_file_actions_addchdir() and posix_spawn_file_actions_addfchdir().
Austin Group Defect 1318 is applied, adding FD_CLOFORK.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/clock_gettime.html =====
clock_getres
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
clock_getres, clock_gettime, clock_settime — clock and timer functions
SYNOPSIS
[CX]  #include
int clock_getres(clockid_t clock_id, struct timespec *res);
int clock_gettime(clockid_t clock_id, struct timespec *tp);
int clock_settime(clockid_t clock_id, const struct timespec *tp);
DESCRIPTION
The clock_getres() function shall return the resolution of any clock. Clock resolutions are implementation-defined and
cannot be set by a process. If the argument res is not NULL, the resolution of the specified clock shall be stored in the
location pointed to by res. If res is NULL, the clock resolution is not returned. If the time argument of
clock_settime() is not a multiple of res, then the value is truncated to a multiple of res.
The clock_gettime() function shall return the current value tp for the specified clock, clock_id.
The clock_settime() function shall set the specified clock, clock_id, to the value specified by tp. Time
values that are between two consecutive non-negative integer multiples of the resolution of the specified clock shall be truncated
down to the smaller multiple of the resolution.
A clock may be system-wide (that is, visible to all processes) or per-process (measuring time that is meaningful only within a
process). All implementations shall support a clock_id of CLOCK_REALTIME as defined in . This clock represents the clock measuring real time for the system. For this
clock, the values returned by clock_gettime() and specified by clock_settime() represent the amount of time (in
seconds and nanoseconds) since the Epoch. An implementation may also support additional clocks. The interpretation of time values
for these clocks is unspecified.
If the value of the CLOCK_REALTIME clock is set via clock_settime(), the new value of the clock shall be used to
determine the time of expiration for absolute time services based upon the CLOCK_REALTIME clock. This applies to the time at which
armed absolute timers expire. If the absolute time requested at the invocation of such a time service is before the new value of
the clock, the time service shall expire immediately as if the clock had reached the requested time normally.
Setting the value of the CLOCK_REALTIME clock via clock_settime() shall have no effect on threads that are blocked
waiting for a relative time service based upon this clock, including the nanosleep() and thrd_sleep() functions;
nor on the expiration of relative timers based upon this clock. Consequently, these time services shall expire when the requested
relative interval elapses, independently of the new or old value of the clock.
All implementations shall support a clock_id of CLOCK_MONOTONIC defined in . This clock represents the monotonic clock for the system. For this clock, the
value returned by clock_gettime() represents the amount of time (in seconds and nanoseconds) since an unspecified point in
the past (for example, system start-up time, or the Epoch). This point does not change after system start-up time. The value of the
CLOCK_MONOTONIC clock cannot be set via clock_settime(). This function shall fail if it is invoked with a clock_id
argument of CLOCK_MONOTONIC.
The effect of setting a clock via clock_settime() on armed per-process timers associated with a clock other than
CLOCK_REALTIME is implementation-defined.
If the value of the CLOCK_REALTIME clock is set via clock_settime(), the new value of the clock shall be used to
determine the time at which the system shall awaken a thread blocked on an absolute clock_nanosleep() call based upon the CLOCK_REALTIME clock. If the absolute time
requested at the invocation of such a time service is before the new value of the clock, the call shall return immediately as if
the clock had reached the requested time normally.
Setting the value of the CLOCK_REALTIME clock via clock_settime() shall have no effect on any thread that is blocked on a
relative clock_nanosleep() call. Consequently, the call shall return when
the requested relative interval elapses, independently of the new or old value of the clock.
Appropriate privileges to set a particular clock are implementation-defined.
[CPT]
If _POSIX_CPUTIME is defined, implementations shall support clock ID values obtained by invoking clock_getcpuclockid(), which represent the CPU-time clock of a given process.
Implementations shall also support the special clockid_t value CLOCK_PROCESS_CPUTIME_ID, which represents the CPU-time clock
of the calling process when invoking one of the clock_*() or timer_*() functions. For these clock IDs, the values
returned by clock_gettime() and specified by clock_settime() represent the amount of execution time of the process
associated with the clock. Changing the value of a CPU-time clock via clock_settime() shall have no effect on the behavior
of the sporadic server scheduling policy (see Scheduling Policies
).
[TCT]
If _POSIX_THREAD_CPUTIME is defined, implementations shall support clock ID values obtained by invoking pthread_getcpuclockid(), which represent the CPU-time clock of a given thread.
Implementations shall also support the special clockid_t value CLOCK_THREAD_CPUTIME_ID, which represents the CPU-time clock
of the calling thread when invoking one of the clock_*() or timer_*() functions. For these clock IDs, the values
returned by clock_gettime() and specified by clock_settime() shall represent the amount of execution time of the
thread associated with the clock. Changing the value of a CPU-time clock via clock_settime() shall have no effect on the
behavior of the sporadic server scheduling policy (see Scheduling
Policies).
RETURN VALUE
A return value of 0 shall indicate that the call succeeded. A return value of -1 shall indicate that an error occurred, and
errno shall be set to indicate the error.
ERRORS
The clock_getres(), clock_gettime(), and clock_settime() functions shall fail if:
[EINVAL]
The clock_id argument does not specify a known clock.
The clock_gettime() function shall fail if:
[EOVERFLOW]
The number of seconds will not fit in an object of type time_t.
The clock_settime() function shall fail if:
[EINVAL]
The tp argument to clock_settime() is outside the range for the given clock ID.
[EINVAL]
The tp argument specified a nanosecond value less than zero or greater than or equal to 1000 million.
[EINVAL]
The value of the clock_id argument is CLOCK_MONOTONIC.
The clock_settime() function may fail if:
[EPERM]
The requesting process does not have appropriate privileges to set the specified clock.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Note that the absolute value of the monotonic clock is meaningless (because its origin is arbitrary), and thus there is no need
to set it. Furthermore, realtime applications can rely on the fact that the value of this clock is never set and, therefore, that
time intervals measured with this clock will not be affected by calls to clock_settime().
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
Scheduling Policies, clock_getcpuclockid(), clock_nanosleep(), ctime(),
mq_receive(), mq_send(),
nanosleep(), pthread_mutex_clocklock(), sem_clockwait(), thrd_sleep(),
time(), timer_create()
, timer_getoverrun()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Timers
option.
The APPLICATION USAGE section is added.
The following changes were made to align with the IEEE P1003.1a draft standard:
Clarification is added of the effect of resetting the clock resolution.
CPU-time clocks and the clock_getcpuclockid() function are added for
alignment with IEEE Std 1003.1d-1999.
The following changes are added for alignment with IEEE Std 1003.1j-2000:
The DESCRIPTION is updated as follows:
The value returned by clock_gettime() for CLOCK_MONOTONIC is specified.
The clock_settime() function failing for CLOCK_MONOTONIC is specified.
The effects of clock_settime() on the clock_nanosleep() function
with respect to CLOCK_REALTIME are specified.
An [EINVAL] error is added to the ERRORS section, indicating that clock_settime() fails for CLOCK_MONOTONIC.
The APPLICATION USAGE section notes that the CLOCK_MONOTONIC clock need not and shall not be set by clock_settime() since
the absolute value of the CLOCK_MONOTONIC clock is meaningless.
The clock_nanosleep(), mq_timedreceive(), mq_timedsend(), pthread_mutex_timedlock(), sem_timedwait(), timer_create(),
and timer_settime() functions are added to the SEE ALSO section.
Issue 7
Functionality relating to the Clock Selection option is moved to the Base.
The clock_getres(), clock_gettime(), and clock_settime() functions are moved from the Timers option to the
Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0058 [106] is applied.
Issue 8
Austin Group Defect 1302 is applied, changing "the nanosleep() function" to
"the nanosleep() and thrd_sleep() functions".
Austin Group Defect 1346 is applied, requiring support for Monotonic Clock.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mkostemp.html =====
mkdtemp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mkdtemp, mkostemp, mkstemp — create a unique directory or file
SYNOPSIS
[CX]  #include
char *mkdtemp(char *template);
int mkostemp(char *template, int flag);
int mkstemp(char *template);
DESCRIPTION
The mkdtemp() function shall create a directory with a unique name derived from template. The application shall
ensure that the string provided in template is a pathname ending with at least six trailing 'X' characters. The
mkdtemp() function shall modify the contents of template by replacing six or more 'X' characters at the end
of the pathname with the same number of characters from the portable filename character set. The characters shall be chosen such
that the resulting pathname does not duplicate the name of an existing file at the time of the call to mkdtemp(). The
mkdtemp() function shall use the resulting pathname to create the new directory as if by a call to:
mkdir(pathname, S_IRWXU)
The mkstemp() function shall create a regular file with a unique name derived from template and return a file
descriptor for the file open for reading and writing. The application shall ensure that the string provided in template is a
pathname ending with at least six trailing 'X' characters. The mkstemp() function shall modify the contents of
template by replacing six or more 'X' characters at the end of the pathname with the same number of characters from
the portable filename character set. The characters shall be chosen such that the resulting pathname does not duplicate the name of
an existing file at the time of the call to mkstemp(). The mkstemp() function shall use the resulting pathname to
create the file, and obtain a file descriptor for it, as if by a call to:
open(pathname, O_RDWR|O_CREAT|O_EXCL, S_IRUSR|S_IWUSR)
By behaving as if the O_EXCL flag for open() is set, the function prevents any
possible race condition between testing whether the file exists and opening it for use.
The mkostemp() function shall be equivalent to the mkstemp() function, except that the flag argument can
contain additional flags to be used as if by open(). Behavior is unspecified if the
flag argument contains more than the following flags:
O_APPEND
Set append mode.
O_CLOEXEC
Set the FD_CLOEXEC file descriptor flag.
O_CLOFORK
Set the FD_CLOFORK file descriptor flag.
O_DSYNC
[SIO]
Write according to the synchronized I/O data integrity completion.
O_RSYNC
[SIO]
Synchronized read I/O operations.
O_SYNC
[XSI|SIO]  Write according to synchronized I/O file integrity completion.
RETURN VALUE
Upon successful completion, the mkdtemp() function shall return the value of template. Otherwise, it shall return
a null pointer and shall set errno to indicate the error.
Upon successful completion, the mkstemp() function shall return an open file descriptor. Otherwise, it shall return -1
and shall set errno to indicate the error.
ERRORS
These functions shall fail if:
[EINVAL]
The string pointed to by template does not end in "XXXXXX".
The mkostemp() function may fail if:
[EINVAL]
The value of the flag argument is invalid.
Additional error conditions for the mkdtemp() function are defined in mkdir(). Additional error conditions for the mkstemp() and
mkostemp() functions are defined in open().
The following sections are informative.
EXAMPLES
Generating a Pathname
The following example creates a file with a 10-character name beginning with the characters "file" and opens the file
for reading and writing. The value returned as the value of fd is a file descriptor that identifies the file.
#include
...
char template[] = "/tmp/fileXXXXXX";
int fd;
fd = mkstemp(template);
APPLICATION USAGE
It is possible to run out of letters.
Portable applications should pass exactly six trailing 'X's in the template and no more; implementations may treat any
additional trailing 'X's as either a fixed or replaceable part of the template. To be sure of only passing six, a fixed
string of at least one non-'X' character should precede the six 'X's.
Since 'X' is in the portable filename character set, some of the replacement characters can be 'X's, leaving
part (or even all) of the template effectively unchanged.
RATIONALE
The O_CLOEXEC and O_CLOFORK flags of mkostemp() are necessary to avoid a data race in multi-threaded applications.
Without O_CLOFORK, a file descriptor is leaked into a child process created by one thread in the window between another thread
creating a temporary file descriptor with mkstemp() and then using fcntl() to
set the FD_CLOFORK flag. Without O_CLOEXEC, a temporary file descriptor intentionally inherited by child processes is similarly
leaked into an executed program if FD_CLOEXEC is not set atomically.
Implementations are encouraged to have mkdtemp(), mkostemp(), and mkstemp() report an [EILSEQ] error if the
last component of the pathname in template contains any bytes that have the encoded value of a
character.
FUTURE DIRECTIONS
None.
SEE ALSO
getpid(), mkdir(),
open(), tmpfile(), tmpnam()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 7
Austin Group Interpretation 1003.1-2001 #143 is applied.
SD5-XSH-ERN-168 is applied, clarifying file permissions upon creation.
The mkstemp() function is moved from the XSI option to the Base.
The mkdtemp() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 1.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0380 [291], XSH/TC1-2008/0381 [324], and XSH/TC1-2008/0382 [291] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0215 [567,669] is applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defects 411, 1318, and 1350 are applied, adding mkostemp().
Austin Group Defect 652 is applied, adding the [EINVAL] error for mkstemp().
Austin Group Defect 1734 is applied, replacing the error conditions specified only for mkdtemp() with a reference to
mkdir().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/cexp.html =====
cexp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cexp, cexpf, cexpl — complex exponential functions
SYNOPSIS
#include
double complex cexp(double complex z);
float complex cexpf(float complex z);
long double complex cexpl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex exponent of z, defined as ez.
RETURN VALUE
These functions shall return the complex exponential value of z.
[MXC]
cexp(conj(z)), cexpf(conjf(z)), and cexpl(conjl(z)) shall return
exactly the same value as conj(cexp(z)), conjf(cexpf(z)), and
conjl(cexpl(z)), respectively, including for the special values of z below.
If z is ±0 + i0, 1 + i0 shall be returned.
If z is x + iInf where x is finite, NaN + iNaN shall be returned and the invalid
floating-point exception shall be raised.
If z is x + iNaN where x is finite, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is +Inf + i0, +Inf + i0 shall be returned.
If z is -Inf + iy where y is finite, +0 (cos(y) + isin(y)) shall be
returned.
If z is +Inf + iy where y is non-zero and finite, +Inf (cos(y) + isin(y)) shall
be returned.
If z is -Inf + iInf, ±0 ± i0 shall be returned; the signs of the real and imaginary parts of the result are
unspecified.
If z is +Inf + iInf, ±Inf + iNaN shall be returned and the invalid floating-point exception shall be
raised; the sign of the real part of the result is unspecified.
If z is -Inf + iNaN, ±0 ± i0 shall be returned; the signs of the real and imaginary parts of the result are
unspecified.
If z is +Inf + iNaN, ±Inf + iNaN shall be returned; the sign of the real part of the result is
unspecified.
If z is NaN + i0, NaN + i0 shall be returned.
If z is NaN + iy where y is any non-zero number, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is NaN + iNaN, NaN + iNaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
clog()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fprintf.html =====
fprintf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
asprintf, dprintf, fprintf, printf, snprintf, sprintf — print formatted output
SYNOPSIS
#include
[CX]  int asprintf(char **restrict ptr, const char *restrict format,
...);
int dprintf(int fildes, const char *restrict format, ...);
int fprintf(FILE *restrict stream, const char *restrict format, ...);
int printf(const char *restrict format, ...);
int snprintf(char *restrict s, size_t n,
const char *restrict format, ...);
int sprintf(char *restrict s, const char *restrict format, ...);
DESCRIPTION
[CX]  Except for asprintf(), dprintf(), and the behavior of the %lc conversion when passed a null wide
character, the functionality described on this reference page is aligned with the ISO C standard. Any other conflict between
the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard for all fprintf(), printf(), snprintf(), and sprintf() functionality except in relation to the
%lc conversion when passed a null wide character.
The fprintf() function shall place output on the named output stream. The printf() function shall place
output on the standard output stream stdout. The sprintf() function shall place output followed by the null byte,
'\0', in consecutive bytes starting at *s; it is the user's responsibility to ensure that enough space is
available.
[CX]  The
asprintf() function shall be equivalent to sprintf(), except that the output string shall be written to dynamically
allocated memory, allocated as if by a call to malloc(), of sufficient length to hold
the resulting string, including a terminating null byte. If the call to asprintf() is successful, the address of this
dynamically allocated string shall be stored in the location referenced by ptr.
The dprintf() function shall be equivalent to the fprintf() function, except that dprintf() shall write
output to the file associated with the file descriptor specified by the fildes argument rather than place output on a
stream.
The snprintf() function shall be equivalent to sprintf(), with the addition of the n argument which limits
the number of bytes written to the buffer referred to by s. If n is zero, nothing shall be written and s may
be a null pointer. Otherwise, output bytes beyond the n-1st shall be discarded instead of being written to the array, and a
null byte is written at the end of the bytes actually written into the array.
If copying takes place between objects that overlap as a result of a call to sprintf() or snprintf(), the results
are undefined.
Each of these functions converts, formats, and prints its arguments under control of the format. The application shall
ensure that the format is a character string, beginning and ending in its initial shift state, if any. The format is composed of
zero or more directives: ordinary characters, which are simply copied to the output stream, and conversion
specifications, each of which shall result in the fetching of zero or more arguments. The results are undefined if there are
insufficient arguments for the format. If the format is exhausted while arguments remain, the excess arguments shall be evaluated
but are otherwise ignored.
[CX]
Conversions can be applied to the nth argument after the format in the argument list, rather than to the next unused
argument. In this case, the conversion specifier character % (see below) is replaced by the sequence
"%n$", where n is a decimal integer in the range [1,{NL_ARGMAX}], giving the position of the
argument in the argument list. This feature provides for the definition of format strings that select arguments in an order
appropriate to specific languages (see the EXAMPLES section).
The format can contain either numbered argument conversion specifications (that is, those introduced by
"%n$" and optionally containing the "*m$" forms of field width and precision), or
unnumbered argument conversion specifications (that is, those introduced by the % character and optionally containing the
* form of field width and precision), but not both. The only exception to this is that %% can be mixed with the
"%n$" form. The results of mixing numbered and unnumbered argument specifications in a format string are
undefined. When numbered argument specifications are used, specifying the Nth argument requires that all the leading
arguments, from the first to the (N-1)th, are specified in the format string.
In format strings containing the "%n$" form of conversion specification, numbered arguments in the
argument list can be referenced from the format string as many times as required.
In format strings containing the % form of conversion specification, each conversion specification uses the first
unused argument in the argument list.
[CX]  All
forms of the fprintf() functions allow for the insertion of a language-dependent radix character in the output string. The
radix character is defined in the current locale (category LC_NUMERIC ). In the POSIX locale, or in a locale where the radix
character is not defined, the radix character shall default to a  ('.').
Each conversion specification is introduced by the '%' character [CX]   or by the
character sequence "%n$",   after
which the following appear in sequence:
Zero or more flags (in any order), which modify the meaning of the conversion specification.
An optional minimum field width. If the converted value has fewer bytes than the field width, it shall be padded with
characters by default on the left; it shall be padded on the right if the left-adjustment flag ('-'),
described below, is given to the field width. The field width takes the form of an  ('*'), [CX]   or in
conversion specifications introduced by "%n$" the "*m$" string,  described below, or a decimal integer.
An optional precision that gives the minimum number of digits to appear for the d, i, o,
u, x, and X conversion specifiers; the number of digits to appear after the radix character for the
a, A, e, E, f, and F conversion specifiers; the maximum number of significant
digits for the g and G conversion specifiers; or the maximum number of bytes to be printed from a string in the
s [XSI]   and S   conversion specifiers. The
precision takes the form of a  ('.') followed either by an  ('*'), [CX]   or in
conversion specifications introduced by "%n$" the "*m$" string,  described below, or an optional decimal digit string, where a null digit
string is treated as zero. If a precision appears with any other conversion specifier, the behavior is undefined.
An optional length modifier that specifies the size of the argument.
A conversion specifier character that indicates the type of conversion to be applied.
A field width, or precision, or both, may be indicated by an  ('*'). In this case an argument of type
int supplies the field width or precision. Applications shall ensure that arguments specifying field width, or precision, or
both appear in that order before the argument, if any, to be converted. A negative field width is taken as a '-' flag
followed by a positive field width. A negative precision is taken as if the precision were omitted. [CX]   In format
strings containing conversion specifications introduced by "%n$", in addition to being indicated by the
decimal digit string, a field width may be indicated by the sequence "*m$" and precision by the sequence
".*m$", where m is a decimal integer in the range [1,{NL_ARGMAX}] giving the position in the
argument list (after the format argument) of an integer argument containing the field width or precision, for example:
printf("%1$d:%2$.*3$d:%4$.*3$d\n", hour, min, precision, sec);
The flag characters and their meanings are:
'
[CX]
(The .) The integer portion of the result of a decimal conversion (%i, %d, %u,
%f, %F, %g, or %G) shall be formatted with thousands' grouping characters. For other
conversions the behavior is undefined. The non-monetary grouping character is used.
-
The result of the conversion shall be left-justified within the field. The conversion is right-justified if this flag is not
specified.
+
The result of a signed conversion shall always begin with a sign ('+' or '-'). The conversion shall begin
with a sign only when a negative value is converted if this flag is not specified.
If the first character of a signed conversion is not a sign or if a signed conversion results in no characters, a
shall be prefixed to the result. This means that if the  and '+' flags both appear, the  flag
shall be ignored.
#
Specifies that the value is to be converted to an alternative form. For o conversion, it shall increase the precision,
if and only if necessary, to force the first digit of the result to be a zero (if the value and precision are both 0, a single 0 is
printed). For x or X conversion specifiers, a non-zero result shall have 0x (or 0X) prefixed to it. For
a, A, e, E, f, F, g, and G conversion specifiers, the
result shall always contain a radix character, even if no digits follow the radix character. Without this flag, a radix character
appears in the result of these conversions only if a digit follows it. For g and G conversion specifiers,
trailing zeros shall not be removed from the result as they normally are. For other conversion specifiers, the behavior is
undefined.
0
For d, i, o, u, x, X, a, A, e, E,
f, F, g, and G conversion specifiers, leading zeros (following any indication of sign or base)
are used to pad to the field width rather than performing space padding, except when converting an infinity or NaN. If the
'0' and '-' flags both appear, the '0' flag is ignored. For d, i, o,
u, x, and X conversion specifiers, if a precision is specified, the '0' flag shall be ignored.
[CX]
If the '0' and  flags both appear, the grouping characters are inserted before zero padding. For
other conversions, the behavior is undefined.
The length modifiers and their meanings are:
hh
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a signed char or unsigned char argument (the argument will have been promoted according to the integer
promotions, but its value shall be converted to signed char or unsigned char before printing); or that a following
n conversion specifier applies to a pointer to a signed char argument.
h
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a short or unsigned short argument (the argument will have been promoted according to the integer
promotions, but its value shall be converted to short or unsigned short before printing); or that a following
n conversion specifier applies to a pointer to a short argument.
l (ell)
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a long or unsigned long argument; that a following n conversion specifier applies to a pointer to
a long argument; that a following c conversion specifier applies to a wint_t argument; that a following
s conversion specifier applies to a pointer to a wchar_t argument; or has no effect on a following a,
A, e, E, f, F, g, or G conversion specifier.
ll (ell-ell)
Specifies that a following d, i, o, u, x, or X conversion specifier applies
to a long long or unsigned long long argument; or that a following n conversion specifier applies to a
pointer to a long long argument.
j
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to an intmax_t or uintmax_t argument; or that a following n conversion specifier applies to a
pointer to an intmax_t argument.
z
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a size_t or the corresponding signed integer type argument; or that a following n conversion specifier
applies to a pointer to a signed integer type corresponding to a size_t argument.
t
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a ptrdiff_t or the corresponding unsigned type argument; or that a following n conversion
specifier applies to a pointer to a ptrdiff_t argument.
L
Specifies that a following a, A, e, E, f, F, g, or G
conversion specifier applies to a long double argument.
If a length modifier appears with any conversion specifier other than as specified above, the behavior is undefined.
The conversion specifiers and their meanings are:
d, i
The int argument shall be converted to a signed decimal in the style "[-]dddd". The precision
specifies the minimum number of digits to appear; if the value being converted can be represented in fewer digits, it shall be
expanded with leading zeros. The default precision is 1. The result of converting zero with an explicit precision of zero shall be
no characters.
o
The unsigned argument shall be converted to unsigned octal format in the style "dddd". The
precision specifies the minimum number of digits to appear; if the value being converted can be represented in fewer digits, it
shall be expanded with leading zeros. The default precision is 1. The result of converting zero with an explicit precision of zero
shall be no characters.
u
The unsigned argument shall be converted to unsigned decimal format in the style "dddd". The
precision specifies the minimum number of digits to appear; if the value being converted can be represented in fewer digits, it
shall be expanded with leading zeros. The default precision is 1. The result of converting zero with an explicit precision of zero
shall be no characters.
x
The unsigned argument shall be converted to unsigned hexadecimal format in the style "dddd";
the letters "abcdef" are used. The precision specifies the minimum number of digits to appear; if the value being
converted can be represented in fewer digits, it shall be expanded with leading zeros. The default precision is 1. The result of
converting zero with an explicit precision of zero shall be no characters.
X
Equivalent to the x conversion specifier, except that letters "ABCDEF" are used instead of
"abcdef".
f, F
The double argument shall be converted to decimal notation in the style
"[-]ddd.ddd", where the number of digits after the radix character is equal to the
precision specification. If the precision is missing, it shall be taken as 6; if the precision is explicitly zero and no
'#' flag is present, no radix character shall appear. If a radix character appears, at least one digit appears before it.
The low-order digit shall be rounded in an implementation-defined manner.
A double argument representing an infinity shall be converted in one of the styles "[-]inf" or
"[-]infinity"; which style is implementation-defined. A double argument representing a NaN shall be converted in
one of the styles "[-]nan(n-char-sequence)" or "[-]nan"; which style, and the meaning of any
n-char-sequence, is implementation-defined. The F conversion specifier produces "INF",
"INFINITY", or "NAN" instead of "inf", "infinity", or "nan", respectively.
e, E
The double argument shall be converted in the style
"[-]d.ddde±dd", where there is one digit before the radix character (which
is non-zero if the argument is non-zero) and the number of digits after it is equal to the precision; if the precision is missing,
it shall be taken as 6; if the precision is zero and no '#' flag is present, no radix character shall appear. The
low-order digit shall be rounded in an implementation-defined manner. The E conversion specifier shall produce a number
with 'E' instead of 'e' introducing the exponent. The exponent shall always contain at least two digits. If the
value is zero, the exponent shall be zero.
A double argument representing an infinity or NaN shall be converted in the style of an f or F
conversion specifier.
g, G
The double argument representing a floating-point number shall be converted in the style f or e (or in
the style F or E in the case of a G conversion specifier), depending on the value converted and the
precision. Let P equal the precision if non-zero, 6 if the precision is omitted, or 1 if the precision is zero. Then, if a
conversion with style E would have an exponent of X:
If P>X>=-4, the conversion shall be with style f (or F) and precision
P-(X+1).
Otherwise, the conversion shall be with style e (or E) and precision P-1.
Finally, unless the '#' flag is used, any trailing zeros shall be removed from the fractional portion of the result and
the decimal-point character shall be removed if there is no fractional portion remaining.
A double argument representing an infinity or NaN shall be converted in the style of an f or F
conversion specifier.
a, A
A double argument representing a floating-point number shall be converted in the style
"[-]0xh.hhhhp±d", where there is one hexadecimal digit (which shall be
non-zero if the argument is a normalized floating-point number and is otherwise unspecified) before the decimal-point character and
the number of hexadecimal digits after it is equal to the precision; if the precision is missing and FLT_RADIX is a power of 2,
then the precision shall be sufficient for an exact representation of the value; if the precision is missing and FLT_RADIX is not a
power of 2, then the precision shall be sufficient to distinguish values of type double, except that trailing zeros may be
omitted; if the precision is zero and the '#' flag is not specified, no decimal-point character shall appear. The letters
"abcdef" shall be used for a conversion and the letters "ABCDEF" for A conversion. The
A conversion specifier produces a number with 'X' and 'P' instead of 'x' and 'p'. The
exponent shall always contain at least one digit, and only as many more digits as necessary to represent the decimal exponent of 2.
If the value is zero, the exponent shall be zero.
A double argument representing an infinity or NaN shall be converted in the style of an f or F
conversion specifier.
c
The int argument shall be converted to an unsigned char, and the resulting byte shall be written.
If an l (ell) qualifier is present, [CX]   the wint_t argument shall be converted to a multi-byte
sequence as if by a call to wcrtomb() with a pointer to storage of at least
MB_CUR_MAX bytes, the wint_t argument converted to wchar_t, and an initial shift state, and the resulting byte(s)
written.
s
The argument shall be a pointer to an array of char. Bytes from the array shall be written up to (but not including) any
terminating null byte. If the precision is specified, no more than that many bytes shall be written. If the precision is not
specified or is greater than the size of the array, the application shall ensure that the array contains a null byte.
If an l (ell) qualifier is present, the argument shall be a pointer to an array of type wchar_t. Wide characters
from the array shall be converted to characters (each as if by a call to the wcrtomb() function, with the conversion state described by an mbstate_t object
initialized to zero before the first wide character is converted) up to and including a terminating null wide character. The
resulting characters shall be written up to (but not including) the terminating null character (byte). If no precision is
specified, the application shall ensure that the array contains a null wide character. If a precision is specified, no more than
that many characters (bytes) shall be written (including shift sequences, if any), and the array shall contain a null wide
character if, to equal the character sequence length given by the precision, the function would need to access a wide character one
past the end of the array. In no case shall a partial character be written.
p
The argument shall be a pointer to void. The value of the pointer is converted to a sequence of printable characters, in
an implementation-defined manner.
n
The argument shall be a pointer to an integer into which is written the number of bytes written to the output so far by this
call to one of the fprintf() functions. No argument is converted.
C
[XSI]
Equivalent to lc.
S
[XSI]
Equivalent to ls.
%
Write a '%' character; no argument shall be converted. The application shall ensure that the complete conversion
specification is %%.
If a conversion specification does not match one of the above forms, the behavior is undefined. If any argument is not the
correct type for the corresponding conversion specification, the behavior is undefined.
In no case shall a nonexistent or small field width cause truncation of a field; if the result of a conversion is wider than the
field width, the field shall be expanded to contain the conversion result. Characters generated by fprintf() and
printf() are printed as if fputc() had been called.
For the a and A conversion specifiers, if FLT_RADIX is a power of 2, the value shall be correctly rounded to a
hexadecimal floating number with the given precision.
For a and A conversions, if FLT_RADIX is not a power of 2 and the result is not exactly representable in the
given precision, the result should be one of the two adjacent numbers in hexadecimal floating style with the given precision, with
the extra stipulation that the error should have a correct sign for the current rounding direction.
For the e, E, f, F, g, and G conversion specifiers, if the number of
significant decimal digits is at most DECIMAL_DIG, then the result should be correctly rounded. If the number of significant
decimal digits is more than DECIMAL_DIG but the source value is exactly representable with DECIMAL_DIG digits, then the result
should be an exact representation with trailing zeros. Otherwise, the source value is bounded by two adjacent decimal strings
L
#include
#include
#include
char *strperm (mode_t);
...
struct stat statbuf;
struct passwd *pwd;
struct group *grp;
...
printf("%10.10s", strperm (statbuf.st_mode));
printf("%4d", statbuf.st_nlink);
if ((pwd = getpwuid(statbuf.st_uid)) != NULL)
printf(" %-8.8s", pwd->pw_name);
else
printf(" %-8ld", (long) statbuf.st_uid);
if ((grp = getgrgid(statbuf.st_gid)) != NULL)
printf(" %-8.8s", grp->gr_name);
else
printf(" %-8ld", (long) statbuf.st_gid);
printf("%9jd", (intmax_t) statbuf.st_size);
...
Printing a Localized Date String
The following example gets a localized date string. The nl_langinfo()
function shall return the localized date string, which specifies the order and layout of the date. The strftime() function takes this information and, using the tm structure for values,
places the date and time information into datestring. The printf() function then outputs datestring and the
name of the entry.
#include
#include
#include
...
struct dirent *dp;
struct tm *tm;
char datestring[256];
...
strftime(datestring, sizeof(datestring), nl_langinfo (D_T_FMT), tm);
printf(" %s %s\n", datestring, dp->d_name);
...
Printing Error Information
The following example uses fprintf() to write error information to standard error.
In the first group of calls, the program tries to open the password lock file named LOCKFILE. If the file already exists,
this is an error, as indicated by the O_EXCL flag on the open() function. If the call
fails, the program assumes that someone else is updating the password file, and the program exits.
The next group of calls saves a new password file as the current password file by creating a link between LOCKFILE and
the new password file PASSWDFILE.
#include
#include
#include
#include
#include
#include
#include
#include
#define LOCKFILE "/etc/ptmp"
#define PASSWDFILE "/etc/passwd"
...
int pfd;
...
if ((pfd = open(LOCKFILE, O_WRONLY | O_CREAT | O_EXCL,
S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) == -1)
{
fprintf(stderr, "Cannot open /etc/ptmp. Try again later.\n");
exit(1);
}
...
if (link(LOCKFILE,PASSWDFILE) == -1) {
fprintf(stderr, "Link error: %s\n", strerror(errno));
exit(1);
}
...
Printing Usage Information
The following example checks to make sure the program has the necessary arguments, and uses fprintf() to print usage
information if the expected number of arguments is not present.
#include
#include
...
char *Options = "hdbtl";
...
if (argc  ('*') in the format
string; this ensures the correct number of decimal places for the element based on the number of elements requested.
#include
...
long i;
char *keystr;
int elementlen, len;
...
while (len
#include
#include
#include
#include
#include
...
char *pathname;
struct passwd *pw;
size_t len;
...
// digits required for pid_t is number of bits times
// log2(10) = approx 10/33
len = strlen(pw->pw_dir) + 1 + 1+(sizeof(pid_t)*80+32)/33 +
sizeof ".out";
pathname = malloc(len);
if (pathname != NULL)
{
snprintf(pathname, len, "%s/%jd.out", pw->pw_dir,
(intmax_t)getpid());
...
}
Reporting an Event
The following example loops until an event has timed out. The pause() function
waits forever unless it receives a signal. The fprintf() statement should never occur due to the possible return values of
pause().
#include
#include
#include
#include
...
while (!event_complete) {
...
if (pause() != -1 || errno != EINTR)
fprintf(stderr, "pause: unknown error: %s\n", strerror(errno));
}
...
Printing Monetary Information
The following example uses strfmon() to convert a number and store it as a
formatted monetary string named convbuf. If the first number is printed, the program prints the format and the description;
otherwise, it just prints the number.
#include
#include
...
struct tblfmt {
char *format;
char *description;
};
struct tblfmt table[] = {
{ "%n", "default formatting" },
{ "%11n", "right align within an 11 character field" },
{ "%#5n", "aligned columns for values up to 99999" },
{ "%=*#5n", "specify a fill character" },
{ "%=0#5n", "fill characters do not use grouping" },
{ "%^#5n", "disable the grouping separator" },
{ "%^#5.0n", "round off to whole units" },
{ "%^#5.4n", "increase the precision" },
{ "%(#5n", "use an alternative pos/neg style" },
{ "%!(#5n", "disable the currency symbol" },
};
...
float input[3];
int i, j;
char convbuf[100];
...
strfmon(convbuf, sizeof(convbuf), table[i].format, input[j]);
if (j == 0) {
printf("%s  %s      %s\n", table[i].format,
convbuf, table[i].description);
}
else {
printf("    %s\n", convbuf);
}
...
Printing Wide Characters
The following example prints a series of wide characters. Suppose that "L`@`" expands to three bytes:
wchar_t wz [3] = L"@@";       // Zero-terminated
wchar_t wn [3] = L"@@@";      // Unterminated
fprintf (stdout,"%ls", wz);   // Outputs 6 bytes
fprintf (stdout,"%ls", wn);   // Undefined because wn has no terminator
fprintf (stdout,"%4ls", wz);  // Outputs 3 bytes
fprintf (stdout,"%4ls", wn);  // Outputs 3 bytes; no terminator needed
fprintf (stdout,"%9ls", wz);  // Outputs 6 bytes
fprintf (stdout,"%9ls", wn);  // Outputs 9 bytes; no terminator needed
fprintf (stdout,"%10ls", wz); // Outputs 6 bytes
fprintf (stdout,"%10ls", wn); // Undefined because wn has no terminator
In the last line of the example, after processing three characters, nine bytes have been output. The fourth character must then
be examined to determine whether it converts to one byte or more. If it converts to more than one byte, the output is only nine
bytes. Since there is no fourth character in the array, the behavior is undefined.
APPLICATION USAGE
If the application calling fprintf() has any objects of type wint_t or wchar_t, it must also include the
header to have these objects defined.
The space allocated by a successful call to asprintf() should be subsequently freed by a call to free().
RATIONALE
If an implementation detects that there are insufficient arguments for the format, it is recommended that the function should
fail and report an [EINVAL] error.
The behavior specified for the %lc conversion differs slightly from the specification in the ISO C standard, in
that printing the null wide character produces a null byte instead of 0 bytes of output as would be required by a strict reading of
the ISO C standard's direction to behave as if applying the %ls specifier to a wchar_t array whose first
element is the null wide character. Requiring a multi-byte output for every possible wide character, including the null character,
matches historical practice, and provides consistency with %c in fprintf() and with both %c and
%lc in fwprintf(). It is anticipated that a future edition of the
ISO C standard will change to match the behavior specified here.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fputc(), fscanf(), setlocale(), strfmon(), strlcat(), wcrtomb(), wcslcat()
XBD 7. Locale, , ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
Aligned with ISO/IEC 9899:1990/Amendment 1:1995 (E). Specifically, the l (ell) qualifier can now be used with
c and s conversion specifiers.
The snprintf() function is new in Issue 5.
Issue 6
Extensions beyond the ISO C standard are marked.
The normative text is updated to avoid use of the term "must" for application requirements.
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The prototypes for fprintf(), printf(), snprintf(), and sprintf() are updated, and the XSI shading
is removed from snprintf().
The description of snprintf() is aligned with the ISO C standard. Note that this supersedes the snprintf()
description in The Open Group Base Resolution bwg98-006, which changed the behavior from Issue 5.
The DESCRIPTION is updated.
The DESCRIPTION is updated to use the terms "conversion specifier" and "conversion specification" consistently.
ISO/IEC 9899:1999 standard, Technical Corrigendum 1 is incorporated.
An example of printing wide characters is added.
Issue 7
Austin Group Interpretation 1003.1-2001 #161 is applied, updating the DESCRIPTION of the 0 flag.
Austin Group Interpretation 1003.1-2001 #170 is applied.
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #68 (SD5-XSH-ERN-70) is applied, revising the description of g
and G.
SD5-XSH-ERN-174 is applied.
The dprintf() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 1.
Functionality relating to the %n$ form of conversion specification and the  flag is moved from the
XSI option to the Base.
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0163 [302], XSH/TC1-2008/0164 [316], XSH/TC1-2008/0165 [316],
XSH/TC1-2008/0166 [451,291], and XSH/TC1-2008/0167 [14] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0126 [894], XSH/TC2-2008/0127 [557], and XSH/TC2-2008/0128 [936] are
applied.
Issue 8
Austin Group Defect 986 is applied, adding strlcat() and wcslcat() to the SEE ALSO section.
Austin Group Defect 1020 is applied, clarifying that the snprintf() argument n limits the number of bytes written
to s; it is not necessarily the same as the size of s.
Austin Group Defect 1021 is applied, changing "output error" to "error" in the RETURN VALUE section.
Austin Group Defect 1137 is applied, clarifying the use of "%n$" and "*m$" in
conversion specifications.
Austin Group Defect 1205 is applied, changing the description of the % conversion specifier.
Austin Group Defect 1219 is applied, removing the snprintf()-specific [EOVERFLOW] error.
Austin Group Defect 1496 is applied, adding the asprintf() function.
Austin Group Defect 1562 is applied, clarifying that it is the application's responsibility to ensure that the format is a
character string, beginning and ending in its initial shift state, if any.
Austin Group Defect 1647 is applied, changing the description of the c conversion specifier and updating the statement
that this volume of POSIX.1-2024 defers to the ISO C standard so that it excludes the %lc conversion when passed a
null wide character.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/cpow.html =====
cpow
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cpow, cpowf, cpowl — complex power functions
SYNOPSIS
#include
double complex cpow(double complex x, double complex y);
float complex cpowf(float complex x, float complex y);
long double complex cpowl(long double complex x,
long double complex y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex power function xy, with a branch cut for the first
parameter along the negative real axis.
[MXC]
These functions shall raise floating-point exceptions if appropriate for the calculation of the parts of the result, and may also
raise spurious floating-point exceptions.
RETURN VALUE
These functions shall return the complex power function value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
Permitting spurious floating-point exceptions allows cpow(z, c) to be implemented as
cexp(cclog(z)) without precluding implementations that treat special cases more carefully.
FUTURE DIRECTIONS
None.
SEE ALSO
cabs(), csqrt()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/lrint.html =====
lrint
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
lrint, lrintf, lrintl — round to nearest integer value using current rounding direction
SYNOPSIS
#include
long lrint(double x);
long lrintf(float x);
long lrintl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall round their argument to the nearest integer value, rounding according to the current rounding
direction.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the rounded integer value.
[MX]  If
x is NaN, a domain error shall occur and an unspecified value is returned.
If x is +Inf, a domain error shall occur and an unspecified value is returned.
If x is -Inf, a domain error shall occur and an unspecified value is returned.
If the correct value is positive and too large to represent as a long, an unspecified value shall be returned.
[MX]
On systems that support the IEC 60559 Floating-Point option, a domain error shall occur;   otherwise, a [CX]   domain  error may occur.
If the correct value is negative and too large to represent as a long, an unspecified value shall be returned.
[MX]
On systems that support the IEC 60559 Floating-Point option, a domain error shall occur;   otherwise, a [CX]   domain  error may occur.
ERRORS
These functions shall fail if:
Domain Error
[MX]
The x argument is NaN or ±Inf, or the correct value is not representable as an integer.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
These functions may fail if:
Domain Error
The correct value is not representable as an integer.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
These functions provide floating-to-integer conversions. They round according to the current rounding direction. If the rounded
value is outside the range of the return type, the numeric result is unspecified and the invalid floating-point exception is
raised. When they raise no other floating-point exception and the result differs from the argument, they raise the inexact
floating-point exception.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), llrint()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #53 (SD5-XSH-ERN-77) is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mbrtoc16.html =====
mbrtoc16
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mbrtoc16, mbrtoc32 — convert a character to a Unicode character code (restartable)
SYNOPSIS
#include
size_t mbrtoc16(char16_t *restrict pc16, const char *restrict s,
size_t n, mbstate_t *restrict ps);
size_t mbrtoc32(char32_t *restrict pc32, const char *restrict s,
size_t n, mbstate_t *restrict ps);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
If s is a null pointer, the mbrtoc16() function shall be equivalent to the call:
mbrtoc16(NULL, "", 1, ps)
In this case, the values of the parameters pc16 and n are ignored.
If s is not a null pointer, the mbrtoc16() function shall inspect at most n bytes beginning with the byte
pointed to by s to determine the number of bytes needed to complete the next character (including any shift sequences). If
the function determines that the next character is complete and valid, it shall determine the values of the corresponding wide
characters and then, if pc16 is not a null pointer, shall store the value of the first (or only) such character in the
object pointed to by pc16. Subsequent calls shall store successive wide characters without consuming any additional input
until all the characters have been stored. If the corresponding wide character is the null wide character, the resulting state
described shall be the initial conversion state.
If ps is a null pointer, the mbrtoc16() function shall use its own internal mbstate_t object, which shall
be initialized at program start-up to the initial conversion state. Otherwise, the mbstate_t object pointed to by ps
shall be used to completely describe the current conversion state of the associated character sequence.
The behavior of this function is affected by the LC_CTYPE category of the current locale.
The mbrtoc16() function shall not change the setting of errno if successful.
The mbrtoc32() function shall behave the same way as mbrtoc16() except that the first parameter shall point to an
object of type char32_t instead of char16_t. References to pc16 in the above description shall apply as if
they were pc32 when they are being read as describing mbrtoc32().
If called with a null ps argument, the mbrtoc16() function need not be thread-safe; however, such calls shall
avoid data races with calls to mbrtoc16() with a non-null argument and with calls to all other functions.
If called with a null ps argument, the mbrtoc32() function need not be thread-safe; however, such calls shall
avoid data races with calls to mbrtoc32() with a non-null argument and with calls to all other functions.
The implementation shall behave as if no function defined in this volume of POSIX.1-2024 calls mbrtoc16() or
mbrtoc32() with a null pointer for ps.
RETURN VALUE
These functions shall return the first of the following that applies:
0
If the next n or fewer bytes complete the character that corresponds to the null wide character (which is the value
stored).
between 1 and n inclusive
If the next n or fewer bytes complete a valid character (which is the value stored); the value returned shall be the number
of bytes that complete the character.
(size_t)-3
If the next character resulting from a previous call has been stored, in which case no bytes from the input shall be consumed
by the call.
(size_t)-2
If the next n bytes contribute to an incomplete but potentially valid character, and all n bytes have been
processed (no value is stored). When n has at least the value of the {MB_CUR_MAX} macro, this case can only occur if
s points at a sequence of redundant shift sequences (for implementations with state-dependent encodings).
(size_t)-1
If an encoding error occurs, in which case the next n or fewer bytes do not contribute to a complete and valid character
(no value is stored). In this case, [EILSEQ] shall be stored in errno and the conversion state is undefined.
ERRORS
These functions shall fail if:
[EILSEQ]
An invalid character sequence is detected. [CX]   In the POSIX locale an [EILSEQ] error cannot occur since all byte
values are valid characters.
These functions may fail if:
[EINVAL]
[CX]
ps points to an object that contains an invalid conversion state.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
c16rtomb()
XBD
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/posix_typed_mem_open.html =====
posix_typed_mem_open
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
posix_typed_mem_open — open a typed memory object (ADVANCED REALTIME)
SYNOPSIS
[TYM]  #include
int posix_typed_mem_open(const char *name, int oflag, int tflag);
DESCRIPTION
The posix_typed_mem_open() function shall establish a connection between the typed memory object specified by the string
pointed to by name and a file descriptor. It shall create an open file description that refers to the typed memory object
and a file descriptor that refers to that open file description. The file descriptor shall be allocated as described in 2.6 File Descriptor Allocation and can be used by other functions to refer to
that typed memory object. It is unspecified whether the name appears in the file system and is visible to other functions that take
pathnames as arguments. The name argument conforms to the construction rules for a pathname, except that the interpretation
of  characters other than the leading  character in name is implementation-defined, and that the
length limits for the name argument are implementation-defined and need not be the same as the pathname limits {PATH_MAX}
and {NAME_MAX}. If name begins with the  character, then processes calling posix_typed_mem_open() with
the same value of name shall refer to the same typed memory object. If name does not begin with the
character, the effect is implementation-defined.
Each typed memory object supported in a system shall be identified by a name which specifies not only its associated typed
memory pool, but also the path or port by which it is accessed. That is, the same typed memory pool accessed via several different
ports shall have several different corresponding names. The binding between names and typed memory objects is established in an
implementation-defined manner. Unlike shared memory objects, there is no way within POSIX.1-2024 for a program to create a typed
memory object.
The value of tflag shall determine how the typed memory object behaves when subsequently mapped by calls to mmap(). At most, one of the following flags defined in  may be specified:
POSIX_TYPED_MEM_ALLOCATE
Allocate on mmap().
POSIX_TYPED_MEM_ALLOCATE_CONTIG
Allocate contiguously on mmap().
POSIX_TYPED_MEM_MAP_ALLOCATABLE
Map on mmap(), without affecting allocatability.
If tflag has the flag POSIX_TYPED_MEM_ALLOCATE specified, any subsequent call to mmap() using the returned file descriptor shall result in allocation and mapping of typed
memory from the specified typed memory pool. The allocated memory may be a contiguous previously unallocated area of the typed
memory pool or several non-contiguous previously unallocated areas (mapped to a contiguous portion of the process address space).
If tflag has the flag POSIX_TYPED_MEM_ALLOCATE_CONTIG specified, any subsequent call to mmap() using the returned file descriptor shall result in allocation and mapping of a single
contiguous previously unallocated area of the typed memory pool (also mapped to a contiguous portion of the process address space).
If tflag has none of the flags POSIX_TYPED_MEM_ALLOCATE or POSIX_TYPED_MEM_ALLOCATE_CONTIG specified, any subsequent call to
mmap() using the returned file descriptor shall map an application-chosen area from the
specified typed memory pool such that this mapped area becomes unavailable for allocation until unmapped by all processes. If
tflag has the flag POSIX_TYPED_MEM_MAP_ALLOCATABLE specified, any subsequent call to mmap() using the returned file descriptor shall map an application-chosen area from the
specified typed memory pool without an effect on the availability of that area for allocation; that is, mapping such an object
leaves each byte of the mapped area unallocated if it was unallocated prior to the mapping or allocated if it was allocated prior
to the mapping. Appropriate privileges to specify the POSIX_TYPED_MEM_MAP_ALLOCATABLE flag are implementation-defined.
If successful, posix_typed_mem_open() shall return a file descriptor for the typed memory object. The open file
description is new, and therefore the file descriptor shall not share it with any other processes. It is unspecified whether the
file offset is set. The FD_CLOEXEC file descriptor flag associated with the new file descriptor shall be cleared unless
oflag includes O_CLOEXEC. The FD_CLOFORK file descriptor flag associated with the new file descriptor shall be cleared
unless oflag includes O_CLOFORK.
The behavior of msync(), ftruncate(), and all file operations other than mmap(), posix_mem_offset(), posix_typed_mem_get_info(), fstat(), dup(), dup2(), dup3(), and close(), is unspecified when passed a file descriptor connected to a typed memory object by
this function.
The file status flags of the open file description shall be set according to the value of oflag. Applications shall
specify exactly one of the three access mode values described below as the value of oflag.
O_RDONLY
Open for read access only.
O_WRONLY
Open for write access only.
O_RDWR
Open for read or write access.
Additionally, the value of oflag can include the following flags:
O_CLOEXEC
Set the FD_CLOEXEC file descriptor flag.
O_CLOFORK
Set the FD_CLOFORK file descriptor flag.
RETURN VALUE
Upon successful completion, the posix_typed_mem_open() function shall return a non-negative integer representing the file
descriptor. Otherwise, it shall return -1 and set errno to indicate the error.
ERRORS
The posix_typed_mem_open() function shall fail if:
[EACCES]
The typed memory object exists and the permissions specified by oflag are denied.
[EINTR]
The posix_typed_mem_open() operation was interrupted by a signal.
[EINVAL]
The flags specified in tflag are invalid (more than one of POSIX_TYPED_MEM_ALLOCATE, POSIX_TYPED_MEM_ALLOCATE_CONTIG, or
POSIX_TYPED_MEM_MAP_ALLOCATABLE is specified).
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
Too many file descriptors are currently open in the system.
[ENOENT]
The named typed memory object does not exist.
[EPERM]
The caller lacks appropriate privileges to specify the POSIX_TYPED_MEM_MAP_ALLOCATABLE flag in the tflag argument.
The posix_typed_mem_open() function may fail if:
[ENAMETOOLONG]
The length of the name argument exceeds {_POSIX_PATH_MAX} on systems that do not support the XSI option [XSI]   or exceeds
{_XOPEN_PATH_MAX} on XSI systems,   or has a pathname component
that is longer than {_POSIX_NAME_MAX} on systems that do not support the XSI option [XSI]   or longer
than {_XOPEN_NAME_MAX} on XSI systems.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The use of the O_CLOEXEC and O_CLOFORK flags to posix_typed_mem_open() is necessary to avoid leaking typed memory file
descriptors to child processes, since fcntl() has unspecified results on typed memory
objects and therefore cannot be used to set FD_CLOEXEC or FD_CLOFORK after the file descriptor has been opened. The exec family of functions already unmaps all memory associated with a typed memory object, but does
not close the file descriptor unless FD_CLOEXEC is also set.
FUTURE DIRECTIONS
None.
SEE ALSO
2.6 File Descriptor Allocation, close(), dup(), exec, fcntl(), fstat(), ftruncate(), mmap(), msync(), posix_mem_offset(),
posix_typed_mem_get_info(), umask()
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1j-2000.
Issue 7
Austin Group Interpretation 1003.1-2001 #143 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0442 [119,428] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0256 [835], XSH/TC2-2008/0257 [835], and XSH/TC2-2008/0258 [835] are
applied.
Issue 8
Austin Group Defects 411 and 1318 are applied, adding O_CLOEXEC, O_CLOFORK, and dup3().
Austin Group Defect 593 is applied, removing a reference to  from
the DESCRIPTION section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atomic_flag_test_and_set.html =====
atomic_flag_test_and_set
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atomic_flag_test_and_set, atomic_flag_test_and_set_explicit — test and set an atomic flag
SYNOPSIS
#include
_Bool atomic_flag_test_and_set(volatile atomic_flag *object);
_Bool atomic_flag_test_and_set_explicit(volatile atomic_flag *object,
memory_order order);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
Implementations that define the macro __STDC_NO_ATOMICS__ need not provide the  header nor support these generic functions.
The atomic_flag_test_and_set_explicit() function shall atomically place the atomic flag pointed to by object into
the set state and return the value corresponding to the immediately preceding state. This operation shall be an atomic
read-modify-write operation (see 4.15.1 Memory Ordering). Memory
shall be affected according to the value of order.
The atomic_flag_test_and_set() function shall be equivalent to atomic_flag_test_and_set_explicit() called with
order set to memory_order_seq_cst.
RETURN VALUE
These functions shall return the value that corresponds to the state of the atomic flag immediately before the effects. The
return value true shall correspond to the set state and the return value false shall correspond to the clear state.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD 4.15.1 Memory Ordering,
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcstoimax.html =====
wcstoimax
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcstoimax, wcstoumax — convert a wide-character string to an integer type
SYNOPSIS
#include
#include
intmax_t wcstoimax(const wchar_t *restrict nptr,
wchar_t **restrict endptr, int base);
uintmax_t wcstoumax(const wchar_t *restrict nptr,
wchar_t **restrict endptr, int base);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall be equivalent to the wcstol(), wcstoll(), wcstoul(), and wcstoull() functions, respectively, except that the initial portion of the wide string
shall be converted to intmax_t and uintmax_t representation, respectively.
RETURN VALUE
These functions shall return the converted value, if any.
If no conversion could be performed, zero shall be returned. If the correct value is outside the range of representable values,
{INTMAX_MAX}, {INTMAX_MIN}, or {UINTMAX_MAX} shall be returned (according to the return type and sign of the value, if any), and
errno shall be set to [ERANGE].
ERRORS
These functions shall fail if:
[EINVAL]
The value of base is not supported.
[ERANGE]
The value to be returned is not representable.
These functions may fail if:
[EINVAL]
No conversion could be performed.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
wcstol(), wcstoul()
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fflush.html =====
fflush
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fflush — flush a stream
SYNOPSIS
#include
int fflush(FILE *stream);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
If stream points to an output stream or an update stream in which the most recent operation was not input,
fflush() shall cause any unwritten data for that stream to be written to the file, [CX]   and the last
data modification and last file status change timestamps of the underlying file shall be marked for update.
For a stream open for reading with an underlying file description, if the file is not already at EOF, and the file is one
capable of seeking, the file offset of the underlying open file description shall be set to the file position of the stream, and
any characters pushed back onto the stream by ungetc() or ungetwc() that have not subsequently been read from the stream shall be discarded (without
further changing the file offset).
If stream is a null pointer, fflush() shall perform this flushing action on all streams for which the behavior is
defined above.
RETURN VALUE
Upon successful completion, fflush() shall return 0; otherwise, it shall set the error indicator for the stream, return
EOF, [CX]
and set errno to indicate the error.
ERRORS
The fflush() function shall fail if:
[EAGAIN]
[CX]
The O_NONBLOCK flag is set for the file descriptor underlying stream and the thread would be delayed in the write operation.
[EBADF]
[CX]
The file descriptor underlying stream is not valid.
[EFBIG]
[CX]  An
attempt was made to write a file that exceeds the maximum file size.
[EFBIG]
[CX]  An
attempt was made to write a file that exceeds the file size limit of the process.
[XSI]
A SIGXFSZ signal shall also be generated for the thread.
[EFBIG]
[CX]
The file is a regular file and an attempt was made to write at or beyond the offset maximum associated with the corresponding
stream.
[EINTR]
[CX]
The fflush() function was interrupted by a signal.
[EIO]
[CX]
The process is a member of a background process group attempting to write to its controlling terminal, TOSTOP is set, the calling
thread is not blocking SIGTTOU, the process is not ignoring SIGTTOU, and the process group of the process is orphaned. This error
may also be returned under implementation-defined conditions.
[ENOMEM]
[CX]
The underlying stream was created by open_memstream() or open_wmemstream() and insufficient memory is available.
[ENOSPC]
[CX]
There was no free space remaining on the device containing the file or in the buffer used by the fmemopen() function.
[EPIPE]
[CX]  An
attempt is made to write to a pipe or FIFO that is not open for reading by any process. A SIGPIPE signal shall also be sent to the
thread.
The fflush() function may fail if:
[ENXIO]
[CX]  A
request was made of a nonexistent device, or the request was outside the capabilities of the device.
The following sections are informative.
EXAMPLES
Sending Prompts to Standard Output
The following example uses printf() calls to print a series of prompts for
information the user must enter from standard input. The fflush() calls force the output to standard output. The
fflush() function is used because standard output is usually buffered and the prompt may not immediately be printed on the
output or terminal. The getline() function calls read strings from standard input
and place the results in variables, for use later in the program.
char *user;
char *oldpasswd;
char *newpasswd;
ssize_t llen;
size_t blen;
struct termios term;
tcflag_t saveflag;
printf("User name: ");
fflush(stdout);
blen = 0;
llen = getline(&user, &blen, stdin);
user[llen-1] = 0;
tcgetattr(fileno(stdin), &term);
saveflag = term.c_lflag;
term.c_lflag &= ~ECHO;
tcsetattr(fileno(stdin), TCSANOW, &term);
printf("Old password: ");
fflush(stdout);
blen = 0;
llen = getline(&oldpasswd, &blen, stdin);
oldpasswd[llen-1] = 0;
printf("\nNew password: ");
fflush(stdout);
blen = 0;
llen = getline(&newpasswd, &blen, stdin);
newpasswd[llen-1] = 0;
term.c_lflag = saveflag;
tcsetattr(fileno(stdin), TCSANOW, &term);
free(user);
free(oldpasswd);
free(newpasswd);
APPLICATION USAGE
None.
RATIONALE
Data buffered by the system may make determining the validity of the position of the current file descriptor impractical. Thus,
enforcing the repositioning of the file descriptor after fflush() on streams open for read() is not mandated by POSIX.1-2024.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fmemopen(), getrlimit(), open_memstream()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
Large File Summit extensions are added.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The [EFBIG] error is added as part of the large file support extensions.
The [ENXIO] optional error condition is added.
The RETURN VALUE section is updated to note that the error indicator shall be set for the stream. This is for alignment with the
ISO/IEC 9899:1999 standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/31 is applied, updating the [EAGAIN] error in the ERRORS section
from "the process would be delayed" to "the thread would be delayed".
Issue 7
Austin Group Interpretation 1003.1-2001 #002 is applied, clarifying the interaction of file descriptors and streams.
The [ENOSPC] error condition is updated and the [ENOMEM] error is added from The Open Group Technical Standard, 2006, Extended
API Set Part 1.
The EXAMPLES section is revised.
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0126 [87], XSH/TC1-2008/0127 [79], and XSH/TC1-2008/0128 [14] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0112 [816] and XSH/TC2-2008/0113 [626] are applied.
Issue 8
Austin Group Defect 308 is applied, clarifying the handling of [EFBIG] errors.
Austin Group Defect 1669 is applied, removing XSI shading from part of the [EFBIG] error relating to the file size limit for the
process.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getpgrp.html =====
getpgrp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getpgrp — get the process group ID of the calling process
SYNOPSIS
#include
pid_t getpgrp(void);
DESCRIPTION
The getpgrp() function shall return the process group ID of the calling process.
RETURN VALUE
The getpgrp() function shall always be successful and no return value is reserved to indicate an error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
4.3 BSD provides a getpgrp() function that returns the process group ID for a specified process. Although this function
supports job control, all known job control shells always specify the calling process with this function. Thus, the simpler System
V getpgrp() suffices, and the added complexity of the 4.3 BSD getpgrp() is provided by the getpgid() function.
FUTURE DIRECTIONS
None.
SEE ALSO
exec, fork(), getpgid(), getpid(), getppid(), kill(), setpgid(), setsid()
XBD ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
In the SYNOPSIS, the optional include of the  header is
removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
Issue 8
Austin Group Defect 1245 is applied, changing the RATIONALE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/isalnum.html =====
isalnum
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
isalnum, isalnum_l — test for an alphanumeric character
SYNOPSIS
#include
int isalnum(int c);
[CX]  int isalnum_l(int c, locale_t locale);
DESCRIPTION
For isalnum(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The isalnum() [CX]   and isalnum_l()
functions shall test whether c is a character of class alpha or digit in the current locale,
[CX]
or in the locale represented by locale,  respectively;
see XBD 7. Locale.
The c argument is an int, the value of which the application shall ensure is representable as an unsigned
char or equal to the value of the macro EOF. If the argument has any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to isalnum_l() is the special locale object LC_GLOBAL_LOCALE or is not a
valid locale object handle.
RETURN VALUE
The isalnum() [CX]   and isalnum_l()
functions shall return non-zero if c is an alphanumeric character; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
isalpha(), isblank(), iscntrl(), isdigit(), isgraph(), islower(), isprint(), ispunct(), isspace(), isupper(), isxdigit(), setlocale(), uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The isalnum_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0274 [302], XSH/TC1-2008/0275 [283], and XSH/TC1-2008/0276 [283] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pclose.html =====
pclose
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pclose — close a pipe stream to or from a process
SYNOPSIS
[CX]  #include
int pclose(FILE *stream);
DESCRIPTION
The pclose() function shall close a stream that was opened by popen(), wait
for the command to terminate, and return the termination status of the process that was running the command language interpreter.
However, if a call caused the termination status to be unavailable to pclose(), then pclose() shall return -1 with
errno set to [ECHILD] to report this situation. This can happen if the application calls one of the following functions:
wait()
waitpid() with a pid argument less than or equal to 0 or equal to the
process ID of the command line interpreter
Any other function not defined in this volume of POSIX.1-2024 that could do one of the above
In any case, pclose() shall not return before the child process created by popen() has terminated.
If the command language interpreter cannot be executed, the child termination status returned by pclose() shall be as if
the command language interpreter terminated using exit(127) or _exit(127).
The pclose() function shall not affect the termination status of any child of the calling process other than the one
created by popen() for the associated stream.
If the argument stream to pclose() is not a pointer to a stream created by popen(), the result of pclose() is undefined.
If a thread is canceled during execution of pclose(), the behavior is undefined.
RETURN VALUE
Upon successful return, pclose() shall return the termination status of the command language interpreter. Otherwise,
pclose() shall return -1 and set errno to indicate the error.
ERRORS
The pclose() function shall fail if:
[ECHILD]
The status of the child process could not be obtained, as described above.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
There is a requirement that pclose() not return before the child process terminates. This is intended to disallow
implementations that return [EINTR] if a signal is received while waiting. If pclose() returned before the child terminated,
there would be no way for the application to discover which child used to be associated with the stream, and it could not do the
cleanup itself.
If the stream pointed to by stream was not created by popen(), historical
implementations of pclose() return -1 without setting errno. To avoid requiring pclose() to set errno
in this case, POSIX.1-2024 makes the behavior unspecified. An application should not use pclose() to close any stream that
was not created by popen().
Some historical implementations of pclose() either block or ignore the signals SIGINT, SIGQUIT, and SIGHUP while waiting
for the child process to terminate. Since this behavior is not described for the pclose() function in POSIX.1-2024, such
implementations are not conforming. Also, some historical implementations return [EINTR] if a signal is received, even though the
child process has not terminated. Such implementations are also considered non-conforming.
Consider, for example, an application that uses:
popen("command", "r")
to start command, which is part of the same application. The parent writes a prompt to its standard output (presumably
the terminal) and then reads from the popen()ed stream. The child reads the response
from the user, does some transformation on the response (pathname expansion, perhaps) and writes the result to its standard output.
The parent process reads the result from the pipe, does something with it, and prints another prompt. The cycle repeats. Assuming
that both processes do appropriate buffer flushing, this would be expected to work.
To conform to POSIX.1-2024, pclose() must use waitpid(), or some similar
function, instead of wait().
See the RATIONALE for popen() for a sample implementation of pclose().
FUTURE DIRECTIONS
None.
SEE ALSO
fork(), popen(), wait()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 7
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0246 [632] is applied.
Issue 8
Austin Group Defect 411 is applied, changing the RATIONALE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/connect.html =====
connect
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
connect — connect a socket
SYNOPSIS
#include
int connect(int socket, const struct sockaddr *address,
socklen_t address_len);
DESCRIPTION
The connect() function shall attempt to make a connection on a connection-mode socket or to set or reset the peer address
of a connectionless-mode socket. The function takes the following arguments:
socket
Specifies the file descriptor associated with the socket.
address
Points to a sockaddr structure containing the peer address. The length and format of the address depend on the address
family of the socket.
address_len
Specifies the length of the sockaddr structure pointed to by the address argument.
If the address family of the socket is AF_UNIX, the application shall ensure that a null terminator after the pathname is
included in the sun_path member of address as a sockaddr_un structure, and that address_len is at least
offsetof(struct sockaddr_un, sun_path) + 1 plus the length of the pathname.
If the socket has not already been bound to a local address, connect() shall bind it to an address which, unless the
socket's address family is AF_UNIX, is an unused local address.
If the initiating socket is not connection-mode, then connect() shall set the socket's peer address, and no connection is
made. For SOCK_DGRAM sockets, the peer address identifies where all datagrams are sent on subsequent send() functions, and limits the remote sender for subsequent recv() functions. If the sa_family member of address is AF_UNSPEC, the socket's
peer address shall be reset. Note that despite no connection being made, the term "connected" is used to describe a
connectionless-mode socket for which a peer address has been set.
If the initiating socket is connection-mode, then connect() shall attempt to establish a connection to the address
specified by the address argument. If the connection cannot be established immediately and O_NONBLOCK is not set for the
file descriptor for the socket, connect() shall block for up to an unspecified timeout interval until the connection is
established. If the timeout interval expires before the connection is established, connect() shall fail and the connection
attempt shall be aborted. If connect() is interrupted by a signal that is caught while blocked waiting to establish a
connection, connect() shall fail and set errno to [EINTR], but the connection request shall not be aborted, and the
connection shall be established asynchronously.
If the connection cannot be established immediately and O_NONBLOCK is set for the file descriptor for the socket,
connect() shall fail and set errno to [EINPROGRESS], but the connection request shall not be aborted, and the
connection shall be established asynchronously. Subsequent calls to connect() for the same socket, before the connection is
established, shall fail and set errno to [EALREADY].
When the connection has been established asynchronously, pselect(), select(), poll(), and ppoll() shall indicate that the file descriptor for the socket is ready for writing.
The socket in use may require the process to have appropriate privileges to use the connect() function.
RETURN VALUE
Upon successful completion, connect() shall return 0; otherwise, -1 shall be returned and errno set to indicate
the error.
ERRORS
The connect() function shall fail if:
[EADDRNOTAVAIL]
The specified address is not available from the local machine.
[EAFNOSUPPORT]
The specified address is not a valid address for the address family of the specified socket.
[EALREADY]
A connection request is already in progress for the specified socket.
[EBADF]
The socket argument is not a valid file descriptor.
[ECONNREFUSED]
The target address was not listening for connections or refused the connection request.
[EINPROGRESS]
O_NONBLOCK is set for the file descriptor for the socket and the connection cannot be immediately established; the connection
shall be established asynchronously.
[EINTR]
The attempt to establish a connection was interrupted by delivery of a signal that was caught; the connection shall be
established asynchronously.
[EISCONN]
The specified socket is connection-mode and is already connected.
[ENETUNREACH]
No route to the network is present.
[ENOTSOCK]
The socket argument does not refer to a socket.
[EPROTOTYPE]
The specified address has a different type than the socket bound to the specified peer address.
[ETIMEDOUT]
The attempt to connect timed out before a connection was made.
If the address family of the socket is AF_UNIX, then connect() shall fail if:
[EIO]
An I/O error occurred while reading from or writing to the file system.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the pathname in address.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of the pathname does not name an existing file or the pathname is an empty string.
[ENOTDIR]
A component of the path prefix of the pathname in address names an existing file that is neither a directory nor a
symbolic link to a directory, or the pathname in address contains at least one non- character and ends with one
or more trailing  characters and the last pathname component names an existing file that is neither a directory nor a
symbolic link to a directory.
The connect() function may fail if:
[EACCES]
Search permission is denied for a component of the path prefix; or write access to the named socket is denied.
[EADDRINUSE]
Attempt to establish a connection that uses addresses that are already in use.
[ECONNRESET]
Remote host reset the connection request.
[EHOSTUNREACH]
The destination host cannot be reached (probably because the host is down or a remote router cannot reach it).
[EINVAL]
The address_len argument is not a valid length for the address family; or invalid address family in the sockaddr
structure.
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the pathname in address.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
[ENETDOWN]
The local network interface used to reach the destination is down.
[ENOBUFS]
No buffer space is available.
[EOPNOTSUPP]
The socket is listening and cannot be connected.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
If connect() fails, the state of the socket is unspecified. Conforming applications should close the file descriptor and
create a new socket before attempting to reconnect.
For AF_UNIX sockets, some implementations support an extension where address_len does not have to include a null
terminator for the pathname stored in sun_path, which in turn allows a pathname to be one byte longer. However, such usage
is not portable, and carries a risk of accessing beyond the intended bounds of the pathname length.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
accept(), bind(), close(), getsockname(), poll(), pselect(), send(), shutdown(), socket()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
The wording of the mandatory [ELOOP] error condition is updated, and a second optional [ELOOP] error condition is added.
Issue 7
Austin Group Interpretation 1003.1-2001 #035 is applied, clarifying the description of connected sockets.
Austin Group Interpretation 1003.1-2001 #143 is applied.
Austin Group Interpretation 1003.1-2001 #188 is applied, changing the method used to reset a peer address for a datagram
socket.
SD5-XSH-ERN-185 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0062 [324] is applied.
Issue 8
Austin Group Defect 561 is applied, changing the requirements for the sun_path member of the sockaddr_un
structure.
Austin Group Defect 1263 is applied, adding ppoll().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/isless.html =====
isgreater
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
isgreater, isgreaterequal, isless, islessequal, islessgreater — real-floating relational tests
SYNOPSIS
#include
int isgreater(real-floating x, real-floating y);
int isgreaterequal(real-floating x, real-floating y);
int isless(real-floating x, real-floating y);
int islessequal(real-floating x, real-floating y);
int islessgreater(real-floating x, real-floating y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The isgreater() macro shall determine whether its first argument is greater than its second argument. The value of
isgreater(x, y) shall be equal to (x) > (y); however, unlike
(x) > (y), isgreater(x, y) shall not raise the invalid floating-point exception
when x and y are unordered.
The isgreaterequal() macro shall determine whether its first argument is greater than or equal to its second argument.
The value of isgreaterequal(x, y) shall be equal to (x) >= (y); however, unlike
(x) >= (y), isgreaterequal(x, y) shall not raise the invalid floating-point
exception when x and y are unordered.
The isless() macro shall determine whether its first argument is less than its second argument. The value of
isless(x, y) shall be equal to (x)  (y); however, islessgreater(x,
y) shall not raise the invalid floating-point exception when x and y are unordered (nor shall it evaluate
x and y twice).
[MX]
Relational operators and their corresponding comparison macros shall produce equivalent result values, even if argument values are
represented in wider formats. Thus, comparison macro arguments represented in formats wider than their semantic types shall not be
converted to the semantic types, unless the wide evaluation method converts operands of relational operators to their semantic
types. The standard wide evaluation methods characterized by FLT_EVAL_METHOD equal to 1 or 2 (see ) do not convert operands of relational operators to their semantic types.
RETURN VALUE
Upon successful completion, the isgreater() macro shall return the value of (x) > (y).
Upon successful completion, the isgreaterequal() macro shall return the value of
(x) >= (y).
Upon successful completion, the isless() macro shall return the value of (x)  (y).
If x or y is NaN, these functions shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The relational and equality operators support the usual mathematical relationships between numeric values. For any ordered pair
of numeric values, exactly one of the relationships (less, greater, and equal) is true. Relational operators may raise the invalid
floating-point exception when argument values are NaNs. For a NaN and a numeric value, or for two NaNs, just the unordered
relationship is true. This macro is a quiet (non-floating-point exception raising) version of a relational operator. It facilitates
writing efficient code that accounts for NaNs without suffering the invalid floating-point exception. In the SYNOPSIS section,
real-floating indicates that the argument shall be an expression of real-floating type.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
isunordered()
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
The individual pages for these functions have been merged to form a single page, to reduce duplication.
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ntohs.html =====
htonl
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
htonl, htons, ntohl, ntohs — convert values between host and network byte order
SYNOPSIS
#include
uint32_t htonl(uint32_t hostlong);
uint16_t htons(uint16_t hostshort);
uint32_t ntohl(uint32_t netlong);
uint16_t ntohs(uint16_t netshort);
DESCRIPTION
These functions shall convert 16-bit and 32-bit quantities between network byte order and host byte order.
On some implementations, these functions are defined as macros.
The uint32_t and uint16_t types are defined in .
RETURN VALUE
The htonl() and htons() functions shall return the argument value converted from host to network byte order.
The ntohl() and ntohs() functions shall return the argument value converted from network to host byte order.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
These functions are most often used in conjunction with IPv4 addresses and ports as returned by gethostent() and getservent().
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
be16toh(), endhostent(),
endservent()
XBD , ,
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
Issue 8
Austin Group Defect 162 is applied, adding be16toh() and  to the SEE ALSO section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_rwlock_trywrlock.html =====
pthread_rwlock_trywrlock
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_rwlock_trywrlock, pthread_rwlock_wrlock — lock a read-write lock object for writing
SYNOPSIS
#include
int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
DESCRIPTION
The pthread_rwlock_trywrlock() function shall apply a write lock like the pthread_rwlock_wrlock() function, with
the exception that the function shall fail if any thread currently holds rwlock (for reading or writing).
The pthread_rwlock_wrlock() function shall apply a write lock to the read-write lock referenced by rwlock. The
calling thread shall acquire the write lock if no thread (reader or writer) holds the read-write lock rwlock. Otherwise, if
another thread holds the read-write lock rwlock, the calling thread shall block until it can acquire the lock. If a deadlock
condition occurs or the calling thread already owns the read-write lock for writing or reading, the call shall either deadlock or
return [EDEADLK].
Results are undefined if any of these functions are called with an uninitialized read-write lock.
If a signal is delivered to a thread waiting for a read-write lock for writing, upon return from the signal handler the thread
resumes waiting for the read-write lock for writing as if it was not interrupted.
RETURN VALUE
The pthread_rwlock_trywrlock() function shall return zero if the lock for writing on the read-write lock object
referenced by rwlock is acquired. Otherwise, an error number shall be returned to indicate the error.
If successful, the pthread_rwlock_wrlock() function shall return zero; otherwise, an error number shall be returned to
indicate the error.
ERRORS
The pthread_rwlock_trywrlock() function shall fail if:
[EBUSY]
The read-write lock could not be acquired for writing because it was already locked for reading or writing.
The pthread_rwlock_wrlock() function may fail if:
[EDEADLK]
A deadlock condition was detected or the current thread already owns the read-write lock for writing or reading.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications using these functions may be subject to priority inversion, as discussed in XBD 3.275 Priority Inversion.
RATIONALE
If an implementation detects that the value specified by the rwlock argument to pthread_rwlock_trywrlock() or
pthread_rwlock_wrlock() does not refer to an initialized read-write lock object, it is recommended that the function should
fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_rwlock_clockrdlock(), pthread_rwlock_clockwrlock(), pthread_rwlock_destroy(), pthread_rwlock_rdlock(), pthread_rwlock_unlock()
XBD 3.275 Priority Inversion, 4.15.2 Memory Synchronization,
CHANGE HISTORY
First released in Issue 5.
Issue 6
The following changes are made for alignment with IEEE Std 1003.1j-2000:
The margin code in the SYNOPSIS is changed to THR to indicate that the functionality is now part of the Threads option
(previously it was part of the Read-Write Locks option in IEEE Std 1003.1j-2000 and also part of the XSI extension).
The [EDEADLK] error is deleted as a pthread_rwlock_trywrlock() error.
The SEE ALSO section is updated.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/104 is applied, updating the ERRORS section so that the
[EDEADLK] error includes detection of a deadlock condition.
Issue 7
The pthread_rwlock_trywrlock() and pthread_rwlock_wrlock() functions are moved from the Threads option to the
Base.
The [EINVAL] error for an uninitialized read-write lock object is removed; this condition results in undefined behavior.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0290 [720] and XSH/TC2-2008/0291 [722] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sethostent.html =====
endhostent
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
endhostent, gethostent, sethostent — network host database functions
SYNOPSIS
#include
void endhostent(void);
struct hostent *gethostent(void);
void sethostent(int stayopen);
DESCRIPTION
These functions shall retrieve information about hosts. This information is considered to be stored in a database that can be
accessed sequentially or randomly. The implementation of this database is unspecified.
Note:
In many cases this database is implemented by the Domain Name System, as documented in RFC 1034, RFC 1035, and
RFC 3596.
The sethostent() function shall open a connection to the database and set the next entry for retrieval to the first entry
in the database. If the stayopen argument is non-zero, the connection shall not be closed by a call to gethostent(),
and the implementation may maintain an open file descriptor. If a file descriptor is opened, the FD_CLOEXEC flag shall be set; see
.
The gethostent() function shall read the next entry in the database, opening and closing a connection to the database as
necessary.
Entries shall be returned in hostent structures.
The endhostent() function shall close the connection to the database, releasing any open file descriptor.
These functions need not be thread-safe.
RETURN VALUE
Upon successful completion, the gethostent() function shall return a pointer to a hostent structure if the
requested entry was found, and a null pointer if the end of the database was reached or the requested entry was not found.
The application shall not modify the structure to which the return value points, nor any storage areas pointed to by pointers
within the structure. The returned pointer, and pointers within the structure, might be invalidated or the structure or the storage
areas might be overwritten by a subsequent call to gethostent(). The returned pointer, and pointers within the structure,
might also be invalidated if the calling thread is terminated.
ERRORS
The gethostent() and sethostent() functions may fail if:
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum allowable number of files is currently open in the system.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
endservent()
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0081 [75,428] and XSH/TC1-2008/0082 [75] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0089 [656] is applied.
Issue 8
Austin Group Defect 368 is applied, adding a requirement for FD_CLOEXEC to be set if a file descriptor is opened, and adding the
[EMFILE] and [ENFILE] errors.
Austin Group Defect 1685 is applied, updating RFC references.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atanh.html =====
atanh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atanh, atanhf, atanhl — inverse hyperbolic tangent functions
SYNOPSIS
#include
double atanh(double x);
float atanhf(float x);
long double atanhl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the inverse hyperbolic tangent of their argument x.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the inverse hyperbolic tangent of their argument.
If x is ±1, a pole error shall occur, and atanh(), atanhf(), and atanhl() shall return the value of
the macro HUGE_VAL, HUGE_VALF, and HUGE_VALL, respectively, with the same sign as the correct value of the function.
For finite |x|>1, a domain error shall occur, and [MX]   either a NaN (if supported), or   an implementation-defined value shall be returned.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, x shall be returned.
If x is ±Inf, a domain error shall occur, and a NaN shall be returned.
[MXX]
If x is subnormal, x should be returned.
[MX]  If x is subnormal, a range error may occur and, if x is
not returned, atanh(), atanhf(), and atanhl() shall return an implementation-defined value no greater in
magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
ERRORS
These functions shall fail if:
Domain Error
The x argument is finite and not in the range [-1,1], [MX]   or is ±Inf.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
Pole Error
The x argument is ±1.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the divide-by-zero floating-point exception shall
be raised.
These functions may fail if:
Range Error
[MX]
The value of x is subnormal.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), tanh()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The atanh() function is no longer marked as an extension.
The atanhf() and atanhl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0039 [320] and XSH/TC1-2008/0040 [680] are applied.
Issue 8
Austin Group Defect 1382 is applied, rearranging the text describing the behavior when x is subnormal to avoid the need
for two shading changes.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/seteuid.html =====
seteuid
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
seteuid — set effective user ID
SYNOPSIS
#include
int seteuid(uid_t uid);
DESCRIPTION
If uid is equal to the real user ID or the saved set-user-ID, or if the process has appropriate privileges,
seteuid() shall set the effective user ID of the calling process to uid; the real user ID and saved set-user-ID shall
remain unchanged.
The seteuid() function shall not affect the supplementary group list in any way.
RETURN VALUE
Upon successful completion, 0 shall be returned; otherwise, -1 shall be returned and errno set to indicate the error.
ERRORS
The seteuid() function shall fail if:
[EINVAL]
The value of the uid argument is invalid and is not supported by the implementation.
[EPERM]
The process does not have appropriate privileges and uid does not match the real user ID or the saved set-user-ID.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
Refer to the RATIONALE section in setuid().
FUTURE DIRECTIONS
None.
SEE ALSO
exec, getegid(), geteuid(), getgid(), getresgid(), getresuid(), getuid(), setegid(), setgid(), setregid(), setresgid(), setresuid(), setreuid(), setuid()
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from the IEEE P1003.1a draft standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/123 is applied, making an editorial correction to the [EPERM]
error in the ERRORS section.
Issue 8
Austin Group Defect 1344 is applied, adding getresgid(), getresuid(), setresgid(), and setresuid() to SEE ALSO.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/posix_spawn_file_actions_adddup2.html =====
posix_spawn_file_actions_adddup2
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
posix_spawn_file_actions_adddup2 — add dup2 action to spawn file actions object (ADVANCED REALTIME)
SYNOPSIS
[SPN]  #include
int posix_spawn_file_actions_adddup2(posix_spawn_file_actions_t
*file_actions, int fildes, int newfildes);
DESCRIPTION
The posix_spawn_file_actions_adddup2() function shall add a dup2() action to
the object referenced by file_actions that shall cause the file descriptor fildes to be duplicated as
newfildes (as if dup2(fildes, newfildes) had been called) when a new process is spawned using this file
actions object.
If fildes and newfildes are equal, then the action shall ensure that newfildes is inherited by the new
process with FD_CLOEXEC clear, even if the FD_CLOEXEC flag of fildes is set at the time the new process is spawned, and even
though dup2() would not make such a change.
A spawn file actions object is as defined in posix_spawn_file_actions_addclose().
RETURN VALUE
Upon successful completion, the posix_spawn_file_actions_adddup2() function shall return zero; otherwise, an error number
shall be returned to indicate the error.
ERRORS
The posix_spawn_file_actions_adddup2() function shall fail if:
[EBADF]
The value specified by fildes or newfildes is negative or greater than or equal to {OPEN_MAX}.
[ENOMEM]
Insufficient memory exists to add to the spawn file actions object.
The posix_spawn_file_actions_adddup2() function may fail if:
[EINVAL]
The value specified by file_actions is invalid.
It shall not be considered an error for the fildes argument passed to the posix_spawn_file_actions_adddup2()
function to specify a file descriptor for which the specified operation could not be performed at the time of the call. Any such
error shall be detected when the associated file actions object is later used during a posix_spawn() or posix_spawnp()
operation.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The posix_spawn_file_actions_adddup2() function is part of the Spawn option and need not be provided on all
implementations.
Implementations may use file descriptors that must be inherited into child processes for the child process to remain conforming,
such as for message catalog or tracing purposes. Therefore, an application that calls posix_spawn_file_actions_adddup2()
with an arbitrary integer for newfildes risks non-conforming behavior, and this function can only portably be used to
overwrite file descriptor values that the application has obtained through explicit actions, or for the three file descriptors
corresponding to the standard file streams. In order to avoid a race condition of leaking an unintended file descriptor into a
child process or executed program, an application should consider opening all file descriptors with the FD_CLOFORK or FD_CLOEXEC
flag, or both flags, set unless the file descriptor is intended to be inherited by child processes or executed programs,
respectively.
RATIONALE
Refer to the RATIONALE section in posix_spawn_file_actions_addclose().
Although dup2() is required to do nothing when fildes and newfildes
are equal and fildes is an open descriptor, the use of posix_spawn_file_actions_adddup2() is required to cause
fildes to be accessible in the child with FD_CLOEXEC clear. This is because there is no counterpart
posix_spawn_file_actions_fcntl() that could be used for clearing the flag as an independent file action. It would also be
possible to achieve this effect by using two calls to posix_spawn_file_actions_adddup2() and a temporary fildes value
known not to conflict with any other file descriptors, coupled with a posix_spawn_file_actions_addclose() to avoid leaking the
temporary, but this approach is complex, and risks [EMFILE] or [ENFILE] failure that can be avoided with the in-place removal of
FD_CLOEXEC.
There is no need for posix_spawn_file_actions_adddup3(), since it makes no sense to create a file descriptor with
FD_CLOEXEC set before spawning the child process, where that file descriptor would immediately be closed again.
FUTURE DIRECTIONS
None.
SEE ALSO
dup(), posix_spawn(), posix_spawn_file_actions_addclose(), posix_spawn_file_actions_destroy()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1d-1999.
IEEE PASC Interpretation 1003.1 #104 is applied, noting that the [EBADF] error can apply to the newfildes argument in
addition to fildes.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0440 [149] is applied.
Issue 8
Austin Group Defect 411 is applied, changing requirements relating to the FD_CLOEXEC flag when fildes and
newfildes are equal.
Austin Group Defect 1318 is applied, adding FD_CLOFORK.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sem_timedwait.html =====
sem_clockwait
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sem_clockwait, sem_timedwait — lock a semaphore
SYNOPSIS
#include
int sem_clockwait(sem_t *restrict sem, clockid_t clock_id,
const struct timespec *restrict abstime);
int sem_timedwait(sem_t *restrict sem,
const struct timespec *restrict abstime);
DESCRIPTION
The sem_clockwait() and sem_timedwait() functions shall lock the semaphore referenced by sem as in the
sem_wait() function. However, if the semaphore cannot be locked without waiting for
another process or thread to unlock the semaphore by performing a sem_post()
function, this wait shall be terminated when the specified timeout expires.
The timeout shall expire when the absolute time specified by abstime passes, as measured by the clock on which timeouts
are based (that is, when the value of that clock equals or exceeds abstime), or if the absolute time specified by
abstime has already been passed at the time of the call.
For sem_timedwait(), the timeout shall be based on the CLOCK_REALTIME clock. For sem_clockwait(), the timeout
shall be based on the clock specified by the clock_id argument. The resolution of the timeout shall be the resolution of the
clock on which it is based. Implementations shall support passing CLOCK_REALTIME and CLOCK_MONOTONIC to sem_clockwait() as
the clock_id argument.
Under no circumstance shall the function fail with a timeout if the semaphore can be locked immediately. The validity of the
abstime need not be checked if the semaphore can be locked immediately.
RETURN VALUE
The sem_clockwait() and sem_timedwait() functions shall return zero if the calling process successfully performed
the semaphore lock operation on the semaphore designated by sem. If the call was unsuccessful, the state of the semaphore
shall be unchanged, and the functions shall return a value of -1 and set errno to indicate the error.
ERRORS
The sem_clockwait() and sem_timedwait() functions shall fail if:
[EINVAL]
The process or thread would have blocked, and either the abstime parameter specified a nanoseconds field value less than
zero or greater than or equal to 1000 million, or the sem_clockwait() function was passed an invalid or unsupported
clock_id value.
[ETIMEDOUT]
The semaphore could not be locked before the specified timeout expired.
The sem_clockwait() and sem_timedwait() functions may fail if:
[EDEADLK]
A deadlock condition was detected.
[EINTR]
A signal interrupted the function.
[EINVAL]
The sem argument does not refer to a valid semaphore.
The following sections are informative.
EXAMPLES
The program shown below operates on an unnamed semaphore. The program expects two command-line arguments. The first argument
specifies a seconds value that is used to set an alarm timer to generate a SIGALRM signal. This handler performs a sem_post() to increment the semaphore that is being waited on in main() using
sem_clockwait(). The second command-line argument specifies the length of the timeout, in seconds, for
sem_clockwait().
#include
#include
#include
#include
#include
#include
#include
#include
sem_t sem;
static void
handler(int sig)
{
int sav_errno = errno;
static const char info_msg[] = "sem_post() from handler\n";
write(STDOUT_FILENO, info_msg, sizeof info_msg - 1);
if (sem_post(&sem) == -1) {
static const char err_msg[] = "sem_post() failed\n";
write(STDERR_FILENO, err_msg, sizeof err_msg - 1);
_exit(EXIT_FAILURE);
}
errno = sav_errno;
}
int
main(int argc, char *argv[])
{
struct sigaction sa;
struct timespec ts;
int s;
if (argc != 3) {
fprintf(stderr, "Usage: %s  \n",
argv[0]);
exit(EXIT_FAILURE);
}
if (sem_init(&sem, 0, 0) == -1) {
perror("sem_init");
exit(EXIT_FAILURE);
}
/* Establish SIGALRM handler; set alarm timer using argv[1] */
sa.sa_handler = handler;
sigemptyset(&sa.sa_mask);
sa.sa_flags = 0;
if (sigaction(SIGALRM, &sa, NULL) == -1) {
perror("sigaction");
exit(EXIT_FAILURE);
}
alarm(atoi(argv[1]));
/* Calculate relative interval as current time plus
number of seconds given argv[2] */
if (clock_gettime(CLOCK_MONOTONIC, &ts) == -1) {
perror("clock_gettime");
exit(EXIT_FAILURE);
}
ts.tv_sec += atoi(argv[2]);
printf("main() about to call sem_clockwait()\n");
while ((s = sem_clockwait(&sem, CLOCK_MONOTONIC, &ts)) == -1 &&
errno == EINTR)
continue;       /* Restart if interrupted by handler */
/* Check what happened */
if (s == -1) {
if (errno == ETIMEDOUT)
printf("sem_clockwait() timed out\n");
else
perror("sem_clockwait");
} else
printf("sem_clockwait() succeeded\n");
exit((s == 0) ? EXIT_SUCCESS : EXIT_FAILURE);
}
APPLICATION USAGE
Applications using these functions may be subject to priority inversion, as discussed in XBD 3.275 Priority Inversion.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
sem_post(), sem_trywait()
, semctl(), semget(), semop(), time()
XBD 3.275 Priority Inversion, ,
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1d-1999.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/120 is applied, updating the ERRORS section so that the [EINVAL]
error becomes optional.
Issue 7
The sem_timedwait() function is moved from the Semaphores option to the Base.
Functionality relating to the Timers option is moved to the Base.
An example is added.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0529 [138] is applied.
Issue 8
Austin Group Defect 592 is applied, removing text relating to  from
the SYNOPSIS and DESCRIPTION sections.
Austin Group Defect 1216 is applied, adding sem_clockwait().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mq_getattr.html =====
mq_getattr
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mq_getattr — get message queue attributes (REALTIME)
SYNOPSIS
[MSG]  #include
int mq_getattr(mqd_t mqdes, struct mq_attr *mqstat);
DESCRIPTION
The mq_getattr() function shall obtain status information and attributes of the message queue and the open message queue
description associated with the message queue descriptor.
The mqdes argument specifies a message queue descriptor.
The results shall be returned in the mq_attr structure referenced by the mqstat argument.
Upon return, the following members shall have the values associated with the open message queue description as set when the
message queue was opened and as modified by subsequent mq_setattr() calls:
mq_flags.
The following attributes of the message queue shall be returned as set at message queue creation: mq_maxmsg,
mq_msgsize.
Upon return, the following members within the mq_attr structure referenced by the mqstat argument shall be set to
the current state of the message queue:
mq_curmsgs
The number of messages currently on the queue.
RETURN VALUE
Upon successful completion, the mq_getattr() function shall return zero. Otherwise, the function shall return -1 and set
errno to indicate the error.
ERRORS
The mq_getattr() function may fail if:
[EBADF]
The mqdes argument is not a valid message queue descriptor.
The following sections are informative.
EXAMPLES
See mq_notify().
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
mq_notify(), mq_open(),
mq_send(), mq_setattr(),
msgctl(), msgget(), msgrcv(), msgsnd()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The mq_getattr() function is marked as part of the Message Passing option.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Message
Passing option.
The mq_timedsend() function is added to the SEE ALSO section for alignment
with IEEE Std 1003.1d-1999.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/61 is applied, updating the ERRORS section to change the [EBADF]
error from mandatory to optional.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/clock.html =====
clock
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
clock — report CPU time used
SYNOPSIS
#include
clock_t clock(void);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The clock() function shall return the implementation's best approximation to the processor time used by the process since
the beginning of an implementation-defined era related only to the process invocation.
RETURN VALUE
To determine the time in seconds, the value returned by clock() should be divided by the value of the macro
CLOCKS_PER_SEC. [XSI]   CLOCKS_PER_SEC is defined to be one million in .
If the processor time used is not available or its value cannot be
represented, the function shall return the value (clock_t)-1.
ERRORS
The clock() function shall fail if:
[EOVERFLOW]
[CX]
The processor time used cannot be represented in an object of type clock_t.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
In programming environments where clock_t is a 32-bit integer type and CLOCKS_PER_SEC is one million, clock() will
start failing in less than 36 minutes of processor time for signed clock_t, or 72 minutes for unsigned clock_t.
Applications intended to be portable to such environments should use times() instead
(or clock_gettime() with CLOCK_PROCESS_CPUTIME_ID, if supported).
In order to measure the time spent in a program, clock() should be called at the start of the program and its return
value subtracted from the value returned by subsequent calls. The value returned by clock() is defined for compatibility
across systems that have clocks with different resolutions. The resolution on any particular system need not be to microsecond
accuracy.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
asctime(), clock_getres()
, ctime(), difftime(), futimens(), gmtime(), localtime(), mktime(), strftime(), strptime(), time(), times()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 7
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0067 [686] is applied.
Issue 8
Austin Group Defect 703 is applied, adding the [EOVERFLOW] error.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_cond_init.html =====
pthread_cond_destroy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_cond_destroy, pthread_cond_init — destroy and initialize condition variables
SYNOPSIS
#include
int pthread_cond_destroy(pthread_cond_t *cond);
int pthread_cond_init(pthread_cond_t *restrict cond,
const pthread_condattr_t *restrict attr);
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
DESCRIPTION
The pthread_cond_destroy() function shall destroy the given condition variable specified by cond; the object
becomes, in effect, uninitialized. An implementation may cause pthread_cond_destroy() to set the object referenced by
cond to an invalid value. A destroyed condition variable object can be reinitialized using pthread_cond_init(); the
results of otherwise referencing the object after it has been destroyed are undefined.
It shall be safe to destroy an initialized condition variable upon which no threads are currently blocked. Attempting to destroy
a condition variable upon which other threads are currently blocked results in undefined behavior.
The pthread_cond_init() function shall initialize the condition variable referenced by cond with attributes
referenced by attr. If attr is NULL, the default condition variable attributes shall be used; the effect is the same
as passing the address of a default condition variable attributes object. Upon successful initialization, the state of the
condition variable shall become initialized.
See 2.9.9 Synchronization Object Copies and Alternative Mappings
for further requirements.
Attempting to initialize an already initialized condition variable results in undefined behavior.
In cases where default condition variable attributes are appropriate, the macro PTHREAD_COND_INITIALIZER can be used to
initialize condition variables. The effect shall be equivalent to dynamic initialization by a call to pthread_cond_init()
with parameter attr specified as NULL, except that no error checks are performed.
The behavior is undefined if the value specified by the cond argument to pthread_cond_destroy() does not refer to
an initialized condition variable.
The behavior is undefined if the value specified by the attr argument to pthread_cond_init() does not refer to an
initialized condition variable attributes object.
RETURN VALUE
If successful, the pthread_cond_destroy() and pthread_cond_init() functions shall return zero; otherwise, an error
number shall be returned to indicate the error.
ERRORS
The pthread_cond_init() function shall fail if:
[EAGAIN]
The system lacked the necessary resources (other than memory) to initialize another condition variable.
[ENOMEM]
Insufficient memory exists to initialize the condition variable.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
A condition variable can be destroyed immediately after all the threads that are blocked on it are awakened. For example,
consider the following code:
struct list {
pthread_mutex_t lm;
...
}
struct elt {
key k;
int busy;
pthread_cond_t notbusy;
...
}
/* Find a list element and reserve it. */
struct elt *
list_find(struct list *lp, key k)
{
struct elt *ep;
pthread_mutex_lock(&lp->lm);
while ((ep = find_elt(l, k) != NULL) && ep->busy)
pthread_cond_wait(&ep->notbusy, &lp->lm);
if (ep != NULL)
ep->busy = 1;
pthread_mutex_unlock(&lp->lm);
return(ep);
}
delete_elt(struct list *lp, struct elt *ep)
{
pthread_mutex_lock(&lp->lm);
assert(ep->busy);
... remove ep from list ...
ep->busy = 0;  /* Paranoid. */
(A) pthread_cond_broadcast(&ep->notbusy);
pthread_mutex_unlock(&lp->lm);
(B) pthread_cond_destroy(&ep->notbusy);
free(ep);
}
In this example, the condition variable and its list element may be freed (line B) immediately after all threads waiting for it
are awakened (line A), since the mutex and the code ensure that no other thread can touch the element to be deleted.
APPLICATION USAGE
None.
RATIONALE
If an implementation detects that the value specified by the cond argument to pthread_cond_destroy() does not
refer to an initialized condition variable, it is recommended that the function should fail and report an [EINVAL] error.
If an implementation detects that the value specified by the cond argument to pthread_cond_destroy() or
pthread_cond_init() refers to a condition variable that is in use (for example, in a pthread_cond_wait() call) by another thread, or detects that the value specified
by the cond argument to pthread_cond_init() refers to an already initialized condition variable, it is recommended
that the function should fail and report an [EBUSY] error.
If an implementation detects that the value specified by the attr argument to pthread_cond_init() does not refer
to an initialized condition variable attributes object, it is recommended that the function should fail and report an [EINVAL]
error.
See also pthread_mutex_destroy().
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_cond_broadcast(), pthread_cond_clockwait(), pthread_mutex_destroy()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_cond_destroy() and pthread_cond_init() functions are marked as part of the Threads option.
IEEE PASC Interpretation 1003.1c #34 is applied, updating the DESCRIPTION.
The restrict keyword is added to the pthread_cond_init() prototype for alignment with the ISO/IEC 9899:1999
standard.
Issue 7
The pthread_cond_destroy() and pthread_cond_init() functions are moved from the Threads option to the Base.
The [EINVAL] error for an uninitialized condition variable and an uninitialized condition variable attributes object is removed;
this condition results in undefined behavior.
The [EBUSY] error for a condition variable already in use or an already initialized condition variable is removed; this
condition results in undefined behavior.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0455 [70] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0269 [972] and XSH/TC2-2008/0270 [910] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strndup.html =====
strdup
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strdup, strndup — duplicate a specific number of bytes from a string
SYNOPSIS
[CX]  #include
char *strdup(const char *s);
char *strndup(const char *s, size_t size);
DESCRIPTION
The strdup() function shall return a pointer to a new string, which is a duplicate of the string pointed to by s.
The returned pointer can be passed to free(). A null pointer is returned if the new
string cannot be created.
The strndup() function shall be equivalent to the strdup() function, duplicating the provided s in a new
block of memory allocated as if by using malloc(), with the exception being that
strndup() copies at most size bytes from the array s into the newly allocated memory, terminating the new
string with a null byte. If s contains a null terminator within the first size bytes, all bytes in s up to and
including the null terminator shall be copied into the new memory buffer. The strndup() function shall not examine more than
size bytes of the array pointed to by s. The newly created string shall always be properly terminated.
RETURN VALUE
The strdup() function shall return a pointer to a new string on success. Otherwise, it shall return a null pointer and
set errno to indicate the error.
Upon successful completion, the strndup() function shall return a pointer to the newly allocated memory containing the
duplicated string. Otherwise, it shall return a null pointer and set errno to indicate the error.
ERRORS
These functions shall fail if:
[ENOMEM]
Storage space available is insufficient.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
For functions that allocate memory as if by malloc(), the application should
release such memory when it is no longer required by a call to free(). For
strdup() and strndup(), this is the return value.
Implementations are free to malloc() a buffer containing either (size + 1)
bytes or (strnlen( s, size) + 1) bytes. Applications should not assume that strndup() will allocate
(size + 1) bytes when strlen( s) is smaller than size.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
free(), wcsdup()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 7
Austin Group Interpretation 1003.1-2001 #044 is applied, changing the "may fail" [ENOMEM] error to become a "shall fail"
error.
The strdup() function is moved from the XSI option to the Base.
The strndup() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 1.
The APPLICATION USAGE section is updated to clarify that memory is allocated as if by malloc().
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0338 [738] is applied.
Issue 8
Austin Group Defect 1019 is applied, clarifying that the strndup() argument s need not point to a null-terminated
string.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/cacos.html =====
cacos
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cacos, cacosf, cacosl — complex arc cosine functions
SYNOPSIS
#include
double complex cacos(double complex z);
float complex cacosf(float complex z);
long double complex cacosl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex arc cosine of z, with branch cuts outside the interval [-1, +1] along the
real axis.
RETURN VALUE
These functions shall return the complex arc cosine value, in the range of a strip mathematically unbounded along the imaginary
axis and in the interval [0, ℼ] along the real axis.
[MXC]
cacos(conj(z)), cacosf(conjf(z)), and cacosl(conjl(z)) shall return
exactly the same value as conj(cacos(z)), conjf(cacosf(z)), and
conjl(cacosl(z)), respectively, including for the special values of z below.
If z is ±0 + i0, ℼ/2 - i0 shall be returned.
If z is ±0 + iNaN, ℼ/2 + iNaN shall be returned.
If z is x + iInf where x is finite, ℼ/2 - iInf shall be returned.
If z is x + iNaN where x is non-zero and finite, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is -Inf + iy where y is positive-signed and finite, ℼ - iInf shall be returned.
If z is +Inf + iy where y is positive-signed and finite, +0 - iInf shall be returned.
If z is -Inf + iInf, 3ℼ/4 - iInf shall be returned.
If z is +Inf + iInf, ℼ/4 - iInf shall be returned.
If z is ±Inf + iNaN, NaN ± iInf shall be returned; the sign of the imaginary part of the result is
unspecified.
If z is NaN + iy where y is finite, NaN + iNaN shall be returned and the invalid floating-point
exception may be raised.
If z is NaN + iInf, NaN - iInf shall be returned.
If z is NaN + iNaN, NaN - iNaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
ccos()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/dlsym.html =====
dlsym
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
dlsym — get the address of a symbol from a symbol table handle
SYNOPSIS
#include
void *dlsym(void *restrict handle, const char *restrict name);
DESCRIPTION
The dlsym() function shall obtain the address of a symbol (a function identifier or a data object identifier) defined in
the symbol table identified by the handle argument. The handle argument is a symbol table handle returned from a call
to dlopen() (and which has not since been released by a call to dlclose()), and name is the symbol's name as a character string. The return value
from dlsym(), converted from type pointer to void to a pointer to the type of the named symbol, can be used to call
(in the case of a function) or access the contents of (in the case of a data object) the named symbol.
The dlsym() function shall search for the named symbol in the symbol table referenced by handle. If the symbol
table was created with lazy loading (see RTLD_LAZY in dlopen()), load ordering shall
be used in dlsym() operations to relocate executable object files needed to resolve the symbol. The symbol resolution
algorithm used shall be dependency order as described in dlopen().
The RTLD_DEFAULT and RTLD_NEXT symbolic constants (which may be defined in ) are reserved for future use as special values that applications may be
allowed to use for handle.
RETURN VALUE
Upon successful completion, if name names a function identifier, dlsym() shall return the address of the function
converted from type pointer to function to type pointer to void; otherwise, dlsym() shall return the address of the
data object associated with the data object identifier named by name converted from a pointer to the type of the data object
to a pointer to void. If handle does not refer to a valid symbol table handle or if the symbol named by name
cannot be found in the symbol table associated with handle, dlsym() shall return a null pointer.
More detailed diagnostic information shall be available through dlerror().
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
The following example shows how dlopen() and dlsym() can be used to access
either a function or a data object. For simplicity, error checking has been omitted.
void *handle;
int (*fptr)(int), *iptr, result;
/* open the needed symbol table */
handle = dlopen("/usr/home/me/libfoo.so", RTLD_LOCAL | RTLD_LAZY);
/* find the address of the function my_function */
fptr = (int (*)(int))dlsym(handle, "my_function");
/* find the address of the data object my_object */
iptr = (int *)dlsym(handle, "my_OBJ");
/* invoke my_function, passing the value of my_OBJ as the parameter */
result = (*fptr)(*iptr);
APPLICATION USAGE
The following special purpose values for handle are reserved for future use and have the indicated meanings:
RTLD_DEFAULT
The identifier lookup happens in the normal global scope; that is, a search for an identifier using handle would find
the same definition as a direct use of this identifier in the program code.
RTLD_NEXT
Specifies the next executable object file after this one that defines name. This one refers to the executable object
file containing the invocation of dlsym(). The next executable object file is the one found upon the application of a load
order symbol resolution algorithm (see dlopen()). The next symbol is either one of
global scope (because it was introduced as part of the original process image or because it was added with a dlopen() operation including the RTLD_GLOBAL flag), or is in an executable object file that
was included in the same dlopen() operation that loaded this one.
The RTLD_NEXT flag is useful to navigate an intentionally created hierarchy of multiply-defined symbols created through
interposition. For example, if a program wished to create an implementation of malloc() that embedded some statistics gathering about memory allocations, such an
implementation could use the real malloc() definition to perform the memory
allocation — and itself only embed the necessary logic to implement the statistics gathering function.
Note that conversion from a void * pointer to a function pointer as in:
fptr = (int (*)(int))dlsym(handle, "my_function");
is not defined by the ISO C standard. This standard requires this conversion to work correctly on conforming
implementations.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
dladdr(), dlclose(), dlerror(), dlopen()
XBD
CHANGE HISTORY
First released in Issue 5.
Issue 6
The restrict keyword is added to the dlsym() prototype for alignment with the ISO/IEC 9899:1999 standard.
The RTLD_DEFAULT and RTLD_NEXT flags are reserved for future use.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/14 is applied, correcting an example, and adding text to the
RATIONALE describing issues related to conversion of pointers to functions and back again.
Issue 7
The dlsym() function is moved from the XSI option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0074 [74] is applied.
Issue 8
Austin Group Defect 993 is applied, adding dladdr() to the SEE ALSO section.
Austin Group Defect 1644 is applied, clarifying that the return value from dlsym() can be converted from type pointer to
void to a pointer to the type of the named symbol using any valid conversion method, not just casting.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strtof.html =====
strtod
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strtod, strtof, strtold — convert a string to a double-precision number
SYNOPSIS
#include
double strtod(const char *restrict nptr, char **restrict endptr);
float strtof(const char *restrict nptr, char **restrict endptr);
long double strtold(const char *restrict nptr, char **restrict endptr);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall convert the initial portion of the string pointed to by nptr to double, float, and
long double representation, respectively. First, they decompose the input string into three parts:
An initial, possibly empty, sequence of white-space bytes
A subject sequence interpreted as a floating-point constant or representing infinity or NaN
A final string of one or more unrecognized characters, including the terminating NUL character of the input string
Then they shall attempt to convert the subject sequence to a floating-point number, and return the result.
The expected form of the subject sequence is an optional '+' or '-' sign, then one of the following:
A non-empty sequence of decimal digits optionally containing a radix character; then an optional exponent part consisting of the
character 'e' or the character 'E', optionally followed by a '+' or '-' character, and then
followed by one or more decimal digits
A 0x or 0X, then a non-empty sequence of hexadecimal digits optionally containing a radix character; then an optional binary
exponent part consisting of the character 'p' or the character 'P', optionally followed by a '+' or
'-' character, and then followed by one or more decimal digits
One of INF or INFINITY, ignoring case
One of NAN or NAN(n-char-sequenceopt), ignoring case in the NAN part, where:
n-char-sequence:
digit
nondigit
n-char-sequence digit
n-char-sequence nondigit
The subject sequence is defined as the longest initial subsequence of the input string, starting with the first non-white-space
byte, that is of the expected form. The subject sequence contains no characters if the input string is not of the expected
form.
If the subject sequence has the expected form for a floating-point number, the sequence of characters starting with the first
digit or the decimal-point character (whichever occurs first) shall be interpreted as a floating constant of the C language, except
that the radix character shall be used in place of a period, and that if neither an exponent part nor a radix character appears in
a decimal floating-point number, or if a binary exponent part does not appear in a hexadecimal floating-point number, an exponent
part of the appropriate type with value zero is assumed to follow the last digit in the string. If the subject sequence begins with
a , the sequence shall be interpreted as negated. A character sequence INF or INFINITY shall be interpreted as
an infinity, if representable in the return type, else as if it were a floating constant that is too large for the range of the
return type. A character sequence NAN or NAN(n-char-sequenceopt) shall be interpreted as a quiet
NaN, if supported in the return type, else as if it were a subject sequence part that does not have the expected form; the meaning
of the n-char sequences is implementation-defined. A pointer to the final string is stored in the object pointed to by
endptr, provided that endptr is not a null pointer.
If the subject sequence has the hexadecimal form and FLT_RADIX is a power of 2, the value resulting from the conversion is
correctly rounded.
[CX]  The
radix character is defined in the current locale (category LC_NUMERIC ). In the POSIX locale, or in a locale where the radix
character is not defined, the radix character shall default to a  ('.').
In other than the C [CX]   or POSIX  locale, additional
locale-specific subject sequence forms may be accepted.
If the subject sequence is empty or does not have the expected form, no conversion shall be performed; the value of nptr
is stored in the object pointed to by endptr, provided that endptr is not a null pointer.
These functions shall not change the setting of errno if successful.
Since 0 is returned on error and is also a valid return on success, an application wishing to check for error situations should
set errno to 0, then call strtod(), strtof(), or strtold(), then check errno.
RETURN VALUE
Upon successful completion, these functions shall return the converted value. If no conversion could be performed, 0 shall be
returned, and errno may be set to [EINVAL].
If the correct value would cause an overflow and default rounding is in effect, ±HUGE_VAL, ±HUGE_VALF, or ±HUGE_VALL shall be
returned (according to the sign of the value), and errno shall be set to [ERANGE].
If the correct value would cause an underflow, a value whose magnitude is no greater than the smallest normalized positive
number in the return type shall be returned [CX]   and errno set to [ERANGE].
ERRORS
These functions shall fail if:
[ERANGE]
The value to be returned would cause overflow and default rounding is in effect [CX]   or the value
to be returned would cause underflow.
These functions may fail if:
[EINVAL]
[CX]  No
conversion could be performed.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
If the subject sequence has the hexadecimal form and FLT_RADIX is not a power of 2, and the result is not exactly representable,
the result should be one of the two numbers in the appropriate internal format that are adjacent to the hexadecimal floating source
value, with the extra stipulation that the error should have a correct sign for the current rounding direction.
If the subject sequence has the decimal form and at most DECIMAL_DIG (defined in ) significant digits, the result should be correctly rounded. If the subject
sequence D has the decimal form and more than DECIMAL_DIG significant digits, consider the two bounding, adjacent decimal
strings L and U, both having DECIMAL_DIG significant digits, such that the values of L, D, and U
satisfy L ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate that errno is not changed if the function is successful.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the RETURN VALUE and ERRORS sections, the [EINVAL] optional error condition is added if no conversion could be performed.
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The strtod() function is updated.
The strtof() and strtold() functions are added.
The DESCRIPTION is extensively revised.
ISO/IEC 9899:1999 standard, Technical Corrigendum 1 is incorporated.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/61 is applied, correcting the second paragraph in the RETURN
VALUE section. This change clarifies the sign of the return value.
Issue 7
Austin Group Interpretation 1003.1-2001 #015 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0610 [302], XSH/TC1-2008/0611 [94], and XSH/TC1-2008/0612 [105] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0348 [584] and XSH/TC2-2008/0349 [796] are applied.
Issue 8
Austin Group Defect 1163 is applied, clarifying the handling of white space in the input string.
Austin Group Defect 1213 is applied, correcting some typographic errors in the APPLICATION USAGE section.
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1686 is applied, adding CX shading to some text in the RETURN VALUE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/cacosh.html =====
cacosh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cacosh, cacoshf, cacoshl — complex arc hyperbolic cosine functions
SYNOPSIS
#include
double complex cacosh(double complex z);
float complex cacoshf(float complex z);
long double complex cacoshl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex arc hyperbolic cosine of z, with a branch cut at values less than 1 along the
real axis.
RETURN VALUE
These functions shall return the complex arc hyperbolic cosine value, in the range of a half-strip of non-negative values along
the real axis and in the interval [-iℼ, +iℼ] along the imaginary axis.
[MXC]
cacosh(conj(z)), cacoshf(conjf(z)), and cacoshl(conjl(z)) shall
return exactly the same value as conj(cacosh(z)), conjf(cacoshf(z)), and
conjl(cacoshl(z)), respectively, including for the special values of z below.
If z is ±0 + i0, +0 + iℼ/2 shall be returned.
If z is x + iInf where x is finite, +Inf + iℼ/2 shall be returned.
If z is 0 + iNaN, NaN ± iℼ/2 shall be returned; the sign of the imaginary part of the result is
unspecified.
If z is x + iNaN where x is non-zero and finite, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is -Inf + iy where y is positive-signed and finite, +Inf + iℼ shall be returned.
If z is +Inf + iy where y is positive-signed and finite, +Inf + i0 shall be returned.
If z is -Inf + iInf, +Inf + i3ℼ/4 shall be returned.
If z is +Inf + iInf, +Inf + iℼ/4 shall be returned.
If z is ±Inf + iNaN, +Inf + iNaN shall be returned.
If z is NaN + iy where y is finite, NaN + iNaN shall be returned and the invalid floating-point
exception may be raised.
If z is NaN + iInf, +Inf + iNaN shall be returned.
If z is NaN + iNaN, NaN + iNaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
ccosh()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fputws.html =====
fputws
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fputws — put a wide-character string on a stream
SYNOPSIS
#include
#include
int fputws(const wchar_t *restrict ws, FILE *restrict stream);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The fputws() function shall write a character string corresponding to the (null-terminated) wide-character string pointed
to by ws to the stream pointed to by stream. No character corresponding to the terminating null wide-character code
shall be written.
[CX]  The
last data modification and last file status change timestamps of the file shall be marked for update between the successful
execution of fputws() and the next successful completion of a call to fflush()
or fclose() on the same stream or a call to exit() or abort().
RETURN VALUE
Upon successful completion, fputws() shall return a non-negative number. Otherwise, it shall return -1, set an error
indicator for the stream, [CX]   and set errno to indicate the error.
ERRORS
Refer to fputwc().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The fputws() function does not append a .
This volume of POSIX.1-2024 requires that successful completion simply return a non-negative integer. There are at least three
known different implementation conventions for this requirement:
Return a constant value.
Return the last character written.
Return the number of bytes written. Note that this implementation convention cannot be adhered to for strings longer than
{INT_MAX} bytes as the value would not be representable in the return type of the function. For backwards-compatibility,
implementations can return the number of bytes for strings of up to {INT_MAX} bytes, and return {INT_MAX} for all longer
strings.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fopen()
XBD ,
CHANGE HISTORY
First released in Issue 4. Derived from the MSE working draft.
Issue 5
The Optional Header (OH) marking is removed from .
Issue 6
Extensions beyond the ISO C standard are marked.
The fputws() prototype is updated for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0176 [412] and XSH/TC1-2008/0177 [14] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/symlink.html =====
symlink
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
symlink, symlinkat — make a symbolic link
SYNOPSIS
#include
int symlink(const char *path1, const char *path2);
[OH] #include
int symlinkat(const char *path1, int fd, const char *path2);
DESCRIPTION
The symlink() function shall create a symbolic link called path2 that contains the string pointed to by
path1 (path2 is the name of the symbolic link created, path1 is the string contained in the symbolic
link).
The string pointed to by path1 shall be treated only as a string and shall not be validated as a pathname.
If the symlink() function fails for any reason other than [EIO], any file named by path2 shall be unaffected.
If path2 names a symbolic link, symlink() shall fail and set errno to [EEXIST].
The symbolic link's user ID shall be set to the process' effective user ID. The symbolic link's group ID shall be set to the
group ID of the parent directory or to the effective group ID of the process. Implementations shall provide a way to initialize the
symbolic link's group ID to the group ID of the parent directory. Implementations may, but need not, provide an
implementation-defined way to initialize the symbolic link's group ID to the effective group ID of the calling process.
The values of the file mode bits for the created symbolic link are unspecified. All interfaces specified by POSIX.1-2024 shall
behave as if the contents of symbolic links can always be read, except that the value of the file mode bits returned in the
st_mode field of the stat structure is unspecified.
Upon successful completion, symlink() shall mark for update the last data access, last data modification, and last file
status change timestamps of the symbolic link. Also, the last data modification and last file status change timestamps of the
directory that contains the new entry shall be marked for update.
The symlinkat() function shall be equivalent to the symlink() function except in the case where path2
specifies a relative path. In this case the symbolic link is created relative to the directory associated with the file descriptor
fd instead of the current working directory. If the access mode of the open file description associated with the file
descriptor is not O_SEARCH, the function shall check whether directory searches are permitted using the current permissions of the
directory underlying the file descriptor. If the access mode is O_SEARCH, the function shall not perform the check.
If symlinkat() is passed the special value AT_FDCWD in the fd parameter, the current working directory shall be
used and the behavior shall be identical to a call to symlink().
RETURN VALUE
Upon successful completion, these functions shall return 0. Otherwise, these functions shall return -1 and set errno to
indicate the error.
ERRORS
These functions shall fail if:
[EACCES]
Write permission is denied in the directory where the symbolic link is being created, or search permission is denied for a
component of the path prefix of path2.
[EEXIST]
The path2 argument names an existing file.
[EILSEQ]
The last pathname component of path2 is not a portable filename, and cannot be created in the target directory.
[EIO]
An I/O error occurs while reading from or writing to the file system.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path2 argument.
[ENAMETOOLONG]
The length of a component of the pathname specified by the path2 argument is longer than {NAME_MAX} or the length of the
path1 argument is longer than {SYMLINK_MAX}.
[ENOENT]
A component of the path prefix of path2 does not name an existing file or path2 is an empty string.
[ENOENT] or [ENOTDIR]
The path2 argument contains at least one non- character and ends with one or more trailing
characters. If path2 without the trailing  characters would name an existing file, an [ENOENT] error shall not
occur.
[ENOSPC]
The directory in which the entry for the new symbolic link is being placed cannot be extended because no space is left on the
file system containing the directory, or the new symbolic link cannot be created because no space is left on the file system which
shall contain the link, or the file system is out of file-allocation resources.
[ENOTDIR]
A component of the path prefix of path2 names an existing file that is neither a directory nor a symbolic link to a
directory.
[EROFS]
The new symbolic link would reside on a read-only file system.
The symlinkat() function shall fail if:
[EACCES]
The access mode of the open file description associated with fd is not O_SEARCH and the permissions of the directory
underlying fd do not permit directory searches.
[EBADF]
The path2 argument does not specify an absolute path and the fd argument is neither AT_FDCWD nor a valid file
descriptor open for reading or searching.
[ENOTDIR]
The path2 argument is not an absolute path and fd is a file descriptor associated with a non-directory file.
These functions may fail if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path2 argument.
[ENAMETOOLONG]
The length of the path2 argument exceeds {PATH_MAX} or pathname resolution of a symbolic link in the path2 argument
produced an intermediate result with a length that exceeds {PATH_MAX}.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Like a hard link, a symbolic link allows a file to have multiple logical names. The presence of a hard link guarantees the
existence of a file, even after the original name has been removed. A symbolic link provides no such assurance; in fact, the file
named by the path1 argument need not exist when the link is created. A symbolic link can cross file system boundaries.
Normal permission checks are made on each component of the symbolic link pathname during its resolution.
RATIONALE
The purpose of the symlinkat() function is to create symbolic links in directories other than the current working
directory without exposure to race conditions. Any part of the path of a file could be changed in parallel to a call to
symlink(), resulting in unspecified behavior. By opening a file descriptor for the target directory and using the
symlinkat() function it can be guaranteed that the created symbolic link is located relative to the desired directory.
Implementations are encouraged to have symlink() and symlinkat() report an [EILSEQ] error if the last component of
path2 contains any bytes that have the encoded value of a  character.
FUTURE DIRECTIONS
None.
SEE ALSO
fdopendir(), fstatat(),
lchown(), link(), open(), readlink(), rename(), unlink()
XBD ,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The following changes were made to align with the IEEE P1003.1a draft standard:
The DESCRIPTION text is updated.
The [ELOOP] optional error condition is added.
Issue 7
Austin Group Interpretation 1003.1-2001 #143 is applied.
The symlinkat() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 2.
Additions have been made describing how symlink() sets the user and group IDs and file mode of the symbolic link, and its
effect on timestamps.
Changes are made to allow a directory to be opened for searching.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0627 [146,428], XSH/TC1-2008/0628 [461], XSH/TC1-2008/0629 [146,428],
XSH/TC1-2008/0630 [146,428,436], XSH/TC1-2008/0631 [324], XSH/TC1-2008/0632 [278], XSH/TC1-2008/0633 [278], and XSH/TC1-2008/0634
[151] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0357 [873], XSH/TC2-2008/0358 [591], XSH/TC2-2008/0359 [641],
XSH/TC2-2008/0360 [817], XSH/TC2-2008/0361 [822], XSH/TC2-2008/0362 [817], and XSH/TC2-2008/0363 [591] are applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defect 293 is applied, adding the [EILSEQ] error.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/iswgraph_l.html =====
iswgraph
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
iswgraph, iswgraph_l — test for a visible wide-character code
SYNOPSIS
#include
int iswgraph(wint_t wc);
[CX]  int iswgraph_l(wint_t wc, locale_t locale);
DESCRIPTION
For iswgraph(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The iswgraph() [CX]   and iswgraph_l()
functions shall test whether wc is a wide-character code representing a character of class graph in the current
locale, [CX]   or in the locale represented by locale,
respectively; see XBD 7. Locale.
The wc argument is a wint_t, the value of which the application shall ensure is a wide-character code
corresponding to a valid character in the locale used by the function, or equal to the value of the macro WEOF. If the argument has
any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to iswgraph_l() is the special locale object LC_GLOBAL_LOCALE or is not
a valid locale object handle.
RETURN VALUE
The iswgraph() [CX]   and iswgraph_l()
functions shall return non-zero if wc is a wide-character code with a visible representation; otherwise, they shall
return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
iswalnum(), iswalpha(),
iswcntrl(), iswctype(),
iswdigit(), iswlower(),
iswprint(), iswpunct(),
iswspace(), iswupper(),
iswxdigit(), setlocale(),
uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 4.
Issue 5
The following change has been made in this version for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E):
The SYNOPSIS has been changed to indicate that this function and associated data types are now made visible by inclusion of the
header rather than .
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The iswgraph_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0326 [302], XSH/TC1-2008/0327 [283], and XSH/TC1-2008/0328 [283] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0187 [685] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/posix_spawnattr_setsigmask.html =====
posix_spawnattr_getsigmask
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
posix_spawnattr_getsigmask, posix_spawnattr_setsigmask — get and set the spawn-sigmask attribute of a spawn attributes
object (ADVANCED REALTIME)
SYNOPSIS
[SPN]  #include
#include
int posix_spawnattr_getsigmask(const posix_spawnattr_t *restrict attr,
sigset_t *restrict sigmask);
int posix_spawnattr_setsigmask(posix_spawnattr_t *restrict attr,
const sigset_t *restrict sigmask);
DESCRIPTION
The posix_spawnattr_getsigmask() function shall obtain the value of the spawn-sigmask attribute from the
attributes object referenced by attr.
The posix_spawnattr_setsigmask() function shall set the spawn-sigmask attribute in an initialized attributes
object referenced by attr.
The spawn-sigmask attribute represents the signal mask in effect in the new process image of a spawn operation (if
POSIX_SPAWN_SETSIGMASK is set in the spawn-flags attribute). The default value of this attribute is unspecified.
RETURN VALUE
Upon successful completion, posix_spawnattr_getsigmask() shall return zero and store the value of the
spawn-sigmask attribute of attr into the object referenced by the sigmask parameter; otherwise, an error
number shall be returned to indicate the error.
Upon successful completion, posix_spawnattr_setsigmask() shall return zero; otherwise, an error number shall be returned
to indicate the error.
ERRORS
These functions may fail if:
[EINVAL]
The value specified by attr is invalid.
The posix_spawnattr_setsigmask() function may fail if:
[EINVAL]
The value of the attribute being set is not valid.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
These functions are part of the Spawn option and need not be provided on all implementations.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
posix_spawn(), posix_spawnattr_destroy(), posix_spawnattr_getsigdefault(), posix_spawnattr_getflags(), posix_spawnattr_getpgroup(), posix_spawnattr_getschedparam(), posix_spawnattr_getschedpolicy()
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1d-1999.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fread.html =====
fread
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fread — binary input
SYNOPSIS
#include
size_t fread(void *restrict ptr, size_t size, size_t nitems,
FILE *restrict stream);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The fread() function shall read into the array pointed to by ptr up to nitems elements whose size is
specified by size in bytes, from the stream pointed to by stream. For each object, size calls shall be made to
the fgetc() function and the results stored, in the order read, in an array of
unsigned char exactly overlaying the object. The file position indicator for the stream (if defined) shall be advanced by
the number of bytes successfully read. If an error occurs, the resulting value of the file position indicator for the stream is
unspecified. If a partial element is read, its value is unspecified.
[CX]  The
fread() function may mark the last data access timestamp of the file associated with stream for update. The last data
access timestamp shall be marked for update by the first successful execution of fgetc(), fgets(), fread(), fscanf(), getc(), getchar(), getdelim(), getline(), or scanf() using stream that
returns data not supplied by a prior call to ungetc().
RETURN VALUE
The fread() function shall return the number of elements successfully read, which shall be less than nitems only
if an error or end-of-file is encountered, or size is zero. If size or nitems is 0, fread() shall
return 0 and the contents of the array and the state of the stream shall remain unchanged. Otherwise, if an error occurs, the error
indicator for the stream shall be set, [CX]   and errno shall be set to indicate the error.
ERRORS
Refer to fgetc().
The following sections are informative.
EXAMPLES
Reading from a Stream
The following example transfers a single 100-byte fixed length record from the fp stream into the array pointed to by
buf.
#include
...
size_t elements_read;
char buf[100];
FILE *fp;
...
elements_read = fread(buf, sizeof(buf), 1, fp);
...
If a read error occurs, elements_read will be zero but the number of bytes read from the stream could be anything from
zero to sizeof(buf)-1.
The following example reads multiple single-byte elements from the fp stream into the array pointed to by buf.
#include
...
size_t bytes_read;
char buf[100];
FILE *fp;
...
bytes_read = fread(buf, 1, sizeof(buf), fp);
...
If a read error occurs, bytes_read will contain the number of bytes read from the stream.
APPLICATION USAGE
The ferror() or feof() functions must
be used to distinguish between an error condition and an end-of-file condition.
Because of possible differences in element length and byte ordering, files written using fwrite() are application-dependent, and possibly cannot be read using fread() by a
different application or by the same application on a different processor.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, feof(), ferror(), fgetc(), fopen(), fscanf(), getc()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
Extensions beyond the ISO C standard are marked.
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The fread() prototype is updated.
The DESCRIPTION is updated to describe how the bytes from a call to fgetc() are
stored.
Issue 7
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0178 [232] and XSH/TC1-2008/0179 [14] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0129 [926] is applied.
Issue 8
Austin Group Defect 1196 is applied, clarifying the RETURN VALUE section.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
Austin Group Defect 1624 is applied, changing the RETURN VALUE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/tss_delete.html =====
tss_delete
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
tss_delete — thread-specific data key deletion
SYNOPSIS
#include
void tss_delete(tss_t key);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The tss_delete() function shall release any resources used by the thread-specific storage identified by key. The
thread-specific data values associated with key need not be null at the time tss_delete() is called. It is the
responsibility of the application to free any application storage or perform any cleanup actions for data structures related to the
deleted key or associated thread-specific data in any threads; this cleanup can be done either before or after tss_delete()
is called.
The application shall ensure that the tss_delete() function is only called with a value for key that was returned
by a call to tss_create() before the thread commenced executing destructors.
If tss_delete() is called while another thread is executing destructors, whether this will affect the number of
invocations of the destructor associated with key on that thread is unspecified.
The tss_delete() function shall be callable from within destructor functions. Calling tss_delete() shall not
result in the invocation of any destructors. Any destructor function that was associated with key shall no longer be called
upon thread exit.
Any attempt to use key following the call to tss_delete() results in undefined behavior.
[CX]  The
tss_delete() function shall not be affected if the calling thread executes a signal handler during the call.
RETURN VALUE
This function shall not return a value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
A thread-specific data key deletion function has been included in order to allow the resources associated with an unused
thread-specific data key to be freed. Unused thread-specific data keys can arise, among other scenarios, when a dynamically loaded
module that allocated a key is unloaded.
Conforming applications are responsible for performing any cleanup actions needed for data structures associated with the key to
be deleted, including data referenced by thread-specific data values. No such cleanup is done by tss_delete(). In
particular, destructor functions are not called. See the RATIONALE for pthread_key_delete() for the reasons for this division of responsibility.
The tss_delete() function is not affected by signal handlers for the reasons stated in XRAT B.2.3 Error Numbers.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_key_delete(), tss_create()
XBD
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/bindtextdomain.html =====
bindtextdomain
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
bindtextdomain, bind_textdomain_codeset, textdomain — text domain manipulation functions
SYNOPSIS
#include
char *bindtextdomain(const char *domainname, const char *dirname);
char *bind_textdomain_codeset(const char *domainname,
const char *codeset);
char *textdomain(const char *domainname);
DESCRIPTION
The textdomain() function shall set or query the name of the current text domain of the calling process. The application
shall ensure that the domainname argument is either a null pointer (when querying), an empty string, or a string that, when
used by the gettext family of functions to construct a pathname to a messages object, results in a valid pathname. For
portable applications, it should only contain characters from the portable filename character set.
The text domain setting made by the last successful call to textdomain() shall remain in effect across subsequent calls
to setlocale(), uselocale(), and
the gettext family of functions.
Applications should not use text domains whose names begin with the strings "SYS_" or "libc". These prefixes
are reserved for implementation use.
The current setting of the text domain can be queried without affecting the current state of the domain by calling
textdomain() with domainname set to a null pointer. Calling textdomain() with a domainname argument of
an empty string shall set the text domain to the default domain, "messages".
The bindtextdomain() function shall set or query the binding of a text domain to a dirname that is used by the
gettext family of functions to construct a pathname to a messages object in the text domain:
If domainname is a null pointer or an empty string, bindtextdomain() shall make no changes and return a null
pointer without changing errno.
Otherwise, if dirname is a non-empty string:
If domainname is not already bound, bindtextdomain() shall bind the text domain specified by domainname to
the pathname pointed to by dirname and return the bound directory pathname on success or a null pointer on failure.
If domainname is already bound, bindtextdomain() shall replace the existing binding with the pathname pointed to
by dirname and return the bound directory pathname on success or a null pointer on failure. On failure, the existing binding
shall remain unchanged.
It is unspecified whether the bindtextdomain() function performs pathname resolution on dirname, or whether that
is done by the gettext family of functions.
Otherwise, if dirname is a null pointer:
If domainname is bound, the function shall return the bound directory pathname.
If domainname is not bound, the function shall return the implementation-defined default directory pathname used by the
gettext family of functions.
Otherwise, dirname is an empty string and the behavior is unspecified.
If a text domain is bound to a relative pathname and the current working directory is changed after the binding is established,
the pathnames used by the gettext family of functions to locate messages objects for that text domain are unspecified.
The bind_textdomain_codeset() function shall set or query the binding of a text domain to the output codeset used by the
gettext family of functions for message strings retrieved from messages objects for the text domain specified by
domainname:
If domainname is a null pointer or an empty string, bind_textdomain_codeset() shall make no changes and return a
null pointer without changing errno.
Otherwise, if codeset is a non-empty string:
If domainname is not already bound, bind_textdomain_codeset() shall bind the text domain specified by
domainname to the codeset pointed to by codeset and return the newly bound codeset on success or a null pointer on
failure.
If domainname is already bound, bind_textdomain_codeset() shall replace the existing binding with the codeset
pointed to by codeset and return the newly bound codeset on success or a null pointer on failure. On failure, the existing
binding shall remain unchanged.
The application shall ensure that the codeset argument, if non-empty, is a valid codeset name that can be used as the
tocode argument of the iconv_open() function, and that in the codeset it
specifies, the  character corresponds to a single null byte.
Otherwise, if codeset is a null pointer:
If domainname is bound, the function shall return the bound codeset.
If domainname is not bound, the function shall return the implementation-defined default codeset used by the
gettext family of functions.
Otherwise, codeset is an empty string and the behavior is unspecified.
If codeset is a null pointer and domainname is a non-empty string, bind_textdomain_codeset() shall return
the current codeset for the named domain, or a null pointer if a codeset has not yet been set. The bind_textdomain_codeset()
function can be called multiple times. If successfully called multiple times with the same domainname argument, the last
such call shall override the setting made by the previous such call.
RETURN VALUE
The return value from a successful textdomain() call shall be a pointer to a string containing the current setting of the
text domain. If domainname is a null pointer, textdomain() shall return a pointer to the string containing the
current text domain. If textdomain() was not previously called and domainname is a null string, the name of the
default text domain shall be returned. The name of the default text domain shall be the string "messages". If
textdomain() fails, a null pointer shall be returned and errno shall be set to indicate the error.
For bindtextdomain() return values see the DESCRIPTION. When bindtextdomain() is called with a non-empty
domainname and returns a null pointer, it shall set errno to indicate the error. When bindtextdomain() returns
a pathname for a bound text domain, the return value shall be a pointer to a copy of the dirname string passed to the
bindtextdomain() call that created the binding. The returned string shall remain valid until the next successful call to
bindtextdomain() with a non-empty dirname and same domainname. The application shall ensure that it does not
modify the returned string.
A call to the bind_textdomain_codeset() function with a non-empty domainname argument shall return one of the
following:
The currently bound codeset name for that text domain if codeset is a null pointer
The newly bound codeset if codeset is non-empty
A null pointer without changing errno if no codeset has yet been bound for that text domain
The application shall ensure that it does not modify the returned string. A subsequent call to bind_textdomain_codeset()
with a non-empty domainname argument might invalidate the returned pointer or overwrite the string content. The returned
pointer might also be invalidated if the calling thread is terminated. If bind_textdomain_codeset() fails, a null pointer
shall be returned and errno shall be set to indicate the error.
ERRORS
For the conditions under which bindtextdomain()—if it performs pathname resolution—fails and may fail, refer to open().
In addition, the textdomain(), bindtextdomain(), and bind_textdomain_codeset() functions may fail if:
[ENOMEM]
Insufficient memory available.
The following sections are informative.
EXAMPLES
See the examples for gettext().
APPLICATION USAGE
A text domainname is limited to {TEXTDOMAIN_MAX} bytes.
Application developers are responsible for ensuring that the text domain used is not used by other applications. To minimize the
chances of collision, developers can prefix text domains with their company or application name (or both) and an underscore. For
example, if your application name was "foo" and you wanted to use the text domain "errors", you could instead use
the text domain "foo_errors". Note that if an application can be installed with a configurable name, a text domain prefix
based on the application name should change with the application name.
Specifying a relative pathname to the bindtextdomain() function should be avoided, since it may result in messages
objects being searched for in a directory relative to the current working directory of the calling process; if the process calls
the chdir() function, the directory searched for may also be changed.
Since pathname resolution of dirname might not be performed by bindtextdomain(), but could be performed later by
the gettext family of functions, and since the latter have no way to report an error, applications should verify, using for
example stat(), that the directory is accessible if this is desired.
RATIONALE
Although the return type of these functions ought to be const char *, it is char * to match historical
practice.
Pathname resolution of the dirname argument passed to bindtextdomain() may be performed by bindtextdomain()
itself or by the gettext family of functions. If pathname resolution fails in one of the gettext family of functions,
it is neither allowed to modify errno nor to return an error, but if pathname resolution fails in bindtextdomain(),
it is required to report an error and set errno just like open() does.
Historically, bindtextdomain() did not perform pathname resolution. However, the standard developers decided to allow
this as an option so that future implementations can, if desired, open a file descriptor for that directory in
bindtextdomain() and then use that file descriptor with openat() in the
gettext family of functions.
The dirname parameter to bindtextdomain() may need to be copied to avoid the possibility of the application
releasing the memory used by the argument while the gettext family of functions may still need to reference it.
When bindtextdomain() is called with a non-empty domainname and an empty dirname, historical
implementations of the gettext family of functions use the empty string for the dirname part of the messages object
pathname, resulting in an absolute pathname of the form /localename/categoryname/textdomainname.mo. The
standard developers did not believe this behavior to be useful. Using the empty dirname case as a way to remove an existing
binding seemed to be a more useful behavior, and would be consistent with the behavior of textdomain(). However, because no
historical implementations behave this way, the behavior is left unspecified.
Some implementations set errno to [EAGAIN] to signal memory allocation failures that might succeed if retried and
[ENOMEM] for failures that are unlikely to ever succeed, for example due to configured limits. 2.3 Error Numbers permits this behavior; when multiple error conditions are
simultaneously true there is no precedence between them.
FUTURE DIRECTIONS
A future version of this standard may require implementations to prefix implementation-provided text domains with either
"SYS_" or a prefix related to the implementor's company name to avoid namespace collisions.
A future version of this standard may require bindtextdomain() to remove any binding for domainname when called
with a non-empty domainname and an empty dirname.
SEE ALSO
gettext(), iconv_open(), setlocale(), uselocale()
XBD ,
XCU msgfmt, xgettext
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_rwlockattr_destroy.html =====
pthread_rwlockattr_destroy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_rwlockattr_destroy, pthread_rwlockattr_init — destroy and initialize the read-write lock attributes
object
SYNOPSIS
#include
int pthread_rwlockattr_destroy(pthread_rwlockattr_t *attr);
int pthread_rwlockattr_init(pthread_rwlockattr_t *attr);
DESCRIPTION
The pthread_rwlockattr_destroy() function shall destroy a read-write lock attributes object. A destroyed attr
attributes object can be reinitialized using pthread_rwlockattr_init(); the results of otherwise referencing the object
after it has been destroyed are undefined. An implementation may cause pthread_rwlockattr_destroy() to set the object
referenced by attr to an invalid value.
The pthread_rwlockattr_init() function shall initialize a read-write lock attributes object attr with the default
value for all of the attributes defined by the implementation.
Results are undefined if pthread_rwlockattr_init() is called specifying an already initialized attr attributes
object.
After a read-write lock attributes object has been used to initialize one or more read-write locks, any function affecting the
attributes object (including destruction) shall not affect any previously initialized read-write locks.
The behavior is undefined if the value specified by the attr argument to pthread_rwlockattr_destroy() does not
refer to an initialized read-write lock attributes object.
RETURN VALUE
If successful, the pthread_rwlockattr_destroy() and pthread_rwlockattr_init() functions shall return zero;
otherwise, an error number shall be returned to indicate the error.
ERRORS
The pthread_rwlockattr_init() function shall fail if:
[ENOMEM]
Insufficient memory exists to initialize the read-write lock attributes object.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
If an implementation detects that the value specified by the attr argument to pthread_rwlockattr_destroy() does
not refer to an initialized read-write lock attributes object, it is recommended that the function should fail and report an
[EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_rwlock_destroy(), pthread_rwlockattr_getpshared()
XBD
CHANGE HISTORY
First released in Issue 5.
Issue 6
The following changes are made for alignment with IEEE Std 1003.1j-2000:
The margin code in the SYNOPSIS is changed to THR to indicate that the functionality is now part of the Threads option
(previously it was part of the Read-Write Locks option in IEEE Std 1003.1j-2000 and also part of the XSI extension).
The SEE ALSO section is updated.
Issue 7
The pthread_rwlockattr_destroy() and pthread_rwlockattr_init() functions are moved from the Threads option to the
Base.
The [EINVAL] error for an uninitialized read-write lock attributes object is removed; this condition results in undefined
behavior.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_testcancel.html =====
pthread_setcancelstate
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_setcancelstate, pthread_setcanceltype, pthread_testcancel — set cancelability state
SYNOPSIS
#include
int pthread_setcancelstate(int state, int *oldstate);
int pthread_setcanceltype(int type, int *oldtype);
void pthread_testcancel(void);
DESCRIPTION
The pthread_setcancelstate() function shall atomically both set the calling thread's cancelability state to the indicated
state and return the previous cancelability state at the location referenced by oldstate. Legal values for
state are PTHREAD_CANCEL_ENABLE and PTHREAD_CANCEL_DISABLE.
The pthread_setcanceltype() function shall atomically both set the calling thread's cancelability type to the indicated
type and return the previous cancelability type at the location referenced by oldtype. Legal values for type
are PTHREAD_CANCEL_DEFERRED and PTHREAD_CANCEL_ASYNCHRONOUS.
The cancelability state and type of any newly created threads, including the thread in which main() was first invoked,
shall be PTHREAD_CANCEL_ENABLE and PTHREAD_CANCEL_DEFERRED respectively.
The pthread_testcancel() function shall create a cancellation point in the calling thread. The
pthread_testcancel() function shall have no effect if cancelability is disabled.
The pthread_setcancelstate() function shall be async-signal-safe.
RETURN VALUE
If successful, the pthread_setcancelstate() and pthread_setcanceltype() functions shall return zero; otherwise, an
error number shall be returned to indicate the error.
ERRORS
The pthread_setcancelstate() function may fail if:
[EINVAL]
The specified state is not PTHREAD_CANCEL_ENABLE or PTHREAD_CANCEL_DISABLE.
The pthread_setcanceltype() function may fail if:
[EINVAL]
The specified type is not PTHREAD_CANCEL_DEFERRED or PTHREAD_CANCEL_ASYNCHRONOUS.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
In order to write a signal handler for an asynchronous signal which can run safely in a cancellable thread,
pthread_setcancelstate() must be used to disable cancellation for the duration of any calls that the signal handler makes
which are cancellation points. However, earlier versions of the standard did not permit strictly conforming applications to call
pthread_setcancelstate() from a signal handler since it was not required to be async-signal-safe. On non-conforming
implementations where pthread_setcancelstate() is not async-signal-safe, alternatives are to ensure either that the
corresponding signals are blocked during execution of functions that are not async-cancel-safe or that cancellation is disabled
during times when those signals could be delivered.
RATIONALE
The pthread_setcancelstate() and pthread_setcanceltype() functions control the points at which a thread may be
asynchronously canceled. For cancellation control to be usable in modular fashion, some rules need to be followed.
An object can be considered to be a generalization of a procedure. It is a set of procedures and global variables written as a
unit and called by clients not known by the object. Objects may depend on other objects.
First, cancelability should only be disabled on entry to an object, never explicitly enabled. On exit from an object, the
cancelability state should always be restored to its value on entry to the object.
This follows from a modularity argument: if the client of an object (or the client of an object that uses that object) has
disabled cancelability, it is because the client does not want to be concerned about cleaning up if the thread is canceled while
executing some sequence of actions. If an object is called in such a state and it enables cancelability and a cancellation request
is pending for that thread, then the thread is canceled, contrary to the wish of the client that disabled.
Second, the cancelability type may be explicitly set to either deferred or asynchronous upon entry to an object.
But as with the cancelability state, on exit from an object the cancelability type should always be restored to its value on entry
to the object.
Finally, only functions that are cancel-safe may be called from a thread that is asynchronously cancelable.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_cancel()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_setcancelstate(), pthread_setcanceltype(), and pthread_testcancel() functions are marked as
part of the Threads option.
Issue 7
The pthread_setcancelstate(), pthread_setcanceltype(), and pthread_testcancel() functions are moved from
the Threads option to the Base.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0294 [622] and XSH/TC2-2008/0295 [615] are applied.
Issue 8
Austin Group Defect 841 is applied, requiring pthread_setcancelstate() to be async-signal-safe.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/putwchar.html =====
putwchar
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
putwchar — put a wide character on a stdout stream
SYNOPSIS
#include
wint_t putwchar(wchar_t wc);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The function call putwchar(wc) shall be equivalent to putwc(wc,stdout).
RETURN VALUE
Refer to fputwc().
ERRORS
Refer to fputwc().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fputwc(), putwc()
XBD
CHANGE HISTORY
First released in Issue 4.
Issue 5
Aligned with ISO/IEC 9899:1990/Amendment 1:1995 (E). Specifically, the type of argument wc is changed from
wint_t to wchar_t.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0479 [14] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_barrierattr_init.html =====
pthread_barrierattr_destroy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_barrierattr_destroy, pthread_barrierattr_init — destroy and initialize the barrier attributes
object
SYNOPSIS
#include
int pthread_barrierattr_destroy(pthread_barrierattr_t *attr);
int pthread_barrierattr_init(pthread_barrierattr_t *attr);
DESCRIPTION
The pthread_barrierattr_destroy() function shall destroy a barrier attributes object. A destroyed attr attributes
object can be reinitialized using pthread_barrierattr_init(); the results of otherwise referencing the object after it has
been destroyed are undefined. An implementation may cause pthread_barrierattr_destroy() to set the object referenced by
attr to an invalid value.
The pthread_barrierattr_init() function shall initialize a barrier attributes object attr with the default value
for all of the attributes defined by the implementation.
If pthread_barrierattr_init() is called specifying an already initialized attr attributes object, the results are
undefined.
After a barrier attributes object has been used to initialize one or more barriers, any function affecting the attributes object
(including destruction) shall not affect any previously initialized barrier.
The behavior is undefined if the value specified by the attr argument to pthread_barrierattr_destroy() does not
refer to an initialized barrier attributes object.
RETURN VALUE
If successful, the pthread_barrierattr_destroy() and pthread_barrierattr_init() functions shall return zero;
otherwise, an error number shall be returned to indicate the error.
ERRORS
The pthread_barrierattr_init() function shall fail if:
[ENOMEM]
Insufficient memory exists to initialize the barrier attributes object.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
If an implementation detects that the value specified by the attr argument to pthread_barrierattr_destroy() does
not refer to an initialized barrier attributes object, it is recommended that the function should fail and report an [EINVAL]
error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_barrierattr_getpshared()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1j-2000.
In the SYNOPSIS, the inclusion of  is no longer
required.
Issue 7
The pthread_barrierattr_destroy() and pthread_barrierattr_init() functions are moved from the Barriers option to
the Base.
The [EINVAL] error for an uninitialized barrier attributes object is removed; this condition results in undefined behavior.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/iswspace.html =====
iswspace
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
iswspace, iswspace_l — test for a white-space wide-character code
SYNOPSIS
#include
int iswspace(wint_t wc);
[CX]  int iswspace_l(wint_t wc, locale_t locale);
DESCRIPTION
For iswspace(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The iswspace() [CX]   and iswspace_l()
functions shall test whether wc is a wide-character code representing a character of class space in the current
locale, [CX]   or in the locale represented by locale,
respectively; see XBD 7. Locale.
The wc argument is a wint_t, the value of which the application shall ensure is a wide-character code
corresponding to a valid character in the locale used by the function, or equal to the value of the macro WEOF. If the argument has
any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to iswspace_l() is the special locale object LC_GLOBAL_LOCALE or is not
a valid locale object handle.
RETURN VALUE
The iswspace() [CX]   and iswspace_l()
functions shall return non-zero if wc is a white-space wide-character code; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
iswalnum(), iswalpha(),
iswcntrl(), iswctype(),
iswdigit(), iswgraph(),
iswlower(), iswprint(),
iswpunct(), iswupper(),
iswxdigit(), setlocale(),
uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 4.
Issue 5
The following change has been made in this version for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E):
The SYNOPSIS has been changed to indicate that this function and associated data types are now made visible by inclusion of the
header rather than .
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The iswspace_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0338 [302], XSH/TC1-2008/0339 [283], and XSH/TC1-2008/0340 [283] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0191 [685] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/if_indextoname.html =====
if_indextoname
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
if_indextoname — map a network interface index to its corresponding name
SYNOPSIS
#include
char *if_indextoname(unsigned ifindex, char *ifname);
DESCRIPTION
The if_indextoname() function shall map an interface index to its corresponding name.
When this function is called, ifname shall point to a buffer of at least {IF_NAMESIZE} bytes. The function shall place in
this buffer the name of the interface with index ifindex.
RETURN VALUE
If ifindex is an interface index, then the function shall return the value supplied in ifname, which points to a
buffer now containing the interface name. Otherwise, the function shall return a null pointer and set errno to indicate the
error.
ERRORS
The if_indextoname() function shall fail if:
[ENXIO]
The interface does not exist.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
getsockopt(), if_freenameindex(), if_nameindex(), if_nametoindex(), setsockopt()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/28 is applied, changing {IFNAMSIZ} to {IF_NAMESIZ} in the
DESCRIPTION.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mq_notify.html =====
mq_notify
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mq_notify — notify process that a message is available (REALTIME)
SYNOPSIS
[MSG]  #include
int mq_notify(mqd_t mqdes, const struct sigevent *notification);
DESCRIPTION
If the argument notification is not NULL, this function shall register the calling process to be notified of message
arrival at an empty message queue associated with the specified message queue descriptor, mqdes. The notification specified
by the notification argument shall be sent to the process when the message queue transitions from empty to non-empty. At any
time, only one process may be registered for notification by a message queue. If the calling process or any other process has
already registered for notification of message arrival at the specified message queue, subsequent attempts to register for that
message queue shall fail.
If notification is NULL and the process is currently registered for notification by the specified message queue, the
existing registration shall be removed.
When the notification is sent to the registered process, its registration shall be removed. The message queue shall then be
available for registration.
If a process has registered for notification of message arrival at a message queue and some thread is blocked in mq_receive() or mq_timedreceive()
waiting to receive a message when a message arrives at the queue, the arriving message shall satisfy the appropriate mq_receive() or mq_timedreceive(),
respectively. The resulting behavior is as if the message queue remains empty, and no notification shall be sent.
RETURN VALUE
Upon successful completion, the mq_notify() function shall return a value of zero; otherwise, the function shall return a
value of -1 and set errno to indicate the error.
ERRORS
The mq_notify() function shall fail if:
[EBADF]
The mqdes argument is not a valid message queue descriptor.
[EBUSY]
A process is already registered for notification by the message queue.
The mq_notify() function may fail if:
[EINVAL]
The notification argument is NULL and the process is currently not registered.
The following sections are informative.
EXAMPLES
The following program registers a notification request for the message queue named in its command-line argument. Notification is
performed by creating a thread. The thread executes a function which reads one message from the queue and then terminates the
process.
#include
#include
#include
#include
#include
#include
#include
static void                     /* Thread start function */
tfunc(union sigval sv)
{
struct mq_attr attr;
ssize_t nr;
void *buf;
mqd_t mqdes = *((mqd_t *) sv.sival_ptr);
/* Determine maximum msg size; allocate buffer to receive msg */
if (mq_getattr(mqdes, &attr) == -1) {
perror("mq_getattr");
exit(EXIT_FAILURE);
}
buf = malloc(attr.mq_msgsize);
if (buf == NULL) {
perror("malloc");
exit(EXIT_FAILURE);
}
nr = mq_receive(mqdes, buf, attr.mq_msgsize, NULL);
if (nr == -1) {
perror("mq_receive");
exit(EXIT_FAILURE);
}
printf("Read %ld bytes from message queue\n", (long) nr);
free(buf);
exit(EXIT_SUCCESS);         /* Terminate the process */
}
int
main(int argc, char *argv[])
{
mqd_t mqdes;
struct sigevent not;
assert(argc == 2);
mqdes = mq_open(argv[1], O_RDONLY);
if (mqdes == (mqd_t) -1) {
perror("mq_open");
exit(EXIT_FAILURE);
}
not.sigev_notify = SIGEV_THREAD;
not.sigev_notify_function = tfunc;
not.sigev_notify_attributes = NULL;
not.sigev_value.sival_ptr = &mqdes;   /* Arg. to thread func. */
if (mq_notify(mqdes, &not) == -1) {
perror("mq_notify");
exit(EXIT_FAILURE);
}
pause();    /* Process will be terminated by thread function */
}
APPLICATION USAGE
Since the  header is only required to declare the sigevent
structure tag as naming an incomplete structure type, in order to use mq_notify() and pass it a pointer to a sigevent
structure, applications need to include  so that sigevent
will be fully defined.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
mq_open(), mq_send(), mq_receive(), msgctl(), msgget(), msgrcv(), msgsnd()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The mq_notify() function is marked as part of the Message Passing option.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Message
Passing option.
The mq_timedsend() function is added to the SEE ALSO section for alignment
with IEEE Std 1003.1d-1999.
Issue 7
SD5-XSH-ERN-38 is applied, adding the mq_timedreceive() function to the
DESCRIPTION.
Austin Group Interpretation 1003.1-2001 #032 is applied, adding the [EINVAL] error.
An example is added.
Issue 8
Austin Group Defect 1282 is applied, changing the EXAMPLES and APPLICATION USAGE sections.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sem_clockwait.html =====
sem_clockwait
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sem_clockwait, sem_timedwait — lock a semaphore
SYNOPSIS
#include
int sem_clockwait(sem_t *restrict sem, clockid_t clock_id,
const struct timespec *restrict abstime);
int sem_timedwait(sem_t *restrict sem,
const struct timespec *restrict abstime);
DESCRIPTION
The sem_clockwait() and sem_timedwait() functions shall lock the semaphore referenced by sem as in the
sem_wait() function. However, if the semaphore cannot be locked without waiting for
another process or thread to unlock the semaphore by performing a sem_post()
function, this wait shall be terminated when the specified timeout expires.
The timeout shall expire when the absolute time specified by abstime passes, as measured by the clock on which timeouts
are based (that is, when the value of that clock equals or exceeds abstime), or if the absolute time specified by
abstime has already been passed at the time of the call.
For sem_timedwait(), the timeout shall be based on the CLOCK_REALTIME clock. For sem_clockwait(), the timeout
shall be based on the clock specified by the clock_id argument. The resolution of the timeout shall be the resolution of the
clock on which it is based. Implementations shall support passing CLOCK_REALTIME and CLOCK_MONOTONIC to sem_clockwait() as
the clock_id argument.
Under no circumstance shall the function fail with a timeout if the semaphore can be locked immediately. The validity of the
abstime need not be checked if the semaphore can be locked immediately.
RETURN VALUE
The sem_clockwait() and sem_timedwait() functions shall return zero if the calling process successfully performed
the semaphore lock operation on the semaphore designated by sem. If the call was unsuccessful, the state of the semaphore
shall be unchanged, and the functions shall return a value of -1 and set errno to indicate the error.
ERRORS
The sem_clockwait() and sem_timedwait() functions shall fail if:
[EINVAL]
The process or thread would have blocked, and either the abstime parameter specified a nanoseconds field value less than
zero or greater than or equal to 1000 million, or the sem_clockwait() function was passed an invalid or unsupported
clock_id value.
[ETIMEDOUT]
The semaphore could not be locked before the specified timeout expired.
The sem_clockwait() and sem_timedwait() functions may fail if:
[EDEADLK]
A deadlock condition was detected.
[EINTR]
A signal interrupted the function.
[EINVAL]
The sem argument does not refer to a valid semaphore.
The following sections are informative.
EXAMPLES
The program shown below operates on an unnamed semaphore. The program expects two command-line arguments. The first argument
specifies a seconds value that is used to set an alarm timer to generate a SIGALRM signal. This handler performs a sem_post() to increment the semaphore that is being waited on in main() using
sem_clockwait(). The second command-line argument specifies the length of the timeout, in seconds, for
sem_clockwait().
#include
#include
#include
#include
#include
#include
#include
#include
sem_t sem;
static void
handler(int sig)
{
int sav_errno = errno;
static const char info_msg[] = "sem_post() from handler\n";
write(STDOUT_FILENO, info_msg, sizeof info_msg - 1);
if (sem_post(&sem) == -1) {
static const char err_msg[] = "sem_post() failed\n";
write(STDERR_FILENO, err_msg, sizeof err_msg - 1);
_exit(EXIT_FAILURE);
}
errno = sav_errno;
}
int
main(int argc, char *argv[])
{
struct sigaction sa;
struct timespec ts;
int s;
if (argc != 3) {
fprintf(stderr, "Usage: %s  \n",
argv[0]);
exit(EXIT_FAILURE);
}
if (sem_init(&sem, 0, 0) == -1) {
perror("sem_init");
exit(EXIT_FAILURE);
}
/* Establish SIGALRM handler; set alarm timer using argv[1] */
sa.sa_handler = handler;
sigemptyset(&sa.sa_mask);
sa.sa_flags = 0;
if (sigaction(SIGALRM, &sa, NULL) == -1) {
perror("sigaction");
exit(EXIT_FAILURE);
}
alarm(atoi(argv[1]));
/* Calculate relative interval as current time plus
number of seconds given argv[2] */
if (clock_gettime(CLOCK_MONOTONIC, &ts) == -1) {
perror("clock_gettime");
exit(EXIT_FAILURE);
}
ts.tv_sec += atoi(argv[2]);
printf("main() about to call sem_clockwait()\n");
while ((s = sem_clockwait(&sem, CLOCK_MONOTONIC, &ts)) == -1 &&
errno == EINTR)
continue;       /* Restart if interrupted by handler */
/* Check what happened */
if (s == -1) {
if (errno == ETIMEDOUT)
printf("sem_clockwait() timed out\n");
else
perror("sem_clockwait");
} else
printf("sem_clockwait() succeeded\n");
exit((s == 0) ? EXIT_SUCCESS : EXIT_FAILURE);
}
APPLICATION USAGE
Applications using these functions may be subject to priority inversion, as discussed in XBD 3.275 Priority Inversion.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
sem_post(), sem_trywait()
, semctl(), semget(), semop(), time()
XBD 3.275 Priority Inversion, ,
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1d-1999.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/120 is applied, updating the ERRORS section so that the [EINVAL]
error becomes optional.
Issue 7
The sem_timedwait() function is moved from the Semaphores option to the Base.
Functionality relating to the Timers option is moved to the Base.
An example is added.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0529 [138] is applied.
Issue 8
Austin Group Defect 592 is applied, removing text relating to  from
the SYNOPSIS and DESCRIPTION sections.
Austin Group Defect 1216 is applied, adding sem_clockwait().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strncpy.html =====
strncpy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
stpncpy, strncpy — copy fixed length string, returning a pointer to the array end
SYNOPSIS
#include
[CX]  char *stpncpy(char *restrict s1, const char *restrict s2, size_t
n);
char *strncpy(char *restrict s1, const char *restrict s2, size_t
n);
DESCRIPTION
For strncpy(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The [CX]
stpncpy()   and strncpy() functions shall copy
not more than n bytes (bytes that follow a NUL character are not copied) from the array pointed to by s2 to the array
pointed to by s1.
If the array pointed to by s2 is a string that is shorter than n bytes, NUL characters shall be appended to the
copy in the array pointed to by s1, until n bytes in all are written.
If copying takes place between objects that overlap, the behavior is undefined.
[CX]  The
strncpy() and stpncpy() functions shall not change the setting of errno on valid input.
RETURN VALUE
[CX]  If
a NUL character is written to the destination, the stpncpy() function shall return the address of the first such NUL
character. Otherwise, it shall return &s1[n].
The strncpy() function shall return s1.
No return values are reserved to indicate an error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications must provide the space in s1 for the n bytes to be transferred, as well as ensure that the s2
and s1 arrays do not overlap.
Character movement is performed differently in different implementations. Thus, overlapping moves may yield surprises.
If there is no NUL character byte in the first n bytes of the array pointed to by s2, the result is not
null-terminated.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
strcpy(), strlcat(), wcsncpy()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The strncpy() prototype is updated for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
The stpncpy() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 1.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that strncpy() and stpncpy() do not change the setting of
errno on valid input.
Austin Group Defect 986 is applied, adding strlcat() to the SEE ALSO section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ccosf.html =====
ccos
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ccos, ccosf, ccosl — complex cosine functions
SYNOPSIS
#include
double complex ccos(double complex z);
float complex ccosf(float complex z);
long double complex ccosl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex cosine of z.
RETURN VALUE
These functions shall return the complex cosine value.
[MXC]
ccos(conj(iz)), ccosf(conjf(iz)), and ccosl(conjl(iz)) shall return
exactly the same value as conj(ccos(iz)), conjf(ccosf(iz)), and
conjl(ccosl(iz)), respectively, and ccos(-iz), ccosf(-iz), and
ccosl(-iz) shall return exactly the same value as ccos(iz), ccosf(iz), and
ccosl(iz), respectively, including for the special values of iz below.
If iz is +0 + i0, 1 + i0 shall be returned.
If iz is +0 + iInf, NaN ± i0 shall be returned and the invalid floating-point exception shall be raised;
the sign of the imaginary part of the result is unspecified.
If iz is +0 + iNaN, NaN ± i0 shall be returned; the sign of the imaginary part of the result is
unspecified.
If iz is x + iInf where x is non-zero and finite, NaN + iNaN shall be returned and the
invalid floating-point exception shall be raised.
If iz is x + iNaN where x is non-zero and finite, NaN + iNaN shall be returned and the
invalid floating-point exception may be raised.
If iz is +Inf + i0, +Inf + i0 shall be returned.
If iz is +Inf + iy where y is non-zero and finite, +Inf (cos(y) + isin(y))
shall be returned.
If iz is +Inf + iInf, ±Inf + iNaN shall be returned and the invalid floating-point exception shall be
raised; the sign of the real part of the result is unspecified.
If iz is +Inf + iNaN, +Inf + iNaN shall be returned.
If iz is NaN + i0, NaN ± i0 shall be returned; the sign of the imaginary part of the result is
unspecified.
If iz is NaN + iy where y is any non-zero number, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If iz is NaN + iNaN, NaN + iNaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The MXC special cases for ccos() are derived from those for ccosh() by
applying the formula ccos(z) = ccosh(iz).
FUTURE DIRECTIONS
None.
SEE ALSO
ccosh(), cacos()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getgrent.html =====
endgrent
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
endgrent, getgrent, setgrent — group database entry functions
SYNOPSIS
[XSI]  #include
void endgrent(void);
struct group *getgrent(void);
void setgrent(void);
DESCRIPTION
The getgrent() function shall return a pointer to a structure containing the broken-out fields of an entry in the group
database. If the group database is not already open, getgrent() shall open it and return a pointer to a group
structure containing the first entry in the database. Thereafter, it shall return a pointer to a group structure containing
the next group structure in the group database, so successive calls may be used to search the entire database.
An implementation that provides extended security controls may impose further implementation-defined restrictions on accessing
the group database. In particular, the system may deny the existence of some or all of the group database entries associated with
groups other than those groups associated with the caller and may omit users other than the caller from the list of members of
groups in database entries that are returned.
The setgrent() function shall rewind the group database so that the next getgrent() call returns the first entry,
allowing repeated searches.
The endgrent() function shall close the group database.
The setgrent() and endgrent() functions shall not change the setting of errno if successful.
On error, the setgrent() and endgrent() functions shall set errno to indicate the error.
Since no value is returned by the setgrent() and endgrent() functions, an application wishing to check for error
situations should set errno to 0, then call the function, then check errno.
These functions need not be thread-safe.
RETURN VALUE
On successful completion, getgrent() shall return a pointer to a group structure. On end-of-file,
getgrent() shall return a null pointer and shall not change the setting of errno. On error, getgrent() shall
return a null pointer and errno shall be set to indicate the error.
The application shall not modify the structure to which the return value points, nor any storage areas pointed to by pointers
within the structure. The returned pointer, and pointers within the structure, might be invalidated or the structure or the storage
areas might be overwritten by a subsequent call to getgrgid(), getgrnam(), or getgrent(). The returned pointer, and pointers within the structure,
might also be invalidated if the calling thread is terminated.
ERRORS
These functions may fail if:
[EINTR]
A signal was caught during the operation.
[EIO]
An I/O error has occurred.
In addition, the getgrent() and setgrent() functions may fail if:
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum allowable number of files is currently open in the system.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
These functions are provided due to their historical usage. Applications should avoid dependencies on fields in the group
database, whether the database is a single file, or where in the file system name space the database resides. Applications should
use getgrnam() and getgrgid()
whenever possible because it avoids these dependencies.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
endpwent(), getgrgid(),
getgrnam(), getlogin()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Normative text previously in the APPLICATION USAGE section is moved to the RETURN VALUE section.
A note indicating that these functions need not be reentrant is added to the DESCRIPTION.
Issue 6
In the DESCRIPTION, the note about reentrancy is expanded to cover thread-safety.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
SD5-XBD-ERN-4 is applied, changing the definition of the [EMFILE] error.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0080 [75] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0086 [493], XSH/TC2-2008/0087 [656], and XSH/TC2-2008/0088 [493] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getprotobyname.html =====
endprotoent
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
endprotoent, getprotobyname, getprotobynumber, getprotoent, setprotoent — network protocol database
functions
SYNOPSIS
#include
void endprotoent(void);
struct protoent *getprotobyname(const char *name);
struct protoent *getprotobynumber(int proto);
struct protoent *getprotoent(void);
void setprotoent(int stayopen);
DESCRIPTION
These functions shall retrieve information about protocols. This information is considered to be stored in a database that can
be accessed sequentially or randomly. The implementation of this database is unspecified.
The setprotoent() function shall open a connection to the database, and set the next entry to the first entry. If the
stayopen argument is non-zero, the connection to the network protocol database shall not be closed after each call to
getprotoent() (either directly, or indirectly through one of the other getproto*() functions), and the implementation
may maintain an open file descriptor for the database. If a file descriptor is used, the FD_CLOEXEC flag shall be set; see .
The getprotobyname() function shall search the database from the beginning and find the first entry for which the
protocol name specified by name matches the p_name member, opening and closing a connection to the database as
necessary.
The getprotobynumber() function shall search the database from the beginning and find the first entry for which the
protocol number specified by proto matches the p_proto member, opening and closing a connection to the database as
necessary.
The getprotoent() function shall read the next entry of the database, opening and closing a connection to the database as
necessary.
The getprotobyname(), getprotobynumber(), and getprotoent() functions shall each return a pointer to a
protoent structure, the members of which shall contain the fields of an entry in the network protocol database.
The endprotoent() function shall close the connection to the database, releasing any open file descriptor.
These functions need not be thread-safe.
RETURN VALUE
Upon successful completion, getprotobyname(), getprotobynumber(), and getprotoent() return a pointer to a
protoent structure if the requested entry was found, and a null pointer if the end of the database was reached or the
requested entry was not found. Otherwise, a null pointer is returned.
The application shall not modify the structure to which the return value points, nor any storage areas pointed to by pointers
within the structure. The returned pointer, and pointers within the structure, might be invalidated or the structure or the storage
areas might be overwritten by a subsequent call to getprotobyname(), getprotobynumber(), or getprotoent(). The
returned pointer, and pointers within the structure, might also be invalidated if the calling thread is terminated.
ERRORS
The getprotobyname(), getprotobynumber(), getprotoent(), and setprotoent() functions may fail
if:
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum allowable number of files is currently open in the system.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0085 [75] and XSH/TC1-2008/0086 [75] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0091 [656] is applied.
Issue 8
Austin Group Defect 368 is applied, adding a requirement for FD_CLOEXEC to be set if a file descriptor is used, and adding the
[EMFILE] and [ENFILE] errors.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/thrd_equal.html =====
thrd_equal
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
thrd_equal — compare thread IDs
SYNOPSIS
#include
int thrd_equal(thrd_t thr0, thrd_t thr1);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The thrd_equal() function shall determine whether the thread identified by thr0 refers to the thread identified by
thr1.
[CX]  The
thrd_equal() function shall not be affected if the calling thread executes a signal handler during the call.
RETURN VALUE
The thrd_equal() function shall return a non-zero value if thr0 and thr1 are equal; otherwise, zero shall
be returned.
If either thr0 or thr1 is not a valid thread ID [CX]   and is not equal to PTHREAD_NULL (which is defined in ),
the behavior is undefined.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
See the RATIONALE section for pthread_equal().
The thrd_equal() function is not affected by signal handlers for the reasons stated in XRAT B.2.3 Error Numbers.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_equal(), thrd_current()
XBD ,
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/casinl.html =====
casin
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
casin, casinf, casinl — complex arc sine functions
SYNOPSIS
#include
double complex casin(double complex z);
float complex casinf(float complex z);
long double complex casinl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex arc sine of z, with branch cuts outside the interval [-1, +1] along the
real axis.
RETURN VALUE
These functions shall return the complex arc sine value, in the range of a strip mathematically unbounded along the imaginary
axis and in the interval [-ℼ/2, +ℼ/2] along the real axis.
[MXC]
casin(conj(iz)), casinf(conjf(iz)), and casinl(conjl(iz)) shall
return exactly the same value as conj(casin(iz)), conjf(casinf(iz)), and
conjl(casinl(iz)), respectively, and casin(-iz), casinf(-iz), and
casinl(-iz) shall return exactly the same value as -casin(iz), -casinf(iz), and
-casinl(iz), respectively, including for the special values of iz below.
If iz is +0 + i0, -i (0 + i0) shall be returned.
If iz is x + iInf where x is positive-signed and finite, -i (+Inf + iℼ/2) shall be
returned.
If iz is x + iNaN where x is finite, -i (NaN + iNaN) shall be returned and the invalid
floating-point exception may be raised.
If iz is +Inf + iy where y is positive-signed and finite, -i (+Inf + i0) shall be
returned.
If iz is +Inf + iInf, -i (+Inf + iℼ/4) shall be returned.
If iz is +Inf + iNaN, -i (+Inf + iNaN) shall be returned.
If iz is NaN + i0, -i (NaN + i0) shall be returned.
If iz is NaN + iy where y is non-zero and finite, -i (NaN + iNaN) shall be returned and the
invalid floating-point exception may be raised.
If iz is NaN + iInf, -i (±Inf + iNaN) shall be returned; the sign of the imaginary part of the
result is unspecified.
If iz is NaN + iNaN, -i (NaN + iNaN) shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The MXC special cases for casin() are derived from those for casinh() by
applying the formula casin(z) = -i casinh(iz).
FUTURE DIRECTIONS
None.
SEE ALSO
casinh(), csin()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/call_once.html =====
call_once
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
call_once — dynamic package initialization
SYNOPSIS
#include
void call_once(once_flag *flag, void (*init_routine)(void));
once_flag flag = ONCE_FLAG_INIT;
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The call_once() function shall use the once_flag pointed to by flag to ensure that init_routine is
called exactly once, the first time the call_once() function is called with that value of flag. Completion of an
effective call to the call_once() function shall synchronize with all subsequent calls to the call_once() function
with the same value of flag.
[CX]  The
call_once() function is not a cancellation point. However, if init_routine is a cancellation point and is canceled,
the effect on flag shall be as if call_once() was never called.
If the call to init_routine is terminated by a call to longjmp() or
siglongjmp(), the behavior is undefined.
The behavior of call_once() is undefined if flag has automatic storage duration or is not initialized by
ONCE_FLAG_INIT.
The call_once() function shall not be affected if the calling thread executes a signal handler during the call.
RETURN VALUE
The call_once() function shall not return a value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
If init_routine recursively calls call_once() with the same flag, the recursive call will not call the
specified init_routine, and thus the specified init_routine will not complete, and thus the recursive call to
call_once() will not return. Use of longjmp() or siglongjmp() within an init_routine to jump to a point outside of
init_routine prevents init_routine from returning.
RATIONALE
For dynamic library initialization in a multi-threaded process, if an initialization flag is used the flag needs to be protected
against modification by multiple threads simultaneously calling into the library. This can be done by using a
statically-initialized mutex. However, the better solution is to use call_once() or pthread_once() which are designed for exactly this purpose, for example:
#include
static once_flag random_is_initialized = ONCE_FLAG_INIT;
extern void initialize_random(void);
int random_function()
{
call_once(&random_is_initialized, initialize_random);
...
/* Operations performed after initialization. */
}
The call_once() function is not affected by signal handlers for the reasons stated in XRAT B.2.3 Error Numbers.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_once()
XBD 4.15.2 Memory Synchronization,
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sin.html =====
sin
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sin, sinf, sinl — sine function
SYNOPSIS
#include
double sin(double x);
float sinf(float x);
long double sinl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the sine of their argument x, measured in radians.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the sine of x.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, x shall be returned.
If x is ±Inf, a domain error shall occur, and a NaN shall be returned.
[MXX]
If x is subnormal, x should be returned.
[MX]  If x is subnormal, a range error may occur and, if x is
not returned, sin(), sinf(), and sinl() shall return an implementation-defined value no greater in magnitude
than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
ERRORS
These functions shall fail if:
Domain Error
[MX]
The x argument is ±Inf.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
These functions may fail if:
Range Error
[MX]
The value of x is subnormal
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
Taking the Sine of a 45-Degree Angle
#include
...
double radians = 45.0 * M_PI / 180;
double result;
...
result = sin(radians);
APPLICATION USAGE
These functions may lose accuracy when their argument is near a multiple of ℼ or is far from 0.0.
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
asin(), feclearexcept(),
fetestexcept(), isnan()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The last two paragraphs of the DESCRIPTION were included as APPLICATION USAGE notes in previous issues.
Issue 6
The sinf() and sinl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0585 [68] and XSH/TC1-2008/0586 [320] are applied.
Issue 8
Austin Group Defect 1382 is applied, rearranging the text describing the behavior when x is subnormal to avoid the need
for two shading changes.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/scalbn.html =====
scalbln
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
scalbln, scalblnf, scalblnl, scalbn, scalbnf, scalbnl — compute exponent using FLT_RADIX
SYNOPSIS
#include
double scalbln(double x, long n);
float scalblnf(float x, long n);
long double scalblnl(long double x, long n);
double scalbn(double x, int n);
float scalbnf(float x, int n);
long double scalbnl(long double x, int n);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute x * FLT_RADIXn efficiently, not normally by
computing FLT_RADIXn explicitly.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return x * FLT_RADIXn.
[MX]  If
the calculation does not overflow or underflow, the returned value shall be exact and shall be independent of the current rounding
direction mode.
If the result would cause overflow, a range error shall occur and these functions shall return ±HUGE_VAL, ±HUGE_VALF, and
±HUGE_VALL (according to the sign of x) as appropriate for the return type of the function.
If the correct value would cause underflow, [MXX]   and is not representable,   a range error may occur, and scalbln(), scalblnf(), scalblnl(),
scalbn(), scalbnf(), and scalbnl() shall return [MXX]
0.0, or   (if IEC 60559 Floating-Point is not supported) an implementation-defined value no greater in
magnitude than DBL_MIN, FLT_MIN, LDBL_MIN, DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0 or ±Inf, x shall be returned.
If n is 0, x shall be returned.
[MXX]
If the correct value would cause underflow, and is representable, a range error may occur and the correct value shall be returned.
ERRORS
These functions shall fail if:
Range Error
The result overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
These functions may fail if:
Range Error
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
These functions are named so as to avoid conflicting with the historical definition of the scalb() function from the
Single UNIX Specification. The difference is that the scalb() function has a second argument of double instead of
int. The scalb() function is not part of the ISO C standard. The three functions whose second type is
long are provided because the factor required to scale from the smallest positive floating-point value to the largest finite
one, on many implementations, is too large to represent in the minimum-width int format.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0521 [68] and XSH/TC1-2008/0522 [68] are applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/gethostname.html =====
gethostname
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
gethostname — get name of current host
SYNOPSIS
#include
int gethostname(char *name, size_t namelen);
DESCRIPTION
The gethostname() function shall return the standard host name for the current machine. The namelen argument shall
specify the size of the array pointed to by the name argument. The returned name shall be null-terminated, except that if
namelen is an insufficient length to hold the host name, then the returned name shall be truncated and it is unspecified
whether the returned name is null-terminated.
Host names are limited to {HOST_NAME_MAX} bytes.
RETURN VALUE
Upon successful completion, 0 shall be returned; otherwise, -1 shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
gethostid(), uname()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
The Open Group Base Resolution bwg2001-008 is applied, changing the namelen parameter from socklen_t to
size_t.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/cexpl.html =====
cexp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cexp, cexpf, cexpl — complex exponential functions
SYNOPSIS
#include
double complex cexp(double complex z);
float complex cexpf(float complex z);
long double complex cexpl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex exponent of z, defined as ez.
RETURN VALUE
These functions shall return the complex exponential value of z.
[MXC]
cexp(conj(z)), cexpf(conjf(z)), and cexpl(conjl(z)) shall return
exactly the same value as conj(cexp(z)), conjf(cexpf(z)), and
conjl(cexpl(z)), respectively, including for the special values of z below.
If z is ±0 + i0, 1 + i0 shall be returned.
If z is x + iInf where x is finite, NaN + iNaN shall be returned and the invalid
floating-point exception shall be raised.
If z is x + iNaN where x is finite, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is +Inf + i0, +Inf + i0 shall be returned.
If z is -Inf + iy where y is finite, +0 (cos(y) + isin(y)) shall be
returned.
If z is +Inf + iy where y is non-zero and finite, +Inf (cos(y) + isin(y)) shall
be returned.
If z is -Inf + iInf, ±0 ± i0 shall be returned; the signs of the real and imaginary parts of the result are
unspecified.
If z is +Inf + iInf, ±Inf + iNaN shall be returned and the invalid floating-point exception shall be
raised; the sign of the real part of the result is unspecified.
If z is -Inf + iNaN, ±0 ± i0 shall be returned; the signs of the real and imaginary parts of the result are
unspecified.
If z is +Inf + iNaN, ±Inf + iNaN shall be returned; the sign of the real part of the result is
unspecified.
If z is NaN + i0, NaN + i0 shall be returned.
If z is NaN + iy where y is any non-zero number, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is NaN + iNaN, NaN + iNaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
clog()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getresgid.html =====
getresgid
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getresgid — get real group ID, effective group ID, and saved set-group-ID
SYNOPSIS
[XSI]  #include
int getresgid(gid_t *restrict rgid, gid_t *restrict egid,
gid_t *restrict sgid);
DESCRIPTION
The getresgid() function shall store the real group ID, effective group ID, and saved set-group-ID of the calling process
in the locations pointed to by the arguments rgid, egid, and sgid, respectively.
RETURN VALUE
Upon successful completion, 0 shall be returned. Otherwise, -1 shall be returned and errno set to indicate the error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
exec, getegid(), geteuid(), getgid(), getresuid(), getuid(), setegid(), seteuid(), setgid(), setregid(), setresgid(), setresuid(), setreuid(), setuid()
XBD
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/thrd_current.html =====
thrd_current
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
thrd_current — get the calling thread ID
SYNOPSIS
#include
thrd_t thrd_current(void);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The thrd_current() function shall identify the thread that called it.
RETURN VALUE
The thrd_current() function shall return the thread ID of the thread that called it.
The thrd_current() function shall always be successful. No return value is reserved to indicate an error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_self(), thrd_create(), thrd_equal()
XBD
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wctrans_l.html =====
wctrans
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wctrans, wctrans_l — define character mapping
SYNOPSIS
#include
wctrans_t wctrans(const char *charclass);
[CX]  wctrans_t wctrans_l(const char *charclass, locale_t locale);
DESCRIPTION
For wctrans(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The wctrans() [CX]   and wctrans_l()
functions are defined for valid character mapping names identified in the current locale. The charclass is a string
identifying a generic character mapping name for which codeset-specific information is required. The following character mapping
names are defined in all locales: tolower and toupper.
These functions shall return a value of type wctrans_t, which can be used as the second argument to subsequent calls of
towctrans() [CX]   and towctrans_l().
The wctrans() [CX]   and wctrans_l()
functions shall determine values of wctrans_t according to the rules of the coded character set defined by character
mapping information in the current locale [CX]   or in the locale represented by locale,   respectively (category LC_CTYPE ).
The values returned by wctrans() shall be valid until a call to setlocale() that modifies the category LC_CTYPE .
[CX]  The
values returned by wctrans_l() shall be valid only in calls to towctrans_l() with a locale represented by locale with the same LC_CTYPE
category value.
The behavior is undefined if the locale argument to wctrans_l() is the special locale object LC_GLOBAL_LOCALE or
is not a valid locale object handle.
RETURN VALUE
The wctrans() [CX]   and wctrans_l()
functions shall return 0 and may set errno to indicate the error if the given character mapping name is not valid for
the current locale (category LC_CTYPE ); otherwise, they shall return a non-zero object of type wctrans_t that can be
used in calls to towctrans() [CX]   and towctrans_l().
ERRORS
These functions may fail if:
[EINVAL]
[CX]
The character mapping name pointed to by charclass is not valid in the current locale.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
towctrans()
XBD
CHANGE HISTORY
First released in Issue 5. Derived from ISO/IEC 9899:1990/Amendment 1:1995 (E).
Issue 7
The wctrans_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0732 [302], XSH/TC1-2008/0733 [289], XSH/TC1-2008/0734 [283], and
XSH/TC1-2008/0735 [283] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/log1pf.html =====
log1p
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
log1p, log1pf, log1pl — compute a natural logarithm
SYNOPSIS
#include
double log1p(double x);
float log1pf(float x);
long double log1pl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute loge(1.0 + x).
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the natural logarithm of 1.0 + x.
If x is -1, a pole error shall occur and log1p(), log1pf(), and log1pl() shall return -HUGE_VAL,
-HUGE_VALF, and -HUGE_VALL, respectively.
For finite values of x that are less than -1, [MX]   or if x is -Inf,  a domain error shall occur, and [MX]   either a NaN (if supported), or   an implementation-defined value shall be returned.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, or +Inf, x shall be returned.
[MXX]
If x is subnormal, x should be returned.
[MX]  If x is subnormal, a range error may occur and, if x is
not returned, log1p(), log1pf(), and log1pl() shall return an implementation-defined value no greater in
magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
ERRORS
These functions shall fail if:
Domain Error
The finite value of x is less than -1, [MX]   or x is -Inf.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
Pole Error
The value of x is -1.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the divide-by-zero floating-point exception shall
be raised.
These functions may fail if:
Range Error
[MX]
The value of x is subnormal.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), log()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
The log1p() function is no longer marked as an extension.
The log1pf() and log1pl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0364 [68] is applied.
Issue 8
Austin Group Defect 1382 is applied, rearranging the text describing the behavior when x is subnormal to avoid the need
for two shading changes.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/aio_fsync.html =====
aio_fsync
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
aio_fsync — asynchronous file synchronization
SYNOPSIS
[FSC|SIO]  #include
int aio_fsync(int op, struct aiocb *aiocbp);
DESCRIPTION
The aio_fsync() function shall asynchronously perform a file synchronization operation, as specified by the op
argument, for I/O operations associated with the file indicated by the file descriptor aio_fildes member of the aiocb
structure referenced by the aiocbp argument and queued at the time of the call to aio_fsync(). The function call
shall return when the synchronization request has been initiated or queued to the file or device (even when the data cannot be
synchronized immediately).
[SIO]
If op is O_DSYNC, all currently queued I/O operations shall be completed as if by a call to fdatasync(); that is, as defined for synchronized I/O data integrity completion.
[FSC]
If op is O_SYNC, all currently queued I/O operations shall be completed as if by a call to fsync();  [FSC SIO]  that is,
as defined for synchronized I/O file integrity completion.   If
the aio_fsync() function fails, or if the operation queued by aio_fsync() fails, then outstanding I/O operations are
not guaranteed to have been completed.
If aio_fsync() succeeds, then it is only the I/O that was queued at the time of the call to aio_fsync() that is
guaranteed to be forced to the relevant completion state. The completion of subsequent I/O on the file descriptor is not guaranteed
to be completed in a synchronized fashion.
The aiocbp argument refers to an asynchronous I/O control block. The aiocbp value may be used as an argument to
aio_error() and aio_return() in
order to determine the error status and return status, respectively, of the asynchronous operation while it is proceeding. When the
request is queued, the error status for the operation is [EINPROGRESS]. When all data has been successfully transferred, the error
status shall be reset to reflect the success or failure of the operation. If the operation does not complete successfully, the
error status for the operation shall be set to indicate the error. The aio_sigevent member determines the asynchronous
notification to occur as specified in 2.4.1 Signal Generation and
Delivery when all operations have achieved synchronized I/O completion. All other members of the structure referenced by
aiocbp are ignored. If the control block referenced by aiocbp becomes an illegal address prior to asynchronous I/O
completion, then the behavior is undefined.
If the aio_fsync() function fails or aiocbp indicates an error condition, data is not guaranteed to have been
successfully transferred.
RETURN VALUE
The aio_fsync() function shall return the value 0 if the I/O operation is successfully queued; otherwise, the function
shall return the value -1 and set errno to indicate the error.
ERRORS
The aio_fsync() function shall fail if:
[EAGAIN]
The requested asynchronous operation was not queued due to temporary resource limitations.
[EBADF]
The aio_fildes member of the aiocb structure referenced by the aiocbp argument is not a valid file
descriptor.
[EINVAL]
[SIO]
This implementation does not support synchronized I/O for this file.
[EINVAL]
[FSC]
The aio_fildes member of the aiocb structure refers to a file on which an fsync() operation is not possible.
[EINVAL]
A value of op other than O_DSYNC or O_SYNC was specified, or O_DSYNC was specified and the implementation does not
provide runtime support for the Synchronized Input and Output option, or O_SYNC was specified and the implementation does not
provide runtime support for the File Synchronization option.
In the event that any of the queued I/O operations fail, aio_fsync() shall return the error condition defined for
read() and write(). The error is returned
in the error status for the asynchronous operation, which can be retrieved using aio_error().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Note that even if the file descriptor is not open for writing, if there are any pending write requests on the underlying file,
then that I/O will be completed prior to the return of a call to aio_error() or
aio_return() indicating that the operation has completed.
See also the APPLICATION USAGE for fdatasync() and fsync().
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
aio_error(), aio_return()
, fcntl(), fdatasync(), fsync(), open(), read(), write()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the
Asynchronous Input and Output option.
The APPLICATION USAGE section is added.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/11 is applied, removing the words "to the calling process" in
the RETURN VALUE section. The term was unnecessary and precluded threads.
Issue 7
The aio_fsync() function is moved from the Asynchronous Input and Output option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0026 [98] and XSH/TC1-2008/0027 [98] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0045 [671] is applied.
Issue 8
Austin Group Defect 672 is applied, changing the APPLICATION USAGE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/va_start.html =====
va_arg
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
va_arg, va_copy, va_end, va_start — handle variable argument list
SYNOPSIS
#include
type va_arg(va_list ap, type);
void va_copy(va_list dest, va_list src);
void va_end(va_list ap);
void va_start(va_list ap, argN);
DESCRIPTION
Refer to XBD
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/munlock.html =====
mlock
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mlock, munlock — lock or unlock a range of process address space (REALTIME)
SYNOPSIS
[MLR]  #include
int mlock(const void *addr, size_t len);
int munlock(const void *addr, size_t len);
DESCRIPTION
The mlock() function shall cause those whole pages containing any part of the address space of the process starting at
address addr and continuing for len bytes to be memory-resident until unlocked or until the process exits or
execs another process image. The implementation may require that addr be a
multiple of {PAGESIZE}.
The munlock() function shall unlock those whole pages containing any part of the address space of the process starting at
address addr and continuing for len bytes, regardless of how many times mlock() has been called by the process
for any of the pages in the specified range. The implementation may require that addr be a multiple of {PAGESIZE}.
If any of the pages in the range specified to a call to munlock() are also mapped into the address spaces of other
processes, any locks established on those pages by another process are unaffected by the call of this process to munlock().
If any of the pages in the range specified by a call to munlock() are also mapped into other portions of the address space
of the calling process outside the range specified, any locks established on those pages via the other mappings are also unaffected
by this call.
Upon successful return from mlock(), pages in the specified range shall be locked and memory-resident. Upon successful
return from munlock(), pages in the specified range shall be unlocked with respect to the address space of the process.
Memory residency of unlocked pages is unspecified.
Appropriate privileges are required to lock process memory with mlock().
RETURN VALUE
Upon successful completion, the mlock() and munlock() functions shall return a value of zero. Otherwise, no change
is made to any locks in the address space of the process, and the function shall return a value of -1 and set errno to
indicate the error.
ERRORS
The mlock() and munlock() functions shall fail if:
[ENOMEM]
Some or all of the address range specified by the addr and len arguments does not correspond to valid mapped
pages in the address space of the process.
The mlock() function shall fail if:
[EAGAIN]
Some or all of the memory identified by the operation could not be locked when the call was made.
The mlock() and munlock() functions may fail if:
[EINVAL]
The addr argument is not a multiple of {PAGESIZE}.
The mlock() function may fail if:
[ENOMEM]
Locking the pages mapped by the specified range would exceed an implementation-defined limit on the amount of memory that the
process may lock.
[EPERM]
The calling process does not have appropriate privileges to perform the requested operation.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
exec, exit(), fork(), mlockall(), munmap()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The mlock() and munlock() functions are marked as part of the Range Memory Locking option.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Range
Memory Locking option.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pathconf.html =====
fpathconf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fpathconf, pathconf — get configurable pathname variables
SYNOPSIS
#include
long fpathconf(int fildes, int name);
long pathconf(const char *path, int name);
DESCRIPTION
The fpathconf() and pathconf() functions shall determine the current value of a configurable limit or option
(variable) that is associated with a file or directory.
For pathconf(), the path argument points to the pathname of a file or directory.
For fpathconf(), the fildes argument is an open file descriptor.
The name argument represents the variable to be queried relative to that file or directory. Implementations shall support
all of the variables listed in the following table and may support others. The variables in the following table come from  or  and the
symbolic constants, defined in , are the corresponding values used
for name.
Variable
Value of name
Requirements
{FILESIZEBITS}
_PC_FILESIZEBITS
4,7
{LINK_MAX}
_PC_LINK_MAX
1
{MAX_CANON}
_PC_MAX_CANON
2
{MAX_INPUT}
_PC_MAX_INPUT
2
{NAME_MAX}
_PC_NAME_MAX
3,4
{PATH_MAX}
_PC_PATH_MAX
4,5
{PIPE_BUF}
_PC_PIPE_BUF
6
{POSIX2_SYMLINKS}
_PC_2_SYMLINKS
4
{POSIX_ALLOC_SIZE_MIN}
_PC_ALLOC_SIZE_MIN
10
{POSIX_REC_INCR_XFER_SIZE}
_PC_REC_INCR_XFER_SIZE
10
{POSIX_REC_MAX_XFER_SIZE}
_PC_REC_MAX_XFER_SIZE
10
{POSIX_REC_MIN_XFER_SIZE}
_PC_REC_MIN_XFER_SIZE
10
{POSIX_REC_XFER_ALIGN}
_PC_REC_XFER_ALIGN
10
{SYMLINK_MAX}
_PC_SYMLINK_MAX
4,9
{TEXTDOMAIN_MAX}
_PC_TEXTDOMAIN_MAX
3,4
_POSIX_CHOWN_RESTRICTED
_PC_CHOWN_RESTRICTED
7
_POSIX_NO_TRUNC
_PC_NO_TRUNC
3,4
_POSIX_VDISABLE
_PC_VDISABLE
2
_POSIX_ASYNC_IO
_PC_ASYNC_IO
8
_POSIX_FALLOC
_PC_FALLOC
8
_POSIX_PRIO_IO
_PC_PRIO_IO
8
_POSIX_SYNC_IO
_PC_SYNC_IO
8
_POSIX_TIMESTAMP_RESOLUTION
_PC_TIMESTAMP_RESOLUTION
1
Requirements
If path or fildes refers to a directory, the value returned shall apply to the directory
itself.
If path or fildes does not refer to a terminal file, it is unspecified whether an implementation
supports an association of the variable name with the specified file.
If path or fildes refers to a directory, the value returned shall apply to filenames within the
directory.
If path or fildes does not refer to a directory, it is unspecified whether an implementation
supports an association of the variable name with the specified file.
If path or fildes refers to a directory, the value returned shall be the maximum length of a
relative pathname that would not cross any mount points when the specified directory is the working directory.
If path refers to a FIFO, or fildes refers to a pipe or FIFO, the value returned shall apply to the
referenced object. If path or fildes refers to a directory, the value returned shall apply to any FIFO that exists or
can be created within the directory. If path or fildes refers to any other type of file, it is unspecified whether an
implementation supports an association of the variable name with the specified file.
If path or fildes refers to a directory, the value returned shall apply to any files, other than
directories, that exist or can be created within the directory.
If path or fildes refers to a directory, it is unspecified whether an implementation supports an
association of the variable name with the specified file.
If path or fildes refers to a directory, the value returned shall be the maximum length of the
string that a symbolic link in that directory can contain.
If path or fildes des does not refer to a regular file, it is unspecified whether an implementation
supports an association of the variable name with the specified file. If an implementation supports such an association for other
than a regular file, the value returned is unspecified.
RETURN VALUE
If name is an invalid value, both pathconf() and fpathconf() shall return -1 and set errno to
indicate the error.
If the variable corresponding to name is described in  as a maximum or minimum value and the variable has no limit for the path or
file descriptor, both pathconf() and fpathconf() shall return -1 without changing errno. Note that indefinite
limits do not imply infinite limits; see .
If the implementation needs to use path to determine the value of name and the implementation does
not support the association of name with the file specified by path, or if the process did not have appropriate
privileges to query the file specified by path, or path does not exist, pathconf() shall return -1 and set
errno to indicate the error.
If the implementation needs to use fildes to determine the value of name and the implementation does
not support the association of name with the file specified by fildes, or if fildes is an invalid file
descriptor, fpathconf() shall return -1 and set errno to indicate the error.
Otherwise, pathconf() or fpathconf() shall return the current variable value for the file or
directory without changing errno. The value returned shall not be more restrictive than the corresponding value available to
the application when it was compiled with the implementation's  or
.
If the variable corresponding to name is dependent on an unsupported option, the results are
unspecified.
ERRORS
The pathconf() function shall fail if:
[EINVAL]
The value of name is not valid.
[EOVERFLOW]
The value of name is _PC_TIMESTAMP_RESOLUTION and the resolution is larger than {LONG_MAX}.
The pathconf() function may fail if:
[EACCES]
Search permission is denied for a component of the path prefix.
[EINVAL]
The implementation does not support an association of the variable name with the specified file.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path argument.
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
[ENOENT]
A component of path does not name an existing file or path is an empty string.
[ENOTDIR]
A component of the path prefix names an existing file that is neither a directory nor a symbolic link to a directory, or the
path argument contains at least one non- character and ends with one or more trailing  characters
and the last pathname component names an existing file that is neither a directory nor a symbolic link to a directory.
The fpathconf() function shall fail if:
[EINVAL]
The value of name is not valid.
[EOVERFLOW]
The value of name is _PC_TIMESTAMP_RESOLUTION and the resolution is larger than {LONG_MAX}.
The fpathconf() function may fail if:
[EBADF]
The fildes argument is not a valid file descriptor.
[EINVAL]
The implementation does not support an association of the variable name with the specified file.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Application developers should check whether an option, such as _POSIX_ADVISORY_INFO, is supported prior to obtaining and using
values for related variables such as {POSIX_ALLOC_SIZE_MIN}.
RATIONALE
The pathconf() function was proposed immediately after the sysconf()
function when it was realized that some configurable values may differ across file system, directory, or device boundaries.
For example, {NAME_MAX} frequently changes between System V and BSD-based file systems; System V uses a maximum of
14, BSD 255. On an implementation that provides both types of file systems, an application would be forced to limit all pathname
components to 14 bytes, as this would be the value specified in  on
such a system.
Therefore, various useful values can be queried on any pathname or file descriptor, assuming that appropriate
privileges are in place.
The value returned for the variable {PATH_MAX} indicates the longest relative pathname that could be given if the
specified directory is the current working directory of the process. A process may not always be able to generate a name that long
and use it if a subdirectory in the pathname crosses into a more restrictive file system. Note that implementations are allowed to
accept pathnames longer than {PATH_MAX} bytes long, but are not allowed to return pathnames longer than this unless the user
specifies a larger buffer using a function that provides a buffer size argument.
The value returned for the variable _POSIX_CHOWN_RESTRICTED also applies to directories that do not have file
systems mounted on them. The value may change when crossing a mount point, so applications that need to know should check for each
directory. (An even easier check is to try the chown() function and look for an error
in case it happens.)
Unlike the values returned by sysconf(), the pathname-oriented
variables are potentially more volatile and are not guaranteed to remain constant throughout the lifetime of the process. For
example, in between two calls to pathconf(), the file system in question may have been unmounted and remounted with
different characteristics.
Also note that most of the errors are optional. If one of the variables always has the same value on an
implementation, the implementation need not look at path or fildes to return that value and is, therefore, not
required to detect any of the errors except the meaning of [EINVAL] that indicates that the value of name is not valid for
that variable, and the [EOVERFLOW] error that indicates the value to be returned is larger than {LONG_MAX}.
If the value of any of the limits is unspecified (logically infinite), they will not be defined in  and the pathconf() and fpathconf() functions return -1
without changing errno. This can be distinguished from the case of giving an unrecognized name argument because
errno is set to [EINVAL] in this case.
Since -1 is a valid return value for the pathconf() and fpathconf() functions, applications should
set errno to zero before calling them and check errno only if the return value is -1.
For the case of {SYMLINK_MAX}, since both pathconf() and open()
follow symbolic links, there is no way that path or fildes could refer to a symbolic link.
It was the intention of IEEE Std 1003.1d-1999 that the following variables:
{POSIX_ALLOC_SIZE_MIN}
{POSIX_REC_INCR_XFER_SIZE}
{POSIX_REC_MAX_XFER_SIZE}
{POSIX_REC_MIN_XFER_SIZE}
{POSIX_REC_XFER_ALIGN}
only applied to regular files, but Note 10 also permits implementation of the advisory semantics on other file
types unique to an implementation (for example, a character special device).
The [EOVERFLOW] error for _PC_TIMESTAMP_RESOLUTION cannot occur on POSIX-compliant file systems because POSIX
requires a timestamp resolution no larger than one second. Even on 32-bit systems, this can be represented without overflow.
FUTURE DIRECTIONS
None.
SEE ALSO
chown(), confstr(),
sysconf()
XBD ,
XCU getconf
CHANGE HISTORY
First released in Issue 3. Included for alignment with the POSIX.1-1988 standard.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Realtime Extension.
Large File Summit extensions are added.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The DESCRIPTION is updated to include {FILESIZEBITS}.
The [ELOOP] mandatory error condition is added.
A second [ENAMETOOLONG] is added as an optional error condition.
The following changes were made to align with the IEEE P1003.1a draft standard:
The _PC_SYMLINK_MAX entry is added to the table in the DESCRIPTION.
The following pathconf() variables and their associated names are added for alignment with
IEEE Std 1003.1d-1999:
{POSIX_ALLOC_SIZE_MIN}
{POSIX_REC_INCR_XFER_SIZE}
{POSIX_REC_MAX_XFER_SIZE}
{POSIX_REC_MIN_XFER_SIZE}
{POSIX_REC_XFER_ALIGN}
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/18 is applied, changing the fourth paragraph of the
DESCRIPTION and removing shading and margin markers from the table. This change is needed since implementations are required to
support all of these symbols.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/34 is applied, adding the table entry for
POSIX2_SYMLINKS in the DESCRIPTION.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/35 is applied, updating the DESCRIPTION and
RATIONALE sections to clarify behavior for the following variables:
{POSIX_ALLOC_SIZE_MIN}
{POSIX_REC_INCR_XFER_SIZE}
{POSIX_REC_MAX_XFER_SIZE}
{POSIX_REC_MIN_XFER_SIZE}
{POSIX_REC_XFER_ALIGN}
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/36 is applied, updating the RETURN VALUE and
APPLICATION USAGE sections to state that the results are unspecified if a variable is dependent on an unsupported option, and
advising application developers to check for supported options prior to obtaining and using such values.
Issue 7
Austin Group Interpretations 1003.1-2001 #143 and #160 are applied.
Changes are made related to support for finegrained timestamps.
The [ENOTDIR] error condition is clarified to cover the condition where the last component of a pathname exists but
is not a directory or a symbolic link to a directory.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0160 [256,428], XSH/TC1-2008/0161 [256,428], and
XSH/TC1-2008/0162 [324] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0124 [651] and XSH/TC2-2008/0125 [651] are applied.
Issue 8
Austin Group Defect 687 is applied, adding _POSIX_FALLOC and _PC_FALLOC.
Austin Group Defect 1122 is applied, adding {TEXTDOMAIN_MAX}.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/exit.html =====
exit
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
exit — terminate a process
SYNOPSIS
#include
void exit(int status);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The exit() function shall cause normal process termination to occur. No functions registered by the at_quick_exit() function shall be called. If a process calls the exit()
function more than once, or calls the quick_exit() function in addition to the
exit() function, the behavior is undefined.
The value of status can be 0, EXIT_SUCCESS, EXIT_FAILURE, [CX]
or any other value, though only the least significant 8
bits (that is, status & 0377) shall be available from wait() and waitpid(); the full value shall be available from waitid() and in the siginfo_t passed to a signal handler for SIGCHLD.
The exit() function shall first call all functions registered by atexit(),
in the reverse order of their registration, except that a function is called after any previously registered functions that had
already been called at the time it was registered. Each function is called as many times as it was registered. If, during the call
to any such function, a call to the longjmp() function is made that would terminate
the call to the registered function, the behavior is undefined.
If a function registered by a call to atexit() fails to return, the remaining
registered functions shall not be called and the rest of the exit() processing shall not be completed.
The exit() function shall then flush all open streams with unwritten buffered data. [CX]  For each stream
which is the active handle to its underlying file descriptor, and for which the file is not already at EOF and is capable of
seeking, the file offset of the underlying open file description shall be set to the file position of the stream. For each open
stream, the exit() function shall perform the equivalent of a close() on the
file descriptor that is associated with the stream.  Finally, the
process shall be terminated [CX]   with the same consequences as described in Consequences of Process Termination().
RETURN VALUE
The exit() function does not return.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
See APPLICATION USAGE.
APPLICATION USAGE
When a stream that has unwritten buffered data is flushed by exit() there is no way for the calling process to discover
whether or not exit() successfully wrote the data to the underlying file descriptor. Therefore, it is strongly recommended
that applications always ensure there is no unwritten buffered data in any stream when calling exit(), or returning from the
initial call to main(), with a status value that indicates no errors occurred.
For example, the following code demonstrates one way to ensure that stdout has already been successfully flushed before
calling exit() with status 0. If the flush fails, the file descriptor underlying stdout is closed so that
exit() will not try to repeat the failed write operation. If the flush succeeds, a final check with ferror() is performed to ensure that there were no write errors during earlier flush
operations (that were not handled at the time).
int status = 0;
if (fflush(stdout) != 0) {
perror("appname: standard output");
close(fileno(stdout));
status = 1;
}
else if (ferror(stdout)) {
fputs("appname: write error on standard output\n", stderr);
status = 1;
}
exit(status);
See also _Exit().
RATIONALE
See _Exit().
FUTURE DIRECTIONS
None.
SEE ALSO
_Exit(), at_quick_exit(),
atexit(), exec, fflush(), longjmp(), quick_exit(), tmpfile(), wait(), waitid()
XBD
CHANGE HISTORY
Issue 7
Austin Group Interpretation 1003.1-2001 #031 is applied, separating the _Exit() and
_exit() functions from the exit() function.
Austin Group Interpretation 1003.1-2001 #085 is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0100 [594] is applied.
Issue 8
Austin Group Defect 610 is applied, clarifying the effects of exit() on open streams.
Austin Group Defect 1302 is applied, aligning this function with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1490 is applied, changing the EXAMPLES and APPLICATION USAGE sections.
Austin Group Defect 1629 is applied, changing the APPLICATION USAGE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/insque.html =====
insque
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
insque, remque — insert or remove an element in a queue
SYNOPSIS
[XSI]  #include
void insque(void *element, void *pred);
void remque(void *element);
DESCRIPTION
The insque() and remque() functions shall manipulate queues built from doubly-linked lists. The queue can be
either circular or linear. An application using insque() or remque() shall ensure it defines a structure in which the
first two members of the structure are pointers to the same type of structure, and any further members are application-specific.
The first member of the structure is a forward pointer to the next entry in the queue. The second member is a backward pointer to
the previous entry in the queue. If the queue is linear, the queue is terminated with null pointers. The names of the structure and
of the pointer members are not subject to any special restriction.
The insque() function shall insert the element pointed to by element into a queue immediately after the element
pointed to by pred.
The remque() function shall remove the element pointed to by element from a queue.
If the queue is to be used as a linear list, invoking insque(&element, NULL), where element is the initial
element of the queue, shall initialize the forward and backward pointers of element to null pointers.
If the queue is to be used as a circular list, the application shall ensure it initializes the forward pointer and the backward
pointer of the initial element of the queue to the element's own address.
RETURN VALUE
The insque() and remque() functions do not return a value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
Creating a Linear Linked List
The following example creates a linear linked list.
#include
...
struct myque element1;
struct myque element2;
char *data1 = "DATA1";
char *data2 = "DATA2";
...
element1.data = data1;
element2.data = data2;
insque (&element1, NULL);
insque (&element2, &element1);
Creating a Circular Linked List
The following example creates a circular linked list.
#include
...
struct myque element1;
struct myque element2;
char *data1 = "DATA1";
char *data2 = "DATA2";
...
element1.data = data1;
element2.data = data2;
element1.fwd = &element1;
element1.bck = &element1;
insque (&element2, &element1);
Removing an Element
The following example removes the element pointed to by element1.
#include
...
struct myque element1;
...
remque (&element1);
APPLICATION USAGE
The historical implementations of these functions described the arguments as being of type struct qelem * rather than as
being of type void * as defined here. In those implementations, struct qelem was commonly defined in  as:
struct qelem {
struct qelem  *q_forw;
struct qelem  *q_back;
};
Applications using these functions, however, were never able to use this structure directly since it provided no room for the
actual data contained in the elements. Most applications defined structures that contained the two pointers as the initial elements
and also provided space for, or pointers to, the object's data. Applications that used these functions to update more than one type
of table also had the problem of specifying two or more different structures with the same name, if they literally used struct
qelem as specified.
As described here, the implementations were actually expecting a structure type where the first two members were forward and
backward pointers to structures. With C compilers that didn't provide function prototypes, applications used structures as
specified in the DESCRIPTION above and the compiler did what the application expected.
If this method had been carried forward with an ISO C standard compiler and the historical function prototype, most
applications would have to be modified to cast pointers to the structures actually used to be pointers to struct qelem to
avoid compilation warnings. By specifying void * as the argument type, applications do not need to change (unless they
specifically referenced struct qelem and depended on it being defined in ).
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sem_unlink.html =====
sem_unlink
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sem_unlink — remove a named semaphore
SYNOPSIS
#include
int sem_unlink(const char *name);
DESCRIPTION
The sem_unlink() function shall remove the semaphore named by the string name. If the semaphore named by
name is currently referenced by other processes, then sem_unlink() shall have no effect on the state of the
semaphore. If one or more processes have the semaphore open when sem_unlink() is called, destruction of the semaphore is
postponed until all references to the semaphore have been destroyed by calls to sem_close(), _exit(), or exec. Calls to sem_open() to recreate or reconnect
to the semaphore refer to a new semaphore after sem_unlink() is called. The sem_unlink() call shall not block until
all references have been destroyed; it shall return immediately.
RETURN VALUE
Upon successful completion, the sem_unlink() function shall return a value of 0. Otherwise, the semaphore shall not be
changed and the function shall return a value of -1 and set errno to indicate the error.
ERRORS
The sem_unlink() function shall fail if:
[EACCES]
Permission is denied to unlink the named semaphore.
[ENOENT]
The named semaphore does not exist.
The sem_unlink() function may fail if:
[ENAMETOOLONG]
The length of the name argument exceeds {_POSIX_PATH_MAX} on systems that do not support the XSI option [XSI]   or exceeds
{_XOPEN_PATH_MAX} on XSI systems,   or has a pathname component
that is longer than {_POSIX_NAME_MAX} on systems that do not support the XSI option [XSI]   or longer
than {_XOPEN_NAME_MAX} on XSI systems.   A call to
sem_unlink() with a name argument that contains the same semaphore name as was previously used in a successful
sem_open() call shall not give an [ENAMETOOLONG] error.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
A future version might require the sem_open() and sem_unlink() functions
to have semantics similar to normal file system operations.
SEE ALSO
semctl(), semget(), semop(), sem_close(), sem_open()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The sem_unlink() function is marked as part of the Semaphores option.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Semaphores
option.
Issue 7
Austin Group Interpretation 1003.1-2001 #077 is applied, changing [ENAMETOOLONG] from a "shall fail" to a "may fail"
error.
Austin Group Interpretation 1003.1-2001 #141 is applied, adding FUTURE DIRECTIONS.
The sem_unlink() function is moved from the Semaphores option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0531 [37] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fesetenv.html =====
fegetenv
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fegetenv, fesetenv — get and set current floating-point environment
SYNOPSIS
#include
int fegetenv(fenv_t *envp);
int fesetenv(const fenv_t *envp);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The fegetenv() function shall attempt to store the current floating-point environment in the object pointed to by
envp.
The fesetenv() function shall attempt to establish the floating-point environment represented by the object pointed to by
envp. The argument envp shall point to an object set by a call to fegetenv() or feholdexcept(), or equal a floating-point environment macro. The fesetenv()
function does not raise floating-point exceptions, but only installs the state of the floating-point status flags represented
through its argument.
RETURN VALUE
If the representation was successfully stored, fegetenv() shall return zero. Otherwise, it shall return a non-zero value.
If the environment was successfully established, fesetenv() shall return zero. Otherwise, it shall return a non-zero
value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feholdexcept(), feupdateenv()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
ISO/IEC 9899:1999 standard, Technical Corrigendum 1 is incorporated.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_getcpuclockid.html =====
pthread_getcpuclockid
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_getcpuclockid — access a thread CPU-time clock (ADVANCED REALTIME THREADS)
SYNOPSIS
[TCT]  #include
#include
int pthread_getcpuclockid(pthread_t thread_id, clockid_t *clock_id);
DESCRIPTION
The pthread_getcpuclockid() function shall return in clock_id the clock ID of the CPU-time clock of the thread
specified by thread_id, if the thread specified by thread_id exists.
RETURN VALUE
Upon successful completion, pthread_getcpuclockid() shall return zero; otherwise, an error number shall be returned to
indicate the error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The pthread_getcpuclockid() function is part of the Thread CPU-Time Clocks option and need not be provided on all
implementations.
RATIONALE
If an implementation detects use of a thread ID after the end of its lifetime, it is recommended that the function should fail
and report an [ESRCH] error.
FUTURE DIRECTIONS
None.
SEE ALSO
clock_getcpuclockid(), clock_getres(), timer_create()
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1d-1999.
In the SYNOPSIS, the inclusion of  is no longer
required.
Issue 7
The pthread_getcpuclockid() function is marked only as part of the Thread CPU-Time Clocks option as the Threads option is
now part of the Base.
Austin Group Interpretation 1003.1-2001 #142 is applied, removing the [ESRCH] error condition.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0275 [757] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wmemcpy.html =====
wmemcpy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wmemcpy — copy wide characters in memory
SYNOPSIS
#include
wchar_t *wmemcpy(wchar_t *restrict ws1, const wchar_t *restrict ws2,
size_t n);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The wmemcpy() function shall copy n wide characters from the object pointed to by ws2 to the object pointed
to by ws1. This function shall not be affected by locale and all wchar_t values shall be treated identically. The
null wide character and wchar_t values not corresponding to valid characters shall not be treated specially.
If n is zero, the application shall ensure that ws1 and ws2 are valid pointers, and the function shall copy
zero wide characters.
[CX]  The
wmemcpy() function shall not change the setting of errno on valid input.
RETURN VALUE
The wmemcpy() function shall return the value of ws1.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
wmemchr(), wmemcmp(), wmemmove(), wmemset()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E).
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
The wmemcpy() prototype is updated for alignment with the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that wmemcpy() does not change the setting of errno on
valid input.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/calloc.html =====
calloc
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
calloc — a memory allocator
SYNOPSIS
#include
void *calloc(size_t nelem, size_t elsize);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The calloc() function shall allocate unused space for an array of nelem elements each of whose size in bytes is
elsize. The space shall be initialized to all bits 0.
The order and contiguity of storage allocated by successive calls to calloc() is unspecified. The pointer returned if the
allocation succeeds shall be suitably aligned so that it may be assigned to a pointer to any type of object with a fundamental
alignment requirement and then used to access such an object or an array of such objects in the space allocated (until the space is
explicitly freed or reallocated). Each such allocation shall yield a pointer to an object disjoint from any other object. The
pointer returned shall point to the start (lowest byte address) of the allocated space. If the space cannot be allocated, a null
pointer shall be returned. If the size of the space requested is 0, the behavior is implementation-defined: either a null pointer
shall be returned, or the behavior shall be as if the size were some non-zero value, except that the behavior is undefined if the
returned pointer is used to access an object.
For purposes of determining the existence of a data race, calloc() shall behave as though it accessed only memory
locations accessible through its arguments and not other static duration storage. The function may, however, visibly modify the
storage that it allocates. Calls to aligned_alloc(), calloc(), free(), malloc(), [ADV]   posix_memalign(),
[CX]
reallocarray(),
and realloc() that allocate or deallocate a particular region of memory shall
occur in a single total order (see 4.15.1 Memory Ordering), and each
such deallocation call shall synchronize with the next allocation (if any) in this order.
RETURN VALUE
Upon successful completion, calloc() shall return a pointer to the allocated space; if either nelem or
elsize is 0, the application shall ensure that the pointer is not used to access an object.
Otherwise, it shall return a null pointer [CX]   and set errno to indicate the error.
ERRORS
The calloc() function shall fail if:
[ENOMEM]
[CX]
Insufficient memory is available, including the case when nelem * elsize would overflow.
The calloc() function may fail if:
[EINVAL]
[CX]
nelem or elsize is 0 and the implementation does not support 0 sized allocations.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
There is now no requirement for the implementation to support the inclusion of .
RATIONALE
See the RATIONALE for malloc().
FUTURE DIRECTIONS
None.
SEE ALSO
aligned_alloc(), free(),
malloc(), realloc()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The setting of errno and the [ENOMEM] error condition are mandatory if an insufficient memory condition occurs.
Issue 7
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0053 [526] is applied.
Issue 8
Austin Group Defect 374 is applied, changing the RETURN VALUE and ERRORS sections in relation to 0 sized allocations.
Austin Group Defect 1218 is applied, changing the [ENOMEM] error.
Austin Group Defect 1302 is applied, aligning this function with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1387 is applied, changing the RATIONALE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_create.html =====
pthread_create
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_create — thread creation
SYNOPSIS
#include
int pthread_create(pthread_t *restrict thread,
const pthread_attr_t *restrict attr,
void *(*start_routine)(void*), void *restrict
arg);
DESCRIPTION
The pthread_create() function shall create a new thread, with attributes specified by attr, within a process. If
attr is NULL, the default attributes shall be used. If the attributes specified by attr are modified later, the
thread's attributes shall not be affected. Upon successful completion, pthread_create() shall store the ID of the created
thread in the location referenced by thread.
The thread is created executing start_routine with arg as its sole argument. If the start_routine returns,
the effect shall be as if there was an implicit call to pthread_exit() using
the return value of start_routine as the exit status. Note that the thread in which main() was originally invoked
differs from this. When it returns from main(), the effect shall be as if there was an implicit call to exit() using the return value of main() as the exit status.
The signal state of the new thread shall be initialized as follows:
The signal mask shall be inherited from the creating thread.
The set of signals pending for the new thread shall be empty.
The thread-local current locale [XSI]   and the alternate stack
shall not be inherited.
The floating-point environment shall be inherited from the creating thread.
If pthread_create() fails, no new thread is created and the contents of the location referenced by thread are
undefined.
[TCT]
If _POSIX_THREAD_CPUTIME is defined, the new thread shall have a CPU-time clock accessible, and the initial value of this clock
shall be set to zero.
The behavior is undefined if the value specified by the attr argument to pthread_create() does not refer to an
initialized thread attributes object.
RETURN VALUE
If successful, the pthread_create() function shall return zero; otherwise, an error number shall be returned to indicate
the error.
ERRORS
The pthread_create() function shall fail if:
[EAGAIN]
The system lacked the necessary resources to create another thread, or the system-imposed limit on the total number of threads
in a process {PTHREAD_THREADS_MAX} would be exceeded.
[EPERM]
The caller does not have appropriate privileges to set the required scheduling parameters or scheduling policy.
The pthread_create() function shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
There is no requirement on the implementation that the ID of the created thread be available before the newly created thread
starts executing. The calling thread can obtain the ID of the created thread through the thread argument of the
pthread_create() function, and the newly created thread can obtain its ID by a call to pthread_self().
RATIONALE
A suggested alternative to pthread_create() would be to define two separate operations: create and start. Some
applications would find such behavior more natural. Ada, in particular, separates the "creation" of a task from its
"activation".
Splitting the operation was rejected by the standard developers for many reasons:
The number of calls required to start a thread would increase from one to two and thus place an additional burden on
applications that do not require the additional synchronization. The second call, however, could be avoided by the additional
complication of a start-up state attribute.
An extra state would be introduced: "created but not started". This would require the standard to specify the behavior of the
thread operations when the target has not yet started executing.
For those applications that require such behavior, it is possible to simulate the two separate steps with the facilities that
are currently provided. The start_routine() can synchronize by waiting on a condition variable that is signaled by the start
operation.
An Ada implementor can choose to create the thread at either of two points in the Ada program: when the task object is created,
or when the task is activated (generally at a "begin"). If the first approach is adopted, the start_routine() needs to
wait on a condition variable to receive the order to begin "activation". The second approach requires no such condition variable
or extra synchronization. In either approach, a separate Ada task control block would need to be created when the task object is
created to hold rendezvous queues, and so on.
An extension of the preceding model would be to allow the state of the thread to be modified between the create and start. This
would allow the thread attributes object to be eliminated. This has been rejected because:
All state in the thread attributes object has to be able to be set for the thread. This would require the definition of
functions to modify thread attributes. There would be no reduction in the number of function calls required to set up the thread.
In fact, for an application that creates all threads using identical attributes, the number of function calls required to set up
the threads would be dramatically increased. Use of a thread attributes object permits the application to make one set of attribute
setting function calls. Otherwise, the set of attribute setting function calls needs to be made for each thread creation.
Depending on the implementation architecture, functions to set thread state would require kernel calls, or for other
implementation reasons would not be able to be implemented as macros, thereby increasing the cost of thread creation.
The ability for applications to segregate threads by class would be lost.
Another suggested alternative uses a model similar to that for process creation, such as "thread fork". The fork semantics
would provide more flexibility and the "create" function can be implemented simply by doing a thread fork followed immediately by
a call to the desired "start routine" for the thread. This alternative has these problems:
For many implementations, the entire stack of the calling thread would need to be duplicated, since in many architectures there
is no way to determine the size of the calling frame.
Efficiency is reduced since at least some part of the stack has to be copied, even though in most cases the thread never needs
the copied context, since it merely calls the desired start routine.
If an implementation detects that the value specified by the attr argument to pthread_create() does not refer to
an initialized thread attributes object, it is recommended that the function should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
fork(), pthread_exit(),
pthread_join()
XBD 4.15.2 Memory Synchronization,
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_create() function is marked as part of the Threads option.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The [EPERM] mandatory error condition is added.
The thread CPU-time clock semantics are added for alignment with IEEE Std 1003.1d-1999.
The restrict keyword is added to the pthread_create() prototype for alignment with the ISO/IEC 9899:1999
standard.
The DESCRIPTION is updated to make it explicit that the floating-point environment is inherited from the creating thread.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/44 is applied, adding text that the alternate stack is not
inherited.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/93 is applied, updating the ERRORS section to remove the
mandatory [EINVAL] error ("The value specified by attr is invalid"), and adding the optional [EINVAL] error ("The
attributes specified by attr are invalid").
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/94 is applied, adding the APPLICATION USAGE section.
Issue 7
The pthread_create() function is moved from the Threads option to the Base.
The [EINVAL] error for an uninitialized thread attributes object is removed; this condition results in undefined behavior.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0458 [302] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0274 [849] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/tan.html =====
tan
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
tan, tanf, tanl — tangent function
SYNOPSIS
#include
double tan(double x);
float tanf(float x);
long double tanl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the tangent of their argument x, measured in radians.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the tangent of x.
If the correct value would cause underflow, [MXX]   and is not representable,   a range error may occur, and tan(), tanf(), and tanl() shall return
[MXX]
0.0, or   (if IEC 60559 Floating-Point is not supported)
an implementation-defined value no greater in magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, x shall be returned.
If x is ±Inf, a domain error shall occur, and either a NaN (if supported), or an implementation-defined value shall be
returned.
[MXX]
If x is subnormal, x should be returned.
[MX]  If x is subnormal, a range error may occur and, if x is
not returned, tan(), tanf(), and tanl() shall return an implementation-defined value no greater in magnitude
than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
[MXX]
If the correct value would cause underflow, and is representable, a range error may occur and the correct value shall be returned.
[XSI]
If the correct value would cause overflow, a range error shall occur and tan(), tanf(), and tanl() shall
return ±HUGE_VAL, ±HUGE_VALF, and ±HUGE_VALL, respectively, with the same sign as the correct value of the function.
ERRORS
These functions shall fail if:
Domain Error
[MX]
The value of x is ±Inf.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
Range Error
[XSI]
The result overflows
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
These functions may fail if:
Range Error
The result underflows, [MX]   or the value of x is subnormal.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
Taking the Tangent of a 45-Degree Angle
#include
...
double radians = 45.0 * M_PI / 180;
double result;
...
result = tan (radians);
APPLICATION USAGE
There are no known floating-point representations such that for a normal argument, tan(x) is either overflow or
underflow.
These functions may lose accuracy when their argument is near a multiple of ℼ/2 or is far from 0.0.
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
atan(), feclearexcept(),
fetestexcept(), isnan()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The last two paragraphs of the DESCRIPTION were included as APPLICATION USAGE notes in previous issues.
Issue 6
The tanf() and tanl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/64 is applied, correcting the last paragraph in the RETURN VALUE
section.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0635 [68], XSH/TC1-2008/0636 [68], and XSH/TC1-2008/0637 [68] are
applied.
Issue 8
Austin Group Defect 1382 is applied, rearranging the text describing the behavior when x is subnormal to avoid the need
for two shading changes.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/printf.html =====
fprintf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
asprintf, dprintf, fprintf, printf, snprintf, sprintf — print formatted output
SYNOPSIS
#include
[CX]  int asprintf(char **restrict ptr, const char *restrict format,
...);
int dprintf(int fildes, const char *restrict format, ...);
int fprintf(FILE *restrict stream, const char *restrict format, ...);
int printf(const char *restrict format, ...);
int snprintf(char *restrict s, size_t n,
const char *restrict format, ...);
int sprintf(char *restrict s, const char *restrict format, ...);
DESCRIPTION
[CX]  Except for asprintf(), dprintf(), and the behavior of the %lc conversion when passed a null wide
character, the functionality described on this reference page is aligned with the ISO C standard. Any other conflict between
the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard for all fprintf(), printf(), snprintf(), and sprintf() functionality except in relation to the
%lc conversion when passed a null wide character.
The fprintf() function shall place output on the named output stream. The printf() function shall place
output on the standard output stream stdout. The sprintf() function shall place output followed by the null byte,
'\0', in consecutive bytes starting at *s; it is the user's responsibility to ensure that enough space is
available.
[CX]  The
asprintf() function shall be equivalent to sprintf(), except that the output string shall be written to dynamically
allocated memory, allocated as if by a call to malloc(), of sufficient length to hold
the resulting string, including a terminating null byte. If the call to asprintf() is successful, the address of this
dynamically allocated string shall be stored in the location referenced by ptr.
The dprintf() function shall be equivalent to the fprintf() function, except that dprintf() shall write
output to the file associated with the file descriptor specified by the fildes argument rather than place output on a
stream.
The snprintf() function shall be equivalent to sprintf(), with the addition of the n argument which limits
the number of bytes written to the buffer referred to by s. If n is zero, nothing shall be written and s may
be a null pointer. Otherwise, output bytes beyond the n-1st shall be discarded instead of being written to the array, and a
null byte is written at the end of the bytes actually written into the array.
If copying takes place between objects that overlap as a result of a call to sprintf() or snprintf(), the results
are undefined.
Each of these functions converts, formats, and prints its arguments under control of the format. The application shall
ensure that the format is a character string, beginning and ending in its initial shift state, if any. The format is composed of
zero or more directives: ordinary characters, which are simply copied to the output stream, and conversion
specifications, each of which shall result in the fetching of zero or more arguments. The results are undefined if there are
insufficient arguments for the format. If the format is exhausted while arguments remain, the excess arguments shall be evaluated
but are otherwise ignored.
[CX]
Conversions can be applied to the nth argument after the format in the argument list, rather than to the next unused
argument. In this case, the conversion specifier character % (see below) is replaced by the sequence
"%n$", where n is a decimal integer in the range [1,{NL_ARGMAX}], giving the position of the
argument in the argument list. This feature provides for the definition of format strings that select arguments in an order
appropriate to specific languages (see the EXAMPLES section).
The format can contain either numbered argument conversion specifications (that is, those introduced by
"%n$" and optionally containing the "*m$" forms of field width and precision), or
unnumbered argument conversion specifications (that is, those introduced by the % character and optionally containing the
* form of field width and precision), but not both. The only exception to this is that %% can be mixed with the
"%n$" form. The results of mixing numbered and unnumbered argument specifications in a format string are
undefined. When numbered argument specifications are used, specifying the Nth argument requires that all the leading
arguments, from the first to the (N-1)th, are specified in the format string.
In format strings containing the "%n$" form of conversion specification, numbered arguments in the
argument list can be referenced from the format string as many times as required.
In format strings containing the % form of conversion specification, each conversion specification uses the first
unused argument in the argument list.
[CX]  All
forms of the fprintf() functions allow for the insertion of a language-dependent radix character in the output string. The
radix character is defined in the current locale (category LC_NUMERIC ). In the POSIX locale, or in a locale where the radix
character is not defined, the radix character shall default to a  ('.').
Each conversion specification is introduced by the '%' character [CX]   or by the
character sequence "%n$",   after
which the following appear in sequence:
Zero or more flags (in any order), which modify the meaning of the conversion specification.
An optional minimum field width. If the converted value has fewer bytes than the field width, it shall be padded with
characters by default on the left; it shall be padded on the right if the left-adjustment flag ('-'),
described below, is given to the field width. The field width takes the form of an  ('*'), [CX]   or in
conversion specifications introduced by "%n$" the "*m$" string,  described below, or a decimal integer.
An optional precision that gives the minimum number of digits to appear for the d, i, o,
u, x, and X conversion specifiers; the number of digits to appear after the radix character for the
a, A, e, E, f, and F conversion specifiers; the maximum number of significant
digits for the g and G conversion specifiers; or the maximum number of bytes to be printed from a string in the
s [XSI]   and S   conversion specifiers. The
precision takes the form of a  ('.') followed either by an  ('*'), [CX]   or in
conversion specifications introduced by "%n$" the "*m$" string,  described below, or an optional decimal digit string, where a null digit
string is treated as zero. If a precision appears with any other conversion specifier, the behavior is undefined.
An optional length modifier that specifies the size of the argument.
A conversion specifier character that indicates the type of conversion to be applied.
A field width, or precision, or both, may be indicated by an  ('*'). In this case an argument of type
int supplies the field width or precision. Applications shall ensure that arguments specifying field width, or precision, or
both appear in that order before the argument, if any, to be converted. A negative field width is taken as a '-' flag
followed by a positive field width. A negative precision is taken as if the precision were omitted. [CX]   In format
strings containing conversion specifications introduced by "%n$", in addition to being indicated by the
decimal digit string, a field width may be indicated by the sequence "*m$" and precision by the sequence
".*m$", where m is a decimal integer in the range [1,{NL_ARGMAX}] giving the position in the
argument list (after the format argument) of an integer argument containing the field width or precision, for example:
printf("%1$d:%2$.*3$d:%4$.*3$d\n", hour, min, precision, sec);
The flag characters and their meanings are:
'
[CX]
(The .) The integer portion of the result of a decimal conversion (%i, %d, %u,
%f, %F, %g, or %G) shall be formatted with thousands' grouping characters. For other
conversions the behavior is undefined. The non-monetary grouping character is used.
-
The result of the conversion shall be left-justified within the field. The conversion is right-justified if this flag is not
specified.
+
The result of a signed conversion shall always begin with a sign ('+' or '-'). The conversion shall begin
with a sign only when a negative value is converted if this flag is not specified.
If the first character of a signed conversion is not a sign or if a signed conversion results in no characters, a
shall be prefixed to the result. This means that if the  and '+' flags both appear, the  flag
shall be ignored.
#
Specifies that the value is to be converted to an alternative form. For o conversion, it shall increase the precision,
if and only if necessary, to force the first digit of the result to be a zero (if the value and precision are both 0, a single 0 is
printed). For x or X conversion specifiers, a non-zero result shall have 0x (or 0X) prefixed to it. For
a, A, e, E, f, F, g, and G conversion specifiers, the
result shall always contain a radix character, even if no digits follow the radix character. Without this flag, a radix character
appears in the result of these conversions only if a digit follows it. For g and G conversion specifiers,
trailing zeros shall not be removed from the result as they normally are. For other conversion specifiers, the behavior is
undefined.
0
For d, i, o, u, x, X, a, A, e, E,
f, F, g, and G conversion specifiers, leading zeros (following any indication of sign or base)
are used to pad to the field width rather than performing space padding, except when converting an infinity or NaN. If the
'0' and '-' flags both appear, the '0' flag is ignored. For d, i, o,
u, x, and X conversion specifiers, if a precision is specified, the '0' flag shall be ignored.
[CX]
If the '0' and  flags both appear, the grouping characters are inserted before zero padding. For
other conversions, the behavior is undefined.
The length modifiers and their meanings are:
hh
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a signed char or unsigned char argument (the argument will have been promoted according to the integer
promotions, but its value shall be converted to signed char or unsigned char before printing); or that a following
n conversion specifier applies to a pointer to a signed char argument.
h
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a short or unsigned short argument (the argument will have been promoted according to the integer
promotions, but its value shall be converted to short or unsigned short before printing); or that a following
n conversion specifier applies to a pointer to a short argument.
l (ell)
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a long or unsigned long argument; that a following n conversion specifier applies to a pointer to
a long argument; that a following c conversion specifier applies to a wint_t argument; that a following
s conversion specifier applies to a pointer to a wchar_t argument; or has no effect on a following a,
A, e, E, f, F, g, or G conversion specifier.
ll (ell-ell)
Specifies that a following d, i, o, u, x, or X conversion specifier applies
to a long long or unsigned long long argument; or that a following n conversion specifier applies to a
pointer to a long long argument.
j
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to an intmax_t or uintmax_t argument; or that a following n conversion specifier applies to a
pointer to an intmax_t argument.
z
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a size_t or the corresponding signed integer type argument; or that a following n conversion specifier
applies to a pointer to a signed integer type corresponding to a size_t argument.
t
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a ptrdiff_t or the corresponding unsigned type argument; or that a following n conversion
specifier applies to a pointer to a ptrdiff_t argument.
L
Specifies that a following a, A, e, E, f, F, g, or G
conversion specifier applies to a long double argument.
If a length modifier appears with any conversion specifier other than as specified above, the behavior is undefined.
The conversion specifiers and their meanings are:
d, i
The int argument shall be converted to a signed decimal in the style "[-]dddd". The precision
specifies the minimum number of digits to appear; if the value being converted can be represented in fewer digits, it shall be
expanded with leading zeros. The default precision is 1. The result of converting zero with an explicit precision of zero shall be
no characters.
o
The unsigned argument shall be converted to unsigned octal format in the style "dddd". The
precision specifies the minimum number of digits to appear; if the value being converted can be represented in fewer digits, it
shall be expanded with leading zeros. The default precision is 1. The result of converting zero with an explicit precision of zero
shall be no characters.
u
The unsigned argument shall be converted to unsigned decimal format in the style "dddd". The
precision specifies the minimum number of digits to appear; if the value being converted can be represented in fewer digits, it
shall be expanded with leading zeros. The default precision is 1. The result of converting zero with an explicit precision of zero
shall be no characters.
x
The unsigned argument shall be converted to unsigned hexadecimal format in the style "dddd";
the letters "abcdef" are used. The precision specifies the minimum number of digits to appear; if the value being
converted can be represented in fewer digits, it shall be expanded with leading zeros. The default precision is 1. The result of
converting zero with an explicit precision of zero shall be no characters.
X
Equivalent to the x conversion specifier, except that letters "ABCDEF" are used instead of
"abcdef".
f, F
The double argument shall be converted to decimal notation in the style
"[-]ddd.ddd", where the number of digits after the radix character is equal to the
precision specification. If the precision is missing, it shall be taken as 6; if the precision is explicitly zero and no
'#' flag is present, no radix character shall appear. If a radix character appears, at least one digit appears before it.
The low-order digit shall be rounded in an implementation-defined manner.
A double argument representing an infinity shall be converted in one of the styles "[-]inf" or
"[-]infinity"; which style is implementation-defined. A double argument representing a NaN shall be converted in
one of the styles "[-]nan(n-char-sequence)" or "[-]nan"; which style, and the meaning of any
n-char-sequence, is implementation-defined. The F conversion specifier produces "INF",
"INFINITY", or "NAN" instead of "inf", "infinity", or "nan", respectively.
e, E
The double argument shall be converted in the style
"[-]d.ddde±dd", where there is one digit before the radix character (which
is non-zero if the argument is non-zero) and the number of digits after it is equal to the precision; if the precision is missing,
it shall be taken as 6; if the precision is zero and no '#' flag is present, no radix character shall appear. The
low-order digit shall be rounded in an implementation-defined manner. The E conversion specifier shall produce a number
with 'E' instead of 'e' introducing the exponent. The exponent shall always contain at least two digits. If the
value is zero, the exponent shall be zero.
A double argument representing an infinity or NaN shall be converted in the style of an f or F
conversion specifier.
g, G
The double argument representing a floating-point number shall be converted in the style f or e (or in
the style F or E in the case of a G conversion specifier), depending on the value converted and the
precision. Let P equal the precision if non-zero, 6 if the precision is omitted, or 1 if the precision is zero. Then, if a
conversion with style E would have an exponent of X:
If P>X>=-4, the conversion shall be with style f (or F) and precision
P-(X+1).
Otherwise, the conversion shall be with style e (or E) and precision P-1.
Finally, unless the '#' flag is used, any trailing zeros shall be removed from the fractional portion of the result and
the decimal-point character shall be removed if there is no fractional portion remaining.
A double argument representing an infinity or NaN shall be converted in the style of an f or F
conversion specifier.
a, A
A double argument representing a floating-point number shall be converted in the style
"[-]0xh.hhhhp±d", where there is one hexadecimal digit (which shall be
non-zero if the argument is a normalized floating-point number and is otherwise unspecified) before the decimal-point character and
the number of hexadecimal digits after it is equal to the precision; if the precision is missing and FLT_RADIX is a power of 2,
then the precision shall be sufficient for an exact representation of the value; if the precision is missing and FLT_RADIX is not a
power of 2, then the precision shall be sufficient to distinguish values of type double, except that trailing zeros may be
omitted; if the precision is zero and the '#' flag is not specified, no decimal-point character shall appear. The letters
"abcdef" shall be used for a conversion and the letters "ABCDEF" for A conversion. The
A conversion specifier produces a number with 'X' and 'P' instead of 'x' and 'p'. The
exponent shall always contain at least one digit, and only as many more digits as necessary to represent the decimal exponent of 2.
If the value is zero, the exponent shall be zero.
A double argument representing an infinity or NaN shall be converted in the style of an f or F
conversion specifier.
c
The int argument shall be converted to an unsigned char, and the resulting byte shall be written.
If an l (ell) qualifier is present, [CX]   the wint_t argument shall be converted to a multi-byte
sequence as if by a call to wcrtomb() with a pointer to storage of at least
MB_CUR_MAX bytes, the wint_t argument converted to wchar_t, and an initial shift state, and the resulting byte(s)
written.
s
The argument shall be a pointer to an array of char. Bytes from the array shall be written up to (but not including) any
terminating null byte. If the precision is specified, no more than that many bytes shall be written. If the precision is not
specified or is greater than the size of the array, the application shall ensure that the array contains a null byte.
If an l (ell) qualifier is present, the argument shall be a pointer to an array of type wchar_t. Wide characters
from the array shall be converted to characters (each as if by a call to the wcrtomb() function, with the conversion state described by an mbstate_t object
initialized to zero before the first wide character is converted) up to and including a terminating null wide character. The
resulting characters shall be written up to (but not including) the terminating null character (byte). If no precision is
specified, the application shall ensure that the array contains a null wide character. If a precision is specified, no more than
that many characters (bytes) shall be written (including shift sequences, if any), and the array shall contain a null wide
character if, to equal the character sequence length given by the precision, the function would need to access a wide character one
past the end of the array. In no case shall a partial character be written.
p
The argument shall be a pointer to void. The value of the pointer is converted to a sequence of printable characters, in
an implementation-defined manner.
n
The argument shall be a pointer to an integer into which is written the number of bytes written to the output so far by this
call to one of the fprintf() functions. No argument is converted.
C
[XSI]
Equivalent to lc.
S
[XSI]
Equivalent to ls.
%
Write a '%' character; no argument shall be converted. The application shall ensure that the complete conversion
specification is %%.
If a conversion specification does not match one of the above forms, the behavior is undefined. If any argument is not the
correct type for the corresponding conversion specification, the behavior is undefined.
In no case shall a nonexistent or small field width cause truncation of a field; if the result of a conversion is wider than the
field width, the field shall be expanded to contain the conversion result. Characters generated by fprintf() and
printf() are printed as if fputc() had been called.
For the a and A conversion specifiers, if FLT_RADIX is a power of 2, the value shall be correctly rounded to a
hexadecimal floating number with the given precision.
For a and A conversions, if FLT_RADIX is not a power of 2 and the result is not exactly representable in the
given precision, the result should be one of the two adjacent numbers in hexadecimal floating style with the given precision, with
the extra stipulation that the error should have a correct sign for the current rounding direction.
For the e, E, f, F, g, and G conversion specifiers, if the number of
significant decimal digits is at most DECIMAL_DIG, then the result should be correctly rounded. If the number of significant
decimal digits is more than DECIMAL_DIG but the source value is exactly representable with DECIMAL_DIG digits, then the result
should be an exact representation with trailing zeros. Otherwise, the source value is bounded by two adjacent decimal strings
L
#include
#include
#include
char *strperm (mode_t);
...
struct stat statbuf;
struct passwd *pwd;
struct group *grp;
...
printf("%10.10s", strperm (statbuf.st_mode));
printf("%4d", statbuf.st_nlink);
if ((pwd = getpwuid(statbuf.st_uid)) != NULL)
printf(" %-8.8s", pwd->pw_name);
else
printf(" %-8ld", (long) statbuf.st_uid);
if ((grp = getgrgid(statbuf.st_gid)) != NULL)
printf(" %-8.8s", grp->gr_name);
else
printf(" %-8ld", (long) statbuf.st_gid);
printf("%9jd", (intmax_t) statbuf.st_size);
...
Printing a Localized Date String
The following example gets a localized date string. The nl_langinfo()
function shall return the localized date string, which specifies the order and layout of the date. The strftime() function takes this information and, using the tm structure for values,
places the date and time information into datestring. The printf() function then outputs datestring and the
name of the entry.
#include
#include
#include
...
struct dirent *dp;
struct tm *tm;
char datestring[256];
...
strftime(datestring, sizeof(datestring), nl_langinfo (D_T_FMT), tm);
printf(" %s %s\n", datestring, dp->d_name);
...
Printing Error Information
The following example uses fprintf() to write error information to standard error.
In the first group of calls, the program tries to open the password lock file named LOCKFILE. If the file already exists,
this is an error, as indicated by the O_EXCL flag on the open() function. If the call
fails, the program assumes that someone else is updating the password file, and the program exits.
The next group of calls saves a new password file as the current password file by creating a link between LOCKFILE and
the new password file PASSWDFILE.
#include
#include
#include
#include
#include
#include
#include
#include
#define LOCKFILE "/etc/ptmp"
#define PASSWDFILE "/etc/passwd"
...
int pfd;
...
if ((pfd = open(LOCKFILE, O_WRONLY | O_CREAT | O_EXCL,
S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) == -1)
{
fprintf(stderr, "Cannot open /etc/ptmp. Try again later.\n");
exit(1);
}
...
if (link(LOCKFILE,PASSWDFILE) == -1) {
fprintf(stderr, "Link error: %s\n", strerror(errno));
exit(1);
}
...
Printing Usage Information
The following example checks to make sure the program has the necessary arguments, and uses fprintf() to print usage
information if the expected number of arguments is not present.
#include
#include
...
char *Options = "hdbtl";
...
if (argc  ('*') in the format
string; this ensures the correct number of decimal places for the element based on the number of elements requested.
#include
...
long i;
char *keystr;
int elementlen, len;
...
while (len
#include
#include
#include
#include
#include
...
char *pathname;
struct passwd *pw;
size_t len;
...
// digits required for pid_t is number of bits times
// log2(10) = approx 10/33
len = strlen(pw->pw_dir) + 1 + 1+(sizeof(pid_t)*80+32)/33 +
sizeof ".out";
pathname = malloc(len);
if (pathname != NULL)
{
snprintf(pathname, len, "%s/%jd.out", pw->pw_dir,
(intmax_t)getpid());
...
}
Reporting an Event
The following example loops until an event has timed out. The pause() function
waits forever unless it receives a signal. The fprintf() statement should never occur due to the possible return values of
pause().
#include
#include
#include
#include
...
while (!event_complete) {
...
if (pause() != -1 || errno != EINTR)
fprintf(stderr, "pause: unknown error: %s\n", strerror(errno));
}
...
Printing Monetary Information
The following example uses strfmon() to convert a number and store it as a
formatted monetary string named convbuf. If the first number is printed, the program prints the format and the description;
otherwise, it just prints the number.
#include
#include
...
struct tblfmt {
char *format;
char *description;
};
struct tblfmt table[] = {
{ "%n", "default formatting" },
{ "%11n", "right align within an 11 character field" },
{ "%#5n", "aligned columns for values up to 99999" },
{ "%=*#5n", "specify a fill character" },
{ "%=0#5n", "fill characters do not use grouping" },
{ "%^#5n", "disable the grouping separator" },
{ "%^#5.0n", "round off to whole units" },
{ "%^#5.4n", "increase the precision" },
{ "%(#5n", "use an alternative pos/neg style" },
{ "%!(#5n", "disable the currency symbol" },
};
...
float input[3];
int i, j;
char convbuf[100];
...
strfmon(convbuf, sizeof(convbuf), table[i].format, input[j]);
if (j == 0) {
printf("%s  %s      %s\n", table[i].format,
convbuf, table[i].description);
}
else {
printf("    %s\n", convbuf);
}
...
Printing Wide Characters
The following example prints a series of wide characters. Suppose that "L`@`" expands to three bytes:
wchar_t wz [3] = L"@@";       // Zero-terminated
wchar_t wn [3] = L"@@@";      // Unterminated
fprintf (stdout,"%ls", wz);   // Outputs 6 bytes
fprintf (stdout,"%ls", wn);   // Undefined because wn has no terminator
fprintf (stdout,"%4ls", wz);  // Outputs 3 bytes
fprintf (stdout,"%4ls", wn);  // Outputs 3 bytes; no terminator needed
fprintf (stdout,"%9ls", wz);  // Outputs 6 bytes
fprintf (stdout,"%9ls", wn);  // Outputs 9 bytes; no terminator needed
fprintf (stdout,"%10ls", wz); // Outputs 6 bytes
fprintf (stdout,"%10ls", wn); // Undefined because wn has no terminator
In the last line of the example, after processing three characters, nine bytes have been output. The fourth character must then
be examined to determine whether it converts to one byte or more. If it converts to more than one byte, the output is only nine
bytes. Since there is no fourth character in the array, the behavior is undefined.
APPLICATION USAGE
If the application calling fprintf() has any objects of type wint_t or wchar_t, it must also include the
header to have these objects defined.
The space allocated by a successful call to asprintf() should be subsequently freed by a call to free().
RATIONALE
If an implementation detects that there are insufficient arguments for the format, it is recommended that the function should
fail and report an [EINVAL] error.
The behavior specified for the %lc conversion differs slightly from the specification in the ISO C standard, in
that printing the null wide character produces a null byte instead of 0 bytes of output as would be required by a strict reading of
the ISO C standard's direction to behave as if applying the %ls specifier to a wchar_t array whose first
element is the null wide character. Requiring a multi-byte output for every possible wide character, including the null character,
matches historical practice, and provides consistency with %c in fprintf() and with both %c and
%lc in fwprintf(). It is anticipated that a future edition of the
ISO C standard will change to match the behavior specified here.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fputc(), fscanf(), setlocale(), strfmon(), strlcat(), wcrtomb(), wcslcat()
XBD 7. Locale, , ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
Aligned with ISO/IEC 9899:1990/Amendment 1:1995 (E). Specifically, the l (ell) qualifier can now be used with
c and s conversion specifiers.
The snprintf() function is new in Issue 5.
Issue 6
Extensions beyond the ISO C standard are marked.
The normative text is updated to avoid use of the term "must" for application requirements.
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The prototypes for fprintf(), printf(), snprintf(), and sprintf() are updated, and the XSI shading
is removed from snprintf().
The description of snprintf() is aligned with the ISO C standard. Note that this supersedes the snprintf()
description in The Open Group Base Resolution bwg98-006, which changed the behavior from Issue 5.
The DESCRIPTION is updated.
The DESCRIPTION is updated to use the terms "conversion specifier" and "conversion specification" consistently.
ISO/IEC 9899:1999 standard, Technical Corrigendum 1 is incorporated.
An example of printing wide characters is added.
Issue 7
Austin Group Interpretation 1003.1-2001 #161 is applied, updating the DESCRIPTION of the 0 flag.
Austin Group Interpretation 1003.1-2001 #170 is applied.
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #68 (SD5-XSH-ERN-70) is applied, revising the description of g
and G.
SD5-XSH-ERN-174 is applied.
The dprintf() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 1.
Functionality relating to the %n$ form of conversion specification and the  flag is moved from the
XSI option to the Base.
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0163 [302], XSH/TC1-2008/0164 [316], XSH/TC1-2008/0165 [316],
XSH/TC1-2008/0166 [451,291], and XSH/TC1-2008/0167 [14] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0126 [894], XSH/TC2-2008/0127 [557], and XSH/TC2-2008/0128 [936] are
applied.
Issue 8
Austin Group Defect 986 is applied, adding strlcat() and wcslcat() to the SEE ALSO section.
Austin Group Defect 1020 is applied, clarifying that the snprintf() argument n limits the number of bytes written
to s; it is not necessarily the same as the size of s.
Austin Group Defect 1021 is applied, changing "output error" to "error" in the RETURN VALUE section.
Austin Group Defect 1137 is applied, clarifying the use of "%n$" and "*m$" in
conversion specifications.
Austin Group Defect 1205 is applied, changing the description of the % conversion specifier.
Austin Group Defect 1219 is applied, removing the snprintf()-specific [EOVERFLOW] error.
Austin Group Defect 1496 is applied, adding the asprintf() function.
Austin Group Defect 1562 is applied, clarifying that it is the application's responsibility to ensure that the format is a
character string, beginning and ending in its initial shift state, if any.
Austin Group Defect 1647 is applied, changing the description of the c conversion specifier and updating the statement
that this volume of POSIX.1-2024 defers to the ISO C standard so that it excludes the %lc conversion when passed a
null wide character.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getenv.html =====
getenv
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getenv, secure_getenv — get value of an environment variable
SYNOPSIS
#include
char *getenv(const char *name);
[CX]  char *secure_getenv(const char *name);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The getenv() function shall search the environment of the calling process (see XBD 8. Environment Variables) for the environment variable name if it exists and
return a pointer to the value of the environment variable. If the specified environment variable cannot be found, a null pointer
shall be returned. The application shall ensure that it does not modify the string pointed to by the getenv() function,
[CX]
unless it is part of a modifiable object previously placed in the environment by assigning a new value to environ
[XSI]
or by using putenv().
[CX]  The
pointer returned by getenv() shall point to a string within the environment data pointed to by environ.
Note:
This requirement is an extension to the ISO C standard, which allows getenv() to copy the data to an internal
buffer.
The secure_getenv() function shall be equivalent to getenv(), except that it shall return a null pointer if the
calling process does not meet all of the following security criteria:
The effective user ID and real user ID of the calling process were equal during program startup.
The effective group ID and real group ID of the calling process were equal during program startup.
Additional implementation-defined security criteria.
RETURN VALUE
Upon successful completion, getenv() shall return a pointer to a string containing the value for the specified
name. If the specified name cannot be found in the environment of the calling process, a null pointer shall be
returned.
[CX]
Upon successful completion, secure_getenv() shall return a pointer to a string containing the value for the specified
name. If the specified name cannot be found in the environment of the calling process, or the calling process does
not meet the security criteria listed in DESCRIPTION, a null pointer shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
Getting the Value of an Environment Variable
The following example gets the value of the HOME environment variable.
#include
...
const char *name = "HOME";
char *value;
value = getenv(name);
APPLICATION USAGE
None.
RATIONALE
The clearenv() function was considered but rejected. The putenv() function
has now been included for alignment with the Single UNIX Specification.
Some earlier versions of this standard did not require getenv() to be thread-safe because it was allowed to return a
value pointing to an internal buffer. However, this behavior allowed by the ISO C standard is no longer allowed by POSIX.1.
POSIX.1 requires the environment data to be available through environ[], so there is no reason why getenv() can't
return a pointer to the actual data instead of a copy. Therefore getenv() is now required to be thread-safe (except when
another thread modifies the environment).
Conforming applications are required not to directly modify the pointers to which environ points, but to use only the
setenv(), unsetenv(), and putenv() functions, or assignment to environ itself, to manipulate the process
environment. This constraint allows the implementation to properly manage the memory it allocates. This enables the implementation
to free any space it has allocated to strings (and perhaps the pointers to them) stored in environ when unsetenv() is called. A C runtime start-up procedure (that which invokes main() and
perhaps initializes environ) can also initialize a flag indicating that none of the environment has yet been copied to
allocated storage, or that the separate table has not yet been initialized. If the application switches to a complete new
environment by assigning a new value to environ, this can be detected by getenv(), setenv(), unsetenv(), or putenv() and the implementation can at that point reinitialize based on the new environment.
(This may include copying the environment strings into a new array and assigning environ to point to it.)
In fact, for higher performance of getenv(), implementations that do not provide putenv() could also maintain a separate copy of the environment in a data structure that
could be searched much more quickly (such as an indexed hash table, or a binary tree), and update both it and the linear list at
environ when setenv() or unsetenv() is invoked. On implementations that do provide putenv(), such a copy might still be worthwhile but would need to allow for the fact that
applications can directly modify the content of environment strings added with putenv(). For example, if an environment string found by searching the copy is one that was
added using putenv(), the implementation would need to check that the string in
environ still has the same name (and value, if the copy includes values), and whenever searching the copy produces no match
the implementation would then need to search each environment string in environ that was added using putenv() in case any of them have changed their names and now match. Thus, each use of
putenv() to add to the environment would reduce the speed advantage of having the
copy.
Performance of getenv() can be important for applications which have large numbers of environment variables. Typically,
applications like this use the environment as a resource database of user-configurable parameters. The fact that these variables
are in the user's shell environment usually means that any other program that uses environment variables (such as ls, which attempts to use COLUMNS ), or really almost any utility (LANG , LC_ALL
, and so on) is similarly slowed down by the linear search through the variables.
An implementation that maintains separate data structures, or even one that manages the memory it consumes, is not currently
required as it was thought it would reduce consensus among implementors who do not want to change their historical
implementations.
FUTURE DIRECTIONS
None.
SEE ALSO
exec, putenv(), setenv(), unsetenv()
XBD 8. Environment Variables,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
Normative text previously in the APPLICATION USAGE section is moved to the RETURN VALUE section.
A note indicating that this function need not be reentrant is added to the DESCRIPTION.
Issue 6
The following changes were made to align with the IEEE P1003.1a draft standard:
References added to the new setenv() and unsetenv() functions.
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
Austin Group Interpretation 1003.1-2001 #062 is applied, clarifying that a call to putenv() may also cause the string to be overwritten.
Austin Group Interpretation 1003.1-2001 #148 is applied, adding the FUTURE DIRECTIONS.
Austin Group Interpretation 1003.1-2001 #156 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0238 [75,428], XSH/TC1-2008/0239 [167], and XSH/TC1-2008/0240 [167] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0157 [656] is applied.
Issue 8
Austin Group Defects 188 and 1394 are applied, changing getenv() to be thread-safe.
Austin Group Defect 922 is applied, adding the secure_getenv() function.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strcasecmp_l.html =====
strcasecmp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strcasecmp, strcasecmp_l, strncasecmp, strncasecmp_l — case-insensitive string comparisons
SYNOPSIS
#include
int strcasecmp(const char *s1, const char *s2);
int strcasecmp_l(const char *s1, const char *s2,
locale_t locale);
int strncasecmp(const char *s1, const char *s2, size_t n);
int strncasecmp_l(const char *s1, const char *s2,
size_t n, locale_t locale);
DESCRIPTION
The strcasecmp() and strcasecmp_l() functions shall compare, while ignoring differences in case, the string
pointed to by s1 to the string pointed to by s2. The strncasecmp() and strncasecmp_l() functions shall
compare, while ignoring differences in case, not more than n bytes from the string pointed to by s1 to the string
pointed to by s2.
The strcasecmp() and strncasecmp() functions use the current locale to determine the case of the characters.
The strcasecmp_l() and strncasecmp_l() functions use the locale represented by locale to determine the case
of the characters.
When the LC_CTYPE category of the locale being used is from the POSIX locale, these functions shall behave as if the
strings had been converted to lowercase and then a byte comparison performed, and errno shall not be changed on valid input.
Otherwise, the results are unspecified.
The behavior is undefined if the locale argument to strcasecmp_l() or strncasecmp_l() is the special locale
object LC_GLOBAL_LOCALE or is not a valid locale object handle.
RETURN VALUE
Upon completion, strcasecmp() and strcasecmp_l() shall return an integer greater than, equal to, or less than 0,
if the string pointed to by s1 is, ignoring case, greater than, equal to, or less than the string pointed to by s2,
respectively.
Upon successful completion, strncasecmp() and strncasecmp_l() shall return an integer greater than, equal to, or
less than 0, if the possibly null-terminated array pointed to by s1 is, ignoring case, greater than, equal to, or less than
the possibly null-terminated array pointed to by s2, respectively.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
wcscasecmp()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 7
The strcasecmp() and strncasecmp() functions are moved from the XSI option to the Base.
The strcasecmp_l() and strncasecmp_l() functions are added from The Open Group Technical Standard, 2006, Extended
API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0589 [302], XSH/TC1-2008/0590 [294], XSH/TC1-2008/0591 [283], and
XSH/TC1-2008/0592 [283] are applied.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that errno is not changed on valid input.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/swscanf.html =====
fwscanf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fwscanf, swscanf, wscanf — convert formatted wide-character input
SYNOPSIS
#include
#include
int fwscanf(FILE *restrict stream, const wchar_t *restrict format, ...);
int swscanf(const wchar_t *restrict ws,
const wchar_t *restrict format, ...);
int wscanf(const wchar_t *restrict format, ...);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The fwscanf() function shall read from the named input stream. The wscanf() function shall read from the
standard input stream stdin. The swscanf() function shall read from the wide-character string ws. Each
function reads wide characters, interprets them according to a format, and stores the results in its arguments. Each expects, as
arguments, a control wide-character string format described below, and a set of pointer arguments indicating where
the converted input should be stored. The result is undefined if there are insufficient arguments for the format. If the
format is exhausted while arguments remain, the excess arguments are evaluated but are otherwise ignored.
[CX]
Conversions can be applied to the nth argument after the format in the argument list, rather than to the next unused
argument. In this case, the conversion specifier wide character % (see below) is replaced by the sequence "%n$",
where n is a decimal integer in the range [1,{NL_ARGMAX}]. This feature provides for the definition of format
wide-character strings that select arguments in an order appropriate to specific languages. In format wide-character strings
containing the "%n$" form of conversion specifications, it is unspecified whether numbered arguments in
the argument list can be referenced from the format wide-character string more than once.
The format can contain either form of a conversion specification—that is, % or "%n$"—
but the two forms cannot normally be mixed within a single format wide-character string. The only exception to this is that
%% or %* can be mixed with the "%n$" form. When numbered argument specifications are
used, specifying the Nth argument requires that all the leading arguments, from the first to the (N-1)th, are
pointers.
The fwscanf() function in all its forms allows for detection of a language-dependent radix character in the input string,
encoded as a wide-character value. The radix character is defined in the current locale (category LC_NUMERIC ). In the POSIX
locale, or in a locale where the radix character is not defined, the radix character shall default to a
('.').
The format is a wide-character string composed of zero or more directives. Each directive is composed of one of the
following: one or more white-space wide characters; an ordinary wide character (neither '%' nor a white-space wide
character); or a conversion specification. It is unspecified whether an encoding error occurs if the format string contains
wchar_t values that do not correspond to members of the character set of the current locale and the specified semantics do
not require that value to be processed by wcrtomb().
Each conversion specification is introduced by the '%' [CX]
or by the character sequence
"%n$",   after which the following
appear in sequence:
An optional assignment-suppressing character '*'.
An optional non-zero decimal integer that specifies the maximum field width.
[CX]  An
optional assignment-allocation character 'm'.
An optional length modifier that specifies the size of the receiving object.
A conversion specifier wide character that specifies the type of conversion to be applied. The valid conversion specifiers are
described below.
The fwscanf() functions shall execute each directive of the format in turn. When all directives have been executed, or if
a directive fails (as detailed below), the function shall return. Failures are described as input failures (due to the
unavailability of input bytes) or matching failures (due to inappropriate input).
A directive composed of one or more white-space wide characters shall be executed by reading input up to the first wide
character that is not a white-space wide character, which shall remain unread, or until no more wide characters can be read. The
directive shall never fail.
A directive that is an ordinary wide character shall be executed as follows. The next wide character is read from the input and
compared with the wide character that comprises the directive; if the comparison shows that they are not equivalent, the directive
shall fail, and the differing and subsequent wide characters remain unread. Similarly, if end-of-file, an encoding error, or a read
error prevents a wide character from being read, the directive shall fail.
A directive that is a conversion specification defines a set of matching input sequences, as described below for each conversion
wide character. A conversion specification is executed in the following steps.
Input white-space wide characters shall be skipped, unless the conversion specification includes a [, c, or
n conversion specifier.
An item shall be read from the input, unless the conversion specification includes an n conversion specifier wide
character. An input item is defined as the longest sequence of input wide characters, not exceeding any specified field width,
which is an initial subsequence of a matching sequence. The first wide character, if any, after the input item shall remain unread.
If the length of the input item is zero, the execution of the conversion specification shall fail; this condition is a matching
failure, unless end-of-file, an encoding error, or a read error prevented input from the stream, in which case it is an input
failure.
Except in the case of a % conversion specifier, the input item (or, in the case of a %n conversion
specification, the count of input wide characters) shall be converted to a type appropriate to the conversion wide character. If
the input item is not a matching sequence, the execution of the conversion specification shall fail; this condition is a matching
failure. Unless assignment suppression was indicated by a '*', the result of the conversion shall be placed in the object
pointed to by the first argument following the format argument that has not already received a conversion result if the
conversion specification is introduced by %, [CX]   or in the nth argument if introduced by the wide-character
sequence "%n$".   If this object does
not have an appropriate type, or if the result of the conversion cannot be represented in the space provided, the behavior is
undefined.
[CX]  The
c, s, and [ conversion specifiers shall accept an optional assignment-allocation character 'm',
which shall cause a memory buffer to be allocated to hold the conversion results. If the conversion specifier is s or
[, the allocated buffer shall include space for a terminating null character (or wide character). In such a case, the
argument corresponding to the conversion specifier should be a reference to a pointer value that will receive a pointer to the
allocated buffer. The system shall allocate a buffer as if malloc() had been called.
The application shall be responsible for freeing the memory after usage. If there is insufficient memory to allocate a buffer, the
function shall set errno to [ENOMEM] and a conversion error shall result. If the function returns EOF, any memory
successfully allocated for parameters using assignment-allocation character 'm' by this call shall be freed before the
function returns.
The length modifiers and their meanings are:
hh
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to signed char or unsigned char.
h
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to short or unsigned short.
l (ell)
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to long or unsigned long; that a following a, A,
e, E, f, F, g, or G conversion specifier applies to an argument with type
pointer to double; or that a following c, s, or [ conversion specifier applies to an argument
with type pointer to wchar_t. [CX]   If the 'm' assignment-allocation character is specified, the conversion applies to
an argument with the type pointer to a pointer to wchar_t.
ll (ell-ell)
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to long long or unsigned long long.
j
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to intmax_t or uintmax_t.
z
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to size_t or the corresponding signed integer type.
t
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to ptrdiff_t or the corresponding unsigned type.
L
Specifies that a following a, A, e, E, f, F, g, or G
conversion specifier applies to an argument with type pointer to long double.
If a length modifier appears with any conversion specifier other than as specified above, the behavior is undefined.
The following conversion specifier wide characters are valid:
d
Matches an optionally signed decimal integer, whose format is the same as expected for the subject sequence of wcstol() with the value 10 for the base argument. In the absence of a size modifier,
the application shall ensure that the corresponding argument is a pointer to int.
i
Matches an optionally signed integer, whose format is the same as expected for the subject sequence of wcstol() with 0 for the base argument. In the absence of a size modifier, the
application shall ensure that the corresponding argument is a pointer to int.
o
Matches an optionally signed octal integer, whose format is the same as expected for the subject sequence of wcstoul() with the value 8 for the base argument. In the absence of a size modifier,
the application shall ensure that the corresponding argument is a pointer to unsigned.
u
Matches an optionally signed decimal integer, whose format is the same as expected for the subject sequence of wcstoul() with the value 10 for the base argument. In the absence of a size modifier,
the application shall ensure that the corresponding argument is a pointer to unsigned.
x
Matches an optionally signed hexadecimal integer, whose format is the same as expected for the subject sequence of wcstoul() with the value 16 for the base argument. In the absence of a size modifier,
the application shall ensure that the corresponding argument is a pointer to unsigned.
a, e, f, g
Matches an optionally signed floating-point number, infinity, or NaN whose format is the same as expected for the subject sequence
of wcstod(). In the absence of a size modifier, the application shall ensure that the
corresponding argument is a pointer to float.
If the fwprintf() family of functions generates character string representations
for infinity and NaN (a symbolic entity encoded in floating-point format) to support IEEE Std 754-1985, the
fwscanf() family of functions shall recognize them as input.
s
Matches a sequence of non-white-space wide characters. If no l (ell) qualifier is present, characters from the input
field shall be converted as if by repeated calls to the wcrtomb() function, with the
conversion state described by an mbstate_t object initialized to zero before the first wide character is converted. If the
'm' assignment-allocation character is not specified, the application shall ensure that the corresponding argument is a
pointer to a character array large enough to accept the sequence and the terminating null character, which shall be added
automatically. [CX]   Otherwise, the application shall ensure that the corresponding argument is a pointer to a pointer to a
char.
If the l (ell) qualifier is present and the 'm' assignment-allocation character is not specified, the
application shall ensure that the corresponding argument is a pointer to an array of wchar_t large enough to accept the
sequence and the terminating null wide character, which shall be added automatically. [CX]   If the
l (ell) qualifier is present and the 'm' assignment-allocation character is present, the application shall ensure
that the corresponding argument is a pointer to a pointer to a wchar_t.
[
Matches a non-empty sequence of wide characters from a set of expected wide characters (the scanset). If no l
(ell) qualifier is present, wide characters from the input field shall be converted as if by repeated calls to the wcrtomb() function, with the conversion state described by an mbstate_t object
initialized to zero before the first wide character is converted. If the 'm' assignment-allocation character is not
specified, the application shall ensure that the corresponding argument is a pointer to a character array large enough to accept
the sequence and the terminating null character, which shall be added automatically. [CX]   Otherwise, the
application shall ensure that the corresponding argument is a pointer to a pointer to a char.
If an l (ell) qualifier is present and the 'm' assignment-allocation character is not specified, the
application shall ensure that the corresponding argument is a pointer to an array of wchar_t large enough to accept the
sequence and the terminating null wide character. [CX]   If an l (ell) qualifier is present and the 'm'
assignment-allocation character is specified, the application shall ensure that the corresponding argument is a pointer to a
pointer to a wchar_t.
The conversion specification includes all subsequent wide characters in the format string up to and including the
matching  (']'). The wide characters between the square brackets (the scanlist)
comprise the scanset, unless the wide character after the  is a  ('^'), in
which case the scanset contains all wide characters that do not appear in the scanlist between the  and the
. If the conversion specification begins with "[]" or "[^]", the
is included in the scanlist and the next  is the matching
that ends the conversion specification; otherwise, the first  is the one
that ends the conversion specification. If a '-' is in the scanlist and is not the first wide character, nor the second
where the first wide character is a '^', nor the last wide character, the behavior is implementation-defined.
c
Matches a sequence of wide characters of exactly the number specified by the field width (1 if no field width is present in the
conversion specification).
If no l (ell) length modifier is present, characters from the input field shall be converted as if by repeated calls to
the wcrtomb() function, with the conversion state described by an mbstate_t
object initialized to zero before the first wide character is converted. No null character is added. If the 'm'
assignment-allocation character is not specified, the application shall ensure that the corresponding argument is a pointer to the
initial element of a character array large enough to accept the sequence. [CX]
Otherwise, the application shall ensure that the
corresponding argument is a pointer to a pointer to a char.
No null wide character is added. If an l (ell) length modifier is present and the 'm' assignment-allocation
character is not specified, the application shall ensure that the corresponding argument shall be a pointer to the initial element
of an array of wchar_t large enough to accept the sequence. [CX]
If an l (ell) qualifier is present and the
'm' assignment-allocation character is specified, the application shall ensure that the corresponding argument is a
pointer to a pointer to a wchar_t.
p
Matches an implementation-defined set of sequences, which shall be the same as the set of sequences that is produced by the
%p conversion specification of the corresponding fwprintf() functions. The
application shall ensure that the corresponding argument is a pointer to a pointer to void. The interpretation of the input
item is implementation-defined. If the input item is a value converted earlier during the same program execution, the pointer that
results shall compare equal to that value; otherwise, the behavior of the %p conversion is undefined.
n
No input is consumed. The application shall ensure that the corresponding argument is a pointer to the integer into which is to
be written the number of wide characters read from the input so far by this call to the fwscanf() functions. Execution of a
%n conversion specification shall not increment the assignment count returned at the completion of execution of the
function. No argument shall be converted, but one shall be consumed. If the conversion specification includes an
assignment-suppressing wide character or a field width, the behavior is undefined.
C
[XSI]
Equivalent to lc.
S
[XSI]
Equivalent to ls.
%
Matches a single '%' wide character; no conversion or assignment shall occur. The complete conversion specification
shall be %%.
If a conversion specification is invalid, the behavior is undefined.
The conversion specifiers A, E, F, G, and X are also valid and shall be equivalent
to, respectively, a, e, f, g, and x.
If end-of-file is encountered during input, conversion is terminated. If end-of-file occurs before any wide characters matching
the current conversion specification (except for %n) have been read (other than leading white-space wide characters, where
permitted), execution of the current conversion specification shall terminate with an input failure. Otherwise, unless execution of
the current conversion specification is terminated with a matching failure, execution of the following conversion specification (if
any) shall be terminated with an input failure.
Reaching the end of the string in swscanf() shall be equivalent to encountering end-of-file for fwscanf().
If conversion terminates on a conflicting input, the offending input shall be left unread in the input. Any trailing white-space
wide characters (including ) shall be left unread unless matched by a conversion specification. The success of
literal matches and suppressed assignments is only directly determinable via the %n conversion specification.
[CX]  The
fwscanf() and wscanf() functions may mark the last data access timestamp of the file associated with stream
for update. The last data access timestamp shall be marked for update by the first successful execution of fgetwc(), fgetws(), fwscanf(), getwc(), getwchar(), vfwscanf(), vwscanf(), or wscanf()
using stream that returns data not supplied by a prior call to ungetwc().
RETURN VALUE
Upon successful completion, these functions shall return the number of successfully matched and assigned input items; this
number can be zero in the event of an early matching failure. If the input ends before the first conversion (if any) has completed,
and without a matching failure having occurred, EOF shall be returned. If an error occurs before the first conversion (if any) has
completed, and without a matching failure having occurred, EOF shall be returned [CX]   and
errno shall be set to indicate the error.   If a read
error occurs, the error indicator for the stream shall be set.
ERRORS
For the conditions under which the fwscanf() functions shall fail and may fail, refer to fgetwc().
In addition, the fwscanf() function shall fail if:
[EILSEQ]
[CX]
Input byte sequence does not form a valid character.
[ENOMEM]
Insufficient storage space is available.
In addition, the fwscanf() function may fail if:
[EINVAL]
[CX]
There are insufficient arguments.
The following sections are informative.
EXAMPLES
The call:
int i, n; float x; char name[50];
n = wscanf(L"%d%f%s", &i, &x, name);
with the input line:
25 54.32E-1 Hamster
assigns to n the value 3, to i the value 25, to x the value 5.432, and name contains the string
"Hamster".
The call:
int i; float x; char name[50];
(void) wscanf(L"%2d%f%*d %[0123456789]", &i, &x, name);
with input:
56789 0123 56a72
assigns 56 to i, 789.0 to x, skips 0123, and places the string "56\0" in name. The next call to
getchar() shall return the character 'a'.
APPLICATION USAGE
In format strings containing the '%' form of conversion specifications, each argument in the argument list is used
exactly once.
For functions that allocate memory as if by malloc(), the application should
release such memory when it is no longer required by a call to free(). For
fwscanf(), this is memory allocated via use of the 'm' assignment-allocation character.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, getwc(), fwprintf(), setlocale(), wcstod(), wcstol(), wcstoul(), wcrtomb()
XBD 7. Locale, , ,
CHANGE HISTORY
First released in Issue 5. Included for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E).
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The prototypes for fwscanf() and swscanf() are updated.
The DESCRIPTION is updated.
The hh, ll, j, t, and z length modifiers are added.
The a, A, and F conversion characters are added.
The DESCRIPTION is updated to use the terms "conversion specifier" and "conversion specification" consistently.
Issue 7
Austin Group Interpretation 1003.1-2001 #170 is applied.
SD5-XSH-ERN-132 is applied, adding the assignment-allocation character 'm'.
Functionality relating to the "%n$" form of conversion specification is moved from the XSI option to the Base.
Changes are made related to support for finegrained timestamps.
The APPLICATION USAGE section is updated to clarify that memory is allocated as if by malloc().
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0229 [302] and XSH/TC1-2008/0230 [14] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0148 [73], XSH/TC2-2008/0149 [823], and XSH/TC2-2008/0150 [936] are
applied.
Issue 8
Austin Group Defect 1163 is applied, clarifying the handling of white space in the format string.
Austin Group Defect 1173 is applied, clarifying the description of the assignment-allocation character 'm'.
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1375 is applied, changing "terminating null wide character" to "terminating null character (or wide
character)" and changing the first occurrence of wchar_t in the descriptions of the s and [ conversion
specifiers to char.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/isnormal.html =====
isnormal
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
isnormal — test for a normal value
SYNOPSIS
#include
int isnormal(real-floating x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The isnormal() macro shall determine whether its argument value is normal (neither zero, subnormal, infinite, nor NaN).
First, an argument represented in a format wider than its semantic type is converted to its semantic type. Then determination is
based on the type of the argument.
RETURN VALUE
The isnormal() macro shall return a non-zero value if and only if its argument has a normal value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
fpclassify(), isfinite(),
isinf(), isnan(), signbit()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/endnetent.html =====
endnetent
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
endnetent, getnetbyaddr, getnetbyname, getnetent, setnetent — network database functions
SYNOPSIS
#include
void endnetent(void);
struct netent *getnetbyaddr(uint32_t net, int type);
struct netent *getnetbyname(const char *name);
struct netent *getnetent(void);
void setnetent(int stayopen);
DESCRIPTION
These functions shall retrieve information about networks. This information is considered to be stored in a database that can be
accessed sequentially or randomly. The implementation of this database is unspecified.
The setnetent() function shall open and rewind the database. If the stayopen argument is non-zero, the connection
to the net database shall not be closed after each call to getnetent() (either directly, or indirectly through one of
the other getnet*() functions), and the implementation may maintain an open file descriptor to the database. If a file
descriptor is used, the FD_CLOEXEC flag shall be set; see .
The getnetent() function shall read the next entry of the database, opening and closing a connection to the database as
necessary.
The getnetbyaddr() function shall search the database from the beginning, and find the first entry for which the address
family specified by type matches the n_addrtype member and the network number net matches the n_net
member, opening and closing a connection to the database as necessary. The net argument shall be the network number in host
byte order.
The getnetbyname() function shall search the database from the beginning and find the first entry for which the network
name specified by name matches the n_name member, opening and closing a connection to the database as necessary.
The getnetbyaddr(), getnetbyname(), and getnetent() functions shall each return a pointer to a
netent structure, the members of which shall contain the fields of an entry in the network database.
The endnetent() function shall close the database, releasing any open file descriptor.
These functions need not be thread-safe.
RETURN VALUE
Upon successful completion, getnetbyaddr(), getnetbyname(), and getnetent() shall return a pointer to a
netent structure if the requested entry was found, and a null pointer if the end of the database was reached or the
requested entry was not found. Otherwise, a null pointer shall be returned.
The application shall not modify the structure to which the return value points, nor any storage areas pointed to by pointers
within the structure. The returned pointer, and pointers within the structure, might be invalidated or the structure or the storage
areas might be overwritten by a subsequent call to getnetbyaddr(), getnetbyname(), or getnetent(). The
returned pointer, and pointers within the structure, might also be invalidated if the calling thread is terminated.
ERRORS
The getnetbyaddr(), getnetbyname(), getnetent(), and setnetent() functions may fail if:
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum allowable number of files is currently open in the system.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0083 [75] and XSH/TC1-2008/0084 [75] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0090 [656] is applied.
Issue 8
Austin Group Defect 368 is applied, adding a requirement for FD_CLOEXEC to be set if a file descriptor is used, and adding the
[EMFILE] and [ENFILE] errors.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/flockfile.html =====
flockfile
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
flockfile, ftrylockfile, funlockfile — stdio locking functions
SYNOPSIS
[CX]  #include
void flockfile(FILE *file);
int ftrylockfile(FILE *file);
void funlockfile(FILE *file);
DESCRIPTION
These functions shall provide for explicit application-level locking of the locks associated with standard I/O streams (see
2.5 Standard I/O Streams). These functions can be used by a thread to
delineate a sequence of I/O statements that are executed as a unit.
The flockfile() function shall acquire for a thread ownership of a (FILE *) object.
The ftrylockfile() function shall acquire for a thread ownership of a (FILE *) object if the object is available;
ftrylockfile() is a non-blocking version of flockfile().
The funlockfile() function shall relinquish the ownership granted to the thread. The behavior is undefined if a thread
other than the current owner calls the funlockfile() function.
The functions shall behave as if there is a lock count associated with each (FILE *) object. This count is implicitly
initialized to zero when the (FILE *) object is created. The (FILE *) object is unlocked when the count is zero. When
the count is positive, a single thread owns the (FILE *) object. When the flockfile() function is called, if the
count is zero or if the count is positive and the caller owns the (FILE *) object, the count shall be incremented.
Otherwise, the calling thread shall be suspended, waiting for the count to return to zero. Each call to funlockfile() shall
decrement the count. This allows matching calls to flockfile() (or successful calls to ftrylockfile()) and
funlockfile() to be nested.
RETURN VALUE
None for flockfile() and funlockfile().
The ftrylockfile() function shall return zero for success and non-zero to indicate that the lock cannot be acquired.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications using these functions may be subject to priority inversion, as discussed in XBD 3.275 Priority Inversion.
A call to exit() can block until locked streams are unlocked because a thread having
ownership of a (FILE*) object blocks all function calls that reference that (FILE*) object (except those with names
ending in _unlocked) from other threads, including calls to exit().
Note: a FILE lock is not a file lock (see XBD 3.143 File Lock
).
RATIONALE
The flockfile() and funlockfile() functions provide an orthogonal mutual-exclusion lock for each FILE. The
ftrylockfile() function provides a non-blocking attempt to acquire a FILE lock, analogous to pthread_mutex_trylock().
These locks behave as if they are the same as those used internally by stdio for thread-safety. This both provides
thread-safety of these functions without requiring a second level of internal locking and allows functions in stdio to be
implemented in terms of other stdio functions.
Application developers and implementors should be aware that there are potential deadlock problems on FILE objects. For
example, the line-buffered flushing semantics of stdio (requested via {_IOLBF}) require that certain input operations
sometimes cause the buffered contents of implementation-defined line-buffered output streams to be flushed. If two threads each
hold the lock on the other's FILE, deadlock ensues. This type of deadlock can be avoided by acquiring FILE locks in a
consistent order. In particular, the line-buffered output stream deadlock can typically be avoided by acquiring locks on input
streams before locks on output streams if a thread would be acquiring both.
In summary, threads sharing stdio streams with other threads can use flockfile() and funlockfile() to cause
sequences of I/O performed by a single thread to be kept bundled. The only case where the use of flockfile() and
funlockfile() is required is to provide a scope protecting uses of the *_unlocked functions/macros. This moves the
cost/performance tradeoff to the optimal point.
FUTURE DIRECTIONS
None.
SEE ALSO
exit(), getc_unlocked()
XBD 3.275 Priority Inversion,
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
These functions are marked as part of the Thread-Safe Functions option.
Issue 7
The flockfile(), ftrylockfile(), and funlockfile() functions are moved from the Thread-Safe Functions
option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0140 [118] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0116 [611] is applied.
Issue 8
Austin Group Defect 1118 is applied, clarifying that a FILE lock is not a file lock.
Austin Group Defect 1302 is applied, replacing parts of the text with a reference to 2.5 Standard I/O Streams.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/dup3.html =====
dup
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
dup, dup2, dup3 — duplicate an open file descriptor
SYNOPSIS
#include
int dup(int fildes);
int dup2(int fildes, int fildes2);
int dup3(int fildes, int fildes2, int flag);
DESCRIPTION
The dup() function provides an alternative interface to the service provided by fcntl() using the F_DUPFD command. The call dup(fildes) shall be equivalent
to:
fcntl(fildes, F_DUPFD, 0);
The dup2() function shall cause the file descriptor fildes2 to refer to the same open file description as the file
descriptor fildes and to share any locks, and shall return fildes2. If fildes2 is already a valid open file
descriptor, it shall be closed first, unless fildes is equal to fildes2 in which case dup2() shall return
fildes2 without closing it. If the close operation fails to close fildes2, dup2() shall return -1 without
changing the open file description to which fildes2 refers. If fildes is not a valid file descriptor, dup2()
shall return -1 and shall not close fildes2. If fildes2 is less than 0 or greater than or equal to {OPEN_MAX},
dup2() shall return -1 with errno set to [EBADF].
Upon successful completion, if fildes is not equal to fildes2, the FD_CLOEXEC and FD_CLOFORK flags associated with
fildes2 shall be cleared. If fildes is equal to fildes2, the FD_CLOEXEC and FD_CLOFORK flags associated with
fildes2 shall not be changed.
The dup3() function shall be equivalent to the dup2() function, except that it shall be an error if fildes
is equal to fildes2, and the state of FD_CLOEXEC and FD_CLOFORK on the fildes2 file descriptor shall be determined
solely by the flag argument, which can be constructed from a bitwise-inclusive OR of flags from the following list:
O_CLOEXEC
Atomically set the FD_CLOEXEC flag on fildes2.
O_CLOFORK
Atomically set the FD_CLOFORK flag on fildes2.
[TYM]
If fildes refers to a typed memory object, the result of the dup2() or dup3() functions is unspecified.
RETURN VALUE
Upon successful completion a non-negative integer, namely the file descriptor, shall be returned; otherwise, -1 shall be
returned and errno set to indicate the error.
ERRORS
The dup() function shall fail if:
[EBADF]
The fildes argument is not a valid open file descriptor.
[EMFILE]
All file descriptors available to the process are currently open.
The dup2() and dup3() functions shall fail if:
[EBADF]
The fildes argument is not a valid open file descriptor or the argument fildes2 is negative or greater than or
equal to {OPEN_MAX}.
[EINTR]
The function was interrupted by a signal.
The dup3() function shall fail if:
[EINVAL]
The fildes and fildes2 arguments are equal.
The dup2() and dup3() functions may fail if:
[EIO]
An I/O error occurred while attempting to close fildes2.
The dup3() function may fail if:
[EINVAL]
The value of the flag argument is invalid.
The following sections are informative.
EXAMPLES
Redirecting Standard Output to a File
The following example closes standard output for the current processes, re-assigns standard output to go to the file referenced
by pfd, and closes the original file descriptor to clean up.
#include
...
int pfd;
...
close(1);
dup(pfd);
close(pfd);
...
Redirecting Error Messages
The following example redirects messages from stderr to stdout.
#include
...
dup2(1, 2);
...
APPLICATION USAGE
Implementations may use file descriptors that must be inherited into child processes for the child process to remain conforming,
such as for message catalog or tracing purposes. Therefore, an application that calls dup2() with an arbitrary integer for
fildes2 risks non-conforming behavior, and dup2() can only portably be used to overwrite file descriptor values that
the application has obtained through explicit actions, or for the three file descriptors corresponding to the standard file
streams. In order to avoid a race condition of leaking an unintended file descriptor into a child process or executed program, an
application should consider opening all file descriptors with the FD_CLOFORK or FD_CLOEXEC flag, or both flags, set unless the file
descriptor is intended to be inherited by child processes or executed programs, respectively.
RATIONALE
The dup() function is redundant. Its services are also provided by the fcntl() function. It has been included in this volume of POSIX.1-2024 primarily for historical
reasons, since many existing applications use it. On the other hand, the dup2() function provides unique services, as no
other interface is able to atomically replace an existing file descriptor.
The dup2() function is not marked obsolescent because it presents a type-safe version of functionality provided in a
type-unsafe version by fcntl(). It is used in the POSIX Ada binding.
The dup2() function is not intended for use in critical regions as a synchronization mechanism.
In the description of [EBADF], the case of fildes being out of range is covered by the given case of fildes not
being valid. The descriptions for fildes and fildes2 are different because the only kind of invalidity that is
relevant for fildes2 is whether it is out of range; that is, it does not matter whether fildes2 refers to an open
file when the dup2() call is made.
The dup3() function with the O_CLOEXEC and O_CLOFORK flags is necessary to avoid a data race in multi-threaded
applications. Without O_CLOFORK, a file descriptor is leaked into a child process created by one thread in the window between
another thread creating a file descriptor with dup2() and then using fcntl() to
set the FD_CLOFORK flag. Without O_CLOEXEC, a file descriptor intentionally inherited by child processes is similarly leaked into
an executed program if FD_CLOEXEC is not set atomically. The safe counterpart for avoiding the same race with dup() is the
use of the F_DUPFD_CLOFORK or F_DUPFD_CLOEXEC action of the fcntl() function.
FUTURE DIRECTIONS
None.
SEE ALSO
close(), fcntl(), open()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 7
SD5-XSH-ERN-187 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0075 [149,428] and XSH/TC1-2008/0076 [149] are applied.
Issue 8
Austin Group Defects 411, 1318, 1483, and 1577 are applied, adding dup3() and FD_CLOFORK.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcstoumax.html =====
wcstoimax
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcstoimax, wcstoumax — convert a wide-character string to an integer type
SYNOPSIS
#include
#include
intmax_t wcstoimax(const wchar_t *restrict nptr,
wchar_t **restrict endptr, int base);
uintmax_t wcstoumax(const wchar_t *restrict nptr,
wchar_t **restrict endptr, int base);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall be equivalent to the wcstol(), wcstoll(), wcstoul(), and wcstoull() functions, respectively, except that the initial portion of the wide string
shall be converted to intmax_t and uintmax_t representation, respectively.
RETURN VALUE
These functions shall return the converted value, if any.
If no conversion could be performed, zero shall be returned. If the correct value is outside the range of representable values,
{INTMAX_MAX}, {INTMAX_MIN}, or {UINTMAX_MAX} shall be returned (according to the return type and sign of the value, if any), and
errno shall be set to [ERANGE].
ERRORS
These functions shall fail if:
[EINVAL]
The value of base is not supported.
[ERANGE]
The value to be returned is not representable.
These functions may fail if:
[EINVAL]
No conversion could be performed.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
wcstol(), wcstoul()
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/isatty.html =====
isatty
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
isatty — test for a terminal device
SYNOPSIS
#include
int isatty(int fildes);
DESCRIPTION
The isatty() function shall test whether fildes, an open file descriptor, is associated with a terminal
device.
RETURN VALUE
The isatty() function shall return 1 if fildes is associated with a terminal; otherwise, it shall return 0 and may
set errno to indicate the error.
ERRORS
The isatty() function may fail if:
[EBADF]
The fildes argument is not a valid open file descriptor.
[ENOTTY]
The file associated with the fildes argument is not a terminal.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The isatty() function does not necessarily indicate that a human being is available for interaction via fildes. It
is quite possible that non-terminal devices are connected to the communications line.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The optional setting of errno to indicate an error is added.
The [EBADF] and [ENOTTY] optional error conditions are added.
Issue 7
SD5-XSH-ERN-100 is applied, correcting the definition of the [ENOTTY] error condition.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atomic_signal_fence.html =====
atomic_signal_fence
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atomic_signal_fence, atomic_thread_fence — fence operations
SYNOPSIS
#include
void atomic_signal_fence(memory_order order);
void atomic_thread_fence(memory_order order);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
Implementations that define the macro __STDC_NO_ATOMICS__ need not provide the  header nor support these generic functions.
The atomic_signal_fence() and atomic_thread_fence() functions provide synchronization primitives called
fences. Fences can have acquire semantics, release semantics, or both. A fence with acquire semantics is called an
acquire fence; a fence with release semantics is called a release fence.
A release fence A synchronizes with an acquire fence B if there exist atomic operations X and Y,
both operating on some atomic object M, such that A is sequenced before X, X modifies M,
Y is sequenced before B, and Y reads the value written by X or a value written by any side effect in
the hypothetical release sequence X would head if it were a release operation.
A release fence A synchronizes with an atomic operation B that performs an acquire operation on an atomic object
M if there exists an atomic operation X such that A is sequenced before X, X modifies M,
and B reads the value written by X or a value written by any side effect in the hypothetical release sequence
X would head if it were a release operation.
An atomic operation A that is a release operation on an atomic object M synchronizes with an acquire fence
B if there exists some atomic operation X on M such that X is sequenced before B and reads the
value written by A or a value written by any side effect in the release sequence headed by A.
Depending on the value of order, the operation performed by atomic_thread_fence() shall:
have no effects, if order is equal to memory_order_relaxed;
be an acquire fence, if order is equal to memory_order_acquire or memory_order_consume;
be a release fence, if order is equal to memory_order_release;
be both an acquire fence and a release fence, if order is equal to memory_order_acq_rel;
be a sequentially consistent acquire and release fence, if order is equal to memory_order_seq_cst.
The atomic_signal_fence() function shall be equivalent to atomic_thread_fence(), except that the resulting
ordering constraints shall be established only between a thread and a signal handler executed in the same thread.
RETURN VALUE
These functions shall not return a value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The atomic_signal_fence() function can be used to specify the order in which actions performed by the thread become
visible to the signal handler. Implementation reorderings of loads and stores are inhibited in the same way as with
atomic_thread_fence(), but the hardware fence instructions that atomic_thread_fence() would have inserted are not
emitted.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD 4.15.1 Memory Ordering,
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/thrd_detach.html =====
thrd_detach
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
thrd_detach — detach a thread
SYNOPSIS
#include
int thrd_detach(thrd_t thr);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The thrd_detach() function shall change the thread thr from joinable to detached, indicating to the implementation
that any resources allocated to the thread can be reclaimed when that thread terminates. The application shall ensure that the
thread identified by thr has not been previously detached or joined with another thread.
[CX]  The
thrd_detach() function shall not be affected if the calling thread executes a signal handler during the call.
RETURN VALUE
The thrd_detach() function shall return thrd_success on success or thrd_error if the request could not
be honored.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The thrd_detach() function is not affected by signal handlers for the reasons stated in XRAT B.2.3 Error Numbers.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_detach(), thrd_create(), thrd_join()
XBD
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mkstemp.html =====
mkdtemp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mkdtemp, mkostemp, mkstemp — create a unique directory or file
SYNOPSIS
[CX]  #include
char *mkdtemp(char *template);
int mkostemp(char *template, int flag);
int mkstemp(char *template);
DESCRIPTION
The mkdtemp() function shall create a directory with a unique name derived from template. The application shall
ensure that the string provided in template is a pathname ending with at least six trailing 'X' characters. The
mkdtemp() function shall modify the contents of template by replacing six or more 'X' characters at the end
of the pathname with the same number of characters from the portable filename character set. The characters shall be chosen such
that the resulting pathname does not duplicate the name of an existing file at the time of the call to mkdtemp(). The
mkdtemp() function shall use the resulting pathname to create the new directory as if by a call to:
mkdir(pathname, S_IRWXU)
The mkstemp() function shall create a regular file with a unique name derived from template and return a file
descriptor for the file open for reading and writing. The application shall ensure that the string provided in template is a
pathname ending with at least six trailing 'X' characters. The mkstemp() function shall modify the contents of
template by replacing six or more 'X' characters at the end of the pathname with the same number of characters from
the portable filename character set. The characters shall be chosen such that the resulting pathname does not duplicate the name of
an existing file at the time of the call to mkstemp(). The mkstemp() function shall use the resulting pathname to
create the file, and obtain a file descriptor for it, as if by a call to:
open(pathname, O_RDWR|O_CREAT|O_EXCL, S_IRUSR|S_IWUSR)
By behaving as if the O_EXCL flag for open() is set, the function prevents any
possible race condition between testing whether the file exists and opening it for use.
The mkostemp() function shall be equivalent to the mkstemp() function, except that the flag argument can
contain additional flags to be used as if by open(). Behavior is unspecified if the
flag argument contains more than the following flags:
O_APPEND
Set append mode.
O_CLOEXEC
Set the FD_CLOEXEC file descriptor flag.
O_CLOFORK
Set the FD_CLOFORK file descriptor flag.
O_DSYNC
[SIO]
Write according to the synchronized I/O data integrity completion.
O_RSYNC
[SIO]
Synchronized read I/O operations.
O_SYNC
[XSI|SIO]  Write according to synchronized I/O file integrity completion.
RETURN VALUE
Upon successful completion, the mkdtemp() function shall return the value of template. Otherwise, it shall return
a null pointer and shall set errno to indicate the error.
Upon successful completion, the mkstemp() function shall return an open file descriptor. Otherwise, it shall return -1
and shall set errno to indicate the error.
ERRORS
These functions shall fail if:
[EINVAL]
The string pointed to by template does not end in "XXXXXX".
The mkostemp() function may fail if:
[EINVAL]
The value of the flag argument is invalid.
Additional error conditions for the mkdtemp() function are defined in mkdir(). Additional error conditions for the mkstemp() and
mkostemp() functions are defined in open().
The following sections are informative.
EXAMPLES
Generating a Pathname
The following example creates a file with a 10-character name beginning with the characters "file" and opens the file
for reading and writing. The value returned as the value of fd is a file descriptor that identifies the file.
#include
...
char template[] = "/tmp/fileXXXXXX";
int fd;
fd = mkstemp(template);
APPLICATION USAGE
It is possible to run out of letters.
Portable applications should pass exactly six trailing 'X's in the template and no more; implementations may treat any
additional trailing 'X's as either a fixed or replaceable part of the template. To be sure of only passing six, a fixed
string of at least one non-'X' character should precede the six 'X's.
Since 'X' is in the portable filename character set, some of the replacement characters can be 'X's, leaving
part (or even all) of the template effectively unchanged.
RATIONALE
The O_CLOEXEC and O_CLOFORK flags of mkostemp() are necessary to avoid a data race in multi-threaded applications.
Without O_CLOFORK, a file descriptor is leaked into a child process created by one thread in the window between another thread
creating a temporary file descriptor with mkstemp() and then using fcntl() to
set the FD_CLOFORK flag. Without O_CLOEXEC, a temporary file descriptor intentionally inherited by child processes is similarly
leaked into an executed program if FD_CLOEXEC is not set atomically.
Implementations are encouraged to have mkdtemp(), mkostemp(), and mkstemp() report an [EILSEQ] error if the
last component of the pathname in template contains any bytes that have the encoded value of a
character.
FUTURE DIRECTIONS
None.
SEE ALSO
getpid(), mkdir(),
open(), tmpfile(), tmpnam()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 7
Austin Group Interpretation 1003.1-2001 #143 is applied.
SD5-XSH-ERN-168 is applied, clarifying file permissions upon creation.
The mkstemp() function is moved from the XSI option to the Base.
The mkdtemp() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 1.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0380 [291], XSH/TC1-2008/0381 [324], and XSH/TC1-2008/0382 [291] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0215 [567,669] is applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defects 411, 1318, and 1350 are applied, adding mkostemp().
Austin Group Defect 652 is applied, adding the [EINVAL] error for mkstemp().
Austin Group Defect 1734 is applied, replacing the error conditions specified only for mkdtemp() with a reference to
mkdir().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/umask.html =====
umask
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
umask — set and get the file mode creation mask
SYNOPSIS
#include
mode_t umask(mode_t cmask);
DESCRIPTION
The umask() function shall set the file mode creation mask of the process to cmask and return the previous value
of the mask. Only the file permission bits of cmask (see ) shall be used; [XSI]   the S_ISVTX
bit shall be ignored, and   the meaning of the other bits is
implementation-defined.
The file mode creation mask of the process is used to turn off permission bits in the mode argument supplied during calls
to the following functions:
open(), openat(), creat(), mkdir(), mkdirat(), mkfifo(), and mkfifoat()
[XSI]
mknod(), mknodat()
[MSG]
mq_open()
sem_open()
Permission bit positions that are set in cmask are cleared in the mode of the created file.
RETURN VALUE
The file permission bits in the value returned by umask() shall be the previous value of the file mode creation mask.
[XSI]
The S_ISVTX bit in the returned value shall be clear.
The state of any other bits in the returned value is unspecified, except that a subsequent call to umask() with the
returned value as cmask shall leave the state of the mask the same as its state before the first call, including any
unspecified use of those bits.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
Unsigned argument and return types for umask() were proposed. The return type and the argument were both changed to
mode_t.
Historical implementations have made use of additional bits in cmask for their implementation-defined purposes. The
addition of the text that the meaning of other bits of the field is implementation-defined permits these implementations to conform
to this volume of POSIX.1-2024.
FUTURE DIRECTIONS
None.
SEE ALSO
creat(), exec, mkdir(), mkfifo(), mknod(), mq_open(), open(), sem_open()
XBD ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
In the SYNOPSIS, the optional include of the  header is
removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/143 is applied, adding the mknod(), mq_open(), and sem_open() functions to the DESCRIPTION and SEE ALSO sections.
Issue 8
Austin Group Defect 1522 is applied, adding requirements relating to the S_ISVTX bit.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getpwnam.html =====
getpwnam
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getpwnam, getpwnam_r — search user database for a name
SYNOPSIS
#include
struct passwd *getpwnam(const char *name);
int getpwnam_r(const char *name, struct passwd *pwd, char *buffer,
size_t bufsize, struct passwd **result);
DESCRIPTION
The getpwnam() function shall search the user database for an entry with a matching name.
The getpwnam() function need not be thread-safe.
Applications wishing to check for error situations should set errno to 0 before calling getpwnam(). If
getpwnam() returns a null pointer and errno is non-zero, an error occurred.
The getpwnam_r() function shall update the passwd structure pointed to by pwd and store a pointer to that
structure at the location pointed to by result. The structure shall contain an entry from the user database with a matching
name. Storage referenced by the structure is allocated from the memory provided with the buffer parameter, which is
bufsize bytes in size. A call to sysconf(_SC_GETPW_R_SIZE_MAX) returns either -1 without changing errno or an
initial value suggested for the size of this buffer. A null pointer shall be returned at the location pointed to by result
on error or if the requested entry is not found.
RETURN VALUE
The getpwnam() function shall return a pointer to a struct passwd with the structure as defined in  with a matching entry if found. A null pointer shall be returned if the requested
entry is not found, or an error occurs. If the requested entry was not found, errno shall not be changed. On error,
errno shall be set to indicate the error.
The application shall not modify the structure to which the return value points, nor any storage areas pointed to by pointers
within the structure. The returned pointer, and pointers within the structure, might be invalidated or the structure or the storage
areas might be overwritten by a subsequent call to getpwent(), getpwnam(),
or getpwuid(). The returned pointer, and pointers within the structure, might also
be invalidated if the calling thread is terminated.
The getpwnam_r() function shall return zero on success or if the requested entry was not found and no error has occurred.
If an error has occurred, an error number shall be returned to indicate the error.
ERRORS
These functions may fail if:
[EIO]
An I/O error has occurred.
[EINTR]
A signal was caught during getpwnam().
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum allowable number of files is currently open in the system.
The getpwnam_r() function shall fail if:
[ERANGE]
Insufficient storage was supplied via buffer and bufsize to contain the data to be referenced by the resulting
passwd structure.
The following sections are informative.
EXAMPLES
Note that sysconf(_SC_GETPW_R_SIZE_MAX) may return -1 if there is no hard limit on the size of the buffer needed to store
all the groups returned. This example shows how an application can allocate a buffer of sufficient size to work with
getpwnam_r().
long int initlen = sysconf(_SC_GETPW_R_SIZE_MAX);
size_t len;
if (initlen == -1)
/* Default initial length. */
len = 1024;
else
len = (size_t) initlen;
struct passwd result;
struct passwd *resultp;
char *buffer = malloc(len);
if (buffer == NULL)
...handle error...
int e;
while ((e = getpwnam_r("someuser", &result, buffer, len, &resultp))
== ERANGE)
{
size_t newlen = 2 * len;
if (newlen
#include
#include
#include
#include
...
char *lgn;
struct passwd *pw;
...
if ((lgn = getlogin()) == NULL || (pw = getpwnam(lgn)) == NULL) {
fprintf(stderr, "Get of user information failed.\n"); exit(1);
}
...
APPLICATION USAGE
Three names associated with the current process can be determined: getpwuid(geteuid()) returns the name associated with the effective user ID of the process; getlogin() returns the name associated with the current login activity; and
getpwuid(getuid()) returns the name associated with the real user ID of the
process.
The getpwnam_r() function is thread-safe and returns values in a user-supplied buffer instead of possibly using a static
data area that may be overwritten by each call.
Portable applications should take into account that it is usual for an implementation to return -1 from sysconf() indicating that there is no maximum for _SC_GETPW_R_SIZE_MAX.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
getpwuid(), sysconf()
XBD ,
CHANGE HISTORY
First released in Issue 1. Derived from System V Release 2.0.
Issue 5
Normative text previously in the APPLICATION USAGE section is moved to the RETURN VALUE section.
The getpwnam_r() function is included for alignment with the POSIX Threads Extension.
A note indicating that the getpwnam() function need not be reentrant is added to the DESCRIPTION.
Issue 6
The getpwnam_r() function is marked as part of the Thread-Safe Functions option.
The Open Group Corrigendum U028/3 is applied, correcting text in the DESCRIPTION describing matching the name.
In the SYNOPSIS, the optional include of the  header is
removed.
In the DESCRIPTION, the note about reentrancy is expanded to cover thread-safety.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
In the RETURN VALUE section, the requirement to set errno on error is added.
The [EMFILE], [ENFILE], and [ENXIO] optional error conditions are added.
The APPLICATION USAGE section is updated to include a note on the thread-safe function and its avoidance of possibly using a
static data area.
IEEE PASC Interpretation 1003.1 #116 is applied, changing the description of the size of the buffer from bufsize
characters to bytes.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
SD5-XBD-ERN-4 is applied, changing the definition of the [EMFILE] error.
SD5-XSH-ERN-166 is applied.
The getpwnam_r() function is moved from the Thread-Safe Functions option to the Base.
A minor addition is made to the EXAMPLES section, reminding the application developer to free memory allocated as if by malloc().
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0255 [75,428] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0170 [808] and XSH/TC2-2008/0171 [656] are applied.
Issue 8
Austin Group Defect 398 is applied, changing the [ERANGE] error from "may fail" to "shall fail".
Austin Group Defect 1570 is applied, removing extra spacing in "==".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/hdestroy.html =====
hcreate
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
hcreate, hdestroy, hsearch — manage hash search table
SYNOPSIS
[XSI]  #include
int hcreate(size_t nel);
void hdestroy(void);
ENTRY *hsearch(ENTRY item, ACTION action);
DESCRIPTION
The hcreate(), hdestroy(), and hsearch() functions shall manage hash search tables.
The hcreate() function shall allocate sufficient space for the table, and the application shall ensure it is called
before hsearch() is used. The nel argument is an estimate of the maximum number of entries that the table shall
contain. This number may be adjusted upward by the algorithm in order to obtain certain mathematically favorable circumstances.
The hdestroy() function shall dispose of the search table, and may be followed by another call to hcreate(). After
the call to hdestroy(), the data can no longer be considered accessible.
The hsearch() function is a hash-table search routine. It shall return a pointer into a hash table indicating the
location at which an entry can be found. The item argument is a structure of type ENTRY (defined in the  header) containing two pointers: item.key points to the comparison
key (a char *), and item.data (a void *) points to any other data to be associated with that key. The
comparison function used by hsearch() is strcmp(). The action argument
is a member of an enumeration type ACTION indicating the disposition of the entry if it cannot be found in the table. ENTER
indicates that the item should be inserted in the table at an appropriate point. FIND indicates that no entry should be made.
Unsuccessful resolution is indicated by the return of a null pointer.
These functions need not be thread-safe.
RETURN VALUE
The hcreate() function shall return 0 if it cannot allocate sufficient space for the table; otherwise, it shall return
non-zero.
The hdestroy() function shall not return a value.
The hsearch() function shall return a null pointer if either the action is FIND and the item could not be found or the
action is ENTER and the table is full.
ERRORS
The hcreate() and hsearch() functions may fail if:
[ENOMEM]
Insufficient storage space is available.
The following sections are informative.
EXAMPLES
The following example reads in strings followed by two numbers and stores them in a hash table, discarding duplicates. It then
reads in strings and finds the matching entry in the hash table and prints it out.
#include
#include
#include
struct info {        /* This is the info stored in the table */
int age, room;   /* other than the key. */
};
#define NUM_EMPL    5000    /* # of elements in search table. */
int main(void)
{
char string_space[NUM_EMPL*20];   /* Space to store strings. */
struct info info_space[NUM_EMPL]; /* Space to store employee info. */
char *str_ptr = string_space;     /* Next space in string_space. */
struct info *info_ptr = info_space;
/* Next space in info_space. */
ENTRY item;
ENTRY *found_item; /* Name to look for in table. */
char name_to_find[30];
int i = 0;
/* Create table; no error checking is performed. */
(void) hcreate(NUM_EMPL);
while (scanf("%s%d%d", str_ptr, &info_ptr->age,
&info_ptr->room) != EOF && i++ key,
((struct info *)found_item->data)->age,
((struct info *)found_item->data)->room);
} else
(void)printf("no such employee %s\n", name_to_find);
}
return 0;
}
APPLICATION USAGE
The hcreate() and hsearch() functions may use malloc() to allocate
space.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
bsearch(), lsearch(), malloc(), strcmp(), tdelete()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
A note indicating that this function need not be reentrant is added to the DESCRIPTION.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getutxent.html =====
endutxent
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
endutxent, getutxent, getutxid, getutxline, pututxline, setutxent — user accounting database functions
SYNOPSIS
[XSI]  #include
void endutxent(void);
struct utmpx *getutxent(void);
struct utmpx *getutxid(const struct utmpx *id);
struct utmpx *getutxline(const struct utmpx *line);
struct utmpx *pututxline(const struct utmpx *utmpx);
void setutxent(void);
DESCRIPTION
These functions shall provide access to the user accounting database.
The getutxent() function shall read the next entry from the user accounting database. If the database is not already
open, it shall open it. If it reaches the end of the database, it shall fail.
The getutxid() function shall search forward from the current point in the database. If the ut_type value of the
utmpx structure pointed to by id is BOOT_TIME, OLD_TIME, or NEW_TIME, then it shall stop when it finds an entry with
a matching ut_type value. If the ut_type value is INIT_PROCESS, LOGIN_PROCESS, USER_PROCESS, or DEAD_PROCESS, then it
shall stop when it finds an entry whose type is one of these four and whose ut_id member matches the ut_id member of
the utmpx structure pointed to by id. If the end of the database is reached without a match, getutxid() shall
fail.
The getutxline() function shall search forward from the current point in the database until it finds an entry of the type
LOGIN_PROCESS or USER_PROCESS which also has a ut_line value matching that in the utmpx structure pointed to by
line. If the end of the database is reached without a match, getutxline() shall fail.
The getutxid() or getutxline() function may cache data. For this reason, to use getutxline() to search for
multiple occurrences, the application shall zero out the static data after each success, or getutxline() may return a
pointer to the same utmpx structure.
There is one exception to the rule about clearing the structure before further reads are done. The implicit read done by
pututxline() (if it finds that it is not already at the correct place in the user accounting database) shall not modify the
static structure returned by getutxent(), getutxid(), or getutxline(), if the application has modified this
structure and passed the pointer back to pututxline().
For all entries that match a request, the ut_type member indicates the type of the entry. Other members of the entry
shall contain meaningful data based on the value of the ut_type member as follows:
ut_type Member
Other Members with Meaningful Data
EMPTY
No others
BOOT_TIME
ut_tv
OLD_TIME
ut_tv
NEW_TIME
ut_tv
USER_PROCESS
ut_id, ut_user (login name of the user), ut_line, ut_pid, ut_tv
INIT_PROCESS
ut_id, ut_pid, ut_tv
LOGIN_PROCESS
ut_id, ut_user (implementation-defined name of the login process), ut_line, ut_pid,
ut_tv
DEAD_PROCESS
ut_id, ut_pid, ut_tv
An implementation that provides extended security controls may impose implementation-defined restrictions on
accessing the user accounting database. In particular, the system may deny the existence of some or all of the user accounting
database entries associated with users other than the caller.
If the process has appropriate privileges, the pututxline() function shall write out the structure into the
user accounting database. It shall search for a record as if by getutxid() that satisfies the request. If this search
succeeds, then the entry shall be replaced. Otherwise, a new entry shall be made at the end of the user accounting database.
The endutxent() function shall close the user accounting database.
The setutxent() function shall reset the input to the beginning of the database. This should be done before
each search for a new entry if it is desired that the entire database be examined.
These functions need not be thread-safe.
RETURN VALUE
Upon successful completion, getutxent(), getutxid(), and getutxline() shall return a pointer to a
utmpx structure containing a copy of the requested entry in the user accounting database. Otherwise, a null pointer shall be
returned.
The return value may point to a static area which is overwritten by a subsequent call to getutxid() or
getutxline().
Upon successful completion, pututxline() shall return a pointer to a utmpx structure containing a
copy of the entry added to the user accounting database. Otherwise, a null pointer shall be returned.
The endutxent() and setutxent() functions shall not return a value.
ERRORS
No errors are defined for the endutxent(), getutxent(), getutxid(), getutxline(), and
setutxent() functions.
The pututxline() function may fail if:
[EPERM]
The process does not have appropriate privileges.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The sizes of the arrays in the structure can be found using the sizeof operator.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Normative text previously in the APPLICATION USAGE section is moved to the DESCRIPTION.
A note indicating that these functions need not be reentrant is added to the DESCRIPTION.
Issue 6
In the DESCRIPTION, the note about reentrancy is expanded to cover thread-safety.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0090 [213,428] and XSH/TC1-2008/0091 [213] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/signal.html =====
signal
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
signal — signal management
SYNOPSIS
#include
void (*signal(int sig, void (*func)(int)))(int);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The signal() function chooses one of three ways in which receipt of the signal number sig is to be subsequently
handled. If the value of func is SIG_DFL, default handling for that signal shall occur. If the value of func is
SIG_IGN, the signal shall be ignored. Otherwise, the application shall ensure that func points to a function to be called
when that signal occurs. An invocation of such a function because of a signal, or (recursively) of any further functions called by
that invocation (other than functions in the standard library), is called a "signal handler".
When a signal occurs, and func points to a function, it is implementation-defined whether the equivalent of a:
signal(sig, SIG_DFL);
is executed or the implementation prevents some implementation-defined set of signals (at least including sig) from
occurring until the current signal handling has completed. (If the value of sig is SIGILL, the implementation may
alternatively define that no action is taken.) Next the equivalent of:
(*func)(sig);
is executed. If and when the function returns, if the value of sig was SIGFPE, SIGILL, or SIGSEGV or any other
implementation-defined value corresponding to a computational exception, the behavior is undefined. Otherwise, the program shall
resume execution at the point it was interrupted. The ISO C standard places a restriction on applications relating to the use
of raise() from signal handlers. [CX]   This
restriction does not apply to POSIX applications, as POSIX.1-2024 requires raise() to
be async-signal-safe (see 2.4.3 Signal Actions).
[CX]  If
the process is multi-threaded,   or if the process is
single-threaded and a signal handler is executed other than as the result of:
The process calling abort(), raise(),
[CX]
kill(), pthread_kill(), or sigqueue()   to
generate a signal that is not blocked
[CX]  A
pending signal being unblocked and being delivered before the call that unblocked it returns
the behavior is undefined if:
The signal handler refers to any object [CX]   other than errno   with static or thread storage duration that is not a lock-free atomic object, [CX]   and not a
non-modifiable object (for example, string literals, objects that were defined with a const-qualified type, and objects in memory
that is mapped read-only),   other than by assigning a value to
an object declared as volatile sig_atomic_t, [CX]   unless the previous modification (if any) to the object happens
before the signal handler is called and the return from the signal handler happens before the next modification (if any) to the
object.
The signal handler calls any function defined in this standard other than [CX]   one of the
functions listed in 2.4 Signal Concepts.
At program start-up, the equivalent of:
signal(sig, SIG_IGN);
is executed for some signals, and the equivalent of:
signal(sig, SIG_DFL);
is executed for all other signals [CX]   (see exec).
The signal() function shall not change the setting of errno if successful.
[CX]  The
signal() function is required to be thread-safe. (See 2.9.1
Thread-Safety.)
RETURN VALUE
If the request can be honored, signal() shall return the value of func for the most recent call to signal()
for the specified signal sig. Otherwise, SIG_ERR shall be returned and a positive value shall be stored in errno.
ERRORS
The signal() function shall fail if:
[EINVAL]
[CX]
The sig argument is not a valid signal number or an attempt is made to catch a signal that cannot be caught or ignore a
signal that cannot be ignored.
The signal() function may fail if:
[EINVAL]
[CX]  An
attempt was made to set the action to SIG_DFL for a signal that cannot be caught or ignored (or both).
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The sigaction() function provides a more comprehensive and reliable mechanism
for controlling signals; new applications should use sigaction() rather than
signal().
RATIONALE
The ISO C standard says that the use of signal() in a multi-threaded program results in undefined behavior. However,
POSIX.1 has required signal() to be thread-safe since before threads were added to the ISO C standard.
FUTURE DIRECTIONS
None.
SEE ALSO
2.4 Signal Concepts, exec, pause(), raise(), sigaction(), sigsuspend(), waitid()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
The DESCRIPTION is updated to indicate that the sigpause() function restores the signal mask of the process to its
original state before returning.
The RETURN VALUE section is updated to indicate that the sigpause() function suspends execution of the process until a
signal is received, whereupon it returns -1 and sets errno to [EINTR].
Issue 6
Extensions beyond the ISO C standard are marked.
The normative text is updated to avoid use of the term "must" for application requirements.
The DESCRIPTION is updated for alignment with the ISO/IEC 9899:1999 standard.
References to the wait3() function are removed.
The sighold(), sigignore(), sigrelse(), and sigset() functions are split out onto their own
reference page.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0580 [275], XSH/TC1-2008/0581 [66], and XSH/TC1-2008/0582 [105] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0331 [785] is applied.
Issue 8
Austin Group Defect 728 is applied, reducing the set of circumstances in which undefined behavior results when a signal handler
refers to an object with static or thread storage duration.
Austin Group Defect 1302 is applied, aligning this function with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/truncl.html =====
trunc
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
trunc, truncf, truncl — round to truncated integer value
SYNOPSIS
#include
double trunc(double x);
float truncf(float x);
long double truncl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall round their argument to the integer value, in floating format, nearest to but no larger in magnitude than
the argument.
[MX]
These functions may raise the inexact floating-point exception for finite non-integer arguments.
RETURN VALUE
Upon successful completion, these functions shall return the truncated integer value.
[MX]  The
returned value shall be exact, shall be independent of the current rounding direction mode, and shall have the same sign as
x.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0 or ±Inf, x shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The integral value returned by these functions need not be expressible as an intmax_t. The return value should be tested
before assigning it to an integer type to avoid the undefined results of an integer overflow.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0684 [346] is applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wait.html =====
wait
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wait, waitpid — wait for a child process to stop or terminate
SYNOPSIS
#include
pid_t wait(int *stat_loc);
pid_t waitpid(pid_t pid, int *stat_loc, int options);
DESCRIPTION
The wait() and waitpid() functions shall obtain status information (see 2.12 Status Information) pertaining to one of the caller's child processes. The
wait() function obtains status information for process termination from any child process. The waitpid() function
obtains status information for process termination, and optionally process stop and/or continue, from a specified subset of the
child processes.
The wait() function shall cause the calling thread to become blocked until status information generated by child process
termination is made available to the thread, or until delivery of a signal whose action is either to execute a signal-catching
function or to terminate the process, or an error occurs. If termination status information is available prior to the call to
wait(), return shall be immediate. If termination status information is available for two or more child processes, the order
in which their status is reported is unspecified.
As described in 2.12 Status Information, the wait() and
waitpid() functions consume the status information they obtain.
The behavior when multiple threads are blocked in wait(), waitid(), or
waitpid() is described in 2.12 Status Information.
The waitpid() function shall be equivalent to wait() if the pid argument is (pid_t)-1 and the
options argument is 0. Otherwise, its behavior shall be modified by the values of the pid and options
arguments.
The pid argument specifies a set of child processes for which status is requested. The waitpid() function
shall only return the status of a child process from this set:
If pid is equal to (pid_t)-1, status is requested for any child process. In this respect, waitpid()
is then equivalent to wait().
If pid is greater than 0, it specifies the process ID of a single child process for which status is requested.
If pid is 0, status is requested for any child process whose process group ID is equal to that of the calling
process.
If pid is less than (pid_t)-1, status is requested for any child process whose process group ID is equal to
the absolute value of pid.
The options argument is constructed from the bitwise-inclusive OR of zero or more of the following flags, defined in the
header:
WCONTINUED
[XSI]
The waitpid() function shall report the status of any continued child process specified by pid whose status has not
been reported since it continued from a job control stop.
WNOHANG
The waitpid() function shall not suspend execution of the calling thread if status is not immediately available
for one of the child processes specified by pid.
WUNTRACED
The status of any child processes specified by pid that are stopped, and whose status has not yet been reported since
they stopped, shall also be reported to the requesting process.
If wait() or waitpid() return because the status of a child process is available, these functions shall return a
value equal to the process ID of the child process. In this case, if the value of the argument stat_loc is not a null
pointer, information shall be stored in the location pointed to by stat_loc. The value stored at the location pointed to by
stat_loc shall be 0 if and only if the status returned is from a terminated child process that terminated by one of the
following means:
The process returned 0 from main().
The process called _exit() or exit()
with a status argument of 0.
The process was terminated because the last thread in the process terminated.
Regardless of its value, this information may be interpreted using the following macros, which are defined in  and evaluate to integral expressions; the stat_val argument is
the integer value pointed to by stat_loc.
WIFEXITED(stat_val)
Evaluates to a non-zero value if status was returned for a child process that terminated normally.
WEXITSTATUS(stat_val)
If the value of WIFEXITED(stat_val) is non-zero, this macro shall evaluate to the low-order 8 bits of the status
argument that the child process passed to _exit() or exit(), or the value the child process returned from main().
WIFSIGNALED(stat_val)
Evaluates to a non-zero value if status was returned for a child process that terminated due to the receipt of a signal that
was not caught (see ).
WCOREDUMP(stat_val)
If the value of WIFSIGNALED(stat_val) is non-zero, this macro shall evaluate to a non-zero value if the creation of a core
image of the terminated child was attempted.
WTERMSIG(stat_val)
If the value of WIFSIGNALED(stat_val) is non-zero, this macro shall evaluate to the number of the signal that caused the
termination of the child process.
WIFSTOPPED(stat_val)
Evaluates to a non-zero value if status was returned for a child process that stopped due to the receipt of a signal that
was not caught (see ).
WSTOPSIG(stat_val)
If the value of WIFSTOPPED(stat_val) is non-zero, this macro shall evaluate to the number of the signal that caused the
child process to stop.
WIFCONTINUED(stat_val)
[XSI]
Evaluates to a non-zero value if status was returned for a child process that has continued from a job control stop.
[SPN]
It is unspecified whether the status value returned by calls to wait() or waitpid() for processes created by
posix_spawn() or posix_spawnp() can indicate a WIFSTOPPED(stat_val) before subsequent calls to
wait() or waitpid() indicate WIFEXITED(stat_val) as the result of an error detected before the new process
image starts executing.
It is unspecified whether the status value returned by calls to wait() or waitpid() for processes created
by posix_spawn() or posix_spawnp() can indicate a WIFSIGNALED(stat_val) if a signal is sent to the
parent's process group after posix_spawn() or posix_spawnp() is called.
If the information pointed to by stat_loc was stored by a call to waitpid() that specified the WUNTRACED flag
[XSI]
and did not specify the WCONTINUED flag,   exactly one of
the macros WIFEXITED(*stat_loc), WIFSIGNALED(*stat_loc), and WIFSTOPPED(*stat_loc) shall evaluate to a
non-zero value.
[XSI]
If the information pointed to by stat_loc was stored by a call to waitpid() that specified the WUNTRACED and
WCONTINUED flags, exactly one of the macros WIFEXITED(*stat_loc), WIFSIGNALED(*stat_loc),
WIFSTOPPED(*stat_loc), and WIFCONTINUED(*stat_loc) shall evaluate to a non-zero value.
If the information pointed to by stat_loc was stored by a call to waitpid() that did not specify the WUNTRACED
[XSI]
or WCONTINUED   flags, or by a call to the wait()
function, exactly one of the macros WIFEXITED(*stat_loc) and WIFSIGNALED(*stat_loc) shall evaluate to a non-zero
value.
[XSI]
If the information pointed to by stat_loc was stored by a call to waitpid() that did not specify the WUNTRACED flag
and specified the WCONTINUED flag, exactly one of the macros WIFEXITED(*stat_loc), WIFSIGNALED(*stat_loc), and
WIFCONTINUED(*stat_loc) shall evaluate to a non-zero value.
If the implementation queues the SIGCHLD signal, then if wait() or waitpid() returns because the status of a child
process is available, any pending SIGCHLD signal associated with the process ID of the child process shall be discarded. Any other
pending SIGCHLD signals shall remain pending.
Otherwise, if SIGCHLD is blocked, if wait() or waitpid() return because the status of a child process is
available, any pending SIGCHLD signal shall be cleared unless the status of another child process is available.
For all other conditions, it is unspecified whether child status will be available when a SIGCHLD signal is
delivered.
There may be additional implementation-defined circumstances under which wait() or waitpid() report status.
This shall not occur unless the calling process or one of its child processes explicitly makes use of a non-standard extension. In
these cases the interpretation of the reported status is implementation-defined.
If a parent process terminates without waiting for all of its child processes to terminate, the remaining child processes shall
be assigned a new parent process ID corresponding to an implementation-defined system process.
RETURN VALUE
If wait() or waitpid() returns because the status of a child process is available, these functions shall return a
value equal to the process ID of the child process for which status is reported. If wait() or waitpid()
returns due to the delivery of a signal to the calling process, -1 shall be returned and errno set to [EINTR]. If
waitpid() was invoked with WNOHANG set in options, it has at least one child process specified by pid for
which status is not available, and status is not available for any process specified by pid, 0 is returned.
Otherwise, -1 shall be returned, and errno set to indicate the error.
ERRORS
The wait() function shall fail if:
[ECHILD]
The calling process has no existing unwaited-for child processes.
[EINTR]
The function was interrupted by a signal. The value of the location pointed to by stat_loc is undefined.
The waitpid() function shall fail if:
[ECHILD]
The process specified by pid does not exist or is not a child of the calling process, or the process group specified by
pid does not exist or does not have any member process that is a child of the calling process.
[EINTR]
The function was interrupted by a signal. The value of the location pointed to by stat_loc is undefined.
[EINVAL]
The options argument is not valid.
The following sections are informative.
EXAMPLES
Waiting for a Child Process and then Checking its Status
The following example demonstrates the use of waitpid(), fork(), and the
macros used to interpret the status value returned by waitpid() (and wait()). The code segment creates a child
process which does some unspecified work. Meanwhile the parent loops performing calls to waitpid() to monitor the status of
the child. The loop terminates when child termination is detected.
#include
#include
#include
#include
...
pid_t child_pid, wpid;
int status;
child_pid = fork();
if (child_pid == -1) {      /* fork() failed */
perror("fork");
exit(EXIT_FAILURE);
}
if (child_pid == 0) {       /* This is the child */
/* Child does some work and then terminates */
...
} else {                    /* This is the parent */
do {
wpid = waitpid(child_pid, &status, WUNTRACED
#ifdef WCONTINUED       /* Not all implementations support this */
| WCONTINUED
#endif
);
if (wpid == -1) {
perror("waitpid");
exit(EXIT_FAILURE);
}
if (WIFEXITED(status)) {
printf("child exited, status=%d\n", WEXITSTATUS(status));
} else if (WIFSIGNALED(status)) {
printf("child killed (signal %d)\n", WTERMSIG(status));
} else if (WIFSTOPPED(status)) {
printf("child stopped (signal %d)\n", WSTOPSIG(status));
#ifdef WIFCONTINUED     /* Not all implementations support this */
} else if (WIFCONTINUED(status)) {
printf("child continued\n");
#endif
} else {    /* Non-standard case -- may never happen */
printf("Unexpected status (0x%x)\n", status);
}
} while (!WIFEXITED(status) && !WIFSIGNALED(status));
}
Waiting for a Child Process in a Signal Handler for SIGCHLD
The following example demonstrates how to use waitpid() in a signal handler for SIGCHLD without passing -1 as the
pid argument. (See the APPLICATION USAGE section below for the reasons why passing a pid of -1 is not recommended.)
The method used here relies on the standard behavior of waitpid() when SIGCHLD is blocked. On historical non-conforming
systems, the status of some child processes might not be reported.
#include
#include
#include
#include
#include
#include
#define CHILDREN 10
static void
handle_sigchld(int signum, siginfo_t *sinfo, void *unused)
{
int sav_errno = errno;
int status;
/*
* Obtain status information for the child which
* caused the SIGCHLD signal and write its exit code
* to stdout.
*/
if (sinfo->si_code != CLD_EXITED)
{
static char msg[] = "wrong si_code\n";
write(2, msg, sizeof msg - 1);
}
else if (waitpid(sinfo->si_pid, &status, 0) == -1)
{
static char msg[] = "waitpid() failed\n";
write(2, msg, sizeof msg - 1);
}
else if (!WIFEXITED(status))
{
static char msg[] = "WIFEXITED was false\n";
write(2, msg, sizeof msg - 1);
}
else
{
int code = WEXITSTATUS(status);
char buf[2];
buf[0] = '0' + code;
buf[1] = '\n';
write(1, buf, 2);
}
errno = sav_errno;
}
int
main(void)
{
int i;
pid_t pid;
struct sigaction sa;
sa.sa_flags = SA_SIGINFO;
sa.sa_sigaction = handle_sigchld;
sigemptyset(&sa.sa_mask);
if (sigaction(SIGCHLD, &sa, NULL) == -1)
{
perror("sigaction");
exit(EXIT_FAILURE);
}
for (i = 0; i ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Threads Extension.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
The following changes were made to align with the IEEE P1003.1a draft standard:
The processing of the SIGCHLD signal and the [ECHILD] error is clarified.
The semantics of WIFSTOPPED(stat_val), WIFEXITED(stat_val), and WIFSIGNALED(stat_val) are defined with
respect to posix_spawn() or posix_spawnp() for alignment with IEEE Std 1003.1d-1999.
The DESCRIPTION is updated for alignment with the ISO/IEC 9899:1999 standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/145 is applied, adding the example to the EXAMPLES section.
Issue 7
SD5-XSH-ERN-202 is applied.
APPLICATION USAGE is added, recommending that the wait() function not be used.
An additional example for waitpid() is added.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0707 [421], XSH/TC1-2008/0708 [166], XSH/TC1-2008/0709 [166], and
XSH/TC1-2008/0710 [69] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0384 [690], XSH/TC2-2008/0385 [691], and XSH/TC2-2008/0386 [690] are
applied.
Issue 8
Austin Group Defect 1116 is applied, removing text related to the Realtime Signals Extension option that existed in earlier
versions of this standard.
Austin Group Defects 1141 and 1363 are applied, adding WCOREDUMP, changing the description of WIFSTOPPED, and changing the
RATIONALE section.
Austin Group Defect 1570 is applied, removing extra spacing in "==".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getgroups.html =====
getgroups
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getgroups — get supplementary group IDs
SYNOPSIS
#include
int getgroups(int gidsetsize, gid_t grouplist[]);
DESCRIPTION
The getgroups() function shall fill in the array grouplist with the current supplementary group IDs of the calling
process. It is implementation-defined whether getgroups() also returns the effective group ID in the grouplist
array.
The gidsetsize argument specifies the number of elements in the array grouplist. The actual number of group IDs
stored in the array shall be returned. The values of array entries with indices greater than or equal to the value returned are
undefined.
If gidsetsize is 0, getgroups() shall return the number of group IDs that it would otherwise return without
modifying the array pointed to by grouplist.
If the effective group ID of the process is returned with the supplementary group IDs, the value returned shall always be
greater than or equal to one and less than or equal to the value of {NGROUPS_MAX}+1.
RETURN VALUE
Upon successful completion, the number of supplementary group IDs shall be returned. A return value of -1 indicates failure and
errno shall be set to indicate the error.
ERRORS
The getgroups() function shall fail if:
[EINVAL]
The gidsetsize argument is non-zero and less than the number of group IDs that would have been returned.
The following sections are informative.
EXAMPLES
Getting the Supplementary Group IDs of the Calling Process
The following example places the current supplementary group IDs of the calling process into the group array.
#include
#include
...
gid_t *group;
int ngroups;
long ngroups_max;
ngroups_max = sysconf(_SC_NGROUPS_MAX) + 1;
group = (gid_t *)malloc(ngroups_max *sizeof(gid_t));
ngroups = getgroups(ngroups_max, group);
APPLICATION USAGE
None.
RATIONALE
The related function setgroups() is a privileged operation and therefore is not covered by this volume of
POSIX.1-2024.
As implied by the definition of supplementary groups, the effective group ID may appear in the array returned by
getgroups() or it may be returned only by getegid(). Duplication may exist,
but the application needs to call getegid() to be sure of getting all of the
information. Various implementation variations and administrative sequences cause the set of groups appearing in the result of
getgroups() to vary in order and as to whether the effective group ID is included, even when the set of groups is the same
(in the mathematical sense of "set"). (The history of a process and its parents could affect the details of the result.)
Application developers should note that {NGROUPS_MAX} is not necessarily a constant on all implementations.
FUTURE DIRECTIONS
None.
SEE ALSO
getegid(), setgid()
XBD ,
CHANGE HISTORY
First released in Issue 3. Included for alignment with the POSIX.1-1988 standard.
Issue 5
Normative text previously in the APPLICATION USAGE section is moved to the DESCRIPTION.
Issue 6
In the SYNOPSIS, the optional include of the  header is
removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
A return value of 0 is not permitted, because {NGROUPS_MAX} cannot be 0. This is a FIPS requirement.
The following changes were made to align with the IEEE P1003.1a draft standard:
An explanation is added that the effective group ID may be included in the supplementary group list.
Issue 8
Austin Group Defect 1400 is applied, changing the EXAMPLES section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/exp2l.html =====
exp2
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
exp2, exp2f, exp2l — exponential base 2 functions
SYNOPSIS
#include
double exp2(double x);
float exp2f(float x);
long double exp2l(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the base-2 exponential of x.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return 2x.
If the correct value would cause overflow, a range error shall occur and exp2(), exp2f(), and exp2l() shall
return the value of the macro HUGE_VAL, HUGE_VALF, and HUGE_VALL, respectively.
If the correct value would cause underflow, [MXX]   and is not representable,   a range error may occur, and exp2(), exp2f(), and exp2l() shall return
[MXX]
0.0, or   (if the IEC 60559 Floating-Point option is not
supported) an implementation-defined value no greater in magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, 1 shall be returned.
If x is -Inf, +0 shall be returned.
If x is +Inf, x shall be returned.
[MXX]
If the correct value would cause underflow, and is representable, a range error may occur and the correct value shall be returned.
ERRORS
These functions shall fail if:
Range Error
The result overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
These functions may fail if:
Range Error
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
exp(), feclearexcept(),
fetestexcept(), isnan(),
log()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0108 [68] and XSH/TC1-2008/0109 [68] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0102 [630] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/globfree.html =====
glob
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
glob, globfree — generate pathnames matching a pattern
SYNOPSIS
#include
int glob(const char *restrict pattern, int flags,
int(*errfunc)(const char *epath, int
eerrno),
glob_t *restrict pglob);
void globfree(glob_t *pglob);
DESCRIPTION
The glob() function is a pathname generator that shall implement the rules defined in XCU 2.14 Pattern Matching Notation, with optional support for rule 3 in XCU
2.14.3 Patterns Used for Filename Expansion.
The structure type glob_t is defined in  and includes at least
the following members:
Member Type
Member Name
Description
size_t
gl_pathc
Count of paths matched by pattern.
char **
gl_pathv
Pointer to a list of matched pathnames.
size_t
gl_offs
Slots to reserve at the beginning of gl_pathv.
The argument pattern is a pointer to a pathname pattern to be expanded. The glob() function shall
match all accessible pathnames against this pattern and develop a list of all pathnames that match. In order to have access to a
pathname, glob() requires search permission on every component of a path except the last, and read permission on each
directory of any filename component of pattern that contains any of the following special characters: '*',
'?', and '['.
The glob() function shall store the number of matched pathnames into pglob->gl_pathc and a
pointer to a list of pointers to pathnames into pglob->gl_pathv. The pathnames shall be in sort order as defined
by the current setting of the LC_COLLATE category; see XBD 7.3.2
LC_COLLATE. The first pointer after the last pathname shall be a null pointer. If the pattern does not match any
pathnames, the returned number of matched paths is set to 0, and the contents of pglob->gl_pathv are
implementation-defined.
It is the caller's responsibility to create the structure pointed to by pglob. The glob() function
shall allocate other space as needed, including the memory pointed to by gl_pathv. The globfree() function shall free
any space associated with pglob from a previous call to glob(). The globfree() function shall not modify
errno if pglob was previously used by glob() and not yet freed.
The flags argument is used to control the behavior of glob(). The value of flags is a
bitwise-inclusive OR of zero or more of the following constants, which are defined in :
GLOB_APPEND
Append pathnames generated to the ones from a previous call to glob().
GLOB_DOOFFS
Make use of pglob->gl_offs. If this flag is set, pglob->gl_offs is used to specify how many
null pointers to add to the beginning of pglob->gl_pathv. In other words, pglob->gl_pathv shall
point to pglob->gl_offs null pointers, followed by pglob->gl_pathc pathname pointers, followed by
a null pointer.
GLOB_ERR
Cause glob() to return when an attempt to open or search a pathname as a directory, or an attempt to read an opened
directory, fails because of an error condition that is related to file system contents and prevents glob() from expanding
the pattern. If this flag is not set, glob() shall not treat such conditions as an error, and shall continue to look for
matches. Other error conditions may also be treated the same way as error conditions that are related to file system contents.
GLOB_MARK
For each pathname that matches pattern and is determined to be a directory after pathname resolution, process the
pathname so the result is as if the following steps are applied in order:
If the pathname is , do not modify the pathname and skip the remaining steps.
If the pathname is  and the implementation handles pathname resolution of a pathname
starting with exactly two successive  characters differently than it handles a pathname starting with only a single
, do not modify the pathname and skip the remaining steps.
If the pathname does not end with a , append a  to the pathname and skip the remaining
steps.
A  may be appended to the pathname.
If there are multiple  characters at the end of the pathname, all but one of those trailing
characters may be removed from the pathname.
GLOB_NOCHECK
Supports rule 3 in XCU 2.14.3 Patterns Used for Filename
Expansion. If pattern does not match any pathname, then glob() shall return a list consisting of only
pattern, and the number of matched pathnames is 1.
GLOB_NOESCAPE
Disable backslash escaping.
GLOB_NOSORT
Ordinarily, glob() sorts the matching pathnames according to the current setting of the LC_COLLATE category; see
XBD 7.3.2 LC_COLLATE. When this flag is used, the order of pathnames
returned is unspecified.
The GLOB_APPEND flag can be used to append a new set of pathnames to those found in a previous call to
glob(). The following rules apply to applications when two or more calls to glob() are made with the same value of
pglob and without intervening calls to globfree():
The first such call shall not set GLOB_APPEND. All subsequent calls shall set it.
All the calls shall set GLOB_DOOFFS, or all shall not set it.
After the second call, pglob->gl_pathv points to a list containing the following:
Zero or more null pointers, as specified by GLOB_DOOFFS and pglob->gl_offs.
Pointers to the pathnames that were in the pglob->gl_pathv list before the call, in the same
order as before.
Pointers to the new pathnames generated by the second call, in the specified order.
The count returned in pglob->gl_pathc shall be the total number of pathnames from the two
calls.
The application can change any of the fields after a call to glob(). If it does, the application shall
reset them to the original value before a subsequent call, using the same pglob value, to globfree() or glob()
with the GLOB_APPEND flag.
If errfunc is not a null pointer and, during the search, an attempt to open or search a pathname as a
directory, or an attempt to read an opened directory, fails because of an error condition that prevents glob() from
expanding the pattern, glob() calls (*errfunc()) with two arguments:
The epath argument is a pointer to the path that failed.
The eerrno argument is the value of errno from the failure, as set by opendir(), readdir(), or stat(). (Other values may be used to report other errors not explicitly documented for those
functions.)
If (*errfunc()) is called and returns non-zero, or, optionally, if errfunc is a null pointer and the
attempt failed because of an error condition that is not related to file system contents, or if the GLOB_ERR flag is set in
flags, glob() shall stop the scan and return GLOB_ABORTED after setting gl_pathc and gl_pathv in
pglob to reflect the paths already scanned. If GLOB_ERR is not set and either errfunc is a null pointer or
(*errfunc()) returns 0, the error shall be ignored.
The set of error conditions that are considered to prevent glob() from expanding the pattern shall include
[EACCES], [ENAMETOOLONG], and [ELOOP]. It is implementation-defined what other error conditions are included in the set.
The glob() function shall not fail because of large files.
RETURN VALUE
Upon successful completion, glob() shall return 0. The argument pglob->gl_pathc shall return the number
of matched pathnames and the argument pglob->gl_pathv shall contain a pointer to a null-terminated list of matched
and sorted pathnames. However, if pglob->gl_pathc is 0, the content of pglob->gl_pathv is
undefined.
The globfree() function shall not return a value.
If glob() terminates due to an error, it shall return one of the non-zero constants defined in . The arguments pglob->gl_pathc and
pglob->gl_pathv are still set as defined above.
ERRORS
The glob() function shall fail and return the corresponding value if:
GLOB_ABORTED
The scan was stopped because (*errfunc()) was called and returned non-zero, or, optionally, errfunc was a null
pointer and an attempt to open, read, or search a directory failed because of an error condition that is not related to file system
contents, or GLOB_ERR was set.
GLOB_NOMATCH
The pattern does not match any existing pathname, and GLOB_NOCHECK was not set in flags.
GLOB_NOSPACE
An attempt to allocate memory failed.
The following sections are informative.
EXAMPLES
One use of the GLOB_DOOFFS flag is by applications that build an argument list for use with execv(), execve(), or execvp(). Suppose, for example, that an application wants to do the equivalent of:
ls -ld -- *.c
but for some reason:
system("ls -ld -- *.c")
is not acceptable. The application could obtain the same result (except for error handling, omitted here for
simplicity) using the sequence:
globbuf.gl_offs = 3;
glob("*.c", GLOB_DOOFFS|GLOB_NOCHECK, NULL, &globbuf);
globbuf.gl_pathv[0] = "ls";  // to establish the initial arguments
globbuf.gl_pathv[1] = "-ld"; // that sh -c "ls -ld --" would
globbuf.gl_pathv[2] = "--";  // produce for both examples
execvp("ls", &globbuf.gl_pathv[0]);
Using the same example:
ls -ld -- *.c *.h
could be simulated using GLOB_APPEND as follows:
globbuf.gl_offs = 3;
glob("*.c", GLOB_DOOFFS|GLOB_NOCHECK, NULL, &globbuf);
glob("*.h", GLOB_DOOFFS|GLOB_NOCHECK|GLOB_APPEND, NULL, &globbuf);
...
APPLICATION USAGE
This function is not provided for the purpose of enabling utilities to perform pathname expansion on their arguments, as this
operation is performed by the shell, and utilities are explicitly not expected to redo this. Instead, it is provided for
applications that need to do pathname expansion on strings obtained from other sources, such as a pattern typed by a user or read
from a file.
If a utility needs to see if a pathname matches a given pattern, it can use fnmatch().
Note that gl_pathc and gl_pathv have meaning even if glob() fails. This allows glob()
to report partial results in the event of an error. However, if gl_pathc is 0, gl_pathv is unspecified even if
glob() did not return an error.
The GLOB_NOCHECK option could be used when an application wants to expand a pathname if wildcards are specified,
but wants to treat the pattern as just a string otherwise. The sh utility might use this
for option-arguments, for example.
The new pathnames generated by a subsequent call with GLOB_APPEND are not sorted together with the previous
pathnames. This mirrors the way that the shell handles pathname expansion when multiple expansions are done on a command line.
It is recommended that (*errfunc()) should always return a non-zero value if the eerrno parameter
indicates an error condition that is not related to file system contents. See XRAT C.2.14.3 Patterns Used for Filename Expansion for information about which
error conditions are related to file system contents.
Applications that need tilde and parameter expansion should use wordexp().
RATIONALE
It was claimed that the GLOB_DOOFFS flag is unnecessary because it could be simulated using:
new = (char **)malloc((n + pglob->gl_pathc + 1)
* sizeof(char *));
(void) memcpy(new+n, pglob->gl_pathv,
pglob->gl_pathc * sizeof(char *));
(void) memset(new, 0, n * sizeof(char *));
free(pglob->gl_pathv);
pglob->gl_pathv = new;
However, this assumes that the memory pointed to by gl_pathv is a block that was separately created using
malloc(). This is not necessarily the case. An application should make no assumptions
about how the memory referenced by fields in pglob was allocated. It might have been obtained from malloc() in a large chunk and then carved up within glob(), or it might have been
created using a different memory allocator. It is not the intent of the standard developers to specify or imply how the memory used
by glob() is managed.
The GLOB_APPEND flag would be used when an application wants to expand several different patterns into a single
list.
Earlier versions of this standard defined the behavior associated with the flag GLOB_MARK as: "Each pathname that
is a directory that matches pattern shall have a  appended." This was undesirable if the matched pathname was
or if the matched pathname was  and the implementation treats a leading
differently than it treats a pathname with a single leading . Only a few implementations
were known to conform to this requirement (maybe only one) and there was a lot of variation in the way other implementations
behaved. The current wording allows many of the alternative behaviors that were observed, except that the pathnames "/"
and "//" (if it is treated differently than "/") must not be modified.
Implementations should consider the following much simpler requirement (which is allowed by the current standard)
when processing the GLOB_MARK flag: "Each pathname that matches pattern, is determined to be a directory after pathname
resolution, and does not end with a  shall have a  appended."
Implementations differ as to which error conditions they consider prevent glob() from expanding the pattern.
The standard requires that [EACCES], [ENAMETOOLONG], and [ELOOP] are included because in these cases the expansion could succeed if
performed with a different effective user or group ID, or with an alternative pathname (shorter than {PATH_MAX}, or traversing
fewer symbolic links).
Implementations are encouraged to call (*errfunc()) for all error conditions that are related to file system
contents which occur when attempting to open or search a pathname as a directory or attempting to read an opened directory. The
appropriate way to handle such errors varies according to the provenance of the pattern and what the application will do with the
resulting pathnames, and should therefore be for the application to decide. For example, given the pattern
"non-existing/*", some applications may want glob() to succeed and return an empty list because there are no
existing files that match the pattern, but for others that would not be appropriate, such as if an application asks the user to
name a directory containing files to be processed and the user makes a typing mistake when responding; the application will want to
alert the user to the mistake instead of behaving as if the user had named an empty directory. If (*errfunc()) is called for
[ENOENT] errors, the first application can ignore them in that function, but if (*errfunc()) is not called, the second
application cannot achieve what it wants using glob(). Similar reasoning applies for the pattern "regular_file/*"
and [ENOTDIR] errors.
FUTURE DIRECTIONS
A future version of this standard may require that (*errfunc()) is called for all error conditions that are related to
file system contents which occur when attempting to open or search a pathname as a directory or attempting to read an opened
directory.
SEE ALSO
exec, fdopendir(), fnmatch(), fstatat(), readdir(), wordexp()
XBD 7.3.2 LC_COLLATE,
CHANGE HISTORY
First released in Issue 4. Derived from the ISO POSIX-2 standard.
Issue 5
Moved from POSIX2 C-language Binding to BASE.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
The restrict keyword is added to the glob() prototype for alignment with the ISO/IEC 9899:1999
standard.
Issue 8
Austin Group Defect 385 is applied, adding a requirement that globfree() does not modify errno when passed a
pointer to a glob_t that can be freed.
Austin Group Defect 1255 is applied, changing the EXAMPLES section.
Austin Group Defects 1273 and 1275 are applied, clarifying how errors are treated when attempting to open or search
a pathname as a directory or attempting to read an opened directory.
Austin Group Defect 1300 is applied, changing the description of GLOB_MARK.
Austin Group Defect 1444 is applied, correcting cross-references to wordexp().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mq_open.html =====
mq_open
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mq_open — open a message queue (REALTIME)
SYNOPSIS
[MSG]  #include
mqd_t mq_open(const char *name, int oflag, ...);
DESCRIPTION
The mq_open() function shall establish the connection between a process and a message queue with a message queue
descriptor. It shall create an open message queue description that refers to the message queue, and a message queue descriptor that
refers to that open message queue description. The message queue descriptor is used by other functions to refer to that message
queue. The name argument points to a string naming a message queue. It is unspecified whether the name appears in the file
system and is visible to other functions that take pathnames as arguments. The name argument conforms to the construction
rules for a pathname, except that the interpretation of  characters other than the leading  character in
name is implementation-defined, and that the length limits for the name argument are implementation-defined and need
not be the same as the pathname limits {PATH_MAX} and {NAME_MAX}. If name begins with the  character, then
processes calling mq_open() with the same value of name shall refer to the same message queue object, as long as that
name has not been removed. If name does not begin with the  character, the effect is implementation-defined. If
the name argument is not the name of an existing message queue and creation is not requested, mq_open() shall fail
and return an error.
A message queue descriptor may be implemented using a file descriptor, in which case applications can open up to at least
{OPEN_MAX} file and message queues.
The oflag argument requests the desired receive and/or send access to the message queue. The requested access permission
to receive messages or send messages shall be granted if the calling process would be granted read or write access, respectively,
to an equivalently protected file.
The value of oflag is the bitwise-inclusive OR of values from the following list. Applications shall specify exactly one
of the first three values (access modes) below in the value of oflag:
O_RDONLY
Open the message queue for receiving messages. The process can use the returned message queue descriptor with mq_receive(), but not mq_send(). A message
queue may be open multiple times in the same or different processes for receiving messages.
O_WRONLY
Open the queue for sending messages. The process can use the returned message queue descriptor with mq_send() but not mq_receive(). A message
queue may be open multiple times in the same or different processes for sending messages.
O_RDWR
Open the queue for both receiving and sending messages. The process can use any of the functions allowed for O_RDONLY and
O_WRONLY. A message queue may be open multiple times in the same or different processes for sending messages.
Any combination of the remaining flags may be specified in the value of oflag:
O_CREAT
Create a message queue. It requires two additional arguments: mode, which shall be of type mode_t, and
attr, which shall be a pointer to an mq_attr structure. If the pathname name has already been used to create a
message queue that still exists, then this flag shall have no effect, except as noted under O_EXCL. Otherwise, a message queue
shall be created without any messages in it. The user ID of the message queue shall be set to the effective user ID of the process.
The group ID of the message queue shall be set to the effective group ID of the process; however, if the name argument is
visible in the file system, the group ID may be set to the group ID of the containing directory. When bits in mode other
than the file permission bits are specified, the effect is unspecified. If attr is NULL, the message queue shall be created
with implementation-defined default message queue attributes. If attr is non-NULL and the calling process has appropriate
privileges on name, the message queue mq_maxmsg and mq_msgsize attributes shall be set to the values of the
corresponding members in the mq_attr structure referred to by attr. The values of the mq_flags and
mq_curmsgs members of the mq_attr structure shall be ignored. If attr is non-NULL, but the calling process
does not have appropriate privileges on name, the mq_open() function shall fail and return an error without creating
the message queue.
O_EXCL
If O_EXCL and O_CREAT are set, mq_open() shall fail if the message queue name exists. The check for the existence
of the message queue and the creation of the message queue if it does not exist shall be atomic with respect to other threads
executing mq_open() naming the same name with O_EXCL and O_CREAT set. If O_EXCL is set and O_CREAT is not set, the
result is undefined.
O_NONBLOCK
Determines whether an mq_send() or mq_receive() waits for resources or messages that are not currently available, or fails
with errno set to [EAGAIN]; see mq_send() and mq_receive() for details.
The mq_open() function does not add or remove messages from the queue.
RETURN VALUE
Upon successful completion, the function shall return a message queue descriptor; otherwise, the function shall return
(mqd_t)-1 and set errno to indicate the error.
ERRORS
The mq_open() function shall fail if:
[EACCES]
The message queue exists and the permissions specified by oflag are denied, or the message queue does not exist and
permission to create the message queue is denied.
[EEXIST]
O_CREAT and O_EXCL are set and the named message queue already exists.
[EINTR]
The mq_open() function was interrupted by a signal.
[EINVAL]
The mq_open() function is not supported for the given name.
[EINVAL]
O_CREAT was specified in oflag, the value of attr is not NULL, and either mq_maxmsg or mq_msgsize
was less than or equal to zero.
[EMFILE]
Too many message queue descriptors or file descriptors are currently in use by this process.
[ENFILE]
Too many message queue descriptors or file descriptors are currently open in the system.
[ENOENT]
O_CREAT is not set and the named message queue does not exist.
[ENOSPC]
There is insufficient space for the creation of the new message queue.
If any of the following conditions occur, the mq_open() function may return (mqd_t)-1 and set errno to the
corresponding value.
[ENAMETOOLONG]
The length of the name argument exceeds {_POSIX_PATH_MAX} on systems that do not support the XSI option [XSI]   or exceeds
{_XOPEN_PATH_MAX} on XSI systems,   or has a pathname component
that is longer than {_POSIX_NAME_MAX} on systems that do not support the XSI option [XSI]   or longer
than {_XOPEN_NAME_MAX} on XSI systems.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
A future version might require the mq_open() and mq_unlink() functions
to have semantics similar to normal file system operations.
SEE ALSO
mq_close(), mq_getattr(),
mq_receive(), mq_send(),
mq_setattr(), mq_unlink(),
msgctl(), msgget(), msgrcv(), msgsnd()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The mq_open() function is marked as part of the Message Passing option.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Message
Passing option.
The mq_timedreceive() and mq_timedsend() functions are added to the SEE ALSO section for alignment with
IEEE Std 1003.1d-1999.
The DESCRIPTION of O_EXCL is updated in response to IEEE PASC Interpretation 1003.1c #48.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/62 is applied, updating the description of the permission bits
in the DESCRIPTION. The change is made for consistency with the shm_open() and
sem_open() functions.
Issue 7
Austin Group Interpretation 1003.1-2001 #077 is applied, clarifying the name argument and changing [ENAMETOOLONG] from a
"shall fail" to a "may fail" error.
Austin Group Interpretation 1003.1-2001 #141 is applied, adding FUTURE DIRECTIONS.
SD5-XSH-ERN-170 is applied, updating the DESCRIPTION to clarify the wording for setting the user ID and group ID of the message
queue.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0394 [259] is applied.
Issue 8
Austin Group Defect 368 is applied, changing the [ENFILE] error.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wmemmove.html =====
wmemmove
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wmemmove — copy wide characters in memory with overlapping areas
SYNOPSIS
#include
wchar_t *wmemmove(wchar_t *ws1, const wchar_t *ws2, size_t n);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The wmemmove() function shall copy n wide characters from the object pointed to by ws2 to the object
pointed to by ws1. Copying shall take place as if the n wide characters from the object pointed to by ws2 are
first copied into a temporary array of n wide characters that does not overlap the objects pointed to by ws1 or
ws2, and then the n wide characters from the temporary array are copied into the object pointed to by ws1.
This function shall not be affected by locale and all wchar_t values shall be treated identically. The null wide
character and wchar_t values not corresponding to valid characters shall not be treated specially.
If n is zero, the application shall ensure that ws1 and ws2 are valid pointers, and the function shall copy
zero wide characters.
[CX]  The
wmemmove() function shall not change the setting of errno on valid input.
RETURN VALUE
The wmemmove() function shall return the value of ws1.
ERRORS
No errors are defined
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
wmemchr(), wmemcmp(), wmemcpy(), wmemset()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E).
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that wmemmove() does not change the setting of errno on
valid input.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/modff.html =====
modf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
modf, modff, modfl — decompose a floating-point number
SYNOPSIS
#include
double modf(double x, double *iptr);
float modff(float value, float *iptr);
long double modfl(long double value, long double *iptr);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall break the argument x into integral and fractional parts, each of which has the same sign as the
argument. It stores the integral part as a double (for the modf() function), a float (for the modff()
function), or a long double (for the modfl() function), in the object pointed to by iptr.
RETURN VALUE
Upon successful completion, these functions shall return the signed fractional part of x.
[MX]  The
returned value shall be exact and shall be independent of the current rounding direction mode.
If x is NaN, a NaN shall be returned, and *iptr shall be set to a NaN.
If x is ±Inf, ±0 shall be returned, and *iptr shall be set to ±Inf.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The modf() function computes the function result and *iptr such that:
a = modf(x, iptr) ;
x == a+*iptr ;
allowing for the usual floating-point inaccuracies.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
frexp(), isnan(), ldexp()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The modff() and modfl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/35 is applied, correcting the code example in the APPLICATION
USAGE section.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/expm1f.html =====
expm1
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
expm1, expm1f, expm1l — compute exponential functions
SYNOPSIS
#include
double expm1(double x);
float expm1f(float x);
long double expm1l(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute ex-1.0.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions return ex-1.0.
If the correct value would cause overflow, a range error shall occur and expm1(), expm1f(), and expm1l()
shall return the value of the macro HUGE_VAL, HUGE_VALF, and HUGE_VALL, respectively.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, ±0 shall be returned.
If x is -Inf, -1 shall be returned.
If x is +Inf, x shall be returned.
[MXX]
If x is subnormal, x should be returned.
[MX]  If x is subnormal, a range error may occur and, if x is
not returned, expm1(), expm1f(), and expm1l() shall return an implementation-defined value no greater in
magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
ERRORS
These functions shall fail if:
Range Error
The result overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
These functions may fail if:
Range Error
[MX]
The value of x is subnormal.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The value of expm1(x) may be more accurate than exp(x)-1.0 for small values of x.
The expm1() and log1p() functions are useful for financial calculations of
((1+x)n-1)/x, namely:
expm1(n * log1p(x))/x
when x is very small (for example, when calculating small daily interest rates). These functions also simplify writing
accurate inverse hyperbolic functions.
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
exp(), feclearexcept(),
fetestexcept(), ilogb(),
log1p()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The expm1f() and expm1l() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The expm1() function is no longer marked as an extension.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0110 [68] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0103 [630] is applied.
Issue 8
Austin Group Defect 1382 is applied, rearranging the text describing the behavior when x is subnormal to avoid the need
for two shading changes.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_equal.html =====
pthread_equal
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_equal — compare thread IDs
SYNOPSIS
#include
int pthread_equal(pthread_t t1, pthread_t t2);
DESCRIPTION
This function shall compare the thread IDs t1 and t2.
RETURN VALUE
The pthread_equal() function shall return a non-zero value if t1 and t2 are equal; otherwise, zero shall be
returned.
If either t1 or t2 is not a valid thread ID and is not equal to PTHREAD_NULL, the behavior is undefined.
ERRORS
No errors are defined.
The pthread_equal() function shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
Implementations may choose to define a thread ID as a structure. This allows additional flexibility and robustness over using an
int. For example, a thread ID could include a sequence number that allows detection of "dangling IDs" (copies of a thread
ID that has been detached). Since the C language does not support comparison on structure types, the pthread_equal()
function is provided to compare thread IDs.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_create(), pthread_self()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_equal() function is marked as part of the Threads option.
Issue 7
The pthread_equal() function is moved from the Threads option to the Base.
Issue 8
Austin Group Defect 599 is applied, changing the RETURN VALUE section to mention PTHREAD_NULL.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/readdir_r.html =====
readdir
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
readdir, readdir_r — read a directory
SYNOPSIS
#include
struct dirent *readdir(DIR *dirp);
[OB]  int readdir_r(DIR *restrict dirp, struct dirent *restrict entry,
struct dirent **restrict result);
DESCRIPTION
The type DIR, which is defined in the  header, represents
a directory stream, which is an ordered sequence of all the directory entries in a particular directory. Directory entries
represent files; files may be removed from a directory or added to a directory asynchronously to the operation of
readdir().
The readdir() function shall return a pointer to a structure representing the directory entry at the current position in
the directory stream specified by the argument dirp, and position the directory stream at the next entry. It shall return a
null pointer upon reaching the end of the directory stream. The structure dirent defined in the  header describes a directory entry. The value of the structure's
d_ino member shall be set to the file serial number of the file named by the d_name member. If the d_name
member names a symbolic link, the value of the d_ino member shall be set to the file serial number of the symbolic link
itself. The d_name member shall be a filename string, and (if not dot or dot-dot) shall contain the same byte sequence as
the last pathname component of the string used to create the directory entry, plus the terminating  byte.
The readdir() function shall not return directory entries containing empty names. If entries for dot or dot-dot exist,
one entry shall be returned for dot and one entry shall be returned for dot-dot; otherwise, they shall not be returned.
The application shall not modify the structure to which the return value of readdir() points, nor any storage areas
pointed to by pointers within the structure. The returned pointer, and pointers within the structure, might be invalidated or the
structure or the storage areas might be overwritten by a subsequent call to readdir() on the same directory stream. They
shall not be affected by a call to readdir() on a different directory stream. The returned pointer, and pointers within the
structure, might also be invalidated if the calling thread is terminated.
If a file is removed from or added to the directory after the most recent call to opendir() or rewinddir(), whether a
subsequent call to readdir() returns an entry for that file is unspecified.
The readdir() function may buffer several directory entries per actual read operation; readdir() shall mark for
update the last data access timestamp of the directory each time the directory is actually read.
After a call to fork(), either the parent or child (but not both) may continue
processing the directory stream using readdir(), rewinddir(),
[XSI]
or seekdir().
If both the parent and child processes use these functions, the result is undefined.
The readdir() function need not be thread-safe if concurrent calls are made for the same directory stream.
Applications wishing to check for error situations should set errno to 0 before calling readdir(). If errno
is set to non-zero on return, an error occurred.
[OB]  The
readdir_r() function shall initialize the dirent structure referenced by entry to represent the directory
entry at the current position in the directory stream referred to by dirp, store a pointer to this structure at the location
referenced by result, and position the directory stream at the next entry.
The storage pointed to by entry shall be large enough for a dirent with an array of char d_name
members containing at least {NAME_MAX}+1 elements.
Upon successful return, the pointer returned at *result shall have the same value as the argument entry. Upon
reaching the end of the directory stream, this pointer shall have the value NULL.
The readdir_r() function shall not return directory entries containing empty names.
If a file is removed from or added to the directory after the most recent call to opendir() or rewinddir(), whether a
subsequent call to readdir_r() returns an entry for that file is unspecified.
The readdir_r() function may buffer several directory entries per actual read operation; readdir_r() shall mark
for update the last data access timestamp of the directory each time the directory is actually read.
RETURN VALUE
Upon successful completion, readdir() shall return a pointer to an object of type struct dirent. When an error is
encountered, a null pointer shall be returned and errno shall be set to indicate the error. When the end of the directory is
encountered, a null pointer shall be returned and errno is not changed.
[OB]  If
successful, the readdir_r() function shall return zero; otherwise, an error number shall be returned to indicate the error.
ERRORS
The readdir() [OB]   and readdir_r()
functions shall fail if:
[EOVERFLOW]
One of the values in the structure to be returned cannot be represented correctly.
[ENOMEM]
Insufficient memory is available.
The readdir() [OB]   and readdir_r()
functions may fail if:
[EBADF]
The dirp argument does not refer to an open directory stream.
[ENOENT]
The current position of the directory stream is invalid.
The following sections are informative.
EXAMPLES
The following sample program searches the current directory for each of the arguments supplied on the command line.
#include
#include
#include
#include
static void lookup(const char *arg)
{
DIR *dirp;
struct dirent *dp;
if ((dirp = opendir(".")) == NULL) {
perror("couldn't open '.'");
return;
}
do {
errno = 0;
if ((dp = readdir(dirp)) != NULL) {
if (strcmp(dp->d_name, arg) != 0)
continue;
(void) printf("found %s\n", arg);
(void) closedir(dirp);
return;
}
} while (dp != NULL);
if (errno != 0)
perror("error reading directory");
else
(void) printf("failed to find %s\n", arg);
(void) closedir(dirp);
return;
}
int main(int argc, char *argv[])
{
int i;
for (i = 1; i , even if a
trailing  was present in the pathname presented to mkdir() when creating
a sub-directory.
However, there are non-conforming file systems where filenames are converted to a canonical representation before a directory
entry is created, such that it is possible to create a file using one string, then perform opendir() and a readdir() loop and not encounter the same string, because
readdir() returns the canonical form of the string instead. Such non-conforming file systems also have the issue that
multiple filenames can resolve to the same directory entry, with potentially confusing results. This standard cannot mandate the
behavior of non-conforming file systems, and strictly conforming applications need not worry about dealing with such file systems,
but it is a concern for developers of portable applications. Therefore, this standard recommends that file system implementations
that perform canonicalization of filenames should reject attempts to create a directory entry with a non-canonical filename using
the [EILSEQ] error. However, if a directory entry already exists, it is reasonable for a file system to permit accessing that file
via a non-canonical filename.
FUTURE DIRECTIONS
The readdir_r() function may be removed in a future version.
SEE ALSO
closedir(), dirfd(), exec, fdopendir(), fstatat(), posix_getdents(), rewinddir(),
symlink()
XBD ,
CHANGE HISTORY
First released in Issue 2.
Issue 5
Large File Summit extensions are added.
The readdir_r() function is included for alignment with the POSIX Threads Extension.
A note indicating that the readdir() function need not be reentrant is added to the DESCRIPTION.
Issue 6
The readdir_r() function is marked as part of the Thread-Safe Functions option.
The Open Group Corrigendum U026/7 is applied, correcting the prototype for readdir_r().
The Open Group Corrigendum U026/8 is applied, clarifying the wording of the successful return for the readdir_r()
function.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
A statement is added to the DESCRIPTION indicating the disposition of certain fields in struct dirent when an entry
refers to a symbolic link.
The [EOVERFLOW] mandatory error condition is added. This change is to support large files.
The [ENOENT] optional error condition is added.
The APPLICATION USAGE section is updated to include a note on the thread-safe function and its avoidance of possibly using a
static data area.
The restrict keyword is added to the readdir_r() prototype for alignment with the ISO/IEC 9899:1999
standard.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/50 is applied, replacing the EXAMPLES section with a new
example.
Issue 7
Austin Group Interpretation 1003.1-2001 #059 is applied, updating the ERRORS section.
Austin Group Interpretation 1003.1-2001 #156 is applied.
The readdir_r() function is moved from the Thread-Safe Functions option to the Base.
Changes are made related to support for finegrained timestamps.
The value of the d_ino member is no longer unspecified for symbolic links.
SD5-XSH-ERN-193 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0486 [75] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0304 [656] is applied.
Issue 8
Austin Group Defect 293 is applied, adding a requirement that d_name contains the same byte sequence as the last pathname
component of the string used to create the directory entry.
Austin Group Defects 696 and 1664 are applied, making readdir_r() obsolescent, requiring readdir() to be
thread-safe except when concurrent calls are made for the same directory stream, and adding the [ENOMEM] error.
Austin Group Defect 697 is applied, adding posix_getdents() to the SEE
ALSO section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/conj.html =====
conj
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
conj, conjf, conjl — complex conjugate functions
SYNOPSIS
#include
double complex conj(double complex z);
float complex conjf(float complex z);
long double complex conjl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex conjugate of z, by reversing the sign of its imaginary part.
RETURN VALUE
These functions return the complex conjugate value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
carg(), cimag(), cproj(), creal()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/tanl.html =====
tan
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
tan, tanf, tanl — tangent function
SYNOPSIS
#include
double tan(double x);
float tanf(float x);
long double tanl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the tangent of their argument x, measured in radians.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the tangent of x.
If the correct value would cause underflow, [MXX]   and is not representable,   a range error may occur, and tan(), tanf(), and tanl() shall return
[MXX]
0.0, or   (if IEC 60559 Floating-Point is not supported)
an implementation-defined value no greater in magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, x shall be returned.
If x is ±Inf, a domain error shall occur, and either a NaN (if supported), or an implementation-defined value shall be
returned.
[MXX]
If x is subnormal, x should be returned.
[MX]  If x is subnormal, a range error may occur and, if x is
not returned, tan(), tanf(), and tanl() shall return an implementation-defined value no greater in magnitude
than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
[MXX]
If the correct value would cause underflow, and is representable, a range error may occur and the correct value shall be returned.
[XSI]
If the correct value would cause overflow, a range error shall occur and tan(), tanf(), and tanl() shall
return ±HUGE_VAL, ±HUGE_VALF, and ±HUGE_VALL, respectively, with the same sign as the correct value of the function.
ERRORS
These functions shall fail if:
Domain Error
[MX]
The value of x is ±Inf.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
Range Error
[XSI]
The result overflows
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
These functions may fail if:
Range Error
The result underflows, [MX]   or the value of x is subnormal.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
Taking the Tangent of a 45-Degree Angle
#include
...
double radians = 45.0 * M_PI / 180;
double result;
...
result = tan (radians);
APPLICATION USAGE
There are no known floating-point representations such that for a normal argument, tan(x) is either overflow or
underflow.
These functions may lose accuracy when their argument is near a multiple of ℼ/2 or is far from 0.0.
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
atan(), feclearexcept(),
fetestexcept(), isnan()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The last two paragraphs of the DESCRIPTION were included as APPLICATION USAGE notes in previous issues.
Issue 6
The tanf() and tanl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/64 is applied, correcting the last paragraph in the RETURN VALUE
section.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0635 [68], XSH/TC1-2008/0636 [68], and XSH/TC1-2008/0637 [68] are
applied.
Issue 8
Austin Group Defect 1382 is applied, rearranging the text describing the behavior when x is subnormal to avoid the need
for two shading changes.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/clogf.html =====
clog
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
clog, clogf, clogl — complex natural logarithm functions
SYNOPSIS
#include
double complex clog(double complex z);
float complex clogf(float complex z);
long double complex clogl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex natural (base e) logarithm of z, with a branch cut along the negative
real axis.
RETURN VALUE
These functions shall return the complex natural logarithm value, in the range of a strip mathematically unbounded along the
real axis and in the interval [-iℼ, +iℼ] along the imaginary axis.
[MXC]
clog(conj(z)), clogf(conjf(z)), and clogl(conjl(z)) shall return
exactly the same value as conj(clog(z)), conjf(clogf(z)), and
conjl(clogl(z)), respectively, including for the special values of z below.
If z is -0 + i0, -Inf + iℼ shall be returned and the divide-by-zero floating-point exception shall be
raised.
If z is +0 + i0, -Inf + i0 shall be returned and the divide-by-zero floating-point exception shall be
raised.
If z is x + iInf where x is finite, +Inf + iℼ/2 shall be returned.
If z is x + iNaN where x is finite, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is -Inf + iy where y is positive-signed and finite, +Inf + iℼ shall be returned.
If z is +Inf + iy where y is positive-signed and finite, +Inf + i0 shall be returned.
If z is -Inf + iInf, +Inf + i3ℼ/4 shall be returned.
If z is +Inf + iInf, +Inf + iℼ/4 shall be returned.
If z is ±Inf + iNaN, +Inf + iNaN shall be returned.
If z is NaN + iy where y is finite, NaN + iNaN shall be returned and the invalid floating-point
exception may be raised.
If z is NaN + iInf, +Inf + iNaN shall be returned.
If z is NaN + iNaN, NaN + iNaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
cexp()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/posix_spawnattr_getschedpolicy.html =====
posix_spawnattr_getschedpolicy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
posix_spawnattr_getschedpolicy, posix_spawnattr_setschedpolicy — get and set the spawn-schedpolicy attribute of a spawn
attributes object (ADVANCED REALTIME)
SYNOPSIS
[SPN PS]  #include
#include
int posix_spawnattr_getschedpolicy(const posix_spawnattr_t
*restrict attr, int *restrict schedpolicy);
int posix_spawnattr_setschedpolicy(posix_spawnattr_t *attr,
int schedpolicy);
DESCRIPTION
The posix_spawnattr_getschedpolicy() function shall obtain the value of the spawn-schedpolicy attribute from the
attributes object referenced by attr.
The posix_spawnattr_setschedpolicy() function shall set the spawn-schedpolicy attribute in an initialized
attributes object referenced by attr.
The spawn-schedpolicy attribute represents the scheduling policy to be assigned to the new process image in a spawn
operation (if POSIX_SPAWN_SETSCHEDULER is set in the spawn-flags attribute). The default value of this attribute is
unspecified.
RETURN VALUE
Upon successful completion, posix_spawnattr_getschedpolicy() shall return zero and store the value of the
spawn-schedpolicy attribute of attr into the object referenced by the schedpolicy parameter; otherwise, an
error number shall be returned to indicate the error.
Upon successful completion, posix_spawnattr_setschedpolicy() shall return zero; otherwise, an error number shall be
returned to indicate the error.
ERRORS
These functions may fail if:
[EINVAL]
The value specified by attr is invalid.
The posix_spawnattr_setschedpolicy() function may fail if:
[EINVAL]
The value of the attribute being set is not valid.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
These functions are part of the Spawn and Process Scheduling options and need not be provided on all implementations.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
posix_spawn(), posix_spawnattr_destroy(), posix_spawnattr_getsigdefault(), posix_spawnattr_getflags(), posix_spawnattr_getpgroup(), posix_spawnattr_getschedparam(), posix_spawnattr_getsigmask()
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1d-1999.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/CMPLX.html =====
CMPLX
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
CMPLX, CMPLXF, CMPLXL — make a complex value
SYNOPSIS
#include
double complex CMPLX(double x, double y);
float complex CMPLXF(float x, float y);
long double complex CMPLXL(long double x, long double y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The CMPLX macros shall expand to an expression of the specified complex type, with the real part having the (converted) value of
x and the imaginary part having the (converted) value of y. The resulting expression shall be suitable for use as an
initializer for an object with static or thread storage duration, provided both arguments are likewise suitable.
RETURN VALUE
The CMPLX macros return the complex value x + i y (where i is the imaginary unit).
These macros shall behave as if the implementation supported imaginary types and the definitions were:
#define CMPLX(x, y)  ((double complex)((double)(x) + \
_Imaginary_I * (double)(y)))
#define CMPLXF(x, y) ((float complex)((float)(x) + \
_Imaginary_I * (float)(y)))
#define CMPLXL(x, y) ((long double complex)((long double)(x) + \
_Imaginary_I * (long double)(y)))
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/tcgetpgrp.html =====
tcgetpgrp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
tcgetpgrp — get the foreground process group ID
SYNOPSIS
#include
pid_t tcgetpgrp(int fildes);
DESCRIPTION
The tcgetpgrp() function shall return the value of the process group ID of the foreground process group associated with
the terminal.
If there is no foreground process group, tcgetpgrp() shall return a value greater than 1 that does not match the process
group ID of any existing process group.
The tcgetpgrp() function is allowed from a process that is a member of a background process group; however, the
information may be subsequently changed by a process that is a member of a foreground process group.
RETURN VALUE
Upon successful completion, tcgetpgrp() shall return the value of the process group ID of the foreground process
associated with the terminal. Otherwise, -1 shall be returned and errno set to indicate the error.
ERRORS
The tcgetpgrp() function shall fail if:
[EBADF]
The fildes argument is not a valid file descriptor.
[ENOTTY]
The calling process does not have a controlling terminal, or the file is not the controlling terminal.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
setsid(), setpgid(), tcsetpgrp()
XBD ,
CHANGE HISTORY
First released in Issue 3. Included for alignment with the POSIX.1-1988 standard.
Issue 6
In the SYNOPSIS, the optional include of the  header is
removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
In the DESCRIPTION, text previously conditional on support for _POSIX_JOB_CONTROL is now mandatory. This is a FIPS
requirement.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_mutex_lock.html =====
pthread_mutex_lock
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_mutex_lock, pthread_mutex_trylock, pthread_mutex_unlock — lock and unlock a mutex
SYNOPSIS
#include
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_trylock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
DESCRIPTION
The mutex object referenced by mutex shall be locked by a call to pthread_mutex_lock() that returns zero or
[EOWNERDEAD]. If the mutex is already locked by another thread, the calling thread shall block until the mutex becomes available.
This operation shall return with the mutex object referenced by mutex in the locked state with the calling thread as its
owner. If a thread attempts to relock a mutex that it has already locked, pthread_mutex_lock() shall behave as described in
the Relock column of the following table. If a thread attempts to unlock a mutex that it has not locked or a mutex which is
unlocked, pthread_mutex_unlock() shall behave as described in the Unlock When Not Owner column of the following
table.
Mutex Type
Robustness
Relock
Unlock When Not Owner
NORMAL
non-robust
deadlock
undefined behavior
NORMAL
robust
deadlock
error returned
ERRORCHECK
either
error returned
error returned
RECURSIVE
either
recursive (see below)
error returned
DEFAULT
non-robust
undefined behavior†
undefined behavior†
DEFAULT
robust
undefined behavior†
error returned
†
If the mutex type is PTHREAD_MUTEX_DEFAULT, the behavior of pthread_mutex_lock() may correspond to one of the three
other standard mutex types as described in the table above. If it does not correspond to one of those three, the behavior is
undefined for the cases marked †.
Where the table indicates recursive behavior, the mutex shall maintain the concept of a lock count. When a thread
successfully acquires a mutex for the first time, the lock count shall be set to one. Every time a thread relocks this mutex, the
lock count shall be incremented by one. Each time the thread unlocks the mutex, the lock count shall be decremented by one. When
the lock count reaches zero, the mutex shall become available for other threads to acquire.
The pthread_mutex_trylock() function shall be equivalent to pthread_mutex_lock(), except that if the
mutex object referenced by mutex is currently locked (by any thread, including the current thread), the call shall return
immediately. If the mutex type is PTHREAD_MUTEX_RECURSIVE and the mutex is currently owned by the calling thread, the mutex lock
count shall be incremented by one and the pthread_mutex_trylock() function shall immediately return success.
The pthread_mutex_unlock() function shall release the mutex object referenced by mutex. The manner in
which a mutex is released is dependent upon the mutex's type attribute. If there are threads blocked on the mutex object referenced
by mutex when pthread_mutex_unlock() is called, resulting in the mutex becoming available, the scheduling policy
shall determine which thread shall acquire the mutex.
(In the case of PTHREAD_MUTEX_RECURSIVE mutexes, the mutex shall become available when the count reaches zero and
the calling thread no longer has any locks on this mutex.)
If a signal is delivered to a thread waiting for a mutex, upon return from the signal handler the thread shall
resume waiting for the mutex as if it was not interrupted.
If mutex is a robust mutex and the process containing the owning thread terminated while holding the mutex
lock, a call to pthread_mutex_lock() shall return the error value [EOWNERDEAD]. If mutex is a robust mutex and the
owning thread terminated while holding the mutex lock, a call to pthread_mutex_lock() may return the error value
[EOWNERDEAD] even if the process in which the owning thread resides has not terminated. In these cases, the mutex shall be locked
by the calling thread but the state it protects is marked as inconsistent. The application should ensure that the state is made
consistent for reuse and when that is complete call pthread_mutex_consistent(). If the application is unable to recover the
state, it should unlock the mutex without a prior call to pthread_mutex_consistent(), after which the mutex is marked permanently
unusable.
If mutex does not refer to an initialized mutex object, the behavior of pthread_mutex_lock(),
pthread_mutex_trylock(), and pthread_mutex_unlock() is undefined.
RETURN VALUE
If successful, the pthread_mutex_lock(), pthread_mutex_trylock(), and pthread_mutex_unlock() functions
shall return zero; otherwise, an error number shall be returned to indicate the error.
ERRORS
The pthread_mutex_lock() and pthread_mutex_trylock() functions shall fail if:
[EAGAIN]
The mutex could not be acquired because the maximum number of recursive locks for mutex has been exceeded.
[EAGAIN]
The mutex is a robust mutex and the system resources available for robust mutexes owned would be exceeded.
[EINVAL]
[RPP|TPP]  The mutex was created with the protocol attribute having the value PTHREAD_PRIO_PROTECT and the calling thread's
priority is higher than the mutex's current priority ceiling.
[ENOTRECOVERABLE]
The state protected by the mutex is not recoverable.
[EOWNERDEAD]
The mutex is a robust mutex and the process containing the previous owning thread terminated while holding the mutex lock. The
mutex lock shall be acquired by the calling thread and it is up to the new owner to make the state consistent.
The pthread_mutex_lock() function shall fail if:
[EDEADLK]
The mutex type is PTHREAD_MUTEX_ERRORCHECK and the current thread already owns the mutex.
The pthread_mutex_trylock() function shall fail if:
[EBUSY]
The mutex could not be acquired because it was already locked.
The pthread_mutex_unlock() function shall fail if:
[EPERM]
The mutex type is PTHREAD_MUTEX_ERRORCHECK or PTHREAD_MUTEX_RECURSIVE, or the mutex is a robust mutex, and the current thread
does not own the mutex.
The pthread_mutex_lock() and pthread_mutex_trylock() functions may fail if:
[EOWNERDEAD]
The mutex is a robust mutex and the previous owning thread terminated while holding the mutex lock. The mutex lock shall be
acquired by the calling thread and it is up to the new owner to make the state consistent.
The pthread_mutex_lock() function may fail if:
[EDEADLK]
A deadlock condition was detected.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications that have assumed that non-zero return values are errors will need updating for use with robust mutexes, since a
valid return for a thread acquiring a mutex which is protecting a currently inconsistent state is [EOWNERDEAD]. Applications that
do not check the error returns, due to ruling out the possibility of such errors arising, should not use robust mutexes. If an
application is supposed to work with normal and robust mutexes it should check all return values for error conditions and if
necessary take appropriate action.
RATIONALE
Mutex objects are intended to serve as a low-level primitive from which other thread synchronization functions can be built. As
such, the implementation of mutexes should be as efficient as possible, and this has ramifications on the features available at the
interface.
The mutex functions and the particular default settings of the mutex attributes have been motivated by the desire
to not preclude fast, inlined implementations of mutex locking and unlocking.
Since most attributes only need to be checked when a thread is going to be blocked, the use of attributes does not
slow the (common) mutex-locking case.
Likewise, while being able to extract the thread ID of the owner of a mutex might be desirable, it would require
storing the current thread ID when each mutex is locked, and this could incur unacceptable levels of overhead. Similar arguments
apply to a mutex_tryunlock operation.
For further rationale on the extended mutex types, see XRAT Threads Extensions.
If an implementation detects that the value specified by the mutex argument does not refer to an initialized
mutex object, it is recommended that the function should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_mutex_clocklock(), pthread_mutex_consistent(), pthread_mutex_destroy(), pthread_mutexattr_getrobust()
XBD 4.15.2 Memory Synchronization,
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_mutex_lock(), pthread_mutex_trylock(), and pthread_mutex_unlock() functions are marked as part
of the Threads option.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX
Specification:
The behavior when attempting to relock a mutex is defined.
The pthread_mutex_timedlock() function is added to
the SEE ALSO section for alignment with IEEE Std 1003.1d-1999.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/98 is applied, updating the ERRORS section so that
the [EDEADLK] error includes detection of a deadlock condition. The RATIONALE section is also reworded to take into account
non-XSI-conformant systems.
Issue 7
SD5-XSH-ERN-43 is applied, marking the "shall fail" case of the [EINVAL] error as dependent on the Thread Priority Protection
option.
Changes are made from The Open Group Technical Standard, 2006, Extended API Set Part 3.
The pthread_mutex_lock(), pthread_mutex_trylock(), and pthread_mutex_unlock() functions are
moved from the Threads option to the Base.
The following extended mutex types are moved from the XSI option to the Base:
PTHREAD_MUTEX_NORMAL
PTHREAD_MUTEX_ERRORCHECK
PTHREAD_MUTEX_RECURSIVE
PTHREAD_MUTEX_DEFAULT
The DESCRIPTION is updated to clarify the behavior when mutex does not refer to an initialized mutex.
The ERRORS section is updated to account properly for all of the various mutex types.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0461 [121], XSH/TC1-2008/0462 [92,428], and XSH/TC1-2008/0463
[121] are applied.
Issue 8
Austin Group Defect 354 is applied, adding the [EAGAIN] error for exceeding system resources available for robust mutexes
owned.
Austin Group Defect 1115 is applied, changing "the thread" to "the calling thread".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/help/about.html =====
About
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
About the HTML Version
This html version of this standard is made available under
the following terms and conditions.
The html has been generated from the original troff sources by Andrew
Josey and Geoff Clare of The Open Group.
The intent has not been to produce a verbatim copy of the printed version
but to utilize the uniqueness of the different media with its support
for hyperlinking and searching. In cases of conflict the printed version is the master
copy and takes precedence.
The translation process has used a tool known as genhtml which
takes the troff and produces html output. The W3C Tidy tool has been used
as part of the production process.
Additional scripts have been run to
do further html cleanup and to produce the indices.
This version utilizes style sheets for the general layout affecting
all the pages (choice of fonts and some shading)
and  a piece of javascript to open up  the help
page in a separate browser window. A frames and a non-frames interface
have been provided.
If you find the font sizes too small, either switch
off the style sheets in your browser, or set your browser
to override the document fonts.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
===== susv5-html/help/terms.html =====
The Open Group Publications on the Web
The Open Group Publications on
the Web
An explanation and terms for
access to HTML and PDF documents
We are pleased to be able to
publish our Standard, Guides, and other publications on the World Wide
Web.
We ask readers to give us
their name and email address for a number of reasons:
To enable us to gauge the
interest in any particular document/subject area
To enable us to alert you
to new editions of the specification
To enable us to send you
details of any corrigenda
The documents are available
under the following terms and conditions:
You should note that The
Open Group maintains full copyright protection on all
its publications.
You are permitted to read
the HTML and PDF versions of The Open Group publications using
your HTML browser/pdf reader software and to download them for
your own personal use provided you have given your
name and email address for each publication
requested. However, you are NOT permitted to amend,
copy, reprint, offer for sale, or otherwise re-use
material from these documents without explicit
permission from The Open Group.
Whilst The Open Group
will use its best endeavors to create HTML versions
that mirror the PDF publications, there are
bound to be differences between the versions. The
PDF publication remains the authoritative
version for Testing and Certification and other purposes.
The Open Group reserves
the right to charge for HTML/PDF  versions of its
publications in the future.
Readers who acquire the
HTML/PDF version of The Open Group publications from a
source other than The Open Group should be conscious
of the fact that HTML/PDF is a revisable format and that
the un-official, probably illegal, version they
acquire might have been changed from the original.
Additional terms and conditions apply to IEEE Std 1003.1 / The Base Specifications Issue 8:
The Open Group Base Specifications Issue 8, and
IEEE Std 1003.1-2024
are a joint work co-owned by the IEEE and The Open Group. We are pleased
in association with The IEEE to make this joint work available on
the World Wide Web.
For the above terms 1 through 5,
where it states The Open Group, for these documents this should be read
as The Open Group and The IEEE.
As part of our agreement with the IEEE
we are obliged to pass details  (name and email address) to the IEEE of
those who acquire these documents. The IEEE will not disclose this
information to any third party.
We invite readers to send us
comments and suggestions about our publications and
especially their presentation in HTML. Questions and comments
should be addressed to OGPubs@opengroup.org
©
2001-2024
===== susv5-html/help/codes.html =====
Codes
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
This help file is not part of the standard, but is provided for information.
Codes
The codes and their meanings are as follows. See also Margin Code Notation .
[ADV]
Advisory Information
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the ADV margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the ADV margin legend.
[CD]
C-Language Development Utilities
The functionality described is optional.
Where applicable, utilities are marked with the CD margin legend in the SYNOPSIS section. Where additional semantics apply to a
utility, the material is identified by use of the CD margin legend.
[CPT]
Process CPU-Time Clocks
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the CPT margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the CPT margin legend.
[CX]
Extension to the ISO C standard
The functionality described is an extension to the ISO C standard or a deviation from it. Application developers may make use of the functionality as it
is supported on all POSIX.1-2024-conforming systems.
With each function or header from the ISO C standard, a statement is included to the effect that "any conflict is unintentional",
or "any other conflict is unintentional" if there is an intentional conflict (deviation).
That is intended to refer to a direct conflict. POSIX.1-2024 acts in part as a profile of the ISO C standard, and it
may choose to further constrain behaviors allowed to vary by the ISO C standard. Such limitations and other compatible
differences are not considered conflicts, even if a CX mark is missing. The markings are for information only.
Where additional semantics apply to a function or header, the material is identified by use of the CX margin legend.
[DC]
Decice Control
The functionality described is optional. The functionality is also an extension to the ISO C standard.
Where applicable, functions are marked with the DC margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the DC margin legend.
[FR]
FORTRAN Runtime Utilities
The functionality described is optional.
Where applicable, utilities are marked with the FR margin legend in the SYNOPSIS section. Where additional semantics apply to a
utility, the material is identified by use of the FR margin legend.
[FSC]
File Synchronization
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the FSC margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the FSC margin legend.
[IP6]
IPV6
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the IP6 margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the IP6 margin legend.
[MC1]
Non-Robust Mutex Priority Protection or Non-Robust Mutex Priority Inheritance or Robust Mutex Priority Protection or Robust Mutex
Priority Inheritance
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
This is a shorthand notation for combinations of multiple option codes.
Where applicable, functions are marked with the MC1 margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the MC1 margin legend.
Refer to Margin Code Notation .
[ML]
Process Memory Locking
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the ML margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the ML margin legend.
[MLR]
Range Memory Locking
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the MLR margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the MLR margin legend.
[MSG]
Message Passing
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the MSG margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the MSG margin legend.
[MX]  IEC
60559 Floating-Point
The functionality described is optional. The functionality described is mandated by the ISO C standard only for implementations that define __STDC_IEC_559__.
[MXC]  IEC
60559 Complex Floating-Point
The functionality described is optional. The functionality described is mandated by the ISO C standard only for implementations that define __STDC_IEC_559_COMPLEX__.
[MXX]  IEC 60559 Floating-Point Extension
The functionality described is optional. The functionality described is part of the IEC 60559 Floating-Point option, but is an extension fo the ISO C standard
[OB]
Obsolescent
The functionality described may be removed in a future version of this volume of POSIX.1-2024. Strictly Conforming POSIX
Applications and Strictly Conforming XSI Applications shall not use obsolescent features.
Where applicable, the material is identified by use of the OB margin legend.
[OF]
Output Format Incompletely Specified
The functionality described is an XSI extension. The format of the output produced by the utility is not fully specified. It is
therefore not possible to post-process this output in a consistent fashion. Typical problems include unknown length of strings and
unspecified field delimiters.
Where applicable, the material is identified by use of the OF margin legend.
[OH]
Optional Header
In the SYNOPSIS section of some interfaces in the System Interfaces volume of POSIX.1-2024 an included header is marked as in the
following example:
[OH]
#include
#include
int open(const char *path, int oflag, ...);
The OH margin legend indicates that the optional header defines constants
that will be needed if the function is called with certain flag arguments;
thus it may be required for some of the functionality described, but is
not needed otherwise.
[PIO]
Prioritized Input and Output
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the PIO margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the PIO margin legend.
[PS]
Process Scheduling
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the PS margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the PS margin legend.
[RPI]
Robust Mutex Priority Inheritance
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the RPI margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the RPI margin legend.
[RPP]
Robust Mutex Priority Protection
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the RPP margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the RPP margin legend.
[RS]  Raw
Sockets
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the RS margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the RS margin legend.
[SD]
Software Development Utilities
The functionality described is optional.
Where applicable, utilities are marked with the SD margin legend in the SYNOPSIS section. Where additional semantics apply to a
utility, the material is identified by use of the SD margin legend.
[SHM]
Shared Memory Objects
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the SHM margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the SHM margin legend.
[SIO]
Synchronized Input and Output
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the SIO margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the SIO margin legend.
[SPN]
Spawn
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the SPN margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the SPN margin legend.
[SS]
Process Sporadic Server
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the SS margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the SS margin legend.
[TCT]
Thread CPU-Time Clocks
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the TCT margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the TCT margin legend.
[TPI]
Non-Robust Mutex Priority Inheritance
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the TPI margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the TPI margin legend.
[TPP]
Non-Robust Mutex Priority Protection
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the TPP margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the TPP margin legend.
[TPS]
Thread Execution Scheduling
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the TPS margin legend for the SYNOPSIS section. Where additional semantics apply to
a function, the material is identified by use of the TPS margin legend.
[TSA]
Thread Stack Address Attribute
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the TSA margin legend for the SYNOPSIS section. Where additional semantics apply to
a function, the material is identified by use of the TSA margin legend.
[TSH]
Thread Process-Shared Synchronization
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the TSH margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the TSH margin legend.
[TSP]
Thread Sporadic Server
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the TSP margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the TSP margin legend.
[TSS]
Thread Stack Size Attribute
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the TSS margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the TSS margin legend.
[TYM]
Typed Memory Objects
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the TYM margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the TYM margin legend.
[UP]
User Portability Utilities
The functionality described is optional.
Where applicable, utilities are marked with the UP margin legend in the SYNOPSIS section. Where additional semantics apply to a
utility, the material is identified by use of the UP margin legend.
[UU]
UUCP Utilities
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the UU margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the UU margin legend.
[XSI]
X/Open System Interfaces
The functionality described is part of the X/Open Systems Interfaces option. Functionality marked XSI is an extension to the
ISO C standard. Application developers may confidently make use of such extensions on all systems supporting the X/Open System
Interfaces option.
If an entire SYNOPSIS section is shaded and marked XSI, all the functionality described in that reference page is an extension.
See XSI Conformance .
Margin Code Notation
Some of the functionality described in POSIX.1-2024 depends on support of more than one option, or independently may depend on
several options. The following notation for margin codes is used to denote the following cases.
A Feature Dependent on One or Two Options
In this case, margin codes have a  separator; for example:
[SHM]
This feature requires support for only the Shared Memory Objects option.
[SHM TYM]  This feature requires support for both the Shared Memory Objects option and the Typed Memory Objects option; that is,
an application which uses this feature is portable only between implementations that provide both options.
A Feature Dependent on Either of the Options Denoted
In this case, margin codes have a '|' separator to denote the logical OR; for example:
[SHM|TYM]  This feature is dependent on support for either the Shared Memory Objects option or the Typed Memory Objects option; that is,
an application which uses this feature is portable between implementations that provide any (or all) of the options.
A Feature Dependent on More than Two Options
The following shorthand notations are used:
[MC1]
The MC1 margin code is shorthand for TPP|TPI|RPP|RPI. Features which are shaded with this margin code require support of either the
Non-Robust Mutex Priority Protection option or the Non-Robust Mutex Priority Inheritance option or the Robust Mutex Priority
Protection option or the Robust Mutex Priority Inheritance option.
Large Sections Dependent on an Option
Where large sections of text are dependent on support for an option, a lead-in text block is provided and shaded accordingly;
for example:
[XSI]
This section describes extensions to support interprocess communication. The functionality described in this section shall be
provided on implementations that support the XSI option (and the rest of this section is not further marked).
This help file is not part of the standard, but is provided for information.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
===== susv5-html/xbd.html =====
Base Definitions
This page uses frames, but your browser doesn't support them. Go to ToC