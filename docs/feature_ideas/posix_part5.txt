"
nn
S
:Dd:
Day delta created
"
nn
S
:T:
Time delta created
"
:Th:::Tm:::Ts:
S
:Th:
Hour delta created
"
nn
S
:Tm:
Minutes delta created
"
nn
S
:Ts:
Seconds delta created
"
nn
S
:P:
Programmer who created Delta
"
logname
S
:DS:
Delta sequence number
"
nnnn
S
:DP:
Predecessor Delta sequence number
"
nnnn
S
:DI:
Sequence number of deltas included, excluded, or ignored
"
:Dn:/:Dx:/:Dg:
S
:Dn:
Deltas included (sequence #)
"
:DS: :DS: ...
S
:Dx:
Deltas excluded (sequence #)
"
:DS: :DS: ...
S
:Dg:
Deltas ignored (sequence #)
"
:DS: :DS: ...
S
:MR:
MR numbers for delta
"
text
M
:C:
Comments for delta
"
text
M
:UN:
User names
User Names
text
M
:FL:
Flag list
Flags
text
M
:Y:
Module type flag
"
text
S
:MF:
MR validation flag
"
yes or no
S
:MP:
MR validation program name
"
text
S
:KF:
Keyword error, warning flag
"
yes or no
S
:BF:
Branch flag
"
yes or no
S
:J:
Joint edit flag
"
yes or no
S
:LK:
Locked releases
"
:R: ...
S
:Q:
User-defined keyword
"
text
S
:M:
Module name
"
text
S
:FB:
Floor boundary
"
:R:
S
:CB:
Ceiling boundary
"
:R:
S
:Ds:
Default SID
"
:I:
S
:ND:
Null delta flag
"
yes or no
S
:FD:
File descriptive text
Comments
text
M
:BD:
Body
Body
text
M
:GB:
Gotten body
"
text
M
:W:
A form of what string
N/A
:Z::M:\t:I:
S
:A:
A form of what string
N/A
:Z::Y: :M: :I::Z:
S
:Z:
what string delimiter
N/A
@(#)
S
:F:
SCCS filename
N/A
text
S
:PN:
SCCS file pathname
N/A
text
S
*
:Dt:=:DT: :I: :D: :T: :P: :DS: :DP:
**
:R:.:L:.:B:.:S: if the delta is a branch delta (:BF:==yes)
:R:.:L: if the delta is not a branch delta (:BF:==no)
***
The line statistics are capped at 99999. For example, if 100000 lines were unchanged in a certain revision, :Lu: shall
produce the value 99999.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
None.
EXAMPLES
The following example:
prs -d "User Names for :F: are:\n:UN:" s.file
might write to standard output:
User Names for s.file are:
xyz
131
abc
The following example:
prs -d "Delta for pgm :M:: :I: - :D: By :P:" -r s.file
might write to standard output:
Delta for pgm main.c: 3.7 - 77/12/01 By cas
As a special case:
prs s.file
might write to standard output:
s.file:
D 1.1 77/12/01 00:00:00 cas 1 000000/00000/00000
MRs:
bl78-12345
bl79-54321
COMMENTS:
this is the comment line for s.file initial delta
for each delta table entry of the D type. The only option allowed to be used with this special case is the
-a option.
RATIONALE
None.
FUTURE DIRECTIONS
If this utility is directed to display a pathname that contains any bytes that have the encoded value of a
character when  is a terminator or separator in the output format being used, implementations are encouraged to
treat this as an error. A future version of this standard may require implementations to treat this as an error.
SEE ALSO
admin, delta, get, what
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 2.
Issue 5
The phrase "in which keyword substitution is followed by a " is deleted from the end of the second paragraph of
Data Keywords.
The interpretation of the YY component of the -c cutoff argument is noted.
Issue 6
The normative text is reworded to emphasize the term "shall" for implementation requirements.
The Open Group Base Resolution bwg2001-007 is applied, updating the table in STDOUT with a note that line
statistics are capped at 99999 for the :Li:, :Ld:, :Lu:, and :DL: keywords.
The Open Group Interpretation PIN4C.00009 is applied.
Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to report an error if a utility is directed to display a
pathname that contains any bytes that have the encoded value of a  character when  is a terminator or
separator in the output format being used.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1452 is applied, deleting :KV: from the list of keywords.
Austin Group Defect 1570 is applied, removing extra spacing in "==".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/cmp.html =====
cmp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cmp — compare two files
SYNOPSIS
cmp [-l|-s] file1 file2
DESCRIPTION
The cmp utility shall compare two files. The cmp utility shall write no output if the files are the same. Under
default options, if they differ, it shall write to standard output the byte and line number at which the first difference occurred.
Bytes and lines shall be numbered beginning with 1.
OPTIONS
The cmp utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-l
(Lowercase ell.) Write the byte number (decimal) and the differing bytes (octal) for each difference.
-s
Write nothing to standard output or standard error when files differ; indicate differing files through exit status only. It is
unspecified whether a diagnostic message is written to standard error when an error is encountered; if a message is not written,
the error is indicated through exit status only.
OPERANDS
The following operands shall be supported:
file1
A pathname of the first file to be compared. If file1 is '-', the standard input shall be used.
file2
A pathname of the second file to be compared. If file2 is '-', the standard input shall be used.
If both file1 and file2 refer to standard input or refer to the same FIFO special, block special, or character
special file, the results are undefined.
STDIN
The standard input shall be used only if the file1 or file2 operand refers to standard input. See the INPUT FILES
section.
INPUT FILES
The input files can be any file type.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of cmp:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error and
informative messages written to standard output.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
In the POSIX locale, results of the comparison shall be written to standard output. When no options are used, the format shall
be:
"%s %s differ: char %d, line %d\n", file1, file2,
,
When the -l option is used, the format shall be:
"%d %o %o\n", , ,
for each byte that differs. The first  number is from file1 while the second is from
file2. In both cases,  shall be relative to the beginning of the file, beginning with 1.
No output shall be written to standard output when the -s option is used.
STDERR
The standard error shall be used only for diagnostic messages. If the -l option is used and file1 and file2
differ in length, or if the -s option is not used and file1 and file2 are identical for the entire length of
the shorter file, in the POSIX locale the following diagnostic message shall be written:
"cmp: EOF on %s%s\n", ,
The  field shall either be null or a string that starts with a  and contains no
characters. Some implementations report on the number of lines in this case.
If the -s option is used and an error occurs, it is unspecified whether a diagnostic message is written to standard
error.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
The files are identical.
1
The files are different; this includes the case where one file is identical to the first part of the other.
>1
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
Although input files to cmp can be any type, the results might not be what would be expected on character special device
files or on file types not described by the System Interfaces volume of POSIX.1-2024. Since this volume of POSIX.1-2024 does not
specify the block size used when doing input, comparisons of character special files need not compare all of the data in those
files.
For files which are not text files, line numbers simply reflect the presence of a , without any implication that
the file is organized into lines.
Since the behavior of -s differs between implementations as to whether error messages are written, the only way to ensure
consistent behavior of cmp when -s is used is to redirect standard error to /dev/null.
If error messages are wanted, instead of using -s standard output should be redirected to /dev/null, and anything
written to standard error should be discarded if the exit status is 1. For example:
silent_cmp() {
# compare files with no output except error messages
message=$(cmp "$@" 2>&1 >/dev/null)
status=$?
case $status in
(0|1) ;;
(*) printf '%s\n' "$message" ;;
esac
return $status
}
EXAMPLES
None.
RATIONALE
The global language in 1.4 Utility Description Defaults indicates
that using two mutually-exclusive options together produces unspecified results. Some System V implementations consider the option
usage:
cmp -l -s ...
to be an error. They also treat:
cmp -s -l ...
as if no options were specified. Both of these behaviors are considered bugs, but are allowed.
The word char in the standard output format comes from historical usage, even though it is actually a byte number. When
cmp is supported in other locales, implementations are encouraged to use the word byte or its equivalent in another
language. Users should not interpret this difference to indicate that the functionality of the utility changed between locales.
Some implementations report on the number of lines in the identical-but-shorter file case. This is allowed by the inclusion of
the  fields in the output format. The restriction on having a leading  and no
characters is to make parsing for the filename easier. It is recognized that some filenames containing white-space
characters make parsing difficult anyway, but the restriction does aid programs used on systems where the names are predominantly
well behaved.
FUTURE DIRECTIONS
If this utility is directed to display a pathname that contains any bytes that have the encoded value of a
character when  is a terminator or separator in the output format being used, implementations are encouraged to
treat this as an error. A future version of this standard may require implementations to treat this as an error.
Future versions of this standard may require that diagnostic messages are written to standard error when the -s option is
specified.
SEE ALSO
comm, diff
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 2.
Issue 7
SD5-XCU-ERN-96 is applied, updating the STDERR section.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0075 [478] is applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to report an error if a utility is directed to display a
pathname that contains any bytes that have the encoded value of a  character when  is a terminator or
separator in the output format being used.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/getopts.html =====
getopts
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getopts — parse utility options
SYNOPSIS
getopts optstring name [param...]
DESCRIPTION
The getopts utility shall retrieve options and option-arguments from a list of parameters. It shall support the Utility
Syntax Guidelines 3 to 10, inclusive, described in XBD 12.2 Utility Syntax
Guidelines.
When the shell is first invoked, the shell variable OPTIND shall be initialized to 1. Each time getopts is
invoked, it shall place the value of the next option found in the parameter list in the shell variable specified by the name
operand and the shell variable OPTIND shall be set as follows:
When getopts successfully parses an option that takes an option-argument (that is, a character followed by
in optstring, and exit status is 0), the value of OPTIND shall be the integer index of the next element of the
parameter list (if any; see OPERANDS below) to be searched for an option character. Index 1 identifies the first element of the
parameter list.
When getopts reports end of options (that is, when exit status is 1), the value of OPTIND shall be the integer
index of the next element of the parameter list (if any).
In all other cases, the value of OPTIND is unspecified, but shall encode the information needed for the next invocation
of getopts to resume parsing options after the option just parsed.
When the option requires an option-argument, the getopts utility shall place it in the shell variable OPTARG . If
no option was found, or if the option that was found does not have an option-argument, OPTARG shall be unset.
If an option character not contained in the optstring operand is found where an option character is expected, the shell
variable specified by name shall be set to the  ('?') character. In this case, if the first
character in optstring is a  (':'), the shell variable OPTARG shall be set to the option
character found, but no output shall be written to standard error; otherwise, the shell variable OPTARG shall be unset and a
diagnostic message shall be written to standard error. This condition shall be considered to be an error detected in the way
arguments were presented to the invoking application, but shall not be an error in getopts processing.
If an option-argument is missing:
If the first character of optstring is a , the shell variable specified by name shall be set to the
character and the shell variable OPTARG shall be set to the option character found.
Otherwise, the shell variable specified by name shall be set to the  character, the shell variable
OPTARG shall be unset, and a diagnostic message shall be written to standard error. This condition shall be considered to be
an error detected in the way arguments were presented to the invoking application, but shall not be an error in getopts
processing; a diagnostic message shall be written as stated, but the exit status shall be zero.
When the end of options is encountered, the getopts utility shall exit with a return value of one; the shell variable
OPTIND shall be set to the index of the argument containing the first operand in the parameter list, or the value 1 plus the
number of elements in the parameter list if there are no operands in the parameter list; the name variable shall be set to
the  character. Any of the following shall identify the end of options: the first "--" element of the
parameter list that is not an option-argument, finding an element of the parameter list that is not an option-argument and does not
begin with a '-', or encountering an error.
The shell variables OPTIND and OPTARG shall not be exported by default. An error in setting any of these variables
(such as if name has previously been marked readonly) shall be considered an error of getopts processing, and
shall result in a return value greater than one.
The getopts utility can affect OPTIND , OPTARG , and the shell variable specified by the name
operand, within the current shell execution environment; see 2.13 Shell
Execution Environment.
If the application sets OPTIND to the value 1, a new set of parameters can be used: either the current positional
parameters or new param values. Any other attempt to invoke getopts multiple times in a single shell execution
environment with parameters (positional parameters or param operands) that are not the same in all invocations, or with an
OPTIND value modified by the application to be a value other than 1, produces unspecified results.
OPTIONS
None.
OPERANDS
The following operands shall be supported:
optstring
A string containing the option characters recognized by the utility invoking getopts. If a character is followed by a
, the option shall be expected to have an argument, which should be supplied as a separate argument. Applications
should specify an option character and its option-argument as separate arguments, but getopts shall interpret the characters
following an option character requiring arguments as an argument whether or not this is done. An explicit null option-argument need
not be recognized if it is not supplied as a separate argument when getopts is invoked. (See also the getopt() function defined in the System Interfaces volume of POSIX.1-2024.) The characters
and  shall not be used as option characters by an application. The use of other option
characters that are not alphanumeric produces unspecified results. Whether or not the option-argument is supplied as a separate
argument from the option character, the value in OPTARG shall only be the characters of the option-argument. The first
character in optstring determines how getopts behaves if an option character is not known or an option-argument is
missing.
name
The name of a shell variable that shall be set by the getopts utility to the option character that was found.
By default, the list of parameters parsed by the getopts utility shall be the positional parameters currently set in the
invoking shell environment ("$@"). If param operands are given, they shall be parsed instead of the positional
parameters. Note that the next element of the parameter list need not exist; in this case, OPTIND will be set to
$#+1 or the number of param operands plus 1.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of getopts:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
OPTIND
This variable shall be used by the getopts utility as the index of the next argument to be processed.
ASYNCHRONOUS EVENTS
Default.
STDOUT
Not used.
STDERR
Whenever an error is detected and the first character in the optstring operand is not a  (':'), a
diagnostic message shall be written to standard error with the following information in an unspecified format:
The invoking program name shall be identified in the message. The invoking program name shall be the value of the shell special
parameter 0 (see 2.5.2 Special Parameters) at the time the
getopts utility is invoked. A name equivalent to:
basename "$0"
may be used.
If an option is found that was not specified in optstring, this error is identified and the invalid option character
shall be identified in the message.
If an option requiring an option-argument is found, but an option-argument is not found, this error shall be identified and the
invalid option character shall be identified in the message.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
An option, specified or unspecified by optstring, was found.
1
The end of options was encountered.
>1
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
This utility is required to be intrinsic. See 1.7 Intrinsic Utilities
for details.
Since getopts affects the current shell execution environment, it is generally provided as a shell regular built-in. If
it is called in a subshell or separate utility execution environment, such as one of the following:
(getopts abc value "$@")
nohup getopts ...
find . -exec getopts ... \;
it does not affect the shell variables in the caller's environment.
Note that shell functions share OPTIND with the calling shell even though the positional parameters are changed. If the
calling shell and any of its functions uses getopts to parse arguments, the results are unspecified.
EXAMPLES
The following example script parses and displays its arguments:
aflag=
bflag=
while getopts ab: name
do
case $name in
a)    aflag=1;;
b)    bflag=1
bval="$OPTARG";;
?)   printf "Usage: %s: [-a] [-b value] args\n" $0
exit 2;;
esac
done
if [ -n "$aflag" ]; then
printf "Option -a specified\n"
fi
if [ -n "$bflag" ]; then
printf 'Option -b "%s" specified\n' "$bval"
fi
shift $(($OPTIND - 1))
printf "Remaining arguments are: %s\n" "$*"
RATIONALE
The getopts utility was chosen in preference to the System V getopt utility because getopts handles
option-arguments containing  characters.
The OPTARG variable is not mentioned in the ENVIRONMENT VARIABLES section because it does not affect the execution of
getopts; it is one of the few "output-only" variables used by the standard utilities.
The  is not allowed as an option character because that is not historical behavior, and it violates the Utility
Syntax Guidelines. The  is now specified to behave as in the KornShell version of the getopts utility; when
used as the first character in the optstring operand, it disables diagnostics concerning missing option-arguments and
unexpected option characters. This replaces the use of the OPTERR variable that was specified in an early proposal.
Although a leading  in optstring is required to have no effect on the behavior of getopt(), this standard intentionally allows implementations of the getopts utility to
use a leading  as an extension that alters behavior. In fact, a  anywhere in the optstring
in the getopts utility produces unspecified behavior.
The formats of the diagnostic messages produced by the getopts utility and the getopt() function are not fully specified because implementations with superior
("friendlier") formats objected to the formats used by some historical implementations. The standard developers considered it
important that the information in the messages used be uniform between getopts and getopt(). Exact duplication of the messages might not be possible, particularly if a utility
is built on another system that has a different getopt() function, but the messages
must have specific information included so that the program name, invalid option character, and type of error can be distinguished
by a user.
Only a rare application program intercepts a getopts standard error message and wants to parse it. Therefore,
implementations are free to choose the most usable messages they can devise. The following formats are used by many historical
implementations:
"%s: illegal option -- %c\n", ,
"%s: option requires an argument -- %c\n", , \
Historical shells with built-in versions of getopt() or getopts have used
different formats, frequently not even indicating the option character found in error.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5.2 Special Parameters
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
XSH getopt()
CHANGE HISTORY
First released in Issue 4.
Issue 6
The normative text is reworded to avoid use of the term "must" for application requirements.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0092 [159] is applied.
Issue 8
Austin Group Defect 191 is applied, adding a paragraph about leading  to the RATIONALE section.
Austin Group Defect 367 is applied, requiring that getopts distinguishes between encountering the end of options and an
error occurring, setting its exit status to one and greater than one, respectively.
Austin Group Defect 854 is applied, adding a note to the APPLICATION USAGE section that this utility is required to be
intrinsic.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1442 is applied, changing the EXAMPLES section.
Austin Group Defect 1784 is applied, clarifying several aspects of getopts behavior and changing the value of
OPTIND to be unspecified in some circumstances.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/break.html =====
Shell Command Language
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
Please enable javascript in your browser to automatically redirect to the target page, otherwise select the link below.
2.15 Special Built-In Utilities
break
colon
continue
dot
eval
exec
exit
export
readonly
return
set
shift
times
trap
unset
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
===== susv5-html/utilities/set.html =====
Shell Command Language
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
Please enable javascript in your browser to automatically redirect to the target page, otherwise select the link below.
2.15 Special Built-In Utilities
break
colon
continue
dot
eval
exec
exit
export
readonly
return
set
shift
times
trap
unset
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
===== susv5-html/utilities/more.html =====
more
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
more — display files on a page-by-page basis
SYNOPSIS
[UP]  more [-ceisu] [-n number] [-p
command] [-t tagstring] [file...]
DESCRIPTION
The more utility shall read files and either write them to the terminal on a page-by-page basis or filter them to
standard output. If standard output is not a terminal device, all input files shall be copied to standard output in their entirety,
without modification, except as specified for the -s option. If standard output is a terminal device, the files shall be
written a number of lines (one screenful) at a time under the control of user commands. See the EXTENDED DESCRIPTION section.
Certain block-mode terminals do not have all the capabilities necessary to support the complete more definition; they are
incapable of accepting commands that are not terminated with a . Implementations that support such terminals shall
provide an operating mode to more in which all commands can be terminated with a  on those terminals. This
mode:
Shall be documented in the system documentation
Shall, at invocation, inform the user of the terminal deficiency that requires the  usage and provide
instructions on how this warning can be suppressed in future invocations
Shall not be required for implementations supporting only fully capable terminals
Shall not affect commands already requiring  characters
Shall not affect users on the capable terminals from using more as described in this volume of POSIX.1-2024
OPTIONS
The more utility shall conform to XBD 12.2 Utility Syntax
Guidelines, except that '+' may be recognized as an option delimiter as well as '-'.
The following options shall be supported:
-c
If a screen is to be written that has no lines in common with the current screen, or more is writing its first screen,
more shall not scroll the screen, but instead shall redraw each line of the screen in turn, from the top of the screen to
the bottom. In addition, if more is writing its first screen, the screen shall be cleared. This option may be silently
ignored on devices with insufficient terminal capabilities.
-e
Exit immediately after writing the last line of the last file in the argument list; see the EXTENDED DESCRIPTION section.
-i
Perform pattern matching in a case-insensitive manner; see XBD 9.2 Regular
Expression General Requirements.
-n number
Specify the number of lines per screenful. The number argument is a positive decimal integer. The -n option shall
override any values obtained from any other source.
-p command
Each time a screen from a new file is displayed or redisplayed (including as a result of more commands; for example,
:p), execute the more command(s) in the command arguments in the order specified, as if entered by the user after the
first screen has been displayed. No intermediate results shall be displayed (that is, if the command is a movement to a screen
different from the normal first screen, only the screen resulting from the command shall be displayed.) If any of the commands fail
for any reason, an informational message to this effect shall be written, and no further commands specified using the -p
option shall be executed for this file.
-s
Behave as if consecutive empty lines were a single empty line.
-t tagstring
Write the screenful of the file containing the tag named by the tagstring argument. See the ctags utility. The tags feature represented by -t tagstring and the :t
command is optional. It shall be provided on any system that also provides a conforming implementation of ctags; otherwise, the use of -t produces undefined results.
The filename resulting from the -t option shall be logically added as a prefix to the list of command line files, as if
specified by the user. If the tag named by the tagstring argument is not found, it shall be an error, and more shall
take no further action.
If the tag specifies a line number, the first line of the display shall contain the beginning of that line. If the tag specifies
a pattern, the first line of the display shall contain the beginning of the matching text from the first line of the file that
contains that pattern. If the line does not exist in the file or matching text is not found, an informational message to this
effect shall be displayed, and more shall display the default screen as if -t had not been specified.
If both the -t tagstring and -p command options are given, the -t tagstring shall be
processed first; that is, the file and starting line for the display shall be as specified by -t, and then the -p
more command shall be executed. If the line (matching text) specified by the -t command does not exist (is not
found), no -p more command shall be executed for this file at any time.
-u
Treat a  as a printable control character, displayed as an implementation-defined character sequence (see the
EXTENDED DESCRIPTION section), suppressing backspacing and the special handling that produces underlined or standout mode text on
some terminal types. Also, do not ignore a  at the end of a line.
OPERANDS
The following operand shall be supported:
file
A pathname of an input file. If no file operands are specified, the standard input shall be used. If a file is
'-', the standard input shall be read at that point in the sequence.
STDIN
The standard input shall be used only if no file operands are specified, or if a file operand is '-'.
INPUT FILES
The input files being examined shall be text files. If standard output is a terminal, standard error shall be used to read
commands from the user. If standard output is a terminal, standard error is not readable, and command input is needed, more
may attempt to obtain user commands from the controlling terminal (for example, /dev/tty); otherwise, more shall
terminate with an error indicating that it was unable to read user commands. If standard output is not a terminal, no error shall
result if standard error cannot be opened for reading.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of more:
COLUMNS
Override the system-selected horizontal display line size. See XBD 8.
Environment Variables for valid values and results when it is unset or null.
EDITOR
Used by the v command to select an editor. See the EXTENDED DESCRIPTION section.
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_COLLATE
Determine the locale for the behavior of ranges, equivalence classes, and multi-character collating elements within regular
expressions.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files) and the behavior of character classes within regular
expressions.
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error and
informative messages written to standard output.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
LINES
Override the system-selected vertical screen size, used as the number of lines in a screenful. See XBD 8. Environment Variables for valid values and results when it is unset or null. The
-n option shall take precedence over the LINES variable for determining the number of lines in a screenful.
MORE
Determine a string containing options described in the OPTIONS section preceded with  characters and
-separated as on the command line. Any command line options shall be processed after those in the MORE
variable, as if the command line were:
more $MORE options operands
The MORE variable shall take precedence over the TERM and LINES variables for determining the number of
lines in a screenful.
TERM
Determine the name of the terminal type. If this variable is unset or null, an unspecified default terminal type is used.
ASYNCHRONOUS EVENTS
The following actions shall be taken upon receipt of signals:
SIGCONT
The actions described below for SIGWINCH shall be taken, except that the screen shall always be refreshed (regardless of
whether the terminal window size changed).
SIGWINCH
If standard output is a terminal, the current terminal window size associated with the terminal on standard output shall be
obtained, as if by a call to XSH tcgetwinsize(). If the terminal window size
is successfully obtained, it shall be used as follows:
If the COLUMNS environment variable is unset or does not contain a number, the horizontal display line size shall be set
to the number of columns in the obtained terminal window size.
If the -n option was not specified (neither on the command line nor via the MORE environment variable) and the
LINES environment variable is unset or does not contain a number, the vertical screen size shall be set to the number of
rows in the obtained terminal window size.
If the above resulted in either the vertical screen size or the horizontal display line size (or both) changing to a different
value, the number of lines available per screen and the number of columns available per line shall be updated correspondingly (see
XBD 8. Environment Variables) and the screen shall be refreshed; otherwise,
the screen may be refreshed.
The action taken for all other signals shall be the default.
STDOUT
The standard output shall be used to write the contents of the input files.
STDERR
The standard error shall be used for diagnostic messages and user commands (see the INPUT FILES section), and, if standard
output is a terminal device, to write a prompting string. The prompting string shall appear on the screen line below the last line
of the file displayed in the current screenful. The prompt shall contain the name of the file currently being examined and shall
contain an end-of-file indication and the name of the next file, if any, when prompting at the end-of-file. If an error or
informational message is displayed, it is unspecified whether it is contained in the prompt. If it is not contained in the prompt,
it shall be displayed and then the user shall be prompted for a continuation character, at which point another message or the user
prompt may be displayed. The prompt is otherwise unspecified. It is unspecified whether informational messages are written for
other user commands.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
The following section describes the behavior of more when the standard output is a terminal device. If the standard
output is not a terminal device, no options other than -s shall have any effect, and all input files shall be copied to
standard output otherwise unmodified, at which time more shall exit without further action.
The number of lines available per screen shall be determined by the -n option, if present, or by obtaining the vertical
screen size from the LINES environment variable (see the ENVIRONMENT VARIABLES section) or from the terminal window size
associated with the terminal on standard output (see XSH tcgetwinsize()),
with a default value as described in XBD 8. Environment Variables.
The maximum number of lines written shall be one less than this number, because the screen line after the last line written
shall be used to write a user prompt and user input. If the number of lines in the screen is less than two, the results are
undefined. It is unspecified whether user input is permitted to be longer than the remainder of the single line where the prompt
has been written.
The number of columns available per line shall be determined by obtaining the horizontal display line size from the
COLUMNS environment variable (see the ENVIRONMENT VARIABLES section) or from the terminal window size associated with the
terminal on standard output (see XSH tcgetwinsize()), with a default value as
described in XBD 8. Environment Variables.
Lines that are longer than the display shall be folded; the length at which folding occurs is unspecified, but should be
appropriate for the output device. Folding may occur between glyphs of single characters that take up multiple display columns.
When standard output is a terminal and -u is not specified, more shall treat  and
characters specially:
A character, followed first by a sequence of n  characters (where n is the same as the number of
column positions that the character occupies), then by n  characters ('_'), shall cause that
character to be written as underlined text, if the terminal type supports that. The n  characters,
followed first by n  characters, then any character with n column positions, shall also cause that
character to be written as underlined text, if the terminal type supports that.
A sequence of n  characters (where n is the same as the number of column positions that the
previous character occupies) that appears between two identical printable characters shall cause the first of those two characters
to be written as emboldened text (that is, visually brighter, standout mode, or inverse-video mode), if the terminal type supports
that, and the second to be discarded. Immediately subsequent occurrences of /character pairs for that same
character shall also be discarded. (For example, the sequence "a\ba\ba\ba" is interpreted as a single emboldened
'a'.)
The more utility shall logically discard all other  characters from the line as well as the character
which precedes them, if any.
A  at the end of a line shall be ignored, rather than being written as a non-printable character, as
described in the next paragraph.
It is implementation-defined how other non-printable characters are written. Implementations should use the same format that
they use for the ex print command; see the OPTIONS section within the ed utility. It is unspecified whether a multi-column character shall be separated if it crosses a
display line boundary; it shall not be discarded. The behavior is unspecified if the number of columns on the display is less than
the number of columns any single character in the line being displayed would occupy.
When each new file is displayed (or redisplayed), more shall write the first screen of the file. Once the initial screen
has been written, more shall prompt for a user command. If the execution of the user command results in a screen that has
lines in common with the current screen, and the device has sufficient terminal capabilities, more shall scroll the screen;
otherwise, it is unspecified whether the screen is scrolled or redrawn.
For all files but the last (including standard input if no file was specified, and for the last file as well, if the -e
option was not specified), when more has written the last line in the file, more shall prompt for a user command.
This prompt shall contain the name of the next file as well as an indication that more has reached end-of-file. If the user
command is f, -F, , j, , d, -D, or s,
more shall display the next file. Otherwise, if displaying the last file, more shall exit. Otherwise, more
shall execute the user command specified.
Several of the commands described in this section display a previous screen from the input stream. In the case that text is
being taken from a non-rewindable stream, such as a pipe, it is implementation-defined how much backwards motion is supported. If a
command cannot be executed because of a limitation on backwards motion, an error message to this effect shall be displayed, the
current screen shall not change, and the user shall be prompted for another command.
If a command cannot be performed because there are insufficient lines to display, more shall alert the terminal. If a
command cannot be performed because there are insufficient lines to display or a / command fails: if the input is the
standard input, the last screen in the file may be displayed; otherwise, the current file and screen shall not change, and the user
shall be prompted for another command.
The interactive commands in the following sections shall be supported. Some commands can be preceded by a decimal integer,
called count in the following descriptions. If not specified with the command, count shall default to 1. In the
following descriptions, pattern is a basic regular expression, as described in XBD 9.3 Basic Regular Expressions. The term "examine" is historical usage meaning
"open the file for viewing"; for example, more foo would be expressed as examining file foo.
In the following descriptions, unless otherwise specified, line is a line in the more display, not a line from the
file being examined.
In the following descriptions, the current position refers to two things:
The position of the current line on the screen
The line number (in the file) of the current line on the screen
Usually, the line on the screen corresponding to the current position is the third line on the screen. If this is not possible
(there are fewer than three lines to display or this is the first page of the file, or it is the last page of the file), then the
current position is either the first or last line on the screen as described later.
Help
Synopsis:
h
Write a summary of these commands and other implementation-defined commands. The behavior shall be as if the more utility
were executed with the -e option on a file that contained the summary information. The user shall be prompted as described
earlier in this section when end-of-file is reached. If the user command is one of those specified to continue to the next file,
more shall return to the file and screen state from which the h command was executed.
Scroll Forward One Screenful
Synopsis:
[count]f
[count]-F
Scroll forward count lines, with a default of one screenful. If count is more than the screen size, only the final
screenful shall be written.
Scroll Backward One Screenful
Synopsis:
[count]b
[count]-B
Scroll backward count lines, with a default of one screenful (see the -n option). If count is more than the
screen size, only the final screenful shall be written.
Scroll Forward One Line
Synopsis:
[count]
[count]j
[count]
Scroll forward count lines. The default count for the  shall be one screenful; for j and
, one line. The entire count lines shall be written, even if count is more than the screen size.
Scroll Backward One Line
Synopsis:
[count]k
Scroll backward count lines. The entire count lines shall be written, even if count is more than the screen
size.
Scroll Forward One Half Screenful
Synopsis:
[count]d
[count]-D
Scroll forward count lines, with a default of one half of the screen size. If count is specified, it shall become
the new default for subsequent d, -D, and u commands.
Skip Forward One Line
Synopsis:
[count]s
Display the screenful beginning with the line count lines after the last line on the current screen. If count
would cause the current position to be such that less than one screenful would be written, the last screenful in the file shall be
written.
Scroll Backward One Half Screenful
Synopsis:
[count]u
[count]-U
Scroll backward count lines, with a default of one half of the screen size. If count is specified, it shall become
the new default for subsequent d, -D, u, and -U commands. The entire count lines
shall be written, even if count is more than the screen size.
Go to Beginning of File
Synopsis:
[count]g
Display the screenful beginning with line count.
Go to End-of-File
Synopsis:
[count]G
If count is specified, display the screenful beginning with the line count. Otherwise, display the last screenful
of the file.
Refresh the Screen
Synopsis:
r
-L
Refresh the screen.
Discard and Refresh
Synopsis:
R
Refresh the screen, discarding any buffered input. If the current file is non-seekable, buffered input shall not be discarded
and the R command shall be equivalent to the r command.
Mark Position
Synopsis:
mletter
Mark the current position with the letter named by letter, where letter represents the name of one of the
lowercase letters of the portable character set. When a new file is examined, all marks may be lost.
Return to Mark
Synopsis:
'letter
Return to the position that was previously marked with the letter named by letter, making that line the current
position.
Return to Previous Position
Synopsis:
''
Return to the position from which the last large movement command was executed (where a "large movement" is defined as any
movement of more than a screenful of lines). If no such movements have been made, return to the beginning of the file.
Search Forward for Pattern
Synopsis:
[count]/[!]pattern
Display the screenful beginning with the countth line containing the pattern. The search shall start after the first line
currently displayed. The null regular expression ('/' followed by a ) shall repeat the search using the
previous regular expression, with a default count. If the character '!' is included, the matching lines shall be
those that do not contain the pattern. If no match is found for the pattern, a message to that effect shall be
displayed.
Search Backward for Pattern
Synopsis:
[count]?[!]pattern
Display the screenful beginning with the countth previous line containing the pattern. The search shall start on the last
line before the first line currently displayed. The null regular expression ('?' followed by a ) shall
repeat the search using the previous regular expression, with a default count. If the character '!' is included,
matching lines shall be those that do not contain the pattern. If no match is found for the pattern, a message to
that effect shall be displayed.
Repeat Search
Synopsis:
[count]n
Repeat the previous search for countth line containing the last pattern (or not containing the last
pattern, if the previous search was "/!" or "?!").
Repeat Search in Reverse
Synopsis:
[count]N
Repeat the search in the opposite direction of the previous search for the countth line containing the last
pattern (or not containing the last pattern, if the previous search was "/!" or "?!").
Examine New File
Synopsis:
:e [filename]
Examine a new file. If the filename argument is not specified, the current file (see the :n and :p commands
below) shall be re-examined. The filename shall be subjected to the process of shell word expansions (see 2.6 Word Expansions); if more than a single pathname results, the effects are
unspecified. If filename is a  ('#'), the previously examined file shall be re-examined. If
filename is not accessible for any reason (including that it is a non-seekable file), an error message to this effect shall
be displayed and the current file and screen shall not change.
Examine Next File
Synopsis:
[count]:n
Examine the next file. If a number count is specified, the countth next file shall be examined. If filename
refers to a non-seekable file, the results are unspecified.
Examine Previous File
Synopsis:
[count]:p
Examine the previous file. If a number count is specified, the countth previous file shall be examined. If
filename refers to a non-seekable file, the results are unspecified.
Go to Tag
Synopsis:
:t tagstring
If the file containing the tag named by the tagstring argument is not the current file, examine the file, as if the
:e command was executed with that file as the argument. Otherwise, or in addition, display the screenful beginning with the
tag, as described for the -t option (see the OPTIONS section). If the ctags
utility is not supported by the system, the use of :t produces undefined results.
Invoke Editor
Synopsis:
v
Invoke an editor to edit the current file being examined. If standard input is being examined, the results are unspecified. The
name of the editor shall be taken from the environment variable EDITOR , or shall default to vi. If the last pathname component in EDITOR is either vi or ex, the editor shall be invoked with a -c
linenumber command line argument, where linenumber is the line number of the file line containing the display line
currently displayed as the first line of the screen. It is implementation-defined whether line-setting options are passed to
editors other than vi and ex.
When the editor exits, more shall resume with the same file and screen as when the editor was invoked.
Display Position
Synopsis:
=
-G
Write a message for which the information references the first byte of the line after the last line of the file on the screen.
This message shall include the name of the file currently being examined, its number relative to the total number of files there
are to examine, the line number in the file, the byte number and the total bytes in the file, and what percentage of the file
precedes the current position. If more is reading from standard input, or the file is shorter than a single screen, the line
number, the byte number, the total bytes, and the percentage need not be written.
Quit
Synopsis:
q
:q
ZZ
Exit more.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
If an error is encountered accessing a file when using the :n command, more shall attempt to examine the next file
in the argument list, but the final exit status shall be affected. If an error is encountered accessing a file via the :p
command, more shall attempt to examine the previous file in the argument list, but the final exit status shall be affected.
If an error is encountered accessing a file via the :e command, more shall remain in the current file and the final
exit status shall not be affected.
The following sections are informative.
APPLICATION USAGE
When the standard output is not a terminal, only the -s filter-modification option is effective. This is based on
historical practice. For example, a typical implementation of man pipes its output
through more -s to squeeze excess white space for terminal users. When man
is piped to lp, however, it is undesirable for this squeezing to happen.
EXAMPLES
The -p allows arbitrary commands to be executed at the start of each file. Examples are:
more -p G file1 file2
Examine each file starting with its last screenful.
more -p 100 file1 file2
Examine each file starting with line 100 in the current position (usually the third line, so line 98 would be the first line
written).
more -p /100 file1 file2
Examine each file starting with the first line containing the string "100" in the current position
RATIONALE
The more utility, available in BSD and BSD-derived systems, was chosen as the prototype for the POSIX file display
program since it is more widely available than either the public-domain program less or than pg, a pager provided in
System V. The 4.4 BSD more is the model for the features selected; it is almost fully upwards-compatible from the 4.3 BSD
version in wide use and has become more amenable for vi users. Several features
originally derived from various file editors, found in both less and pg, have been added to this volume of
POSIX.1-2024 as they have proved extremely popular with users.
There are inconsistencies between more and vi that result from historical
practice. For example, the single-character commands h, f, b, and  are screen movers in
more, but cursor movers in vi. These inconsistencies were maintained because the
cursor movements are not applicable to more and the powerful functionality achieved without the use of the control key
justifies the differences.
The tags interface has been included in a program that is not a text editor because it promotes another degree of consistent
operation with vi. It is conceivable that the paging environment of more would be
superior for browsing source code files in some circumstances.
The operating mode referred to for block-mode terminals effectively adds a  to each Synopsis line that currently
has none. So, for example, d would page one screenful. The mode could be triggered by a command line option,
environment variable, or some other method. The details are not imposed by this volume of POSIX.1-2024 because there are so few
systems known to support such terminals. Nevertheless, it was considered that all systems should be able to support more
given the exception cited for this small community of terminals because, in comparison to vi, the cursor movements are few and the command set relatively amenable to the optional
characters.
Historically some versions of more did not obtain the terminal window size on receipt of SIGCONT, resulting in incorrect
screen contents when the screen was refreshed if the size had been changed while more was suspended. This is considered to
be a bug in those implementations.
Some versions of more provide a shell escaping mechanism similar to the ex
! command. The standard developers did not consider that this was necessary in a paginator, particularly given the wide
acceptance of multiple window terminals and job control features. (They chose to retain such features in the editors and mailx because the shell interaction also gives an opportunity to modify the editing buffer,
which is not applicable to more.)
The -p (position) option replaces the + command because of the Utility Syntax Guidelines. The
+command option is no longer specified by POSIX.1-2024 but may be present in some implementations. In early
proposals, it took a pattern argument, but historical less provided the more general facility of a command. It
would have been desirable to use the same -c as ex and vi, but the letter was already in use.
The text stating "from a non-rewindable stream ... implementations may limit the amount of backwards motion supported" would
allow an implementation that permitted no backwards motion beyond text already on the screen. It was not possible to require a
minimum amount of backwards motion that would be effective for all conceivable device types. The implementation should allow the
user to back up as far as possible, within device and reasonable memory allocation constraints.
Historically, non-printable characters were displayed using the ARPA standard mappings, which are as follows:
Printable characters are left alone.
Control characters less than \177 are represented as followed by the character offset from the '@' character in the
ASCII map; for example, \007 is represented as 'G'.
\177 is represented as followed by '?'.
The display of characters having their eighth bit set was less standard. Existing implementations use hex (0x00), octal (\000),
and a meta-bit display. (The latter displayed characters with their eighth bit set as the two characters "M-", followed by
the seven-bit display as described previously.) The latter probably has the best claim to historical practice because it was used
with the -v option of 4 BSD and 4 BSD-derived versions of the cat utility since
1980.
No specific display format is required by POSIX.1-2024. Implementations are encouraged to conform to historic practice in the
absence of any strong reason to diverge.
FUTURE DIRECTIONS
None.
SEE ALSO
2. Shell Command Language, ctags, ed, ex, vi
XBD 8. Environment Variables, 9.2 Regular Expression General Requirements, 9.3 Basic Regular Expressions, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 4.
Issue 5
The FUTURE DIRECTIONS section is added.
Issue 6
This utility is marked as part of the User Portability Utilities option.
The obsolescent SYNOPSIS is removed.
The utility has been extensively reworked for alignment with the IEEE P1003.2b draft standard:
Changes have been made as a result of IEEE PASC Interpretations 1003.2 #37 and #109.
The more utility should be able to handle underlined and emboldened displays of characters that are wider than a single
column position.
Issue 7
Austin Group Interpretation 1003.1-2001 #027 is applied, clarifying that '+' may be recognized as an option delimiter
in the OPTIONS section.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0123 [265] is applied.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0146 [584] is applied.
Issue 8
Austin Group Defect 1031 is applied, changing the description of the -i option.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1185 is applied, changing the ASYNCHRONOUS EVENTS and EXTENDED DESCRIPTION sections in relation to the
terminal window size.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/date.html =====
date
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
date — write the date and time
SYNOPSIS
date [-u] [+format]
[XSI]  date [-u] mmddhhmm[[cc]yy]
DESCRIPTION
The date utility shall write the date and time to standard output [XSI]   or attempt
to set the system date and time.  By default, the current date and
time shall be written. If an operand beginning with '+' is specified, the output format of date shall be controlled
by the conversion specifications and other text in the operand.
OPTIONS
The date utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following option shall be supported:
-u
Perform operations as if the TZ environment variable was set to the string "UTC0", or its equivalent historical
value of "GMT0". Otherwise, date shall use the timezone indicated by the TZ environment variable or the
system default if that variable is unset or null.
OPERANDS
The following operands shall be supported:
+format
When the format is specified, the output shall be formatted as if by strftime()
with the specified format string, and a timeptr argument that is the equivalent of localtime(&now) if
-u is not specified or gmtime(&now) if -u is specified, where now is an object of type
time_t containing the return value of time(0).
A  shall always be appended to the output of strftime().
mmddhhmm[[cc]yy]
[XSI]
Attempt to set the system date and time from the value given in the operand. This is only possible if the user has appropriate
privileges and the system permits the setting of the system date and time. The first mm is the month (number); dd is
the day (number); hh is the hour (number, 24-hour system); the second mm is the minute (number); cc is the
century and is the first two digits of the year (this is optional); yy is the last two digits of the year and is optional.
If century is not specified, then values in the range [69,99] shall refer to years 1969 to 1999 inclusive, and values in the range
[00,68] shall refer to years 2000 to 2068 inclusive. The current year is the default if yy is omitted.
Note:
It is expected that in a future version of this standard the default century inferred from a 2-digit year will change. (This
would apply to all commands accepting a 2-digit year as input.)
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of date:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
LC_TIME
Determine the format and contents of date and time strings written by date.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
TZ
Determine the timezone in which the time and date are written, unless the -u option is specified. If the TZ
variable is unset or null and -u is not specified, an unspecified system default timezone is used.
ASYNCHRONOUS EVENTS
Default.
STDOUT
When no formatting operand is specified, the output in the POSIX locale shall be equivalent to specifying:
date "+%a %b %e %H:%M:%S %Z %Y"
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
The date was written successfully.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
Conversion specifiers are of unspecified format when not in the POSIX locale. Some of them can contain
characters in some locales, so it may be difficult to use the format shown in standard output for parsing the output of date
in those locales.
Since the default date utility format for locales other than the POSIX or C locale is not required to include anything
beyond the date and time, whereas for the POSIX or C locale it also includes the day name and time zone, it may be necessary to
specify a format (or override the locale-selection environment variables) to ensure this information is included when desired.
The range of values for %S extends from 0 to 60 seconds to accommodate the occasional leap second.
Although certain of the conversion specifiers in the POSIX locale (such as the name of the month) are shown with initial capital
letters, this need not be the case in other locales. Programs using these fields may need to adjust the capitalization if the
output is going to be used at the beginning of a sentence.
The date string formatting capabilities are intended for use in Gregorian-style calendars, possibly with a different starting
year (or years). The %x and %c conversion specifications, however, are intended for local representation; these
may be based on a different, non-Gregorian calendar.
The %C conversion specification was introduced to allow a fallback for the %EC (alternative year format base
year); it can be viewed as the base of the current subdivision in the Gregorian calendar. The century number is calculated as the
year divided by 100 and truncated to an integer; it should not be confused with the use of ordinal numbers for centuries (for
example, "twenty-first century".) Both the %Ey and %y can then be viewed as the offset from %EC and
%C, respectively.
The E and O modifiers modify the traditional conversion specifiers, so that they can always be used, even if
the implementation (or the current locale) does not support the modifier.
The E modifier supports alternative date formats, such as the Japanese Emperor's Era, as long as these are based on the
Gregorian calendar system. Extending the E modifiers to other date elements may provide an implementation-defined
extension capable of supporting other calendar systems, especially in combination with the O modifier.
The O modifier supports time and date formats using the locale's alternative numerical symbols, such as Kanji or Hindi
digits or ordinal number representation.
Non-European locales, whether they use Latin digits in computational items or not, often have local forms of the digits for use
in date formats. This is not totally unknown even in Europe; a variant of dates uses Roman numerals for the months: the third day
of September 1991 would be written as 3.IX.1991. In Japan, Kanji digits are regularly used for dates; in Arabic-speaking countries,
Hindi digits are used. The %d, %e, %H, %I, %m, %S, %U, %w,
%W, and %y conversion specifications always return the date and time field in Latin digits (that is, 0 to 9). The
%O modifier was introduced to support the use for display purposes of non-Latin digits. In the LC_TIME category in
localedef, the optional alt_digits keyword is intended for this purpose. As
an example, assume the following (partial) localedef source:
alt_digits  "";"I";"II";"III";"IV";"V";"VI";"VII";"VIII" \
"IX";"X";"XI";"XII"
d_fmt       "%e.%Om.%Y"
With the above date, the command:
date "+%x"
would yield 3.IX.1991. With the same d_fmt, but without the alt_digits, the command would yield 3.9.1991.
EXAMPLES
The following are input/output examples of date used at arbitrary times in the POSIX locale:
$ date
Tue Jun 26 09:58:10 PDT 1990
$ date "+DATE: %m/%d/%y%nTIME: %H:%M:%S"
DATE: 11/02/91
TIME: 13:36:16
$ date "+TIME: %r"
TIME: 01:36:32 PM
Examples for Denmark, where the default date and time format is %a %d %b %Y %T
%Z:
$ LANG=da_DK.iso_8859-1 date
ons 02 okt 1991 15:03:32 CET
$ LANG=da_DK.iso_8859-1 \
date "+DATO: %A den %e. %B %Y%nKLOKKEN: %H:%M:%S"
DATO: onsdag den 2. oktober 1991
KLOKKEN: 15:03:56
Examples for Germany, where the default date and time format is %a %d.%h.%Y, %T
%Z:
$ LANG=De_DE.88591 date
Mi 02.Okt.1991, 15:01:21 MEZ
$ LANG=De_DE.88591 date "+DATUM: %A, %d. %B %Y%nZEIT: %H:%M:%S"
DATUM: Mittwoch, 02. Oktober 1991
ZEIT: 15:02:02
Examples for France, where the default date and time format is %a %d %h %Y %Z
%T:
$ LANG=Fr_FR.88591 date
Mer 02 oct 1991 MET 15:03:32
$ LANG=Fr_FR.88591 date "+JOUR: %A %d %B %Y%nHEURE: %H:%M:%S"
JOUR: Mercredi 02 octobre 1991
HEURE: 15:03:56
RATIONALE
Some of the new options for formatting are from the ISO C standard. The -u option was introduced to allow portable
access to Coordinated Universal Time (UTC). The string "GMT0" is allowed as an equivalent TZ value to be compatible
with all of the systems using the BSD implementation, where this option originated.
The %e format conversion specification (adopted from System V) was added because the ISO C standard conversion
specifications did not provide any way to produce the historical default date output during the first nine days of any
month.
There are two varieties of day and week numbering supported (in addition to any others created with the locale-dependent
%E and %O modifier characters):
The historical variety in which Sunday is the first day of the week and the weekdays preceding the first Sunday of the year are
considered week 0. These are represented by %w and %U. A variant of this is %W, using Monday as the
first day of the week, but still referring to week 0. This view of the calendar was retained because so many historical
applications depend on it and the ISO C standard strftime() function, on which
many date implementations are based, was defined in this way.
The international standard, based on the ISO 8601:2019 standard where Monday is the first weekday and the algorithm for the
first week number is more complex: If the week (Monday to Sunday) containing January 1 has four or more days in the new year, then
it is week 1; otherwise, it is week 53 of the previous year, and the next week is week 1. These are represented by the new
conversion specifications %u and %V, added as a result of international comments.
Although this standard only requires the default date utility format, for locales other than the POSIX or C locale, to
include the date and time, it is common for implementations to include day name and time zone information as well. (For the POSIX
locale this is required, with the day name in %a format at the beginning and the time zone in %Z format before
the year.) Implementations are encouraged to include the day name (in %a or %A format) and the time zone (in
%Z or %z format) in the default date utility format for all of the locales they provide.
Some implementations have a date_fmt locale keyword (see 7.3.5
LC_TIME) as an extension, to specify the default date utility format for each locale. On such implementations, if
the localedef utility is used to create a locale that does not have this
information, the date utility must by default still produce output for that locale that includes both the time and the
date.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD 7.3.5 LC_TIME, 8. Environment Variables, 12.2
Utility Syntax Guidelines
XSH fprintf(), strftime()
CHANGE HISTORY
First released in Issue 2.
Issue 5
Changes are made for Year 2000 alignment.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The %EX modified conversion specification is added.
The Open Group Corrigendum U048/2 is applied, correcting the examples.
The DESCRIPTION is updated to refer to conversion specifications, instead of field descriptors for consistency with the
LC_TIME category.
A clarification is made such that the current year is the default if the yy argument is omitted when setting the system
date and time.
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/19 is applied, correcting the CHANGE HISTORY section.
Issue 8
Austin Group Defect 466 is applied, replacing the list of conversion specifications for the +format operand with a
requirement that the output is formatted as if by a call to strftime() with
specific arguments.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1345 is applied, adding paragraphs to APPLICATION USAGE and RATIONALE about the default date utility
format.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/touch.html =====
touch
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
touch — change file access and modification times
SYNOPSIS
touch [-acm] [-r ref_file|-t time|-d
date_time] file...
DESCRIPTION
The touch utility shall change the last data modification timestamps, the last data access timestamps, or both.
The time used can be specified by the -t time option-argument, the corresponding time fields of the file
referenced by the -r ref_file option-argument, or the -d date_time option-argument, as specified in the
following sections. If none of these are specified, touch shall use the current time.
For each file operand, touch shall perform actions equivalent to the following functions defined in the System
Interfaces volume of POSIX.1-2024:
If file does not exist:
The creat() function is called with the following arguments:
The file operand is used as the path argument.
The value of the bitwise-inclusive OR of S_IRUSR, S_IWUSR, S_IRGRP, S_IWGRP, S_IROTH, and S_IWOTH is used as the mode
argument.
The futimens() function is called with the following arguments:
The file descriptor opened in step 1a.
The access time and the modification time, set as described in the OPTIONS section, are used as the first and second elements of
the times array argument, respectively.
If file exists, the utimensat() function is called with the following
arguments:
The AT_FDCWD special value is used as the fd argument.
The file operand is used as the path argument.
The access time and the modification time, set as described in the OPTIONS section, are used as the first and second elements of
the times array argument, respectively.
The flag argument is set to zero.
OPTIONS
The touch utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-a
Change the access time of file. Do not change the modification time unless -m is also specified.
-c
Do not create a specified file if it does not exist. Do not write any diagnostic messages concerning this
condition.
-d date_time
Use the specified date_time instead of the current time. The option-argument shall be a string of the form:
YYYY-MM-DDThh:mm:SS[.frac][tz]
or:
YYYY-MM-DDThh:mm:SS[,frac][tz]
where:
YYYY are at least four decimal digits giving the year.
MM, DD, hh, mm, and SS are as with -t time.
T is the time designator, and can be replaced by a single .
[.frac] and [,frac] are either empty, or a  ('.') or a
(',') respectively, followed by one or more decimal digits, specifying a fractional second.
[tz] is either empty, signifying local time, or the letter 'Z', signifying UTC. If
[tz] is empty, the resulting time shall be affected by the value of the TZ environment
variable.
If the resulting time precedes the Epoch, the behavior is implementation-defined. If the time cannot be represented as the
file's timestamp, touch shall exit immediately with an error status.
-m
Change the modification time of file. Do not change the access time unless -a is also specified.
-r ref_file
Use the corresponding time of the file named by the pathname ref_file instead of the current time.
-t time
Use the specified time instead of the current time. The option-argument shall be a decimal number of the form:
[[CC]YY]MMDDhhmm[.SS]
where each two digits represents the following:
MM
The month of the year [01,12].
DD
The day of the month [01,31].
hh
The hour of the day [00,23].
mm
The minute of the hour [00,59].
CC
The first two digits of the year (the century).
YY
The second two digits of the year.
SS
The second of the minute [00,60].
Both CC and YY shall be optional. If neither is given, the current year shall be assumed. If YY is
specified, but CC is not, CC shall be derived as follows:
If YY is:
CC becomes:
[69,99]
19
[00,68]
20
Note:
It is expected that in a future version of this standard the default century inferred from a 2-digit year will change. (This
would apply to all commands accepting a 2-digit year as input.)
The resulting time shall be affected by the value of the TZ environment variable. If the resulting time
value precedes the Epoch, the behavior is implementation-defined. If the time is out of range for the file's timestamp,
touch shall exit immediately with an error status. The range of valid times past the Epoch is implementation-defined, but it
shall extend to at least the time 0 hours, 0 minutes, 0 seconds, January 1, 2038, Coordinated Universal Time. Some implementations
may not be able to represent dates beyond January 18, 2038, because they use signed int as a time holder.
The range for SS is [00,60] rather than [00,59] because of leap seconds. If SS is 60, and the
resulting time, as affected by the TZ environment variable, does not refer to a leap second, the resulting time shall be one
second after a time where SS is 59. If SS is not given a value, it is assumed to be zero.
If neither the -a nor -m options were specified, touch shall behave as if both the -a
and -m options were specified.
OPERANDS
The following operands shall be supported:
file
A pathname of a file whose times shall be modified.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of touch:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
TZ
Determine the timezone to be used for interpreting the time option-argument. If TZ is unset or null, an
unspecified default timezone shall be used.
ASYNCHRONOUS EVENTS
Default.
STDOUT
Not used.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
The utility executed successfully and all requested changes were made.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
The interpretation of time is taken to be seconds since the Epoch (see XBD 4.19 Seconds Since the Epoch). It should be noted that implementations
conforming to the System Interfaces volume of POSIX.1-2024 do not take leap seconds into account when computing seconds since the
Epoch. When SS=60 is used, the resulting time always refers to 1 plus seconds since the Epoch for a time when
SS=59.
Although the -t time option-argument specifies values in 1969, the access time and modification time
fields are defined in terms of seconds since the Epoch (00:00:00 on 1 January 1970 UTC). Therefore, depending on the value of
TZ when touch is run, there is never more than a few valid hours in 1969 and there need not be any valid times in
1969.
If the T time designator is replaced by a  for the -d date_time option-argument,
the  must be quoted to prevent the shell from splitting the argument.
EXAMPLES
Create or update a file called dwc; the resulting file has both the last data modification and last data access
timestamps set to November 12, 2007 at 10:15:30 local time:
touch -d 2007-11-12T10:15:30 dwc
Create or update a file called nick; the resulting file has both the last data modification and last data
access timestamps set to November 12, 2007 at 10:15:30 UTC:
touch -d 2007-11-12T10:15:30Z nick
Create or update a file called gwc; the resulting file has both the last data modification and last data
access timestamps set to November 12, 2007 at 10:15:30 local time with a fractional second timestamp of .002 seconds:
touch -d 2007-11-12T10:15:30,002 gwc
Create or update a file called ajosey; the resulting file has both the last data modification and last data
access timestamps set to November 12, 2007 at 10:15:30 UTC with a fractional second timestamp of .002 seconds:
touch -d "2007-11-12 10:15:30.002Z" ajosey
Create or update a file called cathy; the resulting file has both the last data modification and last data
access timestamps set to November 12, 2007 at 10:15:00 local time:
touch -t 200711121015 cathy
Create or update a file called drepper; the resulting file has both the last data modification and last data
access timestamps set to November 12, 2007 at 10:15:30 local time:
touch -t 200711121015.30 drepper
Create or update a file called ebb9; the resulting file has both the last data modification and last data
access timestamps set to November 12, 2007 at 10:15:30 local time:
touch -t 0711121015.30 ebb9
Create or update a file called eggert; the resulting file has the last data access timestamp set to the
corresponding time of the file named mark instead of the current time. If the file exists, the last data modification time
is not changed:
touch -a -r mark eggert
RATIONALE
The functionality of touch is described almost entirely through references to functions in the System Interfaces volume
of POSIX.1-2024. In this way, there is no duplication of effort required for describing such side-effects as the relationship of
user IDs to the user database, permissions, and so on.
There are some significant differences between the touch utility in this volume of POSIX.1-2024 and those in
System V and BSD systems. They are upwards-compatible for historical applications from both implementations:
In System V, an ambiguity exists when a pathname that is a decimal number leads the operands; it is treated as a
time value. In BSD, no time value is allowed; files may only be touched to the current time. The -t
time construct solves these problems for future conforming applications (note that the -t option is not historical
practice).
The inclusion of the century digits, CC, is also new. Note that a ten-digit time value is treated as
if YY, and not CC, were specified. The caveat about the range of dates following the Epoch was included as
recognition that some implementations are not able to represent dates beyond 18 January 2038 because they use signed int as
a time holder.
The -r option was added because several comments requested this capability. This option was named -f
in an early proposal, but was changed because the -f option is used in the BSD version of touch with a different
meaning.
At least one historical implementation of touch incremented the exit code if -c was specified and the
file did not exist. This volume of POSIX.1-2024 requires exit status zero if no errors occur.
In previous version of the standard, if at least two operands are specified, and the first operand is an eight or
ten-digit decimal integer, the first operand was assumed to be a date_time operand. This usage was removed in this version
of the standard since it had been marked obsolescent previously.
The -d date_time format is an ISO 8601:2019 standard complete representation of date and time
extended format with an optional decimal point or  followed by a string of digits following the seconds portion to
specify fractions of a second. It is not necessary to recognize "[+/-]hh:mm" and "[+/-]hh" to specify timezones
other than local time and UTC. The T time designator in the ISO 8601:2019 standard extended format may be replaced by
.
FUTURE DIRECTIONS
If this utility is directed to create a new directory entry that contains any bytes that have the encoded value of a
character, implementations are encouraged to treat this as an error. A future version of this standard may require
implementations to treat this as an error.
SEE ALSO
date
XBD 4.19 Seconds Since the Epoch, 8. Environment Variables, 12.2
Utility Syntax Guidelines,
XSH creat(), futimens(), time()
CHANGE HISTORY
First released in Issue 2.
Issue 6
The obsolescent date_time operand is removed.
The Open Group Corrigendum U027/1 is applied. This extends the range of valid time past the Epoch to at least the
time 0 hours, 0 minutes, 0 seconds, January 1, 2038, Coordinated Universal Time. This is a new requirement on POSIX
implementations.
The range for seconds is changed from [00,61] to [00,60] to align with the ISO/IEC 9899:1999 standard, and to
allow for positive leap seconds.
Issue 7
Austin Group Interpretation 1003.1-2001 #118 is applied.
Austin Group Interpretation 1003.1-2001 #193 is applied, adding support for subsecond timestamps.
SD5-XCU-ERN-45 is applied, adding a new paragraph to the RATIONALE.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
SD5-XCU-ERN-110 is applied, updating the OPTIONS section.
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0195 [474] is applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/sact.html =====
sact
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sact — print current SCCS file-editing activity (DEVELOPMENT)
SYNOPSIS
[XSI]  sact file...
DESCRIPTION
The sact utility shall inform the user of any impending deltas to a named SCCS file by writing a list to standard output.
This situation occurs when get -e has been executed previously without a
subsequent execution of delta, unget, or
sccs unedit.
OPTIONS
None.
OPERANDS
The following operand shall be supported:
file
A pathname of an existing SCCS file or a directory. If file is a directory, the sact utility shall behave as
though each file in the directory were specified as a named file, except that non-SCCS files (last component of the pathname does
not begin with s.) and unreadable files shall be silently ignored.
If exactly one file operand appears, and it is '-', the standard input shall be read; each line of the standard
input shall be taken to be the name of an SCCS file to be processed. Non-SCCS files and unreadable files shall be silently
ignored.
STDIN
The standard input shall be a text file used only when the file operand is specified as '-'. Each line of the
text file shall be interpreted as an SCCS pathname.
INPUT FILES
Any SCCS files interrogated are files of an unspecified format.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of sact:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
The output for each named file shall consist of a line in the following format:
"%sΔ%sΔ%sΔ%sΔ%s\n", , , , ,
Specifies the SID of a delta that currently exists in the SCCS file to which changes are made to make the new delta.
Specifies the SID for the new delta to be created.
Contains the login name of the user who makes the delta (that is, who executed a get
for editing).
Contains the date that get -e was executed, in the format used by the
prs :D: data keyword.
Contains the time that get -e was executed, in the format used by the
prs :T: data keyword.
If there is more than one named file or if a directory or standard input is named, each pathname shall be written before each of
the preceding lines:
"\n%s:\n",
STDERR
The standard error shall be used only for optional informative messages concerning SCCS files with no impending deltas, and for
diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
None.
EXAMPLES
None.
RATIONALE
None.
FUTURE DIRECTIONS
If this utility is directed to display a pathname that contains any bytes that have the encoded value of a
character when  is a terminator or separator in the output format being used, implementations are encouraged to
treat this as an error. A future version of this standard may require implementations to treat this as an error.
SEE ALSO
delta, get, sccs, unget
XBD 8. Environment Variables
CHANGE HISTORY
First released in Issue 2.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to report an error if a utility is directed to display a
pathname that contains any bytes that have the encoded value of a  character when  is a terminator or
separator in the output format being used.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/get.html =====
get
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
get — get a version of an SCCS file (DEVELOPMENT)
SYNOPSIS
[XSI]  get [-begkmnlLpst] [-c cutoff] [-i
list] [-r SID] [-x list] file...
DESCRIPTION
The get utility shall generate a text file from each named SCCS file according to the specifications given by its
options.
The generated text shall normally be written into a file called the g-file whose name is derived from the SCCS filename
by simply removing the leading "s.".
OPTIONS
The get utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-r SID
Indicate the SCCS Identification String (SID) of the version (delta) of an SCCS file to be retrieved. The table shows, for the
most useful cases, what version of an SCCS file is retrieved (as well as the SID of the version to be eventually created by
delta if the -e option is also used), as a function of the SID specified.
-c cutoff
Indicate the cutoff date-time, in the form:
YY[MM[DD[HH[MM[SS]]]]]
For the YY component, values in the range [69,99] shall refer to years 1969 to 1999 inclusive, and values in the range
[00,68] shall refer to years 2000 to 2068 inclusive.
Note:
It is expected that in a future version of this standard the default century inferred from a 2-digit year will change. (This
would apply to all commands accepting a 2-digit year as input.)
No changes (deltas) to the SCCS file that were created after the specified cutoff date-time shall be included in the
generated text file. Units omitted from the date-time default to their maximum possible values; for example, -c 7502 is
equivalent to -c 750228235959.
Any number of non-numeric characters may separate the various 2-digit pieces of the cutoff date-time. This feature allows
the user to specify a cutoff date in the form: -c "77/2/2 9:22:25".
-e
Indicate that the get is for the purpose of editing or making a change (delta) to the SCCS file via a subsequent use of
delta. The -e option used in a get for a particular version (SID) of the
SCCS file shall prevent further get commands from editing on the same SID until delta is executed or the j (joint edit) flag is set in the SCCS file. Concurrent use of
get -e for different SIDs is always allowed.
If the g-file generated by get with a -e option is accidentally ruined in the process of editing, it may be
regenerated by re-executing the get command with the -k option in place of the -e option.
SCCS file protection specified via the ceiling, floor, and authorized user list stored in the SCCS file shall be enforced when
the -e option is used.
-b
Use with the -e option to indicate that the new delta should have an SID in a new branch as shown in the table below.
This option shall be ignored if the b flag is not present in the file or if the retrieved delta is not a leaf delta. (A leaf
delta is one that has no successors on the SCCS file tree.)
Note:
A branch delta may always be created from a non-leaf delta.
-i list
Indicate a list of deltas to be included (forced to be applied) in the creation of the generated file. The list
has the following syntax:
::=  |  ,
::= SID | SID - SID
SID, the SCCS Identification of a delta, may be in any form shown in the "SID Specified" column of the table in the EXTENDED
DESCRIPTION section, except that the result of supplying a partial SID is unspecified. A diagnostic message shall be written if the
first SID in the range is not an ancestor of the second SID in the range.
-x list
Indicate a list of deltas to be excluded (forced not to be applied) in the creation of the generated file. See the
-i option for the list format.
-k
Suppress replacement of identification keywords (see below) in the retrieved text by their value. The -k option shall be
implied by the -e option.
-l
Write a delta summary into an l-file.
-L
Write a delta summary to standard output. All informative output that normally is written to standard output shall be written
to standard error instead, unless the -s option is used, in which case it shall be suppressed.
-p
Write the text retrieved from the SCCS file to the standard output. No g-file shall be created. All informative output
that normally goes to the standard output shall go to standard error instead, unless the -s option is used, in which case it
shall disappear.
-s
Suppress all informative output normally written to standard output. However, fatal error messages (which shall always be
written to the standard error) shall remain unaffected.
-m
Precede each text line retrieved from the SCCS file by the SID of the delta that inserted the text line in the SCCS file. The
format shall be:
"%s\t%s", ,
-n
Precede each generated text line with the %M% identification keyword value (see below). The format shall be:
"%s\t%s", ,
When both the -m and -n options are used, the  shall be replaced by the -m
option-generated format.
-g
Suppress the actual retrieval of text from the SCCS file. It is primarily used to generate an l-file, or to verify the
existence of a particular SID.
-t
Use to access the most recently created (top) delta in a given release (for example, -r 1), or release and level (for
example, -r 1.2).
OPERANDS
The following operands shall be supported:
file
A pathname of an existing SCCS file or a directory. If file is a directory, the get utility shall behave as
though each file in the directory were specified as a named file, except that non-SCCS files (last component of the pathname does
not begin with s.) and unreadable files shall be silently ignored.
If exactly one file operand appears, and it is '-', the standard input shall be read; each line of the standard
input is taken to be the name of an SCCS file to be processed. Non-SCCS files and unreadable files shall be silently ignored.
STDIN
The standard input shall be a text file used only if the file operand is specified as '-'. Each line of the text
file shall be interpreted as an SCCS pathname.
INPUT FILES
The SCCS files shall be files of an unspecified format.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of get:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error, and
informative messages written to standard output (or standard error, if the -p option is used).
NLSPATH
Determine the location of messages objects and message catalogs.
TZ
Determine the timezone in which the times and dates written in the SCCS file are evaluated. If the TZ variable is unset
or NULL, an unspecified system default timezone is used.
ASYNCHRONOUS EVENTS
Default.
STDOUT
For each file processed, get shall write to standard output the SID being accessed and the number of lines retrieved from
the SCCS file, in the following format:
"%s\n%d lines\n", ,
If the -e option is used, the SID of the delta to be made shall appear after the SID accessed and before the number of
lines generated, in the POSIX locale:
"%s\nnew delta %s\n%d lines\n", ,
,
If there is more than one named file or if a directory or standard input is named, each pathname shall be written before each of
the lines shown in one of the preceding formats:
"\n%s:\n",
If the -L option is used, a delta summary shall be written following the format specified below for l-files.
If the -i option is used, included deltas shall be listed following the notation, in the POSIX locale:
"Included:\n"
If the -x option is used, excluded deltas shall be listed following the notation, in the POSIX locale:
"Excluded:\n"
If the -p or -L options are specified, the standard output shall consist of the text retrieved from the SCCS
file.
STDERR
The standard error shall be used only for diagnostic messages, except if the -p or -L options are specified, it
shall include all informative messages normally sent to standard output.
OUTPUT FILES
Several auxiliary files may be created by get. These files are known generically as the g-file, l-file,
p-file, and z-file. The letter before the  is called the tag. An auxiliary filename shall
be formed from the SCCS filename: the application shall ensure that the last component of all SCCS filenames is of the form
s.module-name; the auxiliary files shall be named by replacing the leading s with the tag. The g-file
shall be an exception to this scheme: the g-file is named by removing the s. prefix. For example, for s.xyz.c,
the auxiliary filenames would be xyz.c, l.xyz.c, p.xyz.c, and z.xyz.c, respectively.
The g-file, which contains the generated text, shall be created in the current directory (unless the -p option is
used). A g-file shall be created in all cases, whether or not any lines of text were generated by the get. It shall
be owned by the real user. If the -k option is used or implied, the g-file shall be writable by the owner only
(read-only for everyone else); otherwise, it shall be read-only. Only the real user need have write permission in the current
directory.
The l-file shall contain a table showing which deltas were applied in generating the retrieved text. The l-file
shall be created in the current directory if the -l option is used; it shall be read-only and it is owned by the real user.
Only the real user need have write permission in the current directory.
Lines in the l-file shall have the following format:
"%c%c%cΔ%s\t%sΔ%s\n", , , ,
, ,
where the entries are:
A  if the delta was applied; '*' otherwise.
A  if the delta was applied or was not applied and ignored; '*' if the delta was not applied and was not
ignored.
A character indicating a special reason why the delta was or was not applied:
I
Included.
X
Excluded.
C
Cut off (by a -c option).
Date and time (using the format of the date utility's
%y/%m/%d %T conversion specification format) of creation.
Login name of person who created delta.
The comments and MR data shall follow on subsequent lines, indented one . A blank line shall terminate each
entry.
The p-file shall be used to pass information resulting from a get with a -e option along to delta. Its contents shall also be used to prevent a subsequent execution of get with a
-e option for the same SID until delta is executed or the joint edit flag,
j, is set in the SCCS file. The p-file shall be created in the directory containing the SCCS file and the application
shall ensure that the effective user has write permission in that directory. It shall be writable by owner only, and owned by the
effective user. Each line in the p-file shall have the following format:
"%sΔ%sΔ%sΔ%s%s%s\n", ,
, ,
, ,
where  uses the format "" if no -i option was specified, and shall use the format:
"Δ-i%s",
if a -i option was specified and  uses the format "" if no -x option was specified,
and shall use the format:
"Δ-x%s",
if a -x option was specified. There can be an arbitrary number of lines in the p-file at any time; no two lines
shall have the same new delta SID.
The z-file shall serve as a lock-out mechanism against simultaneous updates. Its contents shall be the binary process ID
of the command (that is, get) that created it. The z-file shall be created in the directory containing the SCCS file
for the duration of get. The same protection restrictions as those for the p-file shall apply for the z-file.
The z-file shall be created read-only.
EXTENDED DESCRIPTION
Determination of SCCS Identification String
SID* Specified
-b Keyletter Used†
Other Conditions
SID Retrieved
SID of Delta to be Created
none‡
no
R defaults to mR
mR.mL
mR.(mL+1)
none‡
yes
R defaults to mR
mR.mL
mR.mL.(mB+1).1
R
no
R > mR
mR.mL
R.1***
R
no
R = mR
mR.mL
mR.(mL+1)
R
yes
R > mR
mR.mL
mR.mL.(mB+1).1
R
yes
R = mR
mR.mL
mR.mL.(mB+1).1
R
-
R  R and R exists
R.mL
R.mL.(mB+1).1
R.L
no
No trunk successor
R.L
R.(L+1)
R.L
yes
No trunk successor
R.L
R.L.(mB+1).1
R.L
-
Trunk successor in release >= R
R.L
R.L.(mB+1).1
R.L.B
no
No branch successor
R.L.B.mS
R.L.B.(mS+1)
R.L.B
yes
No branch successor
R.L.B.mS
R.L.(mB+1).1
R.L.B.S
no
No branch successor
R.L.B.S
R.L.B.(S+1)
R.L.B.S
yes
No branch successor
R.L.B.S
R.L.(mB+1).1
R.L.B.S
-
Branch successor
R.L.B.S
R.L.(mB+1).1
*
R, L, B, and S are the release, level, branch, and sequence components of the SID, respectively; m means maximum. Thus, for
example, R.mL means "the maximum level number within release R"; R.L.(mB+1).1 means "the first sequence number on the new branch
(that is, maximum branch number plus one) of level L within release R". Note that if the SID specified is of the form R.L, R.L.B,
or R.L.B.S, each of the specified components shall exist.
**
hR is the highest existing release that is lower than the specified, nonexistent, release R.
***
This is used to force creation of the first delta in a new release.
†
The -b option is effective only if the b flag is present in the file. An entry of '-' means
"irrelevant".
‡
This case applies if the d (default SID) flag is not present in the file. If the d flag is present in the file,
then the SID obtained from the d flag is interpreted as if it had been specified on the command line. Thus, one of the other
cases in this table applies.
System Date and Time
When a g-file is generated, the creation time of deltas in the SCCS file may be taken into account. If any
of these times are apparently in the future, the behavior is unspecified.
Identification Keywords
Identifying information shall be inserted into the text retrieved from the SCCS file by replacing identification
keywords with their value wherever they occur. The following keywords may be used in the text stored in an SCCS file:
%M%
Module name: either the value of the m flag in the file, or if absent, the name of the SCCS file with the leading
s. removed.
%I%
SCCS identification (SID) (%R%.%L% or %R%.%L%.%B%.%S%) of the retrieved text.
%R%
Release.
%L%
Level.
%B%
Branch.
%S%
Sequence.
%D%
Current date (YY/MM/DD).
%H%
Current date (MM/DD/YY).
%T%
Current time (HH:MM:SS).
%E%
Date newest applied delta was created (YY/MM/DD).
%G%
Date newest applied delta was created (MM/DD/YY).
%U%
Time newest applied delta was created (HH:MM:SS).
%Y%
Module type: value of the t flag in the SCCS file.
%F%
SCCS filename.
%P%
SCCS absolute pathname.
%Q%
The value of the q flag in the file.
%C%
Current line number. This keyword is intended for identifying messages output by the program, such as "this should not have
happened" type errors. It is not intended to be used on every line to provide sequence numbers.
%Z%
The four-character string "@(#)" recognizable by what.
%W%
A shorthand notation for constructing what strings:
%W%=%Z%%M%%I%
%A%
Another shorthand notation for constructing what strings:
%A%=%Z%%Y%%M%%I%%Z%
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
Problems can arise if the system date and time have been modified (for example, put forward and then back again, or
unsynchronized clocks across a network) and can also arise when different values of the TZ environment variable are
used.
Problems of a similar nature can also arise for the operation of the delta utility, which compares the previous file body against the working file as part of its
normal operation.
EXAMPLES
None.
RATIONALE
None.
FUTURE DIRECTIONS
If this utility is directed to display a pathname that contains any bytes that have the encoded value of a
character when  is a terminator or separator in the output format being used, implementations are encouraged to
treat this as an error. A future version of this standard may require implementations to treat this as an error.
If this utility is directed to create a new directory entry that contains any bytes that have the encoded value of
a  character, implementations are encouraged to treat this as an error. A future version of this standard may
require implementations to treat this as an error.
SEE ALSO
admin, delta, prs, what
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 2.
Issue 5
A correction is made to the first format string in STDOUT.
The interpretation of the YY component of the -c cutoff argument is noted.
Issue 6
The obsolescent SYNOPSIS is removed, removing the -lp option.
The normative text is reworded to avoid use of the term "must" for application requirements.
The Open Group Corrigendum U025/5 is applied, correcting text in the OPTIONS section.
The Open Group Corrigendum U048/1 is applied.
The Open Group Interpretation PIN4C.00014 is applied.
The Open Group Base Resolution bwg2001-007 is applied as follows:
The EXTENDED DESCRIPTION section is updated to make partial SID handling unspecified, reflecting common usage, and
to clarify SID ranges.
New text is added to the EXTENDED DESCRIPTION and APPLICATION USAGE sections regarding how the system date and
time may be taken into account.
The TZ environment variable is added to the ENVIRONMENT VARIABLES section.
Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0104 [584] is applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to behave as follows:
Report an error if a utility is directed to display a pathname that contains any bytes that have the encoded value
of a  character when  is a terminator or separator in the output format being used.
Disallow the creation of filenames containing any bytes that have the encoded value of a
character.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/cksum.html =====
cksum
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cksum — write file checksums and sizes
SYNOPSIS
cksum [file...]
DESCRIPTION
The cksum utility shall calculate and write to standard output a cyclic redundancy check (CRC) for each input file, and
also write to standard output the number of octets in each file. The CRC used is based on the polynomial used for CRC error
checking in the ISO/IEC 8802-3:1996 standard (Ethernet).
The encoding for the CRC checksum is defined by the generating polynomial:
G(x)=x32+x26+x23+x22+x16+x12+x11+x10+x8+x7+x5+x4+x2+x+1
Mathematically, the CRC value corresponding to a given file shall be defined by the following procedure:
The n bits to be evaluated are considered to be the coefficients of a mod 2 polynomial M(x) of degree
n-1. These n bits are the bits from the file, with the most significant bit being the most significant bit of the
first octet of the file and the last bit being the least significant bit of the last octet, padded with zero bits (if necessary) to
achieve an integral number of octets, followed by one or more octets representing the length of the file as a binary value, least
significant octet first. The smallest number of octets capable of representing this integer shall be used.
M(x) is multiplied by x32 (that is, shifted left 32 bits) and divided by
G(x) using mod 2 division, producing a remainder R(x) of degree , ,
If no file operand was specified, the pathname and its leading  shall be omitted.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
All files were processed successfully.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
The cksum utility is typically used to quickly compare a suspect file against a trusted version of the same, such as to
ensure that files transmitted over noisy media arrive intact. However, this comparison cannot be considered cryptographically
secure. This utility should be avoided whenever non-trivial requirements (including safety and security) have to be fulfilled.
Although input files to cksum can be any type, the results need not be what would be expected on character special device
files or on file types not described by the System Interfaces volume of POSIX.1-2024. Since this volume of POSIX.1-2024 does not
specify the block size used when doing input, checksums of character special files need not process all of the data in those
files.
The algorithm is expressed in terms of a bitstream divided into octets. If a file is transmitted between two systems and
undergoes any data transformation (such as changing little-endian byte ordering to big-endian), identical CRC values cannot be
expected. Implementations performing such transformations may extend cksum to handle such situations.
EXAMPLES
None.
RATIONALE
The cksum utility is included in this standard for reasons of portability but is not suitable for uses where non-trivial
requirements (including safety and security) have to be fulfilled. Implementations are encouraged to provide utilities that
implement hash and integrity checksum algorithms of higher security and to keep up to date with developments in this area.
The following C-language program can be used as a model to describe the algorithm. It assumes that a char is one octet.
It also assumes that the entire file is available for one pass through the function. This was done for simplicity in demonstrating
the algorithm, rather than as an implementation model.
static unsigned long crctab[] = {
0x00000000,
0x04c11db7, 0x09823b6e, 0x0d4326d9, 0x130476dc, 0x17c56b6b,
0x1a864db2, 0x1e475005, 0x2608edb8, 0x22c9f00f, 0x2f8ad6d6,
0x2b4bcb61, 0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,
0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9, 0x5f15adac,
0x5bd4b01b, 0x569796c2, 0x52568b75, 0x6a1936c8, 0x6ed82b7f,
0x639b0da6, 0x675a1011, 0x791d4014, 0x7ddc5da3, 0x709f7b7a,
0x745e66cd, 0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,
0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5, 0xbe2b5b58,
0xbaea46ef, 0xb7a96036, 0xb3687d81, 0xad2f2d84, 0xa9ee3033,
0xa4ad16ea, 0xa06c0b5d, 0xd4326d90, 0xd0f37027, 0xddb056fe,
0xd9714b49, 0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,
0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1, 0xe13ef6f4,
0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d, 0x34867077, 0x30476dc0,
0x3d044b19, 0x39c556ae, 0x278206ab, 0x23431b1c, 0x2e003dc5,
0x2ac12072, 0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16,
0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca, 0x7897ab07,
0x7c56b6b0, 0x71159069, 0x75d48dde, 0x6b93dddb, 0x6f52c06c,
0x6211e6b5, 0x66d0fb02, 0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1,
0x53dc6066, 0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e, 0xbfa1b04b,
0xbb60adfc, 0xb6238b25, 0xb2e29692, 0x8aad2b2f, 0x8e6c3698,
0x832f1041, 0x87ee0df6, 0x99a95df3, 0x9d684044, 0x902b669d,
0x94ea7b2a, 0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e,
0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2, 0xc6bcf05f,
0xc27dede8, 0xcf3ecb31, 0xcbffd686, 0xd5b88683, 0xd1799b34,
0xdc3abded, 0xd8fba05a, 0x690ce0ee, 0x6dcdfd59, 0x608edb80,
0x644fc637, 0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,
0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f, 0x5c007b8a,
0x58c1663d, 0x558240e4, 0x51435d53, 0x251d3b9e, 0x21dc2629,
0x2c9f00f0, 0x285e1d47, 0x36194d42, 0x32d850f5, 0x3f9b762c,
0x3b5a6b9b, 0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,
0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623, 0xf12f560e,
0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7, 0xe22b20d2, 0xe6ea3d65,
0xeba91bbc, 0xef68060b, 0xd727bbb6, 0xd3e6a601, 0xdea580d8,
0xda649d6f, 0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,
0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7, 0xae3afba2,
0xaafbe615, 0xa7b8c0cc, 0xa379dd7b, 0x9b3660c6, 0x9ff77d71,
0x92b45ba8, 0x9675461f, 0x8832161a, 0x8cf30bad, 0x81b02d74,
0x857130c3, 0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640,
0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c, 0x7b827d21,
0x7f436096, 0x7200464f, 0x76c15bf8, 0x68860bfd, 0x6c47164a,
0x61043093, 0x65c52d24, 0x119b4be9, 0x155a565e, 0x18197087,
0x1cd86d30, 0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088, 0x2497d08d,
0x2056cd3a, 0x2d15ebe3, 0x29d4f654, 0xc5a92679, 0xc1683bce,
0xcc2b1d17, 0xc8ea00a0, 0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb,
0xdbee767c, 0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18,
0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4, 0x89b8fd09,
0x8d79e0be, 0x803ac667, 0x84fbdbd0, 0x9abc8bd5, 0x9e7d9662,
0x933eb0bb, 0x97ffad0c, 0xafb010b1, 0xab710d06, 0xa6322bdf,
0xa2f33668, 0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4
};
unsigned long memcrc(const unsigned char *b, size_t n)
{
/*  Input arguments:
*  const unsigned char*   b == byte sequence to checksum
*  size_t                 n == length of sequence
*/
register size_t i;
register unsigned c, s = 0;
for (i = n; i > 0; --i) {
c = *b++;
s = (s > 24) ^ c];
}
/* Extend with the length of the string. */
while (n != 0) {
c = n & 0377;
n >>= 8;
s = (s > 24) ^ c];
}
return ~s;
}
The historical practice of writing the number of "blocks" has been changed to writing the number of octets, since the latter
is not only more useful, but also since historical implementations have not been consistent in defining what a "block" meant.
The algorithm used was selected to increase the operational robustness of cksum. Neither the System V nor BSD sum
algorithm was selected. Since each of these was different and each was the default behavior on those systems, no realistic
compromise was available if either were selected—some set of historical applications would break. Therefore, the name was changed
to cksum. Although the historical sum commands will probably continue to be provided for many years, programs
designed for portability across systems should use the new name.
The algorithm selected is based on that used by the ISO/IEC 8802-3:1996 standard (Ethernet) for the frame check sequence
field. The algorithm used does not match the technical definition of a checksum; the term is used for historical reasons.
The length of the file is included in the CRC calculation because this parallels inclusion of a length field by Ethernet in its
CRC, but also because it guards against inadvertent collisions between files that begin with different series of zero octets. The
chance that two different files produce identical CRCs is much greater when their lengths are not considered. Keeping the length
and the checksum of the file itself separate would yield a slightly more robust algorithm, but historical usage has always been
that a single number (the checksum as printed) represents the signature of the file. It was decided that historical usage was the
more important consideration.
Early proposals contained modifications to the Ethernet algorithm that involved extracting table values whenever an intermediate
result became zero. This was demonstrated to be less robust than the current method and mathematically difficult to describe or
justify.
The calculation used is identical to that given in pseudo-code in the referenced Sarwate article. The pseudo-code rendition
is:
X
character when  is a terminator or separator in the output format being used, implementations are encouraged to
treat this as an error. A future version of this standard may require implementations to treat this as an error.
SEE ALSO
XBD 8. Environment Variables
CHANGE HISTORY
First released in Issue 4.
Issue 7
Austin Group Interpretation 1003.1-2001 #092 is applied.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0081 [446] is applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to report an error if a utility is directed to display a
pathname that contains any bytes that have the encoded value of a  character when  is a terminator or
separator in the output format being used.
Austin Group Defect 1041 is applied, changing the APPLICATION USAGE and RATIONALE sections.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/nm.html =====
nm
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
nm — write the name list of an object file (DEVELOPMENT)
SYNOPSIS
[SD]  nm [-APv] [-g|-u] [-t format]
file...
[XSI]  nm [-APv] [-efox] [-g|-u] [-t
format] file...
DESCRIPTION
The nm utility shall display symbolic information appearing in the object file, executable file, or object-file library
named by file. If no symbolic information is available for a valid input file, the nm utility shall report that fact,
but not consider it an error condition.
The default base used when numeric values are written is unspecified. [XSI]
On XSI-conformant systems, it shall be decimal if the
-P option is not specified.
OPTIONS
The nm utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-A
Write the full pathname or library name of an object on each line.
-e
[XSI]
Write only external (global) and static symbol information.
-f
[XSI]
Produce full output. Write redundant symbols (.text, .data, and .bss), normally suppressed.
-g
Write only external (global) symbol information.
-o
[XSI]
Write numeric values in octal (equivalent to -t o).
-P
Write information in a portable output format, as specified in the STDOUT section.
-t format
Write each numeric value in the specified format. The format shall be dependent on the single character used as the
format option-argument:
d
decimal [XSI]   (default if -P is not specified).
o
octal.
x
hexadecimal (default if -P is specified).
-u
Write only undefined symbols.
-v
Sort output by value instead of by symbol name.
-x
[XSI]
Write numeric values in hexadecimal (equivalent to -t x).
OPERANDS
The following operand shall be supported:
file
A pathname of an object file, executable file, or object-file library.
STDIN
See the INPUT FILES section.
INPUT FILES
The input file shall be an object file, an object-file library whose format is the same as those produced by the ar utility for link editing, or an executable file. The nm utility may accept additional
implementation-defined object library formats for the input file.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of nm:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_COLLATE
Determine the locale for character collation information for the symbol-name and symbol-value collation sequences.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
If symbolic information is present in the input files, then for each file or for each member of an archive, the nm
utility shall write the following information to standard output. By default, the format is unspecified, but the output shall be
sorted by symbol name according to the collation sequence in the current locale.
Library or object name, if -A is specified
Symbol name
Symbol type, which shall either be one of the following single characters or an implementation-defined type represented by a
single character:
A
Global absolute symbol.
a
Local absolute symbol.
B
Global "bss" (that is, uninitialized data space) symbol.
b
Local bss symbol.
D
Global data symbol.
d
Local data symbol.
T
Global text symbol.
t
Local text symbol.
U
Undefined symbol.
Value of the symbol
The size associated with the symbol, if applicable
This information may be supplemented by additional information specific to the implementation.
If the -P option is specified, the previous information shall be displayed using the following portable format. The three
versions differ depending on whether -t d, -t o, or -t x was specified, respectively:
"%s%s %s %d %d\n", , , ,
,
"%s%s %s %o %o\n", , , ,
,
"%s%s %s %x %x\n", , , ,
,
where  shall be formatted as follows:
If -A is not specified,  shall be an empty string.
If -A is specified and the corresponding file operand does not name a library:
"%s: ",
If -A is specified and the corresponding file operand names a library. In this case,
shall name the object file in the library containing the symbol being described:
"%s[%s]: ", ,
If -A is not specified, then if more than one file operand is specified or if only one file operand is
specified and it names a library, nm shall write a line identifying the object containing the following symbols before the
lines containing those symbols, in the form:
If the corresponding file operand does not name a library:
"%s:\n",
If the corresponding file operand names a library; in this case,  shall be the name of the
file in the library containing the following symbols:
"%s[%s]:\n", ,
If -P is specified, but -t is not, the format shall be as if -t x had been specified.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
Mechanisms for dynamic linking make this utility less meaningful when applied to an executable file because a dynamically linked
executable may omit numerous library routines that would be found in a statically linked executable.
EXAMPLES
None.
RATIONALE
Historical implementations of nm have used different bases for numeric output and supplied different default types of
symbols that were reported. The -t format option, similar to that used in od and strings, can be used to specify the numeric
base; -g and -u can be used to restrict the amount of output or the types of symbols included in the output.
The compromise of using -t format versus using -d, -o, and other similar options was
necessary because of differences in the meaning of -o between implementations. The -o option from BSD has been
provided here as -A to avoid confusion with the -o from System V (which has been provided here as -t and as
-o on XSI-conformant systems).
The option list was significantly reduced from that provided by historical implementations.
The nm description is a subset of both the System V and BSD nm utilities with no specified default output.
It was recognized that mechanisms for dynamic linking make this utility less meaningful when applied to an executable file
(because a dynamically linked executable file may omit numerous library routines that would be found in a statically linked
executable file), but the value of nm during software development was judged to outweigh other limitations.
The default output format of nm is not specified because of differences in historical implementations. The -P
option was added to allow some type of portable output format. After a comparison of the different formats used in SunOS, BSD,
SVR3, and SVR4, it was decided to create one that did not match the current format of any of these four systems. The format devised
is easy to parse by humans, easy to parse in shell scripts, and does not need to vary depending on locale (because no English
descriptions are included). All of the systems currently have the information available to use this format.
The format given in nm STDOUT uses  characters between the fields, which may be any number of
characters required to align the columns. The single-character types were selected to match historical practice, and the
requirement that implementation additions also be single characters made parsing the information easier for shell scripts.
FUTURE DIRECTIONS
If this utility is directed to display a pathname that contains any bytes that have the encoded value of a
character when  is a terminator or separator in the output format being used, implementations are encouraged to
treat this as an error. A future version of this standard may require implementations to treat this as an error.
SEE ALSO
ar, c17
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 2.
Issue 6
This utility is marked as supported when both the User Portability Utilities option and the Software Development Utilities
option are supported.
Issue 7
The nm utility is removed from the User Portability Utilities option. User Portability Utilities is now an option for
interactive utilities.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0125 [263] and XCU/TC1-2008/0126 [263] are applied.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0148 [744] is applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to report an error if a utility is directed to display a
pathname that contains any bytes that have the encoded value of a  character when  is a terminator or
separator in the output format being used.
Austin Group Defect 1062 is applied, inserting an empty line between the two SYNOPSIS forms.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/diff.html =====
diff
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
diff — compare two files
SYNOPSIS
diff [-c|-e|-f|-u|-C n|-U n] [-br] file1 file2
DESCRIPTION
The diff utility shall compare the contents of file1 and file2 and write to standard output a list of
changes necessary to convert file1 into file2. This list should be minimal. No output shall be produced if the files
are identical.
OPTIONS
The diff utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-b
Cause any amount of white space at the end of a line to be treated as a single  (that is, the white-space
characters preceding the  are ignored) and other strings of white-space characters, not including
characters, to compare equal.
-c
Produce output in a form that provides three lines of copied context.
-C n
Produce output in a form that provides n lines of copied context (where n shall be interpreted as a positive
decimal integer).
-e
Produce output in a form suitable as input for the ed utility, which can then be used
to convert file1 into file2.
-f
Produce output in an alternative form, similar in format to -e, but not intended to be suitable as input for the
ed utility, and in the opposite order.
-r
Apply diff recursively to files and directories of the same name when file1 and file2 are both
directories.
The diff utility shall detect infinite loops; that is, entering a previously visited directory that is an ancestor of the
last file encountered. When it detects an infinite loop, diff shall write a diagnostic message to standard error and shall
either recover its position in the hierarchy or terminate.
-u
Produce output in a form that provides three lines of unified context.
-U n
Produce output in a form that provides n lines of unified context (where n shall be interpreted as a non-negative
decimal integer).
OPERANDS
The following operands shall be supported:
file1, file2
A pathname of a file to be compared. If either the file1 or file2 operand is '-', the standard input
shall be used in its place.
If both file1 and file2 are directories, diff shall not compare block special files, character special
files, or FIFO special files to any files and shall not compare regular files to directories. Further details are as specified in
Diff Directory Comparison Format. The behavior of diff on other file types is
implementation-defined when found in directories.
If only one of file1 and file2 is a directory, diff shall be applied to the non-directory file and the file
contained in the directory file with a filename that is the same as the last component of the non-directory file.
STDIN
The standard input shall be used only if one of the file1 or file2 operands references standard input. See the
INPUT FILES section.
INPUT FILES
The input files may be of any type.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of diff:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error and
informative messages written to standard output.
LC_TIME
Determine the locale for affecting the format of file timestamps written with the -C and -c options.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
TZ
Determine the timezone used for calculating file timestamps written with a context format. If TZ is unset or null, an
unspecified default timezone shall be used.
ASYNCHRONOUS EVENTS
Default.
STDOUT
Diff Directory Comparison Format
If both file1 and file2 are directories, the following output formats shall be used.
In the POSIX locale, each file that is present in only one directory shall be reported using the following format:
"Only in %s: %s\n", ,
In the POSIX locale, subdirectories that are common to the two directories may be reported with the following format:
"Common subdirectories: %s and %s\n", ,
For each file common to the two directories, if the two files are not to be compared: if the two files have the same device ID
and file serial number, or are both block special files that refer to the same device, or are both character special files that
refer to the same device, in the POSIX locale the output format is unspecified. Otherwise, in the POSIX locale an unspecified
format shall be used that contains the pathnames of the two files.
For each file common to the two directories, if the files are compared and are identical, no output shall be written. If the two
files differ, the following format is written:
"diff %s %s %s\n", , ,
where  are the options as specified on the command line.
All directory pathnames listed in this section shall be relative to the original command line arguments. All other names of
files listed in this section shall be filenames (pathname components).
Diff Binary Output Format
In the POSIX locale, if one or both of the files being compared are not text files, it is implementation-defined whether
diff uses the binary file output format or the other formats as specified below. The binary file output format shall contain
the pathnames of two files being compared and the string "differ".
If both files being compared are text files, depending on the options specified, one of the following formats shall be used to
write the differences.
Diff Default Output Format
The default (without -e, -f, -c, -C, -u, or -U options) diff utility output
shall contain lines of these forms:
"%da%d\n", ,
"%da%d,%d\n", , ,
"%dd%d\n", ,
"%d,%dd%d\n", , ,
"%dc%d\n", ,
"%d,%dc%d\n", , ,
"%dc%d,%d\n", , ,
"%d,%dc%d,%d\n", , , ,
These lines resemble ed subcommands to convert file1 into file2. The
line numbers before the action letters shall pertain to file1; those after shall pertain to file2. Thus, by
exchanging a for d and reading the line in reverse order, one can also determine how to convert file2 into
file1. As in ed, identical pairs (where num1= num2) are abbreviated
as a single number.
Following each of these lines, diff shall write to standard output all lines affected in the first file using the
format:
"
and all lines affected in the second file using the format:
">Δ%s",
If there are lines affected in both file1 and file2 (as with the c subcommand), the changes are separated
with a line consisting of three  characters:
"---\n"
Diff -e Output Format
With the -e option, a script shall be produced that shall, when provided as input to ed, along with an appended w (write) command, convert file1 into file2. Only
the a (append), c (change), d (delete), i (insert), and s (substitute) commands of ed shall be used in this script. Text lines, except those consisting of the single character
('.'), shall be output as they appear in the file.
Diff -f Output Format
With the -f option, an alternative format of script shall be produced. It is similar to that produced by -e, with
the following differences:
It is expressed in reverse sequence; the output of -e orders changes from the end of the file to the beginning; the
-f from beginning to end.
The command form   used by -e is reversed. For example, 10c with
-e would be c10 with -f.
The form used for ranges of line numbers is -separated, rather than -separated.
Diff -c or -C Output Format
With the -c or -C option, the output format shall consist of affected lines along with surrounding lines of
context. The affected lines shall show which ones need to be deleted or changed in file1, and those added from file2.
With the -c option, three lines of context, if available, shall be written before and after the affected lines. With the
-C option, the user can specify how many lines of context are written. The exact format follows.
The name and last modification time of each file shall be output in the following format:
"*** %s %s\n", file1,
"--- %s %s\n", file2,
Each  field shall be the pathname of the corresponding file being compared. The pathname written for standard
input is unspecified.
In the POSIX locale, each  field shall be equivalent to the output from the following command:
date "+%a %b %e %T %Y"
without the trailing , executed at the time of last modification of the corresponding file (or the current time,
if the file is standard input).
Then, the following output formats shall be applied for every set of changes.
First, a line shall be written in the following format:
"***************\n"
"*** %d,%d ****\n", ,
and the following format otherwise:
"*** %d ****\n",
The ending line number of an empty range shall be the number of the preceding line, or 0 if the range is at the start of the
file.
the following format:
"ΔΔ%s",
Deleted lines shall be written as:
"-Δ%s",
Changed lines shall be written as:
"!Δ%s",
"--- %d,%d ----\n", ,
and the following format otherwise:
"--- %d ----\n",
Then, lines of context and changed lines shall be written as described in the previous formats. Lines added from file2
shall be written in the following format:
"+Δ%s",
Diff -u or -U Output Format
The -u or -U options behave like the -c or -C options, except that the context lines are not
repeated; instead, the context, deleted, and added lines are shown together, interleaved. The exact format follows.
The name and last modification time of each file shall be output in the following format:
"---Δ%s\t%s%sΔ%s\n", file1, , ,
"+++Δ%s\t%s%sΔ%s\n", file2, , ,
Each  field shall be the pathname of the corresponding file being compared, or the single character
'-' if standard input is being compared. However, if the pathname contains a  or a , or if it
does not consist entirely of characters taken from the portable character set, the behavior is implementation-defined.
Each  field shall be equivalent to the output from the following command:
date '+%Y-%m-%dΔ%H:%M:%S'
without the trailing , executed at the time of last modification of the corresponding file (or the current time,
if the file is standard input).
Each  field shall be either empty, or a decimal point followed by at least one decimal digit, indicating the
fractional-seconds part (if any) of the file timestamp. The number of fractional digits shall be at least the number needed to
represent the file's timestamp without loss of information.
Each  field shall be of the form "shhmm", where "shh" is a signed two-digit decimal number
in the range -24 through +25, and "mm" is an unsigned two-digit decimal number in the range 00 through 59. It represents
the timezone of the timestamp as the number of hours (hh) and minutes (mm) east (+) or west (-) of UTC for the timestamp. If the
hours and minutes are both zero, the sign shall be '+'. However, if the timezone is not an integral number of minutes away
from UTC, the  field is implementation-defined.
Then, the following output formats shall be applied for every set of changes.
First, the range of lines in each file shall be written in the following format:
"@@Δ-%sΔ+%sΔ@@", ,
Each  field shall be of the form:
"%1d",
or:
"%1d,1",
if the range contains exactly one line, and:
"%1d,%1d", ,
otherwise. If a range is empty, its beginning line number shall be the number of the line just before the range, or 0 if the
empty range starts the file.
following format:
"Δ%s",
where the contents of the unaffected line shall be taken from file1. It is implementation-defined whether an empty
unaffected line is written as an empty line or a line containing a single  character. This line also represents the
same line of file2, even though file2's line may contain different contents due to the -b. Deleted lines shall
be written as:
"-%s",
Added lines shall be written as:
"+%s",
The order of lines written shall be the same as that of the corresponding file. A deleted line shall never be written
immediately after an added line.
If -U n is specified, the output shall contain no more than 2n consecutive unaffected lines; and if the
output contains an affected line and this line is adjacent to up to n consecutive unaffected lines in the corresponding
file, the output shall contain these unaffected lines. -u shall act like -U3.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
No differences were found.
1
Differences were found and all differences were successfully output.
>1
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
If lines at the end of a file are changed and other lines are added, diff output may show this as a delete and add, as a
change, or as a change and add; diff is not expected to know which happened and users should not care about the difference
in output as long as it clearly shows the differences between the files.
EXAMPLES
If dir1 is a directory containing a directory named x, dir2 is a directory containing a directory named
x, dir1/x and dir2/x both contain files named date.out, and dir2/x contains a file named
y, the command:
diff -r dir1 dir2
could produce output similar to:
Common subdirectories: dir1/x and dir2/x
Only in dir2/x: y
diff -r dir1/x/date.out dir2/x/date.out
1c1
Tue Jun 19 21:41:39 PDT 1990
RATIONALE
The -h option was omitted because it was insufficiently specified and does not add to applications portability.
Historical implementations employ algorithms that do not always produce a minimum list of differences; the current language
about making every effort is the best this volume of POSIX.1-2024 can do, as there is no metric that could be employed to judge the
quality of implementations against any and all file contents. The statement "This list should be minimal" clearly implies that
implementations are not expected to provide the following output when comparing two 100-line files that differ in only one
character on a single line:
1,100c1,100
all 100 lines from file1 preceded with " "
The "Only in" messages required when the -r option is specified are not used by most historical implementations if the
-e option is also specified. It is required here because it provides useful information that must be provided to update a
target directory hierarchy to match a source hierarchy. The "Common subdirectories" messages are written by System V and 4.3 BSD
when the -r option is specified. They are allowed here but are not required because they are reporting on something that is
the same, not reporting a difference, and are not needed to update a target hierarchy.
The -c option, which writes output in a format using lines of context, has been included. The format is useful for a
variety of reasons, among them being much improved readability and the ability to understand difference changes when the target
file has line numbers that differ from another similar, but slightly different, copy. The patch utility is most valuable when working with difference listings using a context format.
The BSD version of -c takes an optional argument specifying the amount of context. Rather than overloading -c and
breaking the Utility Syntax Guidelines for diff, the standard developers decided to add a separate option for specifying a
context diff with a specified amount of context (-C). Also, the format for context diffs was extended slightly in 4.3
BSD to allow multiple changes that are within context lines from each other to be merged together. The output format contains an
additional four  characters after the range of affected lines in the first filename. This was to provide a flag for
old programs (like old versions of patch) that only understand the old context format.
The version of context described here does not require that multiple changes within context lines be merged, but it does not
prohibit it either. The extension is upwards-compatible, so any vendors that wish to retain the old version of diff can do
so by adding the extra four  characters (that is, utilities that currently use diff and understand the new
merged format will also understand the old unmerged format, but not vice versa).
The -u and -U options of GNU diff have been included. Their output format, designed by Wayne Davison, takes
up less space than -c and -C format, and in many cases is easier to read. The format's timestamps do not vary by
locale, so LC_TIME does not affect it. The format's line numbers are rendered with the %1d format, not %d,
because the file format notation rules would allow extra  characters to appear around the numbers.
The substitute command was added as an additional format for the -e option. This was added to provide implementations
with a way to fix the classic "dot alone on a line" bug present in many versions of diff. Since many implementations have
fixed this bug, the standard developers decided not to standardize broken behavior, but rather to provide the necessary tool for
fixing the bug. One way to fix this bug is to output two periods whenever a lone period is needed, then terminate the append
command with a period, and then use the substitute command to convert the two periods into one period.
The BSD-derived -r option was added to provide a mechanism for using diff to compare two file system trees. This
behavior is useful, is standard practice on all BSD-derived systems, and is not easily reproducible with the find utility.
The requirement that diff not compare files in some circumstances, even though they have the same name, is based on the
actual output of historical implementations. The specified behavior precludes the problems arising from running into FIFOs and
other files that would cause diff to hang waiting for input with no indication to the user that diff was hung. An
earlier version of this standard specified the output format more precisely, but in practice this requirement was widely ignored
and the benefit of standardization seemed small, so it is now unspecified. In most common usage, diff -r should
indicate differences in the file hierarchies, not the difference of contents of devices pointed to by the hierarchies.
Many early implementations of diff require seekable files. Since the System Interfaces volume of POSIX.1-2024 supports
named pipes, the standard developers decided that such a restriction was unreasonable. Note also that the allowed filename -
almost always refers to a pipe.
No directory search order is specified for diff. The historical ordering is, in fact, not optimal, in that it prints out
all of the differences at the current level, including the statements about all common subdirectories before recursing into those
subdirectories.
The message:
"diff %s %s %s\n", , ,
does not vary by locale because it is the representation of a command, not an English sentence.
FUTURE DIRECTIONS
If this utility is directed to display a pathname that contains any bytes that have the encoded value of a
character when  is a terminator or separator in the output format being used, implementations are encouraged to
treat this as an error. A future version of this standard may require implementations to treat this as an error.
SEE ALSO
cmp, comm, ed, find
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 2.
Issue 5
The FUTURE DIRECTIONS section is added.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The -f option is added.
The output format for -c or -C format is changed to align with changes to the IEEE P1003.2b draft standard
resulting from IEEE PASC Interpretation 1003.2 #71.
The normative text is reworded to avoid use of the term "must" for application requirements.
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/20 is applied, changing the STDOUT section. This changes the
specification of diff -c so that it agrees with existing practice when contexts contain zero lines or one line.
Issue 7
Austin Group Interpretations 1003.1-2001 #115 and #114 are applied.
Austin Group Interpretation 1003.1-2001 #192 is applied, clarifying the behavior if both files are non-text files.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
SD5-XCU-ERN-103 and SD5-XCU-ERN-120 are applied, adding the -u option.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0082 [584], XCU/TC2-2008/0083 [950], XCU/TC2-2008/0084 [969], and
XCU/TC2-2008/0085 [929] are applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to report an error if a utility is directed to display a
pathname that contains any bytes that have the encoded value of a  character when  is a terminator or
separator in the output format being used.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1498 is applied, changing the EXIT STATUS section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/pathchk.html =====
pathchk
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pathchk — check pathnames
SYNOPSIS
pathchk [-p] [-P] pathname...
DESCRIPTION
The pathchk utility shall check that one or more pathnames are valid (that is, they could be used to access or create a
file without causing syntax errors) and portable (that is, no filename truncation results). More extensive portability checks are
provided by the -p and -P options.
By default, the pathchk utility shall check each component of each pathname operand based on the underlying file
system. A diagnostic shall be written for each pathname operand that:
Is longer than {PATH_MAX} bytes (see Pathname Variable Values in XBD )
Contains any component longer than {NAME_MAX} bytes in its containing directory
Contains any component in a directory that is not searchable
Contains any byte sequence that is not valid in its containing directory
The format of the diagnostic message is not specified, but shall indicate the error detected and the corresponding
pathname operand.
It shall not be considered an error if one or more components of a pathname operand do not exist as long as a file
matching the pathname specified by the missing components could be created that does not violate any of the checks specified
above.
OPTIONS
The pathchk utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following option shall be supported:
-p
Instead of performing checks based on the underlying file system, write a diagnostic for each pathname operand that:
Is longer than {_POSIX_PATH_MAX} bytes (see Minimum Values in XBD )
Contains any component longer than {_POSIX_NAME_MAX} bytes
Contains any character in any component that is not in the portable filename character set
-P
Write a diagnostic for each pathname operand that:
Contains a component whose first character is the  character
Is empty
OPERANDS
The following operand shall be supported:
pathname
A pathname to be checked.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of pathchk:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
Not used.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
All pathname operands passed all of the checks.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
The test utility can be used to determine whether a given pathname names an existing
file; it does not, however, give any indication of whether or not any component of the pathname was truncated in a directory where
the _POSIX_NO_TRUNC feature is not in effect. The pathchk utility does not check for file existence; it performs checks to
determine whether a pathname does exist or could be created with no pathname component truncation.
The noclobber option in the shell (see the set special
built-in) can be used to atomically create a file. As with all file creation semantics in the System Interfaces volume of
POSIX.1-2024, it guarantees atomic creation, but still depends on applications to agree on conventions and cooperate on the use of
files after they have been created.
To verify that a pathname meets the requirements of filename portability, applications should use both the -p and
-P options together.
EXAMPLES
To verify that all pathnames in an imported data interchange archive are legitimate and unambiguous on the current system:
# This example assumes that no pathnames in the archive
# contain  characters.
pax -f archive | sed -e 's/[^[:alnum:]]/\\&/g' | xargs pathchk --
if [ $? -eq 0 ]
then
pax -r -f archive
else
echo Investigate problems before importing files.
exit 1
fi
To verify that all files in the current directory hierarchy could be moved to any system conforming to the System Interfaces
volume of POSIX.1-2024 that also supports the pax utility:
find . -exec pathchk -p -P {} +
if [ $? -eq 0 ]
then
pax -w -f ../archive .
else
echo Portable archive cannot be created.
exit 1
fi
To verify that a user-supplied pathname names a readable file and that the application can create a file extending the given
path without truncation and without overwriting any existing file:
case $- in
*C*)    reset="";;
*)      reset="set +C"
set -C;;
esac
test -r "$path" && pathchk "$path.out" &&
rm "$path.out" > "$path.out"
if [ $? -ne 0 ]; then
printf "%s: %s not found or %s.out fails \
creation checks.\n" $0 "$path" "$path"
$reset    # Reset the noclobber option in case a trap
# on EXIT depends on it.
exit 1
fi
$reset
PROCESSING  "$path.out"
The following assumptions are made in this example:
PROCESSING represents the code that is used by the application to use $path once it is verified that
$path.out works as intended.
The state of the noclobber option is unknown when this code is invoked and should be set on exit to the state it was in
when this code was invoked. (The reset variable is used in this example to restore the initial state.)
Note the usage of:
rm "$path.out" > "$path.out"
The pathchk command has already verified, at this point, that $path.out is not truncated.
With the noclobber option set, the shell verifies that $path.out does not already exist before invoking rm.
If the shell succeeded in creating $path.out, rm removes it so that the
application can create the file again in the PROCESSING step.
If the PROCESSING step wants the file to exist already when it is invoked, the:
rm "$path.out" > "$path.out"
should be replaced with:
> "$path.out"
which verifies that the file did not already exist, but leaves $path.out in place for use by PROCESSING.
RATIONALE
The pathchk utility was new for the ISO POSIX-2:1993 standard. It, along with the set -C(noclobber) option added to the shell, replaces the mktemp,
validfnam, and create utilities that appeared in early proposals. All of these utilities were attempts to solve
several common problems:
Verify the validity (for several different definitions of "valid") of a pathname supplied by a user, generated by an
application, or imported from an external source.
Atomically create a file.
Perform various string handling functions to generate a temporary filename.
The create utility, included in an early proposal, provided checking and atomic creation in a single invocation of the
utility; these are orthogonal issues and need not be grouped into a single utility. Note that the noclobber option also
provides a way of creating a lock for process synchronization; since it provides an atomic create, there is no race between
a test for existence and the following creation if it did not exist.
Having a function like tmpnam() in the ISO C standard is important in many
high-level languages. The shell programming language, however, has built-in string manipulation facilities, making it very easy to
construct temporary filenames. The names needed obviously depend on the application, but are frequently of a form similar to:
$TMPDIR/application_abbreviation$$.suffix
In cases where there is likely to be contention for a given suffix, a simple shell for or while loop can be used
with the shell noclobber option to create a file without risk of collisions, as long as applications trying to use the same
filename name space are cooperating on the use of files after they have been created.
For historical purposes, -p does not check for the use of the  character as the first character in a
component of the pathname, or for an empty pathname operand.
FUTURE DIRECTIONS
None.
SEE ALSO
2.7 Redirection, set, test
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines,
CHANGE HISTORY
First released in Issue 4.
Issue 7
Austin Group Interpretations 1003.1-2001 #039, #040, and #094 are applied.
SD5-XCU-ERN-121 is applied, updating the EXAMPLES section.
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0127 [291] is applied.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0150 [584] and XCU/TC2-2008/0151 [584] are applied.
Issue 8
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/[.html =====
test
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
test — evaluate expression
SYNOPSIS
test [expression]
[ [expression] ]
DESCRIPTION
The test utility shall evaluate the expression and indicate the result of the evaluation by its exit status. An
exit status of zero indicates that the expression evaluated as true and an exit status of 1 indicates that the expression evaluated
as false.
In the second form of the utility, where the utility name used is [ rather than test, the application shall ensure
that the closing square bracket is a separate argument. The test and [ utilities may be implemented as a single
linked utility which examines the basename of the zeroth command line argument to determine whether to behave as the test or
[ variant. Applications using the exec family of functions to execute these utilities shall ensure that the argument
passed in arg0 or argv[0] is '[' when executing the [ utility and has a basename of "test"
when executing the test utility.
OPTIONS
The test utility shall not recognize the "--" argument in the manner specified by Guideline 10 in XBD 12.2 Utility Syntax Guidelines. In addition, when the utility name used is
[ the utility does not conform to Guidelines 1 and 2.
No options shall be supported.
OPERANDS
The application shall ensure that all operators and elements of primaries are presented as separate arguments to the test
utility.
The following primaries can be used to construct expression:
-b pathname
True if pathname resolves to an existing directory entry for a block special file. False if pathname cannot be
resolved, or if pathname resolves to an existing directory entry for a file that is not a block special file.
-c pathname
True if pathname resolves to an existing directory entry for a character special file. False if pathname cannot
be resolved, or if pathname resolves to an existing directory entry for a file that is not a character special file.
-d pathname
True if pathname resolves to an existing directory entry for a directory. False if pathname cannot be resolved,
or if pathname resolves to an existing directory entry for a file that is not a directory.
-e pathname
True if pathname resolves to an existing directory entry. False if pathname cannot be resolved.
pathname1 -ef pathname2
True if pathname1 and pathname2 resolve to existing directory entries for the same file; otherwise, false.
-f pathname
True if pathname resolves to an existing directory entry for a regular file. False if pathname cannot be
resolved, or if pathname resolves to an existing directory entry for a file that is not a regular file.
-g pathname
True if pathname resolves to an existing directory entry for a file that has its set-group-ID flag set. False if
pathname cannot be resolved, or if pathname resolves to an existing directory entry for a file that does not have its
set-group-ID flag set.
-h pathname
True if pathname resolves to an existing directory entry for a symbolic link. False if pathname cannot be
resolved, or if pathname resolves to an existing directory entry for a file that is not a symbolic link. If the final
component of pathname is a symbolic link, that symbolic link is not followed.
-L pathname
True if pathname resolves to an existing directory entry for a symbolic link. False if pathname cannot be
resolved, or if pathname resolves to an existing directory entry for a file that is not a symbolic link. If the final
component of pathname is a symbolic link, that symbolic link is not followed.
-n string
True if the length of string is non-zero; otherwise, false.
pathname1 -nt pathname2
True if pathname1 resolves to an existing file and pathname2 cannot be resolved, or if both resolve to existing files
and pathname1 is newer than pathname2 according to their last data modification timestamps; otherwise, false.
pathname1 -ot pathname2
True if pathname2 resolves to an existing file and pathname1 cannot be resolved, or if both resolve to existing files
and pathname1 is older than pathname2 according to their last data modification timestamps; otherwise, false.
-p pathname
True if pathname resolves to an existing directory entry for a FIFO. False if pathname cannot be resolved, or if
pathname resolves to an existing directory entry for a file that is not a FIFO.
-r pathname
True if pathname resolves to an existing directory entry for a file for which permission to read from the file is
granted, as defined in 1.1.1.4 File Read, Write, and Creation.
False if pathname cannot be resolved, or if pathname resolves to an existing directory entry for a file for which
permission to read from the file is not granted.
-S pathname
True if pathname resolves to an existing directory entry for a socket. False if pathname cannot be resolved, or
if pathname resolves to an existing directory entry for a file that is not a socket.
-s pathname
True if pathname resolves to an existing directory entry for a file that has a size greater than zero. False if
pathname cannot be resolved, or if pathname resolves to an existing directory entry for a file that does not have a
size greater than zero.
-t file_descriptor
True if file descriptor number file_descriptor is open and is associated with a terminal. False if file_descriptor is
not a valid file descriptor number, or if file descriptor number file_descriptor is not open, or if it is open but is not
associated with a terminal.
-u pathname
True if pathname resolves to an existing directory entry for a file that has its set-user-ID flag set. False if
pathname cannot be resolved, or if pathname resolves to an existing directory entry for a file that does not have its
set-user-ID flag set.
-w pathname
True if pathname resolves to an existing directory entry for a file for which permission to write to the file is
granted, as defined in 1.1.1.4 File Read, Write, and Creation.
False if pathname cannot be resolved, or if pathname resolves to an existing directory entry for a file for which
permission to write to the file is not granted.
-x pathname
True if pathname resolves to an existing directory entry for a file for which permission to execute the file (or search
it, if it is a directory) is granted, as defined in 1.1.1.4 File Read,
Write, and Creation. False if pathname cannot be resolved, or if pathname resolves to an existing directory
entry for a file for which permission to execute (or search) the file is not granted.
-z string
True if the length of string string is zero; otherwise, false.
string
True if the string string is not the null string; otherwise, false.
s1 = s2
True if the strings s1 and s2 are identical; otherwise, false.
s1 != s2
True if the strings s1 and s2 are not identical; otherwise, false.
s1 > s2
True if s1 collates after s2 in the current locale; otherwise, false.
s1
final argument shall not be counted in this algorithm.)
In the following list, $1, $2, $3, and $4 represent the arguments presented to test:
0 arguments:
Exit false (1).
1 argument:
Exit true (0) if $1 is not null; otherwise, exit false.
2 arguments:
If $1 is '!', exit true if $2 is null, false if $2 is not null.
If $1 is a unary primary, exit true if the unary test is true, false if the unary test is false.
Otherwise, produce unspecified results.
3 arguments:
If $2 is a binary primary, perform the binary test of $1 and $3.
If $1 is '!', negate the two-argument test of $2 and $3.
Otherwise, produce unspecified results.
4 arguments:
If $1 is '!', negate the three-argument test of $2, $3, and $4.
Otherwise, the results are unspecified.
>4 arguments:
The results are unspecified.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of test:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_COLLATE
Determine the locale for the behavior of the > and 1
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
Since '>' and ' s2, s1  s2, and s1 >>
===== susv5-html/utilities/ps.html =====
ps
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ps — report process status
SYNOPSIS
[XSI] ps [-aAw] [-defl]
[-g grouplist] [-G
grouplist]        [-n namelist] [-o format]... [-p
proclist] [-t termlist]        [-u
userlist] [-U userlist]
DESCRIPTION
The ps utility shall write information about processes, subject to having appropriate privileges to obtain information
about those processes.
By default, ps shall select all processes with the same effective user ID as the current user and the same controlling
terminal as the invoker.
OPTIONS
The ps utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-a
Write information for all processes associated with terminals. Implementations may omit session leaders from this list.
-A
Write information for all processes.
-d
[XSI]
Write information for all processes, except session leaders.
-e
[XSI]
Write information for all processes.  (Equivalent to
-A.)
-f
[XSI]
Generate a full listing. (See the STDOUT section for the contents of a full listing.)
-g grouplist
[XSI]
Write information for processes whose session leaders are given in grouplist. The application shall ensure that the
grouplist is a single argument in the form of a  or -separated list.
-G grouplist
Write information for processes whose real group ID numbers are given in grouplist. The application shall ensure that
the grouplist is a single argument in the form of a  or -separated list.
-l
[XSI]
Generate a long listing. (See STDOUT for the contents of a long listing.)
-n namelist
[XSI]
Specify the name of an alternative system namelist file in place of the default. The name of the default file and the format
of a namelist file are unspecified.
-o format
Write information according to the format specification given in format. This is fully described in the STDOUT section.
Multiple -o options can be specified; the format specification shall be interpreted as the -separated
concatenation of all the format option-arguments.
-p proclist
Write information for processes whose process ID numbers are given in proclist. The application shall ensure that the
proclist is a single argument in the form of a  or -separated list.
-t termlist
Write information for processes associated with terminals given in termlist. The application shall ensure that the
termlist is a single argument in the form of a  or -separated list. Terminal identifiers shall be
given in an implementation-defined format. [XSI]   On XSI-conformant systems, they shall be given in one of two
forms: the device's filename (for example, tty04) or, if the device's filename starts with tty, just the identifier
following the characters tty (for example, "04").
-u userlist
[XSI]
Write information for processes whose user ID numbers or login names are given in userlist. The application shall ensure
that the userlist is a single argument in the form of a  or -separated list. In the listing, the
numerical user ID shall be written unless the -f option is used, in which case the login name shall be written.
-U userlist
Write information for processes whose real user ID numbers or login names are given in userlist. The application shall
ensure that the userlist is a single argument in the form of a  or -separated list.
-w
Behave as if the COLUMNS environment variable had a value of at least 132. If the -w option is not specified or
is specified exactly once, all output lines shall contain no more than the greater of {LINE_MAX} and COLUMNS bytes provided
that no format name is specified multiple times.
With the exception of [XSI]  -f, -l, -n namelist,   and -o format, all of the options shown are used to select processes. If any are specified, the
default list shall be ignored and ps shall select the processes represented by the inclusive OR of all the
selection-criteria options.
OPERANDS
None.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of ps:
COLUMNS
Override the system-selected horizontal display line size, used to determine the number of text columns to display. See XBD
8. Environment Variables for valid values and results when it is unset or
null.
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error and
informative messages written to standard output.
LC_TIME
Determine the format and contents of the date and time strings displayed.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
TZ
Determine the timezone used to calculate date and time strings displayed. If TZ is unset or null, an unspecified default
timezone shall be used.
ASYNCHRONOUS EVENTS
Default.
STDOUT
When the -o option is not specified, the standard output format is unspecified.
[XSI]
On XSI-conformant systems, the output format shall be as follows. The column headings and descriptions of the columns in a
ps listing are given below. The precise meanings of these fields are implementation-defined. The letters 'f' and
'l' (below) indicate the option (full or long) that shall cause the corresponding heading to appear;
all means that the heading always appears. Note that these two options determine only what information is provided for a
process; they do not determine which processes are listed.
F
(l)
Flags (octal and additive) associated with the process.
S
(l)
The state of the process.
UID
(f,l)
The user ID number of the process owner; the login name is printed under the -f option.
PID
(all)
The process ID of the process; it is possible to kill a process if this datum is known.
PPID
(f,l)
The process ID of the parent process.
C
(f,l)
Processor utilization for scheduling.
PRI
(l)
The priority of the process; higher numbers mean lower priority.
NI
(l)
Nice value; used in priority computation.
ADDR
(l)
The address of the process.
SZ
(l)
The size in pages of the total memory requirements of the process, including text, data, stack, mapped memory and
other resources.
WCHAN
(l)
The event for which the process is waiting or sleeping; if blank, the process is running.
STIME
(f)
Starting time of the process.
TTY
(all)
The controlling terminal for the process.
TIME
(all)
The cumulative execution time for the process.
CMD
(all)
The command name; the full command name and its arguments are written under the -f option.
A process that has exited and has a parent, but has not yet been waited for by the parent, shall be marked
defunct.
Under the option -f, ps tries to determine the command name and arguments given when the process was
created by examining memory or the swap area. Failing this, the command name, as it would appear without the option -f, is
written in square brackets.
The -o option allows the output format to be specified under user control.
The application shall ensure that the format specification is a list of names presented as a single argument,
or -separated. Each variable has a default header. The default header can be overridden by appending an
and the new text of the header. The rest of the characters in the argument shall be used as the header text.
The fields specified shall be written in the order specified on the command line, and should be arranged in columns in the output.
The field widths shall be selected by the system to be at least as wide as the header text (default or overridden value). If the
header text is null, such as -o user=, the field width shall be at least as wide as the default header text. If all
header text fields are null, no header line shall be written.
The following names are recognized in the POSIX locale:
ruser
The real user ID of the process. This shall be the textual user ID, if it can be obtained and the field width permits, or a
decimal representation otherwise.
user
The effective user ID of the process. This shall be the textual user ID, if it can be obtained and the field width permits, or
a decimal representation otherwise.
rgroup
The real group ID of the process. This shall be the textual group ID, if it can be obtained and the field width permits, or a
decimal representation otherwise.
group
The effective group ID of the process. This shall be the textual group ID, if it can be obtained and the field width permits,
or a decimal representation otherwise.
pid
The decimal value of the process ID.
ppid
The decimal value of the parent process ID.
pgid
The decimal value of the process group ID.
pcpu
The ratio of CPU time used recently to CPU time available in the same period, expressed as a percentage. The meaning of
"recently" in this context is unspecified. The CPU time available is determined in an unspecified manner.
vsz
The size of the process in (virtual) memory in 1024 byte units as a decimal integer.
nice
The decimal value of the nice value of the process; see nice.
etime
In the POSIX locale, the elapsed time since the process was started, in the form:
[[dd-]hh:]mm:ss
where dd shall represent the number of days, hh the number of hours, mm the number of minutes,
and ss the number of seconds. The dd field shall be a decimal integer. The hh, mm, and ss fields
shall be two-digit decimal integers padded on the left with zeros.
time
In the POSIX locale, the cumulative CPU time of the process in the form:
[dd-]hh:mm:ss
The dd, hh, mm, and ss fields shall be as described in the etime specifier.
tty
The name of the controlling terminal of the process (if any) in the same format used by the who utility.
comm
The name of the command being executed (argv[0] value) as a string.
args
The command with all its arguments as a string. The implementation may truncate this value to the field width; it is
implementation-defined whether any further truncation occurs. It is unspecified whether the string represented is a version of the
argument list as it was passed to the command when it started, or is a version of the arguments as they may have been modified by
the application. Applications cannot depend on being able to modify their argument list and having that modification be reflected
in the output of ps.
Any field need not be meaningful in all implementations. In such a case a  ('-')
should be output in place of the field value.
Only comm and args shall be allowed to contain  characters; all others shall not. Any
implementation-defined variables shall be specified in the system documentation along with the default header and indicating
whether the field may contain  characters.
The following table specifies the default header to be used in the POSIX locale corresponding to each format
specifier.
Table: Variable Names and Default Headers in ps
Format Specifier
Default Header
Format Specifier
Default Header
args
COMMAND
ppid
PPID
comm
COMMAND
rgroup
RGROUP
etime
ELAPSED
ruser
RUSER
group
GROUP
time
TIME
nice
NI
tty
TT
pcpu
%CPU
user
USER
pgid
PGID
vsz
VSZ
pid
PID
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
Things can change while ps is running; the snapshot it gives is only true for an instant, and might not be accurate by
the time it is displayed.
The args format specifier is allowed to produce a truncated version of the command arguments. In some
implementations, this information is no longer available when the ps utility is executed.
If the field width is too narrow to display a textual ID, the system may use a numeric version. Normally, the
system would be expected to choose large enough field widths, but if a large number of fields were selected to write, it might
squeeze fields to their minimum sizes to fit on one line. One way to ensure adequate width for the textual IDs is to override the
default header for a field to make it larger than most or all user or group names.
Portable applications should not set COLUMNS to a value greater than {LINE_MAX} and should not specify the
-w option more than once if the output will be used as input for a utility that requires a text file as input because lines
containing more than {LINE_MAX} bytes may cause undefined behavior in some implementations of the utility.
There is no special quoting mechanism for header text. The header text is the rest of the argument. If multiple
header changes are needed, multiple -o options can be used, such as:
ps -o "user=User Name" -o pid=Process\ ID
On some implementations, especially multi-level secure systems, ps may be severely restricted and produce
information only about child processes owned by the user.
EXAMPLES
The command:
ps -o user,pid,ppid=MOM -o args
writes at least the following in the POSIX locale:
USER   PID   MOM   COMMAND
helene    34    12   ps -o user,pid,ppid=MOM -o args
The contents of the COMMAND field need not be the same in all implementations, due to possible
truncation.
RATIONALE
There is very little commonality between BSD and System V implementations of ps. Many options conflict or have subtly
different usages. The standard developers attempted to select a set of options for the base standard that were useful on a wide
range of systems and selected options that either can be implemented on both BSD and System V-based systems without breaking the
current implementations or where the options are sufficiently similar that any changes would not be unduly problematic for users or
implementors.
It is recognized that on some implementations, especially multi-level secure systems, ps may be nearly
useless. The default output has therefore been chosen such that it does not break historical implementations and also is likely to
provide at least some useful information on most systems.
The major change is the addition of the format specification capability. The motivation for this invention is to
provide a mechanism for users to access a wider range of system information, if the system permits it, in a portable manner. The
fields chosen to appear in this volume of POSIX.1-2024 were arrived at after considering what concepts were likely to be both
reasonably useful to the "average" user and had a reasonable chance of being implemented on a wide range of systems. Again it is
recognized that not all systems are able to provide all the information and, conversely, some may wish to provide more. It is hoped
that the approach adopted will be sufficiently flexible and extensible to accommodate most systems. Implementations may be expected
to introduce new format specifiers.
The default output should consist of a short listing containing the process ID, terminal name, cumulative execution
time, and command name of each process.
The preference of the standard developers would have been to make the format specification an operand of the
ps command. Unfortunately, BSD usage precluded this.
At one time a format was included to display the environment array of the process. This was deleted because there
is no portable way to display it.
The -A option is equivalent to the BSD -g and the SVID -e. Because the two systems differed, a
mnemonic compromise was selected.
The -a option is described with some optional behavior because the SVID omits session leaders, but BSD does
not.
In an early proposal, format specifiers appeared for priority and start time. The former was not defined adequately
in this volume of POSIX.1-2024 and was removed in deference to the defined nice value; the latter because elapsed time was
considered to be more useful.
In a new BSD version of ps, a -O option can be used to write all of the default information, followed
by additional format specifiers. This was not adopted because the default output is implementation-defined. Nevertheless, this is a
useful option that should be reserved for that purpose. In the -o option for the POSIX Shell and Utilities ps, the
format is the concatenation of each -o. Therefore, the user can have an alias or function that defines the beginning of
their desired format and add more fields to the end of the output in certain cases where that would be useful.
The format of the terminal name is unspecified, but the descriptions of ps, talk, who, and write require that they all use the same format.
The pcpu field indicates that the CPU time available is determined in an unspecified manner. This is because
it is difficult to express an algorithm that is useful across all possible machine architectures. Historical counterparts to this
value have attempted to show percentage of use in the recent past, such as the preceding minute. Frequently, these values for all
processes did not add up to 100%. Implementations are encouraged to provide data in this field to users that will help them
identify processes currently affecting the performance of the system.
FUTURE DIRECTIONS
None.
SEE ALSO
kill, nice,
renice
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 2.
Issue 6
This utility is marked as part of the User Portability Utilities option.
The normative text is reworded to avoid use of the term "must" for application requirements.
The TZ entry is added to the ENVIRONMENT VARIABLES section.
Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
SD5-XCU-ERN-148 is applied, updating the OPTIONS section.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0160 [584] is applied.
Issue 8
Austin Group Defect 905 is applied, adding the -w option.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1141 is applied, changing the description of SZ in the STDOUT section.
Austin Group Defect 1175 is applied, changing "uid" to "user" in the EXAMPLES section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/exit.html =====
Shell Command Language
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
Please enable javascript in your browser to automatically redirect to the target page, otherwise select the link below.
2.15 Special Built-In Utilities
break
colon
continue
dot
eval
exec
exit
export
readonly
return
set
shift
times
trap
unset
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
===== susv5-html/utilities/cd.html =====
cd
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cd — change the working directory
SYNOPSIS
cd [-L] [directory]
cd -P [-e] [directory]
DESCRIPTION
The cd utility shall change the working directory of the current shell execution environment (see 2.13 Shell Execution Environment) by executing the following steps in sequence.
(In the following steps, the symbol curpath represents an intermediate value used to simplify the description of the
algorithm used by cd. There is no requirement that curpath be made visible to the application.)
If no directory operand is given and the HOME environment variable is empty or undefined, the default behavior is
implementation-defined and no further steps shall be taken.
If no directory operand is given and the HOME environment variable is set to a non-empty value, the cd
utility shall behave as if the directory named in the HOME environment variable was specified as the directory
operand.
If the directory operand begins with a  character, set curpath to the operand and proceed to step
7.
If the first component of the directory operand is dot or dot-dot, proceed to step 6.
Starting with the first pathname in the -separated pathnames of CDPATH (see the ENVIRONMENT VARIABLES
section) if the pathname is non-null, test if the concatenation of that pathname, a  character if that pathname did
not end with a  character, and the directory operand names a directory. If the pathname is null, test if the
concatenation of dot, a  character, and the operand names a directory. In either case, if the resulting string names
an existing directory, set curpath to that string and proceed to step 7. Otherwise, repeat this step with the next pathname
in CDPATH until all pathnames have been tested.
Set curpath to the directory operand.
If the -P option is in effect, proceed to step 10. If curpath does not begin with a  character, set
curpath to the string formed by the concatenation of the value of PWD , a  character if the value of
PWD did not end with a  character, and curpath.
The curpath value shall then be converted to canonical form as follows, considering each component from beginning to end,
in sequence:
Dot components and any  characters that separate them from the next component shall be deleted.
For each dot-dot component, if there is a preceding component and it is neither root nor dot-dot, then:
If the preceding component does not refer (in the context of pathname resolution with symbolic links followed) to a directory,
then the cd utility shall display an appropriate error message and no further steps shall be taken.
The preceding component, all  characters separating the preceding component from dot-dot, dot-dot, and all
characters separating dot-dot from the following component (if any) shall be deleted.
An implementation may further simplify curpath by removing any trailing  characters that are not also
leading  characters, replacing multiple non-leading consecutive  characters with a single ,
and replacing three or more leading  characters with a single . If, as a result of this canonicalization,
the curpath variable is null, no further steps shall be taken.
If curpath is longer than {PATH_MAX} bytes (including the terminating null) and the directory operand was not
longer than {PATH_MAX} bytes (including the terminating null), then curpath shall be converted from an absolute pathname to
an equivalent relative pathname if possible. This conversion shall always be considered possible if the value of PWD , with
a trailing  added if it does not already have one, is an initial substring of curpath. Whether or not it is
considered possible under other circumstances is unspecified. Implementations may also apply this conversion if curpath is
not longer than {PATH_MAX} bytes or the directory operand was longer than {PATH_MAX} bytes.
The cd utility shall then perform actions equivalent to the chdir() function
called with curpath as the path argument. If these actions fail for any reason, the cd utility shall display
an appropriate error message and the remainder of this step shall not be executed. If the -P option is not in effect, the
PWD environment variable shall be set to the value that curpath had on entry to step 9 (i.e., before conversion to a
relative pathname).
If the -P option is in effect, the PWD environment variable shall be set to the string that would be output by
pwd -P. If there is insufficient permission on the new directory, or on any
parent of that directory, to determine the current working directory, the value of the PWD environment variable is
unspecified. If both the -e and the -P options are in effect and cd is unable to determine the pathname of the
current working directory, cd shall complete successfully but return a non-zero exit status.
If, during the execution of the above steps, the PWD environment variable is set, the OLDPWD shell variable shall
also be set to the value of the old working directory (that is the current working directory immediately prior to the call to
cd). It is unspecified whether, when setting OLDPWD , the shell also causes it to be exported if it was not
already.
OPTIONS
The cd utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported by the implementation:
-e
If the -P option is in effect, the current working directory is successfully changed, and the correct value of the
PWD environment variable cannot be determined, exit with exit status 1.
-L
Handle the operand dot-dot logically; symbolic link components shall not be resolved before dot-dot components are processed
(see steps 8. and 9. in the DESCRIPTION).
-P
Handle the operand dot-dot physically; symbolic link components shall be resolved before dot-dot components are processed (see
step 7. in the DESCRIPTION).
If both -L and -P options are specified, the last of these options shall be used and all others ignored. If
neither -L nor -P is specified, the operand shall be handled dot-dot logically; see the DESCRIPTION.
OPERANDS
The following operands shall be supported:
directory
An absolute or relative pathname of the directory that shall become the new working directory. The interpretation of a relative
pathname by cd depends on the -L option and the CDPATH and PWD environment variables. If
directory is an empty string, cd shall write a diagnostic message to standard error and exit with non-zero status. If
directory consists of a single '-' () character, the cd utility shall behave as if
directory contained the value of the OLDPWD environment variable, except that after it sets the value of PWD
it shall write the new value to standard output. The behavior is unspecified if OLDPWD does not start with a
character.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of cd:
CDPATH
A -separated list of pathnames that refer to directories. The cd utility shall use this list in its attempt
to change the directory, as described in the DESCRIPTION. An empty string in place of a directory pathname represents the current
directory. If CDPATH is not set, it shall be treated as if it were an empty string.
HOME
The name of the directory, used when no directory operand is specified.
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
OLDPWD
A pathname of the previous working directory, used when the operand is '-'. If an application sets or unsets the value
of OLDPWD , the behavior of cd with a '-' operand is unspecified.
PWD
This variable shall be set as specified in the DESCRIPTION. If an application sets or unsets the value of PWD , the
behavior of cd is unspecified.
ASYNCHRONOUS EVENTS
Default.
STDOUT
If a non-empty directory name from CDPATH is used, or if the operand '-' is used, and the absolute pathname of
the new working directory can be determined, that pathname shall be written to the standard output as follows:
"%s\n",
If an absolute pathname of the new current working directory cannot be determined, it is unspecified whether nothing is written
to the standard output or the value of curpath used in step 10, followed by a , is written to the standard
output.
If a non-empty directory name from CDPATH is not used, and the directory argument is not '-', there shall be no
output.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
The current working directory was successfully changed and the value of the PWD environment variable was set
correctly.
0
The current working directory was successfully changed, the -e option is not in effect, the -P option is in
effect, and the correct value of the PWD environment variable could not be determined.
>0
Either the -e option or the -P option is not in effect, and an error occurred.
1
The current working directory was successfully changed, both the -e and the -P options are in effect, and the
correct value of the PWD environment variable could not be determined.
>1
Both the -e and the -P options are in effect, and an error occurred.
CONSEQUENCES OF ERRORS
The working directory shall remain unchanged.
The following sections are informative.
APPLICATION USAGE
This utility is required to be intrinsic. See 1.7 Intrinsic Utilities
for details.
Since cd affects the current shell execution environment, it is always provided as a shell regular built-in. If it is
called in a subshell or separate utility execution environment, such as one of the following:
(cd /tmp)
nohup cd
find . -exec cd {} \;
it does not affect the working directory of the caller's environment.
The user must have execute (search) permission in directory in order to change to it.
Since cd treats the operand '-' as a special case, applications should not pass arbitrary values as the operand.
For example, instead of:
CDPATH= cd -P -- "$dir"
applications should use the following:
case $dir in
(/*) cd -P "$dir";;
("") echo >&2 directory is an empty string; exit 1;;
(*) CDPATH= cd -P "./$dir";;
esac
If an absolute pathname of the new current working directory cannot be determined, and a non-empty directory name from
CDPATH is used, cd may write a pathname to standard output that is not an absolute pathname.
EXAMPLES
The following template can be used to perform processing in the directory specified by location and end up in the current
working directory in use before the first cd command was issued:
cd location
if [ $? -ne 0 ]
then
print error message
exit 1
fi
... do whatever is desired as long as the OLDPWD environment variable
is not modified
cd -
RATIONALE
The use of the CDPATH was introduced in the System V shell. Its use is analogous to the use of the PATH variable
in the shell. The BSD C shell used a shell parameter cdpath for this purpose.
A common extension when HOME is undefined is to get the login directory from the user database for the invoking user.
This does not occur on System V implementations.
Some historical shells, such as the KornShell, took special actions when the directory name contained a dot-dot component,
selecting the logical parent of the directory, rather than the actual parent directory; that is, it moved up one level toward the
'/' in the pathname, remembering what the user typed, rather than performing the equivalent of:
chdir("..");
In such a shell, the following commands would not necessarily produce equivalent output for all directories:
cd .. && ls      ls ..
This behavior is now the default. It is not consistent with the definition of dot-dot in most historical practice; that is,
while this behavior has been optionally available in the KornShell, other shells have historically not supported this
functionality. The logical pathname is stored in the PWD environment variable when the cd utility completes and this
value is used to construct the next directory name if cd is invoked with the -L option.
When the -P option is in effect, the correct value of the PWD environment variable cannot be determined on some
systems, but still results in a zero exit status. The value of PWD doesn't matter to some shell scripts and in those cases
this is not a problem. In other cases, especially with multiple calls to cd, the values of PWD and OLDPWD are
important but the standard provided no easy way to know that this was the case. The -e option has been added, even though
this was not historic practice, to give script writers a reliable way to know when the value of PWD is not reliable.
FUTURE DIRECTIONS
If this utility is directed to display a pathname that contains any bytes that have the encoded value of a
character when  is a terminator or separator in the output format being used, implementations are encouraged to
treat this as an error. A future version of this standard may require implementations to treat this as an error.
SEE ALSO
2.13 Shell Execution Environment, pwd
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
XSH chdir()
CHANGE HISTORY
First released in Issue 2.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The cd - operand, PWD , and OLDPWD are added.
The -L and -P options are added to align with the IEEE P1003.2b draft standard. This also includes the
introduction of a new description to include the effect of these options.
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/14 is applied, changing the SYNOPSIS to make it clear that the
-L and -P options are mutually-exclusive.
Issue 7
Austin Group Interpretation 1003.1-2001 #037 is applied.
Austin Group Interpretation 1003.1-2001 #199 is applied, clarifying how the cd utility handles concatenation of two
pathnames when the first pathname ends in a  character.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
Step 7 of the processing performed by cd is revised to refer to curpath instead of "the operand".
Changes to the pwd utility and PWD environment variable have been made to
match the changes to the getcwd() function made for Austin Group Interpretation
1003.1-2001 #140.
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0076 [230], XCU/TC1-2008/0077 [240], XCU/TC1-2008/0078 [240], and
XCU/TC1-2008/0079 [123] are applied.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0074 [584] is applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to report an error if a utility is directed to display a
pathname that contains any bytes that have the encoded value of a  character when  is a terminator or
separator in the output format being used.
Austin Group Defect 253 is applied, adding the -e option.
Austin Group Defect 854 is applied, adding a note to the APPLICATION USAGE section that this utility is required to be
intrinsic.
Austin Group Defect 1045 is applied, clarifying the behavior when the directory operand is '-'.
Austin Group Defect 1047 is applied, requiring cd to treat an empty directory operand as an error
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1527 is applied, clarifying the behavior when an absolute pathname of the new current working directory
cannot be determined.
Austin Group Defect 1601 is applied, clarifying that when setting OLDPWD , the shell need not cause it to be exported if
it was not already.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/who.html =====
who
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
who — display who is on the system
SYNOPSIS
[XSI] who [-mTu] [-abdHlprt] [file]
[XSI]  who [-mu] -s [-bHlprt]
[file]
who -q [file]
who am i
who am I
DESCRIPTION
The who utility shall list various pieces of information about accessible users. The domain of accessibility is
implementation-defined.
[XSI]
Based on the options given, who can also list the user's name, terminal line, login time, elapsed time since activity
occurred on the line, and the process ID of the command interpreter for each current system user.
OPTIONS
The who utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported. The metavariables, such as , refer to fields described in the
STDOUT section.
-a
[XSI]
Process the implementation-defined database or named file with the -b, -d, -l, -p, -r,
-t, -T and -u options turned on.
-b
[XSI]
Write the time and date of the last system reboot. The system reboot time is the time at which the implementation is able to
commence running processes.
-d
[XSI]
Write a list of all processes that have expired and not been respawned by the init system process. The
field shall appear for dead processes and contain the termination and exit values of the dead process. This can be useful in
determining why a process terminated.
-H
[XSI]
Write column headings above the regular output.
-l
[XSI]
(The letter ell.) List only those lines on which the system is waiting for someone to login. The  field shall be
LOGIN in such cases. Other fields shall be the same as for user entries except that the  field does not
exist.
-m
Output only information about the current terminal.
-p
[XSI]
List any other process that is currently active and has been previously spawned by init.
-q
[XSI]
(Quick.) List only the names and the number of users currently logged on. When this option is used, all other options shall be
ignored.
-r
[XSI]
Write the current run-level of the init process.
-s
[XSI]
List only the , , and  fields. This is the default case.
-t
[XSI]
Indicate the last change to the system clock.
-T
Show the state of each terminal, as described in the STDOUT section.
-u
Write "idle time" for each displayed user in addition to any other information. The idle time is the time since any activity
occurred on the user's terminal. The method of determining this is unspecified. [XSI]   This option
shall list only those users who are currently logged in. The  is the user's login name. The
is the name of the line as found in the directory /dev. The  is the time that the user logged in. The
is the number of hours and minutes since activity last occurred on that particular line. A dot indicates
that the terminal has seen activity in the last minute and is therefore "current". If more than twenty-four hours have elapsed or
the line has not been used since boot time, the entry shall be marked . This field is useful when trying to
determine whether a person is working at the terminal or not. The  is the process ID of the user's login process.
OPERANDS
[XSI]
The following operands shall be supported:
am i, am I
In the POSIX locale, limit the output to describing the invoking user, equivalent to the -m option. The am and
i or I need to be separate arguments.
file
Specify a pathname of a file to substitute for the implementation-defined database of logged-on users that who uses by
default.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of who:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
LC_TIME
Determine the locale used for the format and contents of the date and time strings.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
TZ
Determine the timezone used when writing date and time information. If TZ is unset or null, an unspecified default
timezone shall be used.
ASYNCHRONOUS EVENTS
Default.
STDOUT
The who utility shall write its default format to the standard output in an implementation-defined format, subject only
to the requirement of containing the information described above.
[XSI OF]  XSI-conformant systems shall write the default information to the standard output in the following general format:
[][][][][]
For the -b option,  shall be "system boot". The  is unspecified.
The following format shall be used for the -T option:
"%s %c %s %s\n" , , ,
where  is one of the following characters:
+
The terminal allows write access to other users.
-
The terminal denies write access to other users.
?
The terminal write-access state cannot be determined.
This entry is not associated with a terminal.
In the POSIX locale, the  shall be equivalent in format to the output of:
date +"%b %e %H:%M"
If the -u option is used with -T, the idle time shall be added to the end of the previous format in an unspecified
format.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
The name init used for the system process is the most commonly used on historical systems, but it may vary.
The "domain of accessibility" referred to is a broad concept that permits interpretation either on a very secure basis or even
to allow a network-wide implementation like the historical rwho.
EXAMPLES
None.
RATIONALE
Due to differences between historical implementations, the base options provided were a compromise to allow users to work with
those functions. The standard developers also considered removing all the options, but felt that these options offered users
valuable functionality. Additional options to match historical systems are available on XSI-conformant systems.
It is recognized that the who command may be of limited usefulness, especially in a multi-level secure environment. The
standard developers considered, however, that having some standard method of determining the "accessibility" of other users would
aid user portability.
No format was specified for the default who output for systems not supporting the XSI option. In such a user-oriented
command, designed only for human use, this was not considered to be a deficiency.
The format of the terminal name is unspecified, but the descriptions of ps, talk, and write require that they use the same
format.
It is acceptable for an implementation to produce no output for an invocation of who mil.
FUTURE DIRECTIONS
None.
SEE ALSO
mesg
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 2.
Issue 6
This utility is marked as part of the User Portability Utilities option.
The TZ entry is added to the ENVIRONMENT VARIABLES section.
Issue 7
SD5-XCU-ERN-58 is applied, clarifying the -b option.
The who utility is moved from the User Portability Utilities option to the Base. User Portability Utilities is now an
option for interactive utilities.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
Issue 8
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/printf.html =====
printf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
printf — write formatted output
SYNOPSIS
printf format [argument...]
DESCRIPTION
The printf utility shall write formatted operands to the standard output. The argument operands shall be formatted
under control of the format operand.
OPTIONS
None.
OPERANDS
The following operands shall be supported:
format
A character string describing the format to use to write the remaining operands. See the EXTENDED DESCRIPTION section.
argument
The values to be written to standard output, under the control of format. See the EXTENDED DESCRIPTION section.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of printf:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
LC_NUMERIC
Determine the locale for numeric formatting. It shall affect the format of numbers written using the e, E,
f, g, and G conversion specifier characters (if supported).
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
See the EXTENDED DESCRIPTION section.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
The application shall ensure that the format operand is a character string, beginning and ending in its initial shift
state, if any. The format operand shall be used as the format string described in XBD 5. File Format Notation with the following exceptions:
A  in the format string, in any context other than a flag of a conversion specification, shall be treated as an
ordinary character that is copied to the output.
A 'Δ' character in the format string shall be treated as a 'Δ' character, not as a .
In addition to the escape sequences shown in XBD 5. File Format Notation
('\\', '\a', '\b', '\f', '\n', '\r', '\t', '\v'),
"\ddd", where ddd is a one, two, or three-digit octal number, shall be written as a byte with the numeric value
specified by the octal number.
The implementation shall not precede or follow output from the d or u conversion specifiers with
characters not specified by the format operand.
The implementation shall not precede output from the o conversion specifier with zeros not specified by the
format operand.
The a, A, e, E, f, F, g, and G conversion specifiers
need not be supported.
An additional conversion specifier character, b, shall be supported as follows. The argument shall be taken to be a
string that can contain -escape sequences. The following -escape sequences shall be
supported:
The escape sequences listed in XBD 5. File Format Notation
('\\', '\a', '\b', '\f', '\n', '\r', '\t', '\v'), which
shall be converted to the characters they represent.
"\0ddd", where ddd is a zero, one, two, or three-digit octal number that shall be converted to a byte with the
numeric value specified by the octal number.
'\c', which shall not be written and shall cause printf to ignore any remaining characters in the string operand
containing it, any remaining string operands, and any additional characters in the format operand. If a precision is
specified and the argument contains a '\c' after the point at which the number of bytes indicated by the precision
specification have been written, it is unspecified whether the '\c' takes effect.
The interpretation of a  followed by any other sequence of characters is unspecified.
Bytes from the converted string shall be written until the end of the string or the number of bytes indicated by the precision
specification is reached. If the precision is omitted, it shall be taken to be infinite, so all bytes up to the end of the
converted string shall be written.
Conversions can be applied to the nth argument operand rather than to the next argument operand. In this
case, the conversion specifier character '%' is replaced by the sequence "%n$", where n is
a decimal integer in the range [1,{NL_ARGMAX}], giving the argument operand number. This feature provides for the definition
of format strings that select arguments in an order appropriate to specific languages.
The format can contain either numbered argument conversion specifications (that is, ones beginning with
"%n$"), or unnumbered argument conversion specifications, but not both. The only exception to this is that
"%%" can be mixed with the "%n$" form. The results of mixing numbered and unnumbered argument
specifications that consume an argument are unspecified.
For each conversion specification that consumes an argument, an argument operand shall be evaluated and converted to the
appropriate type for the conversion as specified below. The operand to be evaluated shall be determined as follows:
If the conversion specification begins with a "%n$" sequence, the nth argument operand
shall be evaluated.
Otherwise, the evaluated operand shall be the next argument operand after the one evaluated by the previous conversion
specification that consumed an argument; if there is no such previous conversion specification the first argument operand
shall be evaluated.
If the format operand contains no conversion specifications that consume an argument and there are argument
operands present, the results are unspecified.
The format operand shall be reused as often as necessary to satisfy the argument operands. If conversion
specifications beginning with a "%n$" sequence are used, on format reuse the value of n shall refer
to the nth argument operand following the highest numbered argument operand consumed by the previous use of
the format operand.
If an argument operand to be consumed by a conversion specification does not exist:
If it is a numbered argument conversion specification, printf should write a diagnostic message to standard error and
exit with non-zero status, but may behave as for an unnumbered argument conversion specification.
If it is an unnumbered argument conversion specification, any extra b, c, or s conversion specifiers
shall be evaluated as if a null string argument were supplied and any other extra conversion specifiers shall be evaluated as if a
zero argument were supplied.
If a character sequence in the format operand begins with a '%' character, but does not form a valid conversion
specification, the behavior is unspecified.
The argument to the c conversion specifier can be a string containing zero or more bytes. If it contains one or more
bytes, the first byte shall be written and any additional bytes shall be ignored. If the argument is an empty string, it is
unspecified whether nothing is written or a null byte is written.
The argument operands shall be treated as strings if the corresponding conversion specifier is b, c, or
s, and shall be evaluated as if by the strtod() function if the
corresponding conversion specifier is a, A, e, E, f, F, g, or
G. Otherwise, they shall be evaluated as unsuffixed C integer constants, as described by the ISO C standard, with the
following extensions:
A leading  or  shall be allowed.
If the leading character is a single-quote or double-quote, the value shall be the numeric value in the underlying codeset of
the character following the single-quote or double-quote.
Suffixed integer constants may be allowed.
If an argument operand cannot be completely converted into an internal value appropriate to the corresponding conversion
specification, a diagnostic message shall be written to standard error and the utility shall not exit with a zero exit status, but
shall continue processing any remaining operands and shall write the value accumulated at the time the error was detected to
standard output.
It shall not be considered an error if an argument operand is not completely used for a b, c, or
s conversion.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
The floating-point formatting conversion specifications of printf() are not
required because all arithmetic in the shell is integer arithmetic. The awk utility
performs floating-point calculations and provides its own printf function. The bc
utility can perform arbitrary-precision floating-point arithmetic, but does not provide extensive formatting capabilities. (This
printf utility cannot really be used to format bc output; it does not support
arbitrary precision.) Implementations are encouraged to support the floating-point conversions as an extension.
Note that this printf utility, like the printf() function defined in the
System Interfaces volume of POSIX.1-2024 on which it is based, makes no special provision for dealing with multi-byte characters
when using the %c conversion specification or when a precision is specified in a %b or %s conversion
specification. Applications should be extremely cautious using either of these features when there are multi-byte characters in the
character set.
No provision is made in this volume of POSIX.1-2024 which allows field widths and precisions to be specified as '*'
since the '*' can be replaced directly in the format operand using shell variable substitution. Implementations can
also provide this feature as an extension if they so choose.
Hexadecimal character constants as defined in the ISO C standard are not recognized in the format operand because
there is no consistent way to detect the end of the constant. Octal character constants are limited to, at most, three octal
digits, but hexadecimal character constants are only terminated by a non-hex-digit character. In the ISO C standard, string
literal concatenation can be used to terminate a constant and follow it with a hexadecimal character to be written. In the shell,
similar concatenation can be done using $'...' so that the shell converts the hexadecimal sequence before it executes
printf.
The %b conversion specification is not part of the ISO C standard; it has been added here as a portable way to
process -escapes expanded in string operands as provided by the echo
utility. See also the APPLICATION USAGE section of echo for ways to use printf
as a replacement for all of the traditional versions of the echo utility.
If an argument cannot be parsed correctly for the corresponding conversion specification, the printf utility is required
to report an error. Thus, overflow and extraneous characters at the end of an argument being used for a numeric conversion shall be
reported as errors.
Unlike the printf() function, when numbered conversion specifications are used,
specifying the Nth argument does not require that all the leading arguments, from the first to the (N-1)th, are
specified in the format string. For example, "%3$s %1$d\n" is an acceptable format operand which evaluates the
first and third argument operands but not the second.
EXAMPLES
To alert the user and then print and read a series of prompts:
printf "\aPlease fill in the following: \nName: "
read name
printf "Phone number: "
read phone
To read out a list of right and wrong answers from a file, calculate the percentage correctly, and print them out. The numbers
are right-justified and separated by a single . The percentage is written to one decimal place of accuracy:
while read right wrong ; do
percent=$(echo "scale=1;($right*100)/($right+$wrong)" | bc)
printf "%2d right\t%2d wrong\t(%s%%)\n" \
$right $wrong $percent
done >>
===== susv5-html/utilities/fc.html =====
fc
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fc — process the command history list
SYNOPSIS
[UP]  fc [-r] [-e editor] [first
[last]]
fc -l [-nr] [first [last]]
fc -s [old=new] [first]
DESCRIPTION
The fc utility shall list, or shall edit and re-execute, commands previously entered to an interactive sh.
The command history list shall reference commands by number. The first number in the list is selected arbitrarily. The
relationship of a number to its command shall not change except when the user logs in and no other process is accessing the list,
at which time the system may reset the numbering to start the oldest retained command at another number (usually 1). When the
number reaches an implementation-defined upper limit, which shall be no smaller than the value in HISTSIZE or 32767
(whichever is greater), the shell may wrap the numbers, starting the next command with a lower number (usually 1). However, despite
this optional wrapping of numbers, fc shall maintain the time-ordering sequence of the commands. For example, if four
commands in sequence are given the numbers 32766, 32767, 1 (wrapped), and 2 as they are executed, command 32767 is considered the
command previous to 1, even though its number is higher.
When commands are edited (when the -l option is not specified), the resulting lines shall be entered at the end of the
history list and then re-executed by sh. The fc command that caused the editing
shall not be entered into the history list. If the editor returns a non-zero exit status, this shall suppress the entry into the
history list and the command re-execution. Any command line variable assignments or redirection operators used with fc shall
affect both the fc command itself as well as the command that results; for example:
fc -s -- -1 2>/dev/null
reinvokes the previous command, suppressing standard error for both fc and the previous command.
OPTIONS
The fc utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-e editor
Use the editor named by editor to edit the commands. The editor string is a utility name, subject to search via
the PATH variable (see XBD 8. Environment Variables). The value in
the FCEDIT variable shall be used as a default when -e is not specified. If FCEDIT is null or unset, ed shall be used as the editor.
-l
(The letter ell.) List the commands rather than invoking an editor on them. The commands shall be written in the sequence
indicated by the first and last operands, as affected by -r, with each command preceded by the command
number.
-n
Suppress command numbers when listing with -l.
-r
Reverse the order of the commands listed (with -l) or edited (with neither -l nor -s).
-s
Re-execute the command without invoking an editor.
OPERANDS
The following operands shall be supported:
first, last
Select the commands to list or edit. The number of previous commands that can be accessed shall be determined by the value of
the HISTSIZE variable. The value of first or last or both shall be one of the following:
[+]number
A positive number representing a command number; command numbers can be displayed with the -l option.
-number
A negative decimal number representing the command that was executed number of commands previously. For example, -1 is
the immediately previous command.
string
A string indicating the most recently entered command that begins with that string. If the old=new operand is not
also specified with -s, the string form of the first operand cannot contain an embedded .
When the synopsis form with -s is used:
If first is omitted, the previous command shall be used.
For the synopsis forms without -s:
If last is omitted, last shall default to the previous command when -l is specified; otherwise, it shall
default to first.
If first and last are both omitted, the previous 16 commands shall be listed or the previous single command shall
be edited (based on the -l option).
If first and last are both present, all of the commands from first to last shall be edited (without
-l) or listed (with -l). Editing multiple commands shall be accomplished by presenting to the editor all of the
commands at one time, each command starting on a new line. If first represents a newer command than last, the
commands shall be listed or edited in reverse sequence, equivalent to using -r. For example, the following commands on the
first line are equivalent to the corresponding commands on the second:
fc -r 10 20    fc    30 40
fc    20 10    fc -r 40 30
When a range of commands is used, it shall not be an error to specify first or last values that are not in the
history list; fc shall substitute the value representing the oldest or newest command in the list, as appropriate. For
example, if there are only ten commands in the history list, numbered 1 to 10:
fc -l
fc 1 99
shall list and edit, respectively, all ten commands.
old=new
Replace the first occurrence of string old in the commands to be re-executed by the string new.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of fc:
FCEDIT
This variable, when expanded by the shell, shall determine the default value for the -e editor option's
editor option-argument. If FCEDIT is null or unset, ed shall be used as the
editor.
HISTFILE
Determine a pathname naming a command history file. If the HISTFILE variable is not set, the shell may attempt to access
or create a file .sh_history in the directory referred to by the HOME environment variable. If the shell cannot
obtain both read and write access to, or create, the history file, it shall use an unspecified mechanism that allows the history to
operate properly. (References to history "file" in this section shall be understood to mean this unspecified mechanism in such
cases.) An implementation may choose to access this variable only when initializing the history file; this initialization shall
occur when fc or sh first attempt to retrieve entries from, or add entries to, the
file, as the result of commands issued by the user, the file named by the ENV variable, or implementation-defined system
start-up files. In some historical shells, the history file is initialized just after the ENV file has been processed.
Therefore, it is implementation-defined whether changes made to HISTFILE after the history file has been initialized are
effective. Implementations may choose to disable the history list mechanism for users with appropriate privileges who do not set
HISTFILE ; the specific circumstances under which this occurs are implementation-defined. If more than one instance of the
shell is using the same history file, it is unspecified how updates to the history file from those shells interact. As entries are
deleted from the history file, they shall be deleted oldest first. It is unspecified when history file entries are physically
removed from the history file.
HISTSIZE
Determine a decimal number representing the limit to the number of previous commands that are accessible. If this variable is
unset, an unspecified default greater than or equal to 128 shall be used. The maximum number of commands in the history list is
unspecified, but shall be at least 128. An implementation may choose to access this variable only when initializing the history
file, as described under HISTFILE . Therefore, it is unspecified whether changes made to HISTSIZE after the history
file has been initialized are effective.
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
When the -l option is used to list commands, the format of each command in the list shall be as follows:
"%d\t%s\n", ,
If both the -l and -n options are specified, the format of each command shall be:
"\t%s\n",
If the  consists of more than one line, the lines after the first shall be displayed as:
"\t%s\n",
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion of the listing.
>0
An error occurred.
Otherwise, the exit status shall be that of the commands executed by fc.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
This utility is required to be intrinsic. See 1.7 Intrinsic Utilities
for details.
Since editors sometimes use file descriptors as integral parts of their editing, redirecting their file descriptors as part of
the fc command can produce unexpected results. For example, if vi is the
FCEDIT editor, the command:
fc -s | more
does not work correctly on many systems.
Users on windowing systems may want to have separate history files for each window by setting HISTFILE as follows:
HISTFILE=$HOME/.sh_hist$$
EXAMPLES
None.
RATIONALE
This utility is based on the fc built-in of the KornShell.
An early proposal specified the -e option as [-e editor [old= new ]], which is
not historical practice. Historical practice in fc of either [-e editor] or [-e - [ old=
new ]] is acceptable, but not both together. To clarify this, a new option -s was introduced replacing the
[-e -]. This resolves the conflict and makes fc conform to the Utility Syntax Guidelines.
HISTFILE
Some implementations of the KornShell check for the superuser and do not create a history file unless HISTFILE is set.
This is done primarily to avoid creating unlinked files in the root file system when logging in during single-user mode.
HISTFILE must be set for the superuser to have history.
HISTSIZE
Needed to limit the size of history files. It is the intent of the standard developers that when two shells share the same
history file, commands that are entered in one shell shall be accessible by the other shell. Because of the difficulties of
synchronization over a network, the exact nature of the interaction is unspecified.
The initialization process for the history file can be dependent on the system start-up files, in that they may contain commands
that effectively preempt the settings the user has for HISTFILE and HISTSIZE . For example, function definition
commands are recorded in the history file. If the system administrator includes function definitions in some system start-up file
called before the ENV file, the history file is initialized before the user can influence its characteristics. In some
historical shells, the history file is initialized just after the ENV file has been processed. Because of these situations,
the text requires the initialization process to be implementation-defined.
Consideration was given to omitting the fc utility in favor of the command line editing feature in sh. For example, in vi editing mode, typing
" v" is equivalent to:
EDITOR=vi fc
However, the fc utility allows the user the flexibility to edit multiple commands simultaneously (such as fc 10
20) and to use editors other than those supported by sh for command line editing.
In the KornShell, the alias r ("re-do") is preset to fc -e - (equivalent to the POSIX fc
-s). This is probably an easier command name to remember than fc ("fix command"), but it does not meet the Utility
Syntax Guidelines. Renaming fc to hist or redo was considered, but since this description closely matches
historical KornShell practice already, such a renaming was seen as gratuitous. Users are free to create aliases whenever odd
historical names such as fc, awk, cat,
grep, or yacc are standardized by
POSIX.
Command numbers have no ordering effects; they are like serial numbers. The -r option and -number operand address
the sequence of command execution, regardless of serial numbers. So, for example, if the command number wrapped back to 1 at some
arbitrary point, there would be no ambiguity associated with traversing the wrap point. For example, if the command history
were:
32766: echo 1
32767: echo 2
1: echo 3
the number -2 refers to command 32767 because it is the second previous command, regardless of serial number.
FUTURE DIRECTIONS
None.
SEE ALSO
sh
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 4.
Issue 5
The FUTURE DIRECTIONS section is added.
Issue 6
This utility is marked as part of the User Portability Utilities option.
In the ENVIRONMENT VARIABLES section, the text "user's home directory" is updated to "directory referred to by the
HOME environment variable".
Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
Issue 8
Austin Group Defect 854 is applied, adding a note to the APPLICATION USAGE section that this utility is required to be
intrinsic.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/tr.html =====
tr
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
tr — translate characters
SYNOPSIS
tr [-c|-C] [-s] string1 string2
tr -s [-c|-C] string1
tr -d [-c|-C] string1
tr -ds [-c|-C] string1 string2
DESCRIPTION
The tr utility shall copy the standard input to the standard output with substitution or deletion of selected characters.
The options specified and the string1 and string2 operands shall control translations that occur while copying
characters and single-character collating elements.
OPTIONS
The tr utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-c
Complement the set of values specified by string1. See the EXTENDED DESCRIPTION section.
-C
Complement the set of characters specified by string1. See the EXTENDED DESCRIPTION section.
-d
Delete all occurrences of input characters that are specified by string1.
-s
Replace instances of repeated characters with a single character, as described in the EXTENDED DESCRIPTION section.
OPERANDS
The following operands shall be supported:
string1, string2
Translation control strings. Each string shall represent a set of characters to be converted into an array of characters used for
the translation. For a detailed description of how the strings are interpreted, see the EXTENDED DESCRIPTION section.
STDIN
The standard input can be any type of file.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of tr:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_COLLATE
Determine the locale for the behavior of range expressions and equivalence classes.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments) and the behavior of character classes.
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
The tr output shall be identical to the input, with the exception of the specified transformations.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
The operands string1 and string2 (if specified) define two arrays of characters. The constructs in the following
list can be used to specify characters or single-character collating elements. If any of the constructs result in multi-character
collating elements, tr shall exclude, without a diagnostic, those multi-character elements from the resulting array.
character
Any character not described by one of the conventions below shall represent itself.
\octal
Octal sequences can be used to represent characters with specific coded values. An octal sequence shall consist of a
followed by the longest sequence of one, two, or three-octal-digit characters (01234567). The sequence shall
cause the value whose encoding is represented by the one, two, or three-digit octal integer to be placed into the array. Multi-byte
characters require multiple, concatenated escape sequences of this type, including the leading  for each
byte.
\character
The -escape sequences in XBD Escape Sequences and Associated
Actions ('\\', '\a', '\b', '\f', '\n', '\r', '\t',
'\v') shall be supported. The results of using any other character, other than an octal digit, following the
are unspecified. Also, if there is no character following the , the results are
unspecified.
c-c
In the POSIX locale, this construct shall represent the range of collating elements between the range endpoints (as long as
neither endpoint is an octal sequence of the form \octal), inclusive, as defined by the collation sequence. The characters
or collating elements in the range shall be placed in the array in ascending collation sequence. If the second endpoint precedes
the starting endpoint in the collation sequence, it is unspecified whether the range of collating elements is empty, or this
construct is treated as invalid. In locales other than the POSIX locale, this construct has unspecified behavior.
If either or both of the range endpoints are octal sequences of the form \octal, this shall represent the range of
specific coded values between the two range endpoints, inclusive.
[:class:]
Represents all characters belonging to the defined character class, as defined by the current setting of the LC_CTYPE
locale category. The following character class names shall be accepted when specified in string1:
alnum
blank
digit
lower
punct
upper
alpha
cntrl
graph
print
space
xdigit
[XSI]  In addition, character class expressions of the form [:name:] shall be recognized in those locales where the
name keyword has been given a charclass definition in the LC_CTYPE category.
When both the -d and -s options are specified, any of the character class names shall be accepted in
string2. Otherwise, only character class names lower or upper are valid in string2 and then only if the
corresponding character class (upper and lower, respectively) is specified in the same relative position in
string1. Such a specification shall be interpreted as a request for case conversion. When [:lower:] appears in
string1 and [:upper:] appears in string2, the arrays shall contain the characters from the toupper
mapping in the LC_CTYPE category of the current locale. When [:upper:] appears in string1 and [:lower:]
appears in string2, the arrays shall contain the characters from the tolower mapping in the LC_CTYPE category
of the current locale. The first character from each mapping pair shall be in the array for string1 and the second character
from each mapping pair shall be in the array for string2 in the same relative position.
Except for case conversion, the characters specified by a character class expression shall be placed in the array
in an unspecified order.
If the name specified for class does not define a valid character class in the current locale, the behavior
is undefined.
[=equiv=]
Represents all characters or collating elements belonging to the same equivalence class as equiv, as defined by the
current setting of the LC_COLLATE locale category. An equivalence class expression shall be allowed only in string1,
or in string2 when it is being used by the combined -d and -s options. The characters belonging to the
equivalence class shall be placed in the array in an unspecified order.
[x*n]
Represents n repeated occurrences of the character x. Because this expression is used to map multiple characters
to one, it is only valid when it occurs in string2. If n is omitted or is zero, it shall be interpreted as large
enough to extend the string2-based sequence to the length of the string1-based sequence. If n has a leading
zero, it shall be interpreted as an octal value. Otherwise, it shall be interpreted as a decimal value.
When the -d option is not specified:
If string2 is present, each input character found in the array specified by string1 shall be
replaced by the character in the same relative position in the array specified by string2. If the array specified by
string2 is shorter that the one specified by string1, or if a character occurs more than once in string1, the
results are unspecified.
If the -C option is specified, the complements of the characters specified by string1 (the set of
all characters in the current character set, as defined by the current setting of LC_CTYPE , except for those actually
specified in the string1 operand) shall be placed in the array in ascending collation sequence, as defined by the current
setting of LC_COLLATE .
If the -c option is specified, the complement of the values specified by string1 shall be placed in
the array in ascending order by binary value.
Because the order in which characters specified by character class expressions or equivalence class expressions is
undefined, such expressions should only be used if the intent is to map several characters into one. An exception is case
conversion, as described previously.
When the -d option is specified:
Input characters found in the array specified by string1 shall be deleted.
When the -C option is specified with -d, all characters except those specified by string1
shall be deleted. The contents of string2 are ignored, unless the -s option is also specified.
When the -c option is specified with -d, all values except those specified by string1 shall
be deleted. The contents of string2 shall be ignored, unless the -s option is also specified.
The same string cannot be used for both the -d and the -s option; when both options are specified,
both string1 (used for deletion) and string2 (used for squeezing) shall be required.
When the -s option is specified, after any deletions or translations have taken place, repeated sequences of
the same character shall be replaced by one occurrence of the same character, if the character is found in the array specified by
the last operand. If the last operand contains a character class, such as the following example:
tr -s '[:space:]'
the last operand's array shall contain all of the characters in that character class. However, in a case
conversion, as described previously, such as:
tr -s '[:upper:]' '[:lower:]'
the last operand's array shall contain only those characters defined as the second characters in each of the
toupper or tolower character pairs, as appropriate.
An empty string used for string1 or string2 produces undefined results.
EXIT STATUS
The following exit values shall be returned:
0
All input was processed successfully.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
If necessary, string1 and string2 can be quoted to avoid pattern matching by the shell.
If an ordinary digit (representing itself) is to follow an octal sequence, the octal sequence must use the full
three digits to avoid ambiguity.
When string2 is shorter than string1, a difference results between historical System V and BSD
systems. A BSD system pads string2 with the last character found in string2. Thus, it is possible to do the
following:
tr 0123456789 d
which would translate all digits to the letter 'd'. Since this area is specifically unspecified in this
volume of POSIX.1-2024, both the BSD and System V behaviors are allowed, but a conforming application cannot rely on the BSD
behavior. It would have to code the example in the following way:
tr 0123456789 '[d*]'
It should be noted that, despite similarities in appearance, the string operands used by tr are not regular
expressions.
Unlike some historical implementations, this definition of the tr utility correctly processes NUL characters
in its input stream. NUL characters can be stripped by using:
tr -d '\000'
EXAMPLES
The following example creates a list of all words in file1 one per line in file2, where a word is
taken to be a maximal string of letters.
tr -cs "[:alpha:]" "[\n*]" file2
The next example translates all lowercase characters in file1 to uppercase and writes the results to
standard output.
tr "[:lower:]" "[:upper:]" file2
RATIONALE
In some early proposals, an explicit option -n was added to disable the historical behavior of stripping NUL characters
from the input. It was considered that automatically stripping NUL characters from the input was not correct functionality.
However, the removal of -n in a later proposal does not remove the requirement that tr correctly process NUL
characters in its input stream. NUL characters can be stripped by using tr -d '\000'.
Historical implementations of tr differ widely in syntax and behavior. For example, the BSD version has not
needed the bracket characters for the repetition sequence. The tr utility syntax is based more closely on the System V and
XPG3 model while attempting to accommodate historical BSD implementations. In the case of the short string2 padding, the
decision was to unspecify the behavior and preserve System V and XPG3 scripts, which might find difficulty with the BSD method. The
assumption was made that BSD users of tr have to make accommodations to meet the syntax defined here. Since it is possible
to use the repetition sequence to duplicate the desired behavior, whereas there is no simple way to achieve the System V method,
this was the correct, if not desirable, approach.
The use of octal values to specify control characters, while having historical precedents, is not portable. The
introduction of escape sequences for control characters should provide the necessary portability. It is recognized that this may
cause some historical scripts to break.
An early proposal included support for multi-character collating elements. It was pointed out that, while tr
does employ some syntactical elements from REs, the aim of tr is quite different; ranges, for example, do not have a similar
meaning ("any of the chars in the range matches", versus "translate each character in the range to the output
counterpart"). As a result, the previously included support for multi-character collating elements has been removed. What remains
are ranges in current collation order (to support, for example, accented characters), character classes, and equivalence
classes.
In XPG3 the [:class:] and [=equiv=] conventions are shown with double brackets, as in RE syntax.
However, tr does not implement RE principles; it just borrows part of the syntax. Consequently, [:class:] and
[=equiv=] should be regarded as syntactical elements on a par with [x*n], which is not an RE bracket
expression.
The standard developers will consider changes to tr that allow it to translate characters between different
character encodings, or they will consider providing a new utility to accomplish this.
On historical System V systems, a range expression requires enclosing square-brackets, such as:
tr '[a-z]' '[A-Z]'
However, BSD-based systems did not require the brackets, and this convention is used here to avoid breaking large
numbers of BSD scripts:
tr a-z A-Z
The preceding System V script will continue to work because the brackets, treated as regular characters, are
translated to themselves. However, any System V script that relied on "a-z" representing the three characters
'a', '-', and 'z' have to be rewritten as "az-".
The ISO POSIX-2:1993 standard had a -c option that behaved similarly to the -C option, but did
not supply functionality equivalent to the -c option specified in POSIX.1-2024.
The earlier version also said that octal sequences referred to collating elements and could be placed adjacent to
each other to specify multi-byte characters. However, it was noted that this caused ambiguities because tr would not be able
to tell whether adjacent octal sequences were intending to specify multi-byte characters or multiple single byte characters.
POSIX.1-2024 specifies that octal sequences always refer to single byte binary values when used to specify an endpoint of a range
of collating elements.
Earlier versions of this standard allowed for implementations with bytes other than eight bits, but this has been
modified in this version.
FUTURE DIRECTIONS
None.
SEE ALSO
sed
XBD Escape Sequences and Associated Actions, 8. Environment Variables, 12.2
Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 2.
Issue 6
The -C operand is added, and the description of the -c operand is changed to align with the IEEE P1003.2b
draft standard.
The normative text is reworded to avoid use of the term "must" for application requirements.
IEEE Std 1003.1-2001/Cor 2-2004, item XCU/TC2/D6/31 is applied, removing text describing behavior on
systems with bytes consisting of more than eight bits.
IEEE Std 1003.1-2001/Cor 2-2004, item XCU/TC2/D6/32 is applied, updating an example in the EXAMPLES
section to avoid using unspecified behavior.
IEEE Std 1003.1-2001/Cor 2-2004, item XCU/TC2/D6/33 is applied, making a correction to the
RATIONALE.
Issue 7
SD5-XCU-ERN-30 is applied.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
Austin Group Interpretation 1003.1-2001 #132 is applied, adding rationale to the \character construct.
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0145 [325] is applied.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0196 [663] is applied.
Issue 8
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/umask.html =====
umask
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
umask — get or set the file mode creation mask
SYNOPSIS
umask [-S] [mask]
DESCRIPTION
The umask utility shall set the file mode creation mask of the current shell execution environment (see 2.13 Shell Execution Environment) to the value specified by the mask
operand. This mask shall affect the initial value of the file permission bits of subsequently created files. If umask is
called in a subshell or separate utility execution environment, such as one of the following:
(umask 002)
nohup umask ...
find . -exec umask ... \;
it shall not affect the file mode creation mask of the caller's environment.
If the mask operand is not specified, the umask utility shall write to standard output the value of the file mode
creation mask of the invoking process.
OPTIONS
The umask utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following option shall be supported:
-S
Produce symbolic output.
The default output style is unspecified, but shall be recognized on a subsequent invocation of umask on the same system
as a mask operand to restore the previous file mode creation mask.
OPERANDS
The following operand shall be supported:
mask
A string specifying the new file mode creation mask. The string is treated in the same way as the mode operand described
in the EXTENDED DESCRIPTION section for chmod.
For a symbolic_mode value, the new value of the file mode creation mask shall be the logical complement of the file
permission bits portion of the file mode specified by the symbolic_mode string.
In a symbolic_mode value, the permissions op characters '+' and '-' shall be interpreted
relative to the current file mode creation mask; '+' shall cause the bits for the indicated permissions to be cleared in
the mask; '-' shall cause the bits for the indicated permissions to be set in the mask.
The interpretation of mode values that specify file mode bits other than the file permission bits is unspecified.
In the octal integer form of mode, the specified bits are set in the file mode creation mask.
The file mode creation mask shall be set to the resulting numeric value.
The default output of a prior invocation of umask on the same system with no operand also shall be recognized as a
mask operand.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of umask:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
When the mask operand is not specified, the umask utility shall write a message to standard output that can later
be used as a umask mask operand.
If -S is specified, the message shall be in the following format:
"u=%s,g=%s,o=%s\n", , ,
where the three values shall be combinations of letters from the set {r, w, x}; the presence of a letter
shall indicate that the corresponding bit is clear in the file mode creation mask.
If a mask operand is specified, there shall be no output written to standard output.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
The file mode creation mask was successfully changed, or no mask operand was supplied.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
This utility is required to be intrinsic. See 1.7 Intrinsic Utilities
for details.
Since umask affects the current shell execution environment, it is generally provided as a shell regular built-in.
In contrast to the negative permission logic provided by the file mode creation mask and the octal number form of the
mask argument, the symbolic form of the mask argument specifies those permissions that are left alone.
EXAMPLES
Either of the commands:
umask a=rx,ug+w
umask 002
sets the mode mask so that subsequently created files have their S_IWOTH bit cleared.
After setting the mode mask with either of the above commands, the umask command can be used to write out the current
value of the mode mask:
$ umask
0002
(The output format is unspecified, but historical implementations use the octal integer mode format.)
$ umask -S
u=rwx,g=rwx,o=rx
Either of these outputs can be used as the mask operand to a subsequent invocation of the umask utility.
Assuming the mode mask is set as above, the command:
umask g-w
sets the mode mask so that subsequently created files have their S_IWGRP and S_IWOTH bits cleared.
The command:
umask -- -w
sets the mode mask so that subsequently created files have all their write bits cleared. Note that mask operands
-r, -w, -x or anything beginning with a , must be preceded by "--" to keep it
from being interpreted as an option.
RATIONALE
Since umask affects the current shell execution environment, it is generally provided as a shell regular built-in. If it
is called in a subshell or separate utility execution environment, such as one of the following:
(umask 002)
nohup umask ...
find . -exec umask ... \;
it does not affect the file mode creation mask of the environment of the caller.
The description of the historical utility was modified to allow it to use the symbolic modes of chmod. The -s option used in early proposals was changed to -S because -s
could be confused with a symbolic_mode form of mask referring to the S_ISUID and S_ISGID bits.
The default output style is unspecified to permit implementors to provide migration to the new symbolic style at the time most
appropriate to their users. A -o flag to force octal mode output was omitted because the octal mode may not be sufficient to
specify all of the information that may be present in the file mode creation mask when more secure file access permission checks
are implemented.
It has been suggested that trusted systems developers might appreciate ameliorating the requirement that the mode mask
"affects" the file access permissions, since it seems access control lists might replace the mode mask to some degree. The
wording has been changed to say that it affects the file permission bits, and it leaves the details of the behavior of how they
affect the file access permissions to the description in the System Interfaces volume of POSIX.1-2024.
FUTURE DIRECTIONS
None.
SEE ALSO
2. Shell Command Language, chmod
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
XSH umask()
CHANGE HISTORY
First released in Issue 2.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The octal mode is supported.
IEEE Std 1003.1-2001/Cor 2-2004, item XCU/TC2/D6/34 is applied, making a correction to the RATIONALE.
Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0197 [584] is applied.
Issue 8
Austin Group Defect 854 is applied, adding a note to the APPLICATION USAGE section that this utility is required to be
intrinsic.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/readonly.html =====
Shell Command Language
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
Please enable javascript in your browser to automatically redirect to the target page, otherwise select the link below.
2.15 Special Built-In Utilities
break
colon
continue
dot
eval
exec
exit
export
readonly
return
set
shift
times
trap
unset
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
===== susv5-html/utilities/wait.html =====
wait
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wait — await process completion
SYNOPSIS
wait [pid...]
DESCRIPTION
The wait utility shall wait for one or more child processes whose process IDs are known in the current shell execution
environment (see 2.13 Shell Execution Environment) to terminate.
If the wait utility is invoked with no operands, it shall wait until all process IDs known to the invoking shell have
terminated and exit with a zero exit status.
If one or more pid operands are specified that represent known process IDs, the wait utility shall wait until all
of them have terminated. If one or more pid operands are specified that represent unknown process IDs, wait shall
treat them as if they were known process IDs that exited with exit status 127. The exit status returned by the wait utility
shall be the exit status of the process requested by the last pid operand.
Once a process ID that is known in the current shell execution environment (see 2.13 Shell Execution Environment) has been successfully waited for, it shall be
removed from the list of process IDs that are known in the current shell execution environment. If the process ID is associated
with a background job, the corresponding job shall also be removed from the list of background jobs.
OPTIONS
None.
OPERANDS
The following operand shall be supported:
pid
One of the following:
The unsigned decimal integer process ID of a child process whose termination the utility is to wait for.
A job ID (see XBD 3.182 Job ID) that identifies a process group in
the case of a job-control background job, or a process ID in the case of a non-job-control background job (if supported), to be
waited for. The job ID notation is applicable only for invocations of wait in the current shell execution environment; see
2.13 Shell Execution Environment. The exit status of wait shall
be determined by the exit status of the last pipeline to be executed.
Note:
The job ID type of pid is only available on systems supporting the User Portability Utilities option or supporting
non-job-control background jobs.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of wait:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
Not used.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
If one or more operands were specified, all of them have terminated or were not known in the invoking shell execution
environment, and the status of the last operand specified is known, then the exit status of wait shall be the status of the
last operand specified. If the process terminated abnormally due to the receipt of a signal, the exit status shall be greater than
128 and shall be distinct from the exit status generated by other signals, but the exact value is unspecified. (See the kill -l option.) Otherwise, the wait utility shall exit with one of the following
values:
0
The wait utility was invoked with no operands and all process IDs known by the invoking shell have terminated.
1-126
The wait utility detected an error.
127
The process ID specified by the last pid operand specified is not known in the invoking shell execution
environment.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
This utility is required to be intrinsic. See 1.7 Intrinsic Utilities
for details.
On most implementations, wait is a shell built-in. If it is called in a subshell or separate utility execution
environment, such as one of the following:
(wait)
nohup wait ...
find . -exec wait ... \;
it returns immediately because there are no known process IDs to wait for in those environments.
The use of job ID notation is not dependent on job control being enabled. When job control has been disabled using set +m, wait can still be used to wait for the process group associated with a
job-control background job, or the process ID associated with a non-control background job (if supported), using
wait %
See also the RATIONALE for jobs and kill.
The shell is allowed to discard the status of any process if it determines that the application cannot get the process ID for
that process from the shell. It is also required to remember only {CHILD_MAX} number of processes in this way. Since the only way
to get the process ID from the shell is by using the '!' shell parameter, the shell is allowed to discard the status of an
asynchronous AND-OR list if "$!" was not referenced before another asynchronous AND-OR list was started. (This means that
the shell only has to keep the status of the last asynchronous AND-OR list started if the application did not reference
"$!". If the implementation of the shell is smart enough to determine that a reference to "$!" was not saved
anywhere that the application can retrieve it later, it can use this information to trim the list of saved information. Note also
that a successful call to wait with no operands discards the exit status of all asynchronous AND-OR lists.)
If the exit status of wait is greater than 128, there is no way for the application to know if the waited-for process
exited with that value or was killed by a signal. Since most utilities exit with small values, there is seldom any ambiguity. Even
in the ambiguous cases, most applications just need to know that the asynchronous job failed; it does not matter whether it
detected an error and failed or was killed and did not complete its job normally.
Some historical shells returned from wait when a process stops instead of only when it terminates. This standard does not allow
wait to return when a process stops for two reasons:
The vast majority, if not all, shell scripts that use wait (without using an extension) expect it not to return until the
process terminates.
It is not possible to write a portable shell script that can correctly handle wait returning when a process stops,
because an exit status indicating a process was stopped by a signal cannot be distinguished from one indicating that the process
called exit() with the same value.
The standard developers considered allowing interactive shells to return from wait when a process stops, since the
interactive user would see a message which would allow them to tell whether the process stopped or terminated. However, they
decided that it would be inadvisable to introduce an inconsistency between interactive and non-interactive shells, particularly as
the most likely use of wait in an interactive shell is to try out commands before putting them in a shell script.
Implementations can provide an extension that could be used to request that wait returns when a process stops. It is
recommended that any such extension uses a different method of returning information about the wait status of the process so that
the information can be unambiguous. One suitable method would be an option that takes a variable name as an option-argument. The
named variable would be set to a numeric value and the exit status of wait would indicate whether this value is an exit value or a
signal number, and whether the signal terminated the process or stopped it. Such an extension would also provide a way for shell
scripts to obtain the full exit value (as would be returned by waitid()).
EXAMPLES
Although the exact value used when a process is terminated by a signal is unspecified, if it is known that a signal terminated a
process, a script can still reliably determine which signal by using kill as shown by
the following script:
sleep 1000&
pid=$!
kill -kill $pid
wait $pid
echo $pid was terminated by a SIG$(kill -l $?) signal.
If the following sequence of commands is run in less than 31 seconds:
sleep 257 | sleep 31 &
jobs -l %%
either of the following commands returns the exit status of the second sleep in the
pipeline:
wait
wait %%
RATIONALE
The description of wait does not refer to the waitpid() function from the
System Interfaces volume of POSIX.1-2024 because that would needlessly overspecify this interface. However, the wording means that
wait is required to wait for an explicit process when it is given an argument so that the status information of other
processes is not consumed. Historical implementations use the wait() function defined
in the System Interfaces volume of POSIX.1-2024 until wait() returns the requested
process ID or finds that the requested process does not exist. Because this means that a shell script could not reliably get the
status of all background children if a second background job was ever started before the first job finished, it is recommended that
the wait utility use a method such as the functionality provided by the waitpid() function.
The ability to wait for multiple pid operands was adopted from the KornShell.
This new functionality was added because it is needed to determine the exit status of any asynchronous AND-OR list accurately.
The only compatibility problem that this change creates is for a script like
while sleep 60 do
job& echo Job started $(date) as $!  done
which causes the shell to monitor all of the jobs started until the script terminates or runs out of memory. This would not be a
problem if the loop did not reference "$!" or if the script would occasionally wait for jobs it started.
FUTURE DIRECTIONS
A future version of this standard may add an option which takes a variable name as an option-argument, allowing wait to
return information about the wait status of a process in an unambiguous way.
SEE ALSO
2. Shell Command Language, kill, sh
XBD 3.182 Job ID, 8.
Environment Variables
XSH wait()
CHANGE HISTORY
First released in Issue 2.
Issue 8
Austin Group Defect 854 is applied, adding a note to the APPLICATION USAGE section that this utility is required to be
intrinsic.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1254 is applied, updating various requirements for the jobs
utility to account for the addition of 2.11 Job Control.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/V3_chap03.html =====
Utilities
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
3. Utilities
This chapter contains the definitions of the utilities, as follows:
Mandatory utilities that are present on every conformant system
Optional utilities that are present only on systems supporting the associated option; see 1.8.1 Codes for information on the options in this volume of POSIX.1-2024
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/mindex.html =====
The Base Specifications Issue 8
The Open Group Base Specifications Issue 8
IEEE Std 1003.1™-2024 Edition
Copyright©  2001-2024 The IEEE and The Open Group
POSIX.1-2024 is simultaneously IEEE Std 1003.1™-2024 and The Open Group Standard Base Specifications,
Issue 8.
POSIX.1-2024 defines a standard operating
system interface and environment, including a command interpreter (or "shell"), and common utility programs to support
applications portability at the source code level. POSIX.1-2024 is intended to be used by both application developers and system
implementors and comprises four major components (each in an associated volume):
General terms, concepts, and interfaces common to all
volumes of this standard, including utility conventions and C-language header definitions, are included in the Base Definitions
volume.
Definitions for system service functions and
subroutines, language-specific system services for the C programming language, function issues, including portability, error
handling, and error recovery, are included in the System Interfaces volume.
Definitions for a standard source code-level
interface to command interpretation services (a "shell") and common utility programs for application programs are included in
the Shell and Utilities volume.
Extended rationale that did not fit well into the
rest of the document structure, which contains historical information concerning the contents of POSIX.1-2024 and why features were
included or discarded by the standard developers, is included in the Rationale (Informative) volume.
The following areas are outside the scope of
POSIX.1-2024:
Graphics interfaces
Database management system interfaces
Record I/O considerations
Object or binary code portability
System configuration and resource
availability
POSIX.1-2024 describes the external
characteristics and facilities that are of importance to application developers, rather than the internal construction techniques
employed to achieve these capabilities. Special emphasis is placed on those functions and facilities that are needed in a wide
variety of commercial applications.
Keywords
application program interface (API), argument, asynchronous, basic regular expression (BRE), batch job, batch system, built-in
utility, byte, child, command language interpreter, CPU, extended regular expression (ERE), FIFO, file access control mechanism,
input/output (I/O), job control, network, portable operating system interface (POSIX™), parent, shell, stream, string,
synchronous, system, thread, X/Open System Interface (XSI)
Frontmatter (Informative)
[ Preface | Typographical Conventions |
Notice to Users | Participants | Trademarks | Acknowledgements | Referenced Documents ]
Tables of Contents by volume: [ XBD | XSH | XCU | XRAT ]
Links: [ Alphabetic Index | Topical Index | About the HTML version | Downloads | Report a defect ]
Links: [2008 |
2013 |
2016 |
2018 ]
Spec_version: Tue Mar 25 14:45:38 UTC 2025
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
===== susv5-html/webindex.html =====
The Base Specifications Issue 8
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
[Frames Index]
Select a letter to display all entries in the Index which begin with that letter.
[ A | B | C | D |
E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z | Index ]
The Keyword Search performed is equivalent to man -k and matches a string in the
database.
Or perform a Word Search of the Specification
Base
Definitions and Headers
System
Interfaces
Shell &
Utilities
Rationale
Fri Dec 5 11:39:27 GMT 2008
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
===== susv5-html/functions/dbm_delete.html =====
dbm_clearerr
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
dbm_clearerr, dbm_close, dbm_delete, dbm_error, dbm_fetch, dbm_firstkey, dbm_nextkey, dbm_open, dbm_store — database
functions
SYNOPSIS
[XSI]  #include
int dbm_clearerr(DBM *db);
void dbm_close(DBM *db);
int dbm_delete(DBM *db, datum key);
int dbm_error(DBM *db);
datum dbm_fetch(DBM *db, datum key);
datum dbm_firstkey(DBM *db);
datum dbm_nextkey(DBM *db);
DBM *dbm_open(const char *file, int open_flags, mode_t file_mode);
int dbm_store(DBM *db, datum key, datum content, int
store_mode);
DESCRIPTION
These functions create, access, and modify a database.
A datum consists of at least two members, dptr and dsize. The dptr member points to an object that
is dsize bytes in length. Arbitrary binary data, as well as character strings, may be stored in the object pointed to by
dptr.
A database shall be stored in one or two files. When one file is used, the name of the database file shall be formed by
appending the suffix .db to the file argument given to dbm_open(). When two files are used, the names of the
database files shall be formed by appending the suffixes .dir and .pag respectively to the file argument.
The dbm_open() function shall open a database. The file argument to the function is the pathname of the database.
Values for the open_flags argument are constructed by a bitwise-inclusive OR of flags from the following list, defined in
. Applications shall specify exactly one of the first three values
(file access modes) below in the value of open_flags:
O_RDONLY
Open the database, and the underlying file(s) used to store the database, for reading only.
O_RDWR
Open the database, and the underlying file(s) used to store the database, for reading and writing.
O_WRONLY
Open the database for writing only. The underlying file(s) used to store the database shall be opened for reading and
writing.
Any combination of the following can be used:
O_CLOEXEC
If set, the FD_CLOEXEC flag for the new file descriptor(s) used to open the underlying file(s) shall be set.
O_CREAT
If the database exists, this flag has no effect except as noted under O_EXCL below. Otherwise, the database shall be created;
the user ID of the underlying file(s) shall be set to the effective user ID of the process; the group ID of the underlying file(s)
shall be set to the group ID of the file's parent directory or to the effective group ID of the process. Implementations shall
provide a way to initialize the group ID to the group ID of the parent directory. Implementations may, but need not, provide an
implementation-defined way to initialize the group ID to the effective group ID of the calling process.
O_DSYNC
[SIO]
Write I/O operations on the file(s) used to store the database shall complete as defined by synchronized I/O data integrity
completion.
O_EXCL
If O_CREAT and O_EXCL are set, dbm_open() shall fail if the database exists according to the following criteria. If the
database is stored in a file with a .db suffix, a check for the existence of the file and the creation of the file if it
does not exist shall be performed as a single atomic operation. If the database is stored in files with .pag and .dir
suffixes, this atomic existence check and creation operation shall be performed for each file, but it is unspecified which file is
first. If the first file is successfully created and the second file is found to exist, the first file should be removed before
dbm_open() returns.
If O_EXCL is set and O_CREAT is not set, the result is undefined.
O_RSYNC
[SIO]
Read I/O operations on the file(s) used to store the database shall complete at the same level of integrity as specified by the
O_DSYNC and O_SYNC flags. If both O_DSYNC and O_RSYNC are set in oflag, all I/O operations on the file(s) shall complete as defined
by synchronized I/O data integrity completion. If both O_SYNC and O_RSYNC are set in flags, all I/O operations on the file(s) shall
complete as defined by synchronized I/O file integrity completion.
O_SYNC
Write I/O operations on the file(s) used to store the database shall complete as defined by synchronized I/O file integrity
completion.
O_TRUNC
If the database exists and is successfully opened O_RDWR or O_WRONLY, it shall be emptied, and the mode and owner of the
underlying file(s) shall be unchanged. The result of using O_TRUNC without either O_RDWR or O_WRONLY is undefined.
The behaviour of other flags described for the flags argument of open() is
unspecified.
The file_mode argument has the same meaning as the third argument of open()
and shall apply to the underlying file(s) used to store the database.
The dbm_open() function need not accept pathnames longer than {PATH_MAX}-4 bytes (including the terminating null), or
pathnames with a last component longer than {NAME_MAX}-4 bytes (excluding the terminating null).
The dbm_close() function shall close a database. The application shall ensure that argument db is a pointer to a
dbm structure that has been returned from a call to dbm_open().
These database functions shall support an internal block size large enough to support key/content pairs of at least 1023
bytes.
The dbm_fetch() function shall read a record from a database. The argument db is a pointer to a database structure
that has been returned from a call to dbm_open(). The argument key is a datum that has been initialized by the
application to the value of the key that matches the key of the record the program is fetching.
The dbm_store() function shall write a record to a database. The argument db is a pointer to a database structure
that has been returned from a call to dbm_open(). The argument key is a datum that has been initialized by the
application to the value of the key that identifies (for subsequent reading, writing, or deleting) the record the application is
writing. The argument content is a datum that has been initialized by the application to the value of the record the
program is writing. The argument store_mode controls whether dbm_store() replaces any pre-existing record that has
the same key that is specified by the key argument. The application shall set store_mode to either DBM_INSERT or
DBM_REPLACE. If the database contains a record that matches the key argument and store_mode is DBM_REPLACE, the
existing record shall be replaced with the new record. If the database contains a record that matches the key argument and
store_mode is DBM_INSERT, the existing record shall be left unchanged and the new record ignored. If the database does not
contain a record that matches the key argument and store_mode is either DBM_INSERT or DBM_REPLACE, the new record
shall be inserted in the database.
If the sum of a key/content pair exceeds the internal block size, the result is unspecified. Moreover, the application shall
ensure that all key/content pairs that hash together fit on a single block. The dbm_store() function shall return an error
in the event that a disk block fills with inseparable data.
The dbm_delete() function shall delete a record and its key from the database. The argument db is a pointer to a
database structure that has been returned from a call to dbm_open(). The argument key is a datum that has been
initialized by the application to the value of the key that identifies the record the program is deleting.
The dbm_firstkey() function shall return the first key in the database. The argument db is a pointer to a database
structure that has been returned from a call to dbm_open().
The dbm_nextkey() function shall return the next key in the database. The argument db is a pointer to a database
structure that has been returned from a call to dbm_open(). The application shall ensure that the dbm_firstkey()
function is called before calling dbm_nextkey(). Subsequent calls to dbm_nextkey() return the next key until all of
the keys in the database have been returned.
The dbm_error() function shall return the error condition of the database. The argument db is a pointer to a
database structure that has been returned from a call to dbm_open().
The dbm_clearerr() function shall clear the error condition of the database. The argument db is a pointer to a
database structure that has been returned from a call to dbm_open().
The dptr pointers returned by these functions may point into static storage that may be changed by subsequent calls.
These functions need not be thread-safe.
RETURN VALUE
The dbm_store() and dbm_delete() functions shall return 0 when they succeed and a negative value when they
fail.
The dbm_store() function shall return 1 if it is called with a flags value of DBM_INSERT and the function finds an
existing record with the same key.
The dbm_error() function shall return 0 if the error condition is not set and return a non-zero value if the error
condition is set.
The return value of dbm_clearerr() is unspecified.
The dbm_firstkey() and dbm_nextkey() functions shall return a key datum. When the end of the database is
reached, the dptr member of the key is a null pointer. If an error is detected, the dptr member of the key shall be a
null pointer and the error condition of the database shall be set.
The dbm_fetch() function shall return a content datum. If no record in the database matches the key or if an error
condition has been detected in the database, the dptr member of the content shall be a null pointer.
The dbm_open() function shall return a pointer to a database structure. If an error is detected during the operation,
dbm_open() shall return a (DBM *)0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The following code can be used to traverse the database:
for(key = dbm_firstkey(db); key.dptr != NULL; key = dbm_nextkey(db))
The dbm_* functions provided in this library should not be confused in any way with those of a general-purpose database
management system. These functions do not provide for multiple search keys per entry, they do not protect against multi-user access
(in other words they do not lock records or files), and they do not provide the many other useful database functions that are found
in more robust database management systems. Creating and updating databases by use of these functions is relatively slow because of
data copies that occur upon hash collisions. These functions are useful for applications requiring fast lookup of relatively static
information that is to be indexed by a single key.
Note that a strictly conforming application is extremely limited by these functions: since there is no way to determine that the
keys in use do not all hash to the same value (although that would be rare), a strictly conforming application cannot be guaranteed
that it can store more than one block's worth of data in the database. As long as a key collision does not occur, additional data
may be stored, but because there is no way to determine whether an error is due to a key collision or some other error condition
(dbm_error() being effectively a Boolean), once an error is detected, the
application is effectively limited to guessing what the error might be if it wishes to continue using these functions.
The dbm_delete() function need not physically reclaim file space, although it does make it available for reuse by the
database.
After calling dbm_store() or dbm_delete() during a pass through the keys by dbm_firstkey() and
dbm_nextkey(), the application should reset the database by calling dbm_firstkey() before again calling
dbm_nextkey(). The contents of these files are unspecified and may not be portable.
Applications should take care that database pathname arguments specified to dbm_open() are not prefixes of unrelated
files. This might be done, for example, by placing databases in a separate directory.
Since some implementations use three characters for a suffix and others use four characters for a suffix, applications should
ensure that the maximum portable pathname length passed to dbm_open() is no greater than {PATH_MAX}-4 bytes, with the last
component of the pathname no greater than {NAME_MAX}-4 bytes.
RATIONALE
and having .dir as its suffix. The second file containing all data and having .pag as its suffix. This has been
changed not to specify the use of the files and to allow newer implementations of the Berkeley DB interface using a single file
that have evolved while remaining compatible with the application programming interface. The standard developers considered
removing the specific suffixes altogether but decided to retain them so as not to pollute the application file name space more than
necessary and to allow for portable backups of the database.
FUTURE DIRECTIONS
A future revision of this standard may mandate the file removal that is currently recommended (by the use of "should") in the
description of O_EXCL.
SEE ALSO
open()
XBD ,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Normative text previously in the APPLICATION USAGE section is moved to the DESCRIPTION.
A note indicating that these functions need not be reentrant is added to the DESCRIPTION.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
Austin Group Interpretation 1003.1-2001 #042 is applied so that the DESCRIPTION permits newer implementations of the Berkeley DB
interface.
Austin Group Interpretation 1003.1-2001 #156 is applied.
Issue 8
Austin Group Defect 1057 is applied, clarifying how the O_ flags defined for use with open() apply to dbm_open().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/acosl.html =====
acos
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
acos, acosf, acosl — arc cosine functions
SYNOPSIS
#include
double acos(double x);
float acosf(float x);
long double acosl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the principal value of the arc cosine of their argument x. The value of x should be
in the range [-1,1].
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the arc cosine of x, in the range [0,ℼ] radians.
For finite values of x not in the range [-1,1], a domain error shall occur, and [MX]   either a NaN
(if supported), or   an implementation-defined value shall be
returned.
[MX]  If
x is NaN, a NaN shall be returned.
If x is +1, +0 shall be returned.
If x is ±Inf, a domain error shall occur, and a NaN shall be returned.
ERRORS
These functions shall fail if:
Domain Error
The x argument is finite and is not in the range [-1,1], [MX]
or is ±Inf.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
cos(), feclearexcept(),
fetestexcept(), isnan()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The acosf() and acosl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0024 [320] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sched_rr_get_interval.html =====
sched_rr_get_interval
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sched_rr_get_interval — get execution time limits (REALTIME)
SYNOPSIS
[PS|TPS]  #include
int sched_rr_get_interval(pid_t pid, struct timespec *interval);
DESCRIPTION
The sched_rr_get_interval() function shall update the timespec structure referenced by the interval
argument to contain the current execution time limit (that is, time quantum) for the process specified by pid. If pid
is zero, the current execution time limit for the calling process shall be returned.
RETURN VALUE
If successful, the sched_rr_get_interval() function shall return zero. Otherwise, it shall return a value of -1 and set
errno to indicate the error.
ERRORS
The sched_rr_get_interval() function shall fail if:
[ESRCH]
No process can be found corresponding to that specified by pid.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
sched_getparam(), sched_get_priority_max(), sched_getscheduler(), sched_setparam(), sched_setscheduler()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The sched_rr_get_interval() function is marked as part of the Process Scheduling option.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Process
Scheduling option.
IEEE Std 1003.1-2001/Cor 1-2002, XSH/TC1/D6/53 is applied, changing the PS margin code in the SYNOPSIS to
PS|TPS.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/nanf.html =====
nan
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
nan, nanf, nanl — return quiet NaN
SYNOPSIS
#include
double nan(const char *tagp);
float nanf(const char *tagp);
long double nanl(const char *tagp);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The function call nan("n-char-sequence") shall be equivalent to:
strtod("NAN(n-char-sequence)", (char **) NULL);
The function call nan("") shall be equivalent to:
strtod("NAN()", (char **) NULL)
If tagp does not point to an n-char sequence or an empty string, the function call shall be equivalent
to:
strtod("NAN", (char **) NULL)
Function calls to nanf() and nanl() are equivalent to the corresponding function calls to strtof() and strtold().
RETURN VALUE
These functions shall return a quiet NaN, if available, with content indicated through tagp.
[MX]  The
returned value shall be exact and shall be independent of the current rounding direction mode.
If the implementation does not support quiet NaNs, these functions shall return zero.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
strtod()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fileno.html =====
fileno
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fileno — map a stream pointer to a file descriptor
SYNOPSIS
[CX]  #include
int fileno(FILE *stream);
DESCRIPTION
The fileno() function shall return the integer file descriptor associated with the stream pointed to by
stream.
RETURN VALUE
Upon successful completion, fileno() shall return the integer value of the file descriptor associated with stream.
Otherwise, the value -1 shall be returned and errno set to indicate the error.
ERRORS
The fileno() function shall fail if:
[EBADF]
The stream is not associated with a file.
The fileno() function may fail if:
[EBADF]
The file descriptor underlying stream is not a valid file descriptor.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
Without some specification of which file descriptors are associated with these streams, it is impossible for an application to
set up the streams for another application it starts with fork() and exec. In particular, it would not be possible to write a portable version of the sh command interpreter (although there may be other constraints that would prevent that
portability).
FUTURE DIRECTIONS
None.
SEE ALSO
2.5.1 Interaction of File Descriptors and Standard I/O Streams,
dirfd(), fdopen(), fopen(), stdin
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The [EBADF] optional error condition is added.
Issue 7
SD5-XBD-ERN-99 is applied, changing the definition of the [EBADF] error.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0115 [589] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fetestexcept.html =====
fetestexcept
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fetestexcept — test floating-point exception flags
SYNOPSIS
#include
int fetestexcept(int excepts);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The fetestexcept() function shall determine which of a specified subset of the floating-point exception flags are
currently set. The excepts argument specifies the floating-point status flags to be queried.
RETURN VALUE
The fetestexcept() function shall return the value of the bitwise-inclusive OR of the floating-point exception macros
corresponding to the currently set floating-point exceptions included in excepts.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
The following example calls function f() if an invalid exception is set, and then function g() if an overflow
exception is set:
#include
/* ... */
{
#pragma STDC FENV_ACCESS ON
int set_excepts;
feclearexcept(FE_INVALID | FE_OVERFLOW);
// maybe raise exceptions
set_excepts = fetestexcept(FE_INVALID | FE_OVERFLOW);
if (set_excepts & FE_INVALID) f();
if (set_excepts & FE_OVERFLOW) g();
/* ... */
}
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fegetexceptflag(), feraiseexcept()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fpclassify.html =====
fpclassify
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fpclassify — classify real floating type
SYNOPSIS
#include
int fpclassify(real-floating x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The fpclassify() macro shall classify its argument value as NaN, infinite, normal, subnormal, zero, or into another
implementation-defined category. First, an argument represented in a format wider than its semantic type is converted to its
semantic type. Then classification is based on the type of the argument.
RETURN VALUE
The fpclassify() macro shall return the value of the number classification macro appropriate to the value of its
argument.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
isfinite(), isinf(), isnan(), isnormal(), signbit()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fdopen.html =====
fdopen
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fdopen — associate a stream with a file descriptor
SYNOPSIS
[CX]  #include
FILE *fdopen(int fildes, const char *mode);
DESCRIPTION
The fdopen() function shall associate a stream with a file descriptor.
The mode argument points to a character string that is valid for fopen(). If
the string begins with one of the following characters, then the stream shall be associated with fildes as specified.
Otherwise, the behavior is undefined.
'r'
If mode includes '+', the associated stream shall be open for update (reading and writing); otherwise, the
stream shall be open for reading only. If the open file description referenced by fildes has O_APPEND set, it shall remain
set.
'w'
If mode includes '+', the associated stream shall be open for update (reading and writing); otherwise, the
stream shall be open for writing only. The file shall not be truncated by the fdopen() call. If the open file description
referenced by fildes has O_APPEND set, it shall remain set.
'a'
If mode includes '+', the associated stream shall be open for update (reading and writing); otherwise, the
stream shall be open for writing only. If the open file description referenced by fildes has O_APPEND clear, it is
unspecified whether O_APPEND is set by the fdopen() call or remains clear.
The presence of 'x' in mode shall have no effect. The FD_CLOEXEC flag of fildes shall be unchanged if
'e' is not present, and shall be set by the fdopen() call if 'e' is present.
Additional values for the mode argument may be supported by an implementation.
The application shall ensure that the mode of the stream as expressed by the mode argument is allowed by the file access
mode of the open file description to which fildes refers. The file position indicator associated with the new stream is set
to the position indicated by the file offset associated with the file descriptor.
The error and end-of-file indicators for the stream shall be cleared. The fdopen() function may cause the last data
access timestamp of the underlying file to be marked for update.
[SHM]
If fildes refers to a shared memory object, the result of the fdopen() function is unspecified.
[TYM]
If fildes refers to a typed memory object, the result of the fdopen() function is unspecified.
The fdopen() function shall preserve the offset maximum previously set for the open file description corresponding to
fildes.
RETURN VALUE
Upon successful completion, fdopen() shall return a pointer to a stream; otherwise, a null pointer shall be returned and
errno set to indicate the error.
ERRORS
The fdopen() function shall fail if:
[EMFILE]
{STREAM_MAX} streams are currently open in the calling process.
The fdopen() function may fail if:
[EBADF]
The fildes argument is not a valid file descriptor.
[EINVAL]
The mode argument is not a valid mode.
[EMFILE]
{FOPEN_MAX} streams are currently open in the calling process.
[ENOMEM]
Insufficient space to allocate a buffer.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
File descriptors are obtained from calls like open(), dup(), creat(), or pipe(), which open files but do not return streams.
RATIONALE
The file descriptor may have been obtained from open(), creat(), pipe(), dup(), fcntl(), or socket(); inherited through fork(), posix_spawn(), or exec; or perhaps obtained
by other means.
The meanings of the mode arguments of fdopen() and fopen() differ.
With fdopen(), write ('w') mode cannot create or truncate a file, and append ('a') mode cannot create a
file. Inclusion of a 'b' in the mode argument is allowed for consistency with fopen(); the 'b' has no effect on the resulting stream. Implementations differ as to
whether specifying append ('a') mode causes the O_APPEND flag to be set if it was clear, but they are encouraged to do so.
Since fdopen() does not create a file, the 'x' mode modifier is silently ignored. The 'e' mode modifier is
not strictly necessary for fdopen(), since FD_CLOEXEC must not be changed when it is absent; however, it is standardized
here since that modifier is necessary to avoid a data race in multi-threaded applications using freopen(), and consistency dictates that all functions accepting mode strings should
allow the same set of strings.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5.1 Interaction of File Descriptors and Standard I/O Streams,
fclose(), fmemopen(), fopen(), open(), open_memstream(), posix_spawn()
, socket()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Realtime Extension.
Large File Summit extensions are added.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the DESCRIPTION, the use and setting of the mode argument are changed to include binary streams.
In the DESCRIPTION, text is added for large file support to indicate setting of the offset maximum in the open file
description.
All errors identified in the ERRORS section are added.
In the DESCRIPTION, text is added that the fdopen() function may cause st_atime to be updated.
The following changes were made to align with the IEEE P1003.1a draft standard:
Clarification is added that it is the responsibility of the application to ensure that the mode is compatible with the open file
descriptor.
The DESCRIPTION is updated for alignment with IEEE Std 1003.1j-2000 by specifying that fdopen() results are
unspecified for typed memory objects.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/30 is applied, making corrections to the RATIONALE.
Issue 7
SD5-XSH-ERN-149 is applied, adding the {STREAM_MAX} [EMFILE] error condition.
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0121 [409] is applied.
Issue 8
Austin Group Defects 411 and 1526 are applied, changing the requirements for the mode argument.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/remquo.html =====
remquo
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
remquo, remquof, remquol — remainder functions
SYNOPSIS
#include
double remquo(double x, double y, int *quo);
float remquof(float x, float y, int *quo);
long double remquol(long double x, long double y, int *quo);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The remquo(), remquof(), and remquol() functions shall compute the same remainder as the remainder(), remainderf(), and remainderl() functions, respectively. In the object pointed to by quo, they store
a value whose sign is the sign of x/y and whose magnitude is congruent modulo 2n to
the magnitude of the integral quotient of x/y, where n is an implementation-defined integer greater than or
equal to 3. If y is zero, the value stored in the object pointed to by quo is unspecified.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
These functions shall return x REM y.
[MX]
When subnormal results are supported, the returned value shall be exact.
If NaN is supported and a NaN is returned, the value stored in the object pointed to by quo is unspecified.
On systems that do not support the IEC 60559 Floating-Point option, if y is zero, it is implementation-defined whether a
domain error occurs or zero is returned.
[MX]  If
x or y is NaN, a NaN shall be returned.
If x is ±Inf or y is zero and the other argument is non-NaN, a domain error shall occur, and a NaN shall be
returned.
ERRORS
These functions shall fail if:
Domain Error
[MX]
The x argument is ±Inf, or the y argument is ±0 and the other argument is non-NaN.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
These functions may fail if:
Domain Error
The y argument is zero.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
These functions are intended for implementing argument reductions which can exploit a few low-order bits of the quotient. Note
that x may be so large in magnitude relative to y that an exact representation of the quotient is not practical.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), remainder()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #56 (SD5-XSH-ERN-83) is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0507 [320] is applied.
Issue 8
Austin Group Defect 713 is applied, clarifying the behavior when a NaN is returned.
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/killpg.html =====
killpg
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
killpg — send a signal to a process group
SYNOPSIS
[XSI]  #include
int killpg(pid_t pgrp, int sig);
DESCRIPTION
The killpg() function shall send the signal specified by sig to the process group specified by pgrp.
If pgrp is greater than 1, killpg(pgrp, sig) shall be equivalent to
kill(-pgrp, sig). If pgrp is less than or equal to 1, the behavior of killpg() is
undefined.
RETURN VALUE
Refer to kill().
ERRORS
Refer to kill().
The following sections are informative.
EXAMPLES
Sending a Signal to All Other Members of a Process Group
The following example shows how the calling process could send a signal to all other members of its process group. To prevent
itself from receiving the signal it first makes itself immune to the signal by ignoring it.
#include
#include
...
if (signal(SIGUSR1, SIG_IGN) == SIG_ERR)
/* Handle error */;
if (killpg(getpgrp(), SIGUSR1) == -1)
/* Handle error */;"
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
getpgid(), getpid(), kill(), raise()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/52 is applied, adding the example to the EXAMPLES section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fegetexceptflag.html =====
fegetexceptflag
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fegetexceptflag, fesetexceptflag — get and set floating-point status flags
SYNOPSIS
#include
int fegetexceptflag(fexcept_t *flagp, int excepts);
int fesetexceptflag(const fexcept_t *flagp, int excepts);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The fegetexceptflag() function shall attempt to store an implementation-defined representation of the states of the
floating-point status flags indicated by the argument excepts in the object pointed to by the argument flagp.
The fesetexceptflag() function shall attempt to set the floating-point status flags indicated by the argument
excepts to the states stored in the object pointed to by flagp. The value pointed to by flagp shall have been
set by a previous call to fegetexceptflag() whose second argument represented at least those floating-point exceptions
represented by the argument excepts. This function does not raise floating-point exceptions, but only sets the state of the
flags.
RETURN VALUE
If the representation was successfully stored, fegetexceptflag() shall return zero. Otherwise, it shall return a non-zero
value. If the excepts argument is zero or if all the specified exceptions were successfully set, fesetexceptflag()
shall return zero. Otherwise, it shall return a non-zero value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), feraiseexcept(), fetestexcept()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
ISO/IEC 9899:1999 standard, Technical Corrigendum 1 is incorporated.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/cfsetospeed.html =====
cfsetospeed
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cfsetospeed — set output baud rate
SYNOPSIS
#include
int cfsetospeed(struct termios *termios_p, speed_t speed);
DESCRIPTION
The cfsetospeed() function shall set the output baud rate stored in the structure pointed to by termios_p to
speed.
There shall be no effect on the baud rates set in the hardware until a subsequent successful call to tcsetattr() with the same termios structure. Similarly, errors resulting from
attempts to set baud rates not supported by the terminal device need not be detected until the tcsetattr() function is called.
RETURN VALUE
Upon successful completion, cfsetospeed() shall return 0; otherwise, it shall return -1 and errno may be set to
indicate the error.
ERRORS
The cfsetospeed() function may fail if:
[EINVAL]
The speed value is not a valid baud rate.
[EINVAL]
The value of speed is outside the range of possible speed values as specified in .
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
Refer to cfgetispeed().
FUTURE DIRECTIONS
None.
SEE ALSO
cfgetispeed(), cfgetospeed(), cfsetispeed(),
tcsetattr()
XBD 11. General Terminal Interface,
CHANGE HISTORY
First released in Issue 3. Included for alignment with the POSIX.1-1988 standard.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The optional setting of errno and the [EINVAL] error conditions are added.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atan2f.html =====
atan2
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atan2, atan2f, atan2l — arc tangent functions
SYNOPSIS
#include
double atan2(double y, double x);
float atan2f(float y, float x);
long double atan2l(long double y, long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the principal value of the arc tangent of y/x, using the signs of both arguments to
determine the quadrant of the return value.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the arc tangent of y/x in the range [-ℼ,ℼ] radians.
If y is ±0 and x is  0, ±0 shall be returned.
If y is  0 and x is ±0, ℼ/2 shall be returned.
If x is 0, a pole error shall not occur.
[MX]  If
either x or y is NaN, a NaN shall be returned.
If the correct value would cause underflow, a range error may occur, and atan(),
atan2f(), and atan2l() shall return an implementation-defined value no greater in magnitude than DBL_MIN, FLT_MIN,
and LDBL_MIN, respectively. [MXX]   If the IEC 60559 Floating-Point option is supported, y/x should be returned.
[MX]  If
y is ±0 and x is -0, ±ℼ shall be returned.
If y is ±0 and x is +0, ±0 shall be returned.
For finite values of ±y > 0, if x is -Inf, ±ℼ shall be returned.
For finite values of ±y > 0, if x is +Inf, ±0 shall be returned.
For finite values of x, if y is ±Inf, ±ℼ/2 shall be returned.
If y is ±Inf and x is -Inf, ±3ℼ/4 shall be returned.
If y is ±Inf and x is +Inf, ±ℼ/4 shall be returned.
If both arguments are 0, a domain error shall not occur.
ERRORS
These functions may fail if:
Range Error
[MX]
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
Converting Cartesian to Polar Coordinates System
The function below uses atan2() to convert a 2d vector expressed in cartesian coordinates (x,y) to the
polar coordinates (rho,theta). There are other ways to compute the angle theta, using asin() acos(), or atan(). However, atan2() presents here two advantages:
The angle's quadrant is automatically determined.
The singular cases (0,y) are taken into account.
Finally, this example uses hypot() rather than sqrt() since it is better for special cases; see hypot() for more information.
#include
void
cartesian_to_polar(const double x, const double y,
double *rho, double *theta
)
{
*rho   = hypot (x,y); /* better than sqrt(x*x+y*y) */
*theta = atan2 (y,x);
}
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
acos(), asin(), atan(), feclearexcept(), fetestexcept(), hypot(), isnan(), sqrt(), tan()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The atan2f() and atan2l() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard, and the IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/18 is applied, adding to the EXAMPLES section.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0038 [68,428] is applied.
Issue 8
Austin Group Defect 1178 is applied, removing MX shading from a paragraph in the RETURN VALUE section and joining it with the
following paragraph.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sigaction.html =====
sigaction
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sigaction — examine and change a signal action
SYNOPSIS
[CX]  #include
int sigaction(int sig, const struct sigaction *restrict act,
struct sigaction *restrict oact);
DESCRIPTION
The sigaction() function allows the calling process to examine and/or specify the action to be associated with a specific
signal. The argument sig specifies the signal; acceptable values are defined in .
The structure sigaction, used to describe an action to be taken, is defined in the  header to include at least the following members:
Member Type
Member Name
Description
void(*) (int)
sa_handler
Pointer to a signal-catching function or one of the macros SIG_IGN or SIG_DFL.
sigset_t
sa_mask
Additional set of signals to be blocked during execution of signal-catching function.
int
sa_flags
Special flags to affect behavior of signal.
void(*) (int,
siginfo_t *, void *)
sa_sigaction
Pointer to a signal-catching function.
The storage occupied by sa_handler and sa_sigaction may overlap, and a conforming application shall
not use both simultaneously.
If the argument act is not a null pointer, it points to a structure specifying the action to be associated
with the specified signal. If the argument oact is not a null pointer, the action previously associated with the signal is
stored in the location pointed to by the argument oact. If the argument act is a null pointer, signal handling is
unchanged; thus, the call can be used to enquire about the current handling of a given signal. The SIGKILL and SIGSTOP signals
shall not be added to the signal mask using this mechanism; this restriction shall be enforced by the system without causing an
error to be indicated.
If the SA_SIGINFO flag (see below) is cleared in the sa_flags field of the sigaction structure, the
sa_handler field identifies the action to be associated with the specified signal. If the SA_SIGINFO flag is set in the
sa_flags field, the sa_sigaction field specifies a signal-catching function.
The sa_flags field can be used to modify the behavior of the specified signal.
The following flags, defined in the  header, can be
set in sa_flags:
SA_NOCLDSTOP
Do not generate SIGCHLD when children stop [XSI]   or stopped children continue.
If sig is SIGCHLD and the SA_NOCLDSTOP flag is not set in sa_flags, and the implementation supports
the SIGCHLD signal, then a SIGCHLD signal shall be generated for the calling process whenever any of its child processes stop
[XSI]
and a SIGCHLD signal may be generated for the calling process whenever any of its stopped child processes are continued.
If sig is SIGCHLD and the SA_NOCLDSTOP flag is set in
sa_flags, then the implementation shall not generate a SIGCHLD signal in this way.
SA_ONSTACK
[XSI]
If set and an alternate signal stack has been declared with sigaltstack(), the
signal shall be delivered to the calling process on that stack. Otherwise, the signal shall be delivered on the current stack.
SA_RESETHAND
If set, the disposition of the signal shall be reset to SIG_DFL and the SA_SIGINFO flag shall be cleared on entry to the signal
handler.
Note:
SIGILL and SIGTRAP cannot be automatically reset when delivered; the system silently enforces this restriction.
Otherwise, the disposition of the signal shall not be modified on entry to the signal handler.
In addition, if this flag is set, sigaction() may behave as if the SA_NODEFER flag were also set.
SA_RESTART
This flag affects the behavior of interruptible functions; that is, those specified to fail with errno set to [EINTR].
If set, and a function specified as interruptible is interrupted by this signal, the function shall restart and shall not fail with
[EINTR] unless otherwise specified. If an interruptible function which uses a timeout is restarted, the duration of the timeout
following the restart is set to an unspecified value that does not exceed the original timeout value. If the flag is not set,
interruptible functions interrupted by this signal shall fail with errno set to [EINTR].
SA_SIGINFO
If cleared and the signal is caught, the signal-catching function shall be entered as:
void func(int signo);
where signo is the only argument to the signal-catching function. In this case, the application shall use
the sa_handler member to describe the signal-catching function and the application shall not modify the sa_sigaction
member.
If SA_SIGINFO is set and the signal is caught, the signal-catching function shall be entered as:
void func(int signo, siginfo_t *info, void *context);
where two additional arguments are passed to the signal-catching function. The second argument shall point to an
object of type siginfo_t explaining the reason why the signal was generated; the third argument can be cast to a pointer to
an object of type ucontext_t to refer to the receiving thread's context that was interrupted when the signal was delivered.
In this case, the application shall use the sa_sigaction member to describe the signal-catching function and the application
shall not modify the sa_handler member.
The si_signo member contains the system-generated signal number.
[XSI]  The si_errno member may contain implementation-defined additional error information; if non-zero, it contains an
error number identifying the condition that caused the signal to be generated.
The si_code member contains a code identifying the cause of the signal, as described in 2.4.3 Signal Actions.
SA_NOCLDWAIT
[XSI]
If sig does not equal SIGCHLD, the behavior is unspecified. Otherwise, the behavior of the SA_NOCLDWAIT flag is as specified
in Consequences of Process Termination().
SA_NODEFER
If set and sig is caught, sig shall not be added to the thread's signal mask on entry to the signal handler
unless it is included in sa_mask. Otherwise, sig shall always be added to the thread's signal mask on entry to the
signal handler.
When a signal is caught by a signal-catching function installed by sigaction(), a new signal mask is
calculated and installed for the duration of the signal-catching function (or until a call to either sigprocmask() or sigsuspend() is
made). This mask is formed by taking the union of the current signal mask and the value of the sa_mask for the signal being
delivered, and unless SA_NODEFER or SA_RESETHAND is set, then including the signal being delivered. If and when the user's signal
handler returns normally, the original signal mask is restored.
Once an action is installed for a specific signal, it shall remain installed until another action is explicitly
requested (by another call to sigaction()), until the SA_RESETHAND flag causes resetting of the handler, or until one of the
exec functions is called.
If the previous action for sig had been established by signal(), the values of the fields returned in the structure pointed to by oact are
unspecified, and in particular oact->sa_handler is not necessarily the same value passed to signal(). However, if a pointer to the same structure or a copy thereof is passed to a
subsequent call to sigaction() via the act argument, handling of the signal shall be as if the original call to
signal() were repeated.
If sigaction() fails, no new signal handler is installed.
It is unspecified whether an attempt to set the action for a signal that cannot be caught or ignored to SIG_DFL is
ignored or causes an error to be returned with errno set to [EINVAL].
If SA_SIGINFO is not set in sa_flags, then the disposition of subsequent occurrences of sig when it
is already pending is implementation-defined; the signal-catching function shall be invoked with a single argument. If SA_SIGINFO
is set in sa_flags, then subsequent occurrences of sig generated by sigqueue() or as a result of any signal-generating function that supports the specification
of an application-defined value (when sig is already pending) shall be queued in FIFO order until delivered or accepted; the
signal-catching function shall be invoked with three arguments. The application specified value is passed to the signal-catching
function as the si_value member of the siginfo_t structure.
The result of the use of sigaction() and a sigwait() function
concurrently within a process on the same signal is unspecified.
RETURN VALUE
Upon successful completion, sigaction() shall return 0; otherwise, -1 shall be returned, errno shall be set to
indicate the error, and no new signal-catching function shall be installed.
ERRORS
The sigaction() function shall fail if:
[EINVAL]
The sig argument is not a valid signal number or an attempt is made to catch a signal that cannot be caught or ignore a
signal that cannot be ignored.
The sigaction() function may fail if:
[EINVAL]
An attempt was made to set the action to SIG_DFL for a signal that cannot be caught or ignored (or both).
In addition, on systems that do not support the XSI option, the sigaction() function may fail if the
SA_SIGINFO flag is set in the sa_flags field of the sigaction structure for a signal not in the range SIGRTMIN to
SIGRTMAX.
The following sections are informative.
EXAMPLES
Establishing a Signal Handler
The following example demonstrates the use of sigaction() to establish a handler for the SIGINT signal.
#include
static void handler(int signum)
{
/* Take appropriate actions for signal delivery */
}
int main(void)
{
struct sigaction sa;
sa.sa_handler = handler;
sigemptyset(&sa.sa_mask);
sa.sa_flags = SA_RESTART; /* Restart functions if
interrupted by handler */
if (sigaction(SIGINT, &sa, NULL) == -1)
/* Handle error */;
/* Further code */
}
APPLICATION USAGE
The sigaction() function supersedes the signal() function, and should be
used in preference. In particular, sigaction() and signal() should not be used
in the same process to control the same signal. The behavior of async-signal-safe functions, as defined in their respective
DESCRIPTION sections, is as specified by this volume of POSIX.1-2024, regardless of invocation from a signal-catching function.
This is the only intended meaning of the statement that async-signal-safe functions may be used in signal-catching functions
without restrictions. Applications must still consider all effects of such functions on such things as data structures, files, and
process state. In particular, application developers need to consider the restrictions on interactions when interrupting sleep() and interactions among multiple handles for a file description. The fact that any
specific function is listed as async-signal-safe does not necessarily mean that invocation of that function from a signal-catching
function is recommended.
In order to prevent errors arising from interrupting non-async-signal-safe function calls, applications should
protect calls to these functions either by blocking the appropriate signals or through the use of some programmatic semaphore (see
semget(), sem_init(), sem_open(), and so on). Note in particular that even the "safe" functions may modify
errno; the signal-catching function, if not executing as an independent thread, should save and restore its value in order
to avoid the possibility that delivery of a signal in between an error return from a function that sets errno and the
subsequent examination of errno could result in the signal-catching function changing the value of errno. Naturally,
the same principles apply to the async-signal-safety of application routines and asynchronous data access. Note that longjmp() and siglongjmp() are not in the
list of async-signal-safe functions. This is because the code executing after longjmp() and siglongjmp() can call any
unsafe functions with the same danger as calling those unsafe functions directly from the signal handler. Applications that use
longjmp() and siglongjmp() from
within signal handlers require rigorous protection in order to be portable. Many of the other functions that are excluded from the
list are traditionally implemented using either malloc() or free() functions or the standard I/O library, both of which traditionally use data structures
in a non-async-signal-safe manner. Since any combination of different functions using a common data structure can cause
async-signal-safety problems, this volume of POSIX.1-2024 does not define the behavior when any unsafe function is called in a
signal handler that interrupts an unsafe function.
Usually, the signal is executed on the stack that was in effect before the signal was delivered. An alternate stack
may be specified to receive a subset of the signals being caught.
When the signal handler returns, the receiving thread resumes execution at the point it was interrupted unless the
signal handler makes other arrangements. If longjmp() is used to leave the signal
handler, then the signal mask must be explicitly restored.
This volume of POSIX.1-2024 defines the third argument of a signal handling function when SA_SIGINFO is set as a
void * instead of a ucontext_t *, but without requiring type checking. New applications should explicitly cast the
third argument of the signal handling function to ucontext_t *.
The BSD optional four argument signal handling function is not supported by this volume of POSIX.1-2024. The BSD
declaration would be:
void handler(int sig, int code, struct sigcontext *scp,
char *addr);
where sig is the signal number, code is additional information on certain signals, scp is a
pointer to the sigcontext structure, and addr is additional address information. Much the same information is
available in the objects pointed to by the second argument of the signal handler specified when SA_SIGINFO is set.
Since the sigaction() function is allowed but not required to set SA_NODEFER when the application sets the
SA_RESETHAND flag, applications which depend on the SA_RESETHAND functionality for the newly installed signal handler must always
explicitly set SA_NODEFER when they set SA_RESETHAND in order to be portable.
See also the rationale for Realtime Signal Generation and Delivery in XRAT B.2.4.2 Realtime Signal Generation and Delivery.
RATIONALE
Although this volume of POSIX.1-2024 requires that signals that cannot be ignored shall not be added to the signal mask when a
signal-catching function is entered, there is no explicit requirement that subsequent calls to sigaction() reflect this in
the information returned in the oact argument. In other words, if SIGKILL is included in the sa_mask field of
act, it is unspecified whether or not a subsequent call to sigaction() returns with SIGKILL included in the
sa_mask field of oact.
The SA_NOCLDSTOP flag, when supplied in the act->sa_flags parameter, allows overloading SIGCHLD
with the System V semantics that each SIGCLD signal indicates a single terminated child. Most conforming applications that catch
SIGCHLD are expected to install signal-catching functions that repeatedly call the waitpid() function with the WNOHANG flag set, acting on each child for which status is
returned, until waitpid() returns zero. If stopped children are not of interest, the
use of the SA_NOCLDSTOP flag can prevent the overhead from invoking the signal-catching routine when they stop.
Some historical implementations also define other mechanisms for stopping processes, such as the ptrace()
function. These implementations usually do not generate a SIGCHLD signal when processes stop due to this mechanism; however, that
is beyond the scope of this volume of POSIX.1-2024.
This volume of POSIX.1-2024 requires that calls to sigaction() that supply a NULL act argument
succeed, even in the case of signals that cannot be caught or ignored (that is, SIGKILL or SIGSTOP). The System V signal() and BSD sigvec() functions return [EINVAL] in these cases and, in this
respect, their behavior varies from sigaction().
This volume of POSIX.1-2024 requires that sigaction() properly save and restore a signal action set up by
the ISO C standard signal() function. However, there is no guarantee that the
reverse is true, nor could there be given the greater amount of information conveyed by the sigaction structure. Because of
this, applications should avoid using both functions for the same signal in the same process. Since this cannot always be avoided
in case of general-purpose library routines, they should always be implemented with sigaction().
It was intended that the signal() function should be implementable as
a library routine using sigaction().
The POSIX Realtime Extension extends the sigaction() function as specified by the POSIX.1-1990 standard to
allow the application to request on a per-signal basis via an additional signal action flag that the extra parameters, including
the application-defined signal value, if any, be passed to the signal-catching function.
FUTURE DIRECTIONS
None.
SEE ALSO
2.4 Signal Concepts, exec, _Exit(), kill(), longjmp(), pthread_sigmask(),
raise(), semget(), sem_init(), sem_open(), sig2str(), sigaddset(), sigaltstack(), sigdelset(),
sigemptyset(), sigfillset()
, sigismember(), signal(),
sigsuspend(), wait(),
waitid()
XBD
CHANGE HISTORY
First released in Issue 3. Included for alignment with the POSIX.1-1988 standard.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Realtime Extension and POSIX Threads Extension.
In the DESCRIPTION, the second argument to func when SA_SIGINFO is set is no longer permitted to be NULL,
and the description of permitted siginfo_t contents is expanded by reference to .
Since the X/OPEN UNIX Extension functionality is now folded into the BASE, the [ENOTSUP] error is deleted.
Issue 6
The Open Group Corrigendum U028/7 is applied. In the paragraph entitled "Signal Effects on Other Functions", a reference to
sigpending() is added.
In the DESCRIPTION, the text "Signal Generation and Delivery", "Signal Actions", and "Signal Effects on Other
Functions" are moved to a separate section of this volume of POSIX.1-2024.
Text describing functionality from the Realtime Signals Extension option is marked.
The following changes are made for alignment with the ISO POSIX-1:1996 standard:
The [ENOTSUP] error condition is added.
The normative text is updated to avoid use of the term "must" for application requirements.
The restrict keyword is added to the sigaction() prototype for alignment with the
ISO/IEC 9899:1999 standard.
References to the wait3() function are removed.
The SYNOPSIS is marked CX since the presence of this function in the  header is an extension over the ISO C standard.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/57 is applied, changing text in the table
describing the sigaction structure.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/127 is applied, removing text from the DESCRIPTION
duplicated later in the same section.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/128 is applied, updating the DESCRIPTION and
APPLICATION USAGE sections. Changes are made to refer to the thread rather than the process.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/129 is applied, adding the example to the EXAMPLES
section.
Issue 7
Austin Group Interpretation 1003.1-2001 #004 is applied.
Austin Group Interpretations 1003.1-2001 #065 and #084 are applied, clarifying the role of the SA_NODEFER flag with
respect to the signal mask, and clarifying the SA_RESTART flag for interrupted functions which use timeouts.
Austin Group Interpretation 1003.1-2001 #156 is applied.
SD5-XSH-ERN-167 is applied, updating the APPLICATION USAGE section.
SD5-XSH-ERN-172 is applied, updating the DESCRIPTION to make optional the requirement that when the SA_RESETHAND
flag is set, sigaction() shall behave as if the SA_NODEFER flag were also set.
Functionality relating to the Realtime Signals Extension option is moved to the Base.
The description of the si_code member is replaced with a reference to 2.4.3 Signal Actions.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0578 [66] and XSH/TC1-2008/0579 [140] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0329 [690] and XSH/TC2-2008/0330 [491] are applied.
Issue 8
Austin Group Defect 1138 is applied, adding sig2str() to the SEE ALSO
section.
Austin Group Defect 1195 is applied, changing "main()" to "main(void)".
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sched_get_priority_min.html =====
sched_get_priority_max
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sched_get_priority_max, sched_get_priority_min — get priority limits (REALTIME)
SYNOPSIS
[PS|TPS]  #include
int sched_get_priority_max(int policy);
int sched_get_priority_min(int policy);
DESCRIPTION
The sched_get_priority_max() and sched_get_priority_min() functions shall return the appropriate maximum or
minimum, respectively, for the scheduling policy specified by policy.
The value of policy shall be one of the scheduling policy values defined in .
RETURN VALUE
If successful, the sched_get_priority_max() and sched_get_priority_min() functions shall return the appropriate
maximum or minimum values, respectively. If unsuccessful, they shall return a value of -1 and set errno to indicate the
error.
ERRORS
The sched_get_priority_max() and sched_get_priority_min() functions shall fail if:
[EINVAL]
The value of the policy parameter does not represent a defined scheduling policy.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
sched_getparam(), sched_setparam(), sched_getscheduler(), sched_rr_get_interval(), sched_setscheduler()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
These functions are marked as part of the Process Scheduling option.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Process
Scheduling option.
The [ESRCH] error condition has been removed since these functions do not take a pid argument.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/52 is applied, changing the PS margin code in the SYNOPSIS to
PS|TPS.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fesetexceptflag.html =====
fegetexceptflag
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fegetexceptflag, fesetexceptflag — get and set floating-point status flags
SYNOPSIS
#include
int fegetexceptflag(fexcept_t *flagp, int excepts);
int fesetexceptflag(const fexcept_t *flagp, int excepts);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The fegetexceptflag() function shall attempt to store an implementation-defined representation of the states of the
floating-point status flags indicated by the argument excepts in the object pointed to by the argument flagp.
The fesetexceptflag() function shall attempt to set the floating-point status flags indicated by the argument
excepts to the states stored in the object pointed to by flagp. The value pointed to by flagp shall have been
set by a previous call to fegetexceptflag() whose second argument represented at least those floating-point exceptions
represented by the argument excepts. This function does not raise floating-point exceptions, but only sets the state of the
flags.
RETURN VALUE
If the representation was successfully stored, fegetexceptflag() shall return zero. Otherwise, it shall return a non-zero
value. If the excepts argument is zero or if all the specified exceptions were successfully set, fesetexceptflag()
shall return zero. Otherwise, it shall return a non-zero value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), feraiseexcept(), fetestexcept()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
ISO/IEC 9899:1999 standard, Technical Corrigendum 1 is incorporated.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atomic_exchange.html =====
atomic_exchange
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atomic_exchange, atomic_exchange_explicit — atomically exchange the value of an object
SYNOPSIS
#include
C atomic_exchange(volatile A *object, C desired); C
atomic_exchange_explicit(volatile A *object, C desired,
memory_order order);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
Implementations that define the macro __STDC_NO_ATOMICS__ need not provide the  header nor support these generic functions.
The atomic_exchange_explicit() generic function shall atomically replace the value pointed to by object with
desired. This operation shall be an atomic read-modify-write operation (see XBD 4.15.1 Memory Ordering). Memory shall be affected according to the value of
order.
The atomic_exchange() generic function shall be equivalent to atomic_exchange_explicit() called with order
set to memory_order_seq_cst.
RETURN VALUE
These generic functions shall return the value pointed to by object immediately before the effects.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD 4.15.1 Memory Ordering,
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/read.html =====
read
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pread, read — read from a file
SYNOPSIS
#include
ssize_t pread(int fildes, void *buf, size_t nbyte, off_t
offset);
ssize_t read(int fildes, void *buf, size_t nbyte);
DESCRIPTION
The read() function shall attempt to read nbyte bytes from the file associated with the open file descriptor,
fildes, into the buffer pointed to by buf. The behavior of multiple concurrent reads on the same pipe, FIFO, or
terminal device is unspecified.
Before any action described below is taken, and if nbyte is zero, the read() function may detect and return errors
as described below. In the absence of errors, or if error detection is not performed, the read() function shall return zero
and have no other results.
On files that support seeking (for example, a regular file), the read() shall start at a position in the file given by
the file offset associated with fildes. The file offset shall be incremented by the number of bytes actually read.
Files that do not support seeking—for example, terminals—always read from the current position. The value of a file offset
associated with such a file is undefined.
No data transfer shall occur past the current end-of-file. If the starting position is at or after the end-of-file, 0 shall be
returned. If the file refers to a device special file, the result of subsequent read() requests is
implementation-defined.
If the value of nbyte is greater than {SSIZE_MAX}, the result is implementation-defined.
When attempting to read from an empty pipe or FIFO:
If no process has the pipe open for writing, read() shall return 0 to indicate end-of-file.
If some process has the pipe open for writing and O_NONBLOCK is set, read() shall return -1 and set errno to
[EAGAIN].
If some process has the pipe open for writing and O_NONBLOCK is clear, read() shall block the calling thread until some
data is written or the pipe is closed by all processes that had the pipe open for writing.
When attempting to read a file (other than a pipe or FIFO) that supports non-blocking reads and has no data currently
available:
If O_NONBLOCK is set, read() shall return -1 and set errno to [EAGAIN].
If O_NONBLOCK is clear, read() shall block the calling thread until some data becomes available.
The use of the O_NONBLOCK flag has no effect if there is some data available.
The read() function reads data previously written to a file. If any portion of a regular file prior to the end-of-file
has not been written, read() shall return bytes with value 0. For example, lseek() allows the file offset to be set beyond the end of existing data in the file. If data
is later written at this point, subsequent reads in the gap between the previous end of data and the newly written data shall
return bytes with value 0 until data is written into the gap.
Upon successful completion, where nbyte is greater than 0, read() shall mark for update the last data access
timestamp of the file, and shall return the number of bytes read. This number shall never be greater than nbyte. The value
returned may be less than nbyte if the number of bytes left in the file is less than nbyte, if the read()
request was interrupted by a signal, or if the file is a pipe or FIFO or special file and has fewer than nbyte bytes
immediately available for reading. For example, a read() from a file associated with a terminal may return one typed line of
data.
If a read() is interrupted by a signal before it reads any data, it shall return -1 with errno set to [EINTR].
If a read() is interrupted by a signal after it has successfully read some data, it shall return the number of bytes
read.
For regular files, no data transfer shall occur past the offset maximum established in the open file description associated with
fildes.
If fildes refers to a socket, read() shall be equivalent to recv()
with no flags set.
[SIO]
If the O_DSYNC and O_RSYNC bits have been set, read I/O operations on the file descriptor shall complete as defined by synchronized
I/O data integrity completion. If the O_SYNC and O_RSYNC bits have been set, read I/O operations on the file descriptor shall
complete as defined by synchronized I/O file integrity completion.
[SHM]
If fildes refers to a shared memory object, the result of the read() function is unspecified.
[TYM]
If fildes refers to a typed memory object, the result of the read() function is unspecified.
The pread() function shall be equivalent to read(), except that it shall read from a given position in the file
without changing the file offset. The first three arguments to pread() are the same as read() with the addition of a
fourth argument offset for the desired position inside the file. An attempt to perform a pread() on a file that is
incapable of seeking shall result in an error.
RETURN VALUE
Upon successful completion, these functions shall return a non-negative integer indicating the number of bytes actually read.
Otherwise, the functions shall return -1 and set errno to indicate the error.
ERRORS
These functions shall fail if:
[EAGAIN]
The file is neither a pipe, nor a FIFO, nor a socket, the O_NONBLOCK flag is set for the file descriptor, and the thread would
be delayed in the read operation.
[EBADF]
The fildes argument is not a valid file descriptor open for reading.
[EINTR]
The read operation was terminated due to the receipt of a signal, and no data was transferred.
[EIO]
The process is a member of a background process group attempting to read from its controlling terminal, and either the calling
thread is blocking SIGTTIN or the process is ignoring SIGTTIN or the process group of the process is orphaned. This error may also
be generated for implementation-defined reasons.
[EISDIR]
[XSI]
The fildes argument refers to a directory and the implementation does not allow the directory to be read using read()
or pread(). The readdir() function should be used instead.
[EOVERFLOW]
The file is a regular file, nbyte is greater than 0, the starting position is before the end-of-file, and the starting
position is greater than or equal to the offset maximum established in the open file description associated with
fildes.
The pread() function shall fail if:
[EINVAL]
The file is a regular file or block special file, and the offset argument is negative. The file offset shall remain
unchanged.
[ESPIPE]
The file is incapable of seeking.
The read() function shall fail if:
[EAGAIN]
The file is a pipe or FIFO, the O_NONBLOCK flag is set for the file descriptor, and the thread would be delayed in the read
operation.
[EAGAIN] or [EWOULDBLOCK]
The file is a socket, the O_NONBLOCK flag is set for the file descriptor, and the thread would be delayed in the read
operation.
[ECONNRESET]
A read was attempted on a socket and the connection was forcibly closed by its peer.
[ENOTCONN]
A read was attempted on a socket that is not connected.
[ETIMEDOUT]
A read was attempted on a socket and a transmission timeout occurred.
These functions may fail if:
[EIO]
A physical I/O error has occurred.
[ENOBUFS]
Insufficient resources were available in the system to perform the operation.
[ENOMEM]
Insufficient memory was available to fulfill the request.
[ENXIO]
A request was made of a nonexistent device, or the request was outside the capabilities of the device.
The following sections are informative.
EXAMPLES
Reading Data into a Buffer
The following example reads data from the file associated with the file descriptor fd into the buffer pointed to by
buf.
#include
#include
...
char buf[20];
size_t nbytes;
ssize_t bytes_read;
int fd;
...
nbytes = sizeof(buf);
bytes_read = read(fd, buf, nbytes);
...
APPLICATION USAGE
None.
RATIONALE
This volume of POSIX.1-2024 does not specify the value of the file offset after an error is returned; there are too many cases.
For programming errors, such as [EBADF], the concept is meaningless since no file is involved. For errors that are detected
immediately, such as [EAGAIN], clearly the offset should not change. After an interrupt or hardware error, however, an updated
value would be very useful and is the behavior of many implementations.
Note that a read() of zero bytes does not modify the last data access timestamp. A read() that requests more than
zero bytes, but returns zero, is required to modify the last data access timestamp.
Implementations are allowed, but not required, to perform error checking for read() requests of zero bytes.
Input and Output
The use of I/O with large byte counts has always presented problems. Ideas such as lread() and lwrite() (using and
returning longs) were considered at one time. The current solution is to use abstract types on the ISO C standard
function to read() and write(). The abstract types can be declared so that
existing functions work, but can also be declared so that larger types can be represented in future implementations. It is presumed
that whatever constraints limit the maximum range of size_t also limit portable I/O requests to the same range. This volume
of POSIX.1-2024 also limits the range further by requiring that the byte count be limited so that a signed return value remains
meaningful. Since the return type is also a (signed) abstract type, the byte count can be defined by the implementation to be
larger than an int can hold.
The standard developers considered adding atomicity requirements to a pipe or FIFO, but recognized that due to the nature of
pipes and FIFOs there could be no guarantee of atomicity of reads of {PIPE_BUF} or any other size that would be an aid to
applications portability.
This volume of POSIX.1-2024 requires that no action be taken for read() or write() when nbyte is zero. This is not intended to take precedence over detection of
errors (such as invalid buffer pointers or file descriptors). This is consistent with the rest of this volume of POSIX.1-2024, but
the phrasing here could be misread to require detection of the zero case before any other errors. A value of zero is to be
considered a correct value, for which the semantics are a no-op.
I/O is intended to be atomic to ordinary files and pipes and FIFOs. Atomic means that all the bytes from a single operation that
started out together end up together, without interleaving from other I/O operations. It is a known attribute of terminals that
this is not honored, and terminals are explicitly (and implicitly permanently) excepted, making the behavior unspecified. The
behavior for other device types is also left unspecified, but the wording is intended to imply that future standards might choose
to specify atomicity (or not).
There were recommendations to add format parameters to read() and write() in
order to handle networked transfers among heterogeneous file system and base hardware types. Such a facility may be required for
support by the OSI presentation of layer services. However, it was determined that this should correspond with similar C-language
facilities, and that is beyond the scope of this volume of POSIX.1-2024. The concept was suggested to the developers of the
ISO C standard for their consideration as a possible area for future work.
In 4.3 BSD, a read() or write() that is interrupted by a signal before
transferring any data does not by default return an [EINTR] error, but is restarted. In 4.2 BSD, 4.3 BSD, and the Eighth Edition,
there is an additional function, select(), whose purpose is to pause until specified
activity (data to read, space to write, and so on) is detected on specified file descriptors. It is common in applications written
for those systems for select() to be used before read() in situations (such as
keyboard input) where interruption of I/O due to a signal is desired.
The issue of which files or file types are interruptible is considered an implementation design issue. This is often affected
primarily by hardware and reliability issues.
There are no references to actions taken following an "unrecoverable error". It is considered beyond the scope of this volume
of POSIX.1-2024 to describe what happens in the case of hardware errors.
Earlier versions of this standard allowed two very different behaviors with regard to the handling of interrupts. In order to
minimize the resulting confusion, it was decided that POSIX.1-2024 should support only one of these behaviors. Historical practice
on AT&T-derived systems was to have read() and write() return -1 and set
errno to [EINTR] when interrupted after some, but not all, of the data requested had been transferred. However, the US
Department of Commerce FIPS 151-1 and FIPS 151-2 require the historical BSD behavior, in which read() and write() return the number of bytes actually transferred before the interrupt. If -1 is
returned when any data is transferred, it is difficult to recover from the error on a seekable device and impossible on a
non-seekable device. Most new implementations support this behavior. The behavior required by POSIX.1-2024 is to return the number
of bytes transferred.
POSIX.1-2024 does not specify when an implementation that buffers read()s actually moves the data into the user-supplied
buffer, so an implementation may choose to do this at the latest possible moment. Therefore, an interrupt arriving earlier may not
cause read() to return a partial byte count, but rather to return -1 and set errno to [EINTR].
Consideration was also given to combining the two previous options, and setting errno to [EINTR] while returning a short
count. However, not only is there no existing practice that implements this, it is also contradictory to the idea that when
errno is set, the function responsible shall return -1.
This volume of POSIX.1-2024 intentionally does not specify any pread() errors related to pipes, FIFOs, and sockets other
than [ESPIPE].
FUTURE DIRECTIONS
None.
SEE ALSO
fcntl(), lseek(), open(), pipe(), readv()
XBD 11. General Terminal Interface, ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Realtime Extension and the POSIX Threads Extension.
Large File Summit extensions are added.
The pread() function is added.
Issue 6
The DESCRIPTION and ERRORS sections are updated so that references to STREAMS are marked as part of the XSI STREAMS Option
Group.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The DESCRIPTION now states that if read() is interrupted by a signal after it has successfully read some data, it returns
the number of bytes read. In Issue 3, it was optional whether read() returned the number of bytes read, or whether it
returned -1 with errno set to [EINTR]. This is a FIPS requirement.
In the DESCRIPTION, text is added to indicate that for regular files, no data transfer occurs past the offset maximum
established in the open file description associated with fildes. This change is to support large files.
The [EOVERFLOW] mandatory error condition is added.
The [ENXIO] optional error condition is added.
Text referring to sockets is added to the DESCRIPTION.
The following changes were made to align with the IEEE P1003.1a draft standard:
The effect of reading zero bytes is clarified.
The DESCRIPTION is updated for alignment with IEEE Std 1003.1j-2000 by specifying that read() results are
unspecified for typed memory objects.
New RATIONALE is added to explain the atomicity requirements for input and output operations.
The following error conditions are added for operations on sockets: [EAGAIN], [ECONNRESET], [ENOTCONN], and [ETIMEDOUT].
The [EIO] error is made optional.
The following error conditions are added for operations on sockets: [ENOBUFS] and [ENOMEM].
The readv() function is split out into a separate reference page.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/108 is applied, updating the [EAGAIN] error in the ERRORS
section from "the process would be delayed" to "the thread would be delayed".
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/109 is applied, making an editorial correction in the RATIONALE
section.
Issue 7
The pread() function is moved from the XSI option to the Base.
Functionality relating to the XSI STREAMS option is marked obsolescent.
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0480 [218], XSH/TC1-2008/0481 [79], XSH/TC1-2008/0482 [218],
XSH/TC1-2008/0483 [218], XSH/TC1-2008/0484 [218], and XSH/TC1-2008/0485 [218,428] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0302 [710] and XSH/TC2-2008/0303 [676,710] are applied.
Issue 8
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/environ.html =====
exec
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
environ, execl, execle, execlp, execv, execve, execvp, fexecve — execute a file
SYNOPSIS
#include
extern char **environ;
int execl(const char *path, const char *arg0, ... /*, (char *)0 */);
int execle(const char *path, const char *arg0, ... /*,
(char *)0, char *const envp[]*/);
int execlp(const char *file, const char *arg0, ... /*, (char *)0 */);
int execv(const char *path, char *const argv[]);
int execve(const char *path, char *const argv[], char *const envp[]);
int execvp(const char *file, char *const argv[]);
int fexecve(int fd, char *const argv[], char *const envp[]);
DESCRIPTION
The exec family of functions shall replace the current process image with a new process image. The new image shall be
constructed from a regular, executable file called the new process image file. There shall be no return from a successful
exec, because the calling process image is overlaid by the new process image.
The fexecve() function shall be equivalent to the execve() function except that the file to be executed is
determined by the file descriptor fd instead of a pathname. The file offset of fd is ignored.
When a C-language program is executed as a result of a call to one of the exec family of functions, it shall be entered
as a C-language function call as follows:
int main (int argc, char *argv[]);
where argc is the argument count and argv is an array of character pointers to the arguments themselves. In
addition, the following variable, which needs to be declared by the user if it is to be used directly:
extern char **environ;
is initialized as a pointer to an array of character pointers to the environment strings. The argv and environ
arrays are each terminated by a null pointer. The null pointer terminating the argv array is not counted in argc.
Applications can change the entire environment in a single operation by assigning the environ variable to point to an
array of character pointers to the new environment strings. After assigning a new value to environ, applications should not
rely on the new environment strings remaining part of the environment, as a call to getenv(), secure_getenv(),
[XSI]
putenv(),  setenv(), unsetenv(), or any function that is
dependent on an environment variable may, on noticing that environ has changed, copy the environment strings to a new array
and assign environ to point to it.
Any application that directly modifies the pointers to which the environ variable points has undefined behavior.
Conforming multi-threaded applications shall not use the environ variable to access or modify any environment variable
while any other thread is concurrently modifying any environment variable. A call to any function dependent on any environment
variable shall be considered a use of the environ variable to access that environment variable.
The arguments specified by a program with one of the exec functions shall be passed on to the new process image in the
corresponding main() arguments.
For the execl(), execle(), execv(), and execve() functions, the argument path points to a
pathname that identifies the new process image file.
For the execlp() and execvp() functions, the argument file is used to construct a pathname that identifies
the new process image file. If the file argument contains a  character, the file argument shall be used
as the pathname for this file. Otherwise, the path prefix for this file is obtained by a search of the directories passed as the
environment variable PATH (see XBD 8. Environment Variables). If
this environment variable is not present, the results of the search are implementation-defined.
There are two distinct ways in which the contents of the process image file may cause the execution to fail, distinguished by
the setting of errno to either [ENOEXEC] or [EINVAL] (see the ERRORS section). In the cases where the other members of the
exec family of functions would fail and set errno to [ENOEXEC], the execlp() and execvp() functions
shall execute a command interpreter and the environment of the executed command shall be as if the process invoked the sh utility using execl() as follows:
execl(, , file, , (char *)0);
where  is an unspecified pathname for the sh utility,
is an unspecified string, file is the process image file, and where  is zero or more
parameters corresponding to any initial non-null arguments passed after arg0 for execlp() or to any initial non-null
members of argv starting at argv[1] for execvp().
The arguments represented by arg0,... are pointers to null-terminated character strings. These strings shall constitute
the argument list available to the new process image. The list is terminated by a null pointer. The argument arg0 should
point to a filename string that is associated with the process being started by one of the exec functions.
The argument argv is an array of character pointers to null-terminated strings. The application shall ensure that the
last member of this array is a null pointer. These strings shall constitute the argument list available to the new process image.
The value in argv[0] should point to a filename string that is associated with the process being started by one of the
exec functions.
The argument envp is an array of character pointers to null-terminated strings. These strings shall constitute the
environment for the new process image. The envp array is terminated by a null pointer.
For those forms not containing an envp pointer (execl(), execv(),
execlp(), and execvp()), the environment for the new process image shall be taken from the external variable
environ in the calling process.
The number of bytes available for the new process' combined argument and environment lists is {ARG_MAX}. It is
implementation-defined whether null terminators, pointers, and/or any alignment bytes are included in this total.
File descriptors open in the calling process image shall remain open in the new process image, except for those whose
close-on-exec flag FD_CLOEXEC is set. For those file descriptors that remain open, all attributes of the open file
description shall remain unchanged and the FD_CLOFORK file descriptor flag, if set, shall remain set. For any file descriptor that
is closed for this reason, process-owned file locks that the calling process owns on the file associated with the file descriptor
shall be unlocked as a result of the close, as described in close(). File locks that
are not unlocked by closing of file descriptors remain unchanged.
If file descriptor 0, 1, or 2 would otherwise be closed after a successful call to one of the exec family of functions,
implementations may open an unspecified file for the file descriptor in the new process image. If a standard utility or a
conforming application is executed with file descriptor 0 not open for reading or with file descriptor 1 or 2 not open for writing,
the environment in which the utility or application is executed shall be deemed non-conforming, and consequently the utility or
application might not behave as described in this standard.
Directory streams open in the calling process image shall be closed in the new process image.
The state of the floating-point environment in the initial thread of the new process image shall be set to the default.
The state of conversion descriptors and message catalog descriptors in the new process image is undefined.
For the new process image, the equivalent of:
setlocale(LC_ALL, "C")
shall be executed at start-up.
Signals set to the default action (SIG_DFL) in the calling process image shall be set to the default action in the new process
image. Except for SIGCHLD, signals set to be ignored (SIG_IGN) by the calling process image shall be set to be ignored by the new
process image. Signals set to be caught by the calling process image shall be set to the default action in the new process image
(see ).
If the SIGCHLD signal is set to be ignored by the calling process image, it is unspecified whether the SIGCHLD signal is set to
be ignored or to the default action in the new process image.
[XSI]
After a successful call to any of the exec functions, alternate signal stacks are not preserved and the SA_ONSTACK flag
shall be cleared for all signals.
After a successful call to any of the exec functions, any functions previously registered by the atexit(), at_quick_exit(), or pthread_atfork() functions are no longer registered.
[XSI]
If the ST_NOSUID bit is set for the file system containing the new process image file, then the effective user ID, effective group
ID, saved set-user-ID, and saved set-group-ID are unchanged in the new process image. Otherwise,  if the set-user-ID mode bit of the new process image file is set, the effective user ID of the new
process image shall be set to the user ID of the new process image file. Similarly, if the set-group-ID mode bit of the new process
image file is set, the effective group ID of the new process image shall be set to the group ID of the new process image file. The
real user ID, real group ID, and supplementary group IDs of the new process image shall remain the same as those of the calling
process image. The effective user ID and effective group ID of the new process image shall be saved (as the saved set-user-ID and
the saved set-group-ID) for use by setuid().
[XSI]
Any shared memory segments attached to the calling process image shall not be attached to the new process image.
Any named semaphores open in the calling process shall be closed as if by appropriate calls to sem_close(). Any unnamed semaphores open in the calling process shall be destroyed as if
by calls to sem_destroy().
[TYM]
Any blocks of typed memory that were mapped in the calling process are unmapped, as if munmap() was implicitly called to unmap them.
[ML]
Memory locks established by the calling process via calls to mlockall() or mlock() shall be removed. If locked pages in the address space of the calling process are also
mapped into the address spaces of other processes and are locked by those processes, the locks established by the other processes
shall be unaffected by the call by this process to the exec function. If the exec function fails, the effect on
memory locks is unspecified.
Memory mappings created in the process are unmapped before the address space is rebuilt for the new process image.
When the calling process image does not use the SCHED_FIFO, SCHED_RR, [SS]
or SCHED_SPORADIC   scheduling policies, the scheduling policy and parameters of the new process image and the initial
thread in that new process image are implementation-defined.
[PS]
When the calling process image uses the SCHED_FIFO, SCHED_RR, or SCHED_SPORADIC scheduling policies, the process policy and
scheduling parameter settings shall not be changed by a call to an exec function.  [TPS]   The initial thread in the new process image shall inherit the process scheduling policy and
parameters. It shall have the default system contention scope, but shall inherit its allocation domain from the calling process
image.
Per-process timers created by the calling process shall be deleted before replacing the current process image with the new
process image.
[MSG]
All open message queue descriptors in the calling process shall be closed, as described in mq_close().
Any outstanding asynchronous I/O operations may be canceled. Those asynchronous I/O operations that are not canceled shall
complete as if the exec function had not yet occurred, but any associated signal notifications shall be suppressed. It is
unspecified whether the exec function itself blocks awaiting such I/O completion. In no event, however, shall the new
process image created by the exec function be affected by the presence of outstanding asynchronous I/O operations at the
time the exec function is called. Whether any I/O is canceled, and which I/O may be canceled upon exec, is
implementation-defined.
[CPT]
The new process image shall inherit the CPU-time clock of the calling process image. This inheritance means that the process
CPU-time clock of the process being exec-ed shall not be reinitialized or altered as a result of the exec function
other than to reflect the time spent by the process executing the exec function itself.
[TCT]
The initial value of the CPU-time clock of the initial thread of the new process image shall be set to zero.
The thread ID of the initial thread in the new process image is unspecified.
The size and location of the stack on which the initial thread in the new process image runs is unspecified.
The initial thread in the new process image shall have its cancellation type set to PTHREAD_CANCEL_DEFERRED and its cancellation
state set to PTHREAD_CANCEL_ENABLED.
The initial thread in the new process image shall have all thread-specific data values set to NULL and all thread-specific data
keys shall be removed by the call to exec without running destructors.
The initial thread in the new process image shall be joinable, as if created with the detachstate attribute set to
PTHREAD_CREATE_JOINABLE.
The new process shall inherit at least the following attributes from the calling process image:
[XSI]
Nice value (see nice())
[XSI]
semadj values (see semop())
Process ID
Parent process ID
Process group ID
Session membership
Real user ID
Real group ID
Supplementary group IDs
Time left until an alarm clock signal (see alarm())
Current working directory
Root directory
File mode creation mask (see umask())
File size limit (see getrlimit() and setrlimit())
Process signal mask (see pthread_sigmask())
Pending signal (see sigpending())
tms_utime, tms_stime, tms_cutime, and tms_cstime (see times())
Resource limits
Controlling terminal
The initial thread of the new process shall inherit at least the following attributes from the calling thread:
Signal mask (see sigprocmask() and pthread_sigmask())
Pending signals (see sigpending())
All other process attributes defined in this volume of POSIX.1-2024 shall be inherited in the new process image from the old
process image. All other thread attributes defined in this volume of POSIX.1-2024 shall be inherited in the initial thread in the
new process image from the calling thread in the old process image. The inheritance of process or thread attributes not defined by
this volume of POSIX.1-2024 is implementation-defined.
A call to any exec function from a process with more than one thread shall result in all threads being terminated and the
new executable image being loaded and executed. No destructor functions or cleanup handlers shall be called.
Upon successful completion, the exec functions shall mark for update the last data access timestamp of the file. If an
exec function failed but was able to locate the process image file, whether the last data access timestamp is marked for
update is unspecified. Should the exec function succeed, the process image file shall be considered to have been opened with
open(). The corresponding close() shall be
considered to occur at a time after this open, but before process termination or successful completion of a subsequent call to one
of the exec functions, posix_spawn(), or posix_spawnp(). The argv[] and envp[] arrays of pointers and the strings
to which those arrays point shall not be modified by a call to one of the exec functions, except as a consequence of
replacing the process image.
The saved resource limits in the new process image are set to be a copy of the process' corresponding hard and soft limits.
RETURN VALUE
If one of the exec functions returns to the calling process image, an error has occurred; the return value shall be -1,
and errno shall be set to indicate the error.
ERRORS
The exec functions shall fail if:
[E2BIG]
The number of bytes used by the new process image's argument list and environment list is greater than the system-imposed limit
of {ARG_MAX} bytes.
[EACCES]
The new process image file is not a regular file and the implementation does not support execution of files of its type.
[EINVAL]
The new process image file has appropriate privileges and has a recognized executable binary format, but the system does not
support execution of a file with this format.
The exec functions, except for fexecve(), shall fail if:
[EACCES]
Search permission is denied for a directory listed in the new process image file's path prefix, or the new process image file
denies execution permission.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path or file argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of path or file does not name an existing file or path or file is an empty string.
[ENOTDIR]
A component of the new process image file's path prefix names an existing file that is neither a directory nor a symbolic link
to a directory, or the new process image file's pathname contains at least one non- character and ends with one or
more trailing  characters and the last pathname component names an existing file that is neither a directory nor a
symbolic link to a directory.
The exec functions, except for execlp() and execvp(), shall fail if:
[ENOEXEC]
The new process image file has the appropriate access permission but has an unrecognized format.
The fexecve() function shall fail if:
[EBADF]
The fd argument is not a valid file descriptor open for executing.
The exec functions may fail if:
[ENOMEM]
The new process image requires more memory than is allowed by the hardware or system-imposed memory management
constraints.
The exec functions, except for fexecve(), may fail if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path or file argument.
[ENAMETOOLONG]
The length of the path argument or the length of the pathname constructed from the file argument exceeds {PATH_MAX},
or pathname resolution of a symbolic link produced an intermediate result with a length that exceeds {PATH_MAX}.
[ETXTBSY]
The new process image file is a pure procedure (shared text) file that is currently open for writing by some process.
The following sections are informative.
EXAMPLES
Using execl()
The following example executes the ls command, specifying the pathname of the
executable (/bin/ls) and using arguments supplied directly to the command to produce single-column output.
#include
int ret;
...
ret = execl ("/bin/ls", "ls", "-1", (char *)0);
Using execle()
The following example is similar to Using execl(). In addition, it specifies the environment
for the new process image using the env argument.
#include
int ret;
char *env[] = { "HOME=/usr/home", "LOGNAME=home", (char *)0 };
...
ret = execle ("/bin/ls", "ls", "-l", (char *)0, env);
Using execlp()
The following example searches for the location of the ls command among the
directories specified by the PATH environment variable.
#include
int ret;
...
ret = execlp ("ls", "ls", "-l", (char *)0);
Using execv()
The following example passes arguments to the ls command in the cmd array.
#include
int ret;
char *cmd[] = { "ls", "-l", (char *)0 };
...
ret = execv ("/bin/ls", cmd);
Using execve()
The following example passes arguments to the ls command in the cmd array, and
specifies the environment for the new process image using the env argument.
#include
int ret;
char *cmd[] = { "ls", "-l", (char *)0 };
char *env[] = { "HOME=/usr/home", "LOGNAME=home", (char *)0 };
...
ret = execve ("/bin/ls", cmd, env);
Using execvp()
The following example searches for the location of the ls command among the
directories specified by the PATH environment variable, and passes arguments to the ls command in the cmd array.
#include
int ret;
char *cmd[] = { "ls", "-l", (char *)0 };
...
ret = execvp ("ls", cmd);
APPLICATION USAGE
As the state of conversion descriptors and message catalog descriptors in the new process image is undefined, conforming
applications should not rely on their use and should close them prior to calling one of the exec functions.
Applications that require other than the default POSIX locale as the global locale in the new process image should call setlocale() with the appropriate parameters.
When assigning a new value to the environ variable, applications should ensure that the environment to which it will
point contains at least the following:
Any implementation-defined variables required by the implementation to provide a conforming environment. See the _CS_V8_ENV
entry in  and confstr() for details.
A value for PATH which finds conforming versions of all standard utilities before any other versions.
The same constraint applies to the envp array passed to execle() or execve(), in order to ensure that the
new process image is invoked in a conforming environment.
Applications should not execute programs with file descriptor 0 not open for reading or with file descriptor 1 or 2 not open for
writing, as this might cause the executed program to misbehave. In order not to pass on these file descriptors to an executed
program, applications should not just close them but should reopen them on, for example, /dev/null. Some implementations may
reopen them automatically, but applications should not rely on this being done.
If an application wants to perform an integrity test of the file being executed before executing it, the file will need to be
opened with read permission to perform the integrity test.
Since execute permission is checked by fexecve(), the file description fd need not have been opened with the
O_EXEC flag. However, if the file to be executed denies read and write permission for the process preparing to do the exec,
the only way to provide the fd to fexecve() will be to use the O_EXEC flag when opening fd. In this case, the
application will not be able to perform an integrity test since it will not be able to read the contents of the file.
Note that when a file descriptor is opened with O_RDONLY, O_RDWR, or O_WRONLY mode, the file descriptor can be used to read,
read and write, or write the file, respectively, even if the mode of the file changes after the file was opened. Using the O_EXEC
open mode is different; fexecve() will ignore the mode that was used when the file descriptor was opened and the exec
will fail if the mode of the file associated with fd does not grant execute permission to the calling process at the time
fexecve() is called.
RATIONALE
Early proposals required that the value of argc passed to main() be "one or greater". This was driven by the
same requirement in drafts of the ISO C standard. In fact, historical implementations have passed a value of zero when no
arguments are supplied to the caller of the exec functions. This requirement was removed from the ISO C standard and
subsequently removed from this volume of POSIX.1-2024 as well. The wording, in particular the use of the word should,
requires a Strictly Conforming POSIX Application to pass at least one argument to the exec function, thus guaranteeing that
argc be one or greater when invoked by such an application. In fact, this is good practice, since many existing applications
reference argv[0] without first checking the value of argc.
The requirement on a Strictly Conforming POSIX Application also states that the value passed as the first argument be a filename
string associated with the process being started. Although some existing applications pass a pathname rather than a filename string
in some circumstances, a filename string is more generally useful, since the common usage of argv[0] is in printing
diagnostics. In some cases the filename passed is not the actual filename of the file; for example, many implementations of the
login utility use a convention of prefixing a  ('-') to the actual filename, which indicates to
the command interpreter being invoked that it is a "login shell".
Also, note that the test and [ utilities require specific strings for the
argv[0] argument to have deterministic behavior across all implementations.
Historically, there have been two ways that implementations can exec shell scripts.
One common historical implementation is that the execl(), execv(), execle(), and execve() functions
return an [ENOEXEC] error for any file not recognizable as executable, including a shell script. When the execlp() and
execvp() functions encounter such a file, they assume the file to be a shell script and invoke a known command interpreter
to interpret such files. This is now required by POSIX.1-2024. These implementations of execvp() and execlp() only
give the [ENOEXEC] error in the rare case of a problem with the command interpreter's executable file. Because of these
implementations, the [ENOEXEC] error is not mentioned for execlp() or execvp(), although implementations can still
give it.
Another way that some historical implementations handle shell scripts is by recognizing the first two bytes of the file as the
character string "#!" and using the remainder of the first line of the file as the name of the command interpreter to
execute.
One potential source of confusion noted by the standard developers is over how the contents of a process image file affect the
behavior of the exec family of functions. The following is a description of the actions taken:
If the process image file is a valid executable (in a format that is executable and valid and having appropriate privileges) for
this system, then the system executes the file.
If the process image file has appropriate privileges and is in a format that is executable but not valid for this system (such
as a recognized binary for another architecture), then this is an error and errno is set to [EINVAL] (see later RATIONALE on
[EINVAL]).
If the process image file has appropriate privileges but is not otherwise recognized:
If this is a call to execlp() or execvp(), then they invoke a command interpreter assuming that the process image
file is a shell script.
If this is not a call to execlp() or execvp(), then an error occurs and errno is set to [ENOEXEC].
Applications that do not require to access their arguments may use the form:
main(void)
as specified in the ISO C standard. However, the implementation will always provide the two arguments argc and
argv, even if they are not used.
Some implementations provide a third argument to main() called envp. This is defined as a pointer to the
environment. The ISO C standard specifies invoking main() with two arguments, so implementations are required to
support applications written this way. Since this volume of POSIX.1-2024 defines the global variable environ, which is also
provided by historical implementations and can be used anywhere that envp could be used, there is no functional need for the
envp argument. Applications should use the getenv() function rather than
accessing the environment directly via either envp or environ. Implementations are required to support the
two-argument calling sequence, but this does not prohibit an implementation from supporting envp as an optional third
argument.
This volume of POSIX.1-2024 specifies that signals set to SIG_IGN remain set to SIG_IGN, and that the new process image inherits
the signal mask of the thread that called exec in the old process image. This is consistent with historical implementations,
and it permits some useful functionality, such as the nohup command. However, it
should be noted that many existing applications wrongly assume that they start with certain signals set to the default action
and/or unblocked. In particular, applications written with a simpler signal model that does not include blocking of signals, such
as the one in the ISO C standard, may not behave properly if invoked with some signals blocked. Therefore, it is best not to
block or ignore signals across execs without explicit reason to do so, and especially not to block signals across
execs of arbitrary (not closely cooperating) programs.
The exec functions always save the value of the effective user ID and effective group ID of the process at the completion
of the exec, whether or not the set-user-ID or the set-group-ID bit of the process image file is set.
The statement about argv[] and envp[] being constants is included to make explicit to future writers of language
bindings that these objects are completely constant. Due to a limitation of the ISO C standard, it is not possible to state
that idea in standard C. Specifying two levels of const-qualification for the argv[] and envp[]
parameters for the exec functions may seem to be the natural choice, given that these functions do not modify either the
array of pointers or the characters to which the function points, but this would disallow existing correct code. Instead, only the
array of pointers is noted as constant. The table of assignment compatibility for dst=src derived from the ISO C
standard summarizes the compatibility:
dst:
char *[]
const char *[]
char *const[]
const char *const[]
src:
char *[]
VALID
—
VALID
—
const char *[]
—
VALID
—
VALID
char * const []
—
—
VALID
—
const char *const[]
—
—
—
VALID
Since all existing code has a source type matching the first row, the column that gives the most valid combinations
is the third column. The only other possibility is the fourth column, but using it would require a cast on the argv or
envp arguments. It is unfortunate that the fourth column cannot be used, because the declaration a non-expert would
naturally use would be that in the second row.
The ISO C standard and this volume of POSIX.1-2024 do not conflict on the use of environ, but some
historical implementations of environ may cause a conflict. As long as environ is treated in the same way as an entry
point (for example, fork()), it conforms to both standards. A library can contain
fork(), but if there is a user-provided fork(), that fork() is given precedence and no
problem ensues. The situation is similar for environ: the definition in this volume of POSIX.1-2024 is to be used if there
is no user-provided environ to take precedence. At least three implementations are known to exist that solve this
problem.
[E2BIG]
The limit {ARG_MAX} applies not just to the size of the argument list, but to the sum of that and the size of the environment
list.
[EFAULT]
Some historical systems return [EFAULT] rather than [ENOEXEC] when the new process image file is corrupted. They are
non-conforming.
[EINVAL]
This error condition was added to POSIX.1-2024 to allow an implementation to detect executable files generated for different
architectures, and indicate this situation to the application. Historical implementations of shells, execvp(), and
execlp() that encounter an [ENOEXEC] error will execute a shell on the assumption that the file is a shell script. This will
not produce the desired effect when the file is a valid executable for a different architecture. An implementation may now choose
to avoid this problem by returning [EINVAL] when a valid executable for a different architecture is encountered. Some historical
implementations return [EINVAL] to indicate that the path argument contains a character with the high order bit set. The
standard developers chose to deviate from historical practice for the following reasons:
The new utilization of [EINVAL] will provide some measure of utility to the user community.
Historical use of [EINVAL] is not acceptable in an internationalized operating environment.
[ENAMETOOLONG]
Since the file pathname may be constructed by taking elements in the PATH variable and putting them together with the
filename, the [ENAMETOOLONG] error condition could also be reached this way.
[ETXTBSY]
System V returns this error when the executable file is currently open for writing by some process. This volume of POSIX.1-2024
neither requires nor prohibits this behavior.
Other systems (such as System V) may return [EINTR] from exec. This is not addressed by this volume of
POSIX.1-2024, but implementations may have a window between the call to exec and the time that a signal could cause one of
the exec calls to return with [EINTR].
An explicit statement regarding the floating-point environment (as defined in the  header) was added to make it clear that the floating-point environment is set
to its default when a call to one of the exec functions succeeds. The requirements for inheritance or setting to the default
for other process and thread start-up functions is covered by more generic statements in their descriptions and can be summarized
as follows:
posix_spawn()
Set to default.
fork()
Inherit.
pthread_create()
Inherit.
The purpose of the fexecve() function is to enable executing a file which has been verified to be the
intended file. It is possible to actively check the file by reading from the file descriptor and be sure that the file is not
exchanged for another between the reading and the execution. Alternatively, a function like openat() can be used to open a file which has been found by reading the content of a
directory using readdir().
When execlp() or execvp() fall back to invoking sh because
of an [ENOEXEC] condition, the standard leaves the process name (what becomes argv[0] in the resulting sh process) unspecified. Existing implementations vary on whether they pass a variation of
"sh", or preserve the original arg0. There are existing implementations of sh that behave differently depending on the contents of argv[0], such that blindly passing
the original arg0 on to the fallback execution can fail to invoke a compliant shell environment. Because of the requirements
on how sh handles its command line arguments, the shell script will see $0
containing the pathname of the script being executed, regardless of the value of argv[0].
FUTURE DIRECTIONS
None.
SEE ALSO
alarm(), atexit(), chmod(), close(), confstr(), exit(), fcntl(), fork(), fstatvfs(), getenv(), getrlimit(), mknod(), mmap(), nice(), open(), posix_spawn(), pthread_atfork(), pthread_sigmask(), putenv(),
readdir(), semop(), setlocale(), shmat(), sigaction(), sigaltstack(),
sigpending(), system(),
times(), umask()
XBD 8. Environment Variables,
XCU test
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Realtime Extension and the POSIX Threads Extension.
Large File Summit extensions are added.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the DESCRIPTION, behavior is defined for when the process image file is not a valid executable.
In this version, _POSIX_SAVED_IDS is mandated, thus the effective user ID and effective group ID of the new
process image shall be saved (as the saved set-user-ID and the saved set-group-ID) for use by the setuid() function.
The [ELOOP] mandatory error condition is added.
A second [ENAMETOOLONG] is added as an optional error condition.
The [ETXTBSY] optional error condition is added.
The following changes were made to align with the IEEE P1003.1a draft standard:
The [EINVAL] mandatory error condition is added.
The [ELOOP] optional error condition is added.
The description of CPU-time clock semantics is added for alignment with IEEE Std 1003.1d-1999.
The DESCRIPTION is updated for alignment with IEEE Std 1003.1j-2000 by adding semantics for typed
memory.
The normative text is updated to avoid use of the term "must" for application requirements.
The description of tracing semantics is added for alignment with IEEE Std 1003.1q-2000.
IEEE PASC Interpretation 1003.1 #132 is applied.
The DESCRIPTION is updated to make it explicit that the floating-point environment in the new process image is set
to the default.
The DESCRIPTION and RATIONALE are updated to include clarifications of how the contents of a process image file
affect the behavior of the exec functions.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/15 is applied, adding a new paragraph to the
DESCRIPTION and text to the end of the APPLICATION USAGE section. This change addresses a security concern, where implementations
may want to reopen file descriptors 0, 1, and 2 for programs with the set-user-id or set-group-id file mode bits calling the
exec family of functions.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/24 is applied, applying changes to the DESCRIPTION,
addressing which attributes are inherited by threads, and behavioral requirements for threads attributes.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/25 is applied, updating text in the RATIONALE from
"the process signal mask be unchanged across an exec" to "the new process image inherits the signal mask of the thread
that called exec in the old process image".
Issue 7
Austin Group Interpretation 1003.1-2001 #047 is applied, adding the description of _CS_V7_ENV to the APPLICATION USAGE.
Austin Group Interpretation 1003.1-2001 #143 is applied.
The fexecve() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 2.
Functionality relating to the Asynchronous Input and Output, Memory Mapped Files, Threads, and Timers options is
moved to the Base.
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0095 [386], XSH/TC1-2008/0096 [167], XSH/TC1-2008/0097 [291],
XSH/TC1-2008/0098 [173], XSH/TC1-2008/0099 [296], XSH/TC1-2008/00100 [324], XSH/TC1-2008/00101 [296], XSH/TC1-2008/00102 [302],
XSH/TC1-2008/00103 [167], XSH/TC1-2008/00104 [173], and XSH/TC1-2008/00105 [291,429] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0097 [584], XSH/TC2-2008/0098 [898], and XSH/TC2-2008/0099
[734] are applied.
Issue 8
Austin Group Defects 51 and 1669 are applied, moving the getrlimit() and
setrlimit() functions from the XSI option to the Base.
Austin Group Defect 368 is applied, adding a requirement for unnamed semaphores to be destroyed.
Austin Group Defect 768 is applied, adding OFD-owned file locks.
Austin Group Defect 922 is applied, adding the secure_getenv()
function.
Austin Group Defect 1284 is applied, changing "checksum test" to "integrity test" in the APPLICATION USAGE
section.
Austin Group Defect 1318 is applied, adding FD_CLOFORK.
Austin Group Defect 1330 is applied, removing obsolescent interfaces and changing "_V7_" to "_V8_".
Austin Group Defect 1435 is applied, adding function lists to the descriptions of the path and file
arguments.
Austin Group Defect 1645 is applied, making it unspecified what string is passed to the shell in argv[0]
when executed by execlp() or execvp().
Austin Group Defect 1646 is applied, adding at_quick_exit() to
the list of registration functions whose registrations are not inherited across exec.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fmemopen.html =====
fmemopen
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fmemopen — open a memory buffer stream
SYNOPSIS
[CX]  #include
FILE *fmemopen(void *restrict buf, size_t max_size,
const char *restrict mode);
DESCRIPTION
The fmemopen() function shall associate the buffer given by the buf and max_size arguments with a stream.
The buf argument shall be either a null pointer or point to a buffer that is at least max_size bytes long.
The mode argument points to a string. If the string is one of the following, the stream shall be opened in the indicated
mode. Otherwise, the behavior is undefined.
r or rb
Open the stream for reading.
w or wb
Open the stream for writing.
a or ab
Append; open the stream for writing.
r+ or rb+ or r+b
Open the stream for update (reading and writing).
w+ or wb+ or w+b
Open the stream for update (reading and writing).
a+ or ab+ or a+b
Append; open the stream for update (reading and writing).
If the mode argument begins with 'w' and max_size is not zero, the buffer contents shall be truncated by
writing a null byte at the beginning. If the mode argument includes 'b', the results are
implementation-defined.
If a null pointer is specified as the buf argument, fmemopen() shall allocate max_size bytes of memory as
if by a call to malloc(). This buffer shall be automatically freed when the stream is
closed. Because this feature is only useful when the stream is opened for updating (because there is no way to get a pointer to the
buffer) the fmemopen() call may fail if the mode argument does not include a '+'.
When a stream is opened for reading only and buf is not a null pointer, the buffer pointed to by buf shall not be
modified by any operation performed on the stream.
The stream shall maintain a current position in the buffer. This position shall be initially set to either the beginning of the
buffer (for r and w modes) or to the first null byte in the buffer (for a modes). If no null byte is found in
append mode, the initial position shall be set to one byte after the end of the buffer.
If buf is a null pointer, the initial position shall always be set to the beginning of the buffer.
The stream shall also maintain the end position of the current buffer contents; use of fseek() or fseeko() on the stream with SEEK_END
shall seek relative to this end position. If mode starts with 'r', the end position shall be set to the value given
by the max_size argument and shall not change. Otherwise, the stream is writable and the end position shall be variable; for
modes w and w+ the initial end position shall be zero and for modes a and a+ the initial end position
shall be:
Zero, if buf is a null pointer
The position of the first null byte in the buffer, if one is found
The value of the max_size argument, if buf is not a null pointer and no null byte is found
A read operation on the stream shall not advance the current buffer position beyond the current buffer end position. Reaching
the buffer end position in a read operation shall count as "end-of-file". Null bytes in the buffer shall have no special meaning
for reads. The read operation shall start at the current buffer position of the stream.
A write operation shall start either at the current position of the stream (if mode has not specified 'a' as the
first character) or at the current end position of the stream (if mode had 'a' as the first character). If the
current position at the end of the write is larger than the current buffer end position, the current buffer end position shall be
set to the current position. A write operation on the stream shall not advance the current buffer end position beyond the size
given in the max_size argument.
When a stream open for update (the mode argument includes '+') or for writing only is successfully written and
the write advances the current buffer end position, a null byte shall be written at the new buffer end position if it fits.
An attempt to seek a memory buffer stream to a negative position or to a position larger than the buffer size given in the
max_size argument shall fail.
RETURN VALUE
Upon successful completion, fmemopen() shall return a pointer to the object controlling the stream. Otherwise, a null
pointer shall be returned, and errno shall be set to indicate the error.
ERRORS
The fmemopen() function shall fail if:
[EMFILE]
{STREAM_MAX} streams are currently open in the calling process.
The fmemopen() function may fail if:
[EINVAL]
The value of the mode argument is not valid.
[EINVAL]
The buf argument is a null pointer and the mode argument does not include a '+' character.
[EINVAL]
The max_size argument specifies a buffer size of zero and the implementation does not support this.
[ENOMEM]
The buf argument is a null pointer and the allocation of a buffer of length max_size has failed.
[EMFILE]
{FOPEN_MAX} streams are currently open in the calling process.
The following sections are informative.
EXAMPLES
#include
#include
static char buffer[] = "foobar";
int
main (void)
{
int ch;
FILE *stream;
stream = fmemopen(buffer, strlen (buffer), "r");
if (stream == NULL)
/* handle error */;
while ((ch = fgetc(stream)) != EOF)
printf("Got %c\n", ch);
fclose(stream);
return (0);
}
This program produces the following output:
Got f
Got o
Got o
Got b
Got a
Got r
APPLICATION USAGE
Implementations differ as regards how a 'b' in the mode argument affects the behavior. For some the 'b'
has no effect, as is required for fopen(); others distinguish between text and binary
modes.
Note that buf will not be null terminated if max_size bytes are written to the memory stream. Applications wanting
to guarantee that the buffer will be null terminated need to call fmemopen() with max_size set to one byte smaller
than the actual size of buf and set buf[max_size] to a null byte.
This standard intentionally leaves the behavior of 'e' and 'x' in the mode argument undefined;
implementations might silently ignore them so that fmemopen() may accept the same mode strings as fopen(), or may reject them as invalid.
RATIONALE
This interface has been introduced to eliminate many of the errors encountered in the construction of strings, notably
overflowing of strings. This interface prevents overflow.
FUTURE DIRECTIONS
A future version of this standard may require support of zero-length buffer streams explicitly.
SEE ALSO
fdopen(), fopen(), freopen(), fseek(), malloc(), open_memstream()
XBD
CHANGE HISTORY
First released in Issue 7.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0142 [461], XSH/TC1-2008/0143 [396], XSH/TC1-2008/0144 [396],
XSH/TC1-2008/0145 [461], XSH/TC1-2008/0146 [461], XSH/TC1-2008/0147 [461], XSH/TC1-2008/0148 [461], XSH/TC1-2008/0149 [461], and
XSH/TC1-2008/0150 [396] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0117 [587], XSH/TC2-2008/0118 [586,818], and XSH/TC2-2008/0119 [818] are
applied.
Issue 8
Austin Group Defects 456 and 657 are applied, making the behavior implementation-defined when the mode argument includes
'b'.
Austin Group Defect 1144 is applied, adding a requirement that operations on streams opened for reading only do not modify the
buffer pointed to by buf.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mknodat.html =====
mknod
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mknod, mknodat — make directory, special file, or regular file
SYNOPSIS
[XSI]  #include
int mknod(const char *path, mode_t mode, dev_t dev);
[OH] #include
[XSI]  int mknodat(int fd, const char *path, mode_t mode,
dev_t dev);
DESCRIPTION
The mknod() function shall create a new file named by the pathname to which the argument path points.
The file type for path is OR'ed into the mode argument, and the application shall select one of the following
symbolic constants:
Name
Description
S_IFIFO
FIFO-special
S_IFCHR
Character-special (non-portable)
S_IFDIR
Directory (non-portable)
S_IFBLK
Block-special (non-portable)
S_IFREG
Regular (non-portable)
The only portable use of mknod() is to create a FIFO-special file. If mode is not S_IFIFO or
dev is not 0, the behavior of mknod() is unspecified.
The permissions for the new file are OR'ed into the mode argument, and may be selected from any combination
of the following symbolic constants:
Name
Description
S_ISUID
Set user ID on execution.
S_ISGID
Set group ID on execution.
S_IRWXU
Read, write, or execute (search) by owner.
S_IRUSR
Read by owner.
S_IWUSR
Write by owner.
S_IXUSR
Execute (search) by owner.
S_IRWXG
Read, write, or execute (search) by group.
S_IRGRP
Read by group.
S_IWGRP
Write by group.
S_IXGRP
Execute (search) by group.
S_IRWXO
Read, write, or execute (search) by others.
S_IROTH
Read by others.
S_IWOTH
Write by others.
S_IXOTH
Execute (search) by others.
S_ISVTX
On directories, restricted deletion flag.
The user ID of the file shall be initialized to the effective user ID of the process. The group ID of the file
shall be initialized to either the effective group ID of the process or the group ID of the parent directory. Implementations shall
provide a way to initialize the file's group ID to the group ID of the parent directory. Implementations may, but need not, provide
an implementation-defined way to initialize the file's group ID to the effective group ID of the calling process. The owner, group,
and other permission bits of mode shall be modified by the file mode creation mask of the process. The mknod()
function shall clear each bit whose corresponding bit in the file mode creation mask of the process is set.
If path names a symbolic link, mknod() shall fail and set errno to [EEXIST].
Upon successful completion, mknod() shall mark for update the last data access, last data modification, and
last file status change timestamps of the file. Also, the last data modification and last file status change timestamps of the
directory that contains the new entry shall be marked for update.
Only a process with appropriate privileges may invoke mknod() for file types other than FIFO-special.
The mknodat() function shall be equivalent to the mknod() function except in the case where
path specifies a relative path. In this case the newly created directory, special file, or regular file is located relative
to the directory associated with the file descriptor fd instead of the current working directory. If the access mode of the
open file description associated with the file descriptor is not O_SEARCH, the function shall check whether directory searches are
permitted using the current permissions of the directory underlying the file descriptor. If the access mode is O_SEARCH, the
function shall not perform the check.
If mknodat() is passed the special value AT_FDCWD in the fd parameter, the current working directory
shall be used and the behavior shall be identical to a call to mknod().
RETURN VALUE
Upon successful completion, these functions shall return 0. Otherwise, these functions shall return -1 and set errno to
indicate the error. If -1 is returned, the new file shall not be created.
ERRORS
These functions shall fail if:
[EACCES]
A component of the path prefix denies search permission, or write permission is denied on the parent directory.
[EEXIST]
The named file exists.
[EILSEQ]
The last pathname component of path is not a portable filename, and cannot be created in the target directory.
[EINVAL]
An invalid argument exists.
[EIO]
An I/O error occurred while accessing the file system.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of the path prefix of path does not name an existing file or path is an empty string.
[ENOENT] or [ENOTDIR]
The path argument contains at least one non- character and ends with one or more trailing
characters. If path without the trailing  characters would name an existing file, an [ENOENT] error shall not
occur.
[ENOSPC]
The directory that would contain the new file cannot be extended or the file system is out of file allocation resources.
[ENOTDIR]
A component of the path prefix names an existing file that is neither a directory nor a symbolic link to a directory.
[EPERM]
The invoking process does not have appropriate privileges and the file type is not FIFO-special.
[EROFS]
The directory in which the file is to be created is located on a read-only file system.
The mknodat() function shall fail if:
[EACCES]
The access mode of the open file description associated with fd is not O_SEARCH and the permissions of the directory
underlying fd do not permit directory searches.
[EBADF]
The path argument does not specify an absolute path and the fd argument is neither AT_FDCWD nor a valid file
descriptor open for reading or searching.
[ENOTDIR]
The path argument is not an absolute path and fd is a file descriptor associated with a non-directory file.
These functions may fail if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
The following sections are informative.
EXAMPLES
Creating a FIFO Special File
The following example shows how to create a FIFO special file named /home/cnd/mod_done, with read/write
permissions for owner, and with read permissions for group and others.
#include
#include
dev_t dev;
int   status;
...
status  = mknod("/home/cnd/mod_done", S_IFIFO | S_IWUSR |
S_IRUSR | S_IRGRP | S_IROTH, dev);
APPLICATION USAGE
The mkfifo() function is preferred over this function for making FIFO special
files.
RATIONALE
The POSIX.1-1990 standard required that the group ID of a newly created file be set to the group ID of its parent directory or
to the effective group ID of the creating process. FIPS 151-2 required that implementations provide a way to have the group ID be
set to the group ID of the containing directory, but did not prohibit implementations also supporting a way to set the group ID to
the effective group ID of the creating process. Conforming applications should not assume which group ID will be used. If it
matters, an application can use chown() to set the group ID after the file is created,
or determine under what conditions the implementation will set the desired group ID.
The purpose of the mknodat() function is to create directories, special files, or regular files in
directories other than the current working directory without exposure to race conditions. Any part of the path of a file could be
changed in parallel to a call to mknod(), resulting in unspecified behavior. By opening a file descriptor for the target
directory and using the mknodat() function it can be guaranteed that the newly created directory, special file, or regular
file is located relative to the desired directory.
Implementations are encouraged to have mknod() and mknodat() report an [EILSEQ] error if the last
component of path contains any bytes that have the encoded value of a  character.
FUTURE DIRECTIONS
None.
SEE ALSO
chmod(), creat(),
exec, fstatat(), mkdir(), mkfifo(), open(), umask()
XBD ,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
The wording of the mandatory [ELOOP] error condition is updated, and a second optional [ELOOP] error condition is
added.
Issue 7
Austin Group Interpretation 1003.1-2001 #143 is applied.
The mknodat() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 2.
Changes are made related to support for finegrained timestamps.
Changes are made to allow a directory to be opened for searching.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0388 [324], XSH/TC1-2008/0389 [461], XSH/TC1-2008/0390
[146,435], XSH/TC1-2008/0391 [278], and XSH/TC1-2008/0392 [278] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0222 [591], XSH/TC2-2008/0223 [817], XSH/TC2-2008/0224 [822],
XSH/TC2-2008/0225 [817], and XSH/TC2-2008/0226 [591] are applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defect 293 is applied, adding the [EILSEQ] error.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fchownat.html =====
chown
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
chown, fchownat — change owner and group of a file
SYNOPSIS
#include
int chown(const char *path, uid_t owner, gid_t group);
[OH] #include
int fchownat(int fd, const char *path, uid_t owner, gid_t
group,
int flag);
DESCRIPTION
The chown() function shall change the user and group ownership of a file.
The path argument points to a pathname naming a file. The user ID and group ID of the named file shall be set to the
numeric values contained in owner and group, respectively.
Only processes with an effective user ID equal to the user ID of the file or with appropriate privileges may change the
ownership of a file. If _POSIX_CHOWN_RESTRICTED is in effect for path:
Changing the user ID is restricted to processes with appropriate privileges.
Changing the group ID is permitted to a process with an effective user ID equal to the user ID of the file, but without
appropriate privileges, if and only if owner is equal to the file's user ID or (uid_t)-1 and group is equal
either to the calling process' effective group ID or to one of its supplementary group IDs.
If the specified file is a regular file, one or more of the S_IXUSR, S_IXGRP, or S_IXOTH bits of the file mode are set, and the
process does not have appropriate privileges, the set-user-ID (S_ISUID) and set-group-ID (S_ISGID) bits of the file mode shall be
cleared upon successful return from chown(). If the specified file is a regular file, one or more of the S_IXUSR, S_IXGRP,
or S_IXOTH bits of the file mode are set, and the process has appropriate privileges, it is implementation-defined whether the
set-user-ID and set-group-ID bits are altered. If the chown() function is successfully invoked on a file that is not a
regular file and one or more of the S_IXUSR, S_IXGRP, or S_IXOTH bits of the file mode are set, the set-user-ID and set-group-ID
bits may be cleared.
If owner or group is specified as (uid_t)-1 or (gid_t)-1, respectively, the corresponding ID of the
file shall not be changed.
Upon successful completion, chown() shall mark for update the last file status change timestamp of the file, except that
if owner is (uid_t)-1 and group is (gid_t)-1, the file status change timestamp need not be marked for
update.
The fchownat() function shall be equivalent to the chown() and lchown() functions except in the case where path specifies a relative path. In this
case the file to be changed is determined relative to the directory associated with the file descriptor fd instead of the
current working directory. If the access mode of the open file description associated with the file descriptor is not O_SEARCH, the
function shall check whether directory searches are permitted using the current permissions of the directory underlying the file
descriptor. If the access mode is O_SEARCH, the function shall not perform the check.
Values for flag are constructed by a bitwise-inclusive OR of flags from the following list, defined in :
AT_SYMLINK_NOFOLLOW
If path names a symbolic link, ownership of the symbolic link is changed.
If fchownat() is passed the special value AT_FDCWD in the fd parameter, the current working directory shall be
used and the behavior shall be identical to a call to chown() or lchown()
respectively, depending on whether or not the AT_SYMLINK_NOFOLLOW bit is set in the flag argument.
RETURN VALUE
Upon successful completion, these functions shall return 0. Otherwise, these functions shall return -1 and set errno to
indicate the error. If -1 is returned, no changes are made in the user ID and group ID of the file.
ERRORS
These functions shall fail if:
[EACCES]
Search permission is denied on a component of the path prefix.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of path does not name an existing file or path is an empty string.
[ENOTDIR]
A component of the path prefix names an existing file that is neither a directory nor a symbolic link to a directory, or the
path argument contains at least one non- character and ends with one or more trailing  characters
and the last pathname component names an existing file that is neither a directory nor a symbolic link to a directory.
[EPERM]
The effective user ID does not match the owner of the file, or the calling process does not have appropriate privileges and
_POSIX_CHOWN_RESTRICTED indicates that such privilege is required.
[EROFS]
The named file resides on a read-only file system.
The fchownat() function shall fail if:
[EACCES]
The access mode of the open file description associated with fd is not O_SEARCH and the permissions of the directory
underlying fd do not permit directory searches.
[EBADF]
The path argument does not specify an absolute path and the fd argument is neither AT_FDCWD nor a valid file
descriptor open for reading or searching.
[ENOTDIR]
The path argument is not an absolute path and fd is a file descriptor associated with a non-directory file.
These functions may fail if:
[EIO]
An I/O error occurred while reading or writing to the file system.
[EINTR]
The chown() function was interrupted by a signal which was caught.
[EINVAL]
The owner or group ID supplied is not a value supported by the implementation.
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
The fchownat() function may fail if:
[EINVAL]
The value of the flag argument is not valid.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Although chown() can be used on some implementations by the file owner to change the owner and group to any desired
values, the only portable use of this function is to change the group of a file to the effective GID of the calling process or to a
member of its group set.
RATIONALE
System III and System V allow a user to give away files; that is, the owner of a file may change its user ID to anything. This
is a serious problem for implementations that are intended to meet government security regulations. Version 7 and 4.3 BSD permit
only the superuser to change the user ID of a file. Some government agencies (usually not ones concerned directly with security)
find this limitation too confining. This volume of POSIX.1-2024 uses may to permit secure implementations while not
disallowing System V.
System III and System V allow the owner of a file to change the group ID to anything. Version 7 permits only the superuser to
change the group ID of a file. 4.3 BSD permits the owner to change the group ID of a file to its effective group ID or to any of
the groups in the list of supplementary group IDs, but to no others.
The POSIX.1-1990 standard requires that the chown() function invoked by a non-appropriate privileged process clear the
S_ISGID and the S_ISUID bits for regular files, and permits them to be cleared for other types of files. This is so that changes in
accessibility do not accidentally cause files to become security holes. Unfortunately, requiring these bits to be cleared on
non-executable data files also clears the mandatory file locking bit (shared with S_ISGID), which is an extension on many
implementations (it first appeared in System V). These bits should only be required to be cleared on regular files that have one or
more of their execute bits set.
The purpose of the fchownat() function is to enable changing ownership of files in directories other than the current
working directory without exposure to race conditions. Any part of the path of a file could be changed in parallel to a call to
chown() or lchown(), resulting in unspecified behavior. By opening a file
descriptor for the target directory and using the fchownat() function it can be guaranteed that the changed file is located
relative to the desired directory.
FUTURE DIRECTIONS
None.
SEE ALSO
chmod(), fpathconf(),
lchown()
XBD , ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The following changes are made for alignment with the ISO POSIX-1:1996 standard:
The wording describing the optional dependency on _POSIX_CHOWN_RESTRICTED is restored.
The [EPERM] error is restored as an error dependent on _POSIX_CHOWN_RESTRICTED. This is since its operand is a pathname and
applications should be aware that the error may not occur for that pathname if the file system does not support
_POSIX_CHOWN_RESTRICTED.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
The value for owner of (uid_t)-1 allows the use of -1 by the owner of a file to change the group ID only. A
corresponding change is made for group.
The [ELOOP] mandatory error condition is added.
The [EIO] and [EINTR] optional error conditions are added.
A second [ENAMETOOLONG] is added as an optional error condition.
The following changes were made to align with the IEEE P1003.1a draft standard:
Clarification is added that the S_ISUID and S_ISGID bits do not need to be cleared when the process has appropriate
privileges.
The [ELOOP] optional error condition is added.
Issue 7
Austin Group Interpretation 1003.1-2001 #143 is applied.
The fchownat() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 2.
Changes are made related to support for finegrained timestamps.
Changes are made to allow a directory to be opened for searching.
The [ENOTDIR] error condition is clarified to cover the condition where the last component of a pathname exists but is not a
directory or a symbolic link to a directory.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0053 [461], XSH/TC1-2008/0054 [324], XSH/TC1-2008/0055 [278], and
XSH/TC1-2008/0056 [278] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0062 [873], XSH/TC2-2008/0063 [591], XSH/TC2-2008/0064 [485],
XSH/TC2-2008/0065 [817], and XSH/TC2-2008/0066 [817] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/waitid.html =====
waitid
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
waitid — wait for a child process to change state
SYNOPSIS
#include
int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int
options);
DESCRIPTION
The waitid() function shall obtain status information (see 2.12 Status
Information) pertaining to termination, stop, and/or continue events in one of the caller's child processes.
The waitid() function shall cause the calling thread to become blocked until an error occurs or status information
becomes available to the calling thread that satisfies all of the following properties ("matching status information"):
The status information is from one of the child processes in the set of child processes specified by the idtype and
id arguments.
The state change in the status information matches one of the state change flags set in the options argument.
If matching status information is available prior to the call to waitid(), return shall be immediate. If matching status
information is available for two or more child processes, the order in which their status is reported is unspecified.
As described in 2.12 Status Information, the waitid()
function consumes the status information it obtains unless the WNOWAIT flag is set in the options argument.
The behavior when multiple threads are blocked in wait(), waitid(), or
waitpid() is described in 2.12
Status Information.
The waitid() function shall record the obtained status information in the structure pointed to by infop. The
fields of the structure pointed to by infop shall be filled in as described under "Pointer to a Function" in 2.4.3 Signal Actions.
The idtype and id arguments are used to specify which children waitid() waits for.
If idtype is P_PID, waitid() shall wait for the child with a process ID equal to (pid_t)id.
If idtype is P_PGID, waitid() shall wait for any child with a process group ID equal to
(pid_t)id.
If idtype is P_ALL, waitid() shall wait for any children and id is ignored.
The options argument is used to specify which state changes waitid() shall wait for. It is formed by OR'ing
together the following flags:
WCONTINUED
Status shall be returned for any continued child process whose status either has not been reported since it continued from a
job control stop or has been reported only by calls to waitid() with the WNOWAIT flag set.
WEXITED
Wait for processes that have terminated.
WNOHANG
Do not hang if no status is available; return immediately.
WNOWAIT
Keep the process whose status is returned in infop in a waitable state. This shall not affect the state of the process;
the process may be waited for again after this call completes.
WSTOPPED
Status shall be returned for any child that has stopped upon receipt of a signal, and whose status either has not been reported
since it stopped or has been reported only by calls to waitid() with the WNOWAIT flag set.
Applications shall specify at least one of the flags WEXITED, WSTOPPED, or WCONTINUED to be OR'ed in with the options
argument.
The application shall ensure that the infop argument points to a siginfo_t structure. If waitid() returns
because a child process was found that satisfied the conditions indicated by the arguments idtype and options, then
the structure pointed to by infop shall be filled in by the system with the status of the process; the si_signo
member shall be set equal to SIGCHLD. If waitid() returns because WNOHANG was specified and status is not available for any
process specified by idtype and id, then the si_signo and si_pid members of the structure pointed to by
infop shall be set to zero and the values of other members of the structure are unspecified.
RETURN VALUE
If WNOHANG was specified and status is not available for any process specified by idtype and id, 0 shall be
returned. If waitid() returns due to the change of state of one of its children, 0 shall be returned. Otherwise, -1 shall be
returned and errno set to indicate the error.
ERRORS
The waitid() function shall fail if:
[ECHILD]
The calling process has no existing unwaited-for child processes.
[EINTR]
The waitid() function was interrupted by a signal. The values of the fields of the structure pointed to by infop
are undefined.
[EINVAL]
An invalid value was specified for options, or idtype and id specify an invalid set of processes.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Calls to waitid() with idtype equal to P_ALL will collect information about any child process. This may result in
interactions with other interfaces that may be waiting for their own children (such as by use of system()). For this reason it is recommended that portable applications not use
waitid() with idtype of P_ALL. See also APPLICATION USAGE for wait().
[XSI]
As specified in Consequences of Process Termination(), if the calling
process has SA_NOCLDWAIT set or has SIGCHLD set to SIG_IGN, then the termination of a child process will not cause status
information to become available to a thread blocked in wait(), waitid(), or
waitpid(). Thus, a thread blocked in one of the wait functions will remain blocked
unless some other condition causes the thread to resume execution (such as an [ECHILD] failure due to no remaining children in the
set of waited-for children).
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.4.3 Signal Actions, 2.12 Status Information, exec, exit(), wait()
XBD ,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
The DESCRIPTION is updated for alignment with the POSIX Threads Extension.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
Austin Group Interpretation 1003.1-2001 #060 is applied, updating the DESCRIPTION.
The waitid() function is moved from the XSI option to the Base.
APPLICATION USAGE is added, recommending that the waitid() function not be used with idtype equal to P_ALL.
The description of the WNOHANG flag is updated.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0711 [154], XSH/TC1-2008/0712 [154], and XSH/TC1-2008/0713 [153] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0387 [690] is applied.
Issue 8
Austin Group Defect 1332 is applied, changing the description of WEXITED.
Austin Group Defect 1547 is applied, changing the description of [EINTR].
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/iconv_open.html =====
iconv_open
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
iconv_open — codeset conversion allocation function
SYNOPSIS
#include
iconv_t iconv_open(const char *tocode, const char *fromcode);
DESCRIPTION
The iconv_open() function shall return a conversion descriptor that describes a conversion from the codeset specified by
the string pointed to by the fromcode argument to the codeset specified by the string pointed to by the tocode
argument. For state-dependent encodings, the conversion descriptor shall be in a codeset-dependent initial shift state, ready for
immediate use with iconv().
The codeset names that can be specified in fromcode and tocode and their permitted combinations are
implementation-defined. Any one of the following indicator suffixes can be appended to the codeset name in tocode:
//IGNORE
Discard input bytes that do not form a valid character or shift sequence, and discard input characters for which an identical
character does not exist in the output codeset.
//NON_IDENTICAL_DISCARD
Discard input characters for which an identical character does not exist in the output codeset.
//TRANSLIT
Transliterate input characters for which an identical character does not exist in the output codeset into one or more
characters of the output codeset that best resemble the input character.
See the description of iconv() for details of how these indicator suffixes alter
the conversion performed by iconv(). Additional implementation-defined indicator
suffixes may be supported.
A conversion descriptor shall remain valid until it is closed by iconv_close() or an implicit close.
If a file descriptor is used to implement conversion descriptors, the FD_CLOEXEC flag shall be set; see .
RETURN VALUE
Upon successful completion, iconv_open() shall return a conversion descriptor for use on subsequent calls to iconv(). Otherwise, iconv_open() shall return (iconv_t)-1 and set errno
to indicate the error.
ERRORS
The iconv_open() function may fail if:
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
Too many files are currently open in the system.
[ENOMEM]
Insufficient storage space is available.
[EINVAL]
Conversion from the codeset specified in fromcode to the codeset specified in tocode is not supported by the
implementation, or the codeset name in tocode is followed by an indicator suffix that is unrecognized or not supported.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Some implementations of iconv_open() use malloc() to allocate space for
internal buffer areas. The iconv_open() function may fail if there is insufficient storage space to accommodate these
buffers.
Conforming applications must assume that conversion descriptors are not valid after a call to one of the exec functions.
Application developers should consult the system documentation to determine the supported codesets and their naming schemes.
Some implementations of iconv_open() allow appending multiple indicator suffixes to the codeset name in tocode,
and some allow appending an indicator suffix (or suffixes) in both fromcode and tocode. Portable applications should
append at most one indicator suffix, and append it only in tocode.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
iconv(), iconv_close()
XBD ,
CHANGE HISTORY
First released in Issue 4. Derived from the HP-UX Manual.
Issue 7
SD5-XBD-ERN-4 is applied, changing the definition of the [EMFILE] error.
The iconv_open() function is moved from the XSI option to the Base.
Issue 8
Austin Group Defect 1007 is applied, adding support for indicator suffixes in the tocode argument to
iconv_open().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/putc_unlocked.html =====
getc_unlocked
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getc_unlocked, getchar_unlocked, putc_unlocked, putchar_unlocked — stdio with explicit client locking
SYNOPSIS
[CX]  #include
int getc_unlocked(FILE *stream);
int getchar_unlocked(void);
int putc_unlocked(int c, FILE *stream);
int putchar_unlocked(int c);
DESCRIPTION
Versions of the functions getc(), getchar(), putc(), and putchar() respectively named getc_unlocked(), getchar_unlocked(),
putc_unlocked(), and putchar_unlocked() shall be provided which are functionally equivalent to the original versions,
with the exception that they are not required to be implemented in a fully thread-safe manner. They shall be thread-safe when used
within a scope protected by flockfile() (or ftrylockfile()) and funlockfile().
These functions can safely be used in a multi-threaded program if and only if they are called while the invoking thread owns the
(FILE *) object, as is the case after a successful call to the flockfile()
or ftrylockfile() functions.
If getc_unlocked() or putc_unlocked() are implemented as macros they may evaluate stream more than once, so
the stream argument should never be an expression with side-effects.
RETURN VALUE
See getc(), getchar(), putc(), and putchar().
ERRORS
See getc(), getchar(), putc(), and putchar().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Since they may be implemented as macros, getc_unlocked() and putc_unlocked() may treat incorrectly a stream
argument with side-effects. In particular, getc_unlocked(*f++) and putc_unlocked(c,*f++) do not necessarily work as
expected. Therefore, use of these functions in such situations should be preceded by the following statement as appropriate:
#undef getc_unlocked
#undef putc_unlocked
RATIONALE
Some I/O functions are typically implemented as macros for performance reasons (for example, putc() and getc()). For safety, they need to be
synchronized, but it is often too expensive to synchronize on every character. Nevertheless, it was felt that the safety concerns
were more important; consequently, the getc(), getchar(), putc(), and putchar() functions are required to be thread-safe. However, unlocked versions are also
provided with names that clearly indicate the unsafe nature of their operation but can be used to exploit their higher performance.
These unlocked versions can be safely used only within explicitly locked program regions, using exported locking primitives. In
particular, a sequence such as:
flockfile(fileptr);
putc_unlocked('1', fileptr);
putc_unlocked('\n', fileptr);
fprintf(fileptr, "Line 2\n");
funlockfile(fileptr);
is permissible, and results in the text sequence:
1
Line 2
being printed without being interspersed with output from other threads.
It would be wrong to have the standard names such as getc(), putc(), and so on, map to the "faster, but unsafe" rather than the "slower, but safe"
versions. In either case, you would still want to inspect all uses of getc(), putc(), and so on, by hand when converting existing code. Choosing the safe bindings as the
default, at least, results in correct code and maintains the "atomicity at the function" invariant. To do otherwise would
introduce gratuitous synchronization errors into converted code. Other routines that modify the stdio (FILE *)
structures or buffers are also safely synchronized.
Note that there is no need for functions of the form getc_locked(), putc_locked(), and so on, since this is the
functionality of getc(), putc(), et
al. It would be inappropriate to use a feature test macro to switch a macro definition of getc() between getc_locked() and getc_unlocked(), since the ISO C standard
requires an actual function to exist, a function whose behavior could not be changed by the feature test macro. Also, providing
both the xxx_locked() and xxx_unlocked() forms leads to the confusion of whether the suffix describes the behavior of
the function or the circumstances under which it should be used.
Three additional routines, flockfile(), ftrylockfile(), and funlockfile()
(which may be macros), are provided to allow the user to delineate a sequence of I/O statements that are executed
synchronously.
The ungetc() function is infrequently called relative to the other
functions/macros so no unlocked variation is needed.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, flockfile(), getc(), getchar(), putc(), putchar()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
These functions are marked as part of the Thread-Safe Functions option.
The Open Group Corrigendum U030/2 is applied, adding APPLICATION USAGE describing how applications should be written to avoid
the case when the functions are implemented as macros.
Issue 7
The getc_unlocked(), getchar_unlocked(), putc_unlocked(), and putchar_unlocked() functions are moved
from the Thread-Safe Functions option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0232 [395], XSH/TC1-2008/0233 [395], XSH/TC1-2008/0234 [395], and
XSH/TC1-2008/0235 [14] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0151 [826] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fseek.html =====
fseek
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fseek, fseeko — reposition a file-position indicator in a stream
SYNOPSIS
#include
int fseek(FILE *stream, long offset, int whence);
[CX]  int fseeko(FILE *stream, off_t offset, int whence);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The fseek() function shall set the file-position indicator for the stream pointed to by stream. If a read or write
error occurs, the error indicator for the stream shall be set and fseek() fails.
The new position, measured in bytes from the beginning of the file, [CX]
except in the case of streams opened with open_wmemstream() for which the position shall be measured in wide characters,
shall be obtained by adding offset to the position specified
by whence. The specified point is the beginning of the file for SEEK_SET, the current value of the file-position indicator
for SEEK_CUR, or end-of-file for SEEK_END.
If the stream is to be used with wide-character input/output functions, the application shall ensure that offset is
either 0 or a value returned by an earlier call to ftell() on the same stream and
whence is SEEK_SET.
A successful call to fseek() shall clear the end-of-file indicator for the stream and undo any effects of ungetc() and ungetwc() on the same stream.
After an fseek() call, the next operation on an update stream may be either input or output.
[CX]  If
the most recent operation, other than ftell(), on a given stream is fflush(), the file offset in the underlying open file description shall be adjusted to
reflect the location specified by fseek().
The fseek() function shall allow the file-position indicator to be set beyond the end of existing data in the file. If
data is later written at this point, subsequent reads of data in the gap shall return bytes with the value 0 until data is actually
written into the gap.
The behavior of fseek() on devices which are incapable of seeking is implementation-defined. The value of the file offset
associated with such a device is undefined.
If the stream has an underlying file description and is writable, and buffered data had not been written to the underlying file,
fseek() shall cause the unwritten data to be written to the file and shall mark the last data modification and last file
status change timestamps of the file for update. If the stream was created by fmemopen(), open_memstream(), or
open_wmemstream() and the stream is writable, and if the stream is buffered
and data in the stream's buffer has not been written to the underlying memory buffer, fseek() shall cause the unwritten data
to be written to the underlying memory buffer.
In a locale with state-dependent encoding, whether fseek() restores the stream's shift state is
implementation-defined.
The fseeko() function shall be equivalent to the fseek() function except that the offset argument is of
type off_t.
RETURN VALUE
The fseek() [CX]   and fseeko()  functions
shall return 0 if they succeed.
[CX]
Otherwise, they shall return -1 and set errno to indicate the error.
ERRORS
The fseek() [CX]   and fseeko()
functions shall fail if, [CX]   either the stream is unbuffered or the stream's buffer needed to be flushed, and
the call to fseek() or fseeko() causes an underlying lseek() or write() to be invoked, and:
[EAGAIN]
[CX]
The O_NONBLOCK flag is set for the file descriptor and the thread would be delayed in the write operation.
[EBADF]
[CX]
The file descriptor underlying the stream file is not open for writing or the stream's buffer needed to be flushed and the file is
not open.
[EFBIG]
[CX]  An
attempt was made to write a file that exceeds the maximum file size.
[EFBIG]
[CX]  An
attempt was made to write a file that exceeds the file size limit of the process.
[XSI]
A SIGXFSZ signal shall also be generated for the thread.
[EFBIG]
[CX]
The file is a regular file and an attempt was made to write at or beyond the offset maximum associated with the corresponding
stream.
[EINTR]
[CX]
The write operation was terminated due to the receipt of a signal, and no data was transferred.
[EINVAL]
[CX]
The whence argument is invalid, the resulting file-position indicator would be set to a negative value, or the stream was
created by fmemopen() and the resulting file-position indicator would be beyond the
end of the underlying memory buffer.
[EIO]
[CX]  A
physical I/O error has occurred, or the process is a member of a background process group attempting to perform a write() to its controlling terminal, TOSTOP is set, the calling thread is not blocking
SIGTTOU, the process is not ignoring SIGTTOU, and the process group of the process is orphaned. This error may also be returned
under implementation-defined conditions.
[ENOMEM]
[CX]
The stream was created by open_memstream() or open_wmemstream() and insufficient memory is available.
[ENOSPC]
[CX]
There was no free space remaining on the device containing the file or in the buffer used by the fmemopen() function.
[EOVERFLOW]
[CX]
For fseek(), the resulting file offset would be a value which cannot be represented correctly in an object of type
long.
[EOVERFLOW]
[CX]
For fseeko(), the resulting file offset would be a value which cannot be represented correctly in an object of type
off_t.
[EPIPE]
[CX]  An
attempt was made to write to a pipe or FIFO that is not open for reading by any process; a SIGPIPE signal shall also be sent to the
thread.
[ESPIPE]
[CX]
The file descriptor underlying stream is associated with a pipe, FIFO, or socket.
The fseek() [CX]   and fseeko()
functions may fail if:
[ENXIO]
[CX]  A
request was made of a nonexistent device, or the request was outside the capabilities of the device.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
When the stream was created by fmemopen(), fseek() fails if an attempt is
made to seek beyond the end of the underlying memory buffer. This is different than fseek() on a file when a file size limit
is in effect because the size specified to fmemopen() is a fixed, absolute limit
whereas a file size limit is artificial and can be changed. With a file size limit, it is possible to seek past the limit, then
raise the limit and successfully write at the new position; there is no equivalent possibility with the buffer size specified to
fmemopen().
See also the rationale for ftell().
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fopen(), fmemopen(), fsetpos(), ftell(), getrlimit(), lseek(), open_memstream(), rewind(),
ungetc(), write()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
Normative text previously in the APPLICATION USAGE section is moved to the DESCRIPTION.
Large File Summit extensions are added.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The fseeko() function is added.
The [EFBIG], [EOVERFLOW], and [ENXIO] mandatory error conditions are added.
The following change is incorporated for alignment with the FIPS requirements:
The [EINTR] error is no longer an indication that the implementation does not report partial transfers.
The normative text is updated to avoid use of the term "must" for application requirements.
The DESCRIPTION is updated to explicitly state that fseek() sets the file-position indicator, and then on error the error
indicator is set and fseek() fails. This is for alignment with the ISO/IEC 9899:1999 standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/42 is applied, updating the [EAGAIN] error in the ERRORS section
from "the process would be delayed" to "the thread would be delayed".
Issue 7
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0188 [79], XSH/TC1-2008/0189 [122], XSH/TC1-2008/0190 [225], and
XSH/TC1-2008/0191 [14] are applied.
Issue 8
Austin Group Defect 308 is applied, clarifying the handling of [EFBIG] errors.
Austin Group Defect 1027 is applied, specifying that for streams opened with open_wmemstream() the position is measured in wide characters, not bytes.
Austin Group Defect 1225 is applied, clarifying the behavior for memory streams.
Austin Group Defect 1669 is applied, removing XSI shading from part of the [EFBIG] error relating to the file size limit for the
process.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fwprintf.html =====
fwprintf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fwprintf, swprintf, wprintf — print formatted wide-character output
SYNOPSIS
#include
#include
int fwprintf(FILE *restrict stream, const wchar_t *restrict format, ...);
int swprintf(wchar_t *restrict ws, size_t n,
const wchar_t *restrict format, ...);
int wprintf(const wchar_t *restrict format, ...);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The fwprintf() function shall place output on the named output stream. The wprintf() function shall place
output on the standard output stream stdout. The swprintf() function shall place output followed by the null wide
character in consecutive wide characters starting at *ws; no more than n wide characters shall be written, including
a terminating null wide character, which is always added (unless n is zero).
Each of these functions shall convert, format, and print its arguments under control of the format wide-character string.
The format is composed of zero or more directives: ordinary wide-characters, which are simply copied to the output
stream, and conversion specifications, each of which results in the fetching of zero or more arguments. The results are
undefined if there are insufficient arguments for the format. If the format is exhausted while arguments remain, the
excess arguments are evaluated but are otherwise ignored.
[CX]
Conversions can be applied to the nth argument after the format in the argument list, rather than to the next unused
argument. In this case, the conversion specifier wide character % (see below) is replaced by the sequence "%n$",
where n is a decimal integer in the range [1,{NL_ARGMAX}], giving the position of the argument in the argument list. This
feature provides for the definition of format wide-character strings that select arguments in an order appropriate to
specific languages (see the EXAMPLES section).
The format can contain either numbered argument conversion specifications (that is, those introduced by
"%n$" and optionally containing the "*m$" forms of field width and precision), or
unnumbered argument conversion specifications (that is, those introduced by the % character and optionally containing the
* form of field width and precision), but not both. The only exception to this is that %% can be mixed with the
"%n$" form. The results of mixing numbered and unnumbered argument specifications in a format
wide-character string are undefined. When numbered argument specifications are used, specifying the Nth argument requires
that all the leading arguments, from the first to the (N-1)th, are specified in the format wide-character string.
In format wide-character strings containing the "%n$" form of conversion specification, numbered
arguments in the argument list can be referenced from the format wide-character string as many times as required.
In format wide-character strings containing the % form of conversion specification, each argument in the
argument list shall be used exactly once. It is unspecified whether an encoding error occurs if the format string contains
wchar_t values that do not correspond to members of the character set of the current locale and the specified semantics do
not require that value to be processed by wcrtomb().
[CX]  All
forms of the fwprintf() function allow for the insertion of a locale-dependent radix character in the output string, output
as a wide-character value. The radix character is defined in the current locale (category LC_NUMERIC ). In the POSIX locale,
or in a locale where the radix character is not defined, the radix character shall default to a  ('.').
Each conversion specification is introduced by the '%' wide character [CX]   or by the
wide-character sequence "%n$",   after
which the following appear in sequence:
Zero or more flags (in any order), which modify the meaning of the conversion specification.
An optional minimum field width. If the converted value has fewer wide characters than the field width, it shall be
padded with  characters by default on the left; it shall be padded on the right, if the left-adjustment flag
('-'), described below, is given to the field width. The field width takes the form of an  ('*'),
[CX]
or in conversion specifications introduced by "%n$" the "*m$" string,
described below, or a decimal integer.
An optional precision that gives the minimum number of digits to appear for the d, i, o,
u, x, and X conversion specifiers; the number of digits to appear after the radix character for the
a, A, e, E, f, and F conversion specifiers; the maximum number of significant
digits for the g and G conversion specifiers; or the maximum number of wide characters to be printed from a
string in the s conversion specifiers. The precision takes the form of a  ('.') followed either by
an  ('*'), [CX]   or in conversion specifications introduced by "%n$" the
"*m$" string,  described below, or an
optional decimal digit string, where a null digit string is treated as 0. If a precision appears with any other conversion wide
character, the behavior is undefined.
An optional length modifier that specifies the size of the argument.
A conversion specifier wide character that indicates the type of conversion to be applied.
A field width, or precision, or both, may be indicated by an  ('*'). In this case an argument of type
int supplies the field width or precision. Applications shall ensure that arguments specifying field width, or precision, or
both appear in that order before the argument, if any, to be converted. A negative field width is taken as a '-' flag
followed by a positive field width. A negative precision is taken as if the precision were omitted. [CX]   In
format wide-character strings containing conversion specifications introduced by "%n$", in addition
to being indicated by the decimal digit string, a field width may be indicated by the sequence "*m$" and
precision by the sequence ".*m$", where m is a decimal integer in the range [1,{NL_ARGMAX}] giving
the position in the argument list (after the format argument) of an integer argument containing the field width or
precision, for example:
wprintf(L"%1$d:%2$.*3$d:%4$.*3$d\n", hour, min, precision, sec);
The flag wide characters and their meanings are:
'
[CX]
(The .) The integer portion of the result of a decimal conversion (%i, %d, %u,
%f, %F, %g, or %G) shall be formatted with thousands' grouping wide characters. For other
conversions, the behavior is undefined. The numeric grouping wide character is used.
-
The result of the conversion shall be left-justified within the field. The conversion shall be right-justified if this flag is
not specified.
+
The result of a signed conversion shall always begin with a sign ('+' or '-'). The conversion shall begin
with a sign only when a negative value is converted if this flag is not specified.
If the first wide character of a signed conversion is not a sign, or if a signed conversion results in no wide characters, a
shall be prefixed to the result. This means that if the  and '+' flags both appear, the
flag shall be ignored.
#
Specifies that the value is to be converted to an alternative form. For o conversion, it shall increase the precision,
if and only if necessary, to force the first digit of the result to be zero (if the value and precision are both 0, a single 0 is
printed). For x or X conversion specifiers, a non-zero result shall have 0x (or 0X) prefixed to it. For
a, A, e, E, f, F, g, and G conversion specifiers, the
result shall always contain a radix character, even if no digits follow it. Without this flag, a radix character appears in the
result of these conversions only if a digit follows it. For g and G conversion specifiers, trailing zeros shall
not be removed from the result as they normally are. For other conversion specifiers, the behavior is undefined.
0
For d, i, o, u, x, X, a, A, e, E,
f, F, g, and G conversion specifiers, leading zeros (following any indication of sign or base)
are used to pad to the field width rather than performing space padding, except when converting an infinity or NaN. If the
'0' and '-' flags both appear, the '0' flag shall be ignored. For d, i, o,
u, x, and X conversion specifiers, if a precision is specified, the '0' flag shall be ignored.
[CX]
If the '0' and  flags both appear, the grouping wide characters are inserted before zero padding.
For other conversions, the behavior is undefined.
The length modifiers and their meanings are:
hh
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a signed char or unsigned char argument (the argument will have been promoted according to the integer
promotions, but its value shall be converted to signed char or unsigned char before printing); or that a following
n conversion specifier applies to a pointer to a signed char argument.
h
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a short or unsigned short argument (the argument will have been promoted according to the integer
promotions, but its value shall be converted to short or unsigned short before printing); or that a following
n conversion specifier applies to a pointer to a short argument.
l (ell)
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a long or unsigned long argument; that a following n conversion specifier applies to a pointer to
a long argument; that a following c conversion specifier applies to a wint_t argument; that a following
s conversion specifier applies to a pointer to a wchar_t argument; or has no effect on a following a,
A, e, E, f, F, g, or G conversion specifier.
ll (ell-ell)
Specifies that a following d, i, o, u, x, or X conversion specifier applies
to a long long or unsigned long long argument; or that a following n conversion specifier applies to a
pointer to a long long argument.
j
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to an intmax_t or uintmax_t argument; or that a following n conversion specifier applies to a
pointer to an intmax_t argument.
z
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a size_t or the corresponding signed integer type argument; or that a following n conversion specifier
applies to a pointer to a signed integer type corresponding to a size_t argument.
t
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a ptrdiff_t or the corresponding unsigned type argument; or that a following n conversion
specifier applies to a pointer to a ptrdiff_t argument.
L
Specifies that a following a, A, e, E, f, F, g, or G
conversion specifier applies to a long double argument.
If a length modifier appears with any conversion specifier other than as specified above, the behavior is undefined.
The conversion specifiers and their meanings are:
d, i
The int argument shall be converted to a signed decimal in the style "[-]dddd". The precision specifies
the minimum number of digits to appear; if the value being converted can be represented in fewer digits, it shall be expanded with
leading zeros. The default precision shall be 1. The result of converting zero with an explicit precision of zero shall be no wide
characters.
o
The unsigned argument shall be converted to unsigned octal format in the style "dddd". The precision specifies
the minimum number of digits to appear; if the value being converted can be represented in fewer digits, it shall be expanded with
leading zeros. The default precision shall be 1. The result of converting zero with an explicit precision of zero shall be no wide
characters.
u
The unsigned argument shall be converted to unsigned decimal format in the style "dddd". The precision
specifies the minimum number of digits to appear; if the value being converted can be represented in fewer digits, it shall be
expanded with leading zeros. The default precision shall be 1. The result of converting zero with an explicit precision of zero
shall be no wide characters.
x
The unsigned argument shall be converted to unsigned hexadecimal format in the style "dddd"; the letters
"abcdef" are used. The precision specifies the minimum number of digits to appear; if the value being converted can be
represented in fewer digits, it shall be expanded with leading zeros. The default precision shall be 1. The result of converting
zero with an explicit precision of zero shall be no wide characters.
X
Equivalent to the x conversion specifier, except that letters "ABCDEF" are used instead of
"abcdef".
f, F
The double argument shall be converted to decimal notation in the style "[-]ddd.ddd", where the number
of digits after the radix character shall be equal to the precision specification. If the precision is missing, it shall be taken
as 6; if the precision is explicitly zero and no '#' flag is present, no radix character shall appear. If a radix
character appears, at least one digit shall appear before it. The value shall be rounded in an implementation-defined manner to the
appropriate number of digits.
A double argument representing an infinity shall be converted in one of the styles "[-]inf" or
"[-]infinity"; which style is implementation-defined. A double argument representing a NaN shall be converted in
one of the styles "[-]nan" or "[-]nan(n-char-sequence)"; which style, and the meaning of any
n-char-sequence, is implementation-defined. The F conversion specifier produces "INF",
"INFINITY", or "NAN" instead of "inf", "infinity", or "nan", respectively.
e, E
The double argument shall be converted in the style "[-]d.ddde±dd", where there shall be one
digit before the radix character (which is non-zero if the argument is non-zero) and the number of digits after it shall be equal
to the precision; if the precision is missing, it shall be taken as 6; if the precision is zero and no '#' flag is
present, no radix character shall appear. The value shall be rounded in an implementation-defined manner to the appropriate number
of digits. The E conversion wide character shall produce a number with 'E' instead of 'e' introducing
the exponent. The exponent shall always contain at least two digits. If the value is zero, the exponent shall be zero.
A double argument representing an infinity or NaN shall be converted in the style of an f or F
conversion specifier.
g, G
The double argument representing a floating-point number shall be converted in the style f or e (or in
the style F or E in the case of a G conversion specifier), depending on the value converted and the
precision. Let P equal the precision if non-zero, 6 if the precision is omitted, or 1 if the precision is zero. Then, if a
conversion with style E would have an exponent of X:
If P>X>=-4, the conversion shall be with style f (or F) and precision
P-(X+1).
Otherwise, the conversion shall be with style e (or E) and precision P-1.
Finally, unless the '#' flag is used, any trailing zeros shall be removed from the fractional portion of the result and
the decimal-point character shall be removed if there is no fractional portion remaining.
A double argument representing an infinity or NaN shall be converted in the style of an f or F
conversion specifier.
a, A
A double argument representing a floating-point number shall be converted in the style
"[-]0xh.hhhhp±d", where there shall be one hexadecimal digit (which is
non-zero if the argument is a normalized floating-point number and is otherwise unspecified) before the decimal-point wide
character and the number of hexadecimal digits after it shall be equal to the precision; if the precision is missing and FLT_RADIX
is a power of 2, then the precision shall be sufficient for an exact representation of the value; if the precision is missing and
FLT_RADIX is not a power of 2, then the precision shall be sufficient to distinguish values of type double, except that
trailing zeros may be omitted; if the precision is zero and the '#' flag is not specified, no decimal-point wide character
shall appear. The letters "abcdef" are used for a conversion and the letters "ABCDEF" for A
conversion. The A conversion specifier produces a number with 'X' and 'P' instead of 'x' and
'p'. The exponent shall always contain at least one digit, and only as many more digits as necessary to represent the
decimal exponent of 2. If the value is zero, the exponent shall be zero.
A double argument representing an infinity or NaN shall be converted in the style of an f or F
conversion specifier.
c
If no l (ell) qualifier is present, the int argument shall be converted to a wide character as if by calling
the btowc() function and the resulting wide character shall be written. Otherwise, the
wint_t argument shall be converted to wchar_t, and written.
s
If no l (ell) qualifier is present, the application shall ensure that the argument is a pointer to a character array
containing a character sequence beginning in the initial shift state. Characters from the array shall be converted as if by
repeated calls to the mbrtowc() function, with the conversion state described by an
mbstate_t object initialized to zero before the first character is converted, and written up to (but not including) the
terminating null wide character. If the precision is specified, no more than that many wide characters shall be written. If the
precision is not specified, or is greater than the size of the array, the application shall ensure that the array contains a null
wide character.
If an l (ell) qualifier is present, the application shall ensure that the argument is a pointer to an array of type
wchar_t. Wide characters from the array shall be written up to (but not including) a terminating null wide character. If no
precision is specified, or is greater than the size of the array, the application shall ensure that the array contains a null wide
character. If a precision is specified, no more than that many wide characters shall be written.
p
The application shall ensure that the argument is a pointer to void. The value of the pointer shall be converted to a
sequence of printable wide characters in an implementation-defined manner.
n
The application shall ensure that the argument is a pointer to an integer into which is written the number of wide characters
written to the output so far by this call to one of the fwprintf() functions. No argument shall be converted, but one shall
be consumed. If the conversion specification includes any flags, a field width, or a precision, the behavior is undefined.
C
[XSI]
Equivalent to lc.
S
[XSI]
Equivalent to ls.
%
Write a '%' wide character; no argument shall be converted. The application shall ensure that the complete conversion
specification is %%.
If a conversion specification does not match one of the above forms, the behavior is undefined.
In no case does a nonexistent or small field width cause truncation of a field; if the result of a conversion is wider than the
field width, the field shall be expanded to contain the conversion result. Characters generated by fwprintf() and
wprintf() shall be printed as if fputwc() had been called.
For a and A conversions, if FLT_RADIX is not a power of 2 and the result is not exactly representable in the
given precision, the result should be one of the two adjacent numbers in hexadecimal floating style with the given precision, with
the extra stipulation that the error should have a correct sign for the current rounding direction.
For e, E, f, F, g, and G conversion specifiers, if the number of
significant decimal digits is at most DECIMAL_DIG, then the result should be correctly rounded. If the number of significant
decimal digits is more than DECIMAL_DIG but the source value is exactly representable with DECIMAL_DIG digits, then the result
should be an exact representation with trailing zeros. Otherwise, the source value is bounded by two adjacent decimal strings
L , ,
CHANGE HISTORY
First released in Issue 5. Included for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E).
Issue 6
The Open Group Corrigendum U040/1 is applied to the RETURN VALUE section, describing the case if n or more wide
characters are requested to be written using swprintf().
The normative text is updated to avoid use of the term "must" for application requirements.
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The prototypes for fwprintf(), swprintf(), and wprintf() are updated.
The DESCRIPTION is updated.
The hh, ll, j, t, and z length modifiers are added.
The a, A, and F conversion characters are added.
XSI shading is removed from the description of character string representations of infinity and NaN floating-point values.
The DESCRIPTION is updated to use the terms "conversion specifier" and "conversion specification" consistently.
ISO/IEC 9899:1999 standard, Technical Corrigendum 1 is incorporated.
Issue 7
Austin Group Interpretation 1003.1-2001 #161 is applied, updating the DESCRIPTION of the 0 flag.
Austin Group Interpretation 1003.1-2001 #170 is applied.
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #68 (SD5-XSH-ERN-70) is applied, revising the description of g
and G.
Functionality relating to the "%n$" form of conversion specification and the  flag is moved from the
XSI option to the Base.
The [EOVERFLOW] error is added for swprintf().
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0226 [302] and XSH/TC1-2008/0227 [14] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0144 [73], XSH/TC2-2008/0145 [894], XSH/TC2-2008/0146 [557], and
XSH/TC2-2008/0147 [936] are applied.
Issue 8
Austin Group Defect 1021 is applied, changing "output error" to "error" in the RETURN VALUE section and changing the
requirements for [EOVERFLOW].
Austin Group Defect 1137 is applied, clarifying the use of "%n$" and "*m$" in
conversion specifications.
Austin Group Defect 1205 is applied, changing the description of the % conversion specifier.
Austin Group Defect 1219 is applied, changing the swprintf()-specific [EOVERFLOW] error.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/uselocale.html =====
uselocale
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
uselocale — use locale in current thread
SYNOPSIS
[CX]  #include
locale_t uselocale(locale_t newloc);
DESCRIPTION
The uselocale() function shall set or query the current locale for the calling thread.
The value for the newloc argument shall be one of the following:
A value returned by the newlocale() or duplocale() functions
The special locale object descriptor LC_GLOBAL_LOCALE
(locale_t)0
If the newloc argument is (locale_t)0, the current locale shall not be changed; this value can be used to query
the current locale setting. If the newloc argument is LC_GLOBAL_LOCALE, any thread-local locale for the calling thread shall
be uninstalled; the thread shall again use the global locale as the current locale, and changes to the global locale shall affect
the thread. Otherwise, the locale represented by newloc shall be installed as a thread-local locale to be used as the
current locale for the calling thread.
Once the uselocale() function has been called to install a thread-local locale, the behavior of every interface using
data from the current locale shall be affected for the calling thread. The current locale for other threads shall remain
unchanged.
RETURN VALUE
Upon successful completion, the uselocale() function shall return a handle for the thread-local locale that was in use as
the current locale for the calling thread on entry to the function, or LC_GLOBAL_LOCALE if no thread-local locale was in use.
Otherwise, uselocale() shall return (locale_t)0 and set errno to indicate the error.
ERRORS
The uselocale() function may fail if:
[EINVAL]
newloc is not a valid locale object and is not (locale_t)0.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Unlike the setlocale() function, the uselocale() function does not allow
replacing some locale categories only. Applications that need to install a locale which differs only in a few categories must use
newlocale() to change a locale object equivalent to the currently used locale and
install it.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
duplocale(), freelocale()
, getlocalename_l(), newlocale(), setlocale()
XBD
CHANGE HISTORY
First released in Issue 7.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0700 [290] and XSH/TC1-2008/0701 [334] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0382 [582] is applied.
Issue 8
Austin Group Defect 1220 is applied, adding getlocalename_l() to the SEE
ALSO section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/catanl.html =====
catan
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
catan, catanf, catanl — complex arc tangent functions
SYNOPSIS
#include
double complex catan(double complex z);
float complex catanf(float complex z);
long double complex catanl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex arc tangent of z, with branch cuts outside the interval
[-i, +i] along the imaginary axis.
RETURN VALUE
These functions shall return the complex arc tangent value, in the range of a strip mathematically unbounded along the imaginary
axis and in the interval [-ℼ/2, +ℼ/2] along the real axis.
[MXC]
catan(conj(iz)), catanf(conjf(iz)), and catanl(conjl(iz)) shall
return exactly the same value as conj(catan(iz)), conjf(catanf(iz)), and
conjl(catanl(iz)), respectively, and catan(-iz), catanf(-iz), and
catanl(-iz) shall return exactly the same value as -catan(iz), -catanf(iz), and
-catanl(iz), respectively, including for the special values of iz below.
If iz is +0 + i0, -i (+0 + i0) shall be returned.
If iz is +0 + iNaN, -i (+0 + iNaN) shall be returned.
If iz is +1 + i0, -i (+Inf + i0) shall be returned and the divide-by-zero floating-point exception
shall be raised.
If iz is x + iInf where x is positive-signed and finite, -i (+0 + iℼ/2) shall be
returned.
If iz is x + iNaN where x is non-zero and finite, -i (NaN + iNaN) shall be returned
and the invalid floating-point exception may be raised.
If iz is +Inf + iy where y is positive-signed and finite, -i (+0 + iℼ/2) shall be
returned.
If iz is +Inf + iInf, -i (+0 + iℼ/2) shall be returned.
If iz is +Inf + iNaN, -i (+0 + iNaN) shall be returned.
If iz is NaN + iy where y is finite, -i (NaN + iNaN) shall be returned and the invalid
floating-point exception may be raised.
If iz is NaN + iInf, -i (±0 + iℼ/2) shall be returned; the sign of the imaginary part of the result
is unspecified.
If iz is NaN + iNaN, -i (NaN + iNaN) shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The MXC special cases for catan() are derived from those for catanh() by
applying the formula catan(z) = -i catanh(iz).
FUTURE DIRECTIONS
None.
SEE ALSO
catanh(), ctan()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atomic_store.html =====
atomic_store
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atomic_store, atomic_store_explicit — atomically store a value in an object
SYNOPSIS
#include
void atomic_store(volatile A *object, C desired);
void atomic_store_explicit(volatile A *object, C desired,
memory_order order);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
Implementations that define the macro __STDC_NO_ATOMICS__ need not provide the  header nor support these generic functions.
The atomic_store_explicit() generic function shall atomically replace the value pointed to by object with
desired. Memory shall be affected according to the value of order, which the application shall ensure is not
memory_order_acquire, memory_order_consume, nor memory_order_acq_rel.
The atomic_store() generic function shall be equivalent to atomic_store_explicit() called with order set to
memory_order_seq_cst.
RETURN VALUE
These generic functions shall not return a value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD 4.15.1 Memory Ordering,
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atomic_load_explicit.html =====
atomic_load
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atomic_load, atomic_load_explicit — atomically obtain the value of an object
SYNOPSIS
#include
C atomic_load(const volatile A *object); C atomic_load_explicit(const
volatile A *object, memory_order order);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
Implementations that define the macro __STDC_NO_ATOMICS__ need not provide the  header nor support these generic functions.
The atomic_load_explicit() generic function shall atomically obtain the value pointed to by object. Memory shall
be affected according to the value of order, which the application shall ensure is not memory_order_release nor
memory_order_acq_rel.
The atomic_load() generic function shall be equivalent to atomic_load_explicit() called with order set to
memory_order_seq_cst.
RETURN VALUE
These generic functions shall return the value pointed to by object.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD 4.15.1 Memory Ordering,
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_rwlock_init.html =====
pthread_rwlock_destroy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_rwlock_destroy, pthread_rwlock_init — destroy and initialize a read-write lock object
SYNOPSIS
#include
int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,
const pthread_rwlockattr_t *restrict attr);
pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;
DESCRIPTION
The pthread_rwlock_destroy() function shall destroy the read-write lock object referenced by rwlock and release
any resources used by the lock. The effect of subsequent use of the lock is undefined until the lock is reinitialized by another
call to pthread_rwlock_init(). An implementation may cause pthread_rwlock_destroy() to set the object referenced by
rwlock to an invalid value. Results are undefined if pthread_rwlock_destroy() is called when any thread holds
rwlock. Attempting to destroy an uninitialized read-write lock results in undefined behavior.
The pthread_rwlock_init() function shall allocate any resources required to use the read-write lock referenced by
rwlock and initializes the lock to an unlocked state with attributes referenced by attr. If attr is NULL, the
default read-write lock attributes shall be used; the effect is the same as passing the address of a default read-write lock
attributes object. Once initialized, the lock can be used any number of times without being reinitialized. Results are undefined if
pthread_rwlock_init() is called specifying an already initialized read-write lock. Results are undefined if a read-write
lock is used without first being initialized.
If the pthread_rwlock_init() function fails, rwlock shall not be initialized and the contents of rwlock are
undefined.
See 2.9.9 Synchronization Object Copies and Alternative Mappings
for further requirements.
In cases where default read-write lock attributes are appropriate, the macro PTHREAD_RWLOCK_INITIALIZER can be used to
initialize read-write locks. The effect shall be equivalent to dynamic initialization by a call to pthread_rwlock_init()
with the attr parameter specified as NULL, except that no error checks are performed.
The behavior is undefined if the value specified by the attr argument to pthread_rwlock_init() does not refer to
an initialized read-write lock attributes object.
RETURN VALUE
If successful, the pthread_rwlock_destroy() and pthread_rwlock_init() functions shall return zero; otherwise, an
error number shall be returned to indicate the error.
ERRORS
The pthread_rwlock_init() function shall fail if:
[EAGAIN]
The system lacked the necessary resources (other than memory) to initialize another read-write lock.
[ENOMEM]
Insufficient memory exists to initialize the read-write lock.
[EPERM]
The caller does not have the privilege to perform the operation.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications using these and related read-write lock functions may be subject to priority inversion, as discussed in XBD
3.275 Priority Inversion.
RATIONALE
If an implementation detects that the value specified by the rwlock argument to pthread_rwlock_destroy() does not
refer to an initialized read-write lock object, it is recommended that the function should fail and report an [EINVAL] error.
If an implementation detects that the value specified by the attr argument to pthread_rwlock_init() does not refer
to an initialized read-write lock attributes object, it is recommended that the function should fail and report an [EINVAL]
error.
If an implementation detects that the value specified by the rwlock argument to pthread_rwlock_destroy() or
pthread_rwlock_init() refers to a locked read-write lock object, or detects that the value specified by the rwlock
argument to pthread_rwlock_init() refers to an already initialized read-write lock object, it is recommended that the
function should fail and report an [EBUSY] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_rwlock_clockrdlock(), pthread_rwlock_clockwrlock(), pthread_rwlock_rdlock(), pthread_rwlock_trywrlock(), pthread_rwlock_unlock()
XBD 3.275 Priority Inversion,
CHANGE HISTORY
First released in Issue 5.
Issue 6
The following changes are made for alignment with IEEE Std 1003.1j-2000:
The margin code in the SYNOPSIS is changed to THR to indicate that the functionality is now part of the Threads option
(previously it was part of the Read-Write Locks option in IEEE Std 1003.1j-2000 and also part of the XSI extension). The
initializer macro is also deleted from the SYNOPSIS.
The DESCRIPTION is updated as follows:
It explicitly notes allocation of resources upon initialization of a read-write lock object.
A paragraph is added specifying that copies of read-write lock objects may not be used.
An [EINVAL] error is added to the ERRORS section for pthread_rwlock_init(), indicating that the rwlock value is
invalid.
The SEE ALSO section is updated.
The restrict keyword is added to the pthread_rwlock_init() prototype for alignment with the ISO/IEC 9899:1999
standard.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/45 is applied, adding APPLICATION USAGE relating to priority
inversion.
Issue 7
Austin Group Interpretation 1003.1-2001 #048 is applied, adding the PTHREAD_RWLOCK_INITIALIZER macro.
The pthread_rwlock_destroy() and pthread_rwlock_init() functions are moved from the Threads option to the
Base.
The [EINVAL] error for an uninitialized read-write lock object or read-write lock attributes object is removed; this condition
results in undefined behavior.
The [EBUSY] error for a locked read-write lock object or an already initialized read-write lock object is removed; this
condition results in undefined behavior.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0465 [70] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0288 [972] and XSH/TC2-2008/0289 [758] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/nftw.html =====
nftw
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
nftw — walk a file tree
SYNOPSIS
[XSI]  #include
int nftw(const char *path, int (*fn)(const char *,
const struct stat *, int, struct FTW *), int fd_limit, int
flags);
DESCRIPTION
The nftw() function shall recursively descend the directory hierarchy rooted in path. The argument flags is
a bitwise-inclusive OR of zero or more of the following flags:
FTW_CHDIR
If set, nftw() shall change the current working directory to each directory as it reports files in that directory. If
clear, nftw() shall not change the current working directory.
FTW_DEPTH
If set, nftw() shall report all files in a directory before reporting the directory itself. If clear, nftw()
shall report any directory before reporting the files in that directory.
FTW_MOUNT
If set, nftw() shall only report files that have the same device ID (st_dev) as path and shall not descend
below directories that have a different device ID than path. If clear, nftw() shall report all files encountered
during the walk, unless FTW_XDEV is set.
FTW_PHYS
If set, nftw() shall perform a physical walk and shall not follow symbolic links.
FTW_XDEV
If set, nftw() shall not descend below directories that have a different device ID (st_dev) than path;
that is, when a directory with a different device ID is encountered, nftw() shall report the directory itself (unless
FTW_MOUNT is set) but shall not report any files below the directory. If clear, nftw() shall report all files encountered
during the walk, unless FTW_MOUNT is set.
Note:
If both FTW_MOUNT and FTW_XDEV are set, nftw() obeys both flags but the end result is the same as if FTW_XDEV were
clear.
If FTW_PHYS is clear and FTW_DEPTH is set, nftw() shall follow links instead of reporting them, but shall not report any
directory that would be a descendant of itself. If FTW_PHYS is clear and FTW_DEPTH is clear, nftw() shall follow links
instead of reporting them, but shall not report the contents of any directory that would be a descendant of itself.
At each file it encounters, nftw() shall call the user-supplied function fn with four arguments:
The first argument is the pathname of the object.
The second argument is a pointer to the stat buffer containing information on the object, filled in as if fstatat(), stat(), or lstat() had been called to retrieve the information.
The third argument is an integer giving additional information. Its value is one of the following:
FTW_D
The object is a directory.
FTW_DNR
The object is a directory that cannot be read. The fn function shall not be called for any of its descendants.
FTW_DP
The object is a directory and subdirectories have been visited. (This condition shall only occur if the FTW_DEPTH flag is
included in flags.)
FTW_F
The object is a non-directory file.
FTW_NS
The stat() function failed on the object because of lack of appropriate permission.
The stat buffer passed to fn is undefined. Failure of stat() for any
other reason is considered an error and nftw() shall return -1.
FTW_SL
The object is a symbolic link. (This condition shall only occur if the FTW_PHYS flag is included in flags.)
FTW_SLN
The object is a symbolic link that does not name an existing file. The stat buffer passed to fn shall contain
information on the symbolic link. (This condition shall only occur if the FTW_PHYS flag is not included in flags.)
The fourth argument is a pointer to an FTW structure. The value of base is the offset of the object's filename in
the pathname passed as the first argument to fn. The value of level indicates depth relative to the root of the walk,
where the root level is 0.
The results are unspecified if the application-supplied fn function does not preserve the current working directory.
The argument fd_limit sets the maximum number of file descriptors that shall be used by nftw() while traversing
the file tree. At most one file descriptor shall be used for each directory level. The FD_CLOEXEC flag shall be set on any file
descriptor opened by nftw() (see ) not including those opened
by the user-supplied fn function. Every file descriptor opened by nftw() not including those opened by the
user-supplied fn function shall be closed before nftw() returns.
The nftw() function need not be thread-safe.
RETURN VALUE
The nftw() function shall continue until the first of the following conditions occurs:
An invocation of fn shall return a non-zero value, in which case nftw() shall return that value.
The nftw() function detects an error other than [EACCES] (see FTW_DNR and FTW_NS above), in which case nftw()
shall return -1 and set errno to indicate the error.
The tree is exhausted, in which case nftw() shall return 0.
ERRORS
The nftw() function shall fail if:
[EACCES]
Search permission is denied for any component of path or read permission is denied for path, or fn returns
-1 and does not reset errno.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of path does not name an existing file or path is an empty string.
[ENOTDIR]
A component of path names an existing file that is neither a directory nor a symbolic link to a directory.
[EOVERFLOW]
A field in the stat structure cannot be represented correctly in the current programming environment for one or more
files found in the file hierarchy.
The nftw() function may fail if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path argument.
[EMFILE]
All file descriptors available to the process are currently open.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
[ENFILE]
Too many files are currently open in the system.
In addition, errno may be set if the function pointed to by fn causes errno to be set.
The following sections are informative.
EXAMPLES
The following program traverses the directory tree under the path named in its first command-line argument, or under the current
directory if no argument is supplied. It displays various information about each file. The second command-line argument can be used
to specify characters that control the value assigned to the flags argument when calling nftw().
#include
#include
#include
#include
#include
static int
display_info(const char *fpath, const struct stat *sb,
int tflag, struct FTW *ftwbuf)
{
printf("%-3s %2d %7jd   %-40s %d %s\n",
(tflag == FTW_D) ?   "d"   : (tflag == FTW_DNR) ? "dnr" :
(tflag == FTW_DP) ?  "dp"  : (tflag == FTW_F) ?
(S_ISBLK(sb->st_mode) ? "f b" :
S_ISCHR(sb->st_mode) ? "f c" :
S_ISFIFO(sb->st_mode) ? "f p" :
S_ISREG(sb->st_mode) ? "f r" :
S_ISSOCK(sb->st_mode) ? "f s" : "f ?") :
(tflag == FTW_NS) ?  "ns"  : (tflag == FTW_SL) ?  "sl" :
(tflag == FTW_SLN) ? "sln" : "?", ftwbuf->level,
(intmax_t) ((tflag == FTW_NS) ? -1 : sb->st_size),
fpath, ftwbuf->base, fpath + ftwbuf->base);
return 0;           /* To tell nftw() to continue */
}
int
main(int argc, char *argv[])
{
int flags = 0;
if (argc > 2 && strchr(argv[2], 'd') != NULL)
flags |= FTW_DEPTH;
if (argc > 2 && strchr(argv[2], 'p') != NULL)
flags |= FTW_PHYS;
if (nftw((argc st_dev != saved_dev)
return 0;
(where saved_dev is the st_dev value for path).
RATIONALE
Earlier versions of this standard did not make clear that, as well as not reporting them, FTW_MOUNT prevents descent below
directories that have a different device ID than path if they are encountered by following a symbolic link (rather than by
being a mount point). This meant that if such a directory contained any symbolic links to files with the same device ID as
path, nftw() with FTW_PHYS clear was required to report them. However, this was not how nftw() implementations
behaved and the standard has been amended to match existing practice.
FUTURE DIRECTIONS
None.
SEE ALSO
fdopendir(), fstatat(),
readdir()
XBD ,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
In the DESCRIPTION, the definition of the depth argument is clarified.
Issue 6
The Open Group Base Resolution bwg97-003 is applied.
The ERRORS section is updated as follows:
The wording of the mandatory [ELOOP] error condition is updated.
A second optional [ELOOP] error condition is added.
The [EOVERFLOW] mandatory error condition is added.
Text is added to the DESCRIPTION to say that the nftw() function need not be reentrant and that the results are
unspecified if the application-supplied fn function does not preserve the current working directory.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/64 is applied, changing the argument depth to
fd_limit throughout and changing "to a maximum of 5 levels deep" to "using a maximum of 5 file descriptors" in the
EXAMPLES section.
Issue 7
Austin Group Interpretations 1003.1-2001 #143 and #156 are applied.
SD5-XBD-ERN-4 is applied, changing the definition of the [EMFILE] error.
SD5-XBD-ERN-61 is applied.
APPLICATION USAGE is added and the EXAMPLES section is replaced with a new example.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0409 [403], XSH/TC1-2008/0410 [324], and XSH/TC1-2008/0411 [403] are
applied.
Issue 8
Austin Group Defect 368 is applied, adding a requirement for the FD_CLOEXEC flag to be set.
Austin Group Defect 1121 is applied, changing the description of FTW_SLN and the handling of FTW_NS in the EXAMPLES section.
Austin Group Defect 1133 is applied, adding FTW_XDEV.
Austin Group Defect 1210 is applied, changing the description of FTW_MOUNT and the RATIONALE section.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/vfprintf.html =====
vfprintf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
vasprintf, vdprintf, vfprintf, vprintf, vsnprintf, vsprintf — format output of a stdarg argument list
SYNOPSIS
#include
#include
[CX]  int vasprintf(char **restrict ptr, const char *restrict format,
va_list ap);
int vdprintf(int fildes, const char *restrict format, va_list ap);
int vfprintf(FILE *restrict stream, const char *restrict format,
va_list ap);
int vprintf(const char *restrict format, va_list ap);
int vsnprintf(char *restrict s, size_t n, const char *restrict format,
va_list ap);
int vsprintf(char *restrict s, const char *restrict format, va_list
ap);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The [CX]
vasprintf(), vdprintf(),  vfprintf(),
vprintf(), vsnprintf(), and vsprintf() functions shall be equivalent to the [CX]  asprintf(), dprintf(),  fprintf(), printf(), snprintf(), and sprintf() functions respectively, except that instead of being called with a variable number
of arguments, they are called with an argument list as defined by .
These functions shall not invoke the va_end macro. As these functions invoke the va_arg macro, the value of
ap after the return is unspecified.
RETURN VALUE
Refer to fprintf().
ERRORS
Refer to fprintf().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications using these functions should call va_end(ap) afterwards to clean up.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fprintf()
XBD ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The vsnprintf() function is added.
Issue 6
The vfprintf(), vprintf(), vsnprintf(), and vsprintf() functions are updated for alignment with the
ISO/IEC 9899:1999 standard.
Issue 7
The vdprintf() function is added to complement the dprintf() function from
The Open Group Technical Standard, 2006, Extended API Set Part 1.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0703 [14] is applied.
Issue 8
Austin Group Defect 1496 is applied, adding the vasprintf() function.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/iswpunct_l.html =====
iswpunct
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
iswpunct, iswpunct_l — test for a punctuation wide-character code
SYNOPSIS
#include
int iswpunct(wint_t wc);
[CX]  int iswpunct_l(wint_t wc, locale_t locale);
DESCRIPTION
For iswpunct(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The iswpunct() [CX]   and iswpunct_l()
functions shall test whether wc is a wide-character code representing a character of class punct in the current
locale, [CX]   or in the locale represented by locale,
respectively; see XBD 7. Locale.
The wc argument is a wint_t, the value of which the application shall ensure is a wide-character code
corresponding to a valid character in the locale used by the function, or equal to the value of the macro WEOF. If the argument has
any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to iswpunct_l() is the special locale object LC_GLOBAL_LOCALE or is not
a valid locale object handle.
RETURN VALUE
The iswpunct() [CX]   and iswpunct_l()
functions shall return non-zero if wc is a punctuation wide-character code; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
iswalnum(), iswalpha(),
iswcntrl(), iswctype(),
iswdigit(), iswgraph(),
iswlower(), iswprint(),
iswspace(), iswupper(),
iswxdigit(), setlocale(),
uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 4.
Issue 5
The following change has been made in this version for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E):
The SYNOPSIS has been changed to indicate that this function and associated data types are now made visible by inclusion of the
header rather than .
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The iswpunct_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0335 [302], XSH/TC1-2008/0336 [283], and XSH/TC1-2008/0337 [283] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0190 [685] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcschr.html =====
wcschr
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcschr — wide-character string scanning operation
SYNOPSIS
#include
wchar_t *wcschr(const wchar_t *ws, wchar_t wc);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The wcschr() function shall locate the first occurrence of wc in the wide-character string pointed to by
ws. The application shall ensure that the value of wc is a character representable as a type wchar_t and a
wide-character code corresponding to a valid character in the current locale. The terminating null wide-character code is
considered to be part of the wide-character string.
[CX]  The
wcschr() function shall not change the setting of errno on valid input.
RETURN VALUE
Upon completion, wcschr() shall return a pointer to the wide-character code, or a null pointer if the wide-character code
is not found.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
wcsrchr()
XBD
CHANGE HISTORY
First released in Issue 4. Derived from the MSE working draft.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that wcschr() does not change the setting of errno on
valid input.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/dirfd.html =====
dirfd
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
dirfd — extract the file descriptor used by a DIR stream
SYNOPSIS
#include
int dirfd(DIR *dirp);
DESCRIPTION
If the directory stream referenced by dirp has an associated file descriptor, dirfd() shall return that file
descriptor. Otherwise, dirfd() shall open a new file description referring to the directory associated with the directory
stream as if by calling:
open(DirectoryName, O_RDONLY | O_DIRECTORY | O_CLOEXEC);
except that no pathname for use as DirectoryName need exist or be accessible. It shall then associate the new file
descriptor with the directory stream, and return that file descriptor.
Upon successful return from dirfd(), the file descriptor is under the control of the system, and if any attempt is made
to close the file descriptor, or to modify the state of the associated description, other than by means of closedir(), readdir(), readdir_r(), rewinddir(), or
[XSI]
seekdir(),  the
behavior is undefined. Upon calling closedir() the file descriptor shall be
closed.
RETURN VALUE
Upon successful completion, the dirfd() function shall return an integer which contains a file descriptor for the stream
pointed to by dirp. Otherwise, it shall return -1 and shall set errno to indicate the error.
ERRORS
The dirfd() function shall fail if:
[EMFILE]
A new file descriptor is required and all file descriptors available to the process are currently open.
[ENFILE]
A new file descriptor is required and the maximum allowable number of files is currently open in the system.
The dirfd() function may fail if:
[EINVAL]
The dirp argument does not refer to a valid directory stream.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The dirfd() function is intended to be a mechanism by which an application may obtain a file descriptor to use for the
fchdir() function.
RATIONALE
This interface was introduced because the Base Definitions volume of POSIX.1-2024 does not make public the DIR data
structure. Applications tend to use the fchdir() function on the file descriptor
returned by this interface, and this has proven useful for security reasons; in particular, it is a better technique than others
where directory names might change.
On an implementation where reading from a directory stream does not use a file descriptor, opendir() need not allocate one to be returned by dirfd(). The implementation can
instead delay the allocation of a suitable file descriptor until the first time dirfd() is called for the stream. A file
descriptor allocated by dirfd() must be closed by closedir().
FUTURE DIRECTIONS
None.
SEE ALSO
closedir(), fchdir(), fdopendir(), fileno(), open(), readdir()
XBD
CHANGE HISTORY
First released in Issue 7.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0067 [422] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0076 [572] is applied.
Issue 8
Austin Group Defects 391 and 1359 are applied, changing the DESCRIPTION and RATIONALE sections, and adding the [EMFILE] and
[ENFILE] errors.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/select.html =====
pselect
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pselect, select — synchronous I/O multiplexing
SYNOPSIS
#include
int pselect(int nfds, fd_set *restrict readfds,
fd_set *restrict writefds, fd_set *restrict errorfds,
const struct timespec *restrict timeout,
const sigset_t *restrict sigmask);
int select(int nfds, fd_set *restrict readfds,
fd_set *restrict writefds, fd_set *restrict errorfds,
struct timeval *restrict timeout);
void FD_CLR(int fd, fd_set *fdset);
int FD_ISSET(int fd, const fd_set *fdset);
void FD_SET(int fd, fd_set *fdset);
void FD_ZERO(fd_set *fdset);
DESCRIPTION
The pselect() function shall examine the file descriptor sets whose addresses are passed in the readfds,
writefds, and errorfds parameters to see whether some of their descriptors are ready for reading, are ready for
writing, or have an exceptional condition pending, respectively.
The select() function shall be equivalent to the pselect() function, except as follows:
For the select() function, the timeout period is given in seconds and microseconds in an argument of type struct
timeval, whereas for the pselect() function the timeout period is given in seconds and nanoseconds in an argument of
type struct timespec.
The select() function has no sigmask argument; it shall behave as pselect() does when sigmask is a
null pointer.
Upon successful completion, the select() function may modify the object pointed to by the timeout argument.
The pselect() and select() functions shall support regular files, terminal and pseudo-terminal devices, FIFOs,
pipes, and sockets. The behavior of pselect() and select() on file descriptors that refer to other types of file is
unspecified.
The nfds argument specifies the range of descriptors to be tested. The first nfds descriptors shall be checked in
each set; that is, the descriptors from zero through nfds-1 in the descriptor sets shall be examined.
If the readfds argument is not a null pointer, it points to an object of type fd_set that on input specifies the
file descriptors to be checked for being ready to read, and on output indicates which file descriptors are ready to read.
If the writefds argument is not a null pointer, it points to an object of type fd_set that on input specifies the
file descriptors to be checked for being ready to write, and on output indicates which file descriptors are ready to write.
If the errorfds argument is not a null pointer, it points to an object of type fd_set that on input specifies the
file descriptors to be checked for error conditions pending, and on output indicates which file descriptors have error conditions
pending.
Upon successful completion, the pselect() or select() function shall modify the objects pointed to by the
readfds, writefds, and errorfds arguments to indicate which file descriptors are ready for reading, ready for
writing, or have an error condition pending, respectively, and shall return the total number of ready descriptors in all the output
sets. For each file descriptor less than nfds, the corresponding bit shall be set upon successful completion if it was set
on input and the associated condition is true for that file descriptor.
If none of the selected descriptors are ready for the requested operation, the pselect() or select() function
shall block until at least one of the requested operations becomes ready, until the timeout occurs, or until interrupted by
a signal. The timeout parameter controls how long the pselect() or select() function shall take before timing
out. If the timeout parameter is not a null pointer, it specifies a maximum interval to wait for the selection to complete.
If the specified time interval expires without any requested operation becoming ready, the function shall return. If the
timeout parameter is a null pointer, then the call to pselect() or select() shall block indefinitely until at
least one descriptor meets the specified criteria. To effect a poll, the timeout parameter should not be a null pointer, and
should point to a zero-valued timespec structure.
The use of a timeout does not affect any pending timers set up by alarm().
Implementations may place limitations on the maximum timeout interval supported. All implementations shall support a maximum
timeout interval of at least 31 days. If the timeout argument specifies a timeout interval greater than the
implementation-defined maximum value, the maximum value shall be used as the actual timeout value. Implementations may also place
limitations on the granularity of timeout intervals. If the requested timeout interval requires a finer granularity than the
implementation supports, the actual timeout interval shall be rounded up to the next supported value.
If sigmask is not a null pointer, then the pselect() function shall replace the signal mask of the caller by the
set of signals pointed to by sigmask before examining the descriptors, and shall restore the signal mask of the calling
thread before returning. If a signal is unmasked as a result of the signal mask being altered by pselect(), and a
signal-catching function is called for that signal during the execution of the pselect() function, and SA_RESTART is clear
for the interrupting signal, then
If none of the selected file descriptors are ready, pselect() shall immediately fail with the [EINTR] error after the
signal-catching function returns.
If one or more of the selected file descriptors are ready, it is unspecified whether pselect() behaves the same as if
none of the descriptors were ready (failing with [EINTR] as above) or behaves the same as if it was not interrupted (returning the
total number of ready descriptors).
A descriptor shall be considered ready for reading when a call to an input function with O_NONBLOCK clear would not block,
whether or not the function would transfer data successfully. (The function might return data, an end-of-file indication, or an
error other than one indicating that it is blocked, and in each of these cases the descriptor shall be considered ready for
reading.)
A descriptor shall be considered ready for writing when a call to an output function with O_NONBLOCK clear would not block,
whether or not the function would transfer data successfully.
If a socket has a pending error, it shall be considered to have an exceptional condition pending. Otherwise, what constitutes an
exceptional condition is file type-specific. For a file descriptor for use with a socket, it is protocol-specific except as noted
below. For other file types it is implementation-defined. If the operation is meaningless for a particular file type,
pselect() or select() shall indicate that the descriptor is ready for read or write operations, and shall indicate
that the descriptor has no exceptional condition pending.
If a descriptor refers to a socket, the implied input function is the recvmsg()
function with parameters requesting normal and ancillary data, such that the presence of either type shall cause the socket to be
marked as readable. The presence of out-of-band data shall be checked if the socket option SO_OOBINLINE has been enabled, as
out-of-band data is enqueued with normal data. If the socket is currently listening, then it shall be marked as readable if an
incoming connection request has been received, and a call to the accept() or accept4() function shall complete without blocking.
If a descriptor refers to a socket, the implied output function is the sendmsg()
function supplying an amount of normal data equal to the current value of the SO_SNDLOWAT option for the socket. If a non-blocking
call to the connect() function has been made for a socket, and the connection
attempt has either succeeded or failed leaving a pending error, the socket shall be marked as writable.
A socket shall be considered to have an exceptional condition pending if a receive operation with O_NONBLOCK clear for the open
file description and with the MSG_OOB flag set would return out-of-band data without blocking. (It is protocol-specific whether the
MSG_OOB flag would be used to read out-of-band data.) A socket shall also be considered to have an exceptional condition pending if
an out-of-band data mark is present in the receive queue. Other circumstances under which a socket may be considered to have an
exceptional condition pending are protocol-specific and implementation-defined.
If the readfds, writefds, and errorfds arguments are all null pointers and the timeout argument is
not a null pointer, the pselect() or select() function shall block for the time specified, or until interrupted by a
signal. If the readfds, writefds, and errorfds arguments are all null pointers and the timeout argument
is a null pointer, the pselect() or select() function shall block until interrupted by a signal.
File descriptors associated with regular files shall always select true for ready to read, ready to write, and error
conditions.
On failure, the objects pointed to by the readfds, writefds, and errorfds arguments shall not be modified.
If the timeout interval expires without the specified condition being true for any of the specified file descriptors, the objects
pointed to by the readfds, writefds, and errorfds arguments shall have all bits set to 0.
File descriptor masks of type fd_set can be initialized and tested with FD_CLR(), FD_ISSET(),
FD_SET(), and FD_ZERO(). It is unspecified whether each of these is a macro or a function. If a macro definition is
suppressed in order to access an actual function, or a program defines an external identifier with any of these names, the behavior
is undefined.
FD_CLR(fd, fdsetp) shall remove the file descriptor fd from the set pointed to by fdsetp. If
fd is not a member of this set, there shall be no effect on the set, and this shall not be treated as an error.
FD_ISSET(fd, fdsetp) shall evaluate to non-zero if the file descriptor fd is a member of the set
pointed to by fdsetp, and shall evaluate to zero otherwise.
FD_SET(fd, fdsetp) shall add the file descriptor fd to the set pointed to by fdsetp. If the
file descriptor fd is already in this set, there shall be no effect on the set, and this shall not be treated as an
error.
FD_ZERO(fdsetp) shall initialize the descriptor set pointed to by fdsetp to the null set. No error is
returned if the set is not empty at the time FD_ZERO() is invoked.
The behavior of these macros is undefined if the fd argument is less than 0 or greater than or equal to FD_SETSIZE, or if
fd is not a valid file descriptor, or if any of the arguments are expressions with side-effects.
If a thread gets canceled during a pselect() call, the signal mask in effect when executing the registered cleanup
functions is either the original signal mask or the signal mask installed as part of the pselect() call.
RETURN VALUE
Upon successful completion, the pselect() and select() functions shall return the total number of bits set in the
bit masks. Otherwise, -1 shall be returned, and errno shall be set to indicate the error.
FD_CLR(), FD_SET(), and FD_ZERO() do not return a value. FD_ISSET() shall return a non-zero value if
the bit for the file descriptor fd is set in the file descriptor set pointed to by fdset, and 0 otherwise.
ERRORS
Under the following conditions, pselect() and select() shall fail and set errno to:
[EBADF]
One or more of the file descriptor sets specified a file descriptor that is not a valid open file descriptor.
[EINTR]
The function was interrupted by a signal.
If SA_RESTART has been set for the interrupting signal, it is implementation-defined whether the function restarts or returns
with [EINTR].
[EINVAL]
An invalid timeout interval was specified.
[EINVAL]
The nfds argument is less than 0 or greater than FD_SETSIZE.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The use of select() and pselect() requires that the application construct the set of file descriptors to work on
each time through a polling loop, and is inherently limited from operating on file descriptors larger than FD_SETSIZE. Also, the
amount of work to perform scales as nfds increases, even if the number of file descriptors selected within the larger set
remains the same. Thus, applications may wish to consider using poll() and ppoll() instead, for better scaling.
When a pselect() or select() call indicates a file descriptor is ready for reading, this means that if an attempt
to read data had been made at the time that the status of the file descriptor was checked, it would have returned at least one byte
of data, an end-of-file indication, or an error, without blocking (even if O_NONBLOCK is clear). When a pselect() or
select() call indicates that a file descriptor is ready for writing, this means that if an attempt to write one byte of data
had been made at the time that the status of the file descriptor was checked, it would have written that byte or returned an error,
without blocking. However, if an attempt to write more than one byte had been made, it might have blocked (if O_NONBLOCK is clear).
In both cases, by the time the call returns and a subsequent I/O operation is attempted, the state of the file descriptor might
have changed (for example, because another thread read or wrote some data) and, if O_NONBLOCK is clear, there is no guarantee that
the operation will not block (unless it would not block for some other reason, such as setting MIN=0 and TIME=0 for a terminal in
non-canonical mode). Therefore it is recommended that applications always set O_NONBLOCK on file descriptors whose readiness for
I/O they query with pselect() or select().
RATIONALE
In earlier versions of the Single UNIX Specification, the select() function was defined in the  header. This is now changed to . The rationale for this change was as follows: the introduction of
the pselect() function included the  header and the
header defines all the related definitions for the
pselect() and select() functions. Backwards-compatibility to existing XSI implementations is handled by allowing
to include .
Code which wants to avoid the ambiguity of the signal mask for thread cancellation handlers can install an additional
cancellation handler which resets the signal mask to the expected value.
void cleanup(void *arg)
{
sigset_t *ss = (sigset_t *) arg;
pthread_sigmask(SIG_SETMASK, ss, NULL);
}
int call_pselect(int nfds, fd_set *readfds, fd_set *writefds,
fd_set errorfds, const struct timespec *timeout,
const sigset_t *sigmask)
{
sigset_t oldmask;
int result;
pthread_sigmask(SIG_SETMASK, NULL, &oldmask);
pthread_cleanup_push(cleanup, &oldmask);
result = pselect(nfds, readfds, writefds, errorfds, timeout, sigmask);
pthread_cleanup_pop(0);
return result;
}
FUTURE DIRECTIONS
None.
SEE ALSO
accept(), alarm(), connect(), fcntl(), poll(), read(), recvmsg(), sendmsg(), write()
XBD ,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
In the ERRORS section, the text has been changed to indicate that [EINVAL] is returned when nfds is less than 0 or
greater than FD_SETSIZE. It previously stated less than 0, or greater than or equal to FD_SETSIZE.
Text about timeout is moved from the APPLICATION USAGE section to the DESCRIPTION.
Issue 6
The Open Group Corrigendum U026/6 is applied, changing the occurrences of readfs and writefs in the
select() DESCRIPTION to be readfds and writefds.
Text referring to sockets is added to the DESCRIPTION.
The DESCRIPTION and ERRORS sections are updated so that references to STREAMS are marked as part of the XSI STREAMS Option
Group.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
These functions are now mandatory.
The pselect() function is added for alignment with IEEE Std 1003.1g-2000 and additional detail related to
sockets semantics is added to the DESCRIPTION.
The select() function now requires inclusion of .
The restrict keyword is added to the select() prototype for alignment with the ISO/IEC 9899:1999
standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/70 is applied, updating the DESCRIPTION to reference the signal
mask in terms of the calling thread rather than the process.
Issue 7
SD5-XSH-ERN-122 is applied, adding text to the DESCRIPTION for when a thread is canceled during a call to pselect(), and
adding example code to the RATIONALE.
Functionality relating to the XSI STREAMS option is marked obsolescent.
Functionality relating to the Threads option is moved to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0446 [372] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0259 [680] is applied.
Issue 8
Austin Group Defect 220 is applied, adding const to the second parameter of FD_ISSET().
Austin Group Defect 411 is applied, adding accept4().
Austin Group Defect 1186 is applied, clarifying the behavior when the pselect() function is interrupted by a signal.
Austin Group Defect 1263 is applied, changing the APPLICATION USAGE section.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
Austin Group Defect 1448 is applied, changing the APPLICATION USAGE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strncat.html =====
strncat
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strncat — concatenate a string with part of another
SYNOPSIS
#include
char *strncat(char *restrict s1, const char *restrict s2, size_t n);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The strncat() function shall append not more than n bytes (a NUL character and bytes that follow it are not
appended) from the array pointed to by s2 to the end of the string pointed to by s1. The initial byte of s2
overwrites the NUL character at the end of s1. A terminating NUL character is always appended to the result. If copying
takes place between objects that overlap, the behavior is undefined.
[CX]  The
strncat() function shall not change the setting of errno on valid input.
RETURN VALUE
The strncat() function shall return s1; no return value shall be reserved to indicate an error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
strcat(), strlcat()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The strncat() prototype is updated for alignment with the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that strncat() does not change the setting of errno on
valid input.
Austin Group Defect 986 is applied, adding strlcat() to the SEE ALSO section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/setstate.html =====
initstate
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
initstate, random, setstate, srandom — pseudo-random number functions
SYNOPSIS
[XSI]  #include
char *initstate(unsigned seed, char *state, size_t size);
long random(void);
char *setstate(char *state);
void srandom(unsigned seed);
DESCRIPTION
The random() function shall use a non-linear additive feedback random-number generator employing a default state array
size of 31 long integers to return successive pseudo-random numbers in the range from 0 to 231-1.
The period of this random-number generator is approximately 16 x (231-1). The size of the state array
determines the period of the random-number generator. Increasing the state array size shall increase the period.
With 256 bytes of state information, the period of the random-number generator shall be greater than
269.
Like rand(), random() shall produce by default a sequence of numbers that can
be duplicated by calling srandom() with 1 as the seed.
The srandom() function shall initialize the current state array using the value of seed.
The initstate() and setstate() functions handle restarting and changing random-number generators. The
initstate() function allows a state array, pointed to by the state argument, to be initialized for future use. The
size argument, which specifies the size in bytes of the state array, shall be used by initstate() to decide what type
of random-number generator to use; the larger the state array, the more random the numbers. Values for the amount of state
information are 8, 32, 64, 128, and 256 bytes. Other values greater than 8 bytes are rounded down to the nearest one of these
values. If initstate() is called with 8
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
In the DESCRIPTION, the phrase "values smaller than 8" is replaced with "values greater than or equal to 8, or less than
32", "size>>
===== susv5-html/functions/dlclose.html =====
dlclose
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
dlclose — close a symbol table handle
SYNOPSIS
#include
int dlclose(void *handle);
DESCRIPTION
The dlclose() function shall inform the system that the symbol table handle specified by handle is no longer
needed by the application.
An application writer may use dlclose() to make a statement of intent on the part of the process, but this statement does
not create any requirement upon the implementation. When the symbol table handle is closed, the implementation may unload the
executable object files that were loaded by dlopen() when the symbol table handle was
opened and those that were loaded by dlsym() when using the symbol table handle
identified by handle.
Once a symbol table handle has been closed, an application should assume that any symbols (function identifiers and data object
identifiers) made visible using handle, are no longer available to the process.
Although a dlclose() operation is not required to remove any functions or data objects from the address space, neither is
an implementation prohibited from doing so. The only restriction on such a removal is that no function nor data object shall be
removed to which references have been relocated, until or unless all such references are removed. For instance, an executable
object file that had been loaded with a dlopen() operation specifying the RTLD_GLOBAL
flag might provide a target for dynamic relocations performed in the processing of other relocatable objects—in such environments,
an application may assume that no relocation, once made, shall be undone or remade unless the executable object file containing the
relocated object has itself been removed.
RETURN VALUE
If the referenced symbol table handle was successfully closed, dlclose() shall return 0. If handle does not refer
to an open symbol table handle or if the symbol table handle could not be closed, dlclose() shall return a non-zero value.
More detailed diagnostic information shall be available through dlerror().
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
The following example illustrates use of dlopen() and dlclose():
#include
int eret;
void *mylib;
...
/* Open a dynamic library and then close it ... */
mylib = dlopen("mylib.so", RTLD_LOCAL | RTLD_LAZY);
...
eret = dlclose(mylib);
...
APPLICATION USAGE
A conforming application should employ a symbol table handle returned from a dlopen() invocation only within a given scope bracketed by a dlopen() operation and the corresponding dlclose() operation. Implementations are free
to use reference counting or other techniques such that multiple calls to dlopen()
referencing the same executable object file may return a pointer to the same data object as the symbol table handle.
Implementations are also free to re-use a handle. For these reasons, the value of a handle must be treated as an opaque data
type by the application, used only in calls to dlsym() and dlclose().
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
dladdr(), dlerror(), dlopen(), dlsym()
XBD
CHANGE HISTORY
First released in Issue 5.
Issue 6
The DESCRIPTION is updated to say that the referenced object is closed "if this is the last reference to it".
Issue 7
The dlopen() function is moved from the XSI option to Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0069 [74] is applied.
Issue 8
Austin Group Defect 993 is applied, adding dladdr() to the SEE ALSO section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/cabsf.html =====
cabs
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cabs, cabsf, cabsl — return a complex absolute value
SYNOPSIS
#include
double cabs(double complex z);
float cabsf(float complex z);
long double cabsl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex absolute value (also called norm, modulus, or magnitude) of z.
RETURN VALUE
These functions shall return the complex absolute value.
[MXC]
cabs(x + iy), cabs(y + ix), and cabs(x - iy) shall return exactly
the same value.
If z is ±0 ± i0, +0 shall be returned.
If the real or imaginary part of z is ±Inf, +Inf shall be returned, even if the other part is NaN.
If the real or imaginary part of z is NaN and the other part is not ±Inf, NaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/setjmp.html =====
setjmp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
setjmp — set jump point for a non-local goto
SYNOPSIS
#include
int setjmp(jmp_buf env);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
A call to setjmp() shall save the calling environment in its env argument for later use by longjmp().
It is unspecified whether setjmp() is a macro or a function. If a macro definition is suppressed in order to access an
actual function, or a program defines an external identifier with the name setjmp, the behavior is undefined.
An application shall ensure that an invocation of setjmp() appears in one of the following contexts only:
The entire controlling expression of a selection or iteration statement
One operand of a relational or equality operator with the other operand an integral constant expression, with the resulting
expression being the entire controlling expression of a selection or iteration statement
The operand of a unary '!' operator with the resulting expression being the entire controlling expression of a
selection or iteration
The entire expression of an expression statement (possibly cast to void)
If the invocation appears in any other context, the behavior is undefined.
RETURN VALUE
If the return is from a direct invocation, setjmp() shall return 0. If the return is from a call to longjmp(), setjmp() shall return a non-zero value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
In general, sigsetjmp() is more useful in dealing with errors and interrupts
encountered in a low-level subroutine of a program.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
longjmp(), sigsetjmp()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mkfifo.html =====
mkfifo
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mkfifo, mkfifoat — make a FIFO special file
SYNOPSIS
#include
int mkfifo(const char *path, mode_t mode);
[OH] #include
int mkfifoat(int fd, const char *path, mode_t mode);
DESCRIPTION
The mkfifo() function shall create a new FIFO special file named by the pathname pointed to by path. The file
permission bits of the new FIFO shall be initialized from mode. The file permission bits of the mode argument shall
be modified by the process' file creation mask.
When bits in mode other than the file permission bits are set, the effect is implementation-defined.
If path names a symbolic link, mkfifo() shall fail and set errno to [EEXIST].
The FIFO's user ID shall be set to the process' effective user ID. The FIFO's group ID shall be set to the group ID of the
parent directory or to the effective group ID of the process. Implementations shall provide a way to initialize the FIFO's group ID
to the group ID of the parent directory. Implementations may, but need not, provide an implementation-defined way to initialize the
FIFO's group ID to the effective group ID of the calling process.
Upon successful completion, mkfifo() shall mark for update the last data access, last data modification, and last file
status change timestamps of the file. Also, the last data modification and last file status change timestamps of the directory that
contains the new entry shall be marked for update.
The mkfifoat() function shall be equivalent to the mkfifo() function except in the case where path
specifies a relative path. In this case the newly created FIFO is created relative to the directory associated with the file
descriptor fd instead of the current working directory. If the access mode of the open file description associated with the
file descriptor is not O_SEARCH, the function shall check whether directory searches are permitted using the current permissions of
the directory underlying the file descriptor. If the access mode is O_SEARCH, the function shall not perform the check.
If mkfifoat() is passed the special value AT_FDCWD in the fd parameter, the current working directory shall be
used and the behavior shall be identical to a call to mkfifo().
RETURN VALUE
Upon successful completion, these functions shall return 0. Otherwise, these functions shall return -1 and set errno to
indicate the error. If -1 is returned, no FIFO shall be created.
ERRORS
These functions shall fail if:
[EACCES]
A component of the path prefix denies search permission, or write permission is denied on the parent directory of the FIFO to
be created.
[EEXIST]
The named file already exists.
[EILSEQ]
The last pathname component of path is not a portable filename, and cannot be created in the target directory.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of the path prefix of path does not name an existing file or path is an empty string.
[ENOENT] or [ENOTDIR]
The path argument contains at least one non- character and ends with one or more trailing
characters. If path without the trailing  characters would name an existing file, an [ENOENT] error shall not
occur.
[ENOSPC]
The directory that would contain the new file cannot be extended or the file system is out of file-allocation resources.
[ENOTDIR]
A component of the path prefix names an existing file that is neither a directory nor a symbolic link to a directory.
[EROFS]
The named file resides on a read-only file system.
The mkfifoat() function shall fail if:
[EACCES]
The access mode of the open file description associated with fd is not O_SEARCH and the permissions of the directory
underlying fd do not permit directory searches.
[EBADF]
The path argument does not specify an absolute path and the fd argument is neither AT_FDCWD nor a valid file
descriptor open for reading or searching.
[ENOTDIR]
The path argument is not an absolute path and fd is a file descriptor associated with a non-directory file.
These functions may fail if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
The following sections are informative.
EXAMPLES
Creating a FIFO File
The following example shows how to create a FIFO file named /home/cnd/mod_done, with read/write permissions for owner,
and with read permissions for group and others.
#include
#include
int status;
...
status = mkfifo("/home/cnd/mod_done", S_IWUSR | S_IRUSR |
S_IRGRP | S_IROTH);
APPLICATION USAGE
None.
RATIONALE
The syntax of this function is intended to maintain compatibility with historical implementations of mknod(). The latter function was included in the 1984 /usr/group standard but only for use in
creating FIFO special files. The mknod() function was originally excluded from the
POSIX.1-1988 standard as implementation-defined and replaced by mkdir() and
mkfifo(). The mknod() function is now included for alignment with the Single
UNIX Specification.
The POSIX.1-1990 standard required that the group ID of a newly created FIFO be set to the group ID of its parent directory or
to the effective group ID of the creating process. FIPS 151-2 required that implementations provide a way to have the group ID be
set to the group ID of the containing directory, but did not prohibit implementations also supporting a way to set the group ID to
the effective group ID of the creating process. Conforming applications should not assume which group ID will be used. If it
matters, an application can use chown() to set the group ID after the FIFO is created,
or determine under what conditions the implementation will set the desired group ID.
The purpose of the mkfifoat() function is to create a FIFO special file in directories other than the current working
directory without exposure to race conditions. Any part of the path of a file could be changed in parallel to a call to
mkfifo(), resulting in unspecified behavior. By opening a file descriptor for the target directory and using the
mkfifoat() function it can be guaranteed that the newly created FIFO is located relative to the desired directory.
Implementations are encouraged to have mkfifo() and mkfifoat() report an [EILSEQ] error if the last component of
path contains any bytes that have the encoded value of a  character.
FUTURE DIRECTIONS
None.
SEE ALSO
chmod(), mknod(),
umask()
XBD , ,
CHANGE HISTORY
First released in Issue 3. Included for alignment with the POSIX.1-1988 standard.
Issue 6
In the SYNOPSIS, the optional include of the  header is
removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
The [ELOOP] mandatory error condition is added.
A second [ENAMETOOLONG] is added as an optional error condition.
The following changes were made to align with the IEEE P1003.1a draft standard:
The [ELOOP] optional error condition is added.
Issue 7
Austin Group Interpretation 1003.1-2001 #143 is applied.
The mkfifoat() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 2.
Changes are made related to support for finegrained timestamps.
Changes are made to allow a directory to be opened for searching.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0383 [461], XSH/TC1-2008/0384 [146,435], XSH/TC1-2008/0385 [324],
XSH/TC1-2008/0386 [278], and XSH/TC1-2008/0387 [278] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0216 [873], XSH/TC2-2008/0217 [591], XSH/TC2-2008/0218 [817],
XSH/TC2-2008/0219 [822], XSH/TC2-2008/0220 [817], and XSH/TC2-2008/0221 [591] are applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defect 293 is applied, adding the [EILSEQ] error.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/casinhf.html =====
casinh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
casinh, casinhf, casinhl — complex arc hyperbolic sine functions
SYNOPSIS
#include
double complex casinh(double complex z);
float complex casinhf(float complex z);
long double complex casinhl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex arc hyperbolic sine of z, with branch cuts outside the interval
[-i, +i] along the imaginary axis.
RETURN VALUE
These functions shall return the complex arc hyperbolic sine value, in the range of a strip mathematically unbounded along the
real axis and in the interval [-iℼ/2, +iℼ/2] along the imaginary axis.
[MXC]
casinh(conj(z)), casinhf(conjf(z)), and casinhl(conjl(z)) shall
return exactly the same value as conj(casinh(z)), conjf(casinhf(z)), and
conjl(casinhl(z)), respectively, and casinh(-z), casinhf(-z), and
casinhl(-z) shall return exactly the same value as -casinh(z), -casinhf(z), and
-casinhl(z), respectively, including for the special values of z below.
If z is +0 + i0, 0 + i0 shall be returned.
If z is x + iInf where x is positive-signed and finite, +Inf + iℼ/2 shall be returned.
If z is x + iNaN where x is finite, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is +Inf + iy where y is positive-signed and finite, +Inf + i0 shall be returned.
If z is +Inf + iInf, +Inf + iℼ/4 shall be returned.
If z is +Inf + iNaN, +Inf + iNaN shall be returned.
If z is NaN + i0, NaN + i0 shall be returned.
If z is NaN + iy where y is non-zero and finite, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is NaN + iInf, ±Inf + iNaN shall be returned; the sign of the real part of the result is
unspecified.
If z is NaN + iNaN, NaN + iNaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
csinh()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/cbrtl.html =====
cbrt
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cbrt, cbrtf, cbrtl — cube root functions
SYNOPSIS
#include
double cbrt(double x);
float cbrtf(float x);
long double cbrtl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the real cube root of their argument x.
RETURN VALUE
Upon successful completion, these functions shall return the cube root of x.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0 or ±Inf, x shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
For some applications, a true cube root function, which returns negative results for negative arguments, is more appropriate
than pow(x, 1.0/3.0), which returns a NaN for x less than 0.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The cbrt() function is no longer marked as an extension.
The cbrtf() and cbrtl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strchr.html =====
strchr
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strchr — string scanning operation
SYNOPSIS
#include
char *strchr(const char *s, int c);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The strchr() function shall locate the first occurrence of c (converted to a char) in the string pointed to
by s. The terminating NUL character is considered to be part of the string.
[CX]  The
strchr() function shall not change the setting of errno on valid input.
RETURN VALUE
Upon completion, strchr() shall return a pointer to the byte, or a null pointer if the byte was not found.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
strrchr()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
Extensions beyond the ISO C standard are marked.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that strchr() does not change the setting of errno on
valid input.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sinl.html =====
sin
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sin, sinf, sinl — sine function
SYNOPSIS
#include
double sin(double x);
float sinf(float x);
long double sinl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the sine of their argument x, measured in radians.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the sine of x.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, x shall be returned.
If x is ±Inf, a domain error shall occur, and a NaN shall be returned.
[MXX]
If x is subnormal, x should be returned.
[MX]  If x is subnormal, a range error may occur and, if x is
not returned, sin(), sinf(), and sinl() shall return an implementation-defined value no greater in magnitude
than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
ERRORS
These functions shall fail if:
Domain Error
[MX]
The x argument is ±Inf.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
These functions may fail if:
Range Error
[MX]
The value of x is subnormal
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
Taking the Sine of a 45-Degree Angle
#include
...
double radians = 45.0 * M_PI / 180;
double result;
...
result = sin(radians);
APPLICATION USAGE
These functions may lose accuracy when their argument is near a multiple of ℼ or is far from 0.0.
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
asin(), feclearexcept(),
fetestexcept(), isnan()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The last two paragraphs of the DESCRIPTION were included as APPLICATION USAGE notes in previous issues.
Issue 6
The sinf() and sinl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0585 [68] and XSH/TC1-2008/0586 [320] are applied.
Issue 8
Austin Group Defect 1382 is applied, rearranging the text describing the behavior when x is subnormal to avoid the need
for two shading changes.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_mutexattr_getrobust.html =====
pthread_mutexattr_getrobust
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_mutexattr_getrobust, pthread_mutexattr_setrobust — get and set the mutex robust attribute
SYNOPSIS
#include
int pthread_mutexattr_getrobust(const pthread_mutexattr_t *restrict
attr, int *restrict robust);
int pthread_mutexattr_setrobust(pthread_mutexattr_t *attr,
int robust);
DESCRIPTION
The pthread_mutexattr_getrobust() and pthread_mutexattr_setrobust() functions, respectively, shall get and set the
mutex robust attribute. This attribute is set in the robust parameter. Valid values for robust include:
PTHREAD_MUTEX_STALLED
No special actions are taken if the owner of the mutex is terminated while holding the mutex lock. This can lead to deadlocks if no
other thread can unlock the mutex.
This is the default value.
PTHREAD_MUTEX_ROBUST
If the process containing the owning thread of a robust mutex terminates while holding the mutex lock, the next thread that
acquires the mutex shall be notified about the termination by the return value [EOWNERDEAD] from the locking function. If the
owning thread of a robust mutex terminates while holding the mutex lock, the next thread that attempts to acquire the mutex may be
notified about the termination by the return value [EOWNERDEAD]. The notified thread can then attempt to make the state protected
by the mutex consistent again, and if successful can mark the mutex state as consistent by calling pthread_mutex_consistent(). After a subsequent successful call to pthread_mutex_unlock(), the mutex lock shall be released and can be used
normally by other threads. If the mutex is unlocked without a call to pthread_mutex_consistent(), it shall be in a permanently unusable state and
all attempts to lock the mutex shall fail with the error [ENOTRECOVERABLE]. The only permissible operation on such a mutex is
pthread_mutex_destroy().
The behavior is undefined if the value specified by the attr argument to pthread_mutexattr_getrobust() or
pthread_mutexattr_setrobust() does not refer to an initialized mutex attributes object.
RETURN VALUE
Upon successful completion, the pthread_mutexattr_getrobust() function shall return zero and store the value of the
robust attribute of attr into the object referenced by the robust parameter. Otherwise, an error value shall
be returned to indicate the error. If successful, the pthread_mutexattr_setrobust() function shall return zero; otherwise,
an error number shall be returned to indicate the error.
ERRORS
The pthread_mutexattr_setrobust() function shall fail if:
[EINVAL]
The value of robust is invalid.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The actions required to make the state protected by the mutex consistent again are solely dependent on the application. If it is
not possible to make the state of a mutex consistent, robust mutexes can be used to notify this situation by calling pthread_mutex_unlock() without a prior call to pthread_mutex_consistent().
If the state is declared inconsistent by calling pthread_mutex_unlock() without a prior call to pthread_mutex_consistent(), a possible approach could be to destroy the
mutex and then reinitialize it. However, it should be noted that this is possible only in certain situations where the state
protected by the mutex has to be reinitialized and coordination achieved with other threads blocked on the mutex, because otherwise
a call to a locking function with a reference to a mutex object invalidated by a call to pthread_mutex_destroy() results in undefined behavior.
RATIONALE
If an implementation detects that the value specified by the attr argument to pthread_mutexattr_getrobust() or
pthread_mutexattr_setrobust() does not refer to an initialized mutex attributes object, it is recommended that the function
should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_mutex_consistent(), pthread_mutex_destroy(), pthread_mutex_lock()
XBD
CHANGE HISTORY
First released in Issue 7.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0283 [748] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_mutex_init.html =====
pthread_mutex_destroy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_mutex_destroy, pthread_mutex_init — destroy and initialize a mutex
SYNOPSIS
#include
int pthread_mutex_destroy(pthread_mutex_t *mutex);
int pthread_mutex_init(pthread_mutex_t *restrict mutex,
const pthread_mutexattr_t *restrict attr);
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
DESCRIPTION
The pthread_mutex_destroy() function shall destroy the mutex object referenced by mutex; the mutex object becomes,
in effect, uninitialized. An implementation may cause pthread_mutex_destroy() to set the object referenced by mutex
to an invalid value.
A destroyed mutex object can be reinitialized using pthread_mutex_init(); the results of otherwise referencing the object
after it has been destroyed are undefined.
It shall be safe to destroy an initialized mutex that is unlocked. Attempting to destroy a locked mutex, or a mutex that another
thread is attempting to lock, or a mutex that is being used in a pthread_cond_clockwait(), pthread_cond_timedwait(), or pthread_cond_wait() call by another thread, results in undefined behavior.
The pthread_mutex_init() function shall initialize the mutex referenced by mutex with attributes specified by
attr. If attr is NULL, the default mutex attributes are used; the effect shall be the same as passing the address of
a default mutex attributes object. Upon successful initialization, the state of the mutex becomes initialized and unlocked.
See 2.9.9 Synchronization Object Copies and Alternative Mappings
for further requirements.
Attempting to initialize an already initialized mutex results in undefined behavior.
In cases where default mutex attributes are appropriate, the macro PTHREAD_MUTEX_INITIALIZER can be used to initialize mutexes.
The effect shall be equivalent to dynamic initialization by a call to pthread_mutex_init() with parameter attr
specified as NULL, except that no error checks are performed.
The behavior is undefined if the value specified by the mutex argument to pthread_mutex_destroy() does not refer
to an initialized mutex.
The behavior is undefined if the value specified by the attr argument to pthread_mutex_init() does not refer to an
initialized mutex attributes object.
RETURN VALUE
If successful, the pthread_mutex_destroy() and pthread_mutex_init() functions shall return zero; otherwise, an
error number shall be returned to indicate the error.
ERRORS
The pthread_mutex_init() function shall fail if:
[EAGAIN]
The system lacked the necessary resources (other than memory) to initialize another mutex.
[ENOMEM]
Insufficient memory exists to initialize the mutex.
[EPERM]
The caller does not have the privilege to perform the operation.
The pthread_mutex_init() function may fail if:
[EINVAL]
The attributes object referenced by attr has the robust mutex attribute set without the process-shared attribute being
set.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
If an implementation detects that the value specified by the mutex argument to pthread_mutex_destroy() does not
refer to an initialized mutex, it is recommended that the function should fail and report an [EINVAL] error.
If an implementation detects that the value specified by the mutex argument to pthread_mutex_destroy() or
pthread_mutex_init() refers to a locked mutex or a mutex that is referenced (for example, while being used in a pthread_cond_clockwait(), pthread_cond_timedwait(), or pthread_cond_wait() call) by another thread, or detects that the value specified
by the mutex argument to pthread_mutex_init() refers to an already initialized mutex, it is recommended that the
function should fail and report an [EBUSY] error.
If an implementation detects that the value specified by the attr argument to pthread_mutex_init() does not refer
to an initialized mutex attributes object, it is recommended that the function should fail and report an [EINVAL] error.
Alternate Implementations Possible
This volume of POSIX.1-2024 supports several alternative implementations of mutexes. An implementation may store the lock
directly in the object of type pthread_mutex_t. Alternatively, an implementation may store the lock in the heap and merely
store a pointer, handle, or unique ID in the mutex object. Either implementation has advantages or may be required on certain
hardware configurations. So that portable code can be written that is invariant to this choice, this volume of POSIX.1-2024 does
not define assignment or equality for this type, and it uses the term "initialize" to reinforce the (more restrictive) notion
that the lock may actually reside in the mutex object itself.
Note that this precludes an over-specification of the type of the mutex or condition variable and motivates the opaqueness of
the type.
An implementation is permitted, but not required, to have pthread_mutex_destroy() store an illegal value into the mutex.
This may help detect erroneous programs that try to lock (or otherwise reference) a mutex that has already been destroyed.
Tradeoff Between Error Checks and Performance Supported
Many error conditions that can occur are not required to be detected by the implementation in order to let implementations trade
off performance versus degree of error checking according to the needs of their specific applications and execution
environment. As a general rule, conditions caused by the system (such as insufficient memory) are required to be detected, but
conditions caused by an erroneously coded application (such as failing to provide adequate synchronization to prevent a mutex from
being deleted while in use) are specified to result in undefined behavior.
A wide range of implementations is thus made possible. For example, an implementation intended for application debugging may
implement all of the error checks, but an implementation running a single, provably correct application under very tight
performance constraints in an embedded computer might implement minimal checks. An implementation might even be provided in two
versions, similar to the options that compilers provide: a full-checking, but slower version; and a limited-checking, but faster
version. To forbid this optionality would be a disservice to users.
By carefully limiting the use of "undefined behavior" only to things that an erroneous (badly coded) application might do, and
by defining that resource-not-available errors are mandatory, this volume of POSIX.1-2024 ensures that a fully-conforming
application is portable across the full range of implementations, while not forcing all implementations to add overhead to check
for numerous things that a correct program never does. When the behavior is undefined, no error number is specified to be returned
on implementations that do detect the condition. This is because undefined behavior means anything can happen, which
includes returning with any value (which might happen to be a valid, but different, error number). However, since the error number
might be useful to application developers when diagnosing problems during application development, a recommendation is made in
rationale that implementors should return a particular error number if their implementation does detect the condition.
Why No Limits are Defined
Defining symbols for the maximum number of mutexes and condition variables was considered but rejected because the number of
these objects may change dynamically. Furthermore, many implementations place these objects into application memory; thus, there is
no explicit maximum.
Static Initializers for Mutexes and Condition Variables
Providing for static initialization of statically allocated synchronization objects allows modules with private static
synchronization variables to avoid runtime initialization tests and overhead. Furthermore, it simplifies the coding of
self-initializing modules. Such modules are common in C libraries, where for various reasons the design calls for
self-initialization instead of requiring an explicit module initialization function to be called. An example use of static
initialization follows.
Without static initialization, a self-initializing routine foo() might look as follows:
static pthread_once_t foo_once = PTHREAD_ONCE_INIT;
static pthread_mutex_t foo_mutex;
void foo_init()
{
pthread_mutex_init(&foo_mutex, NULL);
}
void foo()
{
pthread_once(&foo_once, foo_init);
pthread_mutex_lock(&foo_mutex);
/* Do work. */
pthread_mutex_unlock(&foo_mutex);
}
With static initialization, the same routine could be coded as follows:
static pthread_mutex_t foo_mutex = PTHREAD_MUTEX_INITIALIZER;
void foo()
{
pthread_mutex_lock(&foo_mutex);
/* Do work. */
pthread_mutex_unlock(&foo_mutex);
}
Note that the static initialization both eliminates the need for the initialization test inside pthread_once() and the fetch of &foo_mutex to learn the address to be passed to
pthread_mutex_lock() or pthread_mutex_unlock().
Thus, the C code written to initialize static objects is simpler on all systems and is also faster on a large class of systems;
those where the (entire) synchronization object can be stored in application memory.
Yet the locking performance question is likely to be raised for machines that require mutexes to be allocated out of special
memory. Such machines actually have to have mutexes and possibly condition variables contain pointers to the actual hardware locks.
For static initialization to work on such machines, pthread_mutex_lock()
also has to test whether or not the pointer to the actual lock has been allocated. If it has not, pthread_mutex_lock() has to initialize it before use. The reservation of such
resources can be made when the program is loaded, and hence return codes have not been added to mutex locking and condition
variable waiting to indicate failure to complete initialization.
This runtime test in pthread_mutex_lock() would at first seem to be
extra work; an extra test is required to see whether the pointer has been initialized. On most machines this would actually be
implemented as a fetch of the pointer, testing the pointer against zero, and then using the pointer if it has already been
initialized. While the test might seem to add extra work, the extra effort of testing a register is usually negligible since no
extra memory references are actually done. As more and more machines provide caches, the real expenses are memory references, not
instructions executed.
Alternatively, depending on the machine architecture, there are often ways to eliminate all overhead in the most
important case: on the lock operations that occur after the lock has been initialized. This can be done by shifting more
overhead to the less frequent operation: initialization. Since out-of-line mutex allocation also means that an address has to be
dereferenced to find the actual lock, one technique that is widely applicable is to have static initialization store a bogus value
for that address; in particular, an address that causes a machine fault to occur. When such a fault occurs upon the first attempt
to lock such a mutex, validity checks can be done, and then the correct address for the actual lock can be filled in. Subsequent
lock operations incur no extra overhead since they do not "fault". This is merely one technique that can be used to support
static initialization, while not adversely affecting the performance of lock acquisition. No doubt there are other techniques that
are highly machine-dependent.
The locking overhead for machines doing out-of-line mutex allocation is thus similar for modules being implicitly initialized,
where it is improved for those doing mutex allocation entirely inline. The inline case is thus made much faster, and the
out-of-line case is not significantly worse.
Besides the issue of locking performance for such machines, a concern is raised that it is possible that threads would serialize
contending for initialization locks when attempting to finish initializing statically allocated mutexes. (Such finishing would
typically involve taking an internal lock, allocating a structure, storing a pointer to the structure in the mutex, and releasing
the internal lock.) First, many implementations would reduce such serialization by hashing on the mutex address. Second, such
serialization can only occur a bounded number of times. In particular, it can happen at most as many times as there are statically
allocated synchronization objects. Dynamically allocated objects would still be initialized via pthread_mutex_init() or
pthread_cond_init().
Finally, if none of the above optimization techniques for out-of-line allocation yields sufficient performance for an
application on some implementation, the application can avoid static initialization altogether by explicitly initializing all
synchronization objects with the corresponding pthread_*_init() functions, which are supported by all implementations. An
implementation can also document the tradeoffs and advise which initialization technique is more efficient for that particular
implementation.
Destroying Mutexes
A mutex can be destroyed immediately after it is unlocked. However, since attempting to destroy a locked mutex, or a mutex that
another thread is attempting to lock, or a mutex that is being used in a pthread_cond_clockwait(), pthread_cond_timedwait(), or pthread_cond_wait() call by another thread, results in undefined behavior, care
must be taken to ensure that no other thread may be referencing the mutex.
Robust Mutexes
Implementations are required to provide robust mutexes for mutexes with the process-shared attribute set to
PTHREAD_PROCESS_SHARED. Implementations are allowed, but not required, to provide robust mutexes when the process-shared attribute
is set to PTHREAD_PROCESS_PRIVATE.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_mutex_getprioceiling(), pthread_mutexattr_getrobust(), pthread_mutex_clocklock(), pthread_mutex_lock(), pthread_mutexattr_getpshared()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_mutex_destroy() and pthread_mutex_init() functions are marked as part of the Threads option.
The pthread_mutex_timedlock() function is added to the SEE ALSO
section for alignment with IEEE Std 1003.1d-1999.
IEEE PASC Interpretation 1003.1c #34 is applied, updating the DESCRIPTION.
The restrict keyword is added to the pthread_mutex_init() prototype for alignment with the ISO/IEC 9899:1999
standard.
Issue 7
Changes are made from The Open Group Technical Standard, 2006, Extended API Set Part 3.
The pthread_mutex_destroy() and pthread_mutex_init() functions are moved from the Threads option to the Base.
The [EINVAL] error for an uninitialized mutex or an uninitialized mutex attributes object is removed; this condition results in
undefined behavior.
The [EBUSY] error for a locked mutex, a mutex that is referenced, or an already initialized mutex is removed; this condition
results in undefined behavior.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0460 [70,428] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0278 [811], XSH/TC2-2008/0279 [972], and XSH/TC2-2008/0280 [811] are
applied.
Issue 8
Austin Group Defect 1216 is applied, adding pthread_cond_clockwait().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_rwlock_destroy.html =====
pthread_rwlock_destroy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_rwlock_destroy, pthread_rwlock_init — destroy and initialize a read-write lock object
SYNOPSIS
#include
int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,
const pthread_rwlockattr_t *restrict attr);
pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;
DESCRIPTION
The pthread_rwlock_destroy() function shall destroy the read-write lock object referenced by rwlock and release
any resources used by the lock. The effect of subsequent use of the lock is undefined until the lock is reinitialized by another
call to pthread_rwlock_init(). An implementation may cause pthread_rwlock_destroy() to set the object referenced by
rwlock to an invalid value. Results are undefined if pthread_rwlock_destroy() is called when any thread holds
rwlock. Attempting to destroy an uninitialized read-write lock results in undefined behavior.
The pthread_rwlock_init() function shall allocate any resources required to use the read-write lock referenced by
rwlock and initializes the lock to an unlocked state with attributes referenced by attr. If attr is NULL, the
default read-write lock attributes shall be used; the effect is the same as passing the address of a default read-write lock
attributes object. Once initialized, the lock can be used any number of times without being reinitialized. Results are undefined if
pthread_rwlock_init() is called specifying an already initialized read-write lock. Results are undefined if a read-write
lock is used without first being initialized.
If the pthread_rwlock_init() function fails, rwlock shall not be initialized and the contents of rwlock are
undefined.
See 2.9.9 Synchronization Object Copies and Alternative Mappings
for further requirements.
In cases where default read-write lock attributes are appropriate, the macro PTHREAD_RWLOCK_INITIALIZER can be used to
initialize read-write locks. The effect shall be equivalent to dynamic initialization by a call to pthread_rwlock_init()
with the attr parameter specified as NULL, except that no error checks are performed.
The behavior is undefined if the value specified by the attr argument to pthread_rwlock_init() does not refer to
an initialized read-write lock attributes object.
RETURN VALUE
If successful, the pthread_rwlock_destroy() and pthread_rwlock_init() functions shall return zero; otherwise, an
error number shall be returned to indicate the error.
ERRORS
The pthread_rwlock_init() function shall fail if:
[EAGAIN]
The system lacked the necessary resources (other than memory) to initialize another read-write lock.
[ENOMEM]
Insufficient memory exists to initialize the read-write lock.
[EPERM]
The caller does not have the privilege to perform the operation.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications using these and related read-write lock functions may be subject to priority inversion, as discussed in XBD
3.275 Priority Inversion.
RATIONALE
If an implementation detects that the value specified by the rwlock argument to pthread_rwlock_destroy() does not
refer to an initialized read-write lock object, it is recommended that the function should fail and report an [EINVAL] error.
If an implementation detects that the value specified by the attr argument to pthread_rwlock_init() does not refer
to an initialized read-write lock attributes object, it is recommended that the function should fail and report an [EINVAL]
error.
If an implementation detects that the value specified by the rwlock argument to pthread_rwlock_destroy() or
pthread_rwlock_init() refers to a locked read-write lock object, or detects that the value specified by the rwlock
argument to pthread_rwlock_init() refers to an already initialized read-write lock object, it is recommended that the
function should fail and report an [EBUSY] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_rwlock_clockrdlock(), pthread_rwlock_clockwrlock(), pthread_rwlock_rdlock(), pthread_rwlock_trywrlock(), pthread_rwlock_unlock()
XBD 3.275 Priority Inversion,
CHANGE HISTORY
First released in Issue 5.
Issue 6
The following changes are made for alignment with IEEE Std 1003.1j-2000:
The margin code in the SYNOPSIS is changed to THR to indicate that the functionality is now part of the Threads option
(previously it was part of the Read-Write Locks option in IEEE Std 1003.1j-2000 and also part of the XSI extension). The
initializer macro is also deleted from the SYNOPSIS.
The DESCRIPTION is updated as follows:
It explicitly notes allocation of resources upon initialization of a read-write lock object.
A paragraph is added specifying that copies of read-write lock objects may not be used.
An [EINVAL] error is added to the ERRORS section for pthread_rwlock_init(), indicating that the rwlock value is
invalid.
The SEE ALSO section is updated.
The restrict keyword is added to the pthread_rwlock_init() prototype for alignment with the ISO/IEC 9899:1999
standard.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/45 is applied, adding APPLICATION USAGE relating to priority
inversion.
Issue 7
Austin Group Interpretation 1003.1-2001 #048 is applied, adding the PTHREAD_RWLOCK_INITIALIZER macro.
The pthread_rwlock_destroy() and pthread_rwlock_init() functions are moved from the Threads option to the
Base.
The [EINVAL] error for an uninitialized read-write lock object or read-write lock attributes object is removed; this condition
results in undefined behavior.
The [EBUSY] error for a locked read-write lock object or an already initialized read-write lock object is removed; this
condition results in undefined behavior.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0465 [70] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0288 [972] and XSH/TC2-2008/0289 [758] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mbsinit.html =====
mbsinit
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mbsinit — determine conversion object status
SYNOPSIS
#include
int mbsinit(const mbstate_t *ps);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
If ps is not a null pointer, the mbsinit() function shall determine whether the object pointed to by ps
describes an initial conversion state.
RETURN VALUE
The mbsinit() function shall return non-zero if ps is a null pointer, or if the pointed-to object describes an
initial conversion state; otherwise, it shall return zero.
If an mbstate_t object is altered by any of the functions described as "restartable", and is then used with a different
character sequence, or in the other conversion direction, or with a different LC_CTYPE category setting than on earlier
function calls, the behavior is undefined.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The mbstate_t object is used to describe the current conversion state from a particular character sequence to a
wide-character sequence (or vice versa) under the rules of a particular setting of the LC_CTYPE category of the
current locale.
The initial conversion state corresponds, for a conversion in either direction, to the beginning of a new character sequence in
the initial shift state. A zero valued mbstate_t object is at least one way to describe an initial conversion state. A zero
valued mbstate_t object can be used to initiate conversion involving any character sequence, in any LC_CTYPE category
setting.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
mbrlen(), mbrtowc(), mbsrtowcs(), wcrtomb(), wcsrtombs()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E).
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fpathconf.html =====
fpathconf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fpathconf, pathconf — get configurable pathname variables
SYNOPSIS
#include
long fpathconf(int fildes, int name);
long pathconf(const char *path, int name);
DESCRIPTION
The fpathconf() and pathconf() functions shall determine the current value of a configurable limit or option
(variable) that is associated with a file or directory.
For pathconf(), the path argument points to the pathname of a file or directory.
For fpathconf(), the fildes argument is an open file descriptor.
The name argument represents the variable to be queried relative to that file or directory. Implementations shall support
all of the variables listed in the following table and may support others. The variables in the following table come from  or  and the
symbolic constants, defined in , are the corresponding values used
for name.
Variable
Value of name
Requirements
{FILESIZEBITS}
_PC_FILESIZEBITS
4,7
{LINK_MAX}
_PC_LINK_MAX
1
{MAX_CANON}
_PC_MAX_CANON
2
{MAX_INPUT}
_PC_MAX_INPUT
2
{NAME_MAX}
_PC_NAME_MAX
3,4
{PATH_MAX}
_PC_PATH_MAX
4,5
{PIPE_BUF}
_PC_PIPE_BUF
6
{POSIX2_SYMLINKS}
_PC_2_SYMLINKS
4
{POSIX_ALLOC_SIZE_MIN}
_PC_ALLOC_SIZE_MIN
10
{POSIX_REC_INCR_XFER_SIZE}
_PC_REC_INCR_XFER_SIZE
10
{POSIX_REC_MAX_XFER_SIZE}
_PC_REC_MAX_XFER_SIZE
10
{POSIX_REC_MIN_XFER_SIZE}
_PC_REC_MIN_XFER_SIZE
10
{POSIX_REC_XFER_ALIGN}
_PC_REC_XFER_ALIGN
10
{SYMLINK_MAX}
_PC_SYMLINK_MAX
4,9
{TEXTDOMAIN_MAX}
_PC_TEXTDOMAIN_MAX
3,4
_POSIX_CHOWN_RESTRICTED
_PC_CHOWN_RESTRICTED
7
_POSIX_NO_TRUNC
_PC_NO_TRUNC
3,4
_POSIX_VDISABLE
_PC_VDISABLE
2
_POSIX_ASYNC_IO
_PC_ASYNC_IO
8
_POSIX_FALLOC
_PC_FALLOC
8
_POSIX_PRIO_IO
_PC_PRIO_IO
8
_POSIX_SYNC_IO
_PC_SYNC_IO
8
_POSIX_TIMESTAMP_RESOLUTION
_PC_TIMESTAMP_RESOLUTION
1
Requirements
If path or fildes refers to a directory, the value returned shall apply to the directory
itself.
If path or fildes does not refer to a terminal file, it is unspecified whether an implementation
supports an association of the variable name with the specified file.
If path or fildes refers to a directory, the value returned shall apply to filenames within the
directory.
If path or fildes does not refer to a directory, it is unspecified whether an implementation
supports an association of the variable name with the specified file.
If path or fildes refers to a directory, the value returned shall be the maximum length of a
relative pathname that would not cross any mount points when the specified directory is the working directory.
If path refers to a FIFO, or fildes refers to a pipe or FIFO, the value returned shall apply to the
referenced object. If path or fildes refers to a directory, the value returned shall apply to any FIFO that exists or
can be created within the directory. If path or fildes refers to any other type of file, it is unspecified whether an
implementation supports an association of the variable name with the specified file.
If path or fildes refers to a directory, the value returned shall apply to any files, other than
directories, that exist or can be created within the directory.
If path or fildes refers to a directory, it is unspecified whether an implementation supports an
association of the variable name with the specified file.
If path or fildes refers to a directory, the value returned shall be the maximum length of the
string that a symbolic link in that directory can contain.
If path or fildes des does not refer to a regular file, it is unspecified whether an implementation
supports an association of the variable name with the specified file. If an implementation supports such an association for other
than a regular file, the value returned is unspecified.
RETURN VALUE
If name is an invalid value, both pathconf() and fpathconf() shall return -1 and set errno to
indicate the error.
If the variable corresponding to name is described in  as a maximum or minimum value and the variable has no limit for the path or
file descriptor, both pathconf() and fpathconf() shall return -1 without changing errno. Note that indefinite
limits do not imply infinite limits; see .
If the implementation needs to use path to determine the value of name and the implementation does
not support the association of name with the file specified by path, or if the process did not have appropriate
privileges to query the file specified by path, or path does not exist, pathconf() shall return -1 and set
errno to indicate the error.
If the implementation needs to use fildes to determine the value of name and the implementation does
not support the association of name with the file specified by fildes, or if fildes is an invalid file
descriptor, fpathconf() shall return -1 and set errno to indicate the error.
Otherwise, pathconf() or fpathconf() shall return the current variable value for the file or
directory without changing errno. The value returned shall not be more restrictive than the corresponding value available to
the application when it was compiled with the implementation's  or
.
If the variable corresponding to name is dependent on an unsupported option, the results are
unspecified.
ERRORS
The pathconf() function shall fail if:
[EINVAL]
The value of name is not valid.
[EOVERFLOW]
The value of name is _PC_TIMESTAMP_RESOLUTION and the resolution is larger than {LONG_MAX}.
The pathconf() function may fail if:
[EACCES]
Search permission is denied for a component of the path prefix.
[EINVAL]
The implementation does not support an association of the variable name with the specified file.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path argument.
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
[ENOENT]
A component of path does not name an existing file or path is an empty string.
[ENOTDIR]
A component of the path prefix names an existing file that is neither a directory nor a symbolic link to a directory, or the
path argument contains at least one non- character and ends with one or more trailing  characters
and the last pathname component names an existing file that is neither a directory nor a symbolic link to a directory.
The fpathconf() function shall fail if:
[EINVAL]
The value of name is not valid.
[EOVERFLOW]
The value of name is _PC_TIMESTAMP_RESOLUTION and the resolution is larger than {LONG_MAX}.
The fpathconf() function may fail if:
[EBADF]
The fildes argument is not a valid file descriptor.
[EINVAL]
The implementation does not support an association of the variable name with the specified file.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Application developers should check whether an option, such as _POSIX_ADVISORY_INFO, is supported prior to obtaining and using
values for related variables such as {POSIX_ALLOC_SIZE_MIN}.
RATIONALE
The pathconf() function was proposed immediately after the sysconf()
function when it was realized that some configurable values may differ across file system, directory, or device boundaries.
For example, {NAME_MAX} frequently changes between System V and BSD-based file systems; System V uses a maximum of
14, BSD 255. On an implementation that provides both types of file systems, an application would be forced to limit all pathname
components to 14 bytes, as this would be the value specified in  on
such a system.
Therefore, various useful values can be queried on any pathname or file descriptor, assuming that appropriate
privileges are in place.
The value returned for the variable {PATH_MAX} indicates the longest relative pathname that could be given if the
specified directory is the current working directory of the process. A process may not always be able to generate a name that long
and use it if a subdirectory in the pathname crosses into a more restrictive file system. Note that implementations are allowed to
accept pathnames longer than {PATH_MAX} bytes long, but are not allowed to return pathnames longer than this unless the user
specifies a larger buffer using a function that provides a buffer size argument.
The value returned for the variable _POSIX_CHOWN_RESTRICTED also applies to directories that do not have file
systems mounted on them. The value may change when crossing a mount point, so applications that need to know should check for each
directory. (An even easier check is to try the chown() function and look for an error
in case it happens.)
Unlike the values returned by sysconf(), the pathname-oriented
variables are potentially more volatile and are not guaranteed to remain constant throughout the lifetime of the process. For
example, in between two calls to pathconf(), the file system in question may have been unmounted and remounted with
different characteristics.
Also note that most of the errors are optional. If one of the variables always has the same value on an
implementation, the implementation need not look at path or fildes to return that value and is, therefore, not
required to detect any of the errors except the meaning of [EINVAL] that indicates that the value of name is not valid for
that variable, and the [EOVERFLOW] error that indicates the value to be returned is larger than {LONG_MAX}.
If the value of any of the limits is unspecified (logically infinite), they will not be defined in  and the pathconf() and fpathconf() functions return -1
without changing errno. This can be distinguished from the case of giving an unrecognized name argument because
errno is set to [EINVAL] in this case.
Since -1 is a valid return value for the pathconf() and fpathconf() functions, applications should
set errno to zero before calling them and check errno only if the return value is -1.
For the case of {SYMLINK_MAX}, since both pathconf() and open()
follow symbolic links, there is no way that path or fildes could refer to a symbolic link.
It was the intention of IEEE Std 1003.1d-1999 that the following variables:
{POSIX_ALLOC_SIZE_MIN}
{POSIX_REC_INCR_XFER_SIZE}
{POSIX_REC_MAX_XFER_SIZE}
{POSIX_REC_MIN_XFER_SIZE}
{POSIX_REC_XFER_ALIGN}
only applied to regular files, but Note 10 also permits implementation of the advisory semantics on other file
types unique to an implementation (for example, a character special device).
The [EOVERFLOW] error for _PC_TIMESTAMP_RESOLUTION cannot occur on POSIX-compliant file systems because POSIX
requires a timestamp resolution no larger than one second. Even on 32-bit systems, this can be represented without overflow.
FUTURE DIRECTIONS
None.
SEE ALSO
chown(), confstr(),
sysconf()
XBD ,
XCU getconf
CHANGE HISTORY
First released in Issue 3. Included for alignment with the POSIX.1-1988 standard.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Realtime Extension.
Large File Summit extensions are added.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The DESCRIPTION is updated to include {FILESIZEBITS}.
The [ELOOP] mandatory error condition is added.
A second [ENAMETOOLONG] is added as an optional error condition.
The following changes were made to align with the IEEE P1003.1a draft standard:
The _PC_SYMLINK_MAX entry is added to the table in the DESCRIPTION.
The following pathconf() variables and their associated names are added for alignment with
IEEE Std 1003.1d-1999:
{POSIX_ALLOC_SIZE_MIN}
{POSIX_REC_INCR_XFER_SIZE}
{POSIX_REC_MAX_XFER_SIZE}
{POSIX_REC_MIN_XFER_SIZE}
{POSIX_REC_XFER_ALIGN}
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/18 is applied, changing the fourth paragraph of the
DESCRIPTION and removing shading and margin markers from the table. This change is needed since implementations are required to
support all of these symbols.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/34 is applied, adding the table entry for
POSIX2_SYMLINKS in the DESCRIPTION.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/35 is applied, updating the DESCRIPTION and
RATIONALE sections to clarify behavior for the following variables:
{POSIX_ALLOC_SIZE_MIN}
{POSIX_REC_INCR_XFER_SIZE}
{POSIX_REC_MAX_XFER_SIZE}
{POSIX_REC_MIN_XFER_SIZE}
{POSIX_REC_XFER_ALIGN}
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/36 is applied, updating the RETURN VALUE and
APPLICATION USAGE sections to state that the results are unspecified if a variable is dependent on an unsupported option, and
advising application developers to check for supported options prior to obtaining and using such values.
Issue 7
Austin Group Interpretations 1003.1-2001 #143 and #160 are applied.
Changes are made related to support for finegrained timestamps.
The [ENOTDIR] error condition is clarified to cover the condition where the last component of a pathname exists but
is not a directory or a symbolic link to a directory.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0160 [256,428], XSH/TC1-2008/0161 [256,428], and
XSH/TC1-2008/0162 [324] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0124 [651] and XSH/TC2-2008/0125 [651] are applied.
Issue 8
Austin Group Defect 687 is applied, adding _POSIX_FALLOC and _PC_FALLOC.
Austin Group Defect 1122 is applied, adding {TEXTDOMAIN_MAX}.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getopt.html =====
getopt
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getopt, optarg, opterr, optind, optopt — command option parsing
SYNOPSIS
#include
int getopt(int argc, char * const argv[], const char *optstring);
extern char *optarg;
extern int opterr, optind, optopt;
DESCRIPTION
The getopt() function is a command-line parser that shall follow Utility Syntax Guidelines 3, 4, 5, 6, 7, 9, and 10 in
XBD 12.2 Utility Syntax Guidelines.
The parameters argc and argv are the argument count and argument array as passed to main() (see exec()). The argument optstring is a string of recognized option characters; if a
character is followed by a , the option takes an argument. All option characters allowed by Utility Syntax Guideline 3
are allowed in optstring. The optstring argument can optionally start with a  ('+'), which
shall have no effect on behavior in a conforming environment. If a  occurs anywhere besides the first character of
optstring, the behavior is unspecified. The implementation may accept other characters as an extension.
The variable optind is the index of the next element of the argv[] vector to be processed. It shall be initialized
to 1 by the system, and getopt() shall update it when it finishes with each element of argv[]. If the application
sets optind to zero before calling getopt(), the behavior is unspecified. When an element of argv[] contains
multiple option characters, it is unspecified how getopt() determines which options have already been processed.
The getopt() function shall return the next option character (if one is found) from argv that matches a character
in optstring (excluding an optional leading ), if there is one that matches. If the option takes an
argument, getopt() shall set the variable optarg to point to the option-argument as follows:
If the option was the last character in the string pointed to by an element of argv, then optarg shall contain the
next element of argv, and optind shall be incremented by 2. If the resulting value of optind is greater than
argc, this indicates a missing option-argument, and getopt() shall return an error indication.
Otherwise, optarg shall point to the string following the option character in that element of argv, and
optind shall be incremented by 1.
If, when getopt() is called, any of the following is true:
argv[optind]  is a null pointer
*argv[optind]  is not the character '-'
argv[optind]  points to the string "-"
getopt() shall return -1 without changing optind. If:
argv[optind]   points to the string "--"
getopt() shall return -1 after incrementing optind.
If getopt() encounters a  as an option character, or an option character that is not contained in
optstring after an optional leading , it shall return the  ('?') character.
If it detects a missing option-argument, it shall return the  character (':') if the first character of
optstring after an optional  was a , or a  character ('?')
otherwise. In either case, getopt() shall set the variable optopt to the option character that caused the error. If
the application has not set the variable opterr to 0, and the first character of optstring after an optional
is not a , getopt() shall also print a diagnostic message to stderr in the format
specified for the getopts utility, unless the stderr stream has wide
orientation, in which case the behavior is undefined.
The getopt() function need not be thread-safe.
RETURN VALUE
The getopt() function shall return the next option character specified on the command line.
A  (':') shall be returned if getopt() detects a missing argument and the first character of
optstring after an optional  was a  (':').
A  ('?') shall be returned if getopt() encounters a  as an option character,
encounters an option character not in optstring, or detects a missing argument and the first character of optstring
after an optional  was not a  (':').
Otherwise, getopt() shall return -1 when all command line options are parsed.
ERRORS
If the application has not set the variable opterr to 0, the first character of optstring is not a ,
and a write error occurs while getopt() is printing a diagnostic message to stderr, then the error indicator for
stderr shall be set; but getopt() shall still succeed and the value of errno after getopt() is
unspecified.
The following sections are informative.
EXAMPLES
Parsing Command Line Options
The following code fragment shows how you might process the arguments for a utility that can take the mutually-exclusive options
a and b and the options f and o, both of which require arguments:
#include
#include
#include
int
main(int argc, char *argv[ ])
{
int c;
int bflg = 0, aflg = 0, errflg = 0;
char *ifile;
char *ofile;
. . .
while ((c = getopt(argc, argv, ":abf:o:")) != -1) {
switch(c) {
case 'a':
if (bflg)
errflg++;
else
aflg++;
break;
case 'b':
if (aflg)
errflg++;
else
bflg++;
break;
case 'f':
ifile = optarg;
break;
case 'o':
ofile = optarg;
break;
case ':':       /* -f or -o without operand */
fprintf(stderr,
"Option -%c requires an operand\n", optopt);
errflg++;
break;
case '?':
fprintf(stderr,
"Unrecognized option: '-%c'\n", optopt);
errflg++;
}
}
if (errflg) {
fprintf(stderr, "usage: . . . ");
exit(2);
}
for ( ; optind
#include
...
const char *Options = "hdbtl";
...
int dbtype, c;
char *st;
...
dbtype = 0;
while ((c = getopt(argc, argv, Options)) != -1) {
if ((st = strchr(Options, c)) != NULL) {
dbtype = st - Options;
break;
}
}
APPLICATION USAGE
The getopt() function is only required to support option characters included in Utility Syntax Guideline 3. Many
historical implementations of getopt() support other characters as options. This is an allowed extension, but applications
that use extensions are not maximally portable. Note that support for multi-byte option characters is only possible when such
characters can be represented as type int.
Applications which use wide-character output functions with stderr should ensure that any calls to getopt() do not
write to stderr, either by setting opterr to 0 or by ensuring the first character of optstring is always a
.
While ferror(stderr) may be used to detect failures to write a diagnostic to stderr when getopt()
returns '?', the value of errno is unspecified in such a condition. Applications desiring more control over
handling write failures should set opterr to 0 and independently perform output to stderr, rather than relying on
getopt() to do the output.
RATIONALE
The optopt variable represents historical practice and allows the application to obtain the identity of the invalid
option.
The description has been written to make it clear that getopt(), like the getopts utility, deals with option-arguments whether separated from the option by
characters or not. Note that the requirements on getopt() and getopts are more stringent than the Utility Syntax Guidelines.
The getopt() function shall return -1, rather than EOF, so that  is not required.
The special significance of a  as the first character of optstring makes getopt() consistent with the
getopts utility. It allows an application to make a distinction between a missing
argument and an incorrect option letter without having to examine the option letter. It is true that a missing argument can only be
detected in one case, but that is a case that has to be considered.
In some non-conforming environments, the use of a leading  in optstring forces getopt() to behave
in a conforming way, when it would otherwise have non-conforming behavior. Its use has been standardized to allow applications to
be written that can guarantee behavior consistent with this specification even in an otherwise non-conforming environment. If both
and  are used at the beginning of optstring, the  must be first.
Note that the use of a leading  in optstring is only standardized for getopt(). Use of a
is intentionally left unspecified for the getopts utility, where
historical implementations did not require a leading  for conforming behavior, and because some historical
getopts implementations used a leading  for a different
extension.
FUTURE DIRECTIONS
None.
SEE ALSO
exec
XBD 12.2 Utility Syntax Guidelines,
XCU getopts
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
A note indicating that the getopt() function need not be reentrant is added to the DESCRIPTION.
Issue 6
IEEE PASC Interpretation 1003.2 #150 is applied.
Austin Group Interpretation 1003.1-2001 #156 is applied.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0248 [318], XSH/TC1-2008/0249 [460], XSH/TC1-2008/0250 [189],
XSH/TC1-2008/0251 [189], XSH/TC1-2008/0252 [189], and XSH/TC1-2008/0253 [460] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0169 [608] is applied.
Issue 8
Austin Group Defect 191 is applied, allowing a leading  in optstring.
Austin Group Defect 1179 is applied, adding some missing '}' characters at the end of the example code.
Austin Group Defect 1523 is applied, clarifying the conditions under which getopt() returns -1 without changing
optind.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/utimes.html =====
futimens
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
futimens, utimensat, utimes — set file access and modification times
SYNOPSIS
#include
int futimens(int fd, const struct timespec times[2]);
[OH] #include
int utimensat(int fd, const char *path, const struct timespec times[2],
int flag);
[XSI]
#include
int utimes(const char *path, const struct timeval times[2]);
DESCRIPTION
The futimens() and utimensat() functions shall set the access and modification times of a file to the values of
the times argument. The futimens() function changes the times of the file associated with the file descriptor
fd. The utimensat() function changes the times of the file pointed to by the path argument, relative to the
directory associated with the file descriptor fd. Both functions allow time specifications accurate to the nanosecond.
For futimens() and utimensat(), the times argument is an array of two timespec structures. The first
array member represents the date and time of last access, and the second member represents the date and time of last modification.
The times in the timespec structure are measured in seconds and nanoseconds since the Epoch. The file's relevant timestamp
shall be set to the greatest value supported by the file system that is not greater than the specified time.
If the tv_nsec field of a timespec structure has the special value UTIME_NOW, the file's relevant timestamp shall
be set to the greatest value supported by the file system that is not greater than the current time. If the tv_nsec field
has the special value UTIME_OMIT, the file's relevant timestamp shall not be changed. In either case, the tv_sec field shall
be ignored.
If the times argument is a null pointer, both the access and modification timestamps shall be set to the greatest value
supported by the file system that is not greater than the current time. If utimensat() is passed a relative path in the
path argument, the file to be used shall be relative to the directory associated with the file descriptor fd instead
of the current working directory. If the access mode of the open file description associated with the file descriptor is not
O_SEARCH, the function shall check whether directory searches are permitted using the current permissions of the directory
underlying the file descriptor. If the access mode is O_SEARCH, the function shall not perform the check.
If utimensat() is passed the special value AT_FDCWD in the fd parameter, the current working directory shall be
used.
Only a process with the effective user ID equal to the user ID of the file, or with write access to the file, or with
appropriate privileges may use futimens() or utimensat() with a null pointer as the times argument or with
both tv_nsec fields set to the special value UTIME_NOW. Only a process with the effective user ID equal to the user ID of
the file or with appropriate privileges may use futimens() or utimensat() with a non-null times argument that
does not have both tv_nsec fields set to UTIME_NOW and does not have both tv_nsec fields set to UTIME_OMIT. If both
tv_nsec fields are set to UTIME_OMIT, no ownership or permissions check shall be performed for the file, but other error
conditions may still be detected (including [EACCES] errors related to the path prefix).
Values for the flag argument of utimensat() are constructed by a bitwise-inclusive OR of flags from the following
list, defined in :
AT_SYMLINK_NOFOLLOW
If path names a symbolic link, then the access and modification times of the symbolic link are changed.
Upon successful completion, futimens() and utimensat() shall mark the last file status change timestamp for
update, with the exception that if both tv_nsec fields are set to UTIME_OMIT, the file status change timestamp need not be
marked for update.
The utimes() function shall be equivalent to the utimensat() function with the special value AT_FDCWD as the
fd argument and the flag argument set to zero, except that the times argument is a timeval structure
rather than a timespec structure, and accuracy is only to the microsecond, not nanosecond, and rounding towards the nearest
second may occur.
RETURN VALUE
Upon successful completion, these functions shall return 0. Otherwise, these functions shall return -1 and set errno to
indicate the error. If -1 is returned, the file times shall not be affected.
ERRORS
The utimes() function shall fail, the futimens() and utimensat() functions shall fail in the case that the
times argument does not have both tv_nsec fields set to UTIME_OMIT, and the futimens() and utimensat()
functions may fail in the case that the times argument has both tv_nsec fields set to UTIME_OMIT, if:
[EACCES]
The times argument is a null pointer, or both tv_nsec values are UTIME_NOW, and the effective user ID of the
process does not match the owner of the file and write access is denied.
[EINVAL]
Either of the times argument structures specified a tv_nsec value that was neither UTIME_NOW nor UTIME_OMIT, and
was a value less than zero or greater than or equal to 1000 million.
[EINVAL]
A new file timestamp would be a value whose tv_sec component is not a value supported by the file system.
[EPERM]
The times argument is not a null pointer, does not have both tv_nsec fields set to UTIME_NOW, does not have both
tv_nsec fields set to UTIME_OMIT, the calling process' effective user ID does not match the owner of the file, and the
calling process does not have appropriate privileges.
[EROFS]
The file system containing the file is read-only.
The futimens() function shall fail in the case that the times argument does not have both tv_nsec fields
set to UTIME_OMIT, and may fail in the case that the times argument has both tv_nsec fields set to UTIME_OMIT,
if:
[EBADF]
The fd argument is not a valid file descriptor.
The utimensat() function shall fail in the case that the times argument does not have both tv_nsec fields
set to UTIME_OMIT, and may fail in the case that the times argument has both tv_nsec fields set to UTIME_OMIT,
if:
[EACCES]
The access mode of the open file description associated with fd is not O_SEARCH and the permissions of the directory
underlying fd do not permit directory searches.
[EBADF]
The path argument does not specify an absolute path and the fd argument is neither AT_FDCWD nor a valid file
descriptor open for reading or searching.
[ENOTDIR]
The path argument is not an absolute path and fd is a file descriptor associated with a non-directory file.
The utimes() function shall fail, the utimensat() function shall fail in the case that the times argument
does not have both tv_nsec fields set to UTIME_OMIT, and the utimensat() function may fail in the case that the
times argument has both tv_nsec fields set to UTIME_OMIT, if:
[EACCES]
Search permission is denied by a component of the path prefix.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of path does not name an existing file or path is an empty string.
[ENOTDIR]
A component of the path prefix names an existing file that is neither a directory nor a symbolic link to a directory, or the
path argument contains at least one non- character and ends with one or more trailing  characters
and the last pathname component names an existing file that is neither a directory nor a symbolic link to a directory.
The utimensat() and utimes() functions may fail if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
The utimensat() function may fail if:
[EINVAL]
The value of the flag argument is not valid.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The purpose of the utimensat() function is to set the access and modification time of files in directories other than the
current working directory without exposure to race conditions. Any part of the path of a file could be changed in parallel to a
call to utimes(), resulting in unspecified behavior. By opening a file descriptor for the target directory and using the
utimensat() function it can be guaranteed that the changed file is located relative to the desired directory.
The standard developers considered including a special case for the permissions required by utimensat() when one
tv_nsec field is UTIME_NOW and the other is UTIME_OMIT. One possibility would be to include this case in with the cases
where times is a null pointer or both fields are UTIME_NOW, where the call is allowed if the process has write permission
for the file. However, associating write permission with an update to just the last data access timestamp (which is normally
updated by read()) did not seem appropriate. The other possibility would be to specify
that this one case is allowed if the process has read permission, but this was felt to be too great a departure from the
utime() and utimes() functions on which utimensat() is based. If an application needs to set the last data
access timestamp to the current time for a file on which it has read permission but is not the owner, it can do so by opening the
file, reading one or more bytes (or reading a directory entry, if the file is a directory), and then closing it.
FUTURE DIRECTIONS
None.
SEE ALSO
read()
XBD , ,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
This function is marked LEGACY.
The normative text is updated to avoid use of the term "must" for application requirements.
The wording of the mandatory [ELOOP] error condition is updated, and a second optional [ELOOP] error condition is added.
Issue 7
Austin Group Interpretation 1003.1-2001 #143 is applied.
The LEGACY marking is removed.
The utimensat() function (renamed from futimesat()) is added from The Open Group Technical Standard, 2006,
Extended API Set Part 2, and changed to allow modifying a symbolic link by adding a flag argument.
The futimens() function is added.
Changes are made related to support for finegrained timestamps.
Changes are made to allow a directory to be opened for searching.
The [ENOTDIR] error condition is clarified to cover the condition where the last component of a pathname exists but is not a
directory or a symbolic link to a directory.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0220 [63,428], XSH/TC1-2008/0221 [278], XSH/TC1-2008/0222 [324],
XSH/TC1-2008/0223 [306], and XSH/TC1-2008/0224 [278] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0140 [591], XSH/TC2-2008/0141 [817], XSH/TC2-2008/0142 [485], and
XSH/TC2-2008/0143 [817] are applied.
Issue 8
Austin Group Defect 1280 is applied, changing the ERRORS section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcsnrtombs.html =====
wcsrtombs
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcsnrtombs, wcsrtombs — convert a wide-character string to a character string (restartable)
SYNOPSIS
#include
[CX]  size_t wcsnrtombs(char *restrict dst, const wchar_t **restrict
src,
size_t nwc, size_t len, mbstate_t *restrict
ps);
size_t wcsrtombs(char *restrict dst, const wchar_t **restrict src,
size_t len, mbstate_t *restrict ps);
DESCRIPTION
For wcsrtombs(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The wcsrtombs() function shall convert a sequence of wide characters from the array indirectly pointed to by src
into a sequence of corresponding characters, beginning in the conversion state described by the object pointed to by ps. If
dst is not a null pointer, the converted characters shall then be stored into the array pointed to by dst. Conversion
continues up to and including a terminating null wide character, which shall also be stored. Conversion shall stop earlier in the
following cases:
When a code is reached that does not correspond to a valid character
When the next character would exceed the limit of len total bytes to be stored in the array pointed to by dst (and
dst is not a null pointer)
Each conversion shall take place as if by a call to the wcrtomb() function.
If dst is not a null pointer, the pointer object pointed to by src shall be assigned either a null pointer (if
conversion stopped due to reaching a terminating null wide character) or the address just past the last wide character converted
(if any). If conversion stopped due to reaching a terminating null wide character, the resulting state described shall be the
initial conversion state.
If ps is a null pointer, the wcsrtombs() function shall use its own internal mbstate_t object, which is
initialized at program start-up to the initial conversion state. Otherwise, the mbstate_t object pointed to by ps
shall be used to completely describe the current conversion state of the associated character sequence.
If called with a null ps argument, the wcsrtombs() function need not be thread-safe; however, such calls shall
avoid data races with calls to wcsrtombs() with a non-null argument and with calls to all other functions.
[CX]  The
wcsnrtombs() function shall be equivalent to the wcsrtombs() function, except that the conversion is limited to the
first nwc wide characters.
If called with a null ps argument, the wcsnrtombs() function need not be thread-safe; however, such calls shall
avoid data races with calls to wcsnrtombs() with a non-null argument and with calls to all other functions.
These functions shall not change the setting of errno if successful.
The behavior of these functions shall be affected by the LC_CTYPE category of the current locale.
The implementation shall behave as if no function defined in System Interfaces volume of POSIX.1-2024 calls these functions.
RETURN VALUE
If conversion stops because a code is reached that does not correspond to a valid character, an encoding error occurs. In this
case, these functions shall store the value of the macro [EILSEQ] in errno and return (size_t)-1; the conversion
state is undefined. Otherwise, these functions shall return the number of bytes in the resulting character sequence, not including
the terminating null (if any).
ERRORS
These functions shall fail if:
[EILSEQ]
A wide-character code does not correspond to a valid character.
These functions may fail if:
[EINVAL]
[CX]
ps points to an object that contains an invalid conversion state.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
mbsinit(), wcrtomb()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E).
Issue 6
In the DESCRIPTION, a note on using this function in a threaded application is added.
Extensions beyond the ISO C standard are marked.
The normative text is updated to avoid use of the term "must" for application requirements.
The wcsrtombs() prototype is updated for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
Austin Group Interpretation 1003.1-2001 #148 is applied, clarifying that the wcsrtombs() function need not be thread-safe
if called with a NULL ps argument.
Austin Group Interpretation 1003.1-2001 #170 is applied.
The wcsnrtombs() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 1.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0722 [109,105] is applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/btowc.html =====
btowc
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
btowc — single byte to wide character conversion
SYNOPSIS
#include
#include
wint_t btowc(int c);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The btowc() function shall determine whether c constitutes a valid (one-byte) character in the initial shift
state.
The behavior of this function shall be affected by the LC_CTYPE category of the current locale.
RETURN VALUE
The btowc() function shall return WEOF if c has the value EOF or if (unsigned char) c does not
constitute a valid (one-byte) character in the initial shift state. Otherwise, it shall return the wide-character representation of
that character.
[CX]  In
the POSIX locale, btowc() shall not return WEOF if c has a value in the range 0 to 255 inclusive.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
wctob()
XBD ,
CHANGE HISTORY
First released in Issue 5. Included for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E).
Issue 7
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0052 [663] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/chmod.html =====
chmod
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
chmod, fchmodat — change mode of a file
SYNOPSIS
#include
int chmod(const char *path, mode_t mode);
[OH] #include
int fchmodat(int fd, const char *path, mode_t mode, int
flag);
DESCRIPTION
The chmod() function shall change S_ISUID, S_ISGID, [XSI]   S_ISVTX,  and the file permission bits of the file named by the pathname pointed to by the path argument to the
corresponding bits in the mode argument. If any bits that can be set in the st_mode value returned by lstat() or stat() but cannot be changed using
chmod(), such as the bits that are used to encode the file type, are set in the mode argument, these read-only
st_mode bits shall be ignored.
If the effective user ID of the process does not match the owner of the file and the process does not have appropriate
privileges, the chmod() function shall fail.
S_ISUID, S_ISGID, [XSI]   S_ISVTX,  and the file permission
bits are described in .
If the calling process does not have appropriate privileges, and if the group ID of the file does not match the effective group
ID or one of the supplementary group IDs and if the file is a regular file, bit S_ISGID (set-group-ID on execution) in the file's
mode shall be cleared upon successful return from chmod().
Additional implementation-defined restrictions may cause the S_ISUID and S_ISGID bits in mode to be ignored,
[XSI]
and may cause the S_ISVTX bit in mode to be ignored for non-directory files.
Upon successful completion, chmod() shall mark for update the last file status change timestamp of the file.
The fchmodat() function shall be equivalent to the chmod() function except in the case where path specifies
a relative path. In this case the file to be changed is determined relative to the directory associated with the file descriptor
fd instead of the current working directory. If the access mode of the open file description associated with the file
descriptor is not O_SEARCH, the function shall check whether directory searches are permitted using the current permissions of the
directory underlying the file descriptor. If the access mode is O_SEARCH, the function shall not perform the check.
Values for flag are constructed by a bitwise-inclusive OR of flags from the following list, defined in :
AT_SYMLINK_NOFOLLOW
If path names a symbolic link, then the mode of the symbolic link is changed.
If fchmodat() is passed the special value AT_FDCWD in the fd parameter, the current working directory shall be
used. If also flag is zero, the behavior shall be identical to a call to chmod().
RETURN VALUE
Upon successful completion, these functions shall return 0. Otherwise, these functions shall return -1 and set errno to
indicate the error. If -1 is returned, no change to the file mode occurs.
ERRORS
These functions shall fail if:
[EACCES]
Search permission is denied on a component of the path prefix.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of path does not name an existing file or path is an empty string.
[ENOTDIR]
A component of the path prefix names an existing file that is neither a directory nor a symbolic link to a directory, or the
path argument contains at least one non- character and ends with one or more trailing  characters
and the last pathname component names an existing file that is neither a directory nor a symbolic link to a directory.
[EPERM]
The effective user ID does not match the owner of the file and the process does not have appropriate privileges.
[EROFS]
The named file resides on a read-only file system.
The fchmodat() function shall fail if:
[EACCES]
The access mode of the open file description associated with fd is not O_SEARCH and the permissions of the directory
underlying fd do not permit directory searches.
[EBADF]
The path argument does not specify an absolute path and the fd argument is neither AT_FDCWD nor a valid file
descriptor open for reading or searching.
[ENOTDIR]
The path argument is not an absolute path and fd is a file descriptor associated with a non-directory file.
These functions may fail if:
[EINTR]
A signal was caught during execution of the function.
[EINVAL]
The value of the mode argument, ignoring read-only st_mode bits (see the DESCRIPTION), is invalid.
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
The fchmodat() function may fail if:
[EINVAL]
The value of the flag argument is invalid.
[EOPNOTSUPP]
The AT_SYMLINK_NOFOLLOW bit is set in the flag argument, path names a symbolic link, and the system does not
support changing the mode of a symbolic link.
The following sections are informative.
EXAMPLES
Setting Read Permissions for User, Group, and Others
The following example sets read permissions for the owner, group, and others.
#include
const char *path;
...
chmod(path, S_IRUSR|S_IRGRP|S_IROTH);
Setting Read, Write, and Execute Permissions for the Owner Only
The following example sets read, write, and execute permissions for the owner, and no permissions for group and others.
#include
const char *path;
...
chmod(path, S_IRWXU);
Setting Different Permissions for Owner, Group, and Other
The following example sets owner permissions for CHANGEFILE to read, write, and execute, group permissions to read and execute,
and other permissions to read.
#include
#define CHANGEFILE "/etc/myfile"
...
chmod(CHANGEFILE, S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH);
Modifying File Permissions
The following example adds group write permission to the existing permission bits for a file if that bit is not already set.
#include
struct stat sbuf;
...
if (stat(path, &sbuf) == 0 && (sbuf.st_mode & S_IWGRP) == 0)
chmod(path, sbuf.st_mode | S_IWGRP);
Setting and Checking File Permissions
The following example sets the file permission bits for a file named /home/cnd/mod1, then calls the stat() function to verify the permissions.
#include
#include
int status;
struct stat buffer
...
chmod("/home/cnd/mod1", S_IRWXU|S_IRWXG|S_IROTH|S_IWOTH);
status = stat("/home/cnd/mod1", &buffer);
APPLICATION USAGE
In order to ensure that the S_ISUID and S_ISGID bits are set, an application requiring this should use stat() after a successful chmod() to verify this.
Any file descriptors currently open by any process on the file could possibly become invalid if the mode of the file is changed
to a value which would deny access to that process. One situation where this could occur is on a stateless file system. This
behavior will not occur in a conforming environment.
RATIONALE
This volume of POSIX.1-2024 specifies that the S_ISGID bit is cleared by chmod() on a regular file under certain
conditions. This is specified on the assumption that regular files may be executed, and the system should prevent users from making
executable setgid() files perform with privileges that the caller does not have. On
implementations that support execution of other file types, the S_ISGID bit should be cleared for those file types under the same
circumstances.
Implementations that use the S_ISUID bit to indicate some other function (for example, mandatory record locking) on
non-executable files need not clear this bit on writing. They should clear the bit for executable files and any other cases where
the bit grants special powers to processes that change the file contents. Similar comments apply to the S_ISGID bit.
The purpose of the fchmodat() function is to enable changing the mode of files in directories other than the current
working directory without exposure to race conditions. Any part of the path of a file could be changed in parallel to a call to
chmod(), resulting in unspecified behavior. By opening a file descriptor for the target directory and using the
fchmodat() function it can be guaranteed that the changed file is located relative to the desired directory. Some
implementations might allow changing the mode of symbolic links. This is not supported by the interfaces in the POSIX
specification. Systems with such support provide an interface named lchmod(). To support such implementations
fchmodat() has a flag parameter.
FUTURE DIRECTIONS
None.
SEE ALSO
access(), chown(),
exec, fstatat(), fstatvfs(), mkdir(), mkfifo(),
mknod(), open()
XBD , ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
The [EINVAL] and [EINTR] optional error conditions are added.
A second [ENAMETOOLONG] is added as an optional error condition.
The following changes were made to align with the IEEE P1003.1a draft standard:
The [ELOOP] optional error condition is added.
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
Austin Group Interpretation 1003.1-2001 #143 is applied.
The fchmodat() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 2.
Changes are made related to support for finegrained timestamps.
Changes are made to allow a directory to be opened for searching.
The [ENOTDIR] error condition is clarified to cover the condition where the last component of a pathname exists but is not a
directory or a symbolic link to a directory.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0048 [300], XSH/TC1-2008/0049 [461], XSH/TC1-2008/0050 [324],
XSH/TC1-2008/0051 [278], and XSH/TC1-2008/0052 [278] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0057 [873], XSH/TC2-2008/0058 [591], XSH/TC2-2008/0059 [817],
XSH/TC2-2008/0060 [817], and XSH/TC2-2008/0061 [893] are applied.
Issue 8
Austin Group Defect 1024 is applied, allowing the S_ISVTX bit to be ignored for non-directory files.
Austin Group Defect 1283 is applied, clarifying that chmod() ignores read-only st_mode bits in the mode
argument.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_mutexattr_getprioceiling.html =====
pthread_mutexattr_getprioceiling
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_mutexattr_getprioceiling, pthread_mutexattr_setprioceiling — get and set the prioceiling attribute of the mutex
attributes object (REALTIME THREADS)
SYNOPSIS
[RPP|TPP]  #include
int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t
*restrict attr, int *restrict prioceiling);
int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *attr,
int prioceiling);
DESCRIPTION
The pthread_mutexattr_getprioceiling() and pthread_mutexattr_setprioceiling() functions, respectively, shall get
and set the priority ceiling attribute of a mutex attributes object pointed to by attr which was previously created by the
function pthread_mutexattr_init().
The prioceiling attribute contains the priority ceiling of initialized mutexes. The values of prioceiling are
within the maximum range of priorities defined by SCHED_FIFO.
The prioceiling attribute defines the priority ceiling of initialized mutexes, which is the minimum priority level at
which the critical section guarded by the mutex is executed. In order to avoid priority inversion, the priority ceiling of the
mutex shall be set to a priority higher than or equal to the highest priority of all the threads that may lock that mutex. The
values of prioceiling are within the maximum range of priorities defined under the SCHED_FIFO scheduling policy.
The behavior is undefined if the value specified by the attr argument to pthread_mutexattr_getprioceiling() or
pthread_mutexattr_setprioceiling() does not refer to an initialized mutex attributes object.
RETURN VALUE
Upon successful completion, the pthread_mutexattr_getprioceiling() and pthread_mutexattr_setprioceiling()
functions shall return zero; otherwise, an error number shall be returned to indicate the error.
ERRORS
These functions may fail if:
[EINVAL]
The value specified by prioceiling is invalid.
[EPERM]
The caller does not have the privilege to perform the operation.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
If an implementation detects that the value specified by the attr argument to pthread_mutexattr_getprioceiling()
or pthread_mutexattr_setprioceiling() does not refer to an initialized mutex attributes object, it is recommended that the
function should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_cond_destroy(), pthread_create(), pthread_mutex_destroy()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Marked as part of the Realtime Threads Feature Group.
Issue 6
The pthread_mutexattr_getprioceiling() and pthread_mutexattr_setprioceiling() functions are marked as part of the
Threads and Thread Priority Protection options.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Thread
Priority Protection option.
The [ENOTSUP] error condition has been removed since these functions do not have a protocol argument.
The restrict keyword is added to the pthread_mutexattr_getprioceiling() prototype for alignment with the
ISO/IEC 9899:1999 standard.
Issue 7
The pthread_mutexattr_getprioceiling() and pthread_mutexattr_setprioceiling() functions are moved from the Threads
option to require support of either the Robust Mutex Priority Protection option or the Non-Robust Mutex Priority Protection
option.
The [EINVAL] error for an uninitialized mutex attributes object is removed; this condition results in undefined behavior.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/cnd_destroy.html =====
cnd_destroy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cnd_destroy, cnd_init — destroy and initialize condition variables
SYNOPSIS
#include
void cnd_destroy(cnd_t *cond);
int cnd_init(cnd_t *cond);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The cnd_destroy() function shall release all resources used by the condition variable pointed to by cond. It shall
be safe to destroy an initialized condition variable upon which no threads are currently blocked. Attempting to destroy a condition
variable upon which other threads are currently blocked results in undefined behavior. A destroyed condition variable object can be
reinitialized using cnd_init(); the results of otherwise referencing the object after it has been destroyed are undefined.
The behavior is undefined if the value specified by the cond argument to cnd_destroy() does not refer to an
initialized condition variable.
The cnd_init() function shall initialize a condition variable. If it succeeds it shall set the variable pointed to by
cond to a value that uniquely identifies the newly initialized condition variable. Attempting to initialize an already
initialized condition variable results in undefined behavior. A thread that calls cnd_wait() on a newly initialized condition variable shall block.
[CX]  See
2.9.9 Synchronization Object Copies and Alternative Mappings for
further requirements.
These functions shall not be affected if the calling thread executes a signal handler during the call.
RETURN VALUE
The cnd_destroy() function shall not return a value.
The cnd_init() function shall return thrd_success on success, or thrd_nomem if no memory could be
allocated for the newly created condition variable, or thrd_error if the request could not be honored.
ERRORS
See RETURN VALUE.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
These functions are not affected by signal handlers for the reasons stated in XRAT B.2.3 Error Numbers.
FUTURE DIRECTIONS
None.
SEE ALSO
cnd_broadcast(), cnd_timedwait()
XBD
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/dbm_error.html =====
dbm_clearerr
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
dbm_clearerr, dbm_close, dbm_delete, dbm_error, dbm_fetch, dbm_firstkey, dbm_nextkey, dbm_open, dbm_store — database
functions
SYNOPSIS
[XSI]  #include
int dbm_clearerr(DBM *db);
void dbm_close(DBM *db);
int dbm_delete(DBM *db, datum key);
int dbm_error(DBM *db);
datum dbm_fetch(DBM *db, datum key);
datum dbm_firstkey(DBM *db);
datum dbm_nextkey(DBM *db);
DBM *dbm_open(const char *file, int open_flags, mode_t file_mode);
int dbm_store(DBM *db, datum key, datum content, int
store_mode);
DESCRIPTION
These functions create, access, and modify a database.
A datum consists of at least two members, dptr and dsize. The dptr member points to an object that
is dsize bytes in length. Arbitrary binary data, as well as character strings, may be stored in the object pointed to by
dptr.
A database shall be stored in one or two files. When one file is used, the name of the database file shall be formed by
appending the suffix .db to the file argument given to dbm_open(). When two files are used, the names of the
database files shall be formed by appending the suffixes .dir and .pag respectively to the file argument.
The dbm_open() function shall open a database. The file argument to the function is the pathname of the database.
Values for the open_flags argument are constructed by a bitwise-inclusive OR of flags from the following list, defined in
. Applications shall specify exactly one of the first three values
(file access modes) below in the value of open_flags:
O_RDONLY
Open the database, and the underlying file(s) used to store the database, for reading only.
O_RDWR
Open the database, and the underlying file(s) used to store the database, for reading and writing.
O_WRONLY
Open the database for writing only. The underlying file(s) used to store the database shall be opened for reading and
writing.
Any combination of the following can be used:
O_CLOEXEC
If set, the FD_CLOEXEC flag for the new file descriptor(s) used to open the underlying file(s) shall be set.
O_CREAT
If the database exists, this flag has no effect except as noted under O_EXCL below. Otherwise, the database shall be created;
the user ID of the underlying file(s) shall be set to the effective user ID of the process; the group ID of the underlying file(s)
shall be set to the group ID of the file's parent directory or to the effective group ID of the process. Implementations shall
provide a way to initialize the group ID to the group ID of the parent directory. Implementations may, but need not, provide an
implementation-defined way to initialize the group ID to the effective group ID of the calling process.
O_DSYNC
[SIO]
Write I/O operations on the file(s) used to store the database shall complete as defined by synchronized I/O data integrity
completion.
O_EXCL
If O_CREAT and O_EXCL are set, dbm_open() shall fail if the database exists according to the following criteria. If the
database is stored in a file with a .db suffix, a check for the existence of the file and the creation of the file if it
does not exist shall be performed as a single atomic operation. If the database is stored in files with .pag and .dir
suffixes, this atomic existence check and creation operation shall be performed for each file, but it is unspecified which file is
first. If the first file is successfully created and the second file is found to exist, the first file should be removed before
dbm_open() returns.
If O_EXCL is set and O_CREAT is not set, the result is undefined.
O_RSYNC
[SIO]
Read I/O operations on the file(s) used to store the database shall complete at the same level of integrity as specified by the
O_DSYNC and O_SYNC flags. If both O_DSYNC and O_RSYNC are set in oflag, all I/O operations on the file(s) shall complete as defined
by synchronized I/O data integrity completion. If both O_SYNC and O_RSYNC are set in flags, all I/O operations on the file(s) shall
complete as defined by synchronized I/O file integrity completion.
O_SYNC
Write I/O operations on the file(s) used to store the database shall complete as defined by synchronized I/O file integrity
completion.
O_TRUNC
If the database exists and is successfully opened O_RDWR or O_WRONLY, it shall be emptied, and the mode and owner of the
underlying file(s) shall be unchanged. The result of using O_TRUNC without either O_RDWR or O_WRONLY is undefined.
The behaviour of other flags described for the flags argument of open() is
unspecified.
The file_mode argument has the same meaning as the third argument of open()
and shall apply to the underlying file(s) used to store the database.
The dbm_open() function need not accept pathnames longer than {PATH_MAX}-4 bytes (including the terminating null), or
pathnames with a last component longer than {NAME_MAX}-4 bytes (excluding the terminating null).
The dbm_close() function shall close a database. The application shall ensure that argument db is a pointer to a
dbm structure that has been returned from a call to dbm_open().
These database functions shall support an internal block size large enough to support key/content pairs of at least 1023
bytes.
The dbm_fetch() function shall read a record from a database. The argument db is a pointer to a database structure
that has been returned from a call to dbm_open(). The argument key is a datum that has been initialized by the
application to the value of the key that matches the key of the record the program is fetching.
The dbm_store() function shall write a record to a database. The argument db is a pointer to a database structure
that has been returned from a call to dbm_open(). The argument key is a datum that has been initialized by the
application to the value of the key that identifies (for subsequent reading, writing, or deleting) the record the application is
writing. The argument content is a datum that has been initialized by the application to the value of the record the
program is writing. The argument store_mode controls whether dbm_store() replaces any pre-existing record that has
the same key that is specified by the key argument. The application shall set store_mode to either DBM_INSERT or
DBM_REPLACE. If the database contains a record that matches the key argument and store_mode is DBM_REPLACE, the
existing record shall be replaced with the new record. If the database contains a record that matches the key argument and
store_mode is DBM_INSERT, the existing record shall be left unchanged and the new record ignored. If the database does not
contain a record that matches the key argument and store_mode is either DBM_INSERT or DBM_REPLACE, the new record
shall be inserted in the database.
If the sum of a key/content pair exceeds the internal block size, the result is unspecified. Moreover, the application shall
ensure that all key/content pairs that hash together fit on a single block. The dbm_store() function shall return an error
in the event that a disk block fills with inseparable data.
The dbm_delete() function shall delete a record and its key from the database. The argument db is a pointer to a
database structure that has been returned from a call to dbm_open(). The argument key is a datum that has been
initialized by the application to the value of the key that identifies the record the program is deleting.
The dbm_firstkey() function shall return the first key in the database. The argument db is a pointer to a database
structure that has been returned from a call to dbm_open().
The dbm_nextkey() function shall return the next key in the database. The argument db is a pointer to a database
structure that has been returned from a call to dbm_open(). The application shall ensure that the dbm_firstkey()
function is called before calling dbm_nextkey(). Subsequent calls to dbm_nextkey() return the next key until all of
the keys in the database have been returned.
The dbm_error() function shall return the error condition of the database. The argument db is a pointer to a
database structure that has been returned from a call to dbm_open().
The dbm_clearerr() function shall clear the error condition of the database. The argument db is a pointer to a
database structure that has been returned from a call to dbm_open().
The dptr pointers returned by these functions may point into static storage that may be changed by subsequent calls.
These functions need not be thread-safe.
RETURN VALUE
The dbm_store() and dbm_delete() functions shall return 0 when they succeed and a negative value when they
fail.
The dbm_store() function shall return 1 if it is called with a flags value of DBM_INSERT and the function finds an
existing record with the same key.
The dbm_error() function shall return 0 if the error condition is not set and return a non-zero value if the error
condition is set.
The return value of dbm_clearerr() is unspecified.
The dbm_firstkey() and dbm_nextkey() functions shall return a key datum. When the end of the database is
reached, the dptr member of the key is a null pointer. If an error is detected, the dptr member of the key shall be a
null pointer and the error condition of the database shall be set.
The dbm_fetch() function shall return a content datum. If no record in the database matches the key or if an error
condition has been detected in the database, the dptr member of the content shall be a null pointer.
The dbm_open() function shall return a pointer to a database structure. If an error is detected during the operation,
dbm_open() shall return a (DBM *)0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The following code can be used to traverse the database:
for(key = dbm_firstkey(db); key.dptr != NULL; key = dbm_nextkey(db))
The dbm_* functions provided in this library should not be confused in any way with those of a general-purpose database
management system. These functions do not provide for multiple search keys per entry, they do not protect against multi-user access
(in other words they do not lock records or files), and they do not provide the many other useful database functions that are found
in more robust database management systems. Creating and updating databases by use of these functions is relatively slow because of
data copies that occur upon hash collisions. These functions are useful for applications requiring fast lookup of relatively static
information that is to be indexed by a single key.
Note that a strictly conforming application is extremely limited by these functions: since there is no way to determine that the
keys in use do not all hash to the same value (although that would be rare), a strictly conforming application cannot be guaranteed
that it can store more than one block's worth of data in the database. As long as a key collision does not occur, additional data
may be stored, but because there is no way to determine whether an error is due to a key collision or some other error condition
(dbm_error() being effectively a Boolean), once an error is detected, the
application is effectively limited to guessing what the error might be if it wishes to continue using these functions.
The dbm_delete() function need not physically reclaim file space, although it does make it available for reuse by the
database.
After calling dbm_store() or dbm_delete() during a pass through the keys by dbm_firstkey() and
dbm_nextkey(), the application should reset the database by calling dbm_firstkey() before again calling
dbm_nextkey(). The contents of these files are unspecified and may not be portable.
Applications should take care that database pathname arguments specified to dbm_open() are not prefixes of unrelated
files. This might be done, for example, by placing databases in a separate directory.
Since some implementations use three characters for a suffix and others use four characters for a suffix, applications should
ensure that the maximum portable pathname length passed to dbm_open() is no greater than {PATH_MAX}-4 bytes, with the last
component of the pathname no greater than {NAME_MAX}-4 bytes.
RATIONALE
and having .dir as its suffix. The second file containing all data and having .pag as its suffix. This has been
changed not to specify the use of the files and to allow newer implementations of the Berkeley DB interface using a single file
that have evolved while remaining compatible with the application programming interface. The standard developers considered
removing the specific suffixes altogether but decided to retain them so as not to pollute the application file name space more than
necessary and to allow for portable backups of the database.
FUTURE DIRECTIONS
A future revision of this standard may mandate the file removal that is currently recommended (by the use of "should") in the
description of O_EXCL.
SEE ALSO
open()
XBD ,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Normative text previously in the APPLICATION USAGE section is moved to the DESCRIPTION.
A note indicating that these functions need not be reentrant is added to the DESCRIPTION.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
Austin Group Interpretation 1003.1-2001 #042 is applied so that the DESCRIPTION permits newer implementations of the Berkeley DB
interface.
Austin Group Interpretation 1003.1-2001 #156 is applied.
Issue 8
Austin Group Defect 1057 is applied, clarifying how the O_ flags defined for use with open() apply to dbm_open().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/llrint.html =====
llrint
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
llrint, llrintf, llrintl — round to the nearest integer value using current rounding direction
SYNOPSIS
#include
long long llrint(double x);
long long llrintf(float x);
long long llrintl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall round their argument to the nearest integer value, rounding according to the current rounding
direction.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the rounded integer value.
[MX]  If
x is NaN, a domain error shall occur, and an unspecified value is returned.
If x is +Inf, a domain error shall occur and an unspecified value is returned.
If x is -Inf, a domain error shall occur and an unspecified value is returned.
If the correct value is positive and too large to represent as a long long, an unspecified value shall be returned.
[MX]
On systems that support the IEC 60559 Floating-Point option, a domain error shall occur;   otherwise, a [CX]   domain  error may occur.
If the correct value is negative and too large to represent as a long long, an unspecified value shall be returned.
[MX]
On systems that support the IEC 60559 Floating-Point option, a domain error shall occur;   otherwise, a [CX]   domain  error may occur.
ERRORS
These functions shall fail if:
Domain Error
[MX]
The x argument is NaN or ±Inf, or the correct value is not representable as an integer.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
These functions may fail if:
Domain Error
The correct value is not representable as an integer.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
These functions provide floating-to-integer conversions. They round according to the current rounding direction. If the rounded
value is outside the range of the return type, the numeric result is unspecified and the invalid floating-point exception is
raised. When they raise no other floating-point exception and the result differs from the argument, they raise the inexact
floating-point exception.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), lrint()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #53 is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/catanhl.html =====
catanh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
catanh, catanhf, catanhl — complex arc hyperbolic tangent functions
SYNOPSIS
#include
double complex catanh(double complex z);
float complex catanhf(float complex z);
long double complex catanhl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex arc hyperbolic tangent of z, with branch cuts outside the interval
[-1, +1] along the real axis.
RETURN VALUE
These functions shall return the complex arc hyperbolic tangent value, in the range of a strip mathematically unbounded along
the real axis and in the interval [-iℼ/2, +iℼ/2] along the imaginary axis.
[MXC]
catanh(conj(z)), catanhf(conjf(z)), and catanhl(conjl(z)) shall
return exactly the same value as conj(catanh(z)), conjf(catanhf(z)), and
conjl(catanhl(z)), respectively, and catanh(-z), catanhf(-z), and
catanhl(-z) shall return exactly the same value as -catanh(z), -catanhf(z), and
-catanhl(z), respectively, including for the special values of z below.
If z is +0 + i0, +0 + i0 shall be returned.
If z is +0 + iNaN, +0 + iNaN shall be returned.
If z is +1 + i0, +Inf + i0 shall be returned and the divide-by-zero floating-point exception shall be
raised.
If z is x + iInf where x is positive-signed and finite, +0 + iℼ/2 shall be returned.
If z is x + iNaN where x is non-zero and finite, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is +Inf + iy where y is positive-signed and finite, +0 + iℼ/2 shall be returned.
If z is +Inf + iInf, +0 + iℼ/2 shall be returned.
If z is +Inf + iNaN, +0 + iNaN shall be returned.
If z is NaN + iy where y is finite, NaN + iNaN shall be returned and the invalid floating-point
exception may be raised.
If z is NaN + iInf, ±0 + iℼ/2 shall be returned; the sign of the real part of the result is
unspecified.
If z is NaN + iNaN, NaN + iNaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
ctanh()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ccoshf.html =====
ccosh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ccosh, ccoshf, ccoshl — complex hyperbolic cosine functions
SYNOPSIS
#include
double complex ccosh(double complex z);
float complex ccoshf(float complex z);
long double complex ccoshl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex hyperbolic cosine of z.
RETURN VALUE
These functions shall return the complex hyperbolic cosine value.
[MXC]
ccosh(conj(z)), ccoshf(conjf(z)), and ccoshl(conjl(z)) shall return
exactly the same value as conj(ccosh(z)), conjf(ccoshf(z)), and
conjl(ccoshl(z)), respectively, and ccosh(-z), ccoshf(-z), and
ccoshl(-z) shall return exactly the same value as ccosh(z), ccoshf(z), and
ccoshl(z), respectively, including for the special values of z below.
If z is +0 + i0, 1 + i0 shall be returned.
If z is +0 + iInf, NaN ± i0 shall be returned and the invalid floating-point exception shall be raised; the
sign of the imaginary part of the result is unspecified.
If z is +0 + iNaN, NaN ± i0 shall be returned; the sign of the imaginary part of the result is
unspecified.
If z is x + iInf where x is non-zero and finite, NaN + iNaN shall be returned and the invalid
floating-point exception shall be raised.
If z is x + iNaN where x is non-zero and finite, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is +Inf + i0, +Inf + i0 shall be returned.
If z is +Inf + iy where y is non-zero and finite, +Inf (cos(y) + isin(y)) shall
be returned.
If z is +Inf + iInf, ±Inf + iNaN shall be returned and the invalid floating-point exception shall be
raised; the sign of the real part of the result is unspecified.
If z is +Inf + iNaN, +Inf + iNaN shall be returned.
If z is NaN + i0, NaN ± i0 shall be returned; the sign of the imaginary part of the result is
unspecified.
If z is NaN + iy where y is any non-zero number, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is NaN + iNaN, NaN + iNaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
cacosh()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/_Exit.html =====
_Exit
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
_Exit, _exit — terminate a process
SYNOPSIS
#include
_Noreturn void _Exit(int status);
#include
_Noreturn void _exit(int status);
DESCRIPTION
For _Exit(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The value of status may be 0, EXIT_SUCCESS, EXIT_FAILURE, [CX]
or any other value, though only the least significant 8
bits (that is, status & 0377) shall be available from wait() and waitpid(); the full value shall be available from waitid() and in the siginfo_t passed to a signal handler for SIGCHLD.
[CX]  The
_Exit() and _exit() functions shall be functionally equivalent.
The _Exit() [CX]   and _exit()  functions
shall not call functions registered with atexit() nor at_quick_exit(), nor any registered signal handlers. [CX]   Open streams
shall not be flushed.   Whether open streams are closed
(without flushing) is implementation-defined. Finally, the calling process shall be terminated with the consequences described
below.
Consequences of Process Termination
[CX]
Process termination caused by any reason shall have the following consequences:
Note:
These consequences are all extensions to the ISO C standard and are not further CX shaded. However, functionality relating
to the XSI option is shaded.
All of the file descriptors, directory streams, conversion descriptors, and message catalog descriptors open in the calling
process shall be closed.
[XSI]
If the parent process of the calling process has set its SA_NOCLDWAIT flag or has set the action for the SIGCHLD signal to
SIG_IGN:
The process' status information (see 2.12 Status Information), if
any, shall be discarded.
The lifetime of the calling process shall end immediately. If SA_NOCLDWAIT is set, it is implementation-defined whether a
SIGCHLD signal is sent to the parent process.
If a thread in the parent process of the calling process is blocked in wait(),
waitpid(), or waitid(), and the parent
process has no remaining child processes in the set of waited-for children, the wait(),
waitid(), or waitpid() function shall
fail and set errno to [ECHILD].
Otherwise:
Status information (see 2.12 Status Information) shall be
generated.
The calling process shall be transformed into a zombie process. Its status information shall be made available to the parent
process until the process' lifetime ends.
The process' lifetime shall end once its parent obtains the process' status information via a currently-blocked or future call
to wait(), waitid() (without WNOWAIT), or
waitpid().
If one or more threads in the parent process of the calling process is blocked in a call to wait(), waitid(), or waitpid() awaiting termination of the process, one (or, if any are calling waitid() with WNOWAIT, possibly more) of these threads shall obtain the process' status
information as specified in 2.12 Status Information and become
unblocked.
A SIGCHLD shall be sent to the parent process.
Termination of a process does not directly terminate its children. The sending of a SIGHUP signal as described below indirectly
terminates children in some circumstances.
The parent process ID of all of the existing child processes and zombie processes of the calling process shall be set to the
process ID of an implementation-defined system process. That is, these processes shall be inherited by a special system
process.
[XSI]
Each attached shared-memory segment is detached and the value of shm_nattch (see shmget()) in the data structure associated with its shared memory ID shall be decremented by
1.
[XSI]
For each semaphore for which the calling process has set a semadj value (see semop()), that value shall be added to the semval of the specified semaphore.
If the process is a controlling process, the SIGHUP signal shall be sent to each process in the foreground process group of the
controlling terminal belonging to the calling process.
If the process is a controlling process, the controlling terminal associated with the session shall be disassociated from the
session, allowing it to be acquired by a new controlling process.
If the exit of the process causes a process group to become orphaned, and if any member of the newly-orphaned process group is
stopped, then a SIGHUP signal followed by a SIGCONT signal shall be sent to each process in the newly-orphaned process group.
All open named semaphores in the calling process shall be closed as if by appropriate calls to sem_close(). All open unnamed semaphores in the calling process shall be destroyed as if
by appropriate calls to sem_destroy().
[ML]  Any
memory locks established by the process via calls to mlockall() or mlock() shall be removed. If locked pages in the address space of the calling process are also
mapped into the address spaces of other processes and are locked by those processes, the locks established by the other processes
shall be unaffected by the call by this process to _Exit() or _exit().
Memory mappings that were created in the process shall be unmapped before the process is destroyed.
[TYM]
Any blocks of typed memory that were mapped in the calling process shall be unmapped, as if munmap() was implicitly called to unmap them.
[MSG]
All open message queue descriptors in the calling process shall be closed as if by appropriate calls to mq_close().
Any outstanding cancelable asynchronous I/O operations may be canceled. Those asynchronous I/O operations that are not canceled
shall complete as if the _Exit() or _exit() operation had not yet occurred, but any associated signal notifications
shall be suppressed. The _Exit() or _exit() operation may block awaiting such I/O completion. Whether any I/O is
canceled, and which I/O may be canceled upon _Exit() or _exit(), is implementation-defined.
Threads terminated by a call to _Exit() or _exit() shall not invoke their cancellation cleanup handlers or
per-thread data destructors.
RETURN VALUE
These functions do not return.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Normally applications should use exit() rather than _Exit() or
_exit().
Exit statuses of 126 and greater are ambiguous in certain circumstances because they have special meanings in the shell (see
2.8.2 Exit Status for Commands and the EXIT STATUS section of
sh).
RATIONALE
Process Termination
Early proposals drew a distinction between normal and abnormal process termination. Abnormal termination was caused only by
certain signals and resulted in implementation-defined "actions", as discussed below. Subsequent proposals distinguished three
types of termination: normal termination (as in the current specification), simple abnormal termination, and
abnormal termination with actions. Again the distinction between the two types of abnormal termination was that they were
caused by different signals and that implementation-defined actions would result in the latter case. Given that these actions were
completely implementation-defined, the early proposals were only saying when the actions could occur and how their occurrence could
be detected, but not what they were. This was of little or no use to conforming applications, and thus the distinction is not made
in this volume of POSIX.1-2024.
The implementation-defined actions usually include, in most historical implementations, the creation of a file named core
in the current working directory of the process. This file contains an image of the memory of the process, together with
descriptive information about the process, perhaps sufficient to reconstruct the state of the process at the receipt of the
signal.
There is a potential security problem in creating a core file if the process was set-user-ID and the current user is not
the owner of the program, if the process was set-group-ID and none of the user's groups match the group of the program, or if the
user does not have permission to write in the current directory. In this situation, an implementation either should not create a
core file or should make it unreadable by the user.
Despite the silence of this volume of POSIX.1-2024 on this feature, applications are advised not to create files named
core because of potential conflicts in many implementations. Some implementations use a name other than core for the
file; for example, by appending the process ID to the filename.
Terminating a Process
It is important that the consequences of process termination as described occur regardless of whether the process called
_exit() (perhaps indirectly through exit()) or instead was terminated due to a
signal or for some other reason. Note that in the specific case of exit() this means
that the status argument to exit() is treated in the same way as the
status argument to _exit().
A language other than C may have other termination primitives than the C-language exit() function, and programs written in such a language should use its native termination
primitives, but those should have as part of their function the behavior of _exit() as described. Implementations in
languages other than C are outside the scope of this version of this volume of POSIX.1-2024, however.
As required by the ISO C standard, using return from main() has the same behavior (other than with respect to
language scope issues) as calling exit() with the returned value. Reaching the end of
the main() function has the same behavior as calling exit(0).
A value of zero (or EXIT_SUCCESS, which is required to be zero) for the argument status conventionally indicates
successful termination. This corresponds to the specification for exit() in the
ISO C standard. The convention is followed by utilities such as make and various
shells, which interpret a zero status from a child process as success. For this reason, applications should not call exit(0)
or _exit(0) when they terminate unsuccessfully; for example, in signal-catching functions.
Historically, the implementation-defined process that inherits children whose parents have terminated without waiting on them is
called init and has a process ID of 1.
The sending of a SIGHUP to the foreground process group when a controlling process terminates corresponds to somewhat different
historical implementations. In System V, the kernel sends a SIGHUP on termination of (essentially) a controlling process. In 4.2
BSD, the kernel does not send SIGHUP in a case like this, but the termination of a controlling process is usually noticed by a
system daemon, which arranges to send a SIGHUP to the foreground process group with the vhangup() function. However, in 4.2
BSD, due to the behavior of the shells that support job control, the controlling process is usually a shell with no other processes
in its process group. Thus, a change to make _exit() behave this way in such systems should not cause problems with existing
applications.
The termination of a process may cause a process group to become orphaned in either of two ways. The connection of a process
group to its parent(s) outside of the group depends on both the parents and their children. Thus, a process group may be orphaned
by the termination of the last connecting parent process outside of the group or by the termination of the last direct descendant
of the parent process(es). In either case, if the termination of a process causes a process group to become orphaned, processes
within the group are disconnected from their job control shell, which no longer has any information on the existence of the process
group. Stopped processes within the group would languish forever. In order to avoid this problem, newly orphaned process groups
that contain stopped processes are sent a SIGHUP signal and a SIGCONT signal to indicate that they have been disconnected from
their session. The SIGHUP signal causes the process group members to terminate unless they are catching or ignoring SIGHUP. Under
most circumstances, all of the members of the process group are stopped if any of them are stopped.
The action of sending a SIGHUP and a SIGCONT signal to members of a newly orphaned process group is similar to the action of 4.2
BSD, which sends SIGHUP and SIGCONT to each stopped child of an exiting process. If such children exit in response to the SIGHUP,
any additional descendants receive similar treatment at that time. In this volume of POSIX.1-2024, the signals are sent to the
entire process group at the same time. Also, in this volume of POSIX.1-2024, but not in 4.2 BSD, stopped processes may be orphaned,
but may be members of a process group that is not orphaned; therefore, the action taken at _exit() must consider processes
other than child processes.
It is possible for a process group to be orphaned by a call to setpgid() or
setsid(), as well as by process termination. This volume of POSIX.1-2024 does not
require sending SIGHUP and SIGCONT in those cases, because, unlike process termination, those cases are not caused accidentally by
applications that are unaware of job control. An implementation can choose to send SIGHUP and SIGCONT in those cases as an
extension; such an extension must be documented as required in .
The ISO/IEC 9899:1999 standard added the _Exit() function that results in immediate program termination without
triggering signals or atexit()-registered functions. In POSIX.1-2024, this is
equivalent to the _exit() function.
FUTURE DIRECTIONS
None.
SEE ALSO
at_quick_exit(), atexit()
, exit(), mlock(), mlockall(), mq_close(), munmap(), quick_exit(), sem_close(), semop(), setpgid(), setsid(), shmget(), wait(), waitid()
XBD ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Realtime Extension and the POSIX Threads Extension.
Interactions with the SA_NOCLDWAIT flag and SIGCHLD signal are further clarified.
The values of status from exit() are better described.
Issue 6
Extensions beyond the ISO C standard are marked.
The DESCRIPTION is updated for alignment with IEEE Std 1003.1j-2000 by adding semantics for typed memory.
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The _Exit() function is included.
The DESCRIPTION is updated.
The description of tracing semantics is added for alignment with IEEE Std 1003.1q-2000.
References to the wait3() function are removed.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/16 is applied, correcting grammar in the DESCRIPTION.
Issue 7
Austin Group Interpretation 1003.1-2001 #031 is applied, separating these functions from the exit() function.
Austin Group Interpretation 1003.1-2001 #085 is applied, clarifying the text regarding flushing of streams and closing of
temporary files.
Functionality relating to the Asynchronous Input and Output, Memory Mapped Files, and Semaphores options is moved to the
Base.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0033 [594] and XSH/TC2-2008/0034 [594,690] are applied.
Issue 8
Austin Group Defect 368 is applied, adding a requirement for unnamed semaphores to be destroyed.
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
Austin Group Defect 1629 is applied, changing the APPLICATION USAGE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/regexec.html =====
regcomp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
regcomp, regerror, regexec, regfree — regular expression matching
SYNOPSIS
#include
int regcomp(regex_t *restrict preg, const char *restrict pattern,
int cflags);
size_t regerror(int errcode, const regex_t *restrict preg,
char *restrict errbuf, size_t errbuf_size);
int regexec(const regex_t *restrict preg, const char *restrict string,
size_t nmatch, regmatch_t pmatch[restrict], int
eflags);
void regfree(regex_t *preg);
DESCRIPTION
These functions interpret basic and extended regular expressions as described in XBD 9. Regular Expressions.
The regex_t structure is defined in  and contains at least
the following member:
Member Type
Member Name
Description
size_t
re_nsub
Number of parenthesized subexpressions.
The regmatch_t structure is defined in  and
contains at least the following members:
Member Type
Member Name
Description
regoff_t
rm_so
Byte offset from start of string to start of substring.
regoff_t
rm_eo
Byte offset from start of string of the first character after the end of substring.
The regcomp() function shall compile the regular expression contained in the string pointed to by the
pattern argument and place the results in the structure pointed to by preg. The cflags argument is the
bitwise-inclusive OR of zero or more of the following flags, which are defined in the  header:
REG_EXTENDED
Use Extended Regular Expressions.
REG_ICASE
Perform matching in a case-insensitive manner (see XBD 9.2 Regular Expression
General Requirements).
REG_MINIMAL
Change the matching behavior for duplication symbols to the leftmost shortest possible match, and invert the behavior of the
repetition modifier '?' () to match the longest possible match instead of the shortest. Only
applicable to REG_EXTENDED regular expressions.
REG_NOSUB
Report only success/fail in regexec().
REG_NEWLINE
Change the handling of  characters, as described in the text.
The default regular expression type for pattern is a Basic Regular Expression. The application can specify
Extended Regular Expressions using the REG_EXTENDED cflags flag.
If the REG_NOSUB flag was not set in cflags, then regcomp() shall set re_nsub to the number of
parenthesized subexpressions (delimited by "\(\)" in basic regular expressions or "()" in extended regular
expressions) found in pattern.
The regexec() function compares the null-terminated string specified by string with the compiled
regular expression preg initialized by a previous call to regcomp(). If it finds a match, regexec() shall
return 0; otherwise, it shall return non-zero indicating either no match or an error. The eflags argument is the
bitwise-inclusive OR of zero or more of the following flags, which are defined in the  header:
REG_NOTBOL
The first character of the string pointed to by string is not the beginning of the line. Therefore, the
character ('^'), when taken as a special character, shall not match the beginning of
string.
REG_NOTEOL
The last character of the string pointed to by string is not the end of the line. Therefore, the
('$'), when taken as a special character, shall not match the end of string.
If nmatch is 0 or REG_NOSUB was set in the cflags argument to regcomp(), then regexec()
shall ignore the pmatch argument. Otherwise, the application shall ensure that the pmatch argument points to an array
with at least nmatch elements, and regexec() shall fill in the elements of that array with offsets of the substrings
of string that correspond to the parenthesized subexpressions of pattern: pmatch[i].rm_so shall
be the byte offset of the beginning and pmatch[i].rm_eo shall be one greater than the byte offset of the end
of substring i. (Subexpression i begins at the ith matched open parenthesis, counting from 1.) Offsets in
pmatch[0] identify the substring that corresponds to the entire regular expression. Unused elements of pmatch up to
pmatch[nmatch-1] shall be filled with -1. If there are more than nmatch subexpressions in pattern
(pattern itself counts as a subexpression), then regexec() shall still do the match, but shall record only the first
nmatch substrings.
When matching a basic or extended regular expression, any given parenthesized subexpression of pattern might
participate in the match of several different substrings of string, or it might not match any substring even though the
pattern as a whole did match. The following rules shall be used to determine which substrings to report in pmatch when
matching regular expressions:
If subexpression i in a regular expression is not contained within another subexpression, and it
participated in the match several times, then the byte offsets in pmatch[i] shall delimit the last such match.
If subexpression i is not contained within another subexpression, and it did not participate in an
otherwise successful match, the byte offsets in pmatch[i] shall be -1. A subexpression does not participate in the
match when:
'*' or "\{\}" appears immediately after the subexpression in a basic regular expression, or
'*', '?', or "{}" appears immediately after the subexpression in an extended regular expression, and the
subexpression did not match (matched 0 times)
or:
'|' is used in an extended regular expression to select this subexpression or another, and the other
subexpression matched.
If subexpression i is contained within another subexpression j, and i is not contained within
any other subexpression that is contained within j, and a match of subexpression j is reported in
pmatch[j], then the match or non-match of subexpression i reported in pmatch[i] shall be as
described in 1. and 2. above, but within the substring reported in pmatch[j] rather than the whole string. The
offsets in pmatch[i] are still relative to the start of string.
If subexpression i is contained in subexpression j, and the byte offsets in pmatch[j]
are -1, then the pointers in pmatch[i] shall also be -1.
If subexpression i matched a zero-length string, then both byte offsets in pmatch[i] shall be
the byte offset of the character or null terminator immediately following the zero-length string.
If, when regexec() is called, the locale is different from when the regular expression was compiled, the
result is undefined.
If REG_NEWLINE is not set in cflags, then a  in pattern or string shall be
treated as an ordinary character. If REG_NEWLINE is set, then  shall be treated as an ordinary character except as
follows:
A  in string shall not be matched by a  outside a bracket expression or by any
form of a non-matching list (see XBD 9. Regular Expressions).
A  ('^') in pattern, when used to specify expression anchoring (see XBD 9.3.8 BRE Expression Anchoring), shall match the zero-length string
immediately after a  in string, regardless of the setting of REG_NOTBOL.
A  ('$') in pattern, when used to specify expression anchoring, shall match the
zero-length string immediately before a  in string, regardless of the setting of REG_NOTEOL.
The regfree() function shall free any memory allocated by regcomp() associated with preg. The
regfree() function shall not modify errno if preg was previously returned by regcomp() and not yet
freed.
The following constants are defined as the minimum set of error return values, although other errors listed as
implementation extensions in  are possible:
REG_BADBR
Content of "\{\}" invalid: not a number, number too large, more than two numbers, first larger than second.
REG_BADPAT
Invalid regular expression.
REG_BADRPT
'?', '*', or '+' not preceded by valid regular expression.
REG_EBRACE
"\{\}" imbalance.
REG_EBRACK
"[]" imbalance.
REG_ECOLLATE
Invalid collating element referenced.
REG_ECTYPE
Invalid character class type referenced.
REG_EESCAPE
Trailing  character in pattern.
REG_EPAREN
"\(\)" or "()" imbalance.
REG_ERANGE
Invalid endpoint in range expression.
REG_ESPACE
Out of memory.
REG_ESUBREG
Number in "\digit" invalid or in error.
REG_NOMATCH
regexec() failed to match.
If more than one error occurs in processing a function call, any one of the possible constants may be returned, as
the order of detection is unspecified.
The regerror() function provides a mapping from error codes returned by regcomp() and
regexec() to unspecified printable strings. It generates a string corresponding to the value of the errcode argument,
which the application shall ensure is the last non-zero value returned by regcomp() or regexec() with the given value
of preg. If errcode is not such a value, the content of the generated string is unspecified.
If preg is a null pointer, but errcode is a value returned by a previous call to regexec() or
regcomp(), the regerror() still generates an error string corresponding to the value of errcode, but it might
not be as detailed under some implementations.
If the errbuf_size argument is not 0, regerror() shall place the generated string into the buffer of
size errbuf_size bytes pointed to by errbuf. If the string (including the terminating null) cannot fit in the buffer,
regerror() shall truncate the string and null-terminate the result.
If errbuf_size is 0, regerror() shall ignore the errbuf argument, and return the size of the
buffer needed to hold the generated string.
If the preg argument to regexec() or regfree() is not a compiled regular expression returned
by regcomp(), the result is undefined. A preg is no longer treated as a compiled regular expression after it is given
to regfree().
RETURN VALUE
Upon successful completion, the regcomp() function shall return 0. Otherwise, it shall return an integer value indicating
an error as described in , and the content of preg is
undefined. If a code is returned, the interpretation shall be as given in .
If regcomp() detects an invalid RE, it may return REG_BADPAT, or it may return one of the error codes that
more precisely describes the error.
Upon successful completion, the regexec() function shall return 0. Otherwise, it shall return REG_NOMATCH to
indicate no match.
Upon successful completion, the regerror() function shall return the number of bytes needed to hold the
entire generated string, including the null termination. If the return value is greater than errbuf_size, the string
returned in the buffer pointed to by errbuf has been truncated.
The regfree() function shall not return a value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
#include
/*
* Match string against the extended regular expression in
* pattern, treating errors as no match.
*
* Return 1 for match, 0 for no match.
*/
int
match(const char *string, char *pattern)
{
int    status;
regex_t    re;
if (regcomp(&re, pattern, REG_EXTENDED|REG_NOSUB) != 0) {
return(0);      /* Report error. */
}
status = regexec(&re, string, (size_t) 0, NULL, 0);
regfree(&re);
if (status != 0) {
return(0);      /* Report error. */
}
return(1);
}
The following demonstrates how the REG_NOTBOL flag could be used with regexec() to find all substrings in a
line that match a pattern supplied by a user. (For simplicity of the example, very little error checking is done.)
(void) regcomp (&re, pattern, 0);
/* This call to regexec() finds the first match on the line. */
error = regexec (&re, &buffer[0], 1, &pm, 0);
while (error == 0) {  /* While matches found. */
/* Substring found between pm.rm_so and pm.rm_eo. */
/* This call to regexec() finds the next match. */
error = regexec (&re, buffer + pm.rm_eo, 1, &pm, REG_NOTBOL);
}
APPLICATION USAGE
An application could use:
regerror(code,preg,(char *)NULL,(size_t)0)
to find out how big a buffer is needed for the generated string, malloc() a buffer to hold the string, and then call regerror() again to get the
string. Alternatively, it could allocate a fixed, static buffer that is big enough to hold most strings, and then use malloc() to allocate a larger buffer if it finds that this is too small.
To match a pattern as described in XCU 2.14 Pattern Matching
Notation, use the fnmatch() function.
RATIONALE
The regexec() function must fill in all nmatch elements of pmatch, where nmatch and pmatch
are supplied by the application, even if some elements of pmatch do not correspond to subexpressions in pattern. The
application developer should note that there is probably no reason for using a value of nmatch that is larger than
preg->re_nsub+1.
The REG_NEWLINE flag supports a use of RE matching that is needed in some applications like text editors. In such
applications, the user supplies an RE asking the application to find a line that matches the given expression. An anchor in such an
RE anchors at the beginning or end of any line. Such an application can pass a sequence of -separated lines to
regexec() as a single long string and specify REG_NEWLINE to regcomp() to get the desired behavior. The application
must ensure that there are no explicit  characters in pattern if it wants to ensure that any match occurs
entirely within a single line.
The REG_NEWLINE flag affects the behavior of regexec(), but it is in the cflags parameter to
regcomp() to allow flexibility of implementation. Some implementations will want to generate the same compiled RE in
regcomp() regardless of the setting of REG_NEWLINE and have regexec() handle anchors differently based on the setting
of the flag. Other implementations will generate different compiled REs based on the REG_NEWLINE.
The REG_ICASE flag supports the operations taken by the grep -i
option and the historical implementations of ex and vi. Including this flag will make it easier for application code to be written that does the same
thing as these utilities.
The substrings reported in pmatch[] are defined using offsets from the start of the string rather than
pointers. This allows type-safe access to both constant and non-constant strings.
The type regoff_t is used for the elements of pmatch[] to ensure that the application can represent
large arrays in memory (important for an application conforming to the Shell and Utilities volume of POSIX.1-2024).
The 1992 edition of this standard required regoff_t to be at least as wide as off_t, to facilitate
future extensions in which the string to be searched is taken from a file. However, these future extensions have not appeared. The
requirement rules out popular implementations with 32-bit regoff_t and 64-bit off_t, so it has been removed.
The standard developers rejected the inclusion of a regsub() function that would be used to do substitutions
for a matched RE. While such a routine would be useful to some applications, its utility would be much more limited than the
matching function described here. Both RE parsing and substitution are possible to implement without support other than that
required by the ISO C standard, but matching is much more complex than substituting. The only difficult part of substitution,
given the information supplied by regexec(), is finding the next character in a string when there can be multi-byte
characters. That is a much larger issue, and one that needs a more general solution.
The errno variable has not been used for error returns to avoid filling the errno name space for this
feature.
The interface is defined so that the matched substrings rm_sp and rm_ep are in a separate
regmatch_t structure instead of in regex_t. This allows a single compiled RE to be used simultaneously in several
contexts; in main() and a signal handler, perhaps, or in multiple threads of lightweight processes. (The preg
argument to regexec() is declared with type const, so the implementation is not permitted to use the structure to
store intermediate results.) It also allows an application to request an arbitrary number of substrings from an RE. The number of
subexpressions in the RE is reported in re_nsub in preg. With this change to regexec(), consideration was
given to dropping the REG_NOSUB flag since the user can now specify this with a zero nmatch argument to regexec().
However, keeping REG_NOSUB allows an implementation to use a different (perhaps more efficient) algorithm if it knows in
regcomp() that no subexpressions need be reported. The implementation is only required to fill in pmatch if
nmatch is not zero and if REG_NOSUB is not specified. Note that the size_t type, as defined in the ISO C
standard, is unsigned, so the description of regexec() does not need to address negative values of nmatch.
REG_NOTBOL was added to allow an application to do repeated searches for the same pattern in a line. If the pattern
contains a  character that should match the beginning of a line, then the pattern should only match when matched
against the beginning of the line. Without the REG_NOTBOL flag, the application could rewrite the expression for subsequent
matches, but in the general case this would require parsing the expression. The need for REG_NOTEOL is not as clear; it was added
for symmetry.
The addition of the regerror() function addresses the historical need for conforming application programs to
have access to error information more than "Function failed to compile/match your RE for unknown reasons".
This interface provides for two different methods of dealing with error conditions. The specific error codes
(REG_EBRACE, for example), defined in , allow an application to
recover from an error if it is so able. Many applications, especially those that use patterns supplied by a user, will not try to
deal with specific error cases, but will just use regerror() to obtain a human-readable error message to present to the
user.
The regerror() function uses a scheme similar to confstr() to
deal with the problem of allocating memory to hold the generated string. The scheme used by strerror() in the ISO C standard was considered unacceptable since it creates
difficulties for multi-threaded applications.
The preg argument is provided to regerror() to allow an implementation to generate a more descriptive
message than would be possible with errcode alone. An implementation might, for example, save the character offset of the
offending character of the pattern in a field of preg, and then include that in the generated message string. The
implementation may also ignore preg.
A REG_FILENAME flag was considered, but omitted. This flag caused regexec() to match patterns as described
in XCU 2.14 Pattern Matching Notation instead of REs. This service is
now provided by the fnmatch() function.
Notice that there is a difference in philosophy between the ISO POSIX-2:1993 standard and POSIX.1-2024 in how
to handle a "bad" regular expression. The ISO POSIX-2:1993 standard says that many bad constructs "produce undefined
results", or that "the interpretation is undefined". POSIX.1-2024, however, says that the interpretation of such REs is
unspecified. The term "undefined" means that the action by the application is an error, of similar severity to passing a bad
pointer to a function.
The regcomp() and regexec() functions are required to accept any null-terminated string as the
pattern argument. If the meaning of the string is "undefined", the behavior of the function is "unspecified".
POSIX.1-2024 does not specify how the functions will interpret the pattern; they might return error codes, or they might do pattern
matching in some completely unexpected way, but they should not do something like abort the process.
FUTURE DIRECTIONS
None.
SEE ALSO
fnmatch(), glob()
XBD 9. Regular Expressions, ,
XCU 2.14 Pattern Matching Notation
CHANGE HISTORY
First released in Issue 4. Derived from the ISO POSIX-2 standard.
Issue 5
Moved from POSIX2 C-language Binding to BASE.
Issue 6
In the SYNOPSIS, the optional include of the  header is
removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX
Specification:
The requirement to include  has been removed.
Although  was required for conforming implementations of
previous POSIX specifications, it was not required for UNIX applications.
The normative text is updated to avoid use of the term "must" for application requirements.
The REG_ENOSYS constant is removed.
The restrict keyword is added to the regcomp(), regerror(), and regexec() prototypes
for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
Austin Group Interpretation 1003.1-2001 #134 is applied, clarifying that if more than one error occurs in processing a function
call, any one of the possible constants may be returned.
SD5-XBD-ERN-60 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0505 [305] is applied.
Issue 8
Austin Group Defect 385 is applied, adding a requirement that regfree() does not modify errno when passed a
pointer to a regex_t that can be freed.
Austin Group Defects 793 and 1329 are applied, adding REG_MINIMAL.
Austin Group Defect 1031 is applied, changing the description of REG_ICASE.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atomic_exchange_explicit.html =====
atomic_exchange
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atomic_exchange, atomic_exchange_explicit — atomically exchange the value of an object
SYNOPSIS
#include
C atomic_exchange(volatile A *object, C desired); C
atomic_exchange_explicit(volatile A *object, C desired,
memory_order order);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
Implementations that define the macro __STDC_NO_ATOMICS__ need not provide the  header nor support these generic functions.
The atomic_exchange_explicit() generic function shall atomically replace the value pointed to by object with
desired. This operation shall be an atomic read-modify-write operation (see XBD 4.15.1 Memory Ordering). Memory shall be affected according to the value of
order.
The atomic_exchange() generic function shall be equivalent to atomic_exchange_explicit() called with order
set to memory_order_seq_cst.
RETURN VALUE
These generic functions shall return the value pointed to by object immediately before the effects.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD 4.15.1 Memory Ordering,
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/lrintl.html =====
lrint
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
lrint, lrintf, lrintl — round to nearest integer value using current rounding direction
SYNOPSIS
#include
long lrint(double x);
long lrintf(float x);
long lrintl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall round their argument to the nearest integer value, rounding according to the current rounding
direction.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the rounded integer value.
[MX]  If
x is NaN, a domain error shall occur and an unspecified value is returned.
If x is +Inf, a domain error shall occur and an unspecified value is returned.
If x is -Inf, a domain error shall occur and an unspecified value is returned.
If the correct value is positive and too large to represent as a long, an unspecified value shall be returned.
[MX]
On systems that support the IEC 60559 Floating-Point option, a domain error shall occur;   otherwise, a [CX]   domain  error may occur.
If the correct value is negative and too large to represent as a long, an unspecified value shall be returned.
[MX]
On systems that support the IEC 60559 Floating-Point option, a domain error shall occur;   otherwise, a [CX]   domain  error may occur.
ERRORS
These functions shall fail if:
Domain Error
[MX]
The x argument is NaN or ±Inf, or the correct value is not representable as an integer.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
These functions may fail if:
Domain Error
The correct value is not representable as an integer.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
These functions provide floating-to-integer conversions. They round according to the current rounding direction. If the rounded
value is outside the range of the return type, the numeric result is unspecified and the invalid floating-point exception is
raised. When they raise no other floating-point exception and the result differs from the argument, they raise the inexact
floating-point exception.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), llrint()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #53 (SD5-XSH-ERN-77) is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/system.html =====
system
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
system — issue a command
SYNOPSIS
#include
int system(const char *command);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
If command is a null pointer, the system() function shall determine whether the host environment has a command
processor. If command is not a null pointer, the system() function shall pass the string pointed to by command
to that command processor to be executed in an implementation-defined manner; this might then cause the program calling
system() to behave in a non-conforming manner or to terminate.
[CX]  The
system() function shall behave as if a child process were created using fork(),
and the child process invoked the sh utility using execl() as follows:
execl(, "sh", "-c", "--", command, (char *)0);
where  is an unspecified pathname for the sh utility. It is
implementation-defined whether the handlers registered with pthread_atfork()
are called as part of the creation of the child process.
The system() function shall ignore the SIGINT and SIGQUIT signals, and shall block the SIGCHLD signal, while waiting for
the command to terminate. If this might cause the application to miss a signal that would have killed it, then the application
should examine the return value from system() and take whatever action is appropriate to the application if the command
terminated due to receipt of a signal.
The system() function shall not affect the termination status of any child of the calling processes other than the
process or processes it itself creates.
The system() function shall not return until the child process has terminated.
If concurrent calls to system() are made from multiple threads, it is unspecified whether:
each call saves and restores the dispositions of the SIGINT and SIGQUIT signals independently, or
in a set of concurrent calls the dispositions in effect after the last call returns are those that were in effect on entry to
the first call.
If a thread is cancelled while it is in a call to system(), it is unspecified whether the child process is terminated and
waited for, or is left running.
RETURN VALUE
If command is a null pointer, system() shall return non-zero to indicate that a command processor is available, or
zero if none is available. [CX]  The system() function shall always return non-zero when command is NULL.
[CX]  If
command is not a null pointer, system() shall return the termination status of the command language interpreter in
the format specified by waitpid(). The termination status shall be as defined for
the sh utility; otherwise, the termination status is unspecified. If some error prevents
the command language interpreter from executing after the child process is created, the return value from system() shall be
as if the command language interpreter had terminated using exit(127) or _exit(127). If a child process cannot be
created, or if the termination status for the command language interpreter cannot be obtained, system() shall return -1 and
set errno to indicate the error.
ERRORS
[CX]  The
system() function may set errno values as described by fork().
In addition, system() may fail if:
[ECHILD]
[CX]
The status of the child process created by system() is no longer available.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
If the return value of system() is not -1, its value can be decoded through the use of the macros described in . For convenience, these macros are also provided in .
Note that, while system() must ignore SIGINT and SIGQUIT and block SIGCHLD while waiting for the child to terminate, the
handling of signals in the executed command is as specified by fork() and exec. For example, if SIGINT is being caught or is set to SIG_DFL when system() is called,
then the child is started with SIGINT handling set to SIG_DFL.
Ignoring SIGINT and SIGQUIT in the parent process prevents coordination problems (two processes reading from the same terminal,
for example) when the executed command ignores or catches one of the signals. It is also usually the correct action when the user
has given a command to the application to be executed synchronously (as in the '!' command in many interactive
applications). In either case, the signal should be delivered only to the child process, not to the application itself. There is
one situation where ignoring the signals might have less than the desired effect. This is when the application uses system()
to perform some task invisible to the user. If the user typed the interrupt character ("^C", for example) while
system() is being used in this way, one would expect the application to be killed, but only the executed command is killed.
Applications that use system() in this way should carefully check the return status from system() to see if the
executed command was successful, and should take appropriate action when the command fails.
Blocking SIGCHLD while waiting for the child to terminate prevents the application from catching the signal and obtaining status
from system()'s child process before system() can get the status itself.
The context in which the utility is ultimately executed may differ from that in which system() was called. For example,
file descriptors that have the FD_CLOEXEC or FD_CLOFORK flag set are closed, and the process ID and parent process ID are
different. Also, if the executed utility changes its environment variables or its current working directory, that change is not
reflected in the caller's context.
There is no defined way for an application to find the specific path for the shell. However, confstr() can provide a value for PATH that is guaranteed to find the sh utility.
Although system() is required to be thread-safe, it is recommended that concurrent calls from multiple threads are
avoided, since system() is not required to coordinate the saving and restoring of the dispositions of the SIGINT and SIGQUIT
signals across a set of overlapping calls, and therefore the signals might end up being set to ignored after the last call returns.
Applications should also avoid cancelling a thread while it is in a call to system() as the child process may be left
running in that event. In addition, if another thread alters the disposition of the SIGCHLD signal, a call to signal() may produce unexpected results.
RATIONALE
The system() function should not be used by programs that have set user (or group) ID privileges. The fork() and exec family of functions (except
execlp() and execvp()), should be used
instead. This prevents any unforeseen manipulation of the environment of the user that could cause execution of commands not
anticipated by the calling program.
There are three levels of specification for the system() function. The ISO C standard gives the most basic. It
requires that the function exists, and defines a way for an application to query whether a command language interpreter exists. It
says nothing about the command language or the environment in which the command is interpreted.
POSIX.1-2024 places additional restrictions on system(). It requires that if there is a command language interpreter, the
environment must be as specified by fork() and exec. This ensures, for example, that close-on-exec works, that process-owned file locks
are not inherited, and that the process ID is different. It also specifies the return value from system() when the command
line can be run, thus giving the application some information about the command's completion status.
Finally, POSIX.1-2024 requires the command to be interpreted as in the shell command language defined in the Shell and Utilities
volume of POSIX.1-2024.
Note that, system(NULL) is required to return non-zero, indicating that there is a command language interpreter. At first
glance, this would seem to conflict with the ISO C standard which allows system(NULL) to return zero. There is no
conflict, however. A system must have a command language interpreter, and is non-conforming if none is present. It is therefore
permissible for the system() function on such a system to implement the behavior specified by the ISO C standard as
long as it is understood that the implementation does not conform to POSIX.1-2024 if system(NULL) returns zero.
It was explicitly decided that when command is NULL, system() should not be required to check to make sure that
the command language interpreter actually exists with the correct mode, that there are enough processes to execute it, and so on.
The call system(NULL) could, theoretically, check for such problems as too many existing child processes, and return zero.
However, it would be inappropriate to return zero due to such a (presumably) transient condition. If some condition exists that is
not under the control of this application and that would cause any system() call to fail, that system has been rendered
non-conforming.
Early drafts required, or allowed, system() to return with errno set to [EINTR] if it was interrupted with a
signal. This error return was removed, and a requirement that system() not return until the child has terminated was added.
This means that if a waitpid() call in system() exits with errno set
to [EINTR], system() must reissue the waitpid(). This change was made for two
reasons:
There is no way for an application to clean up if system() returns [EINTR], short of calling wait(), and that could have the undesirable effect of returning the status of children other
than the one started by system().
While it might require a change in some historical implementations, those implementations already have to be changed because
they use wait() instead of waitpid().
Note that if the application is catching SIGCHLD signals, it will receive such a signal before a successful system() call
returns.
To conform to POSIX.1-2024, system() must use waitpid(), or some similar
function, instead of wait().
The following code sample illustrates how system() might be implemented on an implementation conforming to
POSIX.1-2024.
int system(const char *cmd)
{
int stat;
pid_t pid;
struct sigaction sa, savintr, savequit;
sigset_t saveblock;
if (cmd == NULL)
return(1);
sa.sa_handler = SIG_IGN;
sigemptyset(&sa.sa_mask);
sa.sa_flags = 0;
sigemptyset(&savintr.sa_mask);
sigemptyset(&savequit.sa_mask);
sigaction(SIGINT, &sa, &savintr);
sigaction(SIGQUIT, &sa, &savequit);
sigaddset(&sa.sa_mask, SIGCHLD);
pthread_sigmask(SIG_BLOCK, &sa.sa_mask, &saveblock);
if ((pid = fork()) == 0) {
sigaction(SIGINT, &savintr, (struct sigaction *)0);
sigaction(SIGQUIT, &savequit, (struct sigaction *)0);
sigprocmask(SIG_SETMASK, &saveblock, (sigset_t *)0);
execl("/bin/sh", "sh", "-c", "--", cmd, (char *)0);
_exit(127);
}
if (pid == -1) {
stat = -1; /* errno comes from fork() */
} else {
while (waitpid(pid, &stat, 0) == -1) {
if (errno != EINTR){
stat = -1;
break;
}
}
}
sigaction(SIGINT, &savintr, (struct sigaction *)0);
sigaction(SIGQUIT, &savequit, (struct sigaction *)0);
sigprocmask(SIG_SETMASK, &saveblock, (sigset_t *)0);
return(stat);
}
Note that, while a particular implementation of system() (such as the one above) can assume a particular path for the
shell, such a path is not necessarily valid on another system. The above example is not portable, and is not intended to be.
Earlier versions of this standard did not require system() to be thread-safe because it alters the process-wide
disposition of the SIGINT and SIGQUIT signals. It is now required to be thread-safe to align with the ISO C standard, which
(since the introduction of threads in 2011) requires that it avoids data races. However, the function is not required to coordinate
the saving and restoring of the dispositions of the SIGINT and SIGQUIT signals across a set of overlapping calls, and the above
example does not do so. The example also does not terminate and wait for the child process if the calling thread is cancelled, and
so would leak a process ID in that event.
One reviewer suggested that an implementation of system() might want to use an environment variable such as SHELL
to determine which command interpreter to use. The supposed implementation would use the default command interpreter if the one
specified by the environment variable was not available. This would allow a user, when using an application that prompts for
command lines to be processed using system(), to specify a different command interpreter. Such an implementation is
discouraged. If the alternate command interpreter did not follow the command line syntax specified in the Shell and Utilities
volume of POSIX.1-2024, then changing SHELL would render system() non-conforming. This would affect applications that
expected the specified behavior from system(), and since the Shell and Utilities volume of POSIX.1-2024 does not mention
that SHELL affects system(), the application would not know that it needed to unset SHELL .
Earlier versions of this standard required the command string to be passed as the next argument after "-c"
(omitting "--"). This meant that portable applications needed to take care not to pass a command string beginning with
('-') or  ('+'), as it would then be interpreted as containing options. Now
that implementations are required to pass the "--", applications no longer need to do this.
FUTURE DIRECTIONS
None.
SEE ALSO
2.9.5.2 Cancellation Points, exec, pipe(), pthread_atfork(), wait()
XBD , , ,
XCU sh
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
Extensions beyond the ISO C standard are marked.
Issue 7
Austin Group Interpretation 1003.1-2001 #055 is applied, clarifying the thread-safety of this function and treatment of pthread_atfork() handlers.
Austin Group Interpretation 1003.1-2001 #156 is applied.
SD5-XSH-ERN-30 is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0365 [627] is applied.
Issue 8
Austin Group Defect 768 is applied, adding OFD-owned file locks.
Austin Group Defect 1302 is applied, aligning this function with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1317 is applied, making it implementation-defined whether the handlers registered with pthread_atfork() are called.
Austin Group Defect 1318 is applied, adding FD_CLOFORK.
Austin Group Defect 1440 is applied, adding a "--" argument to the specified execl() call.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sched_getscheduler.html =====
sched_getscheduler
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sched_getscheduler — get scheduling policy (REALTIME)
SYNOPSIS
[PS]  #include
int sched_getscheduler(pid_t pid);
DESCRIPTION
The sched_getscheduler() function shall return the scheduling policy of the process specified by pid. If the value
of pid is negative, the behavior of the sched_getscheduler() function is unspecified.
The values that can be returned by sched_getscheduler() are defined in the  header.
If a process specified by pid exists, and if the calling process has permission, the scheduling policy shall be returned
for the process whose process ID is equal to pid.
If pid is zero, the scheduling policy shall be returned for the calling process.
RETURN VALUE
Upon successful completion, the sched_getscheduler() function shall return the scheduling policy of the specified
process. If unsuccessful, the function shall return -1 and set errno to indicate the error.
ERRORS
The sched_getscheduler() function shall fail if:
[EPERM]
The requesting process does not have permission to determine the scheduling policy of the specified process.
[ESRCH]
No process can be found corresponding to that specified by pid.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
sched_getparam(), sched_setparam(), sched_setscheduler()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The sched_getscheduler() function is marked as part of the Process Scheduling option.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Process
Scheduling option.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/iswctype.html =====
iswctype
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
iswctype, iswctype_l — test character for a specified class
SYNOPSIS
#include
int iswctype(wint_t wc, wctype_t charclass);
[CX]  int iswctype_l(wint_t wc, wctype_t charclass,
locale_t locale);
DESCRIPTION
For iswctype(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The iswctype() [CX]   and iswctype_l()
functions shall determine whether the wide-character code wc has the character class charclass, returning true
or false. The iswctype() [CX]   and iswctype_l()
functions are defined on WEOF and wide-character codes corresponding to the valid character encodings in the current locale, or
[CX]
in the locale represented by locale,  respectively. If
the wc argument is not in the domain of the function, the result is undefined. If the value of charclass is invalid
(that is, not obtained by a call to wctype() or charclass is invalidated by a
subsequent call to setlocale() that has affected category LC_CTYPE ) the
result is unspecified.
[CX]  The
behavior is undefined if the locale argument to iswctype_l() is the special locale object LC_GLOBAL_LOCALE or is not
a valid locale object handle.
RETURN VALUE
The iswctype() [CX]   and iswctype_l()
functions shall return non-zero (true) if and only if wc has the property described by charclass. If
charclass is (wctype_t)0, the iswctype() [CX]   and iswctype_l()  functions shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
Testing for a Valid Character
#include
...
int yes_or_no;
wint_t wc;
wctype_t valid_class;
...
if ((valid_class=wctype("vowel")) == (wctype_t)0)
/* Invalid character class. */
yes_or_no=iswctype(wc,valid_class);
APPLICATION USAGE
The twelve strings "alnum", "alpha", "blank", "cntrl", "digit", "graph",
"lower", "print", "punct", "space", "upper", and "xdigit" are reserved for
the standard character classes. In the table below, the functions in the left column are equivalent to the functions in the right
column.
iswalnum(wc)            iswctype(wc, wctype("alnum"))
iswalnum_l(wc, locale)  iswctype_l(wc, wctype("alnum"), locale)
iswalpha(wc)            iswctype(wc, wctype("alpha"))
iswalpha_l(wc, locale)  iswctype_l(wc, wctype("alpha"), locale)
iswblank(wc)            iswctype(wc, wctype("blank"))
iswblank_l(wc, locale)  iswctype_l(wc, wctype("blank"), locale)
iswcntrl(wc)            iswctype(wc, wctype("cntrl"))
iswcntrl_l(wc, locale)  iswctype_l(wc, wctype("cntrl"), locale)
iswdigit(wc)            iswctype(wc, wctype("digit"))
iswdigit_l(wc, locale)  iswctype_l(wc, wctype("digit"), locale)
iswgraph(wc)            iswctype(wc, wctype("graph"))
iswgraph_l(wc, locale)  iswctype_l(wc, wctype("graph"), locale)
iswlower(wc)            iswctype(wc, wctype("lower"))
iswlower_l(wc, locale)  iswctype_l(wc, wctype("lower"), locale)
iswprint(wc)            iswctype(wc, wctype("print"))
iswprint_l(wc, locale)  iswctype_l(wc, wctype("print"), locale)
iswpunct(wc)            iswctype(wc, wctype("punct"))
iswpunct_l(wc, locale)  iswctype_l(wc, wctype("punct"), locale)
iswspace(wc)            iswctype(wc, wctype("space"))
iswspace_l(wc, locale)  iswctype_l(wc, wctype("space"), locale)
iswupper(wc)            iswctype(wc, wctype("upper"))
iswupper_l(wc, locale)  iswctype_l(wc, wctype("upper"), locale)
iswxdigit(wc)           iswctype(wc, wctype("xdigit"))
iswxdigit_l(wc, locale) iswctype_l(wc, wctype("xdigit"), locale)
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
iswalnum(), iswalpha(),
iswcntrl(), iswdigit(),
iswgraph(), iswlower(),
iswprint(), iswpunct(),
iswspace(), iswupper(),
iswxdigit(), setlocale(),
uselocale(), wctype()
XBD ,
CHANGE HISTORY
First released as World-wide Portability Interfaces in Issue 4.
Issue 5
The following change has been made in this version for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E):
The SYNOPSIS has been changed to indicate that this function and associated data types are now made visible by inclusion of the
header rather than .
Issue 6
The behavior of charclass = (wctype_t)0 is now described.
An example is added.
A new function, iswblank(), is added to the list in the APPLICATION USAGE.
Issue 7
The iswctype_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0321 [283] and XSH/TC1-2008/0322 [283] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0184 [799] and XSH/TC2-2008/0185 [799] are applied.
Issue 8
Austin Group Defect 1302 is applied, aligning the iswctype() function with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fdatasync.html =====
fdatasync
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fdatasync — synchronize the data of a file (REALTIME)
SYNOPSIS
[SIO]  #include
int fdatasync(int fildes);
DESCRIPTION
The fdatasync() function shall force all currently queued I/O operations associated with the file indicated by file
descriptor fildes to the synchronized I/O completion state.
The functionality shall be equivalent to fsync() with the symbol
_POSIX_SYNCHRONIZED_IO defined, with the exception that all I/O operations shall be completed as defined for synchronized I/O data
integrity completion.
RETURN VALUE
If successful, the fdatasync() function shall return the value 0; otherwise, the function shall return the value -1 and
set errno to indicate the error. If the fdatasync() function fails, outstanding I/O operations are not guaranteed to
have been completed.
ERRORS
The fdatasync() function shall fail if:
[EBADF]
The fildes argument is not a valid file descriptor.
[EINVAL]
This implementation does not support synchronized I/O for this file.
In the event that any of the queued I/O operations fail, fdatasync() shall return the error conditions defined for
read() and write().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Note that even if the file descriptor is not open for writing, if there are any pending write requests on the underlying file,
then that I/O will be completed prior to the return of fdatasync().
An application that modifies a directory, for example, by creating a file in the directory, can invoke fdatasync() on the
directory to ensure that the directory's entries are synchronized, although for most applications this should not be necessary (see
XBD 4.11 File System Cache).
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
aio_fsync(), fcntl(), fsync(), open(), read(), write()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the
Synchronized Input and Output option.
The fdatasync() function is marked as part of the Synchronized Input and Output option.
Issue 7
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0110 [501] is applied.
Issue 8
Austin Group Defect 672 is applied, changing the APPLICATION USAGE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_getschedparam.html =====
pthread_getschedparam
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_getschedparam, pthread_setschedparam — dynamic thread scheduling parameters access (REALTIME
THREADS)
SYNOPSIS
[TPS]  #include
int pthread_getschedparam(pthread_t thread, int *restrict policy,
struct sched_param *restrict param);
int pthread_setschedparam(pthread_t thread, int policy,
const struct sched_param *param);
DESCRIPTION
The pthread_getschedparam() and pthread_setschedparam() functions shall, respectively, get and set the scheduling
policy and parameters of individual threads within a multi-threaded process to be retrieved and set. For SCHED_FIFO and SCHED_RR,
the only required member of the sched_param structure is the priority sched_priority. For SCHED_OTHER, the affected
scheduling parameters are implementation-defined.
The pthread_getschedparam() function shall retrieve the scheduling policy and scheduling parameters for the thread whose
thread ID is given by thread and shall store those values in policy and param, respectively. The priority
value returned from pthread_getschedparam() shall be the value specified by the most recent pthread_setschedparam(),
pthread_setschedprio(), or pthread_create() call affecting the target thread. It shall not reflect any temporary
adjustments to its priority as a result of any priority inheritance or ceiling functions. The pthread_setschedparam()
function shall set the scheduling policy and associated scheduling parameters for the thread whose thread ID is given by
thread to the policy and associated parameters provided in policy and param, respectively.
The policy parameter may have the value SCHED_OTHER, SCHED_FIFO, or SCHED_RR. The scheduling parameters for the
SCHED_OTHER policy are implementation-defined. The SCHED_FIFO and SCHED_RR policies shall have a single scheduling parameter,
priority.
[TSP]
If _POSIX_THREAD_SPORADIC_SERVER is defined, then the policy argument may have the value SCHED_SPORADIC, with the exception
for the pthread_setschedparam() function that if the scheduling policy was not SCHED_SPORADIC at the time of the call, it is
implementation-defined whether the function is supported; in other words, the implementation need not allow the application to
dynamically change the scheduling policy to SCHED_SPORADIC. The sporadic server scheduling policy has the associated parameters
sched_ss_low_priority, sched_ss_repl_period, sched_ss_init_budget, sched_priority, and
sched_ss_max_repl. The specified sched_ss_repl_period shall be greater than or equal to the specified
sched_ss_init_budget for the function to succeed; if it is not, then the function shall fail. The value of
sched_ss_max_repl shall be within the inclusive range [1,{SS_REPL_MAX}] for the function to succeed; if not, the function
shall fail. It is unspecified whether the sched_ss_repl_period and sched_ss_init_budget values are stored as provided
by this function or are rounded to align with the resolution of the clock being used.
If the pthread_setschedparam() function fails, the scheduling parameters shall not be changed for the target thread.
RETURN VALUE
If successful, the pthread_getschedparam() and pthread_setschedparam() functions shall return zero; otherwise, an
error number shall be returned to indicate the error.
ERRORS
The pthread_setschedparam() function shall fail if:
[ENOTSUP]
An attempt was made to set the policy or scheduling parameters to an unsupported value.
[ENOTSUP]
[TSP]
An attempt was made to dynamically change the scheduling policy to SCHED_SPORADIC, and the implementation does not support this
change.
The pthread_setschedparam() function may fail if:
[EINVAL]
The value specified by policy or one of the scheduling parameters associated with the scheduling policy policy is
invalid.
[EPERM]
The caller does not have appropriate privileges to set either the scheduling parameters or the scheduling policy of the
specified thread.
[EPERM]
The implementation does not allow the application to modify one of the parameters to the value specified.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
If an implementation detects use of a thread ID after the end of its lifetime, it is recommended that the function should fail
and report an [ESRCH] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_setschedprio(), sched_getparam(), sched_getscheduler()
XBD ,
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_getschedparam() and pthread_setschedparam() functions are marked as part of the Threads and Thread
Execution Scheduling options.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Thread
Execution Scheduling option.
The Open Group Corrigendum U026/2 is applied, correcting the prototype for the pthread_setschedparam() function so that
its second argument is of type int.
The SCHED_SPORADIC scheduling policy is added for alignment with IEEE Std 1003.1d-1999.
The restrict keyword is added to the pthread_getschedparam() prototype for alignment with the
ISO/IEC 9899:1999 standard.
The Open Group Corrigendum U047/1 is applied.
IEEE PASC Interpretation 1003.1 #96 is applied, noting that priority values can also be set by a call to the pthread_setschedprio() function.
Issue 7
The pthread_getschedparam() and pthread_setschedparam() functions are marked only as part of the Thread Execution
Scheduling option as the Threads option is now part of the Base.
Austin Group Interpretation 1003.1-2001 #119 is applied, clarifying the accuracy requirements for the
sched_ss_repl_period and sched_ss_init_budget values.
Austin Group Interpretation 1003.1-2001 #142 is applied, removing the [ESRCH] error condition.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0459 [314] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0276 [757] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sigpending.html =====
sigpending
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sigpending — examine pending signals
SYNOPSIS
[CX]  #include
int sigpending(sigset_t *set);
DESCRIPTION
The sigpending() function shall store, in the location referenced by the set argument, the set of signals that are
blocked from delivery to the calling thread and that are pending on the process or the calling thread.
RETURN VALUE
Upon successful completion, sigpending() shall return 0; otherwise, -1 shall be returned and errno set to indicate
the error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
exec, pthread_sigmask(), sigaddset(),
sigdelset(), sigemptyset(),
sigfillset(), sigismember()
XBD
CHANGE HISTORY
First released in Issue 3.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Threads Extension.
Issue 6
The SYNOPSIS is marked CX since the presence of this function in the  header is an extension over the ISO C standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/vprintf.html =====
vfprintf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
vasprintf, vdprintf, vfprintf, vprintf, vsnprintf, vsprintf — format output of a stdarg argument list
SYNOPSIS
#include
#include
[CX]  int vasprintf(char **restrict ptr, const char *restrict format,
va_list ap);
int vdprintf(int fildes, const char *restrict format, va_list ap);
int vfprintf(FILE *restrict stream, const char *restrict format,
va_list ap);
int vprintf(const char *restrict format, va_list ap);
int vsnprintf(char *restrict s, size_t n, const char *restrict format,
va_list ap);
int vsprintf(char *restrict s, const char *restrict format, va_list
ap);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The [CX]
vasprintf(), vdprintf(),  vfprintf(),
vprintf(), vsnprintf(), and vsprintf() functions shall be equivalent to the [CX]  asprintf(), dprintf(),  fprintf(), printf(), snprintf(), and sprintf() functions respectively, except that instead of being called with a variable number
of arguments, they are called with an argument list as defined by .
These functions shall not invoke the va_end macro. As these functions invoke the va_arg macro, the value of
ap after the return is unspecified.
RETURN VALUE
Refer to fprintf().
ERRORS
Refer to fprintf().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications using these functions should call va_end(ap) afterwards to clean up.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fprintf()
XBD ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The vsnprintf() function is added.
Issue 6
The vfprintf(), vprintf(), vsnprintf(), and vsprintf() functions are updated for alignment with the
ISO/IEC 9899:1999 standard.
Issue 7
The vdprintf() function is added to complement the dprintf() function from
The Open Group Technical Standard, 2006, Extended API Set Part 1.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0703 [14] is applied.
Issue 8
Austin Group Defect 1496 is applied, adding the vasprintf() function.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/tgammaf.html =====
tgamma
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
tgamma, tgammaf, tgammal — compute gamma() function
SYNOPSIS
#include
double tgamma(double x);
float tgammaf(float x);
long double tgammal(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute Γ(x) where Γ(x) is defined as
\(\int_0^{\infty} e^{-t} t^{x-1} d t\)
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the gamma of x.
If x is a negative integer, either a domain error or a pole error may occur and either a NaN (if supported) or ±Inf (if
supported), respectively, or an implementation-defined value shall be returned. [MX]   On systems
that support the IEC 60559 Floating-Point option, a domain error shall occur and a NaN shall be returned.
If x is ±0, tgamma(), tgammaf(), and tgammal() shall return ±HUGE_VAL, ±HUGE_VALF, and ±HUGE_VALL,
respectively. [MX]   On systems that support the IEC 60559 Floating-Point option, a pole error shall occur;   otherwise, a [CX]
pole  error may occur.
If the correct value would cause overflow, a range error shall occur and tgamma(), tgammaf(), and tgammal()
shall return ±HUGE_VAL, ±HUGE_VALF, or ±HUGE_VALL, respectively, with the same sign as the correct value of the function.
If the correct value would cause underflow, [MXX]   and is not representable,   a range error may occur, and tgamma(), tgammaf(), and tgammal() shall return
[MXX]
0.0, or   (if IEC 60559 Floating-Point is not supported)
an implementation-defined value no greater in magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
[MXX]
If the correct value would cause underflow, and is representable, a range error may occur and the correct value shall be
returned.
If x is subnormal and 1/ x is representable, 1/ x should be returned.
[MX]  If
x is NaN, a NaN shall be returned.
If x is +Inf, x shall be returned.
If x is -Inf, a domain error shall occur, and a NaN shall be returned.
ERRORS
These functions shall fail if:
Domain Error
[MX]
The value of x is a negative integer, or x is -Inf.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If
the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall
be raised.
Pole Error
[MX]
The value of x is zero.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If
the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the divide-by-zero floating-point exception
shall be raised.
Range Error
The value overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If
the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall
be raised.
These functions may fail if:
Domain Error
The value of x is a negative integer.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If
the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall
be raised.
Pole Error
The value of x is zero or a negative integer.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If
the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the divide-by-zero floating-point exception
shall be raised.
Range Error
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If
the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception
shall be raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are
independent of each other, but at least one of them must be non-zero.
RATIONALE
This function is named tgamma() in order to avoid conflicts with the historical gamma() and lgamma() functions.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept, fetestexcept, lgamma
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/65 is applied, correcting the third paragraph in the RETURN
VALUE section.
Issue 7
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #52 (SD5-XSH-ERN-85) is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0660 [68], XSH/TC1-2008/0661 [320], and XSH/TC1-2008/0662 [68] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0367 [604] and XSH/TC2-2008/0368 [630] are applied.
Issue 8
Austin Group Defect 1461 is applied, changing the requirements for a negative integer argument to match the ISO C
standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcsstr.html =====
wcsstr
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcsstr — find a wide-character substring
SYNOPSIS
#include
wchar_t *wcsstr(const wchar_t *restrict ws1,
const wchar_t *restrict ws2);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The wcsstr() function shall locate the first occurrence in the wide-character string pointed to by ws1 of the
sequence of wide characters (excluding the terminating null wide character) in the wide-character string pointed to by
ws2.
[CX]  The
wcsstr() function shall not change the setting of errno on valid input.
RETURN VALUE
Upon successful completion, wcsstr() shall return a pointer to the located wide-character string, or a null pointer if
the wide-character string is not found.
If ws2 points to a wide-character string with zero length, the function shall return ws1.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
wcschr()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E).
Issue 6
The wcsstr() prototype is updated for alignment with the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that wcsstr() does not change the setting of errno on
valid input.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pause.html =====
pause
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pause — suspend the thread until a signal is received
SYNOPSIS
#include
int pause(void);
DESCRIPTION
The pause() function shall suspend the calling thread until delivery of a signal whose action is either to execute a
signal-catching function or to terminate the process.
If the action is to terminate the process, pause() shall not return.
If the action is to execute a signal-catching function, pause() shall return after the signal-catching function
returns.
RETURN VALUE
Since pause() suspends thread execution indefinitely unless interrupted by a signal, there is no successful completion
return value. A value of -1 shall be returned and errno set to indicate the error.
ERRORS
The pause() function shall fail if:
[EINTR]
A signal is caught by the calling process and control is returned from the signal-catching function.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Many common uses of pause() have timing windows. The scenario involves checking a condition related to a signal and, if
the signal has not occurred, calling pause(). When the signal occurs between the check and the call to pause(), the
process often blocks indefinitely. The sigprocmask() and sigsuspend() functions can be used to avoid this type of problem.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
sigsuspend()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Threads Extension.
Issue 6
The APPLICATION USAGE section is added.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/isxdigit.html =====
isxdigit
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
isxdigit, isxdigit_l — test for a hexadecimal digit
SYNOPSIS
#include
int isxdigit(int c);
[CX]  int isxdigit_l(int c, locale_t locale);
DESCRIPTION
For isxdigit(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The isxdigit() [CX]   and isxdigit_l()
functions shall test whether c is a character of class xdigit in the current locale, [CX]   or in the
locale represented by locale,  respectively; see XBD 7. Locale.
The c argument is an int, the value of which the application shall ensure is a character representable as an
unsigned char or equal to the value of the macro EOF. If the argument has any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to isxdigit_l() is the special locale object LC_GLOBAL_LOCALE or is not
a valid locale object handle.
RETURN VALUE
The isxdigit() [CX]   and isxdigit_l()
functions shall return non-zero if c is a hexadecimal digit; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
isalnum(), isalpha(), isblank(), iscntrl(), isdigit(), isgraph(), islower(), isprint(), ispunct(), isspace(), isupper()
XBD 7. Locale,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The isxdigit_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0347 [302], XSH/TC1-2008/0348 [283], and XSH/TC1-2008/0349 [283] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/lseek.html =====
lseek
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
lseek — move the read/write file offset
SYNOPSIS
#include
off_t lseek(int fildes, off_t offset, int whence);
DESCRIPTION
The lseek() function shall set the file offset for the open file description associated with the file descriptor
fildes, as follows:
If whence is SEEK_SET, the file offset shall be set to offset bytes.
If whence is SEEK_CUR, the file offset shall be set to its current location plus offset.
If whence is SEEK_END, the file offset shall be set to the size of the file plus offset.
If whence is SEEK_HOLE, the file offset shall be set to the smallest location of a byte within a hole and not less than
offset, except that if offset falls beyond the last byte not within a hole, then the file offset may be set to the
file size instead. It shall be an error if offset is greater than or equal to the size of the file.
If whence is SEEK_DATA, the file offset shall be set to the smallest location of a byte not within a hole and not less
than offset. It shall be an error if no such byte exists.
The symbolic constants SEEK_SET, SEEK_CUR, SEEK_END, SEEK_HOLE, and SEEK_DATA are defined in .
A hole is a contiguous region of bytes within a file, all having the value of zero. Not all bytes with the value zero need
belong to a hole; however, all seekable files shall have a virtual hole starting at the current size of the file, whether or not
the file is sparse.
The behavior of lseek() on devices which are incapable of seeking is implementation-defined. The value of the file offset
associated with such a device is undefined.
The lseek() function shall allow the file offset to be set beyond the end of the existing data in the file. If data is
later written at this point, subsequent reads of data in the gap shall return bytes with the value 0 until data is actually written
into the gap.
The lseek() function shall not, by itself, extend the size of a file.
[SHM]
If fildes refers to a shared memory object, the result of the lseek() function is unspecified.
[TYM]
If fildes refers to a typed memory object, the result of the lseek() function is unspecified.
RETURN VALUE
Upon successful completion, the resulting offset, as measured in bytes from the beginning of the file, shall be returned.
Otherwise, -1 shall be returned, errno shall be set to indicate the error, and the file offset shall remain unchanged.
ERRORS
The lseek() function shall fail if:
[EBADF]
The fildes argument is not an open file descriptor.
[EINVAL]
The whence argument is not a proper value, or the resulting file offset would be negative for a regular file, block
special file, or directory.
[ENXIO]
The whence argument is SEEK_HOLE or SEEK_DATA, and offset is greater than or equal to the file size; or the
whence argument is SEEK_DATA and the offset falls beyond the last byte not within a hole.
[EOVERFLOW]
The resulting file offset would be a value which cannot be represented correctly in an object of type off_t.
[ESPIPE]
The fildes argument is associated with a pipe, FIFO, or socket.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The ISO C standard includes the functions fgetpos() and fsetpos(), which work on very large files by use of a special positioning type.
Although lseek() may position the file offset beyond the end of the file, this function does not itself extend the size
of the file. While the only function in POSIX.1-2024 that may directly extend the size of the file is write(), truncate(), and ftruncate(), several functions originally derived from the ISO C standard, such as
fwrite(), fprintf(), and so on, may do
so (by causing calls on write()).
An invalid file offset that would cause [EINVAL] to be returned may be both implementation-defined and device-dependent (for
example, memory may have few invalid values). A negative file offset may be valid for some devices in some implementations.
The POSIX.1-1990 standard did not specifically prohibit lseek() from returning a negative offset. Therefore, an
application was required to clear errno prior to the call and check errno upon return to determine whether a return
value of (off_t)-1 is a negative offset or an indication of an error condition. The standard developers did not wish to
require this action on the part of a conforming application, and chose to require that errno be set to [EINVAL] when the
resulting file offset would be negative for a regular file, block special file, or directory.
Not all file systems support holes, and even where sparse files are supported, not all contiguous blocks of zero bytes are
required to be recognized as a hole. However, since all files are required to have a virtual hole starting at the current file
size, application writers can use SEEK_HOLE and SEEK_DATA to optimize algorithms that can run faster when it is known that a block
of bytes is all zeros, because a non-sparse file will correctly report the entire file as a single non-hole. A trivial recursive
implementation for these two constants would be as follows, however, for file systems that support sparse files, implementations
are encouraged to do better.
off_t lseek(int fildes, off_t offset, int whence)
{
off_t cur, end;
switch (whence)
{
case SEEK_HOLE:
case SEEK_DATA:
cur = lseek(fildes, 0, SEEK_CUR);
if (cur ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Realtime Extension.
Large File Summit extensions are added.
Issue 6
In the SYNOPSIS, the optional include of the  header is
removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
The [EOVERFLOW] error condition is added. This change is to support large files.
An additional [ESPIPE] error condition is added for sockets.
The DESCRIPTION is updated for alignment with IEEE Std 1003.1j-2000 by specifying that lseek() results are
unspecified for typed memory objects.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0366 [421] is applied.
Issue 8
Austin Group Defect 415 is applied, adding SEEK_HOLE and SEEK_DATA.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_key_create.html =====
pthread_key_create
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_key_create — thread-specific data key creation
SYNOPSIS
#include
int pthread_key_create(pthread_key_t *key, void (*destructor)(void*));
DESCRIPTION
The pthread_key_create() function shall create a thread-specific data key visible to all threads in the process. Key
values provided by pthread_key_create() are opaque objects used to locate thread-specific data. Although the same key value
may be used by different threads, the values bound to the key by pthread_setspecific() are maintained on a per-thread basis and persist for the
life of the calling thread.
Upon key creation, the value NULL shall be associated with the new key in all active threads. Upon thread creation, the value
NULL shall be associated with all defined keys in the new thread.
An optional destructor function may be associated with each key value. At thread exit, if a key value has a non-NULL destructor
pointer, and the thread has a non-NULL value associated with that key, the value of the key is set to NULL, and then the function
pointed to is called with the previously associated value as its sole argument. The order of destructor calls is unspecified if
more than one destructor exists for a thread when it exits.
If, after all the destructors have been called for all non-NULL values with associated destructors, there are still some
non-NULL values with associated destructors, then the process is repeated. If, after at least {PTHREAD_DESTRUCTOR_ITERATIONS}
iterations of destructor calls for outstanding non-NULL values, there are still some non-NULL values with associated destructors,
implementations may stop calling destructors, or they may continue calling destructors until no non-NULL values with associated
destructors exist, even though this might result in an infinite loop.
RETURN VALUE
If successful, the pthread_key_create() function shall store the newly created key value at *key and shall return
zero. Otherwise, an error number shall be returned to indicate the error.
ERRORS
The pthread_key_create() function shall fail if:
[EAGAIN]
The system lacked the necessary resources to create another thread-specific data key, or the system-imposed limit on the total
number of keys per process {PTHREAD_KEYS_MAX} has been exceeded.
[ENOMEM]
Insufficient memory exists to create the key.
The pthread_key_create() function shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
The following example demonstrates a function that initializes a thread-specific data key when it is first called, and
associates a thread-specific object with each calling thread, initializing this object when necessary.
static pthread_key_t key;
static pthread_once_t key_once = PTHREAD_ONCE_INIT;
static void
make_key()
{
(void) pthread_key_create(&key, NULL);
}
func()
{
void *ptr;
(void) pthread_once(&key_once, make_key);
if ((ptr = pthread_getspecific(key)) == NULL) {
ptr = malloc(OBJECT_SIZE);
...
(void) pthread_setspecific(key, ptr);
}
...
}
Note that the key has to be initialized before pthread_getspecific()
or pthread_setspecific() can be used. The pthread_key_create()
call could either be explicitly made in a module initialization routine, or it can be done implicitly by the first call to a module
as in this example. Any attempt to use the key before it is initialized is a programming error, making the code below
incorrect.
static pthread_key_t key;
func()
{
void *ptr;
/* KEY NOT INITIALIZED!!!  THIS WILL NOT WORK!!! */
if ((ptr = pthread_getspecific(key)) == NULL &&
pthread_setspecific(key, NULL) != 0) {
pthread_key_create(&key, NULL);
...
}
}
APPLICATION USAGE
None.
RATIONALE
Destructor Functions
Normally, the value bound to a key on behalf of a particular thread is a pointer to storage allocated dynamically on behalf of
the calling thread. The destructor functions specified with pthread_key_create() are intended to be used to free this
storage when the thread exits. Thread cancellation cleanup handlers cannot be used for this purpose because thread-specific data
may persist outside the lexical scope in which the cancellation cleanup handlers operate.
If the value associated with a key needs to be updated during the lifetime of the thread, it may be necessary to release the
storage associated with the old value before the new value is bound. Although the pthread_setspecific() function could do this automatically, this feature is not
needed often enough to justify the added complexity. Instead, the programmer is responsible for freeing the stale storage:
old = pthread_getspecific(key);
new = allocate();
destructor(old);
pthread_setspecific(key, new);
Note:
The above example could leak storage if run with asynchronous cancellation enabled. No such problems occur in the default
cancellation state if no cancellation points occur between the get and set.
There is no notion of a destructor-safe function. If an application does not call pthread_exit() from a signal handler, or if it blocks any signal whose handler may call
pthread_exit() while calling async-unsafe functions, all functions may be
safely called from destructors.
Non-Idempotent Data Key Creation
There were requests to make pthread_key_create() idempotent with respect to a given key address parameter. This
would allow applications to call pthread_key_create() multiple times for a given key address and be guaranteed that
only one key would be created. Doing so would require the key value to be previously initialized (possibly at compile time) to a
known null value and would require that implicit mutual-exclusion be performed based on the address and contents of the key
parameter in order to guarantee that exactly one key would be created.
Unfortunately, the implicit mutual-exclusion would not be limited to only pthread_key_create(). On many implementations,
implicit mutual-exclusion would also have to be performed by pthread_getspecific() and pthread_setspecific() in order to guard against using incompletely stored or
not-yet-visible key values. This could significantly increase the cost of important operations, particularly pthread_getspecific().
Thus, this proposal was rejected. The pthread_key_create() function performs no implicit synchronization. It is the
responsibility of the programmer to ensure that it is called exactly once per key before use of the key. Several straightforward
mechanisms can already be used to accomplish this, including calling explicit module initialization functions, using mutexes, and
using pthread_once(). This places no significant burden on the programmer,
introduces no possibly confusing ad hoc implicit synchronization mechanism, and potentially allows commonly used
thread-specific data operations to be more efficient.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_getspecific(), pthread_key_delete()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_key_create() function is marked as part of the Threads option.
IEEE PASC Interpretation 1003.1c #8 is applied, updating the DESCRIPTION.
Issue 7
The pthread_key_create() function is moved from the Threads option to the Base.
Issue 8
Austin Group Defect 1059 is applied, changing the example code in the RATIONALE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_attr_setinheritsched.html =====
pthread_attr_getinheritsched
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_attr_getinheritsched, pthread_attr_setinheritsched — get and set the inheritsched attribute (REALTIME
THREADS)
SYNOPSIS
[TPS]  #include
int pthread_attr_getinheritsched(const pthread_attr_t *restrict attr,
int *restrict inheritsched);
int pthread_attr_setinheritsched(pthread_attr_t *attr,
int inheritsched);
DESCRIPTION
The pthread_attr_getinheritsched() and pthread_attr_setinheritsched() functions, respectively, shall get and set
the inheritsched attribute in the attr argument.
When the attributes objects are used by pthread_create(), the
inheritsched attribute determines how the other scheduling attributes of the created thread shall be set.
The supported values of inheritsched shall be:
PTHREAD_INHERIT_SCHED
Specifies that the thread scheduling attributes shall be inherited from the creating thread, and the scheduling attributes in this
attr argument shall be ignored.
PTHREAD_EXPLICIT_SCHED
Specifies that the thread scheduling attributes shall be set to the corresponding values from this attributes object.
The symbols PTHREAD_INHERIT_SCHED and PTHREAD_EXPLICIT_SCHED are defined in the  header.
The following thread scheduling attributes defined by POSIX.1-2024 are affected by the inheritsched attribute: scheduling
policy (schedpolicy), scheduling parameters (schedparam), and scheduling contention scope
(contentionscope).
The behavior is undefined if the value specified by the attr argument to pthread_attr_getinheritsched() or
pthread_attr_setinheritsched() does not refer to an initialized thread attributes object.
RETURN VALUE
If successful, the pthread_attr_getinheritsched() and pthread_attr_setinheritsched() functions shall return zero;
otherwise, an error number shall be returned to indicate the error.
ERRORS
The pthread_attr_setinheritsched() function shall fail if:
[ENOTSUP]
An attempt was made to set the attribute to an unsupported value.
The pthread_attr_setinheritsched() function may fail if:
[EINVAL]
The value of inheritsched is not valid.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
After these attributes have been set, a thread can be created with the specified attributes using pthread_create(). Using these routines does not affect the current running
thread.
See 2.9.4 Thread Scheduling for further details on thread
scheduling attributes and their default settings.
RATIONALE
If an implementation detects that the value specified by the attr argument to pthread_attr_getinheritsched() or
pthread_attr_setinheritsched() does not refer to an initialized thread attributes object, it is recommended that the
function should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_attr_destroy(), pthread_attr_getscope(), pthread_attr_getschedpolicy(), pthread_attr_getschedparam(), pthread_create()
XBD ,
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Marked as part of the Realtime Threads Feature Group.
Issue 6
The pthread_attr_getinheritsched() and pthread_attr_setinheritsched() functions are marked as part of the Threads
and Thread Execution Scheduling options.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Thread
Execution Scheduling option.
The restrict keyword is added to the pthread_attr_getinheritsched() prototype for alignment with the
ISO/IEC 9899:1999 standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/75 is applied, clarifying the values of inheritsched in
the DESCRIPTION and adding two optional [EINVAL] errors to the ERRORS section for checking when attr refers to an
uninitialized thread attribute object.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/77 is applied, adding a reference to 2.9.4 Thread Scheduling in the APPLICATION USAGE section.
Issue 7
The pthread_attr_getinheritsched() and pthread_attr_setinheritsched() functions are marked only as part of the
Thread Execution Scheduling option as the Threads option is now part of the Base.
The [EINVAL] error for an uninitialized thread attributes object is removed; this condition results in undefined behavior.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0450 [314] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0262 [757] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/htobe64.html =====
be16toh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
be16toh, be32toh, be64toh, htobe16, htobe32, htobe64, htole16, htole32, htole64, le16toh, le32toh, le64toh — convert
values between host and specified byte order
SYNOPSIS
#include
uint16_t be16toh(uint16_t big_endian_16bits);
uint32_t be32toh(uint32_t big_endian_32bits);
uint64_t be64toh(uint64_t big_endian_64bits);
uint16_t htobe16(uint16_t host_16bits);
uint32_t htobe32(uint32_t host_32bits);
uint64_t htobe64(uint64_t host_64bits);
uint16_t htole16(uint16_t host_16bits);
uint32_t htole32(uint32_t host_32bits);
uint64_t htole64(uint64_t host_64bits);
uint16_t le16toh(uint16_t little_endian_16bits);
uint32_t le32toh(uint32_t little_endian_32bits);
uint64_t le64toh(uint64_t little_endian_64bits);
DESCRIPTION
These functions shall convert integer values of various sizes between host representations and representations in a specified
order.
On some implementations, these functions are defined as macros.
A little-endian representation of an integer has the least significant byte stored as the first byte, with the significance of
the bytes increasing as the byte address increases. A big-endian representation has the most significant byte as the first byte,
with the significance of the bytes reducing as the byte address increases.
Note:
Network byte order is big-endian.
For example, the uint32_t value 0x01020304 is represented as the four bytes 0x04, 0x03, 0x02, 0x01 on a little-endian
host, and as 0x01, 0x02, 0x03, 0x04 on a big-endian host.
For each of the sizes 16, 32 and 64, the htobeSIZE() function shall convert from whatever order the host uses to
big-endian representation, htoleSIZE() shall convert to little-endian representation, beSIZEtoh() shall convert from
big-endian to host order, and leSIZEtoh() shall convert from little-endian to host order.
RETURN VALUE
These functions shall return an unsigned integer of the appropriate size and representation.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
#include
#include
#include
int main(int argc, char *argv[])
{
uint32_t val;
if (argc > 1) {
val = (uint32_t)strtoul(argv[1], NULL, 0);
printf("Value: %08x\n", val);
printf("As bytes:\n");
union {
uint32_t asint;
unsigned char asbytes[sizeof(uint32_t)];
} u;
printf("Little endian: ");
u.asint = htole32(val);
for (int i = 0; i  is included:
htobe32
htonl
htobe16
htons
be32toh
ntohl
be16toh
ntohs
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
htonl()
XBD ,
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/tcgetattr.html =====
tcgetattr
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
tcgetattr — get the parameters associated with the terminal
SYNOPSIS
#include
int tcgetattr(int fildes, struct termios *termios_p);
DESCRIPTION
The tcgetattr() function shall get the parameters associated with the terminal referred to by fildes and store
them in the termios structure referenced by termios_p. The fildes argument is an open file descriptor
associated with a terminal.
The termios_p argument is a pointer to a termios structure.
The tcgetattr() operation is allowed from any process.
If the terminal device supports different input and output baud rates, the baud rates stored in the termios structure
returned by tcgetattr() shall reflect the actual baud rates, even if they are equal. If differing baud rates are not
supported, the rate returned as the output baud rate shall be the actual baud rate. If the terminal device does not support split
baud rates, the input baud rate stored in the termios structure shall be the output rate (as one of the symbolic
values).
RETURN VALUE
Upon successful completion, 0 shall be returned. Otherwise, -1 shall be returned and errno set to indicate the error.
ERRORS
The tcgetattr() function shall fail if:
[EBADF]
The fildes argument is not a valid file descriptor.
[ENOTTY]
The file associated with fildes is not a terminal.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
Care must be taken when changing the terminal attributes. Applications should always do a tcgetattr(), save the
termios structure values returned, and then do a tcsetattr(), changing only
the necessary fields. The application should use the values saved from the tcgetattr() to reset the terminal state whenever
it is done with the terminal. This is necessary because terminal attributes apply to the underlying port and not to each individual
open instance; that is, all processes that have used the terminal see the latest attribute changes.
A program that uses these functions should be written to catch all signals and take other appropriate actions to ensure that
when the program terminates, whether planned or not, the terminal device's state is restored to its original state.
Existing practice dealing with error returns when only part of a request can be honored is based on calls to the ioctl()
function. In historical BSD and System V implementations, the corresponding ioctl() returns zero if the requested actions
were semantically correct, even if some of the requested changes could not be made. Many existing applications assume this behavior
and would no longer work correctly if the return value were changed from zero to -1 in this case.
Note that either specification has a problem. When zero is returned, it implies everything succeeded even if some of the changes
were not made. When -1 is returned, it implies everything failed even though some of the changes were made.
Applications that need all of the requested changes made to work properly should follow tcsetattr() with a call to tcgetattr() and compare the appropriate field
values.
FUTURE DIRECTIONS
None.
SEE ALSO
tcsetattr()
XBD 11. General Terminal Interface,
CHANGE HISTORY
First released in Issue 3. Included for alignment with the POSIX.1-1988 standard.
Issue 6
In the DESCRIPTION, the rate returned as the input baud rate shall be the output rate. Previously, the number zero was also
allowed but was obsolescent.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atan.html =====
atan
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atan, atanf, atanl — arc tangent function
SYNOPSIS
#include
double atan(double x);
float atanf(float x);
long double atanl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the principal value of the arc tangent of their argument x.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the arc tangent of x in the range [-ℼ/2,ℼ/2] radians.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, x shall be returned.
If x is ±Inf, ±ℼ/2 shall be returned.
[MXX]
If x is subnormal, x should be returned.
[MX]  If x is subnormal, a range error may occur and, if x is
not returned, atan(), atanf(), and atanl() shall return an implementation-defined value no greater in
magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
ERRORS
These functions may fail if:
Range Error
[MX]
The value of x is subnormal.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
atan2(), feclearexcept(),
fetestexcept(), isnan(),
tan()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The atanf() and atanl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0037 [68] is applied.
Issue 8
Austin Group Defect 1382 is applied, rearranging the text describing the behavior when x is subnormal to avoid the need
for two shading changes.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/lroundf.html =====
lround
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
lround, lroundf, lroundl — round to nearest integer value
SYNOPSIS
#include
long lround(double x);
long lroundf(float x);
long lroundl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall round their argument to the nearest integer value, rounding halfway cases away from zero, regardless of
the current rounding direction.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the rounded integer value.
[MX]  If
x is NaN, a domain error shall occur and an unspecified value is returned.
If x is +Inf, a domain error shall occur and an unspecified value is returned.
If x is -Inf, a domain error shall occur and an unspecified value is returned.
If the correct value is positive and too large to represent as a long, an unspecified value shall be returned.
[MX]
On systems that support the IEC 60559 Floating-Point option, a domain shall occur;  otherwise, a [CX]   domain  error may occur.
If the correct value is negative and too large to represent as a long, an unspecified value shall be returned.
[MX]
On systems that support the IEC 60559 Floating-Point option, a domain shall occur;  otherwise, a [CX]   domain  error may occur.
ERRORS
These functions shall fail if:
Domain Error
[MX]
The x argument is NaN or ±Inf, or the correct value is not representable as an integer.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
These functions may fail if:
Domain Error
The correct value is not representable as an integer.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
These functions differ from the lrint() functions in the default rounding
direction, with the lround() functions rounding halfway cases away from zero and needing not to raise the inexact
floating-point exception for non-integer arguments that round to within the range of the return type.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), llround()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #54 (SD5-XSH-ERN-78) is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/readlink.html =====
readlink
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
readlink, readlinkat — read the contents of a symbolic link
SYNOPSIS
#include
ssize_t readlink(const char *restrict path, char *restrict buf,
size_t bufsize);
[OH] #include
ssize_t readlinkat(int fd, const char *restrict path,
char *restrict buf, size_t bufsize);
DESCRIPTION
The readlink() function shall place the contents of the symbolic link referred to by path in the buffer buf
which has size bufsize. If the number of bytes in the symbolic link is less than bufsize, the contents of the
remainder of buf are unspecified. If the buf argument is not large enough to contain the link content, the first
bufsize bytes shall be placed in buf.
If the value of bufsize is greater than {SSIZE_MAX}, the result is implementation-defined.
Upon successful completion, readlink() shall mark for update the last data access timestamp of the symbolic link.
The readlinkat() function shall be equivalent to the readlink() function except in the case where path
specifies a relative path. In this case the symbolic link whose content is read is relative to the directory associated with the
file descriptor fd instead of the current working directory. If the access mode of the open file description associated with
the file descriptor is not O_SEARCH, the function shall check whether directory searches are permitted using the current
permissions of the directory underlying the file descriptor. If the access mode is O_SEARCH, the function shall not perform the
check.
If readlinkat() is passed the special value AT_FDCWD in the fd parameter, the current working directory shall be
used and the behavior shall be identical to a call to readlink().
RETURN VALUE
Upon successful completion, these functions shall return the count of bytes placed in the buffer. Otherwise, these functions
shall return a value of -1, leave the buffer unchanged, and set errno to indicate the error.
ERRORS
These functions shall fail if:
[EACCES]
Search permission is denied for a component of the path prefix of path.
[EINVAL]
The path argument names a file that is not a symbolic link.
[EIO]
An I/O error occurred while reading from the file system.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of path does not name an existing file or path is an empty string.
[ENOTDIR]
A component of the path prefix names an existing file that is neither a directory nor a symbolic link to a directory, or the
path argument contains at least one non- character and ends with one or more trailing  characters
and the last pathname component names an existing file that is neither a directory nor a symbolic link to a directory.
The readlinkat() function shall fail if:
[EACCES]
The access mode of the open file description associated with fd is not O_SEARCH and the permissions of the directory
underlying fd do not permit directory searches.
[EBADF]
The path argument does not specify an absolute path and the fd argument is neither AT_FDCWD nor a valid file
descriptor open for reading or searching.
[ENOTDIR]
The path argument is not an absolute path and fd is a file descriptor associated with a non-directory file.
These functions may fail if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
The following sections are informative.
EXAMPLES
Reading the Name of a Symbolic Link
The following example shows how to read the name of a symbolic link named /modules/pass1.
#include
char buf[1024];
ssize_t len;
...
if ((len = readlink("/modules/pass1", buf, sizeof(buf)-1)) != -1)
buf[len] = '\0';
APPLICATION USAGE
Conforming applications should not assume that the returned contents of the symbolic link are null-terminated.
RATIONALE
The type associated with bufsiz is a size_t in order to be consistent with both the ISO C standard and the
definition of read(). The behavior specified for readlink() when bufsiz
is zero represents historical practice. For this case, the standard developers considered a change whereby readlink() would
return the number of non-null bytes contained in the symbolic link with the buffer buf remaining unchanged; however, since
the stat structure member st_size value can be used to determine the size of buffer necessary to contain the contents
of the symbolic link as returned by readlink(), this proposal was rejected, and the historical practice retained.
The purpose of the readlinkat() function is to read the content of symbolic links in directories other than the current
working directory without exposure to race conditions. Any part of the path of a file could be changed in parallel to a call to
readlink(), resulting in unspecified behavior. By opening a file descriptor for the target directory and using the
readlinkat() function it can be guaranteed that the symbolic link read is located relative to the desired directory.
FUTURE DIRECTIONS
None.
SEE ALSO
fstatat(), symlink()
XBD ,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The return type is changed to ssize_t, to align with the IEEE P1003.1a draft standard.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
This function is made mandatory.
In this function it is possible for the return value to exceed the range of the type ssize_t (since size_t has a
larger range of positive values than ssize_t). A sentence restricting the size of the size_t object is added to the
description to resolve this conflict.
The following changes are made for alignment with the ISO POSIX-1:1996 standard:
The FUTURE DIRECTIONS section is changed to None.
The following changes were made to align with the IEEE P1003.1a draft standard:
The [ELOOP] optional error condition is added.
The restrict keyword is added to the readlink() prototype for alignment with the ISO/IEC 9899:1999
standard.
Issue 7
Austin Group Interpretation 1003.1-2001 #143 is applied.
SD5-XSH-ERN-189 is applied, updating the ERRORS section.
The readlinkat() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 2.
The [EACCES] error is removed from the "may fail" error conditions.
Changes are made to allow a directory to be opened for searching.
The [ENOTDIR] error condition is clarified to cover the condition where the last component of a pathname exists but is not a
directory or a symbolic link to a directory.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0487 [120], XSH/TC1-2008/0488 [461], XSH/TC1-2008/0489 [143],
XSH/TC1-2008/0490 [324], XSH/TC1-2008/0491 [278], XSH/TC1-2008/0492 [278], XSH/TC1-2008/0493 [455], and XSH/TC1-2008/0494 [151,231]
are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0305 [591], XSH/TC2-2008/0306 [817], XSH/TC2-2008/0307 [817], and
XSH/TC2-2008/0308 [591] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/snprintf.html =====
fprintf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
asprintf, dprintf, fprintf, printf, snprintf, sprintf — print formatted output
SYNOPSIS
#include
[CX]  int asprintf(char **restrict ptr, const char *restrict format,
...);
int dprintf(int fildes, const char *restrict format, ...);
int fprintf(FILE *restrict stream, const char *restrict format, ...);
int printf(const char *restrict format, ...);
int snprintf(char *restrict s, size_t n,
const char *restrict format, ...);
int sprintf(char *restrict s, const char *restrict format, ...);
DESCRIPTION
[CX]  Except for asprintf(), dprintf(), and the behavior of the %lc conversion when passed a null wide
character, the functionality described on this reference page is aligned with the ISO C standard. Any other conflict between
the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard for all fprintf(), printf(), snprintf(), and sprintf() functionality except in relation to the
%lc conversion when passed a null wide character.
The fprintf() function shall place output on the named output stream. The printf() function shall place
output on the standard output stream stdout. The sprintf() function shall place output followed by the null byte,
'\0', in consecutive bytes starting at *s; it is the user's responsibility to ensure that enough space is
available.
[CX]  The
asprintf() function shall be equivalent to sprintf(), except that the output string shall be written to dynamically
allocated memory, allocated as if by a call to malloc(), of sufficient length to hold
the resulting string, including a terminating null byte. If the call to asprintf() is successful, the address of this
dynamically allocated string shall be stored in the location referenced by ptr.
The dprintf() function shall be equivalent to the fprintf() function, except that dprintf() shall write
output to the file associated with the file descriptor specified by the fildes argument rather than place output on a
stream.
The snprintf() function shall be equivalent to sprintf(), with the addition of the n argument which limits
the number of bytes written to the buffer referred to by s. If n is zero, nothing shall be written and s may
be a null pointer. Otherwise, output bytes beyond the n-1st shall be discarded instead of being written to the array, and a
null byte is written at the end of the bytes actually written into the array.
If copying takes place between objects that overlap as a result of a call to sprintf() or snprintf(), the results
are undefined.
Each of these functions converts, formats, and prints its arguments under control of the format. The application shall
ensure that the format is a character string, beginning and ending in its initial shift state, if any. The format is composed of
zero or more directives: ordinary characters, which are simply copied to the output stream, and conversion
specifications, each of which shall result in the fetching of zero or more arguments. The results are undefined if there are
insufficient arguments for the format. If the format is exhausted while arguments remain, the excess arguments shall be evaluated
but are otherwise ignored.
[CX]
Conversions can be applied to the nth argument after the format in the argument list, rather than to the next unused
argument. In this case, the conversion specifier character % (see below) is replaced by the sequence
"%n$", where n is a decimal integer in the range [1,{NL_ARGMAX}], giving the position of the
argument in the argument list. This feature provides for the definition of format strings that select arguments in an order
appropriate to specific languages (see the EXAMPLES section).
The format can contain either numbered argument conversion specifications (that is, those introduced by
"%n$" and optionally containing the "*m$" forms of field width and precision), or
unnumbered argument conversion specifications (that is, those introduced by the % character and optionally containing the
* form of field width and precision), but not both. The only exception to this is that %% can be mixed with the
"%n$" form. The results of mixing numbered and unnumbered argument specifications in a format string are
undefined. When numbered argument specifications are used, specifying the Nth argument requires that all the leading
arguments, from the first to the (N-1)th, are specified in the format string.
In format strings containing the "%n$" form of conversion specification, numbered arguments in the
argument list can be referenced from the format string as many times as required.
In format strings containing the % form of conversion specification, each conversion specification uses the first
unused argument in the argument list.
[CX]  All
forms of the fprintf() functions allow for the insertion of a language-dependent radix character in the output string. The
radix character is defined in the current locale (category LC_NUMERIC ). In the POSIX locale, or in a locale where the radix
character is not defined, the radix character shall default to a  ('.').
Each conversion specification is introduced by the '%' character [CX]   or by the
character sequence "%n$",   after
which the following appear in sequence:
Zero or more flags (in any order), which modify the meaning of the conversion specification.
An optional minimum field width. If the converted value has fewer bytes than the field width, it shall be padded with
characters by default on the left; it shall be padded on the right if the left-adjustment flag ('-'),
described below, is given to the field width. The field width takes the form of an  ('*'), [CX]   or in
conversion specifications introduced by "%n$" the "*m$" string,  described below, or a decimal integer.
An optional precision that gives the minimum number of digits to appear for the d, i, o,
u, x, and X conversion specifiers; the number of digits to appear after the radix character for the
a, A, e, E, f, and F conversion specifiers; the maximum number of significant
digits for the g and G conversion specifiers; or the maximum number of bytes to be printed from a string in the
s [XSI]   and S   conversion specifiers. The
precision takes the form of a  ('.') followed either by an  ('*'), [CX]   or in
conversion specifications introduced by "%n$" the "*m$" string,  described below, or an optional decimal digit string, where a null digit
string is treated as zero. If a precision appears with any other conversion specifier, the behavior is undefined.
An optional length modifier that specifies the size of the argument.
A conversion specifier character that indicates the type of conversion to be applied.
A field width, or precision, or both, may be indicated by an  ('*'). In this case an argument of type
int supplies the field width or precision. Applications shall ensure that arguments specifying field width, or precision, or
both appear in that order before the argument, if any, to be converted. A negative field width is taken as a '-' flag
followed by a positive field width. A negative precision is taken as if the precision were omitted. [CX]   In format
strings containing conversion specifications introduced by "%n$", in addition to being indicated by the
decimal digit string, a field width may be indicated by the sequence "*m$" and precision by the sequence
".*m$", where m is a decimal integer in the range [1,{NL_ARGMAX}] giving the position in the
argument list (after the format argument) of an integer argument containing the field width or precision, for example:
printf("%1$d:%2$.*3$d:%4$.*3$d\n", hour, min, precision, sec);
The flag characters and their meanings are:
'
[CX]
(The .) The integer portion of the result of a decimal conversion (%i, %d, %u,
%f, %F, %g, or %G) shall be formatted with thousands' grouping characters. For other
conversions the behavior is undefined. The non-monetary grouping character is used.
-
The result of the conversion shall be left-justified within the field. The conversion is right-justified if this flag is not
specified.
+
The result of a signed conversion shall always begin with a sign ('+' or '-'). The conversion shall begin
with a sign only when a negative value is converted if this flag is not specified.
If the first character of a signed conversion is not a sign or if a signed conversion results in no characters, a
shall be prefixed to the result. This means that if the  and '+' flags both appear, the  flag
shall be ignored.
#
Specifies that the value is to be converted to an alternative form. For o conversion, it shall increase the precision,
if and only if necessary, to force the first digit of the result to be a zero (if the value and precision are both 0, a single 0 is
printed). For x or X conversion specifiers, a non-zero result shall have 0x (or 0X) prefixed to it. For
a, A, e, E, f, F, g, and G conversion specifiers, the
result shall always contain a radix character, even if no digits follow the radix character. Without this flag, a radix character
appears in the result of these conversions only if a digit follows it. For g and G conversion specifiers,
trailing zeros shall not be removed from the result as they normally are. For other conversion specifiers, the behavior is
undefined.
0
For d, i, o, u, x, X, a, A, e, E,
f, F, g, and G conversion specifiers, leading zeros (following any indication of sign or base)
are used to pad to the field width rather than performing space padding, except when converting an infinity or NaN. If the
'0' and '-' flags both appear, the '0' flag is ignored. For d, i, o,
u, x, and X conversion specifiers, if a precision is specified, the '0' flag shall be ignored.
[CX]
If the '0' and  flags both appear, the grouping characters are inserted before zero padding. For
other conversions, the behavior is undefined.
The length modifiers and their meanings are:
hh
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a signed char or unsigned char argument (the argument will have been promoted according to the integer
promotions, but its value shall be converted to signed char or unsigned char before printing); or that a following
n conversion specifier applies to a pointer to a signed char argument.
h
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a short or unsigned short argument (the argument will have been promoted according to the integer
promotions, but its value shall be converted to short or unsigned short before printing); or that a following
n conversion specifier applies to a pointer to a short argument.
l (ell)
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a long or unsigned long argument; that a following n conversion specifier applies to a pointer to
a long argument; that a following c conversion specifier applies to a wint_t argument; that a following
s conversion specifier applies to a pointer to a wchar_t argument; or has no effect on a following a,
A, e, E, f, F, g, or G conversion specifier.
ll (ell-ell)
Specifies that a following d, i, o, u, x, or X conversion specifier applies
to a long long or unsigned long long argument; or that a following n conversion specifier applies to a
pointer to a long long argument.
j
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to an intmax_t or uintmax_t argument; or that a following n conversion specifier applies to a
pointer to an intmax_t argument.
z
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a size_t or the corresponding signed integer type argument; or that a following n conversion specifier
applies to a pointer to a signed integer type corresponding to a size_t argument.
t
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a ptrdiff_t or the corresponding unsigned type argument; or that a following n conversion
specifier applies to a pointer to a ptrdiff_t argument.
L
Specifies that a following a, A, e, E, f, F, g, or G
conversion specifier applies to a long double argument.
If a length modifier appears with any conversion specifier other than as specified above, the behavior is undefined.
The conversion specifiers and their meanings are:
d, i
The int argument shall be converted to a signed decimal in the style "[-]dddd". The precision
specifies the minimum number of digits to appear; if the value being converted can be represented in fewer digits, it shall be
expanded with leading zeros. The default precision is 1. The result of converting zero with an explicit precision of zero shall be
no characters.
o
The unsigned argument shall be converted to unsigned octal format in the style "dddd". The
precision specifies the minimum number of digits to appear; if the value being converted can be represented in fewer digits, it
shall be expanded with leading zeros. The default precision is 1. The result of converting zero with an explicit precision of zero
shall be no characters.
u
The unsigned argument shall be converted to unsigned decimal format in the style "dddd". The
precision specifies the minimum number of digits to appear; if the value being converted can be represented in fewer digits, it
shall be expanded with leading zeros. The default precision is 1. The result of converting zero with an explicit precision of zero
shall be no characters.
x
The unsigned argument shall be converted to unsigned hexadecimal format in the style "dddd";
the letters "abcdef" are used. The precision specifies the minimum number of digits to appear; if the value being
converted can be represented in fewer digits, it shall be expanded with leading zeros. The default precision is 1. The result of
converting zero with an explicit precision of zero shall be no characters.
X
Equivalent to the x conversion specifier, except that letters "ABCDEF" are used instead of
"abcdef".
f, F
The double argument shall be converted to decimal notation in the style
"[-]ddd.ddd", where the number of digits after the radix character is equal to the
precision specification. If the precision is missing, it shall be taken as 6; if the precision is explicitly zero and no
'#' flag is present, no radix character shall appear. If a radix character appears, at least one digit appears before it.
The low-order digit shall be rounded in an implementation-defined manner.
A double argument representing an infinity shall be converted in one of the styles "[-]inf" or
"[-]infinity"; which style is implementation-defined. A double argument representing a NaN shall be converted in
one of the styles "[-]nan(n-char-sequence)" or "[-]nan"; which style, and the meaning of any
n-char-sequence, is implementation-defined. The F conversion specifier produces "INF",
"INFINITY", or "NAN" instead of "inf", "infinity", or "nan", respectively.
e, E
The double argument shall be converted in the style
"[-]d.ddde±dd", where there is one digit before the radix character (which
is non-zero if the argument is non-zero) and the number of digits after it is equal to the precision; if the precision is missing,
it shall be taken as 6; if the precision is zero and no '#' flag is present, no radix character shall appear. The
low-order digit shall be rounded in an implementation-defined manner. The E conversion specifier shall produce a number
with 'E' instead of 'e' introducing the exponent. The exponent shall always contain at least two digits. If the
value is zero, the exponent shall be zero.
A double argument representing an infinity or NaN shall be converted in the style of an f or F
conversion specifier.
g, G
The double argument representing a floating-point number shall be converted in the style f or e (or in
the style F or E in the case of a G conversion specifier), depending on the value converted and the
precision. Let P equal the precision if non-zero, 6 if the precision is omitted, or 1 if the precision is zero. Then, if a
conversion with style E would have an exponent of X:
If P>X>=-4, the conversion shall be with style f (or F) and precision
P-(X+1).
Otherwise, the conversion shall be with style e (or E) and precision P-1.
Finally, unless the '#' flag is used, any trailing zeros shall be removed from the fractional portion of the result and
the decimal-point character shall be removed if there is no fractional portion remaining.
A double argument representing an infinity or NaN shall be converted in the style of an f or F
conversion specifier.
a, A
A double argument representing a floating-point number shall be converted in the style
"[-]0xh.hhhhp±d", where there is one hexadecimal digit (which shall be
non-zero if the argument is a normalized floating-point number and is otherwise unspecified) before the decimal-point character and
the number of hexadecimal digits after it is equal to the precision; if the precision is missing and FLT_RADIX is a power of 2,
then the precision shall be sufficient for an exact representation of the value; if the precision is missing and FLT_RADIX is not a
power of 2, then the precision shall be sufficient to distinguish values of type double, except that trailing zeros may be
omitted; if the precision is zero and the '#' flag is not specified, no decimal-point character shall appear. The letters
"abcdef" shall be used for a conversion and the letters "ABCDEF" for A conversion. The
A conversion specifier produces a number with 'X' and 'P' instead of 'x' and 'p'. The
exponent shall always contain at least one digit, and only as many more digits as necessary to represent the decimal exponent of 2.
If the value is zero, the exponent shall be zero.
A double argument representing an infinity or NaN shall be converted in the style of an f or F
conversion specifier.
c
The int argument shall be converted to an unsigned char, and the resulting byte shall be written.
If an l (ell) qualifier is present, [CX]   the wint_t argument shall be converted to a multi-byte
sequence as if by a call to wcrtomb() with a pointer to storage of at least
MB_CUR_MAX bytes, the wint_t argument converted to wchar_t, and an initial shift state, and the resulting byte(s)
written.
s
The argument shall be a pointer to an array of char. Bytes from the array shall be written up to (but not including) any
terminating null byte. If the precision is specified, no more than that many bytes shall be written. If the precision is not
specified or is greater than the size of the array, the application shall ensure that the array contains a null byte.
If an l (ell) qualifier is present, the argument shall be a pointer to an array of type wchar_t. Wide characters
from the array shall be converted to characters (each as if by a call to the wcrtomb() function, with the conversion state described by an mbstate_t object
initialized to zero before the first wide character is converted) up to and including a terminating null wide character. The
resulting characters shall be written up to (but not including) the terminating null character (byte). If no precision is
specified, the application shall ensure that the array contains a null wide character. If a precision is specified, no more than
that many characters (bytes) shall be written (including shift sequences, if any), and the array shall contain a null wide
character if, to equal the character sequence length given by the precision, the function would need to access a wide character one
past the end of the array. In no case shall a partial character be written.
p
The argument shall be a pointer to void. The value of the pointer is converted to a sequence of printable characters, in
an implementation-defined manner.
n
The argument shall be a pointer to an integer into which is written the number of bytes written to the output so far by this
call to one of the fprintf() functions. No argument is converted.
C
[XSI]
Equivalent to lc.
S
[XSI]
Equivalent to ls.
%
Write a '%' character; no argument shall be converted. The application shall ensure that the complete conversion
specification is %%.
If a conversion specification does not match one of the above forms, the behavior is undefined. If any argument is not the
correct type for the corresponding conversion specification, the behavior is undefined.
In no case shall a nonexistent or small field width cause truncation of a field; if the result of a conversion is wider than the
field width, the field shall be expanded to contain the conversion result. Characters generated by fprintf() and
printf() are printed as if fputc() had been called.
For the a and A conversion specifiers, if FLT_RADIX is a power of 2, the value shall be correctly rounded to a
hexadecimal floating number with the given precision.
For a and A conversions, if FLT_RADIX is not a power of 2 and the result is not exactly representable in the
given precision, the result should be one of the two adjacent numbers in hexadecimal floating style with the given precision, with
the extra stipulation that the error should have a correct sign for the current rounding direction.
For the e, E, f, F, g, and G conversion specifiers, if the number of
significant decimal digits is at most DECIMAL_DIG, then the result should be correctly rounded. If the number of significant
decimal digits is more than DECIMAL_DIG but the source value is exactly representable with DECIMAL_DIG digits, then the result
should be an exact representation with trailing zeros. Otherwise, the source value is bounded by two adjacent decimal strings
L
#include
#include
#include
char *strperm (mode_t);
...
struct stat statbuf;
struct passwd *pwd;
struct group *grp;
...
printf("%10.10s", strperm (statbuf.st_mode));
printf("%4d", statbuf.st_nlink);
if ((pwd = getpwuid(statbuf.st_uid)) != NULL)
printf(" %-8.8s", pwd->pw_name);
else
printf(" %-8ld", (long) statbuf.st_uid);
if ((grp = getgrgid(statbuf.st_gid)) != NULL)
printf(" %-8.8s", grp->gr_name);
else
printf(" %-8ld", (long) statbuf.st_gid);
printf("%9jd", (intmax_t) statbuf.st_size);
...
Printing a Localized Date String
The following example gets a localized date string. The nl_langinfo()
function shall return the localized date string, which specifies the order and layout of the date. The strftime() function takes this information and, using the tm structure for values,
places the date and time information into datestring. The printf() function then outputs datestring and the
name of the entry.
#include
#include
#include
...
struct dirent *dp;
struct tm *tm;
char datestring[256];
...
strftime(datestring, sizeof(datestring), nl_langinfo (D_T_FMT), tm);
printf(" %s %s\n", datestring, dp->d_name);
...
Printing Error Information
The following example uses fprintf() to write error information to standard error.
In the first group of calls, the program tries to open the password lock file named LOCKFILE. If the file already exists,
this is an error, as indicated by the O_EXCL flag on the open() function. If the call
fails, the program assumes that someone else is updating the password file, and the program exits.
The next group of calls saves a new password file as the current password file by creating a link between LOCKFILE and
the new password file PASSWDFILE.
#include
#include
#include
#include
#include
#include
#include
#include
#define LOCKFILE "/etc/ptmp"
#define PASSWDFILE "/etc/passwd"
...
int pfd;
...
if ((pfd = open(LOCKFILE, O_WRONLY | O_CREAT | O_EXCL,
S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) == -1)
{
fprintf(stderr, "Cannot open /etc/ptmp. Try again later.\n");
exit(1);
}
...
if (link(LOCKFILE,PASSWDFILE) == -1) {
fprintf(stderr, "Link error: %s\n", strerror(errno));
exit(1);
}
...
Printing Usage Information
The following example checks to make sure the program has the necessary arguments, and uses fprintf() to print usage
information if the expected number of arguments is not present.
#include
#include
...
char *Options = "hdbtl";
...
if (argc  ('*') in the format
string; this ensures the correct number of decimal places for the element based on the number of elements requested.
#include
...
long i;
char *keystr;
int elementlen, len;
...
while (len
#include
#include
#include
#include
#include
...
char *pathname;
struct passwd *pw;
size_t len;
...
// digits required for pid_t is number of bits times
// log2(10) = approx 10/33
len = strlen(pw->pw_dir) + 1 + 1+(sizeof(pid_t)*80+32)/33 +
sizeof ".out";
pathname = malloc(len);
if (pathname != NULL)
{
snprintf(pathname, len, "%s/%jd.out", pw->pw_dir,
(intmax_t)getpid());
...
}
Reporting an Event
The following example loops until an event has timed out. The pause() function
waits forever unless it receives a signal. The fprintf() statement should never occur due to the possible return values of
pause().
#include
#include
#include
#include
...
while (!event_complete) {
...
if (pause() != -1 || errno != EINTR)
fprintf(stderr, "pause: unknown error: %s\n", strerror(errno));
}
...
Printing Monetary Information
The following example uses strfmon() to convert a number and store it as a
formatted monetary string named convbuf. If the first number is printed, the program prints the format and the description;
otherwise, it just prints the number.
#include
#include
...
struct tblfmt {
char *format;
char *description;
};
struct tblfmt table[] = {
{ "%n", "default formatting" },
{ "%11n", "right align within an 11 character field" },
{ "%#5n", "aligned columns for values up to 99999" },
{ "%=*#5n", "specify a fill character" },
{ "%=0#5n", "fill characters do not use grouping" },
{ "%^#5n", "disable the grouping separator" },
{ "%^#5.0n", "round off to whole units" },
{ "%^#5.4n", "increase the precision" },
{ "%(#5n", "use an alternative pos/neg style" },
{ "%!(#5n", "disable the currency symbol" },
};
...
float input[3];
int i, j;
char convbuf[100];
...
strfmon(convbuf, sizeof(convbuf), table[i].format, input[j]);
if (j == 0) {
printf("%s  %s      %s\n", table[i].format,
convbuf, table[i].description);
}
else {
printf("    %s\n", convbuf);
}
...
Printing Wide Characters
The following example prints a series of wide characters. Suppose that "L`@`" expands to three bytes:
wchar_t wz [3] = L"@@";       // Zero-terminated
wchar_t wn [3] = L"@@@";      // Unterminated
fprintf (stdout,"%ls", wz);   // Outputs 6 bytes
fprintf (stdout,"%ls", wn);   // Undefined because wn has no terminator
fprintf (stdout,"%4ls", wz);  // Outputs 3 bytes
fprintf (stdout,"%4ls", wn);  // Outputs 3 bytes; no terminator needed
fprintf (stdout,"%9ls", wz);  // Outputs 6 bytes
fprintf (stdout,"%9ls", wn);  // Outputs 9 bytes; no terminator needed
fprintf (stdout,"%10ls", wz); // Outputs 6 bytes
fprintf (stdout,"%10ls", wn); // Undefined because wn has no terminator
In the last line of the example, after processing three characters, nine bytes have been output. The fourth character must then
be examined to determine whether it converts to one byte or more. If it converts to more than one byte, the output is only nine
bytes. Since there is no fourth character in the array, the behavior is undefined.
APPLICATION USAGE
If the application calling fprintf() has any objects of type wint_t or wchar_t, it must also include the
header to have these objects defined.
The space allocated by a successful call to asprintf() should be subsequently freed by a call to free().
RATIONALE
If an implementation detects that there are insufficient arguments for the format, it is recommended that the function should
fail and report an [EINVAL] error.
The behavior specified for the %lc conversion differs slightly from the specification in the ISO C standard, in
that printing the null wide character produces a null byte instead of 0 bytes of output as would be required by a strict reading of
the ISO C standard's direction to behave as if applying the %ls specifier to a wchar_t array whose first
element is the null wide character. Requiring a multi-byte output for every possible wide character, including the null character,
matches historical practice, and provides consistency with %c in fprintf() and with both %c and
%lc in fwprintf(). It is anticipated that a future edition of the
ISO C standard will change to match the behavior specified here.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fputc(), fscanf(), setlocale(), strfmon(), strlcat(), wcrtomb(), wcslcat()
XBD 7. Locale, , ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
Aligned with ISO/IEC 9899:1990/Amendment 1:1995 (E). Specifically, the l (ell) qualifier can now be used with
c and s conversion specifiers.
The snprintf() function is new in Issue 5.
Issue 6
Extensions beyond the ISO C standard are marked.
The normative text is updated to avoid use of the term "must" for application requirements.
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The prototypes for fprintf(), printf(), snprintf(), and sprintf() are updated, and the XSI shading
is removed from snprintf().
The description of snprintf() is aligned with the ISO C standard. Note that this supersedes the snprintf()
description in The Open Group Base Resolution bwg98-006, which changed the behavior from Issue 5.
The DESCRIPTION is updated.
The DESCRIPTION is updated to use the terms "conversion specifier" and "conversion specification" consistently.
ISO/IEC 9899:1999 standard, Technical Corrigendum 1 is incorporated.
An example of printing wide characters is added.
Issue 7
Austin Group Interpretation 1003.1-2001 #161 is applied, updating the DESCRIPTION of the 0 flag.
Austin Group Interpretation 1003.1-2001 #170 is applied.
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #68 (SD5-XSH-ERN-70) is applied, revising the description of g
and G.
SD5-XSH-ERN-174 is applied.
The dprintf() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 1.
Functionality relating to the %n$ form of conversion specification and the  flag is moved from the
XSI option to the Base.
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0163 [302], XSH/TC1-2008/0164 [316], XSH/TC1-2008/0165 [316],
XSH/TC1-2008/0166 [451,291], and XSH/TC1-2008/0167 [14] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0126 [894], XSH/TC2-2008/0127 [557], and XSH/TC2-2008/0128 [936] are
applied.
Issue 8
Austin Group Defect 986 is applied, adding strlcat() and wcslcat() to the SEE ALSO section.
Austin Group Defect 1020 is applied, clarifying that the snprintf() argument n limits the number of bytes written
to s; it is not necessarily the same as the size of s.
Austin Group Defect 1021 is applied, changing "output error" to "error" in the RETURN VALUE section.
Austin Group Defect 1137 is applied, clarifying the use of "%n$" and "*m$" in
conversion specifications.
Austin Group Defect 1205 is applied, changing the description of the % conversion specifier.
Austin Group Defect 1219 is applied, removing the snprintf()-specific [EOVERFLOW] error.
Austin Group Defect 1496 is applied, adding the asprintf() function.
Austin Group Defect 1562 is applied, clarifying that it is the application's responsibility to ensure that the format is a
character string, beginning and ending in its initial shift state, if any.
Austin Group Defect 1647 is applied, changing the description of the c conversion specifier and updating the statement
that this volume of POSIX.1-2024 defers to the ISO C standard so that it excludes the %lc conversion when passed a
null wide character.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_exit.html =====
pthread_exit
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_exit — thread termination
SYNOPSIS
#include
_Noreturn void pthread_exit(void *value_ptr);
DESCRIPTION
The pthread_exit() function shall terminate the calling thread and make the value value_ptr available to any
successful join with the terminating thread. Any cancellation cleanup handlers that have been pushed and not yet popped shall be
popped in the reverse order that they were pushed and then executed. After all cancellation cleanup handlers have been executed, if
the thread has any thread-specific data (whether associated with key type tss_t or pthread_key_t), appropriate
destructor functions shall be called in an unspecified order. Thread termination does not release any application visible process
resources, including, but not limited to, mutexes and file descriptors, nor does it perform any process-level cleanup actions,
including, but not limited to, calling any atexit() routines that may exist.
An implicit call to pthread_exit() is made when a thread that was not created using thrd_create(), and is not the thread in which main() was first invoked, returns
from the start routine that was used to create it. The function's return value shall serve as the thread's exit status.
The behavior of pthread_exit() is undefined if called from a cancellation cleanup handler or destructor function that was
invoked as a result of either an implicit or explicit call to pthread_exit().
After a thread has terminated, the result of access to local (auto) variables of the thread is undefined. Thus, references to
local variables of the exiting thread should not be used for the pthread_exit() value_ptr parameter value.
The process shall exit with an exit status of 0 after the last thread has been terminated. The behavior shall be as if the
implementation called exit() with a zero argument at thread termination time.
RETURN VALUE
The pthread_exit() function cannot return to its caller.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Calls to pthread_exit() should not be made from threads created using thrd_create(), as their exit status has a different type (int instead of void
*). If pthread_exit() is called from the initial thread and it is not the last thread to terminate, other threads should
not try to obtain its exit status using thrd_join().
RATIONALE
The normal mechanism by which a thread that was started using pthread_create() terminates is to return from the routine that was specified in the
pthread_create() call that started it. The pthread_exit() function
provides the capability for a thread to terminate without requiring a return from the start routine of that thread, thereby
providing a function analogous to exit().
Regardless of the method of thread termination, any cancellation cleanup handlers that have been pushed and not yet popped are
executed, and the destructors for any existing thread-specific data are executed. This volume of POSIX.1-2024 requires that
cancellation cleanup handlers be popped and called in order. After all cancellation cleanup handlers have been executed,
thread-specific data destructors are called, in an unspecified order, for each item of thread-specific data that exists in the
thread. This ordering is necessary because cancellation cleanup handlers may rely on thread-specific data.
As the meaning of the status is determined by the application (except when the thread has been canceled, in which case it is
PTHREAD_CANCELED), the implementation has no idea what an illegal status value is, which is why no address error checking is
done.
FUTURE DIRECTIONS
None.
SEE ALSO
exit(), pthread_create(), pthread_join(), pthread_key_create(), thrd_create(), thrd_exit(),
tss_create()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_exit() function is marked as part of the Threads option.
Issue 7
The pthread_exit() function is moved from the Threads option to the Base.
Issue 8
Austin Group Defect 1302 is applied, adding _Noreturn to the SYNOPSIS, and updating the page to account for the
addition of  interfaces.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/vasprintf.html =====
vfprintf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
vasprintf, vdprintf, vfprintf, vprintf, vsnprintf, vsprintf — format output of a stdarg argument list
SYNOPSIS
#include
#include
[CX]  int vasprintf(char **restrict ptr, const char *restrict format,
va_list ap);
int vdprintf(int fildes, const char *restrict format, va_list ap);
int vfprintf(FILE *restrict stream, const char *restrict format,
va_list ap);
int vprintf(const char *restrict format, va_list ap);
int vsnprintf(char *restrict s, size_t n, const char *restrict format,
va_list ap);
int vsprintf(char *restrict s, const char *restrict format, va_list
ap);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The [CX]
vasprintf(), vdprintf(),  vfprintf(),
vprintf(), vsnprintf(), and vsprintf() functions shall be equivalent to the [CX]  asprintf(), dprintf(),  fprintf(), printf(), snprintf(), and sprintf() functions respectively, except that instead of being called with a variable number
of arguments, they are called with an argument list as defined by .
These functions shall not invoke the va_end macro. As these functions invoke the va_arg macro, the value of
ap after the return is unspecified.
RETURN VALUE
Refer to fprintf().
ERRORS
Refer to fprintf().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications using these functions should call va_end(ap) afterwards to clean up.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fprintf()
XBD ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The vsnprintf() function is added.
Issue 6
The vfprintf(), vprintf(), vsnprintf(), and vsprintf() functions are updated for alignment with the
ISO/IEC 9899:1999 standard.
Issue 7
The vdprintf() function is added to complement the dprintf() function from
The Open Group Technical Standard, 2006, Extended API Set Part 1.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0703 [14] is applied.
Issue 8
Austin Group Defect 1496 is applied, adding the vasprintf() function.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/imaxdiv.html =====
imaxdiv
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
imaxdiv — return quotient and remainder
SYNOPSIS
#include
imaxdiv_t imaxdiv(intmax_t numer, intmax_t denom);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The imaxdiv() function shall compute numer / denom and numer % denom in a
single operation.
RETURN VALUE
The imaxdiv() function shall return a structure of type imaxdiv_t, comprising both the quotient and the remainder.
The structure shall contain (in either order) the members quot (the quotient) and rem (the remainder), each of which
has type intmax_t.
If either part of the result cannot be represented, the behavior is undefined.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
imaxabs()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/clearerr.html =====
clearerr
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
clearerr — clear indicators on a stream
SYNOPSIS
#include
void clearerr(FILE *stream);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The clearerr() function shall clear the end-of-file and error indicators for the stream to which stream
points.
[CX]  The
clearerr() function shall not change the setting of errno if stream is valid.
RETURN VALUE
The clearerr() function shall not return a value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0057 [401] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_mutexattr_settype.html =====
pthread_mutexattr_gettype
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_mutexattr_gettype, pthread_mutexattr_settype — get and set the mutex type attribute
SYNOPSIS
#include
int pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict attr,
int *restrict type);
int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int type);
DESCRIPTION
The pthread_mutexattr_gettype() and pthread_mutexattr_settype() functions, respectively, shall get and set the
mutex type attribute. This attribute is set in the type parameter to these functions. The default value of the
type attribute is PTHREAD_MUTEX_DEFAULT.
The type of mutex is contained in the type attribute of the mutex attributes. Valid mutex types include:
PTHREAD_MUTEX_NORMAL
PTHREAD_MUTEX_ERRORCHECK
PTHREAD_MUTEX_RECURSIVE
PTHREAD_MUTEX_DEFAULT
The mutex type affects the behavior of calls which lock and unlock the mutex. See pthread_mutex_lock() for details. An implementation may map
PTHREAD_MUTEX_DEFAULT to one of the other mutex types.
The behavior is undefined if the value specified by the attr argument to pthread_mutexattr_gettype() or
pthread_mutexattr_settype() does not refer to an initialized mutex attributes object.
RETURN VALUE
Upon successful completion, the pthread_mutexattr_gettype() function shall return zero and store the value of the
type attribute of attr into the object referenced by the type parameter. Otherwise, an error shall be returned
to indicate the error.
If successful, the pthread_mutexattr_settype() function shall return zero; otherwise, an error number shall be returned
to indicate the error.
ERRORS
The pthread_mutexattr_settype() function shall fail if:
[EINVAL]
The value type is invalid.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
It is advised that an application should not use a PTHREAD_MUTEX_RECURSIVE mutex with condition variables because the implicit
unlock performed in a pthread_cond_clockwait(), pthread_cond_timedwait(), or pthread_cond_wait() call may not actually release the mutex (if it had been locked
multiple times). If this happens, no other thread can satisfy the condition of the predicate.
RATIONALE
If an implementation detects that the value specified by the attr argument to pthread_mutexattr_gettype() or
pthread_mutexattr_settype() does not refer to an initialized mutex attributes object, it is recommended that the function
should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_cond_clockwait(), pthread_mutex_lock()
XBD
CHANGE HISTORY
First released in Issue 5.
Issue 6
The Open Group Corrigendum U033/3 is applied. The SYNOPSIS for pthread_mutexattr_gettype() is updated so that the first
argument is of type const pthread_mutexattr_t *.
The restrict keyword is added to the pthread_mutexattr_gettype() prototype for alignment with the
ISO/IEC 9899:1999 standard.
Issue 7
The pthread_mutexattr_gettype() and pthread_mutexattr_settype() functions are moved from the XSI option to the
Base.
The [EINVAL] error for an uninitialized mutex attributes object is removed; this condition results in undefined behavior.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0464 [121] is applied.
Issue 8
Austin Group Defect 1216 is applied, adding pthread_cond_clockwait().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/asin.html =====
asin
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
asin, asinf, asinl — arc sine function
SYNOPSIS
#include
double asin(double x);
float asinf(float x);
long double asinl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the principal value of the arc sine of their argument x. The value of x should be in
the range [-1,1].
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the arc sine of x, in the range [-ℼ/2,ℼ/2] radians.
For finite values of x not in the range [-1,1], a domain error shall occur, and [MX]   either a NaN
(if supported), or   an implementation-defined value shall be
returned.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, x shall be returned.
If x is ±Inf, a domain error shall occur, and a NaN shall be returned.
[MXX]
If x is subnormal, x should be returned.
[MX]  If x is subnormal, a range error may occur and, if x is
not returned, asin(), asinf(), and asinl() shall return an implementation-defined value no greater in
magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
ERRORS
These functions shall fail if:
Domain Error
The x argument is finite and is not in the range [-1,1], [MX]
or is ±Inf.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
These functions may fail if:
Range Error
[MX]
The value of x is subnormal.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), isnan(), sin()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The asinf() and asinl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0034 [320] and XSH/TC1-2008/0035 [68] are applied.
Issue 8
Austin Group Defect 1382 is applied, rearranging the text describing the behavior when x is subnormal to avoid the need
for two shading changes.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/vswprintf.html =====
vfwprintf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
vfwprintf, vswprintf, vwprintf — wide-character formatted output of a stdarg argument list
SYNOPSIS
#include
#include
#include
int vfwprintf(FILE *restrict stream, const wchar_t *restrict format,
va_list arg);
int vswprintf(wchar_t *restrict ws, size_t n,
const wchar_t *restrict format, va_list arg);
int vwprintf(const wchar_t *restrict format, va_list arg);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The vfwprintf(), vswprintf(), and vwprintf() functions shall be equivalent to fwprintf(), swprintf(), and wprintf() respectively, except that instead of being called with a variable number of
arguments, they are called with an argument list as defined by .
These functions shall not invoke the va_end macro. However, as these functions do invoke the va_arg macro, the
value of ap after the return is unspecified.
RETURN VALUE
Refer to fwprintf().
ERRORS
Refer to fwprintf().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications using these functions should call va_end(ap) afterwards to clean up.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fwprintf()
XBD , ,
CHANGE HISTORY
First released in Issue 5. Included for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E).
Issue 6
The vfwprintf(), vswprintf(), and vwprintf() prototypes are updated for alignment with the
ISO/IEC 9899:1999 standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0705 [14] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcswidth.html =====
wcswidth
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcswidth — number of column positions of a wide-character string
SYNOPSIS
[XSI]  #include
int wcswidth(const wchar_t *pwcs, size_t n);
DESCRIPTION
The wcswidth() function shall determine the number of column positions required for n wide-character codes (or
fewer than n wide-character codes if a null wide-character code is encountered before n wide-character codes are
exhausted) in the string pointed to by pwcs.
The wcswidth() function shall not change the setting of errno on valid input.
RETURN VALUE
The wcswidth() function either shall return 0 (if pwcs points to a null wide-character code), or return the number
of column positions to be occupied by the wide-character string pointed to by pwcs, or return -1 (if any of the first
n wide-character codes in the wide-character string pointed to by pwcs is not a printable wide-character code).
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
This function was removed from the final ISO/IEC 9899:1990/Amendment 1:1995 (E), and the return value for a non-printable
wide character is not specified.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
wcwidth()
XBD 3.75 Column Position,
CHANGE HISTORY
First released in Issue 4. Derived from the MSE working draft.
Issue 6
The Open Group Corrigendum U021/11 is applied. The function is marked as an extension.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that wcswidth() does not change the setting of errno on
valid input.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/endgrent.html =====
endgrent
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
endgrent, getgrent, setgrent — group database entry functions
SYNOPSIS
[XSI]  #include
void endgrent(void);
struct group *getgrent(void);
void setgrent(void);
DESCRIPTION
The getgrent() function shall return a pointer to a structure containing the broken-out fields of an entry in the group
database. If the group database is not already open, getgrent() shall open it and return a pointer to a group
structure containing the first entry in the database. Thereafter, it shall return a pointer to a group structure containing
the next group structure in the group database, so successive calls may be used to search the entire database.
An implementation that provides extended security controls may impose further implementation-defined restrictions on accessing
the group database. In particular, the system may deny the existence of some or all of the group database entries associated with
groups other than those groups associated with the caller and may omit users other than the caller from the list of members of
groups in database entries that are returned.
The setgrent() function shall rewind the group database so that the next getgrent() call returns the first entry,
allowing repeated searches.
The endgrent() function shall close the group database.
The setgrent() and endgrent() functions shall not change the setting of errno if successful.
On error, the setgrent() and endgrent() functions shall set errno to indicate the error.
Since no value is returned by the setgrent() and endgrent() functions, an application wishing to check for error
situations should set errno to 0, then call the function, then check errno.
These functions need not be thread-safe.
RETURN VALUE
On successful completion, getgrent() shall return a pointer to a group structure. On end-of-file,
getgrent() shall return a null pointer and shall not change the setting of errno. On error, getgrent() shall
return a null pointer and errno shall be set to indicate the error.
The application shall not modify the structure to which the return value points, nor any storage areas pointed to by pointers
within the structure. The returned pointer, and pointers within the structure, might be invalidated or the structure or the storage
areas might be overwritten by a subsequent call to getgrgid(), getgrnam(), or getgrent(). The returned pointer, and pointers within the structure,
might also be invalidated if the calling thread is terminated.
ERRORS
These functions may fail if:
[EINTR]
A signal was caught during the operation.
[EIO]
An I/O error has occurred.
In addition, the getgrent() and setgrent() functions may fail if:
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum allowable number of files is currently open in the system.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
These functions are provided due to their historical usage. Applications should avoid dependencies on fields in the group
database, whether the database is a single file, or where in the file system name space the database resides. Applications should
use getgrnam() and getgrgid()
whenever possible because it avoids these dependencies.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
endpwent(), getgrgid(),
getgrnam(), getlogin()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Normative text previously in the APPLICATION USAGE section is moved to the RETURN VALUE section.
A note indicating that these functions need not be reentrant is added to the DESCRIPTION.
Issue 6
In the DESCRIPTION, the note about reentrancy is expanded to cover thread-safety.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
SD5-XBD-ERN-4 is applied, changing the definition of the [EMFILE] error.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0080 [75] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0086 [493], XSH/TC2-2008/0087 [656], and XSH/TC2-2008/0088 [493] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/cosh.html =====
cosh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cosh, coshf, coshl — hyperbolic cosine functions
SYNOPSIS
#include
double cosh(double x);
float coshf(float x);
long double coshl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the hyperbolic cosine of their argument x.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the hyperbolic cosine of x.
If the correct value would cause overflow, a range error shall occur and cosh(), coshf(), and coshl() shall
return the value of the macro HUGE_VAL, HUGE_VALF, and HUGE_VALL, respectively.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, the value 1.0 shall be returned.
If x is ±Inf, +Inf shall be returned.
ERRORS
These functions shall fail if:
Range Error
The result would cause an overflow.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
acosh(), feclearexcept(),
fetestexcept(), isnan(),
sinh(), tanh()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The coshf() and coshl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0072 [630] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_setschedparam.html =====
pthread_getschedparam
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_getschedparam, pthread_setschedparam — dynamic thread scheduling parameters access (REALTIME
THREADS)
SYNOPSIS
[TPS]  #include
int pthread_getschedparam(pthread_t thread, int *restrict policy,
struct sched_param *restrict param);
int pthread_setschedparam(pthread_t thread, int policy,
const struct sched_param *param);
DESCRIPTION
The pthread_getschedparam() and pthread_setschedparam() functions shall, respectively, get and set the scheduling
policy and parameters of individual threads within a multi-threaded process to be retrieved and set. For SCHED_FIFO and SCHED_RR,
the only required member of the sched_param structure is the priority sched_priority. For SCHED_OTHER, the affected
scheduling parameters are implementation-defined.
The pthread_getschedparam() function shall retrieve the scheduling policy and scheduling parameters for the thread whose
thread ID is given by thread and shall store those values in policy and param, respectively. The priority
value returned from pthread_getschedparam() shall be the value specified by the most recent pthread_setschedparam(),
pthread_setschedprio(), or pthread_create() call affecting the target thread. It shall not reflect any temporary
adjustments to its priority as a result of any priority inheritance or ceiling functions. The pthread_setschedparam()
function shall set the scheduling policy and associated scheduling parameters for the thread whose thread ID is given by
thread to the policy and associated parameters provided in policy and param, respectively.
The policy parameter may have the value SCHED_OTHER, SCHED_FIFO, or SCHED_RR. The scheduling parameters for the
SCHED_OTHER policy are implementation-defined. The SCHED_FIFO and SCHED_RR policies shall have a single scheduling parameter,
priority.
[TSP]
If _POSIX_THREAD_SPORADIC_SERVER is defined, then the policy argument may have the value SCHED_SPORADIC, with the exception
for the pthread_setschedparam() function that if the scheduling policy was not SCHED_SPORADIC at the time of the call, it is
implementation-defined whether the function is supported; in other words, the implementation need not allow the application to
dynamically change the scheduling policy to SCHED_SPORADIC. The sporadic server scheduling policy has the associated parameters
sched_ss_low_priority, sched_ss_repl_period, sched_ss_init_budget, sched_priority, and
sched_ss_max_repl. The specified sched_ss_repl_period shall be greater than or equal to the specified
sched_ss_init_budget for the function to succeed; if it is not, then the function shall fail. The value of
sched_ss_max_repl shall be within the inclusive range [1,{SS_REPL_MAX}] for the function to succeed; if not, the function
shall fail. It is unspecified whether the sched_ss_repl_period and sched_ss_init_budget values are stored as provided
by this function or are rounded to align with the resolution of the clock being used.
If the pthread_setschedparam() function fails, the scheduling parameters shall not be changed for the target thread.
RETURN VALUE
If successful, the pthread_getschedparam() and pthread_setschedparam() functions shall return zero; otherwise, an
error number shall be returned to indicate the error.
ERRORS
The pthread_setschedparam() function shall fail if:
[ENOTSUP]
An attempt was made to set the policy or scheduling parameters to an unsupported value.
[ENOTSUP]
[TSP]
An attempt was made to dynamically change the scheduling policy to SCHED_SPORADIC, and the implementation does not support this
change.
The pthread_setschedparam() function may fail if:
[EINVAL]
The value specified by policy or one of the scheduling parameters associated with the scheduling policy policy is
invalid.
[EPERM]
The caller does not have appropriate privileges to set either the scheduling parameters or the scheduling policy of the
specified thread.
[EPERM]
The implementation does not allow the application to modify one of the parameters to the value specified.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
If an implementation detects use of a thread ID after the end of its lifetime, it is recommended that the function should fail
and report an [ESRCH] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_setschedprio(), sched_getparam(), sched_getscheduler()
XBD ,
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_getschedparam() and pthread_setschedparam() functions are marked as part of the Threads and Thread
Execution Scheduling options.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Thread
Execution Scheduling option.
The Open Group Corrigendum U026/2 is applied, correcting the prototype for the pthread_setschedparam() function so that
its second argument is of type int.
The SCHED_SPORADIC scheduling policy is added for alignment with IEEE Std 1003.1d-1999.
The restrict keyword is added to the pthread_getschedparam() prototype for alignment with the
ISO/IEC 9899:1999 standard.
The Open Group Corrigendum U047/1 is applied.
IEEE PASC Interpretation 1003.1 #96 is applied, noting that priority values can also be set by a call to the pthread_setschedprio() function.
Issue 7
The pthread_getschedparam() and pthread_setschedparam() functions are marked only as part of the Thread Execution
Scheduling option as the Threads option is now part of the Base.
Austin Group Interpretation 1003.1-2001 #119 is applied, clarifying the accuracy requirements for the
sched_ss_repl_period and sched_ss_init_budget values.
Austin Group Interpretation 1003.1-2001 #142 is applied, removing the [ESRCH] error condition.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0459 [314] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0276 [757] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcsncat.html =====
wcsncat
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcsncat — concatenate a wide-character string with part of another
SYNOPSIS
#include
wchar_t *wcsncat(wchar_t *restrict ws1, const wchar_t *restrict ws2,
size_t n);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The wcsncat() function shall append not more than n wide-character codes (a null wide-character code and
wide-character codes that follow it are not appended) from the array pointed to by ws2 to the end of the wide-character
string pointed to by ws1. The initial wide-character code of ws2 shall overwrite the null wide-character code at the
end of ws1. A terminating null wide-character code shall always be appended to the result. If copying takes place between
objects that overlap, the behavior is undefined.
[CX]  The
wcsncat() function shall not change the setting of errno on valid input.
RETURN VALUE
The wcsncat() function shall return ws1; no return value is reserved to indicate an error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
wcscat(), wcslcat()
XBD
CHANGE HISTORY
First released in Issue 4. Derived from the MSE working draft.
Issue 6
The wcsncat() prototype is updated for alignment with the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that wcsncat() does not change the setting of errno on
valid input.
Austin Group Defect 986 is applied, adding wcslcat() to the SEE ALSO section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/isgreater.html =====
isgreater
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
isgreater, isgreaterequal, isless, islessequal, islessgreater — real-floating relational tests
SYNOPSIS
#include
int isgreater(real-floating x, real-floating y);
int isgreaterequal(real-floating x, real-floating y);
int isless(real-floating x, real-floating y);
int islessequal(real-floating x, real-floating y);
int islessgreater(real-floating x, real-floating y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The isgreater() macro shall determine whether its first argument is greater than its second argument. The value of
isgreater(x, y) shall be equal to (x) > (y); however, unlike
(x) > (y), isgreater(x, y) shall not raise the invalid floating-point exception
when x and y are unordered.
The isgreaterequal() macro shall determine whether its first argument is greater than or equal to its second argument.
The value of isgreaterequal(x, y) shall be equal to (x) >= (y); however, unlike
(x) >= (y), isgreaterequal(x, y) shall not raise the invalid floating-point
exception when x and y are unordered.
The isless() macro shall determine whether its first argument is less than its second argument. The value of
isless(x, y) shall be equal to (x)  (y); however, islessgreater(x,
y) shall not raise the invalid floating-point exception when x and y are unordered (nor shall it evaluate
x and y twice).
[MX]
Relational operators and their corresponding comparison macros shall produce equivalent result values, even if argument values are
represented in wider formats. Thus, comparison macro arguments represented in formats wider than their semantic types shall not be
converted to the semantic types, unless the wide evaluation method converts operands of relational operators to their semantic
types. The standard wide evaluation methods characterized by FLT_EVAL_METHOD equal to 1 or 2 (see ) do not convert operands of relational operators to their semantic types.
RETURN VALUE
Upon successful completion, the isgreater() macro shall return the value of (x) > (y).
Upon successful completion, the isgreaterequal() macro shall return the value of
(x) >= (y).
Upon successful completion, the isless() macro shall return the value of (x)  (y).
If x or y is NaN, these functions shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The relational and equality operators support the usual mathematical relationships between numeric values. For any ordered pair
of numeric values, exactly one of the relationships (less, greater, and equal) is true. Relational operators may raise the invalid
floating-point exception when argument values are NaNs. For a NaN and a numeric value, or for two NaNs, just the unordered
relationship is true. This macro is a quiet (non-floating-point exception raising) version of a relational operator. It facilitates
writing efficient code that accounts for NaNs without suffering the invalid floating-point exception. In the SYNOPSIS section,
real-floating indicates that the argument shall be an expression of real-floating type.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
isunordered()
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
The individual pages for these functions have been merged to form a single page, to reduce duplication.
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fmodl.html =====
fmod
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fmod, fmodf, fmodl — floating-point remainder value function
SYNOPSIS
#include
double fmod(double x, double y);
float fmodf(float x, float y);
long double fmodl(long double x, long double y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall return the floating-point remainder of the division of x by y.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
These functions shall return the value x-i*y, for some integer i such that, if y is non-zero,
the result has the same sign as x and magnitude less than the magnitude of y.
If the correct value would cause underflow, [MXX]   and is not representable,   a range error may occur, and fmod(), modf(),
and fmodl() shall return [MXX]   0.0, or   (if the IEC 60559
Floating-Point option is not supported) an implementation-defined value no greater in magnitude than DBL_MIN, FLT_MIN, and
LDBL_MIN, respectively.
[MX]  If
x or y is NaN, a NaN shall be returned, and none of the conditions below shall be considered.
If y is zero, a domain error shall occur, and a NaN shall be returned.
If x is infinite, a domain error shall occur, and a NaN shall be returned.
If x is ±0 and y is not zero, ±0 shall be returned.
If x is not infinite and y is ±Inf, x shall be returned.
When subnormal results are supported, the returned value shall be exact and shall be independent of the current rounding
direction mode.
ERRORS
These functions shall fail if:
Domain Error
[MX]
The x argument is infinite or y is zero.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
These functions may fail if:
Range Error
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), isnan()
4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The behavior for when the y argument is zero is now defined.
The fmodf() and fmodl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0151 [68], XSH/TC1-2008/0152 [320], and XSH/TC1-2008/0153 [68] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0120 [605] is applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/unsetenv.html =====
unsetenv
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
unsetenv — remove an environment variable
SYNOPSIS
[CX]  #include
int unsetenv(const char *name);
DESCRIPTION
The unsetenv() function shall remove an environment variable from the environment of the calling process. The name
argument points to a string, which is the name of the variable to be removed. The named argument shall not contain an '='
character. If the named variable does not exist in the current environment, the environment shall be unchanged and the function is
considered to have completed successfully.
The unsetenv() function shall update the list of pointers to which environ points.
The unsetenv() function need not be thread-safe.
RETURN VALUE
Upon successful completion, zero shall be returned. Otherwise, -1 shall be returned, errno set to indicate the error, and
the environment shall be unchanged.
ERRORS
The unsetenv() function shall fail if:
[EINVAL]
The name argument points to an empty string, or points to a string containing an '=' character.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
Refer to the RATIONALE section in setenv().
FUTURE DIRECTIONS
None.
SEE ALSO
getenv(), setenv()
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from the IEEE P1003.1a draft standard.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0698 [167] and XSH/TC1-2008/0699 [185] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/lrand48.html =====
drand48
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
drand48, erand48, jrand48, lcong48, lrand48, mrand48, nrand48, seed48, srand48 — generate uniformly distributed
pseudo-random numbers
SYNOPSIS
[XSI]  #include
double drand48(void);
double erand48(unsigned short xsubi[3]);
long jrand48(unsigned short xsubi[3]);
void lcong48(unsigned short param[7]);
long lrand48(void);
long mrand48(void);
long nrand48(unsigned short xsubi[3]);
unsigned short *seed48(unsigned short seed16v[3]);
void srand48(long seedval);
DESCRIPTION
This family of functions shall generate pseudo-random numbers using a linear congruential algorithm and 48-bit integer
arithmetic.
The drand48() and erand48() functions shall return non-negative, double-precision, floating-point values,
uniformly distributed over the interval [0.0,1.0).
The lrand48() and nrand48() functions shall return non-negative, long integers, uniformly distributed over the
interval [0,231).
The mrand48() and jrand48() functions shall return signed long integers uniformly distributed over the interval
[-231,231).
The srand48(), seed48(), and lcong48() functions are initialization entry points, one of which should be
invoked before either drand48(), lrand48(), or mrand48() is called. (Although it is not recommended practice,
constant default initializer values shall be supplied automatically if drand48(), lrand48(), or mrand48() is
called without a prior call to an initialization entry point.) The erand48(), nrand48(), and jrand48()
functions do not require an initialization entry point to be called first.
All the routines work by generating a sequence of 48-bit integer values,
\(X_{i}\),
according to the linear congruential formula:
\(X_{n+1}=\left(a X_n+c\right)_{\bmod m} \quad n \geq 0\)
The parameter m=248; hence 48-bit integer arithmetic is performed. Unless lcong48() is invoked, the multiplier
value a and the addend value c are given by:
\(
\begin{aligned}
& a= \text { 5DEECE66D }_{16}=273673163155_8 \\
& c=\mathrm{B}_{16}=13_8
\end{aligned}
\)
The value returned by any of the drand48(), erand48(), jrand48(), lrand48(), mrand48(), or
nrand48() functions is computed by first generating the next 48-bit \(X_{i}\) in the sequence. \(X_{i}\) is then converted
to the return value as follows:
For drand48() and erand48() the value shall be 2-48 times \(X_{i}\).
For jrand48() and mrand48() the value shall be the largest integer not greater than 2-16 times \(X_{i}\).
For lrand48() and nrand48() the value shall be the largest integer not greater than 2-17 times \(X_{i}\).
The drand48(), lrand48(), and mrand48() functions store the last 48-bit \(X_{i}\) generated in an internal
buffer; that is why the application shall ensure that these are initialized prior to being invoked. The erand48(),
nrand48(), and jrand48() functions require the calling program to provide storage for the successive \(X_{i}\) values
in the array specified as an argument when the functions are invoked. That is why these routines do not have to be initialized; the
calling program merely has to place the desired initial value of \(X_{i}\) into the array and pass it as an argument. By using
different arguments, erand48(), nrand48(), and jrand48() allow separate modules of a large program to generate
several independent streams of pseudo-random numbers; that is, the sequence of numbers in each stream shall not
depend upon how many times the routines are called to generate numbers for the other streams.
The initializer function srand48() sets the high-order 32 bits of \(X_{i}\) to the low-order 32 bits contained in its
argument. The low-order 16 bits of \(X_{i}\) are set to the arbitrary value 330E16.
The initializer function seed48() sets the value of \(X_{i}\) to the 48-bit value specified in the argument array. The
low-order 16 bits of \(X_{i}\) are set to the low-order 16 bits of seed16v[0]. The mid-order 16 bits of \(X_{i}\) are
set to the low-order 16 bits of seed16v[1]. The high-order 16 bits of \(X_{i}\) are set to the low-order 16 bits of
seed16v[2]. In addition, the previous value of \(X_{i}\) is copied into a 48-bit internal buffer, used only by
seed48(), and a pointer to this buffer is the value returned by seed48(). This returned pointer, which can just be
ignored if not needed, is useful if a program is to be restarted from a given point at some future time—use the pointer to get at
and store the last \(X_{i}\) value, and then use this value to reinitialize via seed48() when the program is restarted.
The initializer function lcong48() allows the user to specify the initial \(X_{i}\), the multiplier value a, and the
addend value c. Argument array elements param[0-2] specify \(X_{i}\), param[3-5] specify the
multiplier a, and param[6] specifies the 16-bit addend c. After lcong48() is called, a subsequent call to
either srand48() or seed48() shall restore the standard multiplier and addend values, a and c,
specified above.
The drand48(), lrand48(), and mrand48() functions need not be thread-safe.
RETURN VALUE
As described in the DESCRIPTION above.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
The following program tests that the required pseudo-random number generator is used by these functions.
#include
#include
int main() {
{
unsigned short xsubi[3] = {37174, 64810, 11603};
double d = erand48(xsubi);
assert(d >= 0.896);
assert(d = 0.337);
assert(d = 0.647);
assert(d = 0.500);
assert(d = 0.506);
assert(d
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
A note indicating that the drand48(), lrand48(), and mrand48() functions need not be reentrant is added to
the DESCRIPTION.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0083 [743] is applied.
Issue 8
Austin Group Defect 1107 is applied, clarifying how the return value is calculated from  \(X_{i}\) for each function.
Austin Group Defect 1134 is applied, adding getentropy().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/faccessat.html =====
access
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
access, faccessat — determine accessibility of a file descriptor
SYNOPSIS
#include
int access(const char *path, int amode);
[OH] #include
int faccessat(int fd, const char *path, int amode, int
flag);
DESCRIPTION
The access() function shall check the file named by the pathname pointed to by the path argument for accessibility
according to the bit pattern contained in amode. The checks for accessibility (including directory permissions checked
during pathname resolution) shall be performed using the real user ID in place of the effective user ID and the real group ID in
place of the effective group ID.
The value of amode is either the bitwise-inclusive OR of the access permissions to be checked (R_OK, W_OK, X_OK) or the
existence test (F_OK).
If any access permissions are checked, each shall be checked individually, as described in XBD 4.7 File Access Permissions, except that where that description refers to
execute permission for a process with appropriate privileges, an implementation may indicate success for X_OK even if execute
permission is not granted to any user.
The faccessat() function, when called with a flag value of zero, shall be equivalent to the access()
function, except in the case where path specifies a relative path. In this case the file whose accessibility is to be
determined shall be located relative to the directory associated with the file descriptor fd instead of the current working
directory. If the access mode of the open file description associated with the file descriptor is not O_SEARCH, the function shall
check whether directory searches are permitted using the current permissions of the directory underlying the file descriptor. If
the access mode is O_SEARCH, the function shall not perform the check.
If faccessat() is passed the special value AT_FDCWD in the fd parameter, the current working directory shall be
used and, if flag is zero, the behavior shall be identical to a call to access().
Values for flag are constructed by a bitwise-inclusive OR of flags from the following list, defined in :
AT_EACCESS
The checks for accessibility (including directory permissions checked during pathname resolution) shall be performed using the
effective user ID and group ID instead of the real user ID and group ID as required in a call to access().
RETURN VALUE
Upon successful completion, these functions shall return 0. Otherwise, these functions shall return -1 and set errno to
indicate the error.
ERRORS
These functions shall fail if:
[EACCES]
Permission bits of the file mode do not permit the requested access, or search permission is denied on a component of the path
prefix.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of path does not name an existing file or path is an empty string.
[ENOTDIR]
A component of the path prefix names an existing file that is neither a directory nor a symbolic link to a directory, or the
path argument contains at least one non- character and ends with one or more trailing  characters
and the last pathname component names an existing file that is neither a directory nor a symbolic link to a directory.
[EROFS]
Write access is requested for a file on a read-only file system.
The faccessat() function shall fail if:
[EACCES]
The access mode of the open file description associated with fd is not O_SEARCH and the permissions of the directory
underlying fd do not permit directory searches.
[EBADF]
The path argument does not specify an absolute path and the fd argument is neither AT_FDCWD nor a valid file
descriptor open for reading or searching.
[ENOTDIR]
The path argument is not an absolute path and fd is a file descriptor associated with a non-directory file.
These functions may fail if:
[EINVAL]
The value of the amode argument is invalid.
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
[ETXTBSY]
Write access is requested for a pure procedure (shared text) file that is being executed.
The faccessat() function may fail if:
[EINVAL]
The value of the flag argument is not valid.
The following sections are informative.
EXAMPLES
Testing for the Existence of a File
The following example tests whether a file named myfile exists in the /tmp directory.
#include
...
int result;
const char *pathname = "/tmp/myfile";
result = access (pathname, F_OK);
APPLICATION USAGE
Use of these functions is discouraged since by the time the returned information is acted upon, it is out-of-date. (That is,
acting upon the information always leads to a time-of-check-to-time-of-use race condition.) An application should instead attempt
the action itself and handle the [EACCES] error that occurs if the file is not accessible (with a change of effective user and
group IDs beforehand, and perhaps a change back afterwards, in the case where access() or faccessat() without
AT_EACCES would have been used.)
Historically, one of the uses of access() was in set-user-ID root programs to check whether the user running the program
had access to a file. This relied on "super-user" privileges which were granted based on the effective user ID being zero, so
that when access() used the real user ID to check accessibility those privileges were not taken into account. On newer
systems where privileges can be assigned which have no association with user or group IDs, if a program with such privileges calls
access(), the change of IDs has no effect on the privileges and therefore they are taken into account in the accessibility
checks. Thus, access() (and faccessat() with flag zero) cannot be used for this historical purpose in such programs.
Likewise, if a system provides any additional or alternate file access control mechanisms that are not user ID-based, they will
still be taken into account.
If a relative pathname is used, no account is taken of whether the current directory (or the directory associated with the file
descriptor fd) is accessible via any absolute pathname. Applications using access(), or faccessat() without
AT_EACCES, may consequently act as if the file would be accessible to a user with the real user ID and group ID of the process when
such a user would not in practice be able to access the file because access would be denied at some point above the current
directory (or the directory associated with the file descriptor fd) in the file hierarchy.
If access() or faccessat() is used with W_OK to check for write access to a directory which has the S_ISVTX bit
set, a return value indicating the directory is writable can be misleading since some operations on files in the directory would
not be permitted based on the ownership of those files (see XBD 4.5 Directory
Protection).
Additional values of amode other than the set defined in the description may be valid; for example, if a system has
extended access controls.
The use of the AT_EACCESS value for flag enables functionality not available in access().
RATIONALE
In early proposals, some inadequacies in the access() function led to the creation of an eaccess() function
because:
Historical implementations of access() do not test file access correctly when the process' real user ID is superuser. In
particular, they always return zero when testing execute permissions without regard to whether the file is executable.
The superuser has complete access to all files on a system. As a consequence, programs started by the superuser and switched to
the effective user ID with lesser privileges cannot use access() to test their file access permissions.
However, the historical model of eaccess() does not resolve problem (1), so this volume of POSIX.1-2024 now allows
access() to behave in the desired way because several implementations have corrected the problem. It was also argued that
problem (2) is more easily solved by using open(), chdir(), or one of the exec functions as
appropriate and responding to the error, rather than creating a new function that would not be as reliable. Therefore,
eaccess() is not included in this volume of POSIX.1-2024.
The sentence concerning appropriate privileges and execute permission bits reflects the two possibilities implemented by
historical implementations when checking superuser access for X_OK.
New implementations are discouraged from returning X_OK unless at least one execution permission bit is set.
The purpose of the faccessat() function is to enable the checking of the accessibility of files in directories other than
the current working directory without exposure to race conditions. Any part of the path of a file could be changed in parallel to a
call to access(), resulting in unspecified behavior. By opening a file descriptor for the target directory and using the
faccessat() function it can be guaranteed that the file tested for accessibility is located relative to the desired
directory.
FUTURE DIRECTIONS
These functions may be formally deprecated (for example, by shading them OB) in a future version of this standard.
SEE ALSO
chmod(), fstatat()
XBD 4.7 File Access Permissions, ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The [ELOOP] mandatory error condition is added.
A second [ENAMETOOLONG] is added as an optional error condition.
The [ETXTBSY] optional error condition is added.
The following changes were made to align with the IEEE P1003.1a draft standard:
The [ELOOP] optional error condition is added.
Issue 7
Austin Group Interpretations 1003.1-2001 #046 and #143 are applied.
The faccessat() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 2.
Changes are made to allow a directory to be opened for searching.
The [ENOTDIR] error condition is clarified to cover the condition where the last component of a pathname exists but is not a
directory or a symbolic link to a directory.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0019 [461], XSH/TC1-2008/0020 [324], XSH/TC1-2008/0021 [278],
XSH/TC1-2008/0022 [278], and XSH/TC1-2008/0023 [291] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0037 [873], XSH/TC2-2008/0038 [591], XSH/TC2-2008/0039 [838],
XSH/TC2-2008/0040 [817], XSH/TC2-2008/0041 [487], XSH/TC2-2008/0042 [838], XSH/TC2-2008/0043 [817], and XSH/TC2-2008/0044 [838] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_rwlock_clockrdlock.html =====
pthread_rwlock_clockrdlock
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_rwlock_clockrdlock, pthread_rwlock_timedrdlock — lock a read-write lock for reading
SYNOPSIS
#include
int pthread_rwlock_clockrdlock(pthread_rwlock_t *restrict rwlock,
clockid_t clock_id, const struct timespec *restrict
abstime);
int pthread_rwlock_timedrdlock(pthread_rwlock_t *restrict rwlock,
const struct timespec *restrict abstime);
DESCRIPTION
The pthread_rwlock_clockrdlock() and pthread_rwlock_timedrdlock() functions shall apply a read lock to the
read-write lock referenced by rwlock as in the pthread_rwlock_rdlock() function. However, if the lock cannot be acquired
without waiting for other threads to unlock the lock, this wait shall be terminated when the specified timeout expires. The timeout
shall expire when the absolute time specified by abstime passes, as measured by the clock on which timeouts are based (that
is, when the value of that clock equals or exceeds abstime), or if the absolute time specified by abstime has already
been passed at the time of the call.
For pthread_rwlock_timedrdlock(), the timeout shall be based on the CLOCK_REALTIME clock. For
pthread_rwlock_clockrdlock(), the timeout shall be based on the clock specified by the clock_id argument. The
resolution of the timeout shall be the resolution of the clock on which it is based. Implementations shall support passing
CLOCK_REALTIME and CLOCK_MONOTONIC to pthread_rwlock_clockrdlock() as the clock_id argument.
Under no circumstances shall the function fail with a timeout if the lock can be acquired immediately. The validity of the
abstime parameter need not be checked if the lock can be immediately acquired.
If a signal that causes a signal handler to be executed is delivered to a thread blocked on a read-write lock via a call to
pthread_rwlock_clockrdlock() or pthread_rwlock_timedrdlock(), upon return from the signal handler the thread shall
resume waiting for the lock as if it was not interrupted.
The calling thread may deadlock if at the time the call is made it holds a write lock on rwlock. The results are
undefined if these functions are called with an uninitialized read-write lock.
RETURN VALUE
The pthread_rwlock_clockrdlock() and pthread_rwlock_timedrdlock() functions shall return zero if the lock for
reading on the read-write lock object referenced by rwlock is acquired. Otherwise, an error number shall be returned to
indicate the error.
ERRORS
The pthread_rwlock_clockrdlock() and pthread_rwlock_timedrdlock() functions shall fail if:
[ETIMEDOUT]
The lock could not be acquired before the specified timeout expired.
The pthread_rwlock_clockrdlock() and pthread_rwlock_timedrdlock() functions may fail if:
[EAGAIN]
The read lock could not be acquired because the maximum number of read locks for lock would be exceeded.
[EDEADLK]
A deadlock condition was detected or the calling thread already holds a write lock on rwlock.
[EINVAL]
The abstime nanosecond value is less than zero or greater than or equal to 1000 million, or the
pthread_rwlock_clockrdlock() function was passed an invalid or unsupported clock_id value.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications using these functions may be subject to priority inversion, as discussed in XBD 3.275 Priority Inversion.
RATIONALE
If an implementation detects that the value specified by the rwlock argument to pthread_rwlock_clockrdlock() or
pthread_rwlock_timedrdlock() does not refer to an initialized read-write lock object, it is recommended that the function
should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_rwlock_clockwrlock(), pthread_rwlock_destroy(), pthread_rwlock_rdlock(), pthread_rwlock_trywrlock(), pthread_rwlock_unlock()
XBD 3.275 Priority Inversion, 4.15.2 Memory Synchronization, ,
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1j-2000.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/102 is applied, updating the ERRORS section so that the
[EDEADLK] error includes detection of a deadlock condition.
Issue 7
The pthread_rwlock_timedrdlock() function is moved from the Timeouts option to the Base.
The [EINVAL] error for an uninitialized read-write lock object is removed; this condition results in undefined behavior.
Issue 8
Austin Group Defect 592 is applied, removing text relating to  from
the SYNOPSIS and DESCRIPTION sections.
Austin Group Defects 1216 and 1472 are applied, adding pthread_rwlock_clockrdlock().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/thrd_create.html =====
thrd_create
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
thrd_create — thread creation
SYNOPSIS
#include
int thrd_create(thrd_t *thr, thrd_start_t func, void *arg);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The thrd_create() function shall create a new thread executing func(arg). If the thrd_create()
function succeeds, it shall set the object pointed to by thr to the identifier of the newly created thread. (A thread's
identifier might be reused for a different thread once the original thread has exited and either been detached or joined to another
thread.) The completion of the thrd_create() function shall synchronize with the beginning of the execution of the new
thread.
[CX]  The
signal state of the new thread shall be initialized as follows:
The signal mask shall be inherited from the creating thread.
The set of signals pending for the new thread shall be empty.
The thread-local current locale shall not be inherited from the creating thread.
The floating-point environment shall be inherited from the creating thread.
[XSI]
The alternate stack shall not be inherited from the creating thread.
Returning from func shall have the same behavior as invoking thrd_exit()
with the value returned from func.
If thrd_create() fails, no new thread shall be created and the contents of the location referenced by thr are
undefined.
[CX]  The
thrd_create() function shall not be affected if the calling thread executes a signal handler during the call.
RETURN VALUE
The thrd_create() function shall return thrd_success on success, or thrd_nomem if no memory could be
allocated for the thread requested, or thrd_error if the request could not be honored, [CX]   such as if the
system-imposed limit on the total number of threads in a process {PTHREAD_THREADS_MAX} would be exceeded.
ERRORS
See RETURN VALUE.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
There is no requirement on the implementation that the ID of the created thread be available before the newly created thread
starts executing. The calling thread can obtain the ID of the created thread through the thr argument of the
thrd_create() function, and the newly created thread can obtain its ID by a call to thrd_current().
RATIONALE
The thrd_create() function is not affected by signal handlers for the reasons stated in XRAT B.2.3 Error Numbers.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_create(), thrd_current(), thrd_detach(),
thrd_exit(), thrd_join()
XBD 4.15.2 Memory Synchronization,
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sigfillset.html =====
sigfillset
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sigfillset — initialize and fill a signal set
SYNOPSIS
[CX]  #include
int sigfillset(sigset_t *set);
DESCRIPTION
The sigfillset() function shall initialize the signal set pointed to by set, such that all signals defined in this
volume of POSIX.1-2024 are included.
RETURN VALUE
Upon successful completion, sigfillset() shall return 0; otherwise, it shall return -1 and set errno to indicate
the error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
Refer to sigemptyset().
FUTURE DIRECTIONS
None.
SEE ALSO
2.4 Signal Concepts, pthread_sigmask(), sigaction(),
sigaddset(), sigdelset(),
sigemptyset(), sigismember(), sigpending(),
sigsuspend()
XBD
CHANGE HISTORY
First released in Issue 3. Included for alignment with the POSIX.1-1988 standard.
Issue 6
The SYNOPSIS is marked CX since the presence of this function in the  header is an extension over the ISO C standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/vswscanf.html =====
vfwscanf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
vfwscanf, vswscanf, vwscanf — wide-character formatted input of a stdarg argument list
SYNOPSIS
#include
#include
#include
int vfwscanf(FILE *restrict stream, const wchar_t *restrict format,
va_list arg);
int vswscanf(const wchar_t *restrict ws, const wchar_t *restrict format,
va_list arg);
int vwscanf(const wchar_t *restrict format, va_list arg);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The vfwscanf(), vswscanf(), and vwscanf() functions shall be equivalent to the fwscanf(), swscanf(), and wscanf() functions, respectively, except that instead of being called with a variable number
of arguments, they are called with an argument list as defined in the  header. These functions shall not invoke the va_end macro. As these
functions invoke the va_arg macro, the value of ap after the return is unspecified.
RETURN VALUE
Refer to fwscanf().
ERRORS
Refer to fwscanf().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications using these functions should call va_end(ap) afterwards to clean up.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fwscanf()
XBD , ,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0706 [14] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fmaxf.html =====
fmax
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fmax, fmaxf, fmaxl — determine maximum numeric value of two floating-point numbers
SYNOPSIS
#include
double fmax(double x, double y);
float fmaxf(float x, float y);
long double fmaxl(long double x, long double y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall determine the maximum numeric value of their arguments. [MX]   NaN arguments
shall be treated as missing data: if one argument is a NaN and the other numeric, then these functions shall choose the numeric
value.
RETURN VALUE
Upon successful completion, these functions shall return the maximum numeric value of their arguments.
[MX]  The
returned value shall be exact and shall be independent of the current rounding direction mode.
If just one argument is a NaN, the other argument shall be returned.
If x and y are NaN, a NaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
fdim(), fmin()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
Austin Group Interpretation 1003.1-2001 #007 is applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/tmpnam.html =====
tmpnam
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
tmpnam — create a name for a temporary file
SYNOPSIS
[OB]  #include
char *tmpnam(char *s);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The tmpnam() function shall generate a string that is a valid pathname that does not name an existing file. The function
is potentially capable of generating {TMP_MAX} different strings, but any or all of them may already be in use by existing files
and thus not be suitable return values.
The tmpnam() function generates a different string each time it is called from the same process, up to {TMP_MAX} times.
If it is called more than {TMP_MAX} times, the behavior is implementation-defined.
The implementation shall behave as if no function defined in this volume of POSIX.1-2024 calls tmpnam().
If called with a null pointer argument, the tmpnam() function need not be thread-safe; however, such calls shall avoid
data races with calls to tmpnam() with a non-null argument and with calls to all other functions.
RETURN VALUE
Upon successful completion, tmpnam() shall return a pointer to a string. If no suitable string can be generated, the
tmpnam() function shall return a null pointer.
If the argument s is a null pointer, tmpnam() shall leave its result in an internal static object and return a
pointer to that object. Subsequent calls to tmpnam() may modify the same object. If the argument s is not a null
pointer, it is presumed to point to an array of at least L_tmpnam chars; tmpnam() shall write its result in that
array and shall return the argument as its value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
Generating a Pathname
The following example generates a unique pathname and stores it in the array pointed to by ptr.
#include
...
char pathname[L_tmpnam+1];
char *ptr;
ptr = tmpnam(pathname);
APPLICATION USAGE
This function only creates pathnames. It is the application's responsibility to create and remove the files.
Between the time a pathname is created and the file is opened, it is possible for some other process to create a file with the
same name. Applications may find tmpfile() more useful.
Applications should use the tmpfile(), mkostemp(), mkstemp(), or mkdtemp() functions instead of the obsolescent tmpnam() function.
RATIONALE
None.
FUTURE DIRECTIONS
The tmpnam() function may be removed in a future version, but not until after it has been removed from the ISO C
standard.
SEE ALSO
fopen(), open(), mkdtemp(), tmpfile(), unlink()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Threads Extension.
Issue 6
Extensions beyond the ISO C standard are marked.
The normative text is updated to avoid use of the term "must" for application requirements.
The DESCRIPTION is expanded for alignment with the ISO/IEC 9899:1999 standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/142 is applied, updating the DESCRIPTION to allow
implementations of the tempnam() function to call tmpnam().
Issue 7
Austin Group Interpretation 1003.1-2001 #148 is applied, clarifying that the tmpnam() function need not be thread-safe if
called with a NULL parameter.
The tmpnam() function is marked obsolescent.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0669 [291] and XSH/TC1-2008/0670 [291,429] are applied.
Issue 8
Austin Group Defect 411 is applied, adding mkostemp().
Austin Group Defect 1302 is applied, aligning this function with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1330 is applied, changing the FUTURE DIRECTIONS section and removing obsolescent interfaces.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/poll.html =====
poll
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
poll, ppoll — input/output multiplexing
SYNOPSIS
#include
int poll(struct pollfd fds[], nfds_t nfds, int timeout);
int ppoll(struct pollfd fds[], nfds_t nfds,
const struct timespec *restrict timeout,
const sigset_t *restrict sigmask);
DESCRIPTION
The ppoll() function provides applications with a mechanism for multiplexing input/output over a set of file descriptors.
For each member of the array pointed to by fds, ppoll() shall examine the given file descriptor for the event(s)
specified in events. The number of pollfd structures in the fds array is specified by nfds. The
ppoll() function shall identify those file descriptors on which an application can make an attempt to read or write data
without blocking, or on which certain events have occurred.
The poll() function shall be equivalent to the ppoll() function, except as follows:
For the poll() function, the timeout period is given in milliseconds in an argument of type int, whereas for the
ppoll() function the timeout period is given in seconds and nanoseconds via an argument of type pointer to struct
timespec. A timeout of -1 for poll() shall be equivalent to passing a null pointer for the timeout for
ppoll().
The poll() function has no sigmask argument; it shall behave as ppoll() does when sigmask is a null
pointer.
The fds argument specifies the file descriptors to be examined and the events of interest for each file descriptor. It is
a pointer to an array with one member for each open file descriptor of interest. The array's members are pollfd structures
within which fd specifies an open file descriptor and events and revents are bitmasks constructed by OR'ing a
combination of the following event flags:
POLLIN
The file descriptor is ready for reading data other than high-priority data.
POLLRDNORM
The file descriptor is ready for reading normal data.
POLLRDBAND
The file descriptor is ready for reading priority data.
POLLPRI
The file descriptor is ready for reading high-priority data.
POLLOUT
The file descriptor is ready for writing normal data.
POLLWRNORM
Equivalent to POLLOUT.
POLLWRBAND
The file descriptor is ready for writing priority data.
POLLERR
An error condition is present on the file descriptor. All error conditions that arise solely from the state of the object
underlying the open file description and would be diagnosed by a return of -1 from a read() or write() call on the file descriptor
shall be reported as a POLLERR event. This flag is only valid in the revents bitmask; it shall be ignored in the
events member.
POLLHUP
A device has been disconnected, or a pipe or FIFO has been closed by the last process that had it open for writing. Once set,
the hangup state of a FIFO shall persist until some process opens the FIFO for writing or until all read-only file descriptors for
the FIFO are closed. This event and POLLOUT are mutually-exclusive. However, this event and POLLIN, POLLRDNORM, POLLRDBAND, or
POLLPRI are not mutually-exclusive. This flag is only valid in the revents bitmask; it shall be ignored in the events
member.
POLLNVAL
The specified fd value is not an open file descriptor. This flag is only valid in the revents member; it shall be
ignored in the events member.
A file descriptor shall be considered ready for reading when a call to an input function with O_NONBLOCK clear would not block,
whether or not the function would transfer data successfully. (The function might return data, an end-of-file indication, or an
error other than one indicating that it is blocked, and in each of these cases the descriptor is considered ready for reading.) A
file descriptor shall be considered ready for writing when a call to an output function with O_NONBLOCK clear would not block,
whether or not the function would transfer data successfully. How much data could be written without blocking depends upon the
object underlying the open file description and its current state.
The significance and semantics of normal, priority, and high-priority data are file and device-specific. The semantics of device
disconnection are device-specific.
If the value of fd is less than 0, events shall be ignored, and revents shall be set to 0 in that entry on
return from poll() or ppoll().
In each pollfd structure, poll() or ppoll() shall clear the revents member, except that where the
application requested a report on a condition by setting one of the bits of events listed above, poll() or
ppoll() shall set the corresponding bit in revents if the requested condition is true. In addition, poll() or
ppoll() shall set the POLLHUP, POLLERR, and POLLNVAL flag in revents if the condition is true, even if the
application did not set the corresponding bit in events.
The timeout argument controls how long the poll() or ppoll() function shall wait before timing out. If the
timeout argument is positive for poll() or not a null pointer for ppoll(), it specifies a maximum interval to
wait for the poll to complete. If the specified time interval expires without any of the defined events having occurred, the
function shall return. If the timeout argument is -1 for poll() or a null pointer for ppoll(), then the call
shall block indefinitely until at least one descriptor meets the specified criteria or until the call is interrupted. To effect a
poll, the application shall ensure that the timeout argument for poll() is 0, or for ppoll() is not a null
pointer and points to a zero-valued timespec structure.
Implementations may place limitations on the maximum timeout interval supported. All implementations shall support a maximum
timeout interval of at least 31 days for ppoll(). If the timeout argument specifies a timeout interval greater than
the implementation-defined maximum value, the maximum value shall be used as the actual timeout value. Implementations may also
place limitations on the granularity of timeout intervals. If the requested timeout interval requires a finer granularity than the
implementation supports, the actual timeout interval shall be rounded up to the next supported value.
The poll() and ppoll() functions shall not be affected by the O_NONBLOCK flag.
The poll() and ppoll() functions shall support regular files, terminal and pseudo-terminal devices, FIFOs, pipes,
and sockets. The behavior of poll() and ppoll() on elements of fds that refer to other types of file is
unspecified.
Regular files shall always poll TRUE for reading and writing.
A file descriptor for a socket that is listening for connections shall indicate that it is ready for reading, once connections
are available. A file descriptor for a socket that is connecting asynchronously shall indicate that it is ready for writing, once a
connection has been established.
Provided the application does not perform any action that results in unspecified or undefined behavior, the value of the
fd and events members of each element of fds shall not be modified by poll() or ppoll().
If sigmask is not a null pointer, the ppoll() function shall replace the signal mask of the caller by the set of
signals pointed to by sigmask before examining the descriptors, and shall restore the signal mask of the calling thread
before returning. If a signal is unmasked as a result of the signal mask being altered by ppoll(), and a signal-catching
function is called for that signal during the execution of the ppoll() function, and SA_RESTART is clear for the
interrupting signal, then
If none of the defined events have occurred on any selected file descriptor, ppoll() shall immediately fail with the
[EINTR] error after the signal-catching function returns.
If one or more of the defined events have occurred, it is unspecified whether ppoll() behaves the same as if none of the
events had occurred (failing with [EINTR] as above) or behaves the same as if it was not interrupted (returning the total number of
pollfd structures that have selected events).
If a thread is canceled during a ppoll() call, it is unspecified whether the signal mask in effect when executing the
registered cleanup functions is the original signal mask or the signal mask installed as part of the ppoll() call.
RETURN VALUE
Upon successful completion, a non-negative value shall be returned. A positive value shall indicate the total number of
pollfd structures that have selected events (that is, those for which the revents member is non-zero). A value of 0
shall indicate that the call timed out and no file descriptors have been selected. Upon failure, -1 shall be returned and
errno set to indicate the error.
ERRORS
The poll() and ppoll() functions shall fail if:
[EAGAIN]
The allocation of internal data structures failed but a subsequent request may succeed.
[EINTR]
A signal was caught during poll() or ppoll().
[EINVAL]
The nfds argument is greater than {OPEN_MAX}.
The ppoll() function shall fail if:
[EINVAL]
An invalid timeout interval was specified.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Other than the difference in the precision of the requested timeout, the following ppoll() call:
ready = ppoll(&fds, nfds, tmo_p, &sigmask);
is equivalent to atomically executing the following calls:
sigset_t origmask;
int timeout;
timeout = (tmo_p == NULL) ? -1 :
(tmo_p->tv_sec * 1000 + tmo_p->tv_nsec / 1000000);
pthread_sigmask(SIG_SETMASK, &sigmask, &origmask);
ready = poll(&fds, nfds, timeout);
pthread_sigmask(SIG_SETMASK, &origmask, NULL);
When a poll() or ppoll() call indicates a file descriptor is ready for reading, this means that if an attempt to
read data had been made at the time that the status of the file descriptor was checked, it would have returned at least one byte of
data, an end-of-file indication, or an error, without blocking (even if O_NONBLOCK is clear). When a poll() or
ppoll() call indicates that a file descriptor is ready for writing, this means that if an attempt to write one byte of data
had been made at the time that the status of the file descriptor was checked, it would have written that byte or returned an error,
without blocking. However, if an attempt to write more than one byte had been made, it might have blocked (if O_NONBLOCK is clear).
In both cases, by the time the call returns and a subsequent I/O operation is attempted, the state of the file descriptor might
have changed (for example, because another thread read or wrote some data) and, if O_NONBLOCK is clear, there is no guarantee that
the operation will not block (unless it would not block for some other reason, such as setting MIN=0 and TIME=0 for a terminal in
non-canonical mode). Therefore it is recommended that applications always set O_NONBLOCK on file descriptors whose readiness for
I/O they query with poll() or ppoll().
The error conditions specified for read() and write() that are reported as POLLERR events are only those that arise solely from the state of
the object underlying the open file description. They do not include, for example, [EAGAIN] as this relates to the state of the
open file description not (solely) the object underlying it.
Application writers should note that repeating a poll() or ppoll() call which indicated that I/O was possible on
one or more of the file descriptors given, without causing some change to the state, either by altering the fds array or
causing appropriate input or output to occur on at least one file descriptor indicated as ready, will result in "busy waiting"—a
subsequent call will always return immediately indicating the same (or perhaps more) events as the previous one.
RATIONALE
The POLLHUP event does not occur for FIFOs just because the FIFO is not open for writing. It only occurs when the FIFO is closed
by the last writer and persists until some process opens the FIFO for writing or until all read-only file descriptors for the FIFO
are closed.
Code which wants to avoid the ambiguity of the signal mask for thread cancellation handlers can install an additional
cancellation handler which resets the signal mask to the expected value:
void cleanup(void *arg)
{
sigset_t *ss = (sigset_t *) arg;
pthread_sigmask(SIG_SETMASK, ss, NULL);
}
int call_ppoll(struct pollfd fds[], nfds_t nfds,
const struct timespec *restrict timeout,
const sigset_t *restrict sigmask)
{
sigset_t oldmask;
int result;
pthread_sigmask(SIG_SETMASK, NULL, &oldmask);
pthread_cleanup_push(cleanup, &oldmask);
result = ppoll(fds, nfds, timeout, sigmask);
pthread_cleanup_pop(0);
return result;
}
FUTURE DIRECTIONS
None.
SEE ALSO
pselect(), read(),
write()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
The description of POLLWRBAND is updated.
Issue 6
Text referring to sockets is added to the DESCRIPTION.
Functionality relating to the XSI STREAMS Option Group is marked.
The Open Group Corrigendum U055/3 is applied, updating the DESCRIPTION of POLLWRBAND.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/66 is applied, correcting the spacing in the EXAMPLES
section.
Issue 7
Austin Group Interpretation 1003.1-2001 #209 is applied, clarifying the POLLHUP event.
The poll() function is moved from the XSI option to the Base.
Functionality relating to the XSI STREAMS option is marked obsolescent.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0249 [623] and XSH/TC2-2008/0250 [683] are applied.
Issue 8
Austin Group Defect 1263 is applied, adding ppoll().
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
Austin Group Defect 1448 is applied, aligning the wording relating to file descriptor readiness with pselect() and changing the APPLICATION USAGE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/scanf.html =====
fscanf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fscanf, scanf, sscanf — convert formatted input
SYNOPSIS
#include
int fscanf(FILE *restrict stream, const char *restrict format, ...);
int scanf(const char *restrict format, ...);
int sscanf(const char *restrict s, const char *restrict format, ...);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The fscanf() function shall read from the named input stream. The scanf() function shall read from the
standard input stream stdin. The sscanf() function shall read from the string s. Each function reads bytes,
interprets them according to a format, and stores the results in its arguments. Each expects, as arguments, a control string
format described below, and a set of pointer arguments indicating where the converted input should be stored. The
result is undefined if there are insufficient arguments for the format. If the format is exhausted while arguments remain, the
excess arguments shall be evaluated but otherwise ignored.
[CX]
Conversions can be applied to the nth argument after the format in the argument list, rather than to the next unused
argument. In this case, the conversion specifier character % (see below) is replaced by the sequence
"%n$", where n is a decimal integer in the range [1,{NL_ARGMAX}]. This feature provides for the
definition of format strings that select arguments in an order appropriate to specific languages. In format strings containing the
"%n$" form of conversion specifications, it is unspecified whether numbered arguments in the argument list
can be referenced from the format string more than once.
The format can contain either form of a conversion specification—that is, % or "%n$"—but the
two forms cannot be mixed within a single format string. The only exception to this is that %% or %* can be mixed
with the "%n$" form. When numbered argument specifications are used, specifying the Nth argument
requires that all the leading arguments, from the first to the (N-1)th, are pointers.
The fscanf() function in all its forms shall allow detection of a language-dependent radix character in the input string.
The radix character is defined in the current locale (category LC_NUMERIC ). In the POSIX locale, or in a locale where the
radix character is not defined, the radix character shall default to a  ('.').
The application shall ensure that the format is a character string, beginning and ending in its initial shift state, if any,
composed of zero or more directives. Each directive is composed of one of the following: one or more white-space bytes; an ordinary
character (neither '%' nor a white-space byte); or a conversion specification. Each conversion specification is introduced
by the character '%' [CX]   or the character sequence "%n$",   after which the following appear in sequence:
An optional assignment-suppressing character '*'.
An optional non-zero decimal integer that specifies the maximum field width.
[CX]  An
optional assignment-allocation character 'm'.
An option length modifier that specifies the size of the receiving object.
A conversion specifier character that specifies the type of conversion to be applied. The valid conversion specifiers are
described below.
The fscanf() functions shall execute each directive of the format in turn. When all directives have been executed, or if
a directive fails (as detailed below), the function shall return. Failures are described as input failures (due to the
unavailability of input bytes) or matching failures (due to inappropriate input).
A directive composed of one or more white-space bytes shall be executed by reading input up to the first non-white-space byte,
which shall remain unread, or until no more bytes can be read. The directive shall never fail.
A directive that is an ordinary character shall be executed as follows: the next byte shall be read from the input and compared
with the byte that comprises the directive; if the comparison shows that they are not equivalent, the directive shall fail, and the
differing and subsequent bytes shall remain unread. Similarly, if end-of-file, an encoding error, or a read error prevents a
character from being read, the directive shall fail.
A directive that is a conversion specification defines a set of matching input sequences, as described below for each conversion
character. A conversion specification shall be executed in the following steps.
Input white-space bytes shall be skipped, unless the conversion specification includes a [, c, C, or
n conversion specifier.
An item shall be read from the input, unless the conversion specification includes an n conversion specifier. An input
item shall be defined as the longest sequence of input bytes (up to any specified maximum field width, which may be measured in
characters or bytes dependent on the conversion specifier) which is an initial subsequence of a matching sequence. The first byte,
if any, after the input item shall remain unread. If the length of the input item is 0, the execution of the conversion
specification shall fail; this condition is a matching failure, unless end-of-file, an encoding error, or a read error prevented
input from the stream, in which case it is an input failure.
Except in the case of a % conversion specifier, the input item (or, in the case of a %n conversion
specification, the count of input bytes) shall be converted to a type appropriate to the conversion character. If the input item is
not a matching sequence, the execution of the conversion specification fails; this condition is a matching failure. Unless
assignment suppression was indicated by a '*', the result of the conversion shall be placed in the object pointed to by
the first argument following the format argument that has not already received a conversion result if the conversion
specification is introduced by %, [CX]   or in the nth argument if introduced by the character
sequence "%n$".  If this object does not
have an appropriate type, or if the result of the conversion cannot be represented in the space provided, the behavior is
undefined.
[CX]  The
c, s, and [ conversion specifiers shall accept an optional assignment-allocation character 'm',
which shall cause a memory buffer to be allocated to hold the conversion results. If the conversion specifier is s or
[, the allocated buffer shall include space for a terminating null character (or wide character). In such a case, the
argument corresponding to the conversion specifier should be a reference to a pointer variable that will receive a pointer to the
allocated buffer. The system shall allocate a buffer as if malloc() had been called.
The application shall be responsible for freeing the memory after usage. If there is insufficient memory to allocate a buffer, the
function shall set errno to [ENOMEM] and a conversion error shall result. If the function returns EOF, any memory
successfully allocated for parameters using assignment-allocation character 'm' by this call shall be freed before the
function returns.
The length modifiers and their meanings are:
hh
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to signed char or unsigned char.
h
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to short or unsigned short.
l (ell)
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to long or unsigned long; that a following a, A,
e, E, f, F, g, or G conversion specifier applies to an argument with type
pointer to double; or that a following c, s, or [ conversion specifier applies to an argument
with type pointer to wchar_t. [CX]   If the 'm' assignment-allocation character is specified, the conversion applies to
an argument with the type pointer to a pointer to wchar_t.
ll (ell-ell)
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to long long or unsigned long long.
j
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to intmax_t or uintmax_t.
z
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to size_t or the corresponding signed integer type.
t
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to ptrdiff_t or the corresponding unsigned type.
L
Specifies that a following a, A, e, E, f, F, g, or G
conversion specifier applies to an argument with type pointer to long double.
If a length modifier appears with any conversion specifier other than as specified above, the behavior is undefined.
The following conversion specifiers are valid:
d
Matches an optionally signed decimal integer, whose format is the same as expected for the subject sequence of strtol() with the value 10 for the base argument. In the absence of a size modifier,
the application shall ensure that the corresponding argument is a pointer to int.
i
Matches an optionally signed integer, whose format is the same as expected for the subject sequence of strtol() with 0 for the base argument. In the absence of a size modifier, the
application shall ensure that the corresponding argument is a pointer to int.
o
Matches an optionally signed octal integer, whose format is the same as expected for the subject sequence of strtoul() with the value 8 for the base argument. In the absence of a size modifier,
the application shall ensure that the corresponding argument is a pointer to unsigned.
u
Matches an optionally signed decimal integer, whose format is the same as expected for the subject sequence of strtoul() with the value 10 for the base argument. In the absence of a size modifier,
the application shall ensure that the corresponding argument is a pointer to unsigned.
x
Matches an optionally signed hexadecimal integer, whose format is the same as expected for the subject sequence of strtoul() with the value 16 for the base argument. In the absence of a size modifier,
the application shall ensure that the corresponding argument is a pointer to unsigned.
a, e, f, g
Matches an optionally signed floating-point number, infinity, or NaN, whose format is the same as expected for the subject sequence
of strtod(). In the absence of a size modifier, the application shall ensure that the
corresponding argument is a pointer to float.
If the fprintf() family of functions generates character string representations
for infinity and NaN (a symbolic entity encoded in floating-point format) to support IEEE Std 754-1985, the
fscanf() family of functions shall recognize them as input.
s
Matches a sequence of bytes that are not white-space bytes. If the 'm' assignment-allocation character is not
specified, the application shall ensure that the corresponding argument is a pointer to the initial byte of an array of
char, signed char, or unsigned char large enough to accept the sequence and a terminating null character code,
which shall be added automatically. [CX]   Otherwise, the application shall ensure that the corresponding argument is a pointer to a
pointer to a char.
If an l (ell) qualifier is present, the input is a sequence of characters that begins in the initial shift state. Each
character shall be converted to a wide character as if by a call to the mbrtowc()
function, with the conversion state described by an mbstate_t object initialized to zero before the first character is
converted. If the 'm' assignment-allocation character is not specified, the application shall ensure that the
corresponding argument is a pointer to an array of wchar_t large enough to accept the sequence and the terminating null wide
character, which shall be added automatically. [CX]   Otherwise, the application shall ensure that the corresponding
argument is a pointer to a pointer to a wchar_t.
[
Matches a non-empty sequence of bytes from a set of expected bytes (the scanset). The normal skip over white-space bytes
shall be suppressed in this case. If the 'm' assignment-allocation character is not specified, the application shall
ensure that the corresponding argument is a pointer to the initial byte of an array of char, signed char, or
unsigned char large enough to accept the sequence and a terminating null byte, which shall be added automatically.
[CX]
Otherwise, the application shall ensure that the corresponding argument is a pointer to a pointer to a char.
If an l (ell) qualifier is present, the input is a sequence of characters that begins in the initial shift state. Each
character in the sequence shall be converted to a wide character as if by a call to the mbrtowc() function, with the conversion state described by an mbstate_t object
initialized to zero before the first character is converted. If the 'm' assignment-allocation character is not specified,
the application shall ensure that the corresponding argument is a pointer to an array of wchar_t large enough to accept the
sequence and the terminating null wide character, which shall be added automatically.
[CX]
Otherwise, the application shall ensure that the corresponding argument is a pointer to a pointer to a wchar_t.
The conversion specification includes all subsequent bytes in the format string up to and including the matching
(']'). The bytes between the square brackets (the scanlist) comprise the scanset,
unless the byte after the  is a  ('^'), in which case the scanset contains
all bytes that do not appear in the scanlist between the  and the . If the conversion
specification begins with "[]" or "[^]", the  is included in the scanlist and the
next  is the matching  that ends the conversion specification; otherwise,
the first  is the one that ends the conversion specification. If a '-' is in the scanlist and
is not the first character, nor the second where the first character is a '^', nor the last character, the behavior is
implementation-defined.
c
Matches a sequence of bytes of the number specified by the field width (1 if no field width is present in the conversion
specification). No null byte is added. The normal skip over white-space bytes shall be suppressed in this case. If the 'm'
assignment-allocation character is not specified, the application shall ensure that the corresponding argument is a pointer to the
initial byte of an array of char, signed char, or unsigned char large enough to accept the sequence.
[CX]
Otherwise, the application shall ensure that the corresponding argument is a pointer to a pointer to a char.
If an l (ell) qualifier is present, the input shall be a sequence of characters that begins in the initial shift state.
Each character in the sequence is converted to a wide character as if by a call to the mbrtowc() function, with the conversion state described by an mbstate_t object
initialized to zero before the first character is converted. No null wide character is added. If the 'm'
assignment-allocation character is not specified, the application shall ensure that the corresponding argument is a pointer to an
array of wchar_t large enough to accept the resulting sequence of wide characters. [CX]   Otherwise, the
application shall ensure that the corresponding argument is a pointer to a pointer to a wchar_t.
p
Matches an implementation-defined set of sequences, which shall be the same as the set of sequences that is produced by the
%p conversion specification of the corresponding fprintf() functions. The
application shall ensure that the corresponding argument is a pointer to a pointer to void. The interpretation of the input
item is implementation-defined. If the input item is a value converted earlier during the same program execution, the pointer that
results shall compare equal to that value; otherwise, the behavior of the %p conversion specification is undefined.
n
No input is consumed. The application shall ensure that the corresponding argument is a pointer to the integer into which shall
be written the number of bytes read from the input so far by this call to the fscanf() functions. Execution of a %n
conversion specification shall not increment the assignment count returned at the completion of execution of the function. No
argument shall be converted, but one shall be consumed. If the conversion specification includes an assignment-suppressing
character or a field width, the behavior is undefined.
C
[XSI]
Equivalent to lc.
S
[XSI]
Equivalent to ls.
%
Matches a single '%' character; no conversion or assignment occurs. The complete conversion specification shall be
%%.
If a conversion specification is invalid, the behavior is undefined.
The conversion specifiers A, E, F, G, and X are also valid and shall be equivalent
to a, e, f, g, and x, respectively.
If end-of-file is encountered during input, conversion shall be terminated. If end-of-file occurs before any bytes matching the
current conversion specification (except for %n) have been read (other than leading white-space bytes, where permitted),
execution of the current conversion specification shall terminate with an input failure. Otherwise, unless execution of the current
conversion specification is terminated with a matching failure, execution of the following conversion specification (if any) shall
be terminated with an input failure.
Reaching the end of the string in sscanf() shall be equivalent to encountering end-of-file for fscanf().
If conversion terminates on a conflicting input, the offending input is left unread in the input. Any trailing white-space bytes
(including  characters) shall be left unread unless matched by a conversion specification. The success of literal
matches and suppressed assignments is only directly determinable via the %n conversion specification.
[CX]  The
fscanf() and scanf() functions may mark the last data access timestamp of the file associated with stream for
update. The last data access timestamp shall be marked for update by the first successful execution of fgetc(), fgets(), fread(), getc(), getchar(), getdelim(), getline(), fscanf(), or scanf() using stream that returns data not
supplied by a prior call to ungetc().
RETURN VALUE
Upon successful completion, these functions shall return the number of successfully matched and assigned input items; this
number can be zero in the event of an early matching failure. If the input ends before the first conversion (if any) has completed,
and without a matching failure having occurred, EOF shall be returned. If an error occurs before the first conversion (if any) has
completed, and without a matching failure having occurred, EOF shall be returned [CX]   and
errno shall be set to indicate the error.   If an error
occurs, the error indicator for the stream shall be set.
ERRORS
For the conditions under which the fscanf() functions fail and may fail, refer to fgetc() or fgetwc().
In addition, the fscanf() function shall fail if:
[EILSEQ]
[CX]
Input byte sequence does not form a valid character.
[ENOMEM]
Insufficient storage space is available.
In addition, the fscanf() function may fail if:
[EINVAL]
[CX]
There are insufficient arguments.
The following sections are informative.
EXAMPLES
The call:
int i, n; float x; char name[50];
n = scanf("%d%f%s", &i, &x, name);
with the input line:
25 54.32E-1 Hamster
assigns to n the value 3, to i the value 25, to x the value 5.432, and name contains the string
"Hamster".
The call:
int i; float x; char name[50];
(void) scanf("%2d%f%*d %[0123456789]", &i, &x, name);
with input:
56789 0123 56a72
assigns 56 to i, 789.0 to x, skips 0123, and places the string "56\0" in name. The next call to
getchar() shall return the character 'a'.
Reading Data into an Array
The following call uses fscanf() to read three floating-point numbers from standard input into the input
array.
float input[3]; fscanf (stdin, "%f %f %f", input, input+1, input+2);
APPLICATION USAGE
If the application calling fscanf() has any objects of type wint_t or wchar_t, it must also include the
header to have these objects defined.
For functions that allocate memory as if by malloc(), the application should
release such memory when it is no longer required by a call to free(). For
fscanf(), this is memory allocated via use of the 'm' assignment-allocation character.
RATIONALE
The set of characters allowed in a scanset is limited to single-byte characters. In other similar places, multi-byte characters
have been permitted, but for alignment with the ISO C standard, it has not been done here. Applications needing this could use
the corresponding wide-character functions to achieve the desired results.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fprintf(), getc(), setlocale(), strtod(), strtol(), strtoul(), wcrtomb()
XBD 7. Locale, , ,
,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
Aligned with ISO/IEC 9899:1990/Amendment 1:1995 (E). Specifically, the l (ell) qualifier is now defined for the
c, s, and [ conversion specifiers.
The DESCRIPTION is updated to indicate that if infinity and NaN can be generated by the fprintf() family of functions, then they are recognized by the fscanf() family.
Issue 6
The Open Group Corrigenda U021/7 and U028/10 are applied. These correct several occurrences of "characters" in the text which
have been replaced with the term "bytes".
The normative text is updated to avoid use of the term "must" for application requirements.
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The prototypes for fscanf(), scanf(), and sscanf() are updated.
The DESCRIPTION is updated.
The hh, ll, j, t, and z length modifiers are added.
The a, A, and F conversion characters are added.
The DESCRIPTION is updated to use the terms "conversion specifier" and "conversion specification" consistently.
Issue 7
Austin Group Interpretation 1003.1-2001 #170 is applied.
SD5-XSH-ERN-9 is applied, correcting fscanf() to scanf() in the DESCRIPTION.
SD5-XSH-ERN-132 is applied, adding the assignment-allocation character 'm'.
Functionality relating to the %n$ form of conversion specification is moved from the XSI option to the Base.
Changes are made related to support for finegrained timestamps.
The APPLICATION USAGE section is updated to clarify that memory is allocated as if by malloc().
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0185 [302], XSH/TC1-2008/0186 [90], and XSH/TC1-2008/0187 [14] are applied.
XSH/TC1-2008/0186 [90] changes the second sentence in the RETURN VALUE section to align with expected wording changes in the next
revision of the ISO C standard.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0135 [936] is applied.
Issue 8
Austin Group Defect 1163 is applied, clarifying the handling of white space in the format string.
Austin Group Defect 1173 is applied, clarifying the description of the assignment-allocation character 'm'.
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
Austin Group Defect 1375 is applied, changing "terminating null character" to "terminating null character (or wide
character)".
Austin Group Defect 1562 is applied, clarifying that it is the application's responsibility to ensure that the format is a
character string, beginning and ending in its initial shift state, if any.
Austin Group Defect 1624 is applied, changing the RETURN VALUE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_detach.html =====
pthread_detach
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_detach — detach a thread
SYNOPSIS
#include
int pthread_detach(pthread_t thread);
DESCRIPTION
The pthread_detach() function shall change the thread thread from joinable to detached, indicating to the
implementation that storage for the thread can be reclaimed when the thread terminates. If thread has not terminated,
pthread_detach() shall not cause it to terminate, but shall prevent the thread from becoming a zombie thread when it does
terminate.
The behavior is undefined if the value specified by the thread argument to pthread_detach() does not refer to a
joinable thread.
RETURN VALUE
If the call succeeds, pthread_detach() shall return 0; otherwise, an error number shall be returned to indicate the
error.
ERRORS
The pthread_detach() function shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The pthread_join() or pthread_detach() functions should eventually be
called for every thread that is created so that storage associated with the thread may be reclaimed.
It has been suggested that a "detach" function is not necessary; the detachstate thread creation attribute is
sufficient, since a thread need never be dynamically detached. However, need arises in at least two cases:
In a cancellation handler for a pthread_join() it is nearly essential to
have a pthread_detach() function in order to detach the thread on which pthread_join() was waiting. Without it, it would be necessary to have the handler do
another pthread_join() to attempt to detach the thread, which would both delay
the cancellation processing for an unbounded period and introduce a new call to pthread_join(), which might itself need a cancellation handler. A dynamic detach is
nearly essential in this case.
In order to detach the "initial thread" (as may be desirable in processes that set up server threads).
If an implementation detects that the value specified by the thread argument to pthread_detach() does not refer to
a joinable thread, it is recommended that the function should fail and report an [EINVAL] error.
If an implementation detects use of a thread ID after the end of its lifetime, it is recommended that the function should fail
and report an [ESRCH] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_join()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_detach() function is marked as part of the Threads option.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/95 is applied, updating the ERRORS section so that the [EINVAL]
and [ESRCH] error cases become optional.
Issue 7
The pthread_detach() function is moved from the Threads option to the Base.
Austin Group Interpretation 1003.1-2001 #142 is applied, removing the [ESRCH] error condition.
The [EINVAL] error for a non-joinable thread is removed; this condition results in undefined behavior.
Issue 8
Austin Group Defect 792 is applied, clarifying that detaching a live thread prevents it becoming a zombie thread when it
terminates.
Austin Group Defect 1167 is applied, clarifying that a thread is no longer joinable after pthread_detach() has been
called for it.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/rint.html =====
rint
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
rint, rintf, rintl — round-to-nearest integral value
SYNOPSIS
#include
double rint(double x);
float rintf(float x);
long double rintl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall return the integral value (represented as a double) nearest x in the direction of the
current rounding mode. The current rounding mode is implementation-defined.
If the current rounding mode rounds toward negative infinity, then rint() shall be equivalent to floor(). If the current rounding mode rounds toward positive infinity, then rint()
shall be equivalent to ceil(). If the current rounding mode rounds towards zero, then
rint() shall be equivalent to trunc(). [MX]   If the current
rounding mode rounds towards nearest, then rint() differs from round() in that
halfway cases are rounded to even rather than away from zero.
These functions differ from the nearbyint(), nearbyintf(), and nearbyintl()
functions only in that they may raise the inexact floating-point exception if the result differs in value from the argument.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the integer (represented as a double precision number) nearest x
in the direction of the current rounding mode. [MX]   The result shall have the same sign as x.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0 or ±Inf, x shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The integral value returned by these functions need not be expressible as an intmax_t. The return value should be tested
before assigning it to an integer type to avoid the undefined results of an integer overflow.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
abs(), ceil(), feclearexcept(), fetestexcept()
, floor(), isnan(), nearbyint()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The rintf() and rintl() functions are added.
The rint() function is no longer marked as an extension.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0514 [346], XSH/TC1-2008/0515 [346], XSH/TC1-2008/0516 [346],
XSH/TC1-2008/0517 [346], and XSH/TC1-2008/0518 [346] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/textdomain.html =====
bindtextdomain
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
bindtextdomain, bind_textdomain_codeset, textdomain — text domain manipulation functions
SYNOPSIS
#include
char *bindtextdomain(const char *domainname, const char *dirname);
char *bind_textdomain_codeset(const char *domainname,
const char *codeset);
char *textdomain(const char *domainname);
DESCRIPTION
The textdomain() function shall set or query the name of the current text domain of the calling process. The application
shall ensure that the domainname argument is either a null pointer (when querying), an empty string, or a string that, when
used by the gettext family of functions to construct a pathname to a messages object, results in a valid pathname. For
portable applications, it should only contain characters from the portable filename character set.
The text domain setting made by the last successful call to textdomain() shall remain in effect across subsequent calls
to setlocale(), uselocale(), and
the gettext family of functions.
Applications should not use text domains whose names begin with the strings "SYS_" or "libc". These prefixes
are reserved for implementation use.
The current setting of the text domain can be queried without affecting the current state of the domain by calling
textdomain() with domainname set to a null pointer. Calling textdomain() with a domainname argument of
an empty string shall set the text domain to the default domain, "messages".
The bindtextdomain() function shall set or query the binding of a text domain to a dirname that is used by the
gettext family of functions to construct a pathname to a messages object in the text domain:
If domainname is a null pointer or an empty string, bindtextdomain() shall make no changes and return a null
pointer without changing errno.
Otherwise, if dirname is a non-empty string:
If domainname is not already bound, bindtextdomain() shall bind the text domain specified by domainname to
the pathname pointed to by dirname and return the bound directory pathname on success or a null pointer on failure.
If domainname is already bound, bindtextdomain() shall replace the existing binding with the pathname pointed to
by dirname and return the bound directory pathname on success or a null pointer on failure. On failure, the existing binding
shall remain unchanged.
It is unspecified whether the bindtextdomain() function performs pathname resolution on dirname, or whether that
is done by the gettext family of functions.
Otherwise, if dirname is a null pointer:
If domainname is bound, the function shall return the bound directory pathname.
If domainname is not bound, the function shall return the implementation-defined default directory pathname used by the
gettext family of functions.
Otherwise, dirname is an empty string and the behavior is unspecified.
If a text domain is bound to a relative pathname and the current working directory is changed after the binding is established,
the pathnames used by the gettext family of functions to locate messages objects for that text domain are unspecified.
The bind_textdomain_codeset() function shall set or query the binding of a text domain to the output codeset used by the
gettext family of functions for message strings retrieved from messages objects for the text domain specified by
domainname:
If domainname is a null pointer or an empty string, bind_textdomain_codeset() shall make no changes and return a
null pointer without changing errno.
Otherwise, if codeset is a non-empty string:
If domainname is not already bound, bind_textdomain_codeset() shall bind the text domain specified by
domainname to the codeset pointed to by codeset and return the newly bound codeset on success or a null pointer on
failure.
If domainname is already bound, bind_textdomain_codeset() shall replace the existing binding with the codeset
pointed to by codeset and return the newly bound codeset on success or a null pointer on failure. On failure, the existing
binding shall remain unchanged.
The application shall ensure that the codeset argument, if non-empty, is a valid codeset name that can be used as the
tocode argument of the iconv_open() function, and that in the codeset it
specifies, the  character corresponds to a single null byte.
Otherwise, if codeset is a null pointer:
If domainname is bound, the function shall return the bound codeset.
If domainname is not bound, the function shall return the implementation-defined default codeset used by the
gettext family of functions.
Otherwise, codeset is an empty string and the behavior is unspecified.
If codeset is a null pointer and domainname is a non-empty string, bind_textdomain_codeset() shall return
the current codeset for the named domain, or a null pointer if a codeset has not yet been set. The bind_textdomain_codeset()
function can be called multiple times. If successfully called multiple times with the same domainname argument, the last
such call shall override the setting made by the previous such call.
RETURN VALUE
The return value from a successful textdomain() call shall be a pointer to a string containing the current setting of the
text domain. If domainname is a null pointer, textdomain() shall return a pointer to the string containing the
current text domain. If textdomain() was not previously called and domainname is a null string, the name of the
default text domain shall be returned. The name of the default text domain shall be the string "messages". If
textdomain() fails, a null pointer shall be returned and errno shall be set to indicate the error.
For bindtextdomain() return values see the DESCRIPTION. When bindtextdomain() is called with a non-empty
domainname and returns a null pointer, it shall set errno to indicate the error. When bindtextdomain() returns
a pathname for a bound text domain, the return value shall be a pointer to a copy of the dirname string passed to the
bindtextdomain() call that created the binding. The returned string shall remain valid until the next successful call to
bindtextdomain() with a non-empty dirname and same domainname. The application shall ensure that it does not
modify the returned string.
A call to the bind_textdomain_codeset() function with a non-empty domainname argument shall return one of the
following:
The currently bound codeset name for that text domain if codeset is a null pointer
The newly bound codeset if codeset is non-empty
A null pointer without changing errno if no codeset has yet been bound for that text domain
The application shall ensure that it does not modify the returned string. A subsequent call to bind_textdomain_codeset()
with a non-empty domainname argument might invalidate the returned pointer or overwrite the string content. The returned
pointer might also be invalidated if the calling thread is terminated. If bind_textdomain_codeset() fails, a null pointer
shall be returned and errno shall be set to indicate the error.
ERRORS
For the conditions under which bindtextdomain()—if it performs pathname resolution—fails and may fail, refer to open().
In addition, the textdomain(), bindtextdomain(), and bind_textdomain_codeset() functions may fail if:
[ENOMEM]
Insufficient memory available.
The following sections are informative.
EXAMPLES
See the examples for gettext().
APPLICATION USAGE
A text domainname is limited to {TEXTDOMAIN_MAX} bytes.
Application developers are responsible for ensuring that the text domain used is not used by other applications. To minimize the
chances of collision, developers can prefix text domains with their company or application name (or both) and an underscore. For
example, if your application name was "foo" and you wanted to use the text domain "errors", you could instead use
the text domain "foo_errors". Note that if an application can be installed with a configurable name, a text domain prefix
based on the application name should change with the application name.
Specifying a relative pathname to the bindtextdomain() function should be avoided, since it may result in messages
objects being searched for in a directory relative to the current working directory of the calling process; if the process calls
the chdir() function, the directory searched for may also be changed.
Since pathname resolution of dirname might not be performed by bindtextdomain(), but could be performed later by
the gettext family of functions, and since the latter have no way to report an error, applications should verify, using for
example stat(), that the directory is accessible if this is desired.
RATIONALE
Although the return type of these functions ought to be const char *, it is char * to match historical
practice.
Pathname resolution of the dirname argument passed to bindtextdomain() may be performed by bindtextdomain()
itself or by the gettext family of functions. If pathname resolution fails in one of the gettext family of functions,
it is neither allowed to modify errno nor to return an error, but if pathname resolution fails in bindtextdomain(),
it is required to report an error and set errno just like open() does.
Historically, bindtextdomain() did not perform pathname resolution. However, the standard developers decided to allow
this as an option so that future implementations can, if desired, open a file descriptor for that directory in
bindtextdomain() and then use that file descriptor with openat() in the
gettext family of functions.
The dirname parameter to bindtextdomain() may need to be copied to avoid the possibility of the application
releasing the memory used by the argument while the gettext family of functions may still need to reference it.
When bindtextdomain() is called with a non-empty domainname and an empty dirname, historical
implementations of the gettext family of functions use the empty string for the dirname part of the messages object
pathname, resulting in an absolute pathname of the form /localename/categoryname/textdomainname.mo. The
standard developers did not believe this behavior to be useful. Using the empty dirname case as a way to remove an existing
binding seemed to be a more useful behavior, and would be consistent with the behavior of textdomain(). However, because no
historical implementations behave this way, the behavior is left unspecified.
Some implementations set errno to [EAGAIN] to signal memory allocation failures that might succeed if retried and
[ENOMEM] for failures that are unlikely to ever succeed, for example due to configured limits. 2.3 Error Numbers permits this behavior; when multiple error conditions are
simultaneously true there is no precedence between them.
FUTURE DIRECTIONS
A future version of this standard may require implementations to prefix implementation-provided text domains with either
"SYS_" or a prefix related to the implementor's company name to avoid namespace collisions.
A future version of this standard may require bindtextdomain() to remove any binding for domainname when called
with a non-empty domainname and an empty dirname.
SEE ALSO
gettext(), iconv_open(), setlocale(), uselocale()
XBD ,
XCU msgfmt, xgettext
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/iswupper_l.html =====
iswupper
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
iswupper, iswupper_l — test for an uppercase letter wide-character code
SYNOPSIS
#include
int iswupper(wint_t wc);
[CX]  int iswupper_l(wint_t wc, locale_t locale);
DESCRIPTION
For iswupper(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The iswupper() [CX]   and iswupper_l()
functions shall test whether wc is a wide-character code representing a character of class upper in the current
locale, [CX]   or in the locale represented by locale,
respectively; see XBD 7. Locale.
The wc argument is a wint_t, the value of which the application shall ensure is a wide-character code
corresponding to a valid character in the locale used by the function, or equal to the value of the macro WEOF. If the argument has
any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to iswupper_l() is the special locale object LC_GLOBAL_LOCALE or is not
a valid locale object handle.
RETURN VALUE
The iswupper() [CX]   and iswupper_l()
functions shall return non-zero if wc is an uppercase letter wide-character code; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
iswalnum(), iswalpha(),
iswcntrl(), iswctype(),
iswdigit(), iswgraph(),
iswlower(), iswprint(),
iswpunct(), iswspace(),
iswxdigit(), setlocale(),
uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 4.
Issue 5
The following change has been made in this version for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E):
The SYNOPSIS has been changed to indicate that this function and associated data types are now made visible by inclusion of the
header rather than .
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The iswupper_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0341 [302], XSH/TC1-2008/0342 [283], and XSH/TC1-2008/0343 [283] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0192 [685] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/str2sig.html =====
sig2str
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sig2str, str2sig — translate between signal names and numbers
SYNOPSIS
[CX]  #include
int sig2str(int signum, char *str);
int str2sig(const char *restrict str, int *restrict pnum);
DESCRIPTION
The sig2str() function shall translate the signal number specified by signum to a signal name and shall store this
string in the location specified by str. The application shall ensure that str points to a location that can store
the string including the terminating null byte. The symbolic constant SIG2STR_MAX defined in  gives the maximum number of bytes required.
If signum is equal to 0, the behavior is unspecified.
If signum is equal to one of the symbolic constants listed in the table of signal numbers in , the stored signal name shall be the name of the symbolic constant without
the SIG prefix.
If signum is equal to SIGRTMIN or SIGRTMAX, the stored string shall be "RTMIN" or "RTMAX",
respectively.
If signum is between SIGRTMIN+1 and (SIGRTMIN+SIGRTMAX)/2 inclusive, the stored string shall be of the form
"RTMIN+n", where n is the shortest decimal representation of the value of
signum-SIGRTMIN.
If signum is between (SIGRTMIN+SIGRTMAX)/2 + 1 and SIGRTMAX-1 inclusive, the stored string shall be either of the form
"RTMIN+n" or of the form "RTMAX-m", where n is the shortest decimal
representation of the value of signum-SIGRTMIN and m is the shortest decimal representation of the value of
SIGRTMAX-signum.
If signum is a valid, supported signal number, is either less than SIGRTMIN or greater than SIGRTMAX, and is not equal to
one of the symbolic constants listed in the table of signal numbers in , the stored string shall uniquely identify the signal number signum
in an unspecified manner.
The str2sig() function shall translate the signal name in the string pointed to by str to a signal number and
shall store this value in the location specified by pnum.
If str points to a string containing the name of one of the symbolic constants listed in the table of signal numbers in
, without the SIG prefix, the stored signal number shall be
equal to the value of the symbolic constant.
If str points to the string "RTMIN" or "RTMAX", the stored value shall be equal to SIGRTMIN or
SIGRTMAX, respectively.
If str points to a string of the form "RTMIN+n", where n is a decimal representation of a
number between 1 and SIGRTMAX-SIGRTMIN-1 inclusive, the stored value shall be equal to SIGRTMIN+n.
If str points to a string of the form "RTMAX-n", where n is a decimal representation of a
number between 1 and SIGRTMAX-SIGRTMIN-1 inclusive, the stored value shall be equal to SIGRTMAX-n.
If str points to a string containing a decimal representation of a valid, supported signal number, the value stored in
the location pointed to by pnum shall be equal to that number.
If str points to a string containing a decimal representation of the value 0 and the string was not returned by a
previous successful call to sig2str() with a signum argument of 0, the behavior is unspecified.
If str points to a string returned by a previous successful call to sig2str(signum,str), the value
stored in the location pointed to by pnum shall be equal to signum.
If str points to a string that does not meet any of the above criteria, str2sig() shall store a value in the
location pointed to by pnum if and only if it recognizes the string as an additional implementation-dependent form of signal
name.
RETURN VALUE
If signum is a valid, supported signal number (that is, one for which kill()
does not return -1 with errno set to [EINVAL]), the sig2str() function shall return 0; otherwise, if signum is
not equal to 0, it shall return -1.
If str2sig() stores a value in the location pointed to by pnum, it shall return 0; otherwise, it shall return
-1.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
Historical versions of these functions translated a signum value 0 to "EXIT" (and vice versa), so that they
could be used by the shell for the trap utility. When adding the functions to this
standard, the standard developers felt that they should be aimed at more general-purpose use, and consequently requiring this
behavior did not seem appropriate and so the behavior in this case has been made unspecified.
FUTURE DIRECTIONS
None.
SEE ALSO
kill(), sigaction(),
strsignal()
XBD
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mkfifoat.html =====
mkfifo
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mkfifo, mkfifoat — make a FIFO special file
SYNOPSIS
#include
int mkfifo(const char *path, mode_t mode);
[OH] #include
int mkfifoat(int fd, const char *path, mode_t mode);
DESCRIPTION
The mkfifo() function shall create a new FIFO special file named by the pathname pointed to by path. The file
permission bits of the new FIFO shall be initialized from mode. The file permission bits of the mode argument shall
be modified by the process' file creation mask.
When bits in mode other than the file permission bits are set, the effect is implementation-defined.
If path names a symbolic link, mkfifo() shall fail and set errno to [EEXIST].
The FIFO's user ID shall be set to the process' effective user ID. The FIFO's group ID shall be set to the group ID of the
parent directory or to the effective group ID of the process. Implementations shall provide a way to initialize the FIFO's group ID
to the group ID of the parent directory. Implementations may, but need not, provide an implementation-defined way to initialize the
FIFO's group ID to the effective group ID of the calling process.
Upon successful completion, mkfifo() shall mark for update the last data access, last data modification, and last file
status change timestamps of the file. Also, the last data modification and last file status change timestamps of the directory that
contains the new entry shall be marked for update.
The mkfifoat() function shall be equivalent to the mkfifo() function except in the case where path
specifies a relative path. In this case the newly created FIFO is created relative to the directory associated with the file
descriptor fd instead of the current working directory. If the access mode of the open file description associated with the
file descriptor is not O_SEARCH, the function shall check whether directory searches are permitted using the current permissions of
the directory underlying the file descriptor. If the access mode is O_SEARCH, the function shall not perform the check.
If mkfifoat() is passed the special value AT_FDCWD in the fd parameter, the current working directory shall be
used and the behavior shall be identical to a call to mkfifo().
RETURN VALUE
Upon successful completion, these functions shall return 0. Otherwise, these functions shall return -1 and set errno to
indicate the error. If -1 is returned, no FIFO shall be created.
ERRORS
These functions shall fail if:
[EACCES]
A component of the path prefix denies search permission, or write permission is denied on the parent directory of the FIFO to
be created.
[EEXIST]
The named file already exists.
[EILSEQ]
The last pathname component of path is not a portable filename, and cannot be created in the target directory.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of the path prefix of path does not name an existing file or path is an empty string.
[ENOENT] or [ENOTDIR]
The path argument contains at least one non- character and ends with one or more trailing
characters. If path without the trailing  characters would name an existing file, an [ENOENT] error shall not
occur.
[ENOSPC]
The directory that would contain the new file cannot be extended or the file system is out of file-allocation resources.
[ENOTDIR]
A component of the path prefix names an existing file that is neither a directory nor a symbolic link to a directory.
[EROFS]
The named file resides on a read-only file system.
The mkfifoat() function shall fail if:
[EACCES]
The access mode of the open file description associated with fd is not O_SEARCH and the permissions of the directory
underlying fd do not permit directory searches.
[EBADF]
The path argument does not specify an absolute path and the fd argument is neither AT_FDCWD nor a valid file
descriptor open for reading or searching.
[ENOTDIR]
The path argument is not an absolute path and fd is a file descriptor associated with a non-directory file.
These functions may fail if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
The following sections are informative.
EXAMPLES
Creating a FIFO File
The following example shows how to create a FIFO file named /home/cnd/mod_done, with read/write permissions for owner,
and with read permissions for group and others.
#include
#include
int status;
...
status = mkfifo("/home/cnd/mod_done", S_IWUSR | S_IRUSR |
S_IRGRP | S_IROTH);
APPLICATION USAGE
None.
RATIONALE
The syntax of this function is intended to maintain compatibility with historical implementations of mknod(). The latter function was included in the 1984 /usr/group standard but only for use in
creating FIFO special files. The mknod() function was originally excluded from the
POSIX.1-1988 standard as implementation-defined and replaced by mkdir() and
mkfifo(). The mknod() function is now included for alignment with the Single
UNIX Specification.
The POSIX.1-1990 standard required that the group ID of a newly created FIFO be set to the group ID of its parent directory or
to the effective group ID of the creating process. FIPS 151-2 required that implementations provide a way to have the group ID be
set to the group ID of the containing directory, but did not prohibit implementations also supporting a way to set the group ID to
the effective group ID of the creating process. Conforming applications should not assume which group ID will be used. If it
matters, an application can use chown() to set the group ID after the FIFO is created,
or determine under what conditions the implementation will set the desired group ID.
The purpose of the mkfifoat() function is to create a FIFO special file in directories other than the current working
directory without exposure to race conditions. Any part of the path of a file could be changed in parallel to a call to
mkfifo(), resulting in unspecified behavior. By opening a file descriptor for the target directory and using the
mkfifoat() function it can be guaranteed that the newly created FIFO is located relative to the desired directory.
Implementations are encouraged to have mkfifo() and mkfifoat() report an [EILSEQ] error if the last component of
path contains any bytes that have the encoded value of a  character.
FUTURE DIRECTIONS
None.
SEE ALSO
chmod(), mknod(),
umask()
XBD , ,
CHANGE HISTORY
First released in Issue 3. Included for alignment with the POSIX.1-1988 standard.
Issue 6
In the SYNOPSIS, the optional include of the  header is
removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
The [ELOOP] mandatory error condition is added.
A second [ENAMETOOLONG] is added as an optional error condition.
The following changes were made to align with the IEEE P1003.1a draft standard:
The [ELOOP] optional error condition is added.
Issue 7
Austin Group Interpretation 1003.1-2001 #143 is applied.
The mkfifoat() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 2.
Changes are made related to support for finegrained timestamps.
Changes are made to allow a directory to be opened for searching.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0383 [461], XSH/TC1-2008/0384 [146,435], XSH/TC1-2008/0385 [324],
XSH/TC1-2008/0386 [278], and XSH/TC1-2008/0387 [278] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0216 [873], XSH/TC2-2008/0217 [591], XSH/TC2-2008/0218 [817],
XSH/TC2-2008/0219 [822], XSH/TC2-2008/0220 [817], and XSH/TC2-2008/0221 [591] are applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defect 293 is applied, adding the [EILSEQ] error.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/srand.html =====
rand
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
rand, srand — pseudo-random number generator
SYNOPSIS
#include
int rand(void);
void srand(unsigned seed);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The rand() function shall compute a sequence of pseudo-random integers in the range [0,{RAND_MAX}] [XSI]   with a
period of at least 232.
The rand() function need not be thread-safe; however, rand() shall avoid data races with all functions other than
non-thread-safe pseudo-random sequence generation functions.
The srand() function uses the argument as a seed for a new sequence of pseudo-random numbers to be returned by subsequent
calls to rand(). If srand() is then called with the same seed value, the sequence of pseudo-random numbers shall be
repeated. If rand() is called before any calls to srand() are made, the same sequence shall be generated as when
srand() is first called with a seed value of 1.
The srand() function need not be thread-safe; however, srand() shall avoid data races with all functions other
than non-thread-safe pseudo-random sequence generation functions.
The implementation shall behave as if no function defined in this volume of POSIX.1-2024 calls rand() or
srand().
RETURN VALUE
The rand() function shall return the next pseudo-random number in the sequence.
The srand() function shall not return a value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
Generating a Pseudo-Random Number Sequence
The following example demonstrates how to generate a sequence of pseudo-random numbers.
#include
#include
...
long count, i;
char *keystr;
int elementlen, len;
char c;
...
/* Initial random number generator. */
srand(1);
/* Create keys using only lowercase characters */
len = 0;
for (i=0; i
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The rand_r() function is included for alignment with the POSIX Threads Extension.
A note indicating that the rand() function need not be reentrant is added to the DESCRIPTION.
Issue 6
Extensions beyond the ISO C standard are marked.
The rand_r() function is marked as part of the Thread-Safe Functions option.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
The rand_r() function is marked obsolescent.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0301 [743] is applied.
Issue 8
Austin Group Defect 1134 is applied, adding getentropy().
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/towlower_l.html =====
towlower
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
towlower, towlower_l — transliterate uppercase wide-character code to lowercase
SYNOPSIS
#include
wint_t towlower(wint_t wc);
[CX]  wint_t towlower_l(wint_t wc, locale_t locale);
DESCRIPTION
For towlower(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The towlower() [CX]  and towlower_l()
functions have as a domain a type wint_t, the value of which the application shall ensure is a character representable
as a wchar_t, and a wide-character code corresponding to a valid character in the locale used by the function or the value
of WEOF. If the argument has any other value, the behavior is undefined. If the argument of towlower() [CX]   or
towlower_l()  represents an uppercase wide-character code,
and there exists a corresponding lowercase wide-character code as defined by character type information in the current locale
[CX]
or in the locale represented by locale,
respectively (category LC_CTYPE ), the result shall be the corresponding lowercase wide-character code. All other
arguments in the domain are returned unchanged.
[CX]  The
behavior is undefined if the locale argument to towlower_l() is the special locale object LC_GLOBAL_LOCALE or is not
a valid locale object handle.
RETURN VALUE
Upon successful completion, the towlower() [CX]   and towlower_l()   functions shall return the lowercase letter corresponding to the argument passed; otherwise, they
shall return the argument unchanged.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
setlocale(), uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 4.
Issue 5
The following change has been made in this version for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E):
The SYNOPSIS has been changed to indicate that this function and associated data types are now made visible by inclusion of the
header rather than .
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The towlower_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0678 [302], XSH/TC1-2008/0679 [283], and XSH/TC1-2008/0680 [283] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0373 [685] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mmap.html =====
mmap
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mmap — map pages of memory
SYNOPSIS
#include
void *mmap(void *addr, size_t len, int prot, int flags,
int fildes, off_t off);
DESCRIPTION
The mmap() function shall establish a mapping between an address space of a process and a memory object.
The mmap() function shall be supported for the following memory objects:
Regular files
Anonymous memory objects
[SHM]
Shared memory objects
[TYM]
Typed memory objects
Support for any other type of file is unspecified.
The format of the call is as follows:
pa=mmap(addr, len, prot, flags, fildes, off);
The mmap() function shall establish a mapping between the address space of the process at an address pa for
len bytes to the memory object represented by the file descriptor fildes at offset off for len bytes,
or to an anonymous memory object of len bytes. The value of pa is an implementation-defined function of the parameter
addr and the values of flags, further described below. A successful mmap() call shall return pa as its
result. The address range starting at pa and continuing for len bytes shall be legitimate for the possible (not
necessarily current) address space of the process. The range of bytes starting at off and continuing for len bytes
shall be legitimate for the possible (not necessarily current) offsets in the memory object represented by fildes.
[TYM]
If fildes represents a typed memory object opened with either the POSIX_TYPED_MEM_ALLOCATE flag or the
POSIX_TYPED_MEM_ALLOCATE_CONTIG flag, the memory object to be mapped shall be that portion of the typed memory object allocated by
the implementation as specified below. In this case, if off is non-zero, the behavior of mmap() is undefined. If
fildes refers to a valid typed memory object that is not accessible from the calling process, mmap() shall fail.
The mapping established by mmap() shall replace any previous mappings for those whole pages containing any part of the
address space of the process starting at pa and continuing for len bytes.
If the size of the mapped file changes after the call to mmap() as a result of some other operation on the mapped file,
the effect of references to portions of the mapped region that correspond to added or removed portions of the file is
unspecified.
If len is zero, mmap() shall fail and no mapping shall be established.
The parameter prot determines whether read, write, execute, or some combination of accesses are permitted to the data
being mapped. The prot shall be either PROT_NONE or the bitwise-inclusive OR of one or more of the other flags in the
following table, defined in the  header.
Symbolic Constant
Description
PROT_READ
Data can be read.
PROT_WRITE
Data can be written.
PROT_EXEC
Data can be executed.
PROT_NONE
Data cannot be accessed.
If an implementation cannot support the combination of access types specified by prot, the call to
mmap() shall fail.
An implementation may permit accesses other than those specified by prot; however, the implementation shall
not permit a write to succeed where PROT_WRITE has not been set and shall not permit any access where PROT_NONE alone has been set.
The implementation shall support at least the following values of prot: PROT_NONE, PROT_READ, PROT_WRITE, and the
bitwise-inclusive OR of PROT_READ and PROT_WRITE. The file descriptor fildes shall have been opened with read permission,
regardless of the protection options specified. If PROT_WRITE is specified, the application shall ensure that it has opened the
file descriptor fildes with write permission unless MAP_PRIVATE is specified in the flags parameter as described
below.
The parameter flags provides other information about the handling of the mapped data. The value of
flags is the bitwise-inclusive OR of these options, defined in :
Symbolic Constant
Description
MAP_ANON
Synonym for MAP_ANONYMOUS.
MAP_ANONYMOUS
Map anonymous memory.
MAP_SHARED
Changes are shared.
MAP_PRIVATE
Changes are private.
MAP_FIXED
Interpret addr exactly.
It is implementation-defined whether MAP_FIXED shall be supported. [XSI]   MAP_FIXED
shall be supported on XSI-conformant systems.
MAP_SHARED and MAP_PRIVATE describe the disposition of write references to the memory object. If MAP_SHARED is
specified, write references shall change the underlying object. If MAP_PRIVATE is specified, modifications to the mapped data by
the calling process shall be visible only to the calling process and shall not change the underlying object. It is unspecified
whether modifications to the underlying object done after the MAP_PRIVATE mapping is established are visible through the
MAP_PRIVATE mapping. Either MAP_SHARED or MAP_PRIVATE can be specified, but not both. The mapping type is retained across fork().
The state of synchronization objects such as mutexes, semaphores, barriers, and conditional variables placed in
shared memory mapped with MAP_SHARED becomes undefined when the last region in any process containing the synchronization object is
unmapped.
[TYM]  When fildes represents a typed memory object opened with either the POSIX_TYPED_MEM_ALLOCATE flag or the
POSIX_TYPED_MEM_ALLOCATE_CONTIG flag, mmap() shall, if there are enough resources available, map len bytes allocated
from the corresponding typed memory object which were not previously allocated to any process in any processor that may access that
typed memory object. If there are not enough resources available, the function shall fail. If fildes represents a typed
memory object opened with the POSIX_TYPED_MEM_ALLOCATE_CONTIG flag, these allocated bytes shall be contiguous within the typed
memory object. If fildes represents a typed memory object opened with the POSIX_TYPED_MEM_ALLOCATE flag, these allocated
bytes may be composed of non-contiguous fragments within the typed memory object. If fildes represents a typed memory object
opened with neither the POSIX_TYPED_MEM_ALLOCATE_CONTIG flag nor the POSIX_TYPED_MEM_ALLOCATE flag, len bytes starting at
offset off within the typed memory object are mapped, exactly as when mapping a file or shared memory object. In this case,
if two processes map an area of typed memory using the same off and len values and using file descriptors that refer
to the same memory pool (either from the same port or from a different port), both processes shall map the same region of storage.
When MAP_FIXED is set in the flags argument, the implementation is informed that the value of pa
shall be addr, exactly. If MAP_FIXED is set, mmap() may return MAP_FAILED and set errno to [EINVAL]. If a
MAP_FIXED request is successful, then any previous mappings [ML|MLR]   or memory locks   for those whole pages containing any part of the address range [pa,pa+len)
shall be removed, as if by an appropriate call to munmap(), before the new mapping is
established.
When MAP_FIXED is not set, the implementation uses addr in an implementation-defined manner to arrive at
pa. The pa so chosen shall be an area of the address space that the implementation deems suitable for a mapping of
len bytes to the file. All implementations interpret an addr value of 0 as granting the implementation complete
freedom in selecting pa, subject to constraints described below. A non-zero value of addr is taken to be a suggestion
of a process address near which the mapping should be placed. When the implementation selects a value for pa, it never
places a mapping at address 0, nor does it replace any extant mapping.
If MAP_FIXED is specified and addr is non-zero, it shall have the same remainder as the off
parameter, modulo the page size as returned by sysconf() when passed _SC_PAGESIZE or
_SC_PAGE_SIZE. The implementation may require that off is a multiple of the page size. If MAP_FIXED is specified, the
implementation may require that addr is a multiple of the page size. The system performs mapping operations over whole
pages. Thus, while the parameter len need not meet a size or alignment constraint, the system shall include, in any mapping
operation, any partial page specified by the address range starting at pa and continuing for len bytes.
If MAP_ANONYMOUS (or its synonym MAP_ANON) is specified, fildes is -1, and off is 0, then
mmap() shall ignore fildes and instead establish a mapping to a new anonymous memory object of size len. The
effect of specifying MAP_ANONYMOUS (or MAP_ANON) with other values of fildes or off is unspecified. Anonymous memory
objects shall be initialized to all bits zero.
The system shall always zero-fill any partial page at the end of an object. Further, the system shall never write
out any modified portions of the last page of an object which are beyond its end. References within the address range starting at
pa and continuing for len bytes to whole pages following the end of an object shall result in delivery of a SIGBUS
signal.
An implementation may generate SIGBUS signals when a reference would cause an error in the mapped object, such as
out-of-space condition.
The mmap() function shall add an extra reference to the file associated with the file descriptor
fildes which is not removed by a subsequent close() on that file descriptor.
This reference shall be removed when there are no more mappings to the file.
The last data access timestamp of the mapped file may be marked for update at any time between the mmap()
call and the corresponding munmap() call. The initial read or write reference to a
mapped region shall cause the file's last data access timestamp to be marked for update if it has not already been marked for
update.
The last data modification and last file status change timestamps of a file that is mapped with MAP_SHARED and
PROT_WRITE shall be marked for update at some point in the interval between a write reference to the mapped region and the next
call to msync() with MS_ASYNC or MS_SYNC for that portion of the file by any process.
If there is no such call and if the underlying file is modified as a result of a write reference, then these timestamps shall be
marked for update at some time after the write reference.
There may be implementation-defined limits on the number of memory regions that can be mapped (per process or per
system).
[XSI]  If such a limit is imposed, whether the number of memory regions that can be mapped by a process is decreased by the
use of shmat() is implementation-defined.
If mmap() fails for reasons other than [EBADF], [EINVAL], or [ENOTSUP], some of the mappings in the address
range starting at addr and continuing for len bytes may have been unmapped.
RETURN VALUE
Upon successful completion, the mmap() function shall return the address at which the mapping was placed (pa);
otherwise, it shall return a value of MAP_FAILED and set errno to indicate the error. The symbol MAP_FAILED is defined in
the  header. No successful return from mmap() shall
return the value MAP_FAILED.
ERRORS
The mmap() function shall fail if:
[EAGAIN]
[ML]
The mapping could not be locked in memory, if required by mlockall(), due to a lack
of resources.
[EINVAL]
The value of len is zero.
[EINVAL]
The value of flags is invalid (neither MAP_PRIVATE nor MAP_SHARED is set).
[EMFILE]
The number of mapped regions would exceed an implementation-defined limit (per process or per system).
[ENOMEM]
MAP_FIXED was specified, and the range [addr,addr+len) exceeds that allowed for the address space of a
process; or, if MAP_FIXED was not specified and there is insufficient room in the address space to effect the mapping.
[ENOMEM]
[ML]
The mapping could not be locked in memory, if required by mlockall(), because it
would require more space than the system is able to supply.
[ENOMEM]
[TYM]
Not enough unallocated memory resources remain in the typed memory object designated by fildes to allocate len bytes.
[ENOTSUP]
MAP_FIXED or MAP_PRIVATE was specified in the flags argument and the implementation does not support this functionality.
The implementation does not support the combination of accesses requested in the prot argument.
[ENXIO]
MAP_FIXED was specified in flags and the combination of addr, len, and off is invalid for the
specified object.
[ENXIO]
[TYM]
The fildes argument refers to a typed memory object that is not accessible from the calling process.
In addition, if MAP_ANONYMOUS (or MAP_ANON) is not set in flags, the mmap() function shall fail if:
[EACCES]
The fildes argument is not open for read, regardless of the protection specified, or fildes is not open for write
and PROT_WRITE was specified for a MAP_SHARED type mapping.
[EBADF]
The fildes argument is not a valid open file descriptor.
[ENODEV]
The fildes argument refers to a file whose type is not supported by mmap().
[EOVERFLOW]
The file is a regular file and the value of off plus len exceeds the offset maximum established in the open file
description associated with fildes.
[ENXIO]
Addresses in the range [off,off+len) are invalid for the object specified by fildes.
The mmap() function may fail if:
[EINVAL]
The addr argument (if MAP_FIXED was specified) or off is not a multiple of the page size as returned by sysconf(), or is considered invalid by the implementation.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Use of mmap() may reduce the amount of memory available to other memory allocation functions.
Use of MAP_FIXED may result in unspecified behavior in further use of malloc() and shmat(). The use of MAP_FIXED is
discouraged, as it may prevent an implementation from making the most effective use of resources. Most implementations require that
off and addr are multiples of the page size as returned by sysconf().
The application must ensure correct synchronization when using mmap() in conjunction with any other file
access method, such as read() and write(),
standard input/output, and shmat().
The mmap() function allows access to resources via address space manipulations, instead of read()/write(). Once a file is mapped, all a
process has to do to access it is use the data at the address to which the file was mapped. So, using pseudo-code to illustrate the
way in which an existing program might be changed to use mmap(), the following:
fildes = open(...)
lseek(fildes, some_offset)
read(fildes, buf, len)
/* Use data in buf. */
becomes:
fildes = open(...)
address = mmap(0, len, PROT_READ, MAP_PRIVATE, fildes, some_offset)
/* Use data at address. */
RATIONALE
After considering several other alternatives, it was decided to adopt the mmap() definition found in SVR4 for mapping
memory objects into process address spaces. The SVR4 definition is minimal, in that it describes only what has been built, and what
appears to be necessary for a general and portable mapping facility.
Note that while mmap() was first designed for mapping files, it is actually a general-purpose mapping
facility. It can be used to map any appropriate object, such as memory, files, devices, and so on, into the address space of a
process.
When a mapping is established, it is possible that the implementation may need to map more than is requested into
the address space of the process because of hardware requirements. An application, however, cannot count on this behavior.
Implementations that do not use a paged architecture may simply allocate a common memory region and return the address of it; such
implementations probably do not allocate any more than is necessary. References past the end of the requested area are
unspecified.
If an application requests a mapping that overlaps existing mappings in the process, it might be desirable that an
implementation detect this and inform the application. However, if the program specifies a fixed address mapping (which requires
some implementation knowledge to determine a suitable address, if the function is supported at all), then the program is presumed
to be successfully managing its own address space and should be trusted when it asks to map over existing data structures.
Furthermore, it is also desirable to make as few system calls as possible, and it might be considered onerous to require an
munmap() before an mmap() to the same address range. This volume of
POSIX.1-2024 specifies that the new mapping replaces any existing mappings (implying an automatic munmap() on the address range), following existing practice in this regard. The standard
developers also considered whether there should be a way for new mappings to overlay existing mappings, but found no existing
practice for this.
It is not expected that all hardware implementations are able to support all combinations of permissions at all
addresses. Implementations are required to disallow write access to mappings without write permission and to disallow access to
mappings without any access permission. Other than these restrictions, implementations may allow access types other than those
requested by the application. For example, if the application requests only PROT_WRITE, the implementation may also allow read
access. A call to mmap() fails if the implementation cannot support allowing all the access requested by the application.
For example, some implementations cannot support a request for both write access and execute access simultaneously. All
implementations must support requests for no access, read access, write access, and both read and write access. Strictly conforming
code must only rely on the required checks. These restrictions allow for portability across a wide range of hardware.
The MAP_FIXED address treatment is likely to fail for non-page-aligned values and for certain
architecture-dependent address ranges. Conforming implementations cannot count on being able to choose address values for MAP_FIXED
without utilizing non-portable, implementation-defined knowledge. Nonetheless, MAP_FIXED is provided as a standard interface
conforming to existing practice for utilizing such knowledge when it is available.
Similarly, in order to allow implementations that do not support virtual addresses, support for directly specifying
any mapping addresses via MAP_FIXED is not required and thus a conforming application may not count on it.
The MAP_PRIVATE function can be implemented efficiently when memory protection hardware is available. When such
hardware is not available, implementations can implement such "mappings" by simply making a real copy of the relevant data into
process private memory, though this tends to behave similarly to read().
The function has been defined to allow for many different models of using shared memory. However, all uses are not
equally portable across all machine architectures. In particular, the mmap() function allows the system as well as the
application to specify the address at which to map a specific region of a memory object. The most portable way to use the function
is always to let the system choose the address, specifying NULL as the value for the argument addr and not to specify
MAP_FIXED.
If it is intended that a particular region of a memory object be mapped at the same address in a group of processes
(on machines where this is even possible), then MAP_FIXED can be used to pass in the desired mapping address. The system can still
be used to choose the desired address if the first such mapping is made without specifying MAP_FIXED, and then the resulting
mapping address can be passed to subsequent processes for them to pass in via MAP_FIXED. The availability of a specific address
range cannot be guaranteed, in general.
The mmap() function can be used to map a region of memory that is larger than the current size of the
object. Memory access within the mapping but beyond the current end of the underlying objects may result in SIGBUS signals being
sent to the process. The reason for this is that the size of the object can be manipulated by other processes and can change at any
moment. The implementation should tell the application that a memory reference is outside the object where this can be detected;
otherwise, written data may be lost and read data may not reflect actual data in the object.
Note that references beyond the end of the object do not extend the object as the new end cannot be determined
precisely by most virtual memory hardware. Instead, the size can be directly manipulated by ftruncate().
Process memory locking does apply to shared memory regions, and the MCL_FUTURE argument to mlockall() can be relied upon to cause new shared memory regions to be automatically
locked.
Existing implementations of mmap() return the value -1 when unsuccessful. Since the casting of this value to
type void * cannot be guaranteed by the ISO C standard to be distinct from a successful value, this volume of
POSIX.1-2024 defines the symbol MAP_FAILED, which a conforming implementation does not return as the result of a successful
call.
Some historical implementations only supported MAP_ANON, some only supported MAP_ANONYMOUS, and some supported both
spellings. This standard includes both spellings partly for application compatibility and partly because neither spelling was
clearly more popular than the other at the time this feature was considered for standardization.
FUTURE DIRECTIONS
None.
SEE ALSO
exec, fcntl(), fork(), lockf(), msync(), munmap(), mprotect(), posix_typed_mem_open(), shmat()
, sysconf()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Aligned with mmap() in the POSIX Realtime Extension as follows:
The DESCRIPTION is extensively reworded.
The [EAGAIN] and [ENOTSUP] mandatory error conditions are added.
New cases of [ENOMEM] and [ENXIO] are added as mandatory error conditions.
The value returned on failure is the value of the constant MAP_FAILED; this was previously defined as -1.
Large File Summit extensions are added.
Issue 6
The mmap() function is marked as part of the Memory Mapped Files option.
The Open Group Corrigendum U028/6 is applied, changing (void *)-1 to MAP_FAILED.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX
Specification:
The DESCRIPTION is updated to describe the use of MAP_FIXED.
The DESCRIPTION is updated to describe the addition of an extra reference to the file associated with the file
descriptor passed to mmap().
The DESCRIPTION is updated to state that there may be implementation-defined limits on the number of memory
regions that can be mapped.
The DESCRIPTION is updated to describe constraints on the alignment and size of the off argument.
The [EINVAL] and [EMFILE] error conditions are added.
The [EOVERFLOW] error condition is added. This change is to support large files.
The following changes are made for alignment with the ISO POSIX-1:1996 standard:
The DESCRIPTION is updated to describe the cases when MAP_PRIVATE and MAP_FIXED need not be supported.
The following changes are made for alignment with IEEE Std 1003.1j-2000:
Semantics for typed memory objects are added to the DESCRIPTION.
New [ENOMEM] and [ENXIO] errors are added to the ERRORS section.
The posix_typed_mem_open() function is added to the
SEE ALSO section.
The normative text is updated to avoid use of the term "must" for application requirements.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/34 is applied, changing the margin code in the
SYNOPSIS from MF|SHM to MC3 (notation for MF|SHM|TYM).
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/60 is applied, updating the DESCRIPTION and ERRORS
sections to add the [EINVAL] error when len is zero.
Issue 7
Austin Group Interpretations 1003.1-2001 #078 and #079 are applied, clarifying page alignment requirements and adding a note
about the state of synchronization objects becoming undefined when a shared region is unmapped.
Functionality relating to the Memory Protection and Memory Mapped Files options is moved to the Base.
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0229 [852] is applied.
Issue 8
Austin Group Defect 850 is applied, adding anonymous memory objects.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/posix_spawnattr_getsigmask.html =====
posix_spawnattr_getsigmask
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
posix_spawnattr_getsigmask, posix_spawnattr_setsigmask — get and set the spawn-sigmask attribute of a spawn attributes
object (ADVANCED REALTIME)
SYNOPSIS
[SPN]  #include
#include
int posix_spawnattr_getsigmask(const posix_spawnattr_t *restrict attr,
sigset_t *restrict sigmask);
int posix_spawnattr_setsigmask(posix_spawnattr_t *restrict attr,
const sigset_t *restrict sigmask);
DESCRIPTION
The posix_spawnattr_getsigmask() function shall obtain the value of the spawn-sigmask attribute from the
attributes object referenced by attr.
The posix_spawnattr_setsigmask() function shall set the spawn-sigmask attribute in an initialized attributes
object referenced by attr.
The spawn-sigmask attribute represents the signal mask in effect in the new process image of a spawn operation (if
POSIX_SPAWN_SETSIGMASK is set in the spawn-flags attribute). The default value of this attribute is unspecified.
RETURN VALUE
Upon successful completion, posix_spawnattr_getsigmask() shall return zero and store the value of the
spawn-sigmask attribute of attr into the object referenced by the sigmask parameter; otherwise, an error
number shall be returned to indicate the error.
Upon successful completion, posix_spawnattr_setsigmask() shall return zero; otherwise, an error number shall be returned
to indicate the error.
ERRORS
These functions may fail if:
[EINVAL]
The value specified by attr is invalid.
The posix_spawnattr_setsigmask() function may fail if:
[EINVAL]
The value of the attribute being set is not valid.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
These functions are part of the Spawn option and need not be provided on all implementations.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
posix_spawn(), posix_spawnattr_destroy(), posix_spawnattr_getsigdefault(), posix_spawnattr_getflags(), posix_spawnattr_getpgroup(), posix_spawnattr_getschedparam(), posix_spawnattr_getschedpolicy()
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1d-1999.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_mutex_trylock.html =====
pthread_mutex_lock
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_mutex_lock, pthread_mutex_trylock, pthread_mutex_unlock — lock and unlock a mutex
SYNOPSIS
#include
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_trylock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
DESCRIPTION
The mutex object referenced by mutex shall be locked by a call to pthread_mutex_lock() that returns zero or
[EOWNERDEAD]. If the mutex is already locked by another thread, the calling thread shall block until the mutex becomes available.
This operation shall return with the mutex object referenced by mutex in the locked state with the calling thread as its
owner. If a thread attempts to relock a mutex that it has already locked, pthread_mutex_lock() shall behave as described in
the Relock column of the following table. If a thread attempts to unlock a mutex that it has not locked or a mutex which is
unlocked, pthread_mutex_unlock() shall behave as described in the Unlock When Not Owner column of the following
table.
Mutex Type
Robustness
Relock
Unlock When Not Owner
NORMAL
non-robust
deadlock
undefined behavior
NORMAL
robust
deadlock
error returned
ERRORCHECK
either
error returned
error returned
RECURSIVE
either
recursive (see below)
error returned
DEFAULT
non-robust
undefined behavior†
undefined behavior†
DEFAULT
robust
undefined behavior†
error returned
†
If the mutex type is PTHREAD_MUTEX_DEFAULT, the behavior of pthread_mutex_lock() may correspond to one of the three
other standard mutex types as described in the table above. If it does not correspond to one of those three, the behavior is
undefined for the cases marked †.
Where the table indicates recursive behavior, the mutex shall maintain the concept of a lock count. When a thread
successfully acquires a mutex for the first time, the lock count shall be set to one. Every time a thread relocks this mutex, the
lock count shall be incremented by one. Each time the thread unlocks the mutex, the lock count shall be decremented by one. When
the lock count reaches zero, the mutex shall become available for other threads to acquire.
The pthread_mutex_trylock() function shall be equivalent to pthread_mutex_lock(), except that if the
mutex object referenced by mutex is currently locked (by any thread, including the current thread), the call shall return
immediately. If the mutex type is PTHREAD_MUTEX_RECURSIVE and the mutex is currently owned by the calling thread, the mutex lock
count shall be incremented by one and the pthread_mutex_trylock() function shall immediately return success.
The pthread_mutex_unlock() function shall release the mutex object referenced by mutex. The manner in
which a mutex is released is dependent upon the mutex's type attribute. If there are threads blocked on the mutex object referenced
by mutex when pthread_mutex_unlock() is called, resulting in the mutex becoming available, the scheduling policy
shall determine which thread shall acquire the mutex.
(In the case of PTHREAD_MUTEX_RECURSIVE mutexes, the mutex shall become available when the count reaches zero and
the calling thread no longer has any locks on this mutex.)
If a signal is delivered to a thread waiting for a mutex, upon return from the signal handler the thread shall
resume waiting for the mutex as if it was not interrupted.
If mutex is a robust mutex and the process containing the owning thread terminated while holding the mutex
lock, a call to pthread_mutex_lock() shall return the error value [EOWNERDEAD]. If mutex is a robust mutex and the
owning thread terminated while holding the mutex lock, a call to pthread_mutex_lock() may return the error value
[EOWNERDEAD] even if the process in which the owning thread resides has not terminated. In these cases, the mutex shall be locked
by the calling thread but the state it protects is marked as inconsistent. The application should ensure that the state is made
consistent for reuse and when that is complete call pthread_mutex_consistent(). If the application is unable to recover the
state, it should unlock the mutex without a prior call to pthread_mutex_consistent(), after which the mutex is marked permanently
unusable.
If mutex does not refer to an initialized mutex object, the behavior of pthread_mutex_lock(),
pthread_mutex_trylock(), and pthread_mutex_unlock() is undefined.
RETURN VALUE
If successful, the pthread_mutex_lock(), pthread_mutex_trylock(), and pthread_mutex_unlock() functions
shall return zero; otherwise, an error number shall be returned to indicate the error.
ERRORS
The pthread_mutex_lock() and pthread_mutex_trylock() functions shall fail if:
[EAGAIN]
The mutex could not be acquired because the maximum number of recursive locks for mutex has been exceeded.
[EAGAIN]
The mutex is a robust mutex and the system resources available for robust mutexes owned would be exceeded.
[EINVAL]
[RPP|TPP]  The mutex was created with the protocol attribute having the value PTHREAD_PRIO_PROTECT and the calling thread's
priority is higher than the mutex's current priority ceiling.
[ENOTRECOVERABLE]
The state protected by the mutex is not recoverable.
[EOWNERDEAD]
The mutex is a robust mutex and the process containing the previous owning thread terminated while holding the mutex lock. The
mutex lock shall be acquired by the calling thread and it is up to the new owner to make the state consistent.
The pthread_mutex_lock() function shall fail if:
[EDEADLK]
The mutex type is PTHREAD_MUTEX_ERRORCHECK and the current thread already owns the mutex.
The pthread_mutex_trylock() function shall fail if:
[EBUSY]
The mutex could not be acquired because it was already locked.
The pthread_mutex_unlock() function shall fail if:
[EPERM]
The mutex type is PTHREAD_MUTEX_ERRORCHECK or PTHREAD_MUTEX_RECURSIVE, or the mutex is a robust mutex, and the current thread
does not own the mutex.
The pthread_mutex_lock() and pthread_mutex_trylock() functions may fail if:
[EOWNERDEAD]
The mutex is a robust mutex and the previous owning thread terminated while holding the mutex lock. The mutex lock shall be
acquired by the calling thread and it is up to the new owner to make the state consistent.
The pthread_mutex_lock() function may fail if:
[EDEADLK]
A deadlock condition was detected.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications that have assumed that non-zero return values are errors will need updating for use with robust mutexes, since a
valid return for a thread acquiring a mutex which is protecting a currently inconsistent state is [EOWNERDEAD]. Applications that
do not check the error returns, due to ruling out the possibility of such errors arising, should not use robust mutexes. If an
application is supposed to work with normal and robust mutexes it should check all return values for error conditions and if
necessary take appropriate action.
RATIONALE
Mutex objects are intended to serve as a low-level primitive from which other thread synchronization functions can be built. As
such, the implementation of mutexes should be as efficient as possible, and this has ramifications on the features available at the
interface.
The mutex functions and the particular default settings of the mutex attributes have been motivated by the desire
to not preclude fast, inlined implementations of mutex locking and unlocking.
Since most attributes only need to be checked when a thread is going to be blocked, the use of attributes does not
slow the (common) mutex-locking case.
Likewise, while being able to extract the thread ID of the owner of a mutex might be desirable, it would require
storing the current thread ID when each mutex is locked, and this could incur unacceptable levels of overhead. Similar arguments
apply to a mutex_tryunlock operation.
For further rationale on the extended mutex types, see XRAT Threads Extensions.
If an implementation detects that the value specified by the mutex argument does not refer to an initialized
mutex object, it is recommended that the function should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_mutex_clocklock(), pthread_mutex_consistent(), pthread_mutex_destroy(), pthread_mutexattr_getrobust()
XBD 4.15.2 Memory Synchronization,
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_mutex_lock(), pthread_mutex_trylock(), and pthread_mutex_unlock() functions are marked as part
of the Threads option.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX
Specification:
The behavior when attempting to relock a mutex is defined.
The pthread_mutex_timedlock() function is added to
the SEE ALSO section for alignment with IEEE Std 1003.1d-1999.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/98 is applied, updating the ERRORS section so that
the [EDEADLK] error includes detection of a deadlock condition. The RATIONALE section is also reworded to take into account
non-XSI-conformant systems.
Issue 7
SD5-XSH-ERN-43 is applied, marking the "shall fail" case of the [EINVAL] error as dependent on the Thread Priority Protection
option.
Changes are made from The Open Group Technical Standard, 2006, Extended API Set Part 3.
The pthread_mutex_lock(), pthread_mutex_trylock(), and pthread_mutex_unlock() functions are
moved from the Threads option to the Base.
The following extended mutex types are moved from the XSI option to the Base:
PTHREAD_MUTEX_NORMAL
PTHREAD_MUTEX_ERRORCHECK
PTHREAD_MUTEX_RECURSIVE
PTHREAD_MUTEX_DEFAULT
The DESCRIPTION is updated to clarify the behavior when mutex does not refer to an initialized mutex.
The ERRORS section is updated to account properly for all of the various mutex types.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0461 [121], XSH/TC1-2008/0462 [92,428], and XSH/TC1-2008/0463
[121] are applied.
Issue 8
Austin Group Defect 354 is applied, adding the [EAGAIN] error for exceeding system resources available for robust mutexes
owned.
Austin Group Defect 1115 is applied, changing "the thread" to "the calling thread".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getrlimit.html =====
getrlimit
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getrlimit, setrlimit — control maximum resource consumption
SYNOPSIS
#include
int getrlimit(int resource, struct rlimit *rlp);
int setrlimit(int resource, const struct rlimit *rlp);
DESCRIPTION
The getrlimit() function shall get, and the setrlimit() function shall set, limits on the consumption of a variety
of resources.
Each call to either getrlimit() or setrlimit() identifies a specific resource to be operated upon as well as a
resource limit. A resource limit is represented by an rlimit structure. The rlim_cur member specifies the current or
soft limit and the rlim_max member specifies the maximum or hard limit. Soft limits can be changed by a process to any value
that is less than or equal to the hard limit. A process can (irreversibly) lower its hard limit to any value that is greater than
or equal to the soft limit. Only a process with appropriate privileges can raise a hard limit. Both hard and soft limits can be
changed in a single call to setrlimit() subject to the constraints described above.
The value RLIM_INFINITY, defined in , shall be
considered to be larger than any other limit value. If a call to getrlimit() returns RLIM_INFINITY for a resource, it means
the implementation shall not enforce limits on that resource. Specifying RLIM_INFINITY as any resource limit value on a successful
call to setrlimit() shall inhibit enforcement of that resource limit.
The following resources are defined:
RLIMIT_CORE
This is the maximum size of a file containing a core image, in bytes, that can be created by a process. A limit of 0 shall
prevent the creation of such a file. If this limit is exceeded, the writing of a file containing a core image shall terminate at
this size. Note that the production of such a file may be one of the implementation-defined actions for abnormal termination.
RLIMIT_CPU
[XSI]
This is the maximum amount of CPU time, in seconds, used by a process. If this limit is exceeded, SIGXCPU shall be generated for
the process. If the process is catching or ignoring SIGXCPU, or all threads belonging to that process are blocking SIGXCPU, the
behavior is unspecified.
RLIMIT_DATA
This is the maximum size of a data segment of the process, in bytes. If this limit is exceeded, the malloc() function shall fail with errno set to [ENOMEM].
RLIMIT_FSIZE
This is the maximum size of a file, in bytes, that can be created by a process. If a write or truncate operation would cause
this limit to be exceeded, [XSI]   a SIGXFSZ shall be generated for the thread; if the thread is blocking, or the process is
catching or ignoring SIGXFSZ,   the operation shall fail with
an [EFBIG] error.
RLIMIT_NOFILE
This is a number one greater than the maximum value that the system shall assign to a newly-created descriptor. If this limit
is exceeded, functions that allocate a file descriptor shall fail with errno set to [EMFILE]. This limit constrains the
number of file descriptors that a process can allocate.
RLIMIT_STACK
This is the maximum size of the initial thread's stack, in bytes. The implementation does not automatically grow the stack
beyond this limit. If this limit is exceeded, SIGSEGV shall be generated for the thread. If the thread is blocking SIGSEGV, or the
process is ignoring or catching SIGSEGV and has not made arrangements to use an alternate stack, the disposition of SIGSEGV shall
be set to SIG_DFL before it is generated.
RLIMIT_AS
This is the maximum size of total available memory of the process, in bytes. If this limit is exceeded, the malloc() and mmap() functions shall fail with
errno set to [ENOMEM]. In addition, the automatic stack growth fails with the effects outlined above.
When using the getrlimit() function, if a resource limit can be represented correctly in an object of type rlim_t,
then its representation is returned; otherwise, if the value of the resource limit is equal to that of the corresponding saved hard
limit, the value returned shall be RLIM_SAVED_MAX; otherwise, the value returned shall be RLIM_SAVED_CUR.
When using the setrlimit() function, if the requested new limit is RLIM_INFINITY, the new limit shall be "no limit";
otherwise, if the requested new limit is RLIM_SAVED_MAX, the new limit shall be the corresponding saved hard limit; otherwise, if
the requested new limit is RLIM_SAVED_CUR, the new limit shall be the corresponding saved soft limit; otherwise, the new limit
shall be the requested value. In addition, if the corresponding saved limit can be represented correctly in an object of type
rlim_t then it shall be overwritten with the new limit.
The result of setting a limit to RLIM_SAVED_MAX or RLIM_SAVED_CUR is unspecified unless a previous call to getrlimit()
returned that value as the soft or hard limit for the corresponding resource limit.
The determination of whether a limit can be correctly represented in an object of type rlim_t is implementation-defined.
For example, some implementations permit a limit whose value is greater than RLIM_INFINITY and others do not.
The exec family of functions shall cause resource limits to be saved.
RETURN VALUE
Upon successful completion, getrlimit() and setrlimit() shall return 0. Otherwise, these functions shall return -1
and set errno to indicate the error.
ERRORS
The getrlimit() and setrlimit() functions shall fail if:
[EINVAL]
An invalid resource was specified; or in a setrlimit() call, the new rlim_cur exceeds the new
rlim_max.
[EPERM]
The limit specified to setrlimit() would have raised the maximum limit value, and the calling process does not have
appropriate privileges.
The setrlimit() function may fail if:
[EINVAL]
The limit specified cannot be lowered because current usage is already higher than the limit.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
If a process attempts to set the hard limit or soft limit for RLIMIT_NOFILE to less than the value of {_POSIX_OPEN_MAX} from
, unexpected behavior may occur.
If a process attempts to set the hard limit or soft limit for RLIMIT_NOFILE to less than the highest currently open file
descriptor +1, unexpected behavior may occur.
RATIONALE
These functions were previously part of the XSI option and have been moved to the Base so that portable shells, and other
utilities that need to relay the wait status of a child process to a parent, can terminate themselves with the same signal that
terminated the child but without overwriting a core image created by the child (through setting RLIMIT_CORE to zero, which disables
core image creation). The RLIMIT_CPU and RLIMIT_FSIZE limits remain in the XSI option because they relate to other XSI
functionality (SIGXCPU and SIGXFSZ).
It should be noted that RLIMIT_STACK applies "at least" to the stack of the initial thread in the process, and not to the sum
of all the stacks in the process, as that would be very limiting unless the value is so big as to provide no value at all with a
single thread.
FUTURE DIRECTIONS
None.
SEE ALSO
exec, fork(), malloc(), open(), sigaltstack(), sysconf()
XBD
XCU ulimit
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
An APPLICATION USAGE section is added.
Large File Summit extensions are added.
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/25 is applied, changing wording for RLIMIT_NOFILE in the
DESCRIPTION related to functions that allocate a file descriptor failing with [EMFILE]. Text is added to the APPLICATION USAGE
section noting the consequences of a process attempting to set the hard or soft limit for RLIMIT_NOFILE less than the highest
currently open file descriptor +1.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/46 is applied, updating the definition of RLIMIT_STACK in the
DESCRIPTION from "the maximum size of a process stack" to "the maximum size of the initial thread's stack". Text is added to
the RATIONALE section.
Issue 8
Austin Group Defects 51 and 1669 are applied, moving the getrlimit() and setrlimit() functions, excluding the
RLIMIT_CPU limit, from the XSI option to the Base.
Austin Group Defect 1141 is applied, changing the description of RLIMIT_CORE.
Austin Group Defect 1416 is applied, changing some uses of "may" to "can" and one to "shall".
Austin Group Defect 1418 is applied, changing the SEE ALSO section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/semop.html =====
semop
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
semop — XSI semaphore operations
SYNOPSIS
[XSI]  #include
int semop(int semid, struct sembuf *sops, size_t nsops);
DESCRIPTION
The semop() function operates on XSI semaphores (see XBD 4.20
Semaphore). It is unspecified whether this function interoperates with the realtime interprocess communication facilities
defined in 2.8 Realtime.
The semop() function shall perform atomically a user-defined array of semaphore operations in array order on the set of
semaphores associated with the semaphore identifier specified by the argument semid.
The argument sops is a pointer to a user-defined array of semaphore operation structures. The implementation shall not
modify elements of this array unless the application uses implementation-defined extensions.
The argument nsops is the number of such structures in the array.
Each structure, sembuf, includes the following members:
Member Type
Member Name
Description
unsigned short
sem_num
Semaphore number.
short
sem_op
Semaphore operation.
short
sem_flg
Operation flags.
Each semaphore operation specified by sem_op is performed on the corresponding semaphore specified by
semid and sem_num.
If all of the semaphore operations complete successfully, semop() shall return 0. If a semaphore operation
fails or blocks, all changes to semadj and semval values performed by completed semaphore operations in the array
before the operation that failed or blocked shall be undone before semop() returns or blocks, respectively. When a semaphore
operation blocks, the change to semncnt or semzcnt indicating which semaphore operation blocked shall not be undone
until the operation unblocks.
For each operation in the array of semaphore operations, the variable sem_op specifies one of three
semaphore operations:
If sem_op is a negative integer and the calling process has alter permission, one of the following shall
occur:
If semval (see ) is greater than or equal
to the absolute value of sem_op, the absolute value of sem_op shall be subtracted from semval. Also, if
(sem_flg & SEM_UNDO) is non-zero, the absolute value of sem_op shall be added to the semadj value of the
calling process for the specified semaphore. If this is not the last operation in the array of semaphore operations to be
performed, processing shall continue with the next operation in the array.
If semval is less than the absolute value of sem_op and (sem_flg & IPC_NOWAIT) is non-zero,
the operation shall fail with errno set to [EAGAIN].
If semval is less than the absolute value of sem_op and (sem_flg & IPC_NOWAIT) is 0,
semop() shall increment the semncnt associated with the specified semaphore and suspend execution of the calling
thread (block) until one of the following conditions occurs:
The value of semval changes. When this occurs, the value of semncnt associated with the specified
semaphore shall be decremented and the array of semaphore operations shall be reevaluated.
The semid for which the calling thread is awaiting action is removed from the system. When this occurs, the
operation shall fail with errno set to [EIDRM].
The calling thread receives a signal that is to be caught. When this occurs, the value of semncnt
associated with the specified semaphore shall be decremented, and the calling thread shall resume execution in the manner
prescribed in sigaction().
If sem_op is a positive integer and the calling process has alter permission, the value of sem_op
shall be added to semval and, if (sem_flg & SEM_UNDO) is non-zero, the value of sem_op shall be subtracted
from the semadj value of the calling process for the specified semaphore. If this is not the last operation in the array of
semaphore operations to be performed, processing shall continue with the next operation in the array.
If sem_op is 0 and the calling process has read permission, one of the following shall occur:
If semval is 0, this is a successful operation. If this is not the last operation in the array of semaphore
operations to be performed, processing shall continue with the next operation in the array.
If semval is non-zero and (sem_flg & IPC_NOWAIT) is non-zero, the operation shall fail with
errno set to [EAGAIN].
If semval is non-zero and (sem_flg & IPC_NOWAIT) is 0, semop() shall increment the
semzcnt associated with the specified semaphore and suspend execution of the calling thread (block) until one of the
following occurs:
The value of semval changes. When this occurs, the value of semzcnt associated with the specified
semaphore shall be decremented and the array of semaphore operations shall be reevaluated.
The semid for which the calling thread is awaiting action is removed from the system. When this occurs, the
operation shall fail with errno set to [EIDRM].
The calling thread receives a signal that is to be caught. When this occurs, the value of semzcnt
associated with the specified semaphore shall be decremented, and the calling thread shall resume execution in the manner
prescribed in sigaction().
Upon successful completion of all of the semaphore operations specified in the array pointed to by sops, the
value of sempid for each semaphore specified in the array shall be set to the process ID of the calling process and the
sem_otime timestamp associated with the semaphore set shall be set to the current time, as described in 2.7.1 IPC General Description.
RETURN VALUE
Upon successful completion, semop() shall return 0; otherwise, it shall return -1 and set errno to indicate the
error.
ERRORS
The semop() function shall fail if:
[E2BIG]
The value of nsops is greater than the system-imposed maximum.
[EACCES]
Operation permission is denied to the calling process; see 2.7 XSI
Interprocess Communication.
[EAGAIN]
The operation would result in suspension of the calling thread but (sem_flg & IPC_NOWAIT) is non-zero.
[EFBIG]
The value of sem_num is greater than or equal to the number of semaphores in the set associated with semid.
[EIDRM]
The semaphore identifier semid is removed from the system.
[EINTR]
The semop() function was interrupted by a signal.
[EINVAL]
The value of semid is not a valid semaphore identifier, or the number of individual semaphores for which the calling
process requests a SEM_UNDO would exceed the system-imposed limit.
[ENOSPC]
The limit on the number of individual processes requesting a SEM_UNDO would be exceeded.
[ERANGE]
An operation would cause a semval to overflow the system-imposed limit, or an operation would cause a semadj
value to overflow the system-imposed limit.
The following sections are informative.
EXAMPLES
Setting Values in Semaphores
The following example sets the values of the two semaphores associated with the semid identifier to the
values contained in the sb array.
#include
...
int semid;
struct sembuf sb[2];
int nsops = 2;
int result;
// Code to initialize semid.
...
// Adjust value of semaphore in the semaphore array semid.
sb[0].sem_num = 0;
sb[0].sem_op = -1;
sb[0].sem_flg = SEM_UNDO | IPC_NOWAIT;
sb[1].sem_num = 1;
sb[1].sem_op = 1;
sb[1].sem_flg = 0;
result = semop(semid, sb, nsops);
Creating a Semaphore Identifier
The following example gets a semaphore key using the ftok() function,
then creates or uses an existing semaphore set associated with that key using the semget() function.
If this process creates the semaphore set, the program uses a call to semop() to initialize it to the value
in the sbuf array. The number of processes that can execute concurrently is set to 2.
The final call to semop() acquires the semaphore and waits until it is free; the SEM_UNDO option releases
the semaphore when the process exits, waiting until there are less than two processes running concurrently.
#include
#include
#include
#include
#include
...
struct sembuf sbuf;
int semid;
key_t semkey;
...
// Get a key for the semaphore set.
if ((semkey = ftok("/tmp", 'a')) == (key_t) -1) {
perror("IPC error: ftok");
exit(1);
}
// Create the semaphore set associated with this key
if ((semid = semget(semkey, 1, IPC_CREAT | IPC_EXCL | S_IRUSR |
S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)) != -1) {
// Initialize the semaphore.
sbuf.sem_num = 0;
sbuf.sem_op = 2; // Set the number of runs without queuing.
sbuf.sem_flg = 0;
if (semop(semid, &sbuf, 1) == -1) {
perror("IPC error: semop");
exit(1);
}
} else if (errno == EEXIST) {
// The semaphore set already exists; get its semaphore ID.
if ((semid = semget(semkey, 0, 0)) == -1) {
perror("IPC error 1: semget");
exit(1);
}
} else {
perror("IPC error 2: semget");
exit(1);
}
// Since the semget() initialized the semaphore to 0, the
// following semop() will block until the creating process
// completes the initialization above. Processes will also
// block in the following semop() call if two other processes
// have already passed this point and are still running.
sbuf.sem_num = 0;
sbuf.sem_op = -1;
sbuf.sem_flg = SEM_UNDO;
if (semop(semid, &sbuf, 1) == -1) {
perror("IPC Error: semop");
exit(1);
}
APPLICATION USAGE
The POSIX Realtime Extension defines alternative interfaces for interprocess communication. Application developers who need to
use IPC should design their applications so that modules using the IPC routines described in 2.7 XSI Interprocess Communication can be easily modified to use the alternative
interfaces.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.7 XSI Interprocess Communication, 2.8 Realtime, exec, exit(), fork(), semctl(), semget(), sem_close(), sem_destroy(), sem_getvalue(),
sem_init(), sem_open(),
sem_post(), sem_trywait(),
sem_unlink()
XBD 4.20 Semaphore, , ,
CHANGE HISTORY
First released in Issue 2. Derived from Issue 2 of the SVID.
Issue 5
The note about use of POSIX Realtime Extension IPC routines has been moved from FUTURE DIRECTIONS to a new APPLICATION USAGE
section.
Issue 7
SD5-XSH-ERN-171 is applied, updating the DESCRIPTION to clarify the order in which the operations in sops will be
performed when there are multiple operations.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0538 [329,429], XSH/TC1-2008/0539 [345,428], XSH/TC1-2008/0540
[329,429], XSH/TC1-2008/0541 [335], and XSH/TC1-2008/0542 [291,429] are applied.
Issue 8
Austin Group Defect 377 is applied, changing the EXAMPLES section.
Austin Group Defect 628 is applied, clarifying how semop() behaves when there is more than one operation in
the array specified by sops.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getgrgid.html =====
getgrgid
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getgrgid, getgrgid_r — get group database entry for a group ID
SYNOPSIS
#include
struct group *getgrgid(gid_t gid);
int getgrgid_r(gid_t gid, struct group *grp, char *buffer,
size_t bufsize, struct group **result);
DESCRIPTION
The getgrgid() function shall search the group database for an entry with a matching gid.
The getgrgid() function need not be thread-safe.
Applications wishing to check for error situations should set errno to 0 before calling getgrgid(). If
getgrgid() returns a null pointer and errno is set to non-zero, an error occurred.
The getgrgid_r() function shall update the group structure pointed to by grp and store a pointer to that
structure at the location pointed to by result. The structure shall contain an entry from the group database with a matching
gid. Storage referenced by the group structure is allocated from the memory provided with the buffer parameter, which
is bufsize bytes in size. A call to sysconf(_SC_GETGR_R_SIZE_MAX) returns either -1 without changing errno or
an initial value suggested for the size of this buffer. A null pointer shall be returned at the location pointed to by
result on error or if the requested entry is not found.
RETURN VALUE
Upon successful completion, getgrgid() shall return a pointer to a struct group with the structure defined in
with a matching entry if one is found. The getgrgid() function
shall return a null pointer if either the requested entry was not found, or an error occurred. If the requested entry was not
found, errno shall not be changed. On error, errno shall be set to indicate the error.
The application shall not modify the structure to which the return value points, nor any storage areas pointed to by pointers
within the structure. The returned pointer, and pointers within the structure, might be invalidated or the structure or the storage
areas might be overwritten by a subsequent call to getgrent(), getgrgid(),
or getgrnam(). The returned pointer, and pointers within the structure, might also
be invalidated if the calling thread is terminated.
If successful, the getgrgid_r() function shall return zero; otherwise, an error number shall be returned to indicate the
error.
ERRORS
The getgrgid() and getgrgid_r() functions may fail if:
[EIO]
An I/O error has occurred.
[EINTR]
A signal was caught during getgrgid().
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum allowable number of files is currently open in the system.
The getgrgid_r() function shall fail if:
[ERANGE]
Insufficient storage was supplied via buffer and bufsize to contain the data to be referenced by the resulting
group structure.
The following sections are informative.
EXAMPLES
Note that sysconf(_SC_GETGR_R_SIZE_MAX) may return -1 if there is no hard limit on the size of the buffer needed to store
all the groups returned. This example shows how an application can allocate a buffer of sufficient size to work with
getgrgid_r().
long int initlen = sysconf(_SC_GETGR_R_SIZE_MAX);
size_t len;
if (initlen == -1)
/* Default initial length. */
len = 1024;
else
len = (size_t) initlen;
struct group result;
struct group *resultp;
char *buffer = malloc(len);
if (buffer == NULL)
...handle error...
int e;
while ((e = getgrgid_r(42, &result, buffer, len, &resultp)) == ERANGE)
{
size_t newlen = 2 * len;
if (newlen
#include
#include
...
struct stat statbuf;
struct group *grp;
...
if ((grp = getgrgid(statbuf.st_gid)) != NULL)
printf(" %-8.8s", grp->gr_name);
else
printf(" %-8d", statbuf.st_gid);
...
APPLICATION USAGE
The getgrgid_r() function is thread-safe and shall return values in a user-supplied buffer instead of possibly using a
static data area that may be overwritten by each call.
Portable applications should take into account that it is usual for an implementation to return -1 from sysconf() indicating that there is no maximum for _SC_GETGR_R_SIZE_MAX.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
endgrent(), getgrnam(),
sysconf()
XBD ,
CHANGE HISTORY
First released in Issue 1. Derived from System V Release 2.0.
Issue 5
Normative text previously in the APPLICATION USAGE section is moved to the RETURN VALUE section.
The getgrgid_r() function is included for alignment with the POSIX Threads Extension.
A note indicating that the getgrgid() function need not be reentrant is added to the DESCRIPTION.
Issue 6
The getgrgid_r() function is marked as part of the Thread-Safe Functions option.
The Open Group Corrigendum U028/3 is applied, correcting text in the DESCRIPTION describing matching the gid.
In the DESCRIPTION, the note about reentrancy is expanded to cover thread-safety.
In the SYNOPSIS, the optional include of the  header is
removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
In the RETURN VALUE section, the requirement to set errno on error is added.
The [EIO], [EINTR], [EMFILE], and [ENFILE] optional error conditions are added.
The APPLICATION USAGE section is updated to include a note on the thread-safe function and its avoidance of possibly using a
static data area.
IEEE PASC Interpretation 1003.1 #116 is applied, changing the description of the size of the buffer from bufsize
characters to bytes.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
SD5-XBD-ERN-4 is applied, changing the definition of the [EMFILE] error.
SD5-XSH-ERN-166 is applied.
The getgrgid_r() function is moved from the Thread-Safe Functions option to the Base.
A minor addition is made to the EXAMPLES section, reminding the application developer to free memory allocated as if by malloc().
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0241 [75] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0160 [808], XSH/TC2-2008/0161 [808], XSH/TC2-2008/0162 [656], and
XSH/TC2-2008/0163 [808] are applied.
Issue 8
Austin Group Defect 398 is applied, changing the [ERANGE] error from "may fail" to "shall fail".
Austin Group Defect 1570 is applied, removing extra spacing in "==".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/toupper.html =====
toupper
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
toupper, toupper_l — transliterate lowercase characters to uppercase
SYNOPSIS
#include
int toupper(int c);
[CX]  int toupper_l(int c, locale_t locale);
DESCRIPTION
For toupper(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The toupper() [CX]   and toupper_l()
functions have as a domain a type int, the value of which is representable as an unsigned char or the value of
EOF. If the argument has any other value, the behavior is undefined.
If the argument of toupper() [CX]   or toupper_l()
represents a lowercase letter, and there exists a corresponding uppercase letter as defined by character type information in
the current locale [CX]   or in the locale represented by locale,
respectively (category LC_CTYPE ), the result shall be the corresponding uppercase letter.
All other arguments in the domain are returned unchanged.
[CX]  The
behavior is undefined if the locale argument to toupper_l() is the special locale object LC_GLOBAL_LOCALE or is not a
valid locale object handle.
RETURN VALUE
Upon successful completion, toupper() [CX]   and toupper_l()   shall return the uppercase letter corresponding to the argument passed; otherwise, they shall
return the argument unchanged.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
setlocale(), uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
Extensions beyond the ISO C standard are marked.
Issue 7
SD5-XSH-ERN-181 is applied, clarifying the RETURN VALUE section.
The toupper_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0673 [283] and XSH/TC1-2008/0674 [283] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/initstate.html =====
initstate
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
initstate, random, setstate, srandom — pseudo-random number functions
SYNOPSIS
[XSI]  #include
char *initstate(unsigned seed, char *state, size_t size);
long random(void);
char *setstate(char *state);
void srandom(unsigned seed);
DESCRIPTION
The random() function shall use a non-linear additive feedback random-number generator employing a default state array
size of 31 long integers to return successive pseudo-random numbers in the range from 0 to 231-1.
The period of this random-number generator is approximately 16 x (231-1). The size of the state array
determines the period of the random-number generator. Increasing the state array size shall increase the period.
With 256 bytes of state information, the period of the random-number generator shall be greater than
269.
Like rand(), random() shall produce by default a sequence of numbers that can
be duplicated by calling srandom() with 1 as the seed.
The srandom() function shall initialize the current state array using the value of seed.
The initstate() and setstate() functions handle restarting and changing random-number generators. The
initstate() function allows a state array, pointed to by the state argument, to be initialized for future use. The
size argument, which specifies the size in bytes of the state array, shall be used by initstate() to decide what type
of random-number generator to use; the larger the state array, the more random the numbers. Values for the amount of state
information are 8, 32, 64, 128, and 256 bytes. Other values greater than 8 bytes are rounded down to the nearest one of these
values. If initstate() is called with 8
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
In the DESCRIPTION, the phrase "values smaller than 8" is replaced with "values greater than or equal to 8, or less than
32", "size>>
===== susv5-html/functions/floorf.html =====
floor
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
floor, floorf, floorl — floor function
SYNOPSIS
#include
double floor(double x);
float floorf(float x);
long double floorl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the largest integral value not greater than x.
[MX]
These functions may raise the inexact floating-point exception for finite non-integer arguments.
RETURN VALUE
[MX]  The
returned value shall be independent of the current rounding direction mode and shall have the same sign as x.
Upon successful completion, these functions shall return the largest integral value not greater than x, expressed as a
double, float, or long double, as appropriate for the return type of the function.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0 or ±Inf, x shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The integral value returned by these functions might not be expressible as an intmax_t. The return value should be tested
before assigning it to an integer type to avoid the undefined results of an integer overflow.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
ceil(), feclearexcept(),
fetestexcept(), isnan()
4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The floorf() and floorl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0141 [346] is applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/reallocarray.html =====
realloc
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
realloc, reallocarray — memory reallocators
SYNOPSIS
#include
void *realloc(void *ptr, size_t size);
[CX]  void *reallocarray(void *ptr, size_t nelem, size_t
elsize);
DESCRIPTION
For realloc(): [CX]  The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The realloc() function shall deallocate the old object pointed to by ptr and return a pointer to a new object that
has the size specified by size. The contents of the new object shall be the same as that of the old object prior to
deallocation, up to the lesser of the new and old sizes. Any bytes in the new object beyond the size of the old object have
indeterminate values.
[CX]  The
reallocarray() function shall be equivalent to the call realloc(ptr, nelem * elsize) except
that overflow in the multiplication shall be an error.
If ptr is a null pointer, realloc() [CX]   or reallocarray()   shall be equivalent to malloc() for the specified
size. Otherwise, if ptr does not match a pointer earlier returned by aligned_alloc(), calloc(), malloc(), [ADV]   posix_memalign(),
realloc(),
[CX]
reallocarray(), or a function in POSIX.1-2024 that allocates memory as if by malloc(),   or if the
space has been deallocated by a call to free(), [CX]   reallocarray(),
or realloc(),  the behavior is undefined.
If size is non-zero and memory for the new object is not allocated, the old object shall not be deallocated.
The order and contiguity of storage allocated by successive calls to realloc() [CX]   or
reallocarray()   is unspecified. The pointer returned if
the allocation succeeds shall be suitably aligned so that it may be assigned to a pointer to any type of object with a fundamental
alignment requirement and then used to access such an object in the space allocated (until the space is explicitly freed or
reallocated). Each such allocation shall yield a pointer to an object disjoint from any other object. The pointer returned shall
point to the start (lowest byte address) of the allocated space. If the space cannot be allocated, a null pointer shall be
returned.
For purposes of determining the existence of a data race, realloc() [CX]   and
reallocarray()   shall each behave as though it accessed
only memory locations accessible through its argument and not other static duration storage. The function may, however, visibly
modify the storage that it allocates. Calls to aligned_alloc(), calloc(), free(), malloc(), [ADV]   posix_memalign(),
[CX]
reallocarray(),   and realloc() that allocate or
deallocate a particular region of memory shall occur in a single total order (see 4.15.1 Memory Ordering), and each such deallocation call shall synchronize
with the next allocation (if any) in this order.
RETURN VALUE
Upon successful completion, realloc() [CX]   and reallocarray()   shall return a pointer to the new object (which can have the same value as a pointer to the old
object), or a null pointer if the new object has not been allocated.
[OB]  If
size is 0,
[OB CX]
or either nelem or elsize is 0,
[OB]  either:
[OB]  A
null pointer shall be returned
[OB CX]
and, if ptr is not a null pointer, errno shall be
set to [EINVAL].
[OB]  A
pointer to the allocated space shall be returned, and the memory object pointed to by ptr shall be freed. The application
shall ensure that the pointer is not used to access an object.
If there is not enough available memory, realloc() [CX]   and reallocarray()   shall return a null pointer
[CX]  and
set errno to [ENOMEM].
ERRORS
The realloc() [CX]   and reallocarray()
functions shall fail if:
[ENOMEM]
[CX]
Insufficient memory is available.
[CX]  The
reallocarray() function shall fail if:
[ENOMEM]
The calculation nelem * elsize would overflow.
The realloc() [CX]   and reallocarray()
functions may fail if:
[EINVAL]
[CX]
The requested allocation size is 0 and the implementation does not support 0 sized allocations.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The ISO C standard makes it implementation-defined whether a call to realloc(p, 0) frees the space pointed to
by p if it returns a null pointer because memory for the new object was not allocated. POSIX.1 instead requires that
implementations set errno if a null pointer is returned and the space has not been freed, and POSIX applications should only
free the space if errno was changed.
RATIONALE
See the RATIONALE for malloc().
FUTURE DIRECTIONS
The ISO C standard states that invoking realloc() with a size argument equal to zero is an obsolescent
feature. This feature may be removed in a future version of this standard.
SEE ALSO
aligned_alloc(), calloc()
, free(), malloc()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the RETURN VALUE section, if there is not enough available memory, the setting of errno to [ENOMEM] is added.
The [ENOMEM] error condition is added.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0495 [400], XSH/TC1-2008/0496 [400], XSH/TC1-2008/0497 [400], and
XSH/TC1-2008/0498 [400] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0309 [526] and XSH/TC2-2008/0310 [526,688] are applied.
Issue 8
Austin Group Defect 374 is applied, adding the [EINVAL] error.
Austin Group Defect 1218 is applied, adding reallocarray().
Austin Group Defect 1302 is applied, aligning the realloc() function with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1387 is applied, changing the RATIONALE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mbrlen.html =====
mbrlen
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mbrlen — get number of bytes in a character (restartable)
SYNOPSIS
#include
size_t mbrlen(const char *restrict s, size_t n,
mbstate_t *restrict ps);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
If s is not a null pointer, mbrlen() shall determine the number of bytes constituting the character pointed to by
s. It shall be equivalent to:
mbstate_t internal;
mbrtowc(NULL, s, n, ps != NULL ? ps : &internal);
If ps is a null pointer, the mbrlen() function shall use its own internal mbstate_t object, which is
initialized at program start-up to the initial conversion state. Otherwise, the mbstate_t object pointed to by ps
shall be used to completely describe the current conversion state of the associated character sequence. The implementation shall
behave as if no function defined in this volume of POSIX.1-2024 calls mbrlen().
The behavior of this function is affected by the LC_CTYPE category of the current locale.
If called with a null ps argument, the mbrlen() function need not be thread-safe; however, such calls shall avoid
data races with calls to mbrlen() with a non-null argument and with calls to all other functions.
The mbrlen() function shall not change the setting of errno if successful.
RETURN VALUE
The mbrlen() function shall return the first of the following that applies:
0
If the next n or fewer bytes complete the character that corresponds to the null wide character.
positive
If the next n or fewer bytes complete a valid character; the value returned shall be the number of bytes that complete
the character.
(size_t)-2
If the next n bytes contribute to an incomplete but potentially valid character, and all n bytes have been
processed. When n has at least the value of the {MB_CUR_MAX} macro, this case can only occur if s points at a
sequence of redundant shift sequences (for implementations with state-dependent encodings).
(size_t)-1
If an encoding error occurs, in which case the next n or fewer bytes do not contribute to a complete and valid
character. In this case, [EILSEQ] shall be stored in errno and the conversion state is undefined.
ERRORS
The mbrlen() function shall fail if:
[EILSEQ]
An invalid character sequence is detected. [CX]   In the POSIX locale an [EILSEQ] error cannot occur since all byte
values are valid characters.
The mbrlen() function may fail if:
[EINVAL]
ps points to an object that contains an invalid conversion state.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
mbsinit(), mbrtowc()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E).
Issue 6
The mbrlen() prototype is updated for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
Austin Group Interpretation 1003.1-2001 #170 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0368 [109,105] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0204 [663,674] is applied.
Issue 8
Austin Group Defect 1302 is applied, aligning this function with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sysconf.html =====
sysconf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sysconf — get configurable system variables
SYNOPSIS
#include
long sysconf(int name);
DESCRIPTION
The sysconf() function provides a method for the application to determine the current value of a configurable system
limit or option (variable). The implementation shall support all of the variables listed in the following table and may
support others.
The name argument represents the system variable to be queried. The following table lists the minimal set of system
variables from  or  that can be returned by sysconf(), and the symbolic constants
defined in  that are the corresponding values used for
name.
Variable
Value of Name
{AIO_LISTIO_MAX}
_SC_AIO_LISTIO_MAX
{AIO_MAX}
_SC_AIO_MAX
{AIO_PRIO_DELTA_MAX}
_SC_AIO_PRIO_DELTA_MAX
{ARG_MAX}
_SC_ARG_MAX
{ATEXIT_MAX}
_SC_ATEXIT_MAX
{BC_BASE_MAX}
_SC_BC_BASE_MAX
{BC_DIM_MAX}
_SC_BC_DIM_MAX
{BC_SCALE_MAX}
_SC_BC_SCALE_MAX
{BC_STRING_MAX}
_SC_BC_STRING_MAX
{CHILD_MAX}
_SC_CHILD_MAX
Clock ticks/second
_SC_CLK_TCK
{COLL_WEIGHTS_MAX}
_SC_COLL_WEIGHTS_MAX
{DELAYTIMER_MAX}
_SC_DELAYTIMER_MAX
{EXPR_NEST_MAX}
_SC_EXPR_NEST_MAX
{HOST_NAME_MAX}
_SC_HOST_NAME_MAX
{IOV_MAX}
_SC_IOV_MAX
{LINE_MAX}
_SC_LINE_MAX
{LOGIN_NAME_MAX}
_SC_LOGIN_NAME_MAX
{NGROUPS_MAX}
_SC_NGROUPS_MAX
Initial size of getgrgid_r() and
_SC_GETGR_R_SIZE_MAX
getgrnam_r() data buffers
Initial size of getpwuid_r() and
_SC_GETPW_R_SIZE_MAX
getpwnam_r() data buffers
{MQ_OPEN_MAX}
_SC_MQ_OPEN_MAX
{MQ_PRIO_MAX}
_SC_MQ_PRIO_MAX
Maximum number of execution units that can be made available to run threads†
_SC_NPROCESSORS_CONF
Maximum number of execution units currently available to run threads†
_SC_NPROCESSORS_ONLN
Highest supported signal number +1
_SC_NSIG
{OPEN_MAX}
_SC_OPEN_MAX
{PAGE_SIZE}
_SC_PAGE_SIZE
{PAGESIZE}
_SC_PAGESIZE
{PTHREAD_DESTRUCTOR_ITERATIONS}
_SC_THREAD_DESTRUCTOR_ITERATIONS
{PTHREAD_KEYS_MAX}
_SC_THREAD_KEYS_MAX
{PTHREAD_STACK_MIN}
_SC_THREAD_STACK_MIN
{PTHREAD_THREADS_MAX}
_SC_THREAD_THREADS_MAX
{RE_DUP_MAX}
_SC_RE_DUP_MAX
{RTSIG_MAX}
_SC_RTSIG_MAX
{SEM_NSEMS_MAX}
_SC_SEM_NSEMS_MAX
{SEM_VALUE_MAX}
_SC_SEM_VALUE_MAX
{SIGQUEUE_MAX}
_SC_SIGQUEUE_MAX
{STREAM_MAX}
_SC_STREAM_MAX
{SYMLOOP_MAX}
_SC_SYMLOOP_MAX
{TIMER_MAX}
_SC_TIMER_MAX
{TTY_NAME_MAX}
_SC_TTY_NAME_MAX
{TZNAME_MAX}
_SC_TZNAME_MAX
_POSIX_ADVISORY_INFO
_SC_ADVISORY_INFO
_POSIX_BARRIERS
_SC_BARRIERS
_POSIX_ASYNCHRONOUS_IO
_SC_ASYNCHRONOUS_IO
_POSIX_CLOCK_SELECTION
_SC_CLOCK_SELECTION
_POSIX_CPUTIME
_SC_CPUTIME
_POSIX_DEVICE_CONTROL
_SC_DEVICE_CONTROL
_POSIX_FSYNC
_SC_FSYNC
_POSIX_IPV6
_SC_IPV6
_POSIX_JOB_CONTROL
_SC_JOB_CONTROL
_POSIX_MAPPED_FILES
_SC_MAPPED_FILES
_POSIX_MEMLOCK
_SC_MEMLOCK
_POSIX_MEMLOCK_RANGE
_SC_MEMLOCK_RANGE
_POSIX_MEMORY_PROTECTION
_SC_MEMORY_PROTECTION
_POSIX_MESSAGE_PASSING
_SC_MESSAGE_PASSING
_POSIX_MONOTONIC_CLOCK
_SC_MONOTONIC_CLOCK
_POSIX_PRIORITIZED_IO
_SC_PRIORITIZED_IO
_POSIX_PRIORITY_SCHEDULING
_SC_PRIORITY_SCHEDULING
_POSIX_RAW_SOCKETS
_SC_RAW_SOCKETS
_POSIX_READER_WRITER_LOCKS
_SC_READER_WRITER_LOCKS
_POSIX_REALTIME_SIGNALS
_SC_REALTIME_SIGNALS
_POSIX_REGEXP
_SC_REGEXP
_POSIX_SAVED_IDS
_SC_SAVED_IDS
_POSIX_SEMAPHORES
_SC_SEMAPHORES
_POSIX_SHARED_MEMORY_OBJECTS
_SC_SHARED_MEMORY_OBJECTS
_POSIX_SHELL
_SC_SHELL
_POSIX_SPAWN
_SC_SPAWN
_POSIX_SPIN_LOCKS
_SC_SPIN_LOCKS
_POSIX_SPORADIC_SERVER
_SC_SPORADIC_SERVER
_POSIX_SS_REPL_MAX
_SC_SS_REPL_MAX
_POSIX_SYNCHRONIZED_IO
_SC_SYNCHRONIZED_IO
_POSIX_THREAD_ATTR_STACKADDR
_SC_THREAD_ATTR_STACKADDR
_POSIX_THREAD_ATTR_STACKSIZE
_SC_THREAD_ATTR_STACKSIZE
_POSIX_THREAD_CPUTIME
_SC_THREAD_CPUTIME
_POSIX_THREAD_PRIO_INHERIT
_SC_THREAD_PRIO_INHERIT
_POSIX_THREAD_PRIO_PROTECT
_SC_THREAD_PRIO_PROTECT
_POSIX_THREAD_PRIORITY_SCHEDULING
_SC_THREAD_PRIORITY_SCHEDULING
_POSIX_THREAD_PROCESS_SHARED
_SC_THREAD_PROCESS_SHARED
Variable
Value of Name
_POSIX_THREAD_ROBUST_PRIO_INHERIT
_SC_THREAD_ROBUST_PRIO_INHERIT
_POSIX_THREAD_ROBUST_PRIO_PROTECT
_SC_THREAD_ROBUST_PRIO_PROTECT
_POSIX_THREAD_SAFE_FUNCTIONS
_SC_THREAD_SAFE_FUNCTIONS
_POSIX_THREAD_SPORADIC_SERVER
_SC_THREAD_SPORADIC_SERVER
_POSIX_THREADS
_SC_THREADS
_POSIX_TIMEOUTS
_SC_TIMEOUTS
_POSIX_TIMERS
_SC_TIMERS
_POSIX_TYPED_MEMORY_OBJECTS
_SC_TYPED_MEMORY_OBJECTS
_POSIX_VERSION
_SC_VERSION
_POSIX_V8_ILP32_OFF32
_SC_V8_ILP32_OFF32
_POSIX_V8_ILP32_OFFBIG
_SC_V8_ILP32_OFFBIG
_POSIX_V8_LP64_OFF64
_SC_V8_LP64_OFF64
_POSIX_V8_LPBIG_OFFBIG
_SC_V8_LPBIG_OFFBIG
[OB]  _POSIX_V7_ILP32_OFF32
_SC_V7_ILP32_OFF32
_POSIX_V7_ILP32_OFFBIG
_SC_V7_ILP32_OFFBIG
_POSIX_V7_LP64_OFF64
_SC_V7_LP64_OFF64
_POSIX_V7_LPBIG_OFFBIG
_SC_V7_LPBIG_OFFBIG
_POSIX2_C_BIND
_SC_2_C_BIND
_POSIX2_C_DEV
_SC_2_C_DEV
_POSIX2_CHAR_TERM
_SC_2_CHAR_TERM
_POSIX2_FORT_RUN
_SC_2_FORT_RUN
_POSIX2_LOCALEDEF
_SC_2_LOCALEDEF
_POSIX2_SW_DEV
_SC_2_SW_DEV
_POSIX2_UPE
_SC_2_UPE
_POSIX2_VERSION
_SC_2_VERSION
_XOPEN_CRYPT
_SC_XOPEN_CRYPT
_XOPEN_ENH_I18N
_SC_XOPEN_ENH_I18N
_XOPEN_REALTIME
_SC_XOPEN_REALTIME
_XOPEN_REALTIME_THREADS
_SC_XOPEN_REALTIME_THREADS
_XOPEN_SHM
_SC_XOPEN_SHM
_XOPEN_UNIX
_SC_XOPEN_UNIX
_XOPEN_UUCP
_SC_XOPEN_UUCP
_XOPEN_VERSION
_SC_XOPEN_VERSION
† The nature of an execution unit and the precise conditions under which an execution unit is considered to be
available, or can be made available, or how many threads it can execute in parallel, are implementation-defined.
RETURN VALUE
If name is an invalid value, sysconf() shall return -1 and set errno to indicate the error. If the variable
corresponding to name is described in  as a maximum or
minimum value and the variable has no limit, sysconf() shall return -1 without changing the value of errno. Note that
indefinite limits do not imply infinite limits; see .
Otherwise, sysconf() shall return the current variable value on the system. The value returned shall not be
more restrictive than the corresponding value described to the application when it was compiled with the implementation's  or . The
value returned for name arguments other than _SC_NPROCESSORS_ONLN shall not change during the lifetime of the calling
process, except that sysconf(_SC_OPEN_MAX) may return different values before and after a call to setrlimit() which changes the RLIMIT_NOFILE soft limit.
If the variable corresponding to name is dependent on an unsupported option, the results are
unspecified.
ERRORS
The sysconf() function shall fail if:
[EINVAL]
The value of the name argument is invalid.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
As -1 is a permissible return value in a successful situation, an application wishing to check for error situations should set
errno to 0, then call sysconf(), and, if it returns -1, check to see if errno is non-zero.
Application developers should check whether an option, such as _POSIX_SPORADIC_SERVER, is supported prior to
obtaining and using values for related variables, such as _POSIX_SS_REPL_MAX.
Although the queries _SC_NPROCESSORS_CONF and _SC_NPROCESSORS_ONLN provide a way for a class of "heavy-load"
application to estimate the optimal number of threads that can be created to maximize throughput, real-world environments have
complications that affect the actual efficiency that can be achieved. For example:
There may be more than one "heavy-load" application running on the system.
The system may be on battery power, and applications should co-ordinate with the system to ensure that a
long-running task can pause, resume, and successfully complete even in the event of a power outage.
In case a portable "heavy-load" application wants to avoid the use of extensions, its developers may wish to
create threads based on the logical partition of the long-running task, or utilize heuristics such as the ratio between CPU time
and real time.
RATIONALE
This functionality was added in response to requirements of application developers and of system vendors who deal with many
international system configurations. It is closely related to pathconf() and
fpathconf().
Although a conforming application can run on all systems by never demanding more resources than the minimum values
published in this volume of POSIX.1-2024, it is useful for that application to be able to use the actual value for the quantity of
a resource available on any given system. To do this, the application makes use of the value of a symbolic constant in  or .
However, once compiled, the application must still be able to cope if the amount of resource available is
increased. To that end, an application may need a means of determining the quantity of a resource, or the presence of an option, at
execution time.
Two examples are offered:
Applications may wish to act differently on systems with or without job control. Applications vendors who wish to
distribute only a single binary package to all instances of a computer architecture would be forced to assume job control is never
available if it were to rely solely on the  value published in this
volume of POSIX.1-2024.
International applications vendors occasionally require knowledge of the number of clock ticks per second. Without
these facilities, they would be required to either distribute their applications partially in source form or to have 50 Hz and 60
Hz versions for the various countries in which they operate.
It is the knowledge that many applications are actually distributed widely in executable form that leads to this
facility. If limited to the most restrictive values in the headers, such applications would have to be prepared to accept the most
limited environments offered by the smallest microcomputers. Although this is entirely portable, there was a consensus that they
should be able to take advantage of the facilities offered by large systems, without the restrictions associated with source and
object distributions.
During the discussions of this feature, it was pointed out that it is almost always possible for an application to
discern what a value might be at runtime by suitably testing the various functions themselves. And, in any event, it could always
be written to adequately deal with error returns from the various functions. In the end, it was felt that this imposed an
unreasonable level of complication and sophistication on the application developer.
This runtime facility is not meant to provide ever-changing values that applications have to check multiple times.
The values are seen as changing no more frequently than once per system initialization, such as by a system administrator or
operator with an automatic configuration program. This volume of POSIX.1-2024 specifies that they shall not change within the
lifetime of the process.
Some values apply to the system overall and others vary at the file system or directory level. The latter are
described in fpathconf().
Note that all values returned must be expressible as integers. String values were considered, but the additional
flexibility of this approach was rejected due to its added complexity of implementation and use.
Some values, such as {PATH_MAX}, are sometimes so large that they must not be used to, say, allocate arrays. The
sysconf() function returns a negative value to show that this symbolic constant is not even defined in this case.
Similar to pathconf(), this permits the implementation not to have
a limit. When one resource is infinite, returning an error indicating that some other resource limit has been reached is conforming
behavior.
FUTURE DIRECTIONS
None.
SEE ALSO
confstr(), fpathconf()
XBD ,
XCU getconf
CHANGE HISTORY
First released in Issue 3. Included for alignment with the POSIX.1-1988 standard.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Realtime Extension and the POSIX Threads Extension.
The _XBS_ variables and name values are added to the table of system variables in the DESCRIPTION. These are all
marked EX.
Issue 6
The symbol CLK_TCK is obsolescent and removed. It is replaced with the phrase "clock ticks per second".
The symbol {PASS_MAX} is removed.
The following changes were made to align with the IEEE P1003.1a draft standard:
Table entries are added for the following variables: _SC_REGEXP, _SC_SHELL, _SC_REGEX_VERSION,
_SC_SYMLOOP_MAX.
The following sysconf() variables and their associated names are added for alignment with
IEEE Std 1003.1d-1999:
_POSIX_ADVISORY_INFO
_POSIX_CPUTIME
_POSIX_SPAWN
_POSIX_SPORADIC_SERVER
_POSIX_THREAD_CPUTIME
_POSIX_THREAD_SPORADIC_SERVER
_POSIX_TIMEOUTS
The following changes are made to the DESCRIPTION for alignment with IEEE Std 1003.1j-2000:
A statement expressing the dependency of support for some system variables on implementation options is
added.
The following system variables are added:
_POSIX_BARRIERS
_POSIX_CLOCK_SELECTION
_POSIX_MONOTONIC_CLOCK
_POSIX_READER_WRITER_LOCKS
_POSIX_SPIN_LOCKS
_POSIX_TYPED_MEMORY_OBJECTS
The following system variables are added for alignment with IEEE Std 1003.2d-1994:
_POSIX2_PBS
_POSIX2_PBS_ACCOUNTING
_POSIX2_PBS_LOCATE
_POSIX2_PBS_MESSAGE
_POSIX2_PBS_TRACK
The following sysconf() variables and their associated names are added for alignment with
IEEE Std 1003.1q-2000:
_POSIX_TRACE
_POSIX_TRACE_EVENT_FILTER
_POSIX_TRACE_INHERIT
_POSIX_TRACE_LOG
The macros associated with the c89 programming models are marked LEGACY, and new equivalent macros
associated with c99 are introduced.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/62 is applied, updating the DESCRIPTION to denote
that the _PC* and _SC* symbols are now required to be supported. A corresponding change has been made in the Base Definitions
volume of POSIX.1-2024. The deletion in the second paragraph removes some duplicated text. Additional symbols that were erroneously
omitted from this reference page have been added.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/63 is applied, making it clear in the RETURN VALUE
section that the value returned for sysconf(_SC_OPEN_MAX) may change if a call to setrlimit() adjusts the RLIMIT_NOFILE soft limit.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/134 is applied, updating the DESCRIPTION to remove
an erroneous entry for _POSIX_SYMLOOP_MAX. This corrects an error in IEEE Std 1003.1-2001/Cor 1-2002.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/135 is applied, removing _POSIX_FILE_LOCKING,
_POSIX_MULTI_PROCESS, _POSIX2_C_VERSION, and _XOPEN_XCU_VERSION (and their associated _SC_* variables) from the DESCRIPTION and
APPLICATION USAGE sections.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/136 is applied, adding the following constants (and
their associated _SC_* variables) to the DESCRIPTION:
_POSIX_SS_REPL_MAX
_POSIX_TRACE_EVENT_NAME_MAX
_POSIX_TRACE_NAME_MAX
_POSIX_TRACE_SYS_MAX
_POSIX_TRACE_USER_EVENT_MAX
The RETURN VALUE and APPLICATION USAGE sections are updated to note that if variables are dependent on unsupported
options, the results are unspecified.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/137 is applied, removing _REGEX_VERSION and
_SC_REGEX_VERSION.
Issue 7
Austin Group Interpretation 1003.1-2001 #160 is applied.
SD5-XSH-ERN-166 is applied, changing "Maximum size" to "Initial size" for the "Maximum size of ..." entries
in the table in the DESCRIPTION.
The variables for the supported programming environments are updated to be V7 and the LEGACY variables are
removed.
The following constants are added:
_POSIX_THREAD_ROBUST_PRIO_INHERIT
_POSIX_THREAD_ROBUST_PRIO_PROTECT
The _XOPEN_UUCP variable and its associated _SC_XOPEN_UUCP value is added to the table of system variables.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0364 [752] is applied.
Issue 8
Austin Group Defect 51 is applied, moving the getrlimit() and setrlimit() functions, excluding the RLIMIT_CPU and RLIMIT_FSIZE limits, from the XSI
option to the Base.
Austin Group Defects 339 and 1608 are applied, adding _SC_NPROCESSORS_CONF and _SC_NPROCESSORS_ONLN.
Austin Group Defect 729 is applied, adding _SC_DEVICE_CONTROL.
Austin Group Defect 741 is applied, adding _SC_NSIG.
Austin Group Defect 1330 is applied, removing obsolescent interfaces and changing "_V7_" to "_V8_" and "_V6_"
to "_V7_".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/powl.html =====
pow
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pow, powf, powl — power function
SYNOPSIS
#include
double pow(double x, double y);
float powf(float x, float y);
long double powl(long double x, long double y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the value of x raised to the power y, xy. If
x is negative, the application shall ensure that y is an integer value.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the value of x raised to the power y.
For finite values of x  0, if x is ±0, ±0 shall be returned.
For y > 0 and not an odd integer, if x is ±0, +0 shall be returned.
If x is -1, and y is ±Inf, 1.0 shall be returned.
For |x|  1, if y is -Inf, +0 shall be returned.
For |x|  1, if y is +Inf, +Inf shall be returned.
For y an odd integer  0, if x is -Inf, -Inf shall be returned.
For y > 0 and not an odd integer, if x is -Inf, +Inf shall be returned.
For y  0, if x is +Inf, +Inf shall be returned.
[MXX]
If the correct value would cause underflow, and is representable, a range error may occur and the correct value shall be returned.
ERRORS
These functions shall fail if:
Domain Error
The value of x is negative and y is a finite non-integer.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
Pole Error
[MX]
The value of x is zero and y is negative.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the divide-by-zero floating-point exception shall
be raised.
Range Error
The result overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
These functions may fail if:
Pole Error
The value of x is zero and y is negative.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the divide-by-zero floating-point exception shall
be raised.
Range Error
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
exp(), feclearexcept(),
fetestexcept(), isnan()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
The powf() and powl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/42 is applied, correcting the third paragraph in the RETURN
VALUE section.
Issue 7
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #51 (SD5-XSH-ERN-81) is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0443 [68], XSH/TC1-2008/0444 [148], and XSH/TC1-2008/0445 [68] are
applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strstr.html =====
strstr
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strstr — find a substring
SYNOPSIS
#include
char *strstr(const char *s1, const char *s2);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The strstr() function shall locate the first occurrence in the string pointed to by s1 of the sequence of bytes
(excluding the terminating NUL character) in the string pointed to by s2.
[CX]  The
strstr() function shall not change the setting of errno on valid input.
RETURN VALUE
Upon successful completion, strstr() shall return a pointer to the located string or a null pointer if the string is not
found.
If s2 points to a string with zero length, the function shall return s1.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
memmem(), strchr()
XBD
CHANGE HISTORY
First released in Issue 3. Included for alignment with the ANSI C standard.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that strstr() does not change the setting of errno on
valid input.
Austin Group Defect 1061 is applied, adding memmem() to the SEE ALSO section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/feof.html =====
feof
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
feof — test end-of-file indicator on a stream
SYNOPSIS
#include
int feof(FILE *stream);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The feof() function shall test the end-of-file indicator for the stream pointed to by stream.
[CX]  The
feof() function shall not change the setting of errno if stream is valid.
RETURN VALUE
The feof() function shall return non-zero if and only if the end-of-file indicator is set for stream.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
clearerr(), ferror(), fopen()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0124 [401] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getdate_err.html =====
getdate
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getdate — convert user format date and time
SYNOPSIS
[XSI]  #include
struct tm *getdate(const char *string);
DESCRIPTION
The getdate() function shall convert a string representation of a date or time into a broken-down time.
The external variable or macro getdate_err, which has type int, is used by getdate() to return error
values. It is unspecified whether getdate_err is a macro or an identifier declared with external linkage, and whether or not
it is a modifiable lvalue. If a macro definition is suppressed in order to access an actual object, or a program defines an
identifier with the name getdate_err, the behavior is undefined.
Templates are used to parse and interpret the input string. The templates are contained in a text file identified by the
environment variable DATEMSK . The DATEMSK variable should be set to indicate the full pathname of the file that
contains the templates. The first line in the template that matches the input specification is used for interpretation and
conversion into the internal time format.
The following conversion specifications shall be supported:
%%
Equivalent to %.
%a
Abbreviated weekday name.
%A
Full weekday name.
%b
Abbreviated month name.
%B
Full month name.
%c
Locale's appropriate date and time representation.
%C
Century number [00,99]; leading zeros are permitted but not required.
%d
Day of month [01,31]; the leading 0 is optional.
%D
Date as %m/%d/%y.
%e
Equivalent to %d.
%h
Abbreviated month name.
%H
Hour [00,23].
%I
Hour [01,12].
%m
Month number [01,12].
%M
Minute [00,59].
%n
Equivalent to .
%p
Locale's equivalent of either AM or PM.
%r
The locale's appropriate representation of time in 12-hour clock notation, if the 12-hour format is supported in the locale
(see XBD 7.3.5 LC_TIME). In the POSIX locale, this shall be
equivalent to %I:%M:%S %p.
%R
Time as %H:%M.
%S
Seconds [00,60]. The range goes to 60 (rather than stopping at 59) to allow positive leap seconds to be expressed. Since leap
seconds cannot be predicted by any algorithm, leap second data has to come from some external source.
%t
Equivalent to .
%T
Time as %H:%M:%S.
%w
Weekday number (Sunday = [0,6]).
%x
Locale's appropriate date representation.
%X
Locale's appropriate time representation.
%y
Year within century. When a century is not otherwise specified, values in the range [69,99] shall refer to years 1969 to 1999
inclusive, and values in the range [00,68] shall refer to years 2000 to 2068 inclusive.
Note:
It is expected that in a future version of this standard the default century inferred from a 2-digit year will change. (This
would apply to all commands accepting a 2-digit year as input.)
%Y
Year as "ccyy" (for example, 2001).
%Z
Timezone name or no characters if no timezone exists. If the timezone supplied by %Z is not the timezone that
getdate() expects, an invalid input specification error shall result. The getdate() function calculates an expected
timezone based on information supplied to the function (such as the hour, day, and month).
The match between the template and input specification performed by getdate() shall be case-insensitive.
The month and weekday names can consist of any combination of upper and lowercase letters. The process can request that the
input date or time specification be in a specific language by setting the LC_TIME category (see setlocale()).
Leading zeros are not necessary for the descriptors that allow leading zeros. However, at most two digits are allowed for those
descriptors, including leading zeros. Extra white space in either the template file or in string shall be ignored.
The results are undefined if the conversion specifications %c, %x, and %X include unsupported
conversion specifications.
The following rules apply for converting the input specification into the internal format:
If %Z is being scanned, then getdate() shall initialize the broken-down time to be the current time in the
scanned timezone. Otherwise, it shall initialize the broken-down time based on the current local time as if localtime() had been called.
If only the weekday is given, the day chosen shall be the day, starting with today and moving into the future, which first
matches the named day.
If only the month (and no year) is given, the month chosen shall be the month, starting with the current month and moving into
the future, which first matches the named month. The first day of the month shall be assumed if no day is given.
If no hour, minute, and second are given, the current hour, minute, and second shall be assumed.
If no date is given, the hour chosen shall be the hour, starting with the current hour and moving into the future, which first
matches the named hour.
If a conversion specification in the DATEMSK file does not correspond to one of the conversion specifications above, the
behavior is unspecified.
The getdate() function need not be thread-safe.
RETURN VALUE
Upon successful completion, getdate() shall return a pointer to a struct tm. Otherwise, it shall return a null
pointer and set getdate_err to indicate the error.
ERRORS
The getdate() function shall fail in the following cases, setting getdate_err to the value shown in the list
below. Any changes to errno are unspecified.
The DATEMSK environment variable is null or undefined.
The template file cannot be opened for reading.
Failed to get file status information.
The template file is not a regular file.
An I/O error is encountered while reading the template file.
Memory allocation failed (not enough memory available).
There is no line in the template that matches the input.
Invalid input specification. For example, February 31; or a time is specified that cannot be represented in a time_t
(representing the time in seconds since the Epoch).
The following sections are informative.
EXAMPLES
The following example shows the possible contents of a template:
%m
%A %B %d, %Y, %H:%M:%S
%A
%B
%m/%d/%y %I %p
%d,%m,%Y %H:%M
at %A the %dst of %B in %Y
run job at %I %p,%B %dnd
%A den %d. %B %Y %H.%M Uhr
The following are examples of valid input specifications for the template in Example 1:
getdate("10/1/87 4 PM");
getdate("Friday");
getdate("Friday September 18, 1987, 10:30:30");
getdate("24,9,1986 10:30");
getdate("at monday the 1st of december in 1986");
getdate("run job at 3 PM, december 2nd");
If the LC_TIME category is set to a German locale that includes freitag as a weekday name and oktober as a
month name, the following would be valid:
getdate("freitag den 10. oktober 1986 10.30 Uhr");
The following example shows how local date and time specification can be defined in the template:
Invocation
Line in Template
getdate("11/27/86")
%m/%d/%y
getdate("27.11.86")
%d.%m.%y
getdate("86-11-27")
%y-%m-%d
getdate("Friday 12:00:00")
%A %H:%M:%S
The following examples help to illustrate the above rules assuming that the current date is Mon Sep 22 12:19:47
EDT 1986 and the LC_TIME category is set to the default C or POSIX locale:
Input
Line in Template
Date
Mon
%a
Mon Sep 22 12:19:47 EDT 1986
Sun
%a
Sun Sep 28 12:19:47 EDT 1986
Fri
%a
Fri Sep 26 12:19:47 EDT 1986
September
%B
Mon Sep 1 12:19:47 EDT 1986
January
%B
Thu Jan 1 12:19:47 EST 1987
December
%B
Mon Dec 1 12:19:47 EST 1986
Sep Mon
%b %a
Mon Sep 1 12:19:47 EDT 1986
Jan Fri
%b %a
Fri Jan 2 12:19:47 EST 1987
Dec Mon
%b %a
Mon Dec 1 12:19:47 EST 1986
Jan Wed 1989
%b %a %Y
Wed Jan 4 12:19:47 EST 1989
Fri 9
%a %H
Fri Sep 26 09:00:00 EDT 1986
Feb 10:30
%b %H:%S
Sun Feb 1 10:00:30 EST 1987
10:30
%H:%M
Tue Sep 23 10:30:00 EDT 1986
13:30
%H:%M
Mon Sep 22 13:30:00 EDT 1986
APPLICATION USAGE
Although historical versions of getdate() did not require that  declare the external variable getdate_err, this volume of POSIX.1-2024
does require it. The standard developers encourage applications to remove declarations of getdate_err and instead
incorporate the declaration by including .
Applications should use %Y (4-digit years) in preference to %y (2-digit years).
RATIONALE
In standard locales, the conversion specifications %c, %x, and %X do not include unsupported
conversion specifiers and so the text regarding results being undefined is not a problem in that case.
FUTURE DIRECTIONS
None.
SEE ALSO
ctime(), localtime(), setlocale(), strftime(), times()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
The last paragraph of the DESCRIPTION is added.
The %C conversion specification is added, and the exact meaning of the %y conversion
specification is clarified in the DESCRIPTION.
A note indicating that this function need not be reentrant is added to the DESCRIPTION.
The %R conversion specification is changed to follow historical practice.
Issue 6
The DESCRIPTION is updated to refer to "seconds since the Epoch" rather than "seconds since 00:00:00 UTC (Coordinated
Universal Time), January 1 1970" for consistency with other time functions.
The description of %S is updated so that the valid range is [00,60] rather than [00,61].
The DESCRIPTION is updated to refer to conversion specifications instead of field descriptors for consistency with
other functions.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
The description of the getdate_err value is expanded.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0152 [796] is applied.
Issue 8
Austin Group Defect 1307 is applied, changing the %r conversion in relation to locales that do not support the 12-hour
clock format.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strfmon.html =====
strfmon
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strfmon, strfmon_l — convert monetary value to a string
SYNOPSIS
#include
ssize_t strfmon(char *restrict s, size_t maxsize,
const char *restrict format, ...);
ssize_t strfmon_l(char *restrict s, size_t maxsize,
locale_t locale, const char *restrict format,
...);
DESCRIPTION
The strfmon() function shall place characters into the array pointed to by s as controlled by the string pointed
to by format. No more than maxsize bytes are placed into the array.
The format is a character string, beginning and ending in its initial state, if any, that contains two types of objects:
plain characters, which are simply copied to the output stream, and conversion specifications, each of which shall
result in the fetching of zero or more arguments which are converted and formatted. The results are undefined if there are
insufficient arguments for the format. If the format is exhausted while arguments remain, the excess arguments are simply
ignored.
The application shall ensure that a conversion specification consists of the following sequence:
A '%' character
Optional flags
Optional field width
Optional left precision
Optional right precision
A required conversion specifier character that determines the conversion to be performed
The strfmon_l() function shall be equivalent to the strfmon() function, except that the locale data used is from
the locale represented by locale.
Flags
One or more of the following optional flags can be specified to control the conversion:
=f
An '=' followed by a single character f which is used as the numeric fill character. In order to work with
precision or width counts, the fill character shall be a single byte character; if not, the behavior is undefined. The default
numeric fill character is the . This flag does not affect field width filling which always uses the .
This flag is ignored unless a left precision (see below) is specified.
^
Do not format the currency amount with grouping characters. The default is to insert the grouping characters if defined for the
current locale.
+ or (
Specify the style of representing positive and negative currency amounts. Only one of '+' or '(' may be
specified.
If '+' is specified, the locale's positive_sign and negative_sign values shall be used (for example, in
many locales, the empty string if positive and '-' if negative). However, if both values would be returned by localeconv() as empty strings, strfmon() shall fail. The placement of the signs
(if not empty) shall depend on the locale settings:
For the n conversion specifier, the placement specified by the locale's p_sign_posn and n_sign_posn
values shall be used.
For the i conversion specifier, the placement specified by the locale's int_p_sign_posn and
int_n_sign_posn values shall be used.
If a sign's placement cannot be determined from these locale values because a value that needs to be used would be returned by
localeconv() as 0 or {CHAR_MAX}, the sign shall be placed as if the relevant
value was 1.
If '(' is specified, negative amounts shall be enclosed within parentheses and the locale's positive_sign and
negative_sign values shall not be used.
If neither flag is specified, the style used shall depend on the locale settings:
For the n conversion specifier, the style specified by the locale's p_sign_posn and n_sign_posn values
shall be used.
For the i conversion specifier, the style specified by the locale's int_p_sign_posn and int_n_sign_posn
values shall be used.
If the style cannot be determined from these locale values because a value that needs to be used would be returned by localeconv() as {CHAR_MAX}, the style used shall be that specified for the '+'
flag; if this would cause strfmon() to fail because the locale's positive_sign and negative_sign values would
both be returned by localeconv() as empty strings, strfmon() shall behave
as if the negative_sign value was the string "-".
!
Suppress the currency symbol from the output conversion.
-
Specify the alignment. If this flag is present the result of the conversion is left-justified (padded to the right) rather than
right-justified. This flag shall be ignored unless a field width (see below) is specified.
Field Width
w
A decimal digit string w specifying a minimum field width in bytes in which the result of the conversion is
right-justified (or left-justified if the flag '-' is specified). The default is 0.
Left Precision
#n
A '#' followed by a decimal digit string n specifying a maximum number of digits expected to be formatted to
the left of the radix character. This option can be used to keep the formatted output from multiple calls to the strfmon()
function aligned in the same columns. It can also be used to fill unused positions with a special character as in
"$***123.45". This option causes an amount to be formatted as if it has the number of digits specified by n. If
more than n digit positions are required, this conversion specification is ignored. Digit positions in excess of those
actually required are filled with the numeric fill character (see the =f flag above).
If grouping has not been suppressed with the '^' flag, and it is defined for the current locale, grouping separators
are inserted before the fill characters (if any) are added. Grouping separators are not applied to fill characters even if the fill
character is a digit.
To ensure alignment, any characters appearing before or after the number in the formatted output such as currency or sign
symbols are padded as necessary with  characters to make their positive and negative formats an equal length.
Right Precision
.p
A  followed by a decimal digit string p specifying the number of digits after the radix character. If the
value of the right precision p is 0, no radix character appears. If a right precision is not included, a default specified
by the current locale is used. The amount being formatted is rounded to the specified number of digits prior to formatting.
Conversion Specifier Characters
The conversion specifier characters and their meanings are:
i
The double argument is formatted according to the locale's international currency format (for example, in the US: USD
1,234.56). If the argument is ±Inf or NaN, the result of the conversion is unspecified.
n
The double argument is formatted according to the locale's national currency format (for example, in the US: $1,234.56).
If the argument is ±Inf or NaN, the result of the conversion is unspecified.
%
Convert to a '%'; no argument is converted. The entire conversion specification shall be %%.
Locale Information
The LC_MONETARY category of the current locale affects the behavior of this function including the monetary radix
character (which may be different from the numeric radix character affected by the LC_NUMERIC category), the grouping
separator, the currency symbols, and formats. The international currency symbol should be conformant with the ISO 4217:2015
standard.
If the value of maxsize is greater than {SSIZE_MAX}, the result is implementation-defined.
The behavior is undefined if the locale argument to strfmon_l() is the special locale object LC_GLOBAL_LOCALE or
is not a valid locale object handle.
RETURN VALUE
If all conversions are successful and the total number of resulting bytes including the terminating null byte is not more than
maxsize, these functions shall return the number of bytes placed into the array pointed to by s, not including the
terminating NUL character. Otherwise, -1 shall be returned, the contents of the array are unspecified, and errno shall be
set to indicate the error.
ERRORS
These functions shall fail if:
[E2BIG]
Conversion stopped due to lack of space in the buffer.
[EINVAL]
The '+' flag was included in a conversion specification and the locale's positive_sign and negative_sign
values would both be returned by localeconv() as empty strings.
The following sections are informative.
EXAMPLES
Given a locale for the US and the values 123.45, -123.45, and 3456.781, the following output might be produced. Square brackets
("[]") are used in this example to delimit the output.
%n         [$123.45]         Default formatting
[-$123.45]
[$3,456.78]
%11n       [    $123.45]     Right align within an 11-character field
[   -$123.45]
[  $3,456.78]
%#5n       [ $   123.45]     Aligned columns for values up to 99999
[-$   123.45]
[ $ 3,456.78]
%=*#5n     [ $***123.45]     Specify a fill character
[-$***123.45]
[ $*3,456.78]
%=0#5n     [ $000123.45]     Fill characters do not use grouping
[-$000123.45]     even if the fill character is a digit
[ $03,456.78]
%^#5n      [ $  123.45]      Disable the grouping separator
[-$  123.45]
[ $ 3456.78]
%^#5.0n    [ $  123]         Round off to whole units
[-$  123]
[ $ 3457]
%^#5.4n    [ $  123.4500]    Increase the precision
[-$  123.4500]
[ $ 3456.7810]
%(#5n      [ $   123.45 ]    Use an alternative pos/neg style
[($   123.45)]
[ $ 3,456.78 ]
%!(#5n     [    123.45 ]     Disable the currency symbol
[(   123.45)]
[  3,456.78 ]
%-14#5.4n  [ $   123.4500 ]  Left-justify the output
[-$   123.4500 ]
[ $ 3,456.7810 ]
%14#5.4n   [  $   123.4500]  Corresponding right-justified output
[ -$   123.4500]
[  $ 3,456.7810]
See also the EXAMPLES section in fprintf().
APPLICATION USAGE
The '+' flag should be used with care, because if the locale's positive_sign and negative_sign values are
both empty strings, there is no way to distinguish negative from positive values with signs and therefore strfmon() fails.
If the application has a preference for signs but parentheses are acceptable, it should try strfmon() with the '+'
flag first, and if it fails with [EINVAL] then repeat the call without the '+' flag.
RATIONALE
The [EINVAL] error condition applies only when the '+' flag is used because this flag indicates that the application
requires the use of signs, and if there are no signs in the locale data then this requirement cannot be satisfied. When neither
'+' nor '(' is used, the application is requesting whatever formatting is appropriate for the locale, and so
strfmon() has a fallback of using a '-' sign for negative values in cases where the locale data does not indicate
parentheses should be used and has no signs.
FUTURE DIRECTIONS
Lowercase conversion characters are reserved for future standards use and uppercase for implementation-defined use.
SEE ALSO
fprintf(), localeconv()
XBD
CHANGE HISTORY
First released in Issue 4.
Issue 5
Moved from ENHANCED I18N to BASE.
The [ENOSYS] error is removed.
Text is added to the DESCRIPTION warning about values of maxsize that are greater than {SSIZE_MAX}.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
The restrict keyword is added to the strfmon() prototype for alignment with the ISO/IEC 9899:1999
standard.
The EXAMPLES section is reworked, clarifying the output format.
Issue 7
SD5-XSH-ERN-29 is applied, updating the examples for %(#5n and %!(#5n.
SD5-XSH-ERN-233 is applied, changing the definition of the '+' or '(' flags to refer to multiple locales.
The strfmon() function is moved from the XSI option to the Base.
The strfmon_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0602 [302], XSH/TC1-2008/0603 [283], and XSH/TC1-2008/0604 [283] are
applied.
Issue 8
Austin Group Defect 1199 is applied, changing the requirements for the '+' and '(' flags and adding the
[EINVAL] error.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/posix_spawnattr_init.html =====
posix_spawnattr_destroy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
posix_spawnattr_destroy, posix_spawnattr_init — destroy and initialize spawn attributes object (ADVANCED
REALTIME)
SYNOPSIS
[SPN]  #include
int posix_spawnattr_destroy(posix_spawnattr_t *attr);
int posix_spawnattr_init(posix_spawnattr_t *attr);
DESCRIPTION
The posix_spawnattr_destroy() function shall destroy a spawn attributes object. A destroyed attr attributes object
can be reinitialized using posix_spawnattr_init(); the results of otherwise referencing the object after it has been
destroyed are undefined. An implementation may cause posix_spawnattr_destroy() to set the object referenced by attr
to an invalid value.
The posix_spawnattr_init() function shall initialize a spawn attributes object attr with the default value for all
of the individual attributes used by the implementation. Results are undefined if posix_spawnattr_init() is called
specifying an already initialized attr attributes object.
A spawn attributes object is of type posix_spawnattr_t (defined in ) and is used to specify the inheritance of process attributes across a spawn
operation. POSIX.1-2024 does not define comparison or assignment operators for the type posix_spawnattr_t.
Each implementation shall document the individual attributes it uses and their default values unless these values are defined by
POSIX.1-2024. Attributes not defined by POSIX.1-2024, their default values, and the names of the associated functions to get and
set those attribute values are implementation-defined.
The resulting spawn attributes object (possibly modified by setting individual attribute values), is used to modify the behavior
of posix_spawn() or posix_spawnp(). After a spawn attributes object has been used to spawn a process by a
call to a posix_spawn() or posix_spawnp(), any function affecting the attributes object (including destruction)
shall not affect any process that has been spawned in this way.
RETURN VALUE
Upon successful completion, posix_spawnattr_destroy() and posix_spawnattr_init() shall return zero; otherwise, an
error number shall be returned to indicate the error.
ERRORS
The posix_spawnattr_init() function shall fail if:
[ENOMEM]
Insufficient memory exists to initialize the spawn attributes object.
The posix_spawnattr_destroy() function may fail if:
[EINVAL]
The value specified by attr is invalid.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
These functions are part of the Spawn option and need not be provided on all implementations.
RATIONALE
The original spawn interface proposed in POSIX.1-2024 defined the attributes that specify the inheritance of process attributes
across a spawn operation as a structure. In order to be able to separate optional individual attributes under their appropriate
options (that is, the spawn-schedparam and spawn-schedpolicy attributes depending upon the Process Scheduling
option), and also for extensibility and consistency with the newer POSIX interfaces, the attributes interface has been changed to
an opaque data type. This interface now consists of the type posix_spawnattr_t, representing a spawn attributes object,
together with associated functions to initialize or destroy the attributes object, and to set or get each individual attribute.
Although the new object-oriented interface is more verbose than the original structure, it is simple to use, more extensible, and
easy to implement.
FUTURE DIRECTIONS
None.
SEE ALSO
posix_spawn(), posix_spawnattr_getsigdefault(), posix_spawnattr_getflags(), posix_spawnattr_getpgroup(), posix_spawnattr_getschedparam(), posix_spawnattr_getschedpolicy(), posix_spawnattr_getsigmask()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1d-1999.
IEEE PASC Interpretation 1003.1 #106 is applied, noting that the effect of initializing an already initialized spawn attributes
option is undefined.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_barrier_init.html =====
pthread_barrier_destroy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_barrier_destroy, pthread_barrier_init — destroy and initialize a barrier object
SYNOPSIS
#include
int pthread_barrier_destroy(pthread_barrier_t *barrier);
int pthread_barrier_init(pthread_barrier_t *restrict barrier,
const pthread_barrierattr_t *restrict attr, unsigned
count);
DESCRIPTION
The pthread_barrier_destroy() function shall destroy the barrier referenced by barrier and release any resources
used by the barrier. The effect of subsequent use of the barrier is undefined until the barrier is reinitialized by another call to
pthread_barrier_init(). An implementation may use this function to set barrier to an invalid value. The results are
undefined if pthread_barrier_destroy() is called when any thread is blocked on the barrier, or if this function is called
with an uninitialized barrier.
The pthread_barrier_init() function shall allocate any resources required to use the barrier referenced by barrier
and shall initialize the barrier with attributes referenced by attr. If attr is NULL, the default barrier attributes
shall be used; the effect is the same as passing the address of a default barrier attributes object. The results are undefined if
pthread_barrier_init() is called when any thread is blocked on the barrier (that is, has not returned from the pthread_barrier_wait() call). The results are undefined if a barrier is used
without first being initialized. The results are undefined if pthread_barrier_init() is called specifying an already
initialized barrier.
The count argument specifies the number of threads that have to call pthread_barrier_wait() before any of them successfully return from the call.
The value specified by count needs to be greater than zero.
If the pthread_barrier_init() function fails, the barrier shall not be initialized and the contents of barrier are
undefined.
See 2.9.9 Synchronization Object Copies and Alternative Mappings
for further requirements.
RETURN VALUE
Upon successful completion, these functions shall return zero; otherwise, an error number shall be returned to indicate the
error.
ERRORS
The pthread_barrier_init() function shall fail if:
[EAGAIN]
The system lacks the necessary resources to initialize another barrier.
[EINVAL]
The value specified by count is equal to zero.
[ENOMEM]
Insufficient memory exists to initialize the barrier.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
If an implementation detects that the value specified by the barrier argument to pthread_barrier_destroy() does
not refer to an initialized barrier object, it is recommended that the function should fail and report an [EINVAL] error.
If an implementation detects that the value specified by the attr argument to pthread_barrier_init() does not
refer to an initialized barrier attributes object, it is recommended that the function should fail and report an [EINVAL]
error.
If an implementation detects that the value specified by the barrier argument to pthread_barrier_destroy() or
pthread_barrier_init() refers to a barrier that is in use (for example, in a pthread_barrier_wait() call) by another thread, or detects that the value
specified by the barrier argument to pthread_barrier_init() refers to an already initialized barrier object, it is
recommended that the function should fail and report an [EBUSY] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_barrier_wait()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1j-2000.
Issue 7
The pthread_barrier_destroy() and pthread_barrier_init() functions are moved from the Barriers option to the
Base.
The [EINVAL] error for an uninitialized barrier object and an uninitialized barrier attributes object is removed; this condition
results in undefined behavior.
The [EBUSY] error for a barrier that is in use or an already initialized barrier object is removed; this condition results in
undefined behavior.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0266 [972] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/asctime_r.html =====
asctime
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
asctime — convert date and time to a string
SYNOPSIS
[OB]  #include
char *asctime(const struct tm *timeptr);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The asctime() function shall convert the broken-down time in the structure pointed to by timeptr into a string in
the form:
Sun Sep 16 01:03:52 1973\n\0
using the equivalent of the following algorithm:
char *asctime(const struct tm *timeptr)
{
static char wday_name[7][3] = {
"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
};
static char mon_name[12][3] = {
"Jan", "Feb", "Mar", "Apr", "May", "Jun",
"Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
};
static char result[26];
sprintf(result, "%.3s %.3s%3d %.2d:%.2d:%.2d %d\n",
wday_name[timeptr->tm_wday],
mon_name[timeptr->tm_mon],
timeptr->tm_mday, timeptr->tm_hour,
timeptr->tm_min, timeptr->tm_sec,
1900 + timeptr->tm_year);
return result;
}
If any of the members of the broken-down time contain values that are outside their normal ranges (see XBD ), the behavior of the asctime() function is undefined. Likewise, if the
calculated year exceeds four digits or is less than the year 1000, the behavior is undefined.
The tm structure is defined in the  header.
The asctime(), ctime(), gmtime(), and localtime() functions shall
return values in one of two static objects: a broken-down time structure and an array of type char. Execution of any of the
functions that return a pointer to one of these object types may overwrite the information in any object of the same type pointed
to by the value returned from any previous call to any of them.
The asctime() function need not be thread-safe; however, asctime() shall avoid data races with all functions other
than itself, ctime(), gmtime(), and
localtime().
RETURN VALUE
Upon successful completion, asctime() shall return a pointer to the string. [CX]   If the
function is unsuccessful, it shall return NULL.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
This function is included only for compatibility with older implementations. It has undefined behavior if the resulting string
would be too long, so the use of this function should be discouraged. On implementations that do not detect output string length
overflow, it is possible to overflow the output buffer in such a way as to cause applications to fail, or possible system security
violations. Also, this function does not support localized date and time formats. To avoid these problems, applications should use
strftime() to generate strings from broken-down times.
Values for the broken-down time structure can be obtained by calling gmtime() or
localtime().
RATIONALE
The standard developers decided to mark the asctime() function obsolescent even though it is in the ISO C standard
due to the possibility of buffer overflow. The ISO C standard also provides the strftime() function which can be used to avoid these problems.
FUTURE DIRECTIONS
This function may be removed in a future version, but not until after it has been removed from the ISO C standard.
SEE ALSO
clock(), ctime(), difftime(), futimens(), gmtime(), localtime(), mktime(), strftime(), strptime(), time()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
Normative text previously in the APPLICATION USAGE section is moved to the DESCRIPTION.
The asctime_r() function is included for alignment with the POSIX Threads Extension.
A note indicating that the asctime() function need not be reentrant is added to the DESCRIPTION.
Issue 6
The asctime_r() function is marked as part of the Thread-Safe Functions option.
Extensions beyond the ISO C standard are marked.
The APPLICATION USAGE section is updated to include a note on the thread-safe function and its avoidance of possibly using a
static data area.
The DESCRIPTION of asctime_r() is updated to describe the format of the string returned.
The restrict keyword is added to the asctime_r() prototype for alignment with the ISO/IEC 9899:1999
standard
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/17 is applied, adding the CX extension in the RETURN VALUE
section requiring that if the asctime() function is unsuccessful it returns NULL.
Issue 7
Austin Group Interpretation 1003.1-2001 #053 is applied, marking these functions obsolescent.
Austin Group Interpretation 1003.1-2001 #156 is applied.
The asctime_r() function is moved from the Thread-Safe Functions option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0033 [86,429] is applied.
Issue 8
Austin Group Defect 469 is applied, clarifying the conditions under which the behavior of asctime() is undefined.
Austin Group Defect 1302 is applied, aligning this function with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1330 is applied, changing the FUTURE DIRECTIONS section.
Austin Group Defect 1376 is applied, removing CX shading from some text derived from the ISO C standard and updating it to
match the ISO C standard.
Austin Group Defect 1410 is applied, removing the asctime_r() function.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/asinh.html =====
asinh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
asinh, asinhf, asinhl — inverse hyperbolic sine functions
SYNOPSIS
#include
double asinh(double x);
float asinhf(float x);
long double asinhl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the inverse hyperbolic sine of their argument x.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the inverse hyperbolic sine of their argument.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, or ±Inf, x shall be returned.
[MXX]
If x is subnormal, x should be returned.
[MX]  If x is subnormal, a range error may occur and, if x is
not returned, asinh(), asinhf(), and asinhl() shall return an implementation-defined value no greater in
magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
ERRORS
These functions may fail if:
Range Error
[MX]
The value of x is subnormal.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), sinh()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The asinh() function is no longer marked as an extension.
The asinhf() and asinhl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0036 [68] is applied.
Issue 8
Austin Group Defect 1382 is applied, rearranging the text describing the behavior when x is subnormal to avoid the need
for two shading changes.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/gethostent.html =====
endhostent
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
endhostent, gethostent, sethostent — network host database functions
SYNOPSIS
#include
void endhostent(void);
struct hostent *gethostent(void);
void sethostent(int stayopen);
DESCRIPTION
These functions shall retrieve information about hosts. This information is considered to be stored in a database that can be
accessed sequentially or randomly. The implementation of this database is unspecified.
Note:
In many cases this database is implemented by the Domain Name System, as documented in RFC 1034, RFC 1035, and
RFC 3596.
The sethostent() function shall open a connection to the database and set the next entry for retrieval to the first entry
in the database. If the stayopen argument is non-zero, the connection shall not be closed by a call to gethostent(),
and the implementation may maintain an open file descriptor. If a file descriptor is opened, the FD_CLOEXEC flag shall be set; see
.
The gethostent() function shall read the next entry in the database, opening and closing a connection to the database as
necessary.
Entries shall be returned in hostent structures.
The endhostent() function shall close the connection to the database, releasing any open file descriptor.
These functions need not be thread-safe.
RETURN VALUE
Upon successful completion, the gethostent() function shall return a pointer to a hostent structure if the
requested entry was found, and a null pointer if the end of the database was reached or the requested entry was not found.
The application shall not modify the structure to which the return value points, nor any storage areas pointed to by pointers
within the structure. The returned pointer, and pointers within the structure, might be invalidated or the structure or the storage
areas might be overwritten by a subsequent call to gethostent(). The returned pointer, and pointers within the structure,
might also be invalidated if the calling thread is terminated.
ERRORS
The gethostent() and sethostent() functions may fail if:
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum allowable number of files is currently open in the system.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
endservent()
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0081 [75,428] and XSH/TC1-2008/0082 [75] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0089 [656] is applied.
Issue 8
Austin Group Defect 368 is applied, adding a requirement for FD_CLOEXEC to be set if a file descriptor is opened, and adding the
[EMFILE] and [ENFILE] errors.
Austin Group Defect 1685 is applied, updating RFC references.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/towupper.html =====
towupper
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
towupper, towupper_l — transliterate lowercase wide-character code to uppercase
SYNOPSIS
#include
wint_t towupper(wint_t wc);
[CX]  wint_t towupper_l(wint_t wc, locale_t locale);
DESCRIPTION
For towupper(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The towupper() [CX]   and towupper_l()
functions have as a domain a type wint_t, the value of which the application shall ensure is a character representable
as a wchar_t, and a wide-character code corresponding to a valid character in the locale used by the function or the value
of WEOF. If the argument has any other value, the behavior is undefined. If the argument of towupper() [CX]   or
towupper_l()  represents a lowercase wide-character code, and
there exists a corresponding uppercase wide-character code as defined by character type information in the current locale
[CX]
or in the locale represented by locale,
respectively (category LC_CTYPE ), the result shall be the corresponding uppercase wide-character code. All other
arguments in the domain are returned unchanged.
[CX]  The
behavior is undefined if the locale argument to towupper_l() is the special locale object LC_GLOBAL_LOCALE or is not
a valid locale object handle.
RETURN VALUE
Upon successful completion, the towupper() [CX]   and towupper_l()   functions shall return the uppercase letter corresponding to the argument passed. Otherwise, they
shall return the argument unchanged.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
setlocale(), uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 4.
Issue 5
The following change has been made in this version for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E):
The SYNOPSIS has been changed to indicate that this function and associated data types are now made visible by inclusion of the
header rather than .
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The towupper_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0681 [302], XSH/TC1-2008/0682 [283], and XSH/TC1-2008/0683 [283] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0374 [685] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/clock_nanosleep.html =====
clock_nanosleep
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
clock_nanosleep — high resolution sleep with specifiable clock
SYNOPSIS
[CX]  #include
int clock_nanosleep(clockid_t clock_id, int flags,
const struct timespec *rqtp, struct timespec *rmtp);
DESCRIPTION
If the flag TIMER_ABSTIME is not set in the flags argument, the clock_nanosleep() function shall cause the current
thread to be suspended from execution until either the time interval specified by the rqtp argument has elapsed, or a signal
is delivered to the calling thread and its action is to invoke a signal-catching function, or the process is terminated. The clock
used to measure the time shall be the clock specified by clock_id.
If the flag TIMER_ABSTIME is set in the flags argument, the clock_nanosleep() function shall cause the current
thread to be suspended from execution until either the time value of the clock specified by clock_id reaches the absolute
time specified by the rqtp argument, or a signal is delivered to the calling thread and its action is to invoke a
signal-catching function, or the process is terminated. If, at the time of the call, the time value specified by rqtp is
less than or equal to the time value of the specified clock, then clock_nanosleep() shall return immediately and the calling
process shall not be suspended.
The suspension time caused by this function may be longer than requested because the argument value is rounded up to an integer
multiple of the sleep resolution, or because of the scheduling of other activity by the system. But, except for the case of being
interrupted by a signal, the suspension time for the relative clock_nanosleep() function (that is, with the TIMER_ABSTIME
flag not set) shall not be less than the time interval specified by rqtp, as measured by the corresponding clock. The
suspension for the absolute clock_nanosleep() function (that is, with the TIMER_ABSTIME flag set) shall be in effect at
least until the value of the corresponding clock reaches the absolute time specified by rqtp, except for the case of being
interrupted by a signal.
The use of the clock_nanosleep() function shall have no effect on the action or blockage of any signal.
The clock_nanosleep() function shall fail if the clock_id argument refers to the CPU-time clock of the calling
thread. It is unspecified whether clock_id values of other CPU-time clocks are allowed.
RETURN VALUE
If the clock_nanosleep() function returns because the requested time has elapsed, its return value shall be zero.
If the clock_nanosleep() function returns because it has been interrupted by a signal, it shall return the corresponding
error value. For the relative clock_nanosleep() function, if the rmtp argument is non-NULL, the timespec
structure referenced by it shall be updated to contain the amount of time remaining in the interval (the requested time minus the
time actually slept). The rqtp and rmtp arguments can point to the same object. If the rmtp argument is NULL,
the remaining time is not returned. The absolute clock_nanosleep() function has no effect on the structure referenced by
rmtp.
If clock_nanosleep() fails, it shall return the corresponding error value.
ERRORS
The clock_nanosleep() function shall fail if:
[EINTR]
The clock_nanosleep() function was interrupted by a signal.
[EINVAL]
The rqtp argument specified a nanosecond value less than zero or greater than or equal to 1000 million; or the
TIMER_ABSTIME flag was specified in flags and the rqtp argument is outside the range for the clock specified by
clock_id; or the clock_id argument does not specify a known clock, or specifies the CPU-time clock of the calling
thread.
[ENOTSUP]
The clock_id argument specifies a clock for which clock_nanosleep() is not supported, such as a CPU-time
clock.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Calling clock_nanosleep() with the value TIMER_ABSTIME not set in the flags argument and with a clock_id of
CLOCK_REALTIME is equivalent to calling nanosleep() with the same rqtp and
rmtp arguments.
RATIONALE
The nanosleep() function specifies that the system-wide clock CLOCK_REALTIME is
used to measure the elapsed time for this time service. However, with the introduction of the monotonic clock CLOCK_MONOTONIC a new
relative sleep function is needed to allow an application to take advantage of the special characteristics of this clock.
There are many applications in which a process needs to be suspended and then activated multiple times in a periodic way; for
example, to poll the status of a non-interrupting device or to refresh a display device. For these cases, it is known that precise
periodic activation cannot be achieved with a relative sleep() or nanosleep() function call. Suppose, for example, a periodic process that is activated at
time T0, executes for a while, and then wants to suspend itself until time T0+T, the period being T. If
this process wants to use the nanosleep() function, it must first call clock_gettime() to get the current time, then calculate the difference between the
current time and T0+T and, finally, call nanosleep() using the
computed interval. However, the process could be preempted by a different process between the two function calls, and in this case
the interval computed would be wrong; the process would wake up later than desired. This problem would not occur with the absolute
clock_nanosleep() function, since only one function call would be necessary to suspend the process until the desired time.
In other cases, however, a relative sleep is needed, and that is why both functionalities are required.
Although it is possible to implement periodic processes using the timers interface, this implementation would require the use of
signals, and the reservation of some signal numbers. In this regard, the reasons for including an absolute version of the
clock_nanosleep() function in POSIX.1-2024 are the same as for the inclusion of the relative nanosleep().
It is also possible to implement precise periodic processes using pthread_cond_timedwait(), in which an absolute timeout is specified that
takes effect if the condition variable involved is never signaled. However, the use of this interface is unnatural, and involves
performing other operations on mutexes and condition variables that imply an unnecessary overhead. Furthermore, pthread_cond_timedwait() is not available in implementations that do not
support threads.
Although the interface of the relative and absolute versions of the new high resolution sleep service is the same
clock_nanosleep() function, the rmtp argument is only used in the relative sleep. This argument is needed in the
relative clock_nanosleep() function to reissue the function call if it is interrupted by a signal, but it is not needed in
the absolute clock_nanosleep() function call; if the call is interrupted by a signal, the absolute clock_nanosleep()
function can be invoked again with the same rqtp argument used in the interrupted call.
FUTURE DIRECTIONS
None.
SEE ALSO
clock_getres(), nanosleep(), pthread_cond_clockwait(), sleep()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1j-2000.
Issue 7
The clock_nanosleep() function is moved from the Clock Selection option to the Base.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0068 [909] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/uname.html =====
uname
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
uname — get the name of the current system
SYNOPSIS
#include
int uname(struct utsname *name);
DESCRIPTION
The uname() function shall store information identifying the current system in the structure pointed to by
name.
The uname() function uses the utsname structure defined in .
The uname() function shall return a string naming the current system in the character array sysname. Similarly,
nodename shall contain the name of this node within an implementation-defined communications network. The arrays
release and version shall further identify the operating system. The array machine shall contain a name that
identifies the hardware that the system is running on.
The format of each member is implementation-defined.
RETURN VALUE
Upon successful completion, a non-negative value shall be returned. Otherwise, -1 shall be returned and errno set to
indicate the error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The inclusion of the nodename member in this structure does not imply that it is sufficient information for interfacing
to communications networks.
RATIONALE
The values of the structure members are not constrained to have any relation to the version of this volume of POSIX.1-2024
implemented in the operating system. An application should instead depend on _POSIX_VERSION and related constants defined in
.
This volume of POSIX.1-2024 does not define the sizes of the members of the structure and permits them to be of different sizes,
although most implementations define them all to be the same size: eight bytes plus one byte for the string terminator. That size
for nodename is not enough for use with many networks.
The uname() function originated in System III, System V, and related implementations, and it does not exist in Version 7
or 4.3 BSD. The values it returns are set at system compile time in those historical implementations.
4.3 BSD has gethostname() and gethostid(), which return a symbolic name and a numeric value, respectively. There are
related sethostname() and sethostid() functions that are used to set the values the other two functions return. The
former functions are included in this specification, the latter are not.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/cprojf.html =====
cproj
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cproj, cprojf, cprojl — complex projection functions
SYNOPSIS
#include
double complex cproj(double complex z);
float complex cprojf(float complex z);
long double complex cprojl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute a projection of z onto the Riemann sphere: z projects to z, except that all
complex infinities (even those with one infinite part and one NaN part) project to positive infinity on the real axis. If z
has an infinite part, then cproj(z) shall be equivalent to:
INFINITY + I * copysign(0.0, cimag(z))
RETURN VALUE
These functions shall return the value of the projection onto the Riemann sphere.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
Two topologies are commonly used in complex mathematics: the complex plane with its continuum of infinities, and the Riemann
sphere with its single infinity. The complex plane is better suited for transcendental functions, the Riemann sphere for algebraic
functions. The complex types with their multiplicity of infinities provide a useful (though imperfect) model for the complex plane.
The cproj() function helps model the Riemann sphere by mapping all infinities to one, and should be used just before any
operation, especially comparisons, that might give spurious results for any of the other infinities. Note that a complex value with
one infinite part and one NaN part is regarded as an infinity, not a NaN, because if one part is infinite, the complex value is
infinite independent of the value of the other part. For the same reason, cabs()
returns an infinity if its argument has an infinite part and a NaN part.
FUTURE DIRECTIONS
None.
SEE ALSO
carg(), cimag(), conj(), creal()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sqrtf.html =====
sqrt
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sqrt, sqrtf, sqrtl — square root function
SYNOPSIS
#include
double sqrt(double x);
float sqrtf(float x);
long double sqrtl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the square root of their argument \(x\),
\(\sqrt{x}\).
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the square root of \(x\).
[MX]  The
returned value shall be dependent on the current rounding direction mode.
For finite values of \(x\)
...
double x = 9.0;
double result;
...
result = sqrt(x);
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are
independent of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept, fetestexcept, isnan
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The sqrtf() and sqrtl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0588 [320] is applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mbrtowc.html =====
mbrtowc
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mbrtowc — convert a character to a wide-character code (restartable)
SYNOPSIS
#include
size_t mbrtowc(wchar_t *restrict pwc, const char *restrict s,
size_t n, mbstate_t *restrict ps);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
If s is a null pointer, the mbrtowc() function shall be equivalent to the call:
mbrtowc(NULL, "", 1, ps)
In this case, the values of the arguments pwc and n are ignored.
If s is not a null pointer, the mbrtowc() function shall inspect at most n bytes beginning at the byte
pointed to by s to determine the number of bytes needed to complete the next character (including any shift sequences). If
the function determines that the next character is completed, it shall determine the value of the corresponding wide character and
then, if pwc is not a null pointer, shall store that value in the object pointed to by pwc. If the corresponding wide
character is the null wide character, the resulting state described shall be the initial conversion state.
If ps is a null pointer, the mbrtowc() function shall use its own internal mbstate_t object, which shall be
initialized at program start-up to the initial conversion state. Otherwise, the mbstate_t object pointed to by ps
shall be used to completely describe the current conversion state of the associated character sequence. The implementation shall
behave as if no function defined in this volume of POSIX.1-2024 calls mbrtowc().
The behavior of this function is affected by the LC_CTYPE category of the current locale.
If called with a null ps argument, the mbrtowc() function need not be thread-safe; however, such calls shall avoid
data races with calls to mbrtowc() with a non-null argument and with calls to all other functions.
The mbrtowc() function shall not change the setting of errno if successful.
RETURN VALUE
The mbrtowc() function shall return the first of the following that applies:
0
If the next n or fewer bytes complete the character that corresponds to the null wide character (which is the value
stored).
between 1 and n inclusive
If the next n or fewer bytes complete a valid character (which is the value stored); the value returned shall be the number
of bytes that complete the character.
(size_t)-2
If the next n bytes contribute to an incomplete but potentially valid character, and all n bytes have been
processed (no value is stored). When n has at least the value of the {MB_CUR_MAX} macro, this case can only occur if
s points at a sequence of redundant shift sequences (for implementations with state-dependent encodings).
(size_t)-1
If an encoding error occurs, in which case the next n or fewer bytes do not contribute to a complete and valid character
(no value is stored). In this case, [EILSEQ] shall be stored in errno and the conversion state is undefined.
ERRORS
The mbrtowc() function shall fail if:
[EILSEQ]
An invalid character sequence is detected. [CX]   In the POSIX locale an [EILSEQ] error cannot occur since all byte
values are valid characters.
The mbrtowc() function may fail if:
[EINVAL]
[CX]
ps points to an object that contains an invalid conversion state.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
mbsinit(), mbsrtowcs()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E).
Issue 6
The mbrtowc() prototype is updated for alignment with the ISO/IEC 9899:1999 standard.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The [EINVAL] error condition is added.
ISO/IEC 9899:1999 standard, Technical Corrigendum 1 is incorporated.
Issue 7
Austin Group Interpretation 1003.1-2001 #170 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0369 [109,105] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0204 [663,674] is applied.
Issue 8
Austin Group Defect 1302 is applied, aligning this function with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strxfrm_l.html =====
strxfrm
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strxfrm, strxfrm_l — string transformation
SYNOPSIS
#include
size_t strxfrm(char *restrict s1, const char *restrict s2, size_t n);
[CX]  size_t strxfrm_l(char *restrict s1, const char *restrict s2,
size_t n, locale_t locale);
DESCRIPTION
For strxfrm(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The strxfrm() [CX]   and strxfrm_l()
functions shall transform the string pointed to by s2 and place the resulting string into the array pointed to by
s1. The transformation is such that if strcmp() is applied to two transformed
strings, it shall return a value greater than, equal to, or less than 0, corresponding to the result of strcoll() [CX]   or strcoll_l(),
respectively, applied to the same two original strings
[CX]
with the same locale.   No more than n bytes are
placed into the resulting array pointed to by s1, including the terminating NUL character. If n is 0, s1 is
permitted to be a null pointer. If copying takes place between objects that overlap, the behavior is undefined.
[CX]  The
strxfrm() and strxfrm_l() functions shall not change the setting of errno if successful.
Since no return value is reserved to indicate an error, an application wishing to check for error situations should set
errno to 0, then call strxfrm() [CX]   or strxfrm_l(),   then check errno.
[CX]  The
behavior is undefined if the locale argument to strxfrm_l() is the special locale object LC_GLOBAL_LOCALE or is not a
valid locale object handle.
RETURN VALUE
Upon successful completion, strxfrm() [CX]   and strxfrm_l()   shall return the length of the transformed string (not including the terminating NUL character).
If the value returned is n or more, the contents of the array pointed to by s1 are unspecified.
On error, strxfrm() [CX]   and strxfrm_l()   may
set errno but no return value is reserved to indicate an error.
ERRORS
These functions may fail if:
[EINVAL]
[CX]
The string pointed to by the s2 argument contains characters outside the domain of the collating sequence.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The transformation function is such that two transformed strings can be ordered by strcmp() as appropriate to collating sequence information in the current locale (category
LC_COLLATE ).
The fact that when n is 0 s1 is permitted to be a null pointer is useful to determine the size of the s1
array prior to making the transformation.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
strcmp(), strcoll()
XBD
CHANGE HISTORY
First released in Issue 3. Included for alignment with the ISO C standard.
Issue 5
The DESCRIPTION is updated to indicate that errno does not change if the function is successful.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the RETURN VALUE and ERRORS sections, the [EINVAL] optional error condition is added if no conversion could be performed.
The strxfrm() prototype is updated for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
The strxfrm_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0624 [283], XSH/TC1-2008/0625 [283], and XSH/TC1-2008/0626 [302] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/memset.html =====
memset
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
memset — set bytes in memory
SYNOPSIS
#include
void *memset(void *s, int c, size_t n);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The memset() function shall copy c (converted to an unsigned char) into each of the first n bytes of
the object pointed to by s.
[CX]  The
memset() function shall not change the setting of errno on valid input.
RETURN VALUE
The memset() function shall return s; no return value is reserved to indicate an error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that memset() does not change the setting of errno on
valid input.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/trunc.html =====
trunc
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
trunc, truncf, truncl — round to truncated integer value
SYNOPSIS
#include
double trunc(double x);
float truncf(float x);
long double truncl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall round their argument to the integer value, in floating format, nearest to but no larger in magnitude than
the argument.
[MX]
These functions may raise the inexact floating-point exception for finite non-integer arguments.
RETURN VALUE
Upon successful completion, these functions shall return the truncated integer value.
[MX]  The
returned value shall be exact, shall be independent of the current rounding direction mode, and shall have the same sign as
x.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0 or ±Inf, x shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The integral value returned by these functions need not be expressible as an intmax_t. The return value should be tested
before assigning it to an integer type to avoid the undefined results of an integer overflow.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0684 [346] is applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/dbm_store.html =====
dbm_clearerr
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
dbm_clearerr, dbm_close, dbm_delete, dbm_error, dbm_fetch, dbm_firstkey, dbm_nextkey, dbm_open, dbm_store — database
functions
SYNOPSIS
[XSI]  #include
int dbm_clearerr(DBM *db);
void dbm_close(DBM *db);
int dbm_delete(DBM *db, datum key);
int dbm_error(DBM *db);
datum dbm_fetch(DBM *db, datum key);
datum dbm_firstkey(DBM *db);
datum dbm_nextkey(DBM *db);
DBM *dbm_open(const char *file, int open_flags, mode_t file_mode);
int dbm_store(DBM *db, datum key, datum content, int
store_mode);
DESCRIPTION
These functions create, access, and modify a database.
A datum consists of at least two members, dptr and dsize. The dptr member points to an object that
is dsize bytes in length. Arbitrary binary data, as well as character strings, may be stored in the object pointed to by
dptr.
A database shall be stored in one or two files. When one file is used, the name of the database file shall be formed by
appending the suffix .db to the file argument given to dbm_open(). When two files are used, the names of the
database files shall be formed by appending the suffixes .dir and .pag respectively to the file argument.
The dbm_open() function shall open a database. The file argument to the function is the pathname of the database.
Values for the open_flags argument are constructed by a bitwise-inclusive OR of flags from the following list, defined in
. Applications shall specify exactly one of the first three values
(file access modes) below in the value of open_flags:
O_RDONLY
Open the database, and the underlying file(s) used to store the database, for reading only.
O_RDWR
Open the database, and the underlying file(s) used to store the database, for reading and writing.
O_WRONLY
Open the database for writing only. The underlying file(s) used to store the database shall be opened for reading and
writing.
Any combination of the following can be used:
O_CLOEXEC
If set, the FD_CLOEXEC flag for the new file descriptor(s) used to open the underlying file(s) shall be set.
O_CREAT
If the database exists, this flag has no effect except as noted under O_EXCL below. Otherwise, the database shall be created;
the user ID of the underlying file(s) shall be set to the effective user ID of the process; the group ID of the underlying file(s)
shall be set to the group ID of the file's parent directory or to the effective group ID of the process. Implementations shall
provide a way to initialize the group ID to the group ID of the parent directory. Implementations may, but need not, provide an
implementation-defined way to initialize the group ID to the effective group ID of the calling process.
O_DSYNC
[SIO]
Write I/O operations on the file(s) used to store the database shall complete as defined by synchronized I/O data integrity
completion.
O_EXCL
If O_CREAT and O_EXCL are set, dbm_open() shall fail if the database exists according to the following criteria. If the
database is stored in a file with a .db suffix, a check for the existence of the file and the creation of the file if it
does not exist shall be performed as a single atomic operation. If the database is stored in files with .pag and .dir
suffixes, this atomic existence check and creation operation shall be performed for each file, but it is unspecified which file is
first. If the first file is successfully created and the second file is found to exist, the first file should be removed before
dbm_open() returns.
If O_EXCL is set and O_CREAT is not set, the result is undefined.
O_RSYNC
[SIO]
Read I/O operations on the file(s) used to store the database shall complete at the same level of integrity as specified by the
O_DSYNC and O_SYNC flags. If both O_DSYNC and O_RSYNC are set in oflag, all I/O operations on the file(s) shall complete as defined
by synchronized I/O data integrity completion. If both O_SYNC and O_RSYNC are set in flags, all I/O operations on the file(s) shall
complete as defined by synchronized I/O file integrity completion.
O_SYNC
Write I/O operations on the file(s) used to store the database shall complete as defined by synchronized I/O file integrity
completion.
O_TRUNC
If the database exists and is successfully opened O_RDWR or O_WRONLY, it shall be emptied, and the mode and owner of the
underlying file(s) shall be unchanged. The result of using O_TRUNC without either O_RDWR or O_WRONLY is undefined.
The behaviour of other flags described for the flags argument of open() is
unspecified.
The file_mode argument has the same meaning as the third argument of open()
and shall apply to the underlying file(s) used to store the database.
The dbm_open() function need not accept pathnames longer than {PATH_MAX}-4 bytes (including the terminating null), or
pathnames with a last component longer than {NAME_MAX}-4 bytes (excluding the terminating null).
The dbm_close() function shall close a database. The application shall ensure that argument db is a pointer to a
dbm structure that has been returned from a call to dbm_open().
These database functions shall support an internal block size large enough to support key/content pairs of at least 1023
bytes.
The dbm_fetch() function shall read a record from a database. The argument db is a pointer to a database structure
that has been returned from a call to dbm_open(). The argument key is a datum that has been initialized by the
application to the value of the key that matches the key of the record the program is fetching.
The dbm_store() function shall write a record to a database. The argument db is a pointer to a database structure
that has been returned from a call to dbm_open(). The argument key is a datum that has been initialized by the
application to the value of the key that identifies (for subsequent reading, writing, or deleting) the record the application is
writing. The argument content is a datum that has been initialized by the application to the value of the record the
program is writing. The argument store_mode controls whether dbm_store() replaces any pre-existing record that has
the same key that is specified by the key argument. The application shall set store_mode to either DBM_INSERT or
DBM_REPLACE. If the database contains a record that matches the key argument and store_mode is DBM_REPLACE, the
existing record shall be replaced with the new record. If the database contains a record that matches the key argument and
store_mode is DBM_INSERT, the existing record shall be left unchanged and the new record ignored. If the database does not
contain a record that matches the key argument and store_mode is either DBM_INSERT or DBM_REPLACE, the new record
shall be inserted in the database.
If the sum of a key/content pair exceeds the internal block size, the result is unspecified. Moreover, the application shall
ensure that all key/content pairs that hash together fit on a single block. The dbm_store() function shall return an error
in the event that a disk block fills with inseparable data.
The dbm_delete() function shall delete a record and its key from the database. The argument db is a pointer to a
database structure that has been returned from a call to dbm_open(). The argument key is a datum that has been
initialized by the application to the value of the key that identifies the record the program is deleting.
The dbm_firstkey() function shall return the first key in the database. The argument db is a pointer to a database
structure that has been returned from a call to dbm_open().
The dbm_nextkey() function shall return the next key in the database. The argument db is a pointer to a database
structure that has been returned from a call to dbm_open(). The application shall ensure that the dbm_firstkey()
function is called before calling dbm_nextkey(). Subsequent calls to dbm_nextkey() return the next key until all of
the keys in the database have been returned.
The dbm_error() function shall return the error condition of the database. The argument db is a pointer to a
database structure that has been returned from a call to dbm_open().
The dbm_clearerr() function shall clear the error condition of the database. The argument db is a pointer to a
database structure that has been returned from a call to dbm_open().
The dptr pointers returned by these functions may point into static storage that may be changed by subsequent calls.
These functions need not be thread-safe.
RETURN VALUE
The dbm_store() and dbm_delete() functions shall return 0 when they succeed and a negative value when they
fail.
The dbm_store() function shall return 1 if it is called with a flags value of DBM_INSERT and the function finds an
existing record with the same key.
The dbm_error() function shall return 0 if the error condition is not set and return a non-zero value if the error
condition is set.
The return value of dbm_clearerr() is unspecified.
The dbm_firstkey() and dbm_nextkey() functions shall return a key datum. When the end of the database is
reached, the dptr member of the key is a null pointer. If an error is detected, the dptr member of the key shall be a
null pointer and the error condition of the database shall be set.
The dbm_fetch() function shall return a content datum. If no record in the database matches the key or if an error
condition has been detected in the database, the dptr member of the content shall be a null pointer.
The dbm_open() function shall return a pointer to a database structure. If an error is detected during the operation,
dbm_open() shall return a (DBM *)0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The following code can be used to traverse the database:
for(key = dbm_firstkey(db); key.dptr != NULL; key = dbm_nextkey(db))
The dbm_* functions provided in this library should not be confused in any way with those of a general-purpose database
management system. These functions do not provide for multiple search keys per entry, they do not protect against multi-user access
(in other words they do not lock records or files), and they do not provide the many other useful database functions that are found
in more robust database management systems. Creating and updating databases by use of these functions is relatively slow because of
data copies that occur upon hash collisions. These functions are useful for applications requiring fast lookup of relatively static
information that is to be indexed by a single key.
Note that a strictly conforming application is extremely limited by these functions: since there is no way to determine that the
keys in use do not all hash to the same value (although that would be rare), a strictly conforming application cannot be guaranteed
that it can store more than one block's worth of data in the database. As long as a key collision does not occur, additional data
may be stored, but because there is no way to determine whether an error is due to a key collision or some other error condition
(dbm_error() being effectively a Boolean), once an error is detected, the
application is effectively limited to guessing what the error might be if it wishes to continue using these functions.
The dbm_delete() function need not physically reclaim file space, although it does make it available for reuse by the
database.
After calling dbm_store() or dbm_delete() during a pass through the keys by dbm_firstkey() and
dbm_nextkey(), the application should reset the database by calling dbm_firstkey() before again calling
dbm_nextkey(). The contents of these files are unspecified and may not be portable.
Applications should take care that database pathname arguments specified to dbm_open() are not prefixes of unrelated
files. This might be done, for example, by placing databases in a separate directory.
Since some implementations use three characters for a suffix and others use four characters for a suffix, applications should
ensure that the maximum portable pathname length passed to dbm_open() is no greater than {PATH_MAX}-4 bytes, with the last
component of the pathname no greater than {NAME_MAX}-4 bytes.
RATIONALE
and having .dir as its suffix. The second file containing all data and having .pag as its suffix. This has been
changed not to specify the use of the files and to allow newer implementations of the Berkeley DB interface using a single file
that have evolved while remaining compatible with the application programming interface. The standard developers considered
removing the specific suffixes altogether but decided to retain them so as not to pollute the application file name space more than
necessary and to allow for portable backups of the database.
FUTURE DIRECTIONS
A future revision of this standard may mandate the file removal that is currently recommended (by the use of "should") in the
description of O_EXCL.
SEE ALSO
open()
XBD ,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Normative text previously in the APPLICATION USAGE section is moved to the DESCRIPTION.
A note indicating that these functions need not be reentrant is added to the DESCRIPTION.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
Austin Group Interpretation 1003.1-2001 #042 is applied so that the DESCRIPTION permits newer implementations of the Berkeley DB
interface.
Austin Group Interpretation 1003.1-2001 #156 is applied.
Issue 8
Austin Group Defect 1057 is applied, clarifying how the O_ flags defined for use with open() apply to dbm_open().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/link.html =====
link
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
link, linkat — hard link one file to another file
SYNOPSIS
#include
int link(const char *path1, const char *path2);
[OH] #include
int linkat(int fd1, const char *path1, int fd2,
const char *path2, int flag);
DESCRIPTION
The link() function shall create a new hard link (directory entry) for the existing file, path1.
The path1 argument points to a pathname naming an existing file. The path2 argument points to a pathname naming
the new directory entry to be created. The link() function shall atomically create a new hard link for the existing file and
the link count of the file shall be incremented by one.
If path1 names a directory, link() shall fail unless the process has appropriate privileges and the implementation
supports using link() on directories.
If path1 names a symbolic link, it is implementation-defined whether link() follows the symbolic link, or creates
a new hard link to the symbolic link itself.
Upon successful completion, link() shall mark for update the last file status change timestamp of the file. Also, the
last data modification and last file status change timestamps of the directory that contains the new entry shall be marked for
update.
If link() fails, no link shall be created and the link count of the file shall remain unchanged.
The implementation may require that the calling process has permission to access the existing file.
The linkat() function shall be equivalent to the link() function except that symbolic links shall be handled as
specified by the value of flag (see below) and except in the case where either path1 or path2 or both are
relative paths. In this case a relative path path1 is interpreted relative to the directory associated with the file
descriptor fd1 instead of the current working directory and similarly for path2 and the file descriptor fd2.
If the access mode of the open file description associated with the file descriptor is not O_SEARCH, the function shall check
whether directory searches are permitted using the current permissions of the directory underlying the file descriptor. If the
access mode is O_SEARCH, the function shall not perform the check.
Values for flag are constructed by a bitwise-inclusive OR of flags from the following list, defined in :
AT_SYMLINK_FOLLOW
If path1 names a symbolic link, a new hard link for the target of the symbolic link is created.
If linkat() is passed the special value AT_FDCWD in the fd1 or fd2 parameter, the current working directory
shall be used for the respective path argument. If both fd1 and fd2 have value AT_FDCWD, the behavior shall be
identical to a call to link(), except that symbolic links shall be handled as specified by the value of flag.
If the AT_SYMLINK_FOLLOW flag is clear in the flag argument and the path1 argument names a symbolic link, a new
hard link is created for the symbolic link path1 and not its target.
RETURN VALUE
Upon successful completion, these functions shall return 0. Otherwise, these functions shall return -1 and set errno to
indicate the error.
ERRORS
These functions shall fail if:
[EACCES]
A component of either path prefix denies search permission, or the requested link requires writing in a directory that denies
write permission, or the calling process does not have permission to access the existing file and this is required by the
implementation.
[EEXIST]
The path2 argument resolves to an existing directory entry or refers to a symbolic link.
[EILSEQ]
The last pathname component of path2 is not a portable filename, and cannot be created in the target directory.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path1 or path2 argument.
[EMLINK]
The number of hard links to the file named by path1 would exceed {LINK_MAX}.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of either path prefix does not exist; the file named by path1 does not exist; or path1 or
path2 points to an empty string.
[ENOENT] or [ENOTDIR]
The path1 argument names an existing non-directory file, and the path2 argument contains at least one
non- character and ends with one or more trailing  characters. If path2 without the trailing
characters would name an existing file, an [ENOENT] error shall not occur.
[ENOSPC]
The directory to contain the link cannot be extended.
[ENOTDIR]
A component of either path prefix names an existing file that is neither a directory nor a symbolic link to a directory, or the
path1 argument contains at least one non- character and ends with one or more trailing  characters
and the last pathname component names an existing file that is neither a directory nor a symbolic link to a directory, or the
path1 argument names an existing non-directory file and the path2 argument names a nonexistent file, contains at
least one non- character, and ends with one or more trailing  characters.
[EPERM]
The file named by path1 is a directory and either the calling process does not have appropriate privileges or the
implementation prohibits using link() on directories.
[EROFS]
The requested link requires writing in a directory on a read-only file system.
[EXDEV]
The file named by path1 and the directory in which the directory entry named by path2 is to be created are on
different file systems and the implementation does not support hard links between file systems.
The linkat() function shall fail if:
[EACCES]
The access mode of the open file description associated with fd1 or fd2 is not O_SEARCH and the permissions of
the directory underlying fd1 or fd2, respectively, do not permit directory searches.
[EBADF]
The path1 or path2 argument does not specify an absolute path and the fd1 or fd2 argument,
respectively, is neither AT_FDCWD nor a valid file descriptor open for reading or searching.
[ENOTDIR]
The path1 or path2 argument is not an absolute path and fd1 or fd2, respectively, is a file
descriptor associated with a non-directory file.
These functions may fail if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path1 or path2 argument.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
The linkat() function may fail if:
[EINVAL]
The value of the flag argument is not valid.
The following sections are informative.
EXAMPLES
Creating a Hard Link to a File
The following example shows how to create an additional hard link to a file named /home/cnd/mod1 by creating a new
directory entry named /modules/pass1.
#include
char *path1 = "/home/cnd/mod1";
char *path2 = "/modules/pass1";
int   status;
...
status = link (path1, path2);
Creating a Hard Link to a File Within a Program
In the following program example, the link() function hard links the /etc/passwd file (defined as
PASSWDFILE) to a file named /etc/opasswd (defined as SAVEFILE), which is used to save the current password
file. Then, after removing the current password file (defined as PASSWDFILE), the new password file is saved as the current
password file using the link() function again.
#include
#define LOCKFILE "/etc/ptmp"
#define PASSWDFILE "/etc/passwd"
#define SAVEFILE "/etc/opasswd"
...
/* Save current password file */
link (PASSWDFILE, SAVEFILE);
/* Remove current password file. */
unlink (PASSWDFILE);
/* Save new password file as current password file. */
link (LOCKFILE,PASSWDFILE);
APPLICATION USAGE
Some implementations do allow hard links between file systems.
If path1 refers to a symbolic link, application developers should use linkat() with appropriate flags to select
whether or not the symbolic link should be resolved.
RATIONALE
Creating additional hard links to a directory is restricted to the superuser in most historical implementations because this
capability may produce loops in the file hierarchy or otherwise corrupt the file system. This volume of POSIX.1-2024 continues that
philosophy by prohibiting link() and unlink() from doing this. Other functions
could do it if the implementor designed such an extension.
Some historical implementations allow hard linking of files on different file systems. Wording was added to explicitly allow
this optional behavior.
The exception for cross-file system hard links is intended to apply only to links that are programmatically indistinguishable
from traditional hard links.
The purpose of the linkat() function is to link files in directories other than the current working directory without
exposure to race conditions. Any part of the path of a file could be changed in parallel to a call to link(), resulting in
unspecified behavior. By opening a file descriptor for the directory of both the existing file and the target location and using
the linkat() function it can be guaranteed that the both filenames are in the desired directories.
Earlier versions of this standard specified only the link() function, and required it to behave like linkat() with
the AT_SYMLINK_FOLLOW flag. However, historical practice from SVR4 and Linux kernels had link() behaving like
linkat() with no flags, and many systems that attempted to provide a conforming link() function did so in a way that
was rarely used, and when it was used did not conform to the standard (e.g., by not being atomic, or by dereferencing the symbolic
link incorrectly). Since applications could not rely on link() following symbolic links in practice, the linkat()
function was added taking a flag to specify the desired behavior for the application.
Implementations are encouraged to have link() and linkat() report an [EILSEQ] error if the file named by
path2 did not previously exist, and the last component of that pathname contains any bytes that have the encoded value of a
character.
FUTURE DIRECTIONS
None.
SEE ALSO
rename(), symlink(), unlink()
XBD ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The [ELOOP] mandatory error condition is added.
A second [ENAMETOOLONG] is added as an optional error condition.
The following changes were made to align with the IEEE P1003.1a draft standard:
An explanation is added of the action when path2 refers to a symbolic link.
The [ELOOP] optional error condition is added.
Issue 7
Austin Group Interpretation 1003.1-2001 #143 is applied.
SD5-XSH-ERN-93 is applied, adding RATIONALE.
The linkat() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 2.
Functionality relating to XSI STREAMS is marked obsolescent.
Changes are made related to support for finegrained timestamps.
The [EOPNOTSUPP] error is removed.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0354 [326], XSH/TC1-2008/0355 [461], XSH/TC1-2008/0356 [326],
XSH/TC1-2008/0357 [324], XSH/TC1-2008/0358 [147,429], XSH/TC1-2008/0359 [277], XSH/TC1-2008/0360 [278], and XSH/TC1-2008/0361 [278]
are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0195 [873], XSH/TC2-2008/0196 [591], XSH/TC2-2008/0197 [817],
XSH/TC2-2008/0198 [822], and XSH/TC2-2008/0199 [817] are applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defect 293 is applied, adding the [EILSEQ] error.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
Austin Group Defect 1380 is applied, changing text using the term "link" in line with its updated definition and removing a
paragraph from the RATIONALE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_getspecific.html =====
pthread_getspecific
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_getspecific, pthread_setspecific — thread-specific data management
SYNOPSIS
#include
void *pthread_getspecific(pthread_key_t key);
int pthread_setspecific(pthread_key_t key, const void *value);
DESCRIPTION
The pthread_getspecific() function shall return the value currently bound to the specified key on behalf of the
calling thread.
The pthread_setspecific() function shall associate a thread-specific value with a key obtained via a
previous call to pthread_key_create(). Different threads may bind
different values to the same key. These values are typically pointers to blocks of dynamically allocated memory that have been
reserved for use by the calling thread.
The effect of calling pthread_getspecific() or pthread_setspecific() with a key value not obtained from
pthread_key_create() or after key has been deleted with pthread_key_delete() is undefined.
Both pthread_getspecific() and pthread_setspecific() may be called from a thread-specific data destructor
function. A call to pthread_getspecific() for the thread-specific data key being destroyed shall return the value NULL,
unless the value is changed (after the destructor starts) by a call to pthread_setspecific(). Calling
pthread_setspecific() from a thread-specific data destructor routine may result either in lost storage (after at least
PTHREAD_DESTRUCTOR_ITERATIONS attempts at destruction) or in an infinite loop.
Both functions may be implemented as macros.
RETURN VALUE
The pthread_getspecific() function shall return the thread-specific data value associated with the given key. If
no thread-specific data value is associated with key, then the value NULL shall be returned.
If successful, the pthread_setspecific() function shall return zero; otherwise, an error number shall be returned to
indicate the error.
ERRORS
No errors are returned from pthread_getspecific().
The pthread_setspecific() function shall fail if:
[ENOMEM]
Insufficient memory exists to associate the non-NULL value with the key.
The pthread_setspecific() function shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
Performance and ease-of-use of pthread_getspecific() are critical for functions that rely on maintaining state in
thread-specific data. Since no errors are required to be detected by it, and since the only error that could be detected is the use
of an invalid key, the function to pthread_getspecific() has been designed to favor speed and simplicity over error
reporting.
If an implementation detects that the value specified by the key argument to pthread_setspecific() does not refer
to a a key value obtained from pthread_key_create() or refers to a key
that has been deleted with pthread_key_delete(), it is recommended that
the function should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_key_create()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_getspecific() and pthread_setspecific() functions are marked as part of the Threads option.
IEEE PASC Interpretation 1003.1c #3 (Part 6) is applied, updating the DESCRIPTION.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/96 is applied, updating the ERRORS section so that the [ENOMEM]
error case is changed from "to associate the value with the key" to "to associate the non-NULL value with the key".
Issue 7
Austin Group Interpretation 1003.1-2001 #063 is applied, updating the ERRORS section.
The pthread_getspecific() and pthread_setspecific() functions are moved from the Threads option to the Base.
The [EINVAL] error for a key value not obtained from pthread_key_create() or a key deleted with pthread_key_delete() is removed; this condition results in undefined
behavior.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/chdir.html =====
chdir
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
chdir — change working directory
SYNOPSIS
#include
int chdir(const char *path);
DESCRIPTION
The chdir() function shall cause the directory named by the pathname pointed to by the path argument to become the
current working directory; that is, the starting point for path searches for pathnames not beginning with '/'.
RETURN VALUE
Upon successful completion, 0 shall be returned. Otherwise, -1 shall be returned, the current working directory shall remain
unchanged, and errno shall be set to indicate the error.
ERRORS
The chdir() function shall fail if:
[EACCES]
Search permission is denied for any component of the pathname.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of path does not name an existing directory or path is an empty string.
[ENOTDIR]
A component of the pathname names an existing file that is neither a directory nor a symbolic link to a directory.
The chdir() function may fail if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
The following sections are informative.
EXAMPLES
Changing the Current Working Directory
The following example makes the value pointed to by directory, /tmp, the current working directory.
#include
...
char *directory = "/tmp";
int ret;
ret = chdir (directory);
APPLICATION USAGE
None.
RATIONALE
The chdir() function only affects the working directory of the current process.
FUTURE DIRECTIONS
None.
SEE ALSO
getcwd()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The APPLICATION USAGE section is added.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The [ELOOP] mandatory error condition is added.
A second [ENAMETOOLONG] is added as an optional error condition.
The following changes were made to align with the IEEE P1003.1a draft standard:
The [ELOOP] optional error condition is added.
Issue 7
Austin Group Interpretation 1003.1-2001 #143 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0047 [324] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/memcmp.html =====
memcmp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
memcmp — compare bytes in memory
SYNOPSIS
#include
int memcmp(const void *s1, const void *s2, size_t n);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The memcmp() function shall compare the first n bytes (each interpreted as unsigned char) of the object
pointed to by s1 to the first n bytes of the object pointed to by s2.
The sign of a non-zero return value shall be determined by the sign of the difference between the values of the first pair of
bytes (both interpreted as type unsigned char) that differ in the objects being compared.
[CX]  The
memcmp() function shall not change the setting of errno on valid input.
RETURN VALUE
The memcmp() function shall return an integer greater than, equal to, or less than 0, if the object pointed to by
s1 is greater than, equal to, or less than the object pointed to by s2, respectively.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that memcmp() does not change the setting of errno on
valid input.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcstoull.html =====
wcstoul
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcstoul, wcstoull — convert a wide-character string to an unsigned long
SYNOPSIS
#include
unsigned long wcstoul(const wchar_t *restrict nptr,
wchar_t **restrict endptr, int base);
unsigned long long wcstoull(const wchar_t *restrict nptr,
wchar_t **restrict endptr, int base);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The wcstoul() and wcstoull() functions shall convert the initial portion of the wide-character string pointed to
by nptr to unsigned long and unsigned long long representation, respectively. First, they shall decompose the
input wide-character string into three parts:
An initial, possibly empty, sequence of white-space wide characters
A subject sequence interpreted as an integer represented in some radix determined by the value of base
A final wide-character string of one or more unrecognized wide-character codes, including the terminating null wide-character
code of the input wide-character string
Then they shall attempt to convert the subject sequence to an unsigned integer, and return the result.
If base is 0, the expected form of the subject sequence is that of a decimal constant, octal constant, or hexadecimal
constant, any of which may be preceded by a '+' or '-' sign. A decimal constant begins with a non-zero digit, and
consists of a sequence of decimal digits. An octal constant consists of the prefix '0' optionally followed by a sequence
of the digits '0' to '7' only. A hexadecimal constant consists of the prefix 0x or 0X followed by a sequence of
the decimal digits and letters 'a' (or 'A') to 'f' (or 'F') with values 10 to 15
respectively.
If the value of base is between 2 and 36, the expected form of the subject sequence is a sequence of letters and digits
representing an integer with the radix specified by base, optionally preceded by a '+' or '-' sign, but
not including an integer suffix. The letters from 'a' (or 'A') to 'z' (or 'Z') inclusive are
ascribed the values 10 to 35; only letters whose ascribed values are less than that of base shall be permitted. If the value
of base is 16, the wide-character codes 0x or 0X may optionally precede the sequence of letters and digits, following the
sign if present.
The subject sequence is defined as the longest initial subsequence of the input wide-character string, starting with the first
non-white-space wide character, that is of the expected form. The subject sequence contains no wide-character codes if the input
wide-character string is empty or consists entirely of white-space wide characters, or if the first non-white-space wide character
is other than a sign or a permissible letter or digit.
If the subject sequence has the expected form and base is 0, the sequence of wide-character codes starting with the first
digit shall be interpreted as an integer constant. If the subject sequence has the expected form and the value of base is
between 2 and 36, it shall be used as the base for conversion, ascribing to each letter its value as given above. If the subject
sequence begins with a , the resulting value shall be the negative of the converted value; this action shall be
performed in the return type. A pointer to the final wide-character string shall be stored in the object pointed to by
endptr, provided that endptr is not a null pointer.
In other than the C [CX]   or POSIX  locale, additional
locale-specific subject sequence forms may be accepted.
If the subject sequence is empty or does not have the expected form, no conversion shall be performed; the value of nptr
shall be stored in the object pointed to by endptr, provided that endptr is not a null pointer.
These functions shall not change the setting of errno if successful.
Since 0, {ULONG_MAX}, and {ULLONG_MAX} are returned on error and 0 is also a valid return on success, an application wishing to
check for error situations should set errno to 0, then call wcstoul() or wcstoull(), then check
errno.
RETURN VALUE
Upon successful completion, the wcstoul() and wcstoull() functions shall return the converted value, if any. If no
conversion could be performed, 0 shall be returned [CX]   and errno may be set to indicate the error.  If the correct value is outside the range of representable values,
{ULONG_MAX} or {ULLONG_MAX} respectively shall be returned and errno set to [ERANGE].
ERRORS
These functions shall fail if:
[EINVAL]
[CX]
The value of base is not supported.
[ERANGE]
The value to be returned is not representable.
These functions may fail if:
[EINVAL]
[CX]  No
conversion could be performed.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
fscanf(), iswalpha(), wcstod(), wcstol()
XBD
CHANGE HISTORY
First released in Issue 4. Derived from the MSE working draft.
Issue 5
The DESCRIPTION is updated to indicate that errno is not changed if the function is successful.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The [EINVAL] error condition is added for when the value of base is not supported.
In the RETURN VALUE and ERRORS sections, the [EINVAL] optional error condition is added if no conversion could be performed.
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The wcstoul() prototype is updated.
The wcstoull() function is added.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0727 [105] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0395 [584] and XSH/TC2-2008/0396 [796] are applied.
Issue 8
Austin Group Defect 700 is applied, clarifying how a subject sequence beginning with  is converted.
Austin Group Defect 1163 is applied, clarifying the handling of white space in the input string.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/cpowl.html =====
cpow
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cpow, cpowf, cpowl — complex power functions
SYNOPSIS
#include
double complex cpow(double complex x, double complex y);
float complex cpowf(float complex x, float complex y);
long double complex cpowl(long double complex x,
long double complex y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex power function xy, with a branch cut for the first
parameter along the negative real axis.
[MXC]
These functions shall raise floating-point exceptions if appropriate for the calculation of the parts of the result, and may also
raise spurious floating-point exceptions.
RETURN VALUE
These functions shall return the complex power function value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
Permitting spurious floating-point exceptions allows cpow(z, c) to be implemented as
cexp(cclog(z)) without precluding implementations that treat special cases more carefully.
FUTURE DIRECTIONS
None.
SEE ALSO
cabs(), csqrt()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/toupper_l.html =====
toupper
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
toupper, toupper_l — transliterate lowercase characters to uppercase
SYNOPSIS
#include
int toupper(int c);
[CX]  int toupper_l(int c, locale_t locale);
DESCRIPTION
For toupper(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The toupper() [CX]   and toupper_l()
functions have as a domain a type int, the value of which is representable as an unsigned char or the value of
EOF. If the argument has any other value, the behavior is undefined.
If the argument of toupper() [CX]   or toupper_l()
represents a lowercase letter, and there exists a corresponding uppercase letter as defined by character type information in
the current locale [CX]   or in the locale represented by locale,
respectively (category LC_CTYPE ), the result shall be the corresponding uppercase letter.
All other arguments in the domain are returned unchanged.
[CX]  The
behavior is undefined if the locale argument to toupper_l() is the special locale object LC_GLOBAL_LOCALE or is not a
valid locale object handle.
RETURN VALUE
Upon successful completion, toupper() [CX]   and toupper_l()   shall return the uppercase letter corresponding to the argument passed; otherwise, they shall
return the argument unchanged.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
setlocale(), uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
Extensions beyond the ISO C standard are marked.
Issue 7
SD5-XSH-ERN-181 is applied, clarifying the RETURN VALUE section.
The toupper_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0673 [283] and XSH/TC1-2008/0674 [283] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fgetwc.html =====
fgetwc
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fgetwc — get a wide-character code from a stream
SYNOPSIS
#include
#include
wint_t fgetwc(FILE *stream);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The fgetwc() function shall obtain the next character (if present) from the input stream pointed to by stream,
convert that to the corresponding wide-character code, and advance the associated file position indicator for the stream (if
defined).
If an error occurs, the resulting value of the file position indicator for the stream is unspecified.
[CX]  The
fgetwc() function may mark the last data access timestamp of the file associated with stream for update. The last
data access timestamp shall be marked for update by the first successful execution of fgetwc(), fgetws(), fwscanf(), getwc(), getwchar(), vfwscanf(), vwscanf(), or wscanf() using stream that returns data not supplied by a prior call to ungetwc().
The fgetwc() function shall not change the setting of errno if successful.
RETURN VALUE
Upon successful completion, the fgetwc() function shall return the wide-character code of the character read from the
input stream pointed to by stream converted to a type wint_t. If the end-of-file indicator for the stream is set, or
if the stream is at end-of-file, the end-of-file indicator for the stream shall be set and fgetwc() shall return WEOF. If an
error other than an encoding error occurs, the error indicator for the stream shall be set, and fgetwc() shall return WEOF
[CX]
and shall set errno to indicate the error.  If an
encoding error occurs, [CX]   the error indicator for the stream shall be set, and  fgetwc() shall return WEOF and shall set errno to indicate the error.
ERRORS
The fgetwc() function shall fail if data needs to be read and:
[EAGAIN]
[CX]
The O_NONBLOCK flag is set for the file descriptor underlying stream and the thread would be delayed in the fgetwc()
operation.
[EBADF]
[CX]
The file descriptor underlying stream is not a valid file descriptor open for reading.
[EILSEQ]
The data obtained from the input stream does not form a valid character.
[EINTR]
[CX]
The read operation was terminated due to the receipt of a signal, and no data was transferred.
[EIO]
[CX]  A
physical I/O error has occurred, or the process is in a background process group attempting to read from its controlling terminal,
and either the calling thread is blocking SIGTTIN or the process is ignoring SIGTTIN or the process group of the process is
orphaned. This error may also be generated for implementation-defined reasons.
[EOVERFLOW]
[CX]
The file is a regular file and an attempt was made to read at or beyond the offset maximum associated with the corresponding
stream.
The fgetwc() function may fail if:
[ENOMEM]
[CX]
Insufficient storage space is available.
[ENXIO]
[CX]  A
request was made of a nonexistent device, or the request was outside the capabilities of the device.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The ferror() or feof() functions must
be used to distinguish between an error condition and an end-of-file condition.
RATIONALE
The requirement to set the error indicator when an encoding error occurs is shaded CX because this is not required by the
ISO C standard. However, the next revision of the ISO C standard is expected to add this requirement.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, feof(), ferror(), fopen()
XBD ,
CHANGE HISTORY
First released in Issue 4. Derived from the MSE working draft.
Issue 5
The Optional Header (OH) marking is removed from .
Large File Summit extensions are added.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The [EIO] and [EOVERFLOW] mandatory error conditions are added.
The [ENOMEM] and [ENXIO] optional error conditions are added.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/33 is applied, updating the [EAGAIN] error in the ERRORS section
from "the process would be delayed" to "the thread would be delayed".
Issue 7
Austin Group Interpretation 1003.1-2001 #051 is applied, clarifying the RETURN VALUE section.
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0136 [105], XSH/TC1-2008/0137 [79], and XSH/TC1-2008/0138 [14] are
applied.
Issue 8
Austin Group Defect 1624 is applied, changing the RETURN VALUE and RATIONALE sections.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/timer_delete.html =====
timer_delete
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
timer_delete — delete a per-process timer
SYNOPSIS
[CX]  #include
int timer_delete(timer_t timerid);
DESCRIPTION
The timer_delete() function deletes the specified timer, timerid, previously created by the timer_create() function. If the timer is armed when timer_delete() is called,
the behavior shall be as if the timer is automatically disarmed before removal. The disposition of pending signals for the deleted
timer is unspecified.
The behavior is undefined if the value specified by the timerid argument to timer_delete() does not correspond to
a timer ID returned by timer_create() but not yet deleted by
timer_delete().
RETURN VALUE
If successful, the timer_delete() function shall return a value of zero. Otherwise, the function shall return a value of
-1 and set errno to indicate the error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
If an implementation detects that the value specified by the timerid argument to timer_delete() does not
correspond to a timer ID returned by timer_create() but not yet deleted by
timer_delete(), it is recommended that the function should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
timer_create()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The timer_delete() function is marked as part of the Timers option.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Timers
option.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/139 is applied, updating the ERRORS section so that the [EINVAL]
error becomes optional.
Issue 7
The timer_delete() function is moved from the Timers option to the Base.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0369 [659] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strdup.html =====
strdup
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strdup, strndup — duplicate a specific number of bytes from a string