===== susv5-html/basedefs/sys_uio.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
.
.TH SYS_UIO 3 "2025-06-08" "POSIX.1-2024" "Library Functions"
.SH NAME
sys/uio.h \- definitions for vector I/O operations
.SH SYNOPSIS
.B #include
.PP
.nf
struct iovec {
void   *iov_base; /* Base address of a memory region for input or output */
size_t  iov_len;  /* The size of the memory pointed to by iov_base */
};
ssize_t readv(int fd, const struct iovec *iov, int iovcnt);
ssize_t writev(int fd, const struct iovec *iov, int iovcnt);
.fi
.SH DESCRIPTION
The
.BR
header defines the
.B struct iovec
structure for use in scatter/gather I/O operations. The
.I iov_base
field is a pointer to a buffer, and
.I iov_len
specifies the length of that buffer. Arrays of
struct iovec
are used to describe multiple non-contiguous memory regions for a single I/O operation, enabling efficient reading or writing of data to or from multiple buffers in a single system call.
.SH STRUCTURES
.nf
struct iovec {
void   *iov_base; /* Starting address */
size_t  iov_len;  /* Number of bytes to transfer */
};
.fi
.SH FUNCTIONS
.TP
.B ssize_t readv(int fd, const struct iovec *iov, int iovcnt);
Reads data from file descriptor
.I fd
into multiple buffers described by the
.I iov
array of length
.I iovcnt
.
.TP
.B ssize_t writev(int fd, const struct iovec *iov, int iovcnt);
Writes data from multiple buffers described by the
.I iov
array of length
.I iovcnt
to file descriptor
.I fd
.
.SH RETURN VALUES
Upon successful completion,
.BR readv ()
and
.BR writev ()
return the number of bytes transferred. Otherwise, they return -1 and set
.I errno
to indicate the error.
.SH ERRORS
The
.BR readv ()
and
.BR writev ()
functions may fail for the same reasons as
.BR read (2)
and
.BR write (2)
respectively. Common errors include:
.TP
.B EBADF
The
.I fd
argument is not a valid file descriptor open for reading (for
.BR readv ())
or writing (for
.BR writev ()).
.TP
.B EFAULT
Part or all of the
.I iov
array points outside the process's address space.
.TP
.B EINVAL
The
.I iovcnt
argument is less than or equal to 0 or greater than the implementation limit
.BR IOV_MAX .
.TP
.B EIO
A low-level I/O error occurred while reading or writing.
.TP
.B Other errors
as described for
.BR read (2)
and
.BR write (2).
.SH CONFORMING TO
POSIX.1-2008 (XSI)
.SH SEE ALSO
,
,
.BR read (2),
.BR write (2),
.BR readv (2),
.BR writev (2)
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/netinet_in.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
netinet/in.h — Internet address family
SYNOPSIS
#include
DESCRIPTION
The  header shall define the following types:
in_port_t
Equivalent to the type uint16_t as described in .
in_addr_t
Equivalent to the type uint32_t as described in .
The  header shall define the sa_family_t type as described in .
The  header shall define the uint8_t and uint32_t types as described in . Inclusion of the  header may also make
visible all symbols from  and .
The  header shall define the in_addr structure, which shall include at least the following
member:
in_addr_t  s_addr
The  header shall define the sockaddr_in structure, which shall include at least the following
members:
sa_family_t     sin_family   AF_INET.
in_port_t       sin_port     Port number.
struct in_addr  sin_addr     IP address.
The sin_port and sin_addr members shall be in network byte order. If the sin_port value passed to bind() is zero, the port number bound to the socket shall be one chosen by the implementation
from an implementation-defined port range to produce an unused local address.
The sockaddr_in structure is used to store addresses for the Internet address family. Pointers to this type shall be cast
by applications to struct sockaddr * for use with socket functions.
[IP6]
The  header shall define the in6_addr structure, which shall include at least the following
member:
uint8_t s6_addr[16]
This array is used to contain a 128-bit IPv6 address, stored in network byte order.
The  header shall define the sockaddr_in6 structure, which shall include at least the
following members:
sa_family_t      sin6_family    AF_INET6.
in_port_t        sin6_port      Port number.
uint32_t         sin6_flowinfo  IPv6 traffic class and flow information.
struct in6_addr  sin6_addr      IPv6 address.
uint32_t         sin6_scope_id  Set of interfaces for a scope.
The sockaddr_in6 structure shall not include any additional members which have a floating-point type if an object of that
type with an all-bits-zero representation does not have the value 0.0.
[IP6 MX]  Implementations that define __STDC_IEC_559__ are required to treat the all-zero bit pattern for a floating point object as a
representation of 0.0, and may therefore have floating-point type members.
[IP6]
The sin6_port and sin6_addr members shall be in network byte order. If the sin6_port value passed to bind() is zero, the port number bound to the socket shall be one chosen by the implementation
from an implementation-defined port range to produce an unused local address.
Prior to calling a function in this standard which reads values from a sockaddr_in6 structure (for example, bind() or connect()), the application shall
ensure that all members of the structure, including any additional non-standard members, if any, are initialized. If the
sockaddr_in6 structure has a non-standard member, and that member has a value other than the value that would result from
default initialization, the behavior of any function in this standard that reads values from the sockaddr_in6 structure is
implementation-defined. All functions in this standard that return data in a sockaddr_in6 structure (for example, getaddrinfo() or accept()) shall
initialize the structure in a way that meets the above requirements, and shall ensure that each non-standard member, if any, has a
value that produces the same behavior as default initialization would in all functions in this standard which read values from a
sockaddr_in6 structure.
The sin6_scope_id field is a 32-bit integer that identifies a set of interfaces as appropriate for the scope of the
address carried in the sin6_addr field. For a link scope sin6_addr, the application shall ensure that
sin6_scope_id is a link index. For a site scope sin6_addr, the application shall ensure that sin6_scope_id is
a site index. The mapping of sin6_scope_id to an interface or set of interfaces is implementation-defined.
The  header shall declare the following external variable:
const struct in6_addr in6addr_any
This variable is initialized by the system to contain the wildcard IPv6 address. The  header also
defines the IN6ADDR_ANY_INIT macro. This macro shall be constant at compile time and can be used to initialize a variable of type
struct in6_addr to the IPv6 wildcard address.
The  header shall declare the following external variable:
const struct in6_addr in6addr_loopback
This variable is initialized by the system to contain the loopback IPv6 address. The  header also
defines the IN6ADDR_LOOPBACK_INIT macro. This macro shall be constant at compile time and can be used to initialize a variable of
type struct in6_addr to the IPv6 loopback address.
The  header shall define the ipv6_mreq structure, which shall include at least the following
members:
struct in6_addr  ipv6mr_multiaddr  IPv6 multicast address.
unsigned         ipv6mr_interface  Interface index.
The  header shall define the following symbolic constants for use as values of the level
argument of getsockopt() and setsockopt():
IPPROTO_IP
Internet protocol.
IPPROTO_IPV6
[IP6]
Internet Protocol Version 6.
IPPROTO_ICMP
Control message protocol.
IPPROTO_RAW
[RS]
Raw IP Packets Protocol.
IPPROTO_TCP
Transmission control protocol.
IPPROTO_UDP
User datagram protocol.
The  header shall define the following symbolic constant for use as a local address in the structure
passed to bind():
INADDR_ANY
IPv4 wildcard address.
The  header shall define the following symbolic constant for use as a destination address in the
structures passed to connect(), sendmsg(), and sendto():
INADDR_BROADCAST
IPv4 broadcast address.
The  header shall define the following symbolic constant, with the value specified, to help
applications declare buffers of the proper size to store IPv4 addresses in string form:
INET_ADDRSTRLEN
16. Length of the string form for IP.
The htonl(), htons(), ntohl(), and ntohs() functions shall be available
as described in . Inclusion of the
header may also make visible all symbols from .
[IP6]
The  header shall define the following symbolic constant, with the value specified, to help applications
declare buffers of the proper size to store IPv6 addresses in string form:
INET6_ADDRSTRLEN
46. Length of the string form for IPv6.
[IP6]
The  header shall define the following symbolic constants, with distinct integer values, for use in the
option_name argument in the getsockopt() or setsockopt() functions at protocol level IPPROTO_IPV6:
IPV6_JOIN_GROUP
Join a multicast group.
IPV6_LEAVE_GROUP
Quit a multicast group.
IPV6_MULTICAST_HOPS
Multicast hop limit.
IPV6_MULTICAST_IF
Interface to use for outgoing multicast packets.
IPV6_MULTICAST_LOOP
Multicast packets are delivered back to the local application.
IPV6_UNICAST_HOPS
Unicast hop limit.
IPV6_V6ONLY
Restrict AF_INET6 socket to IPv6 communications only.
The  header shall define the following macros that test for special IPv6 addresses. Each macro is of
type int and takes a single argument of type const struct in6_addr *:
IN6_IS_ADDR_UNSPECIFIED
Unspecified address.
IN6_IS_ADDR_LOOPBACK
Loopback address.
IN6_IS_ADDR_MULTICAST
Multicast address.
IN6_IS_ADDR_LINKLOCAL
Unicast link-local address.
IN6_IS_ADDR_SITELOCAL
Unicast site-local address.
IN6_IS_ADDR_V4MAPPED
IPv4 mapped address.
IN6_IS_ADDR_V4COMPAT
IPv4-compatible address.
IN6_IS_ADDR_MC_NODELOCAL
Multicast node-local address.
IN6_IS_ADDR_MC_LINKLOCAL
Multicast link-local address.
IN6_IS_ADDR_MC_SITELOCAL
Multicast site-local address.
IN6_IS_ADDR_MC_ORGLOCAL
Multicast organization-local address.
IN6_IS_ADDR_MC_GLOBAL
Multicast global address.
The following sections are informative.
APPLICATION USAGE
Although applications are required to initialize all members (including any non-standard ones) of a sockaddr_in6
structure, the same is not required for the sockaddr_in structure, since historically many applications only initialized the
standard members. Despite this, applications are encouraged to initialize sockaddr_in structures in a manner similar to the
required initialization of sockaddr_in6 structures.
The requirement that sockaddr_in6 does not include any additional members which have a floating-point type if an object
of that type with an all-bits-zero representation does not have the value 0.0 is to allow initialization of a sockaddr_in6
structure using:
struct sockaddr_in6 sa;
memset(&sa, 0, sizeof sa);
as an alternative to the use of default initialization.
RATIONALE
The INADDR_ANY and INADDR_BROADCAST values are byte-order-neutral and thus their byte order is not specified. Many
implementations have additional constants as extensions, such as INADDR_LOOPBACK, that are not byte-order-neutral. Traditionally,
these constants are in host byte order, requiring the use of htonl() when using them
in a sockaddr_in structure.
FUTURE DIRECTIONS
None.
SEE ALSO
4.13 Host and Network Byte Orders, ,
,
XSH bind(), connect(), getsockopt(), htonl(), sendmsg(), sendto(), setsockopt()
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
The sin_zero member was removed from the sockaddr_in structure as per The Open Group Base Resolution
bwg2001-004.
IEEE Std 1003.1-2001/Cor 1-2002, item XBD/TC1/D6/12 is applied, adding const qualifiers to the
in6addr_any and in6addr_loopback external variables.
IEEE Std 1003.1-2001/Cor 2-2004, item XBD/TC2/D6/22 is applied, making it clear which structure members are in
network byte order.
Issue 7
This reference page is clarified with respect to macros and symbolic constants.
POSIX.1-2008, Technical Corrigendum 1, XBD/TC1-2008/0061 [355] is applied.
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0065 [934], XBD/TC2-2008/0066 [952], XBD/TC2-2008/0067 [934], and
XBD/TC2-2008/0068 [952] are applied.
Issue 8
Austin Group Defect 940 is applied, requiring that the sockaddr_in6 structure does not include any additional members
which have a floating-point type if an object of that type with an all-bits-zero representation does not have the value 0.0.
Austin Group Defect 1068 is applied, specifying how a sin_port or sin6_port value of zero is handled by bind().
Austin Group Defect 1299 is applied, changing  to .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/V1_chap02.html =====
Conformance
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
2. Conformance
2.1 Implementation Conformance
For the purposes of POSIX.1-2024, the implementation conformance requirements given in this section apply.
2.1.1 Requirements
A conforming implementation shall meet all of the following criteria:
The system shall support all utilities, functions, and facilities defined within POSIX.1-2024 that are required for POSIX
conformance (see 2.1.3 POSIX Conformance). These interfaces shall support the functional behavior
described herein.
The system may support the X/Open System Interfaces (XSI) option as described in 2.1.4 XSI
Conformance.
The system may support one or more options as described under 2.1.5 Option Groups. When an
implementation claims that an option is supported, all of its constituent parts shall be provided.
The system may provide non-standard extensions. These are features not required by POSIX.1-2024 and may include, but are not
limited to:
Additional functions
Additional headers
Additional symbols in standard headers
Additional utilities
Additional options for standard utilities
Additional environment variables
Additional file types
Non-conforming file systems (for example, legacy file systems for which _POSIX_NO_TRUNC is false, case-insensitive file systems,
or network file systems)
Dynamically populated file systems (for example, /proc)
Additional character special files with special properties (for example, /dev/stdin, /dev/stdout, and
/dev/stderr)
Non-standard extensions of the utilities, functions, or facilities specified in POSIX.1-2024 should be identified as such in the
system documentation. Non-standard extensions, when used, may change the behavior of utilities, functions, or facilities defined by
POSIX.1-2024. The conformance document shall define an environment in which an application can be run with the behavior specified
by POSIX.1-2024. In no case shall such an environment require modification of a Strictly Conforming POSIX Application (see 2.2.1 Strictly Conforming POSIX Application).
Note:
If the documented method of setting up a conforming environment includes the need to set one or more environment variables,
then the values of those environment variables cannot include any  characters, since the confstr() function has to be able to return them in a -separated list of
variable=value pairs. See XSH confstr().
2.1.2 Documentation
A conformance document with the following information shall be available for an implementation claiming conformance to
POSIX.1-2024. The conformance document shall have the same structure as POSIX.1-2024, with the information presented in the
appropriate sections and subsections. Sections and subsections that consist solely of subordinate section titles, with no other
information, are not required. The conformance document shall not contain information about extended facilities or capabilities
outside the scope of POSIX.1-2024.
The conformance document shall contain a statement that indicates the full name, number, and date of the standard that applies.
The conformance document may also list international software standards that are available for use by a Conforming POSIX
Application. Applicable characteristics where documentation is required by one of these standards, or by standards of government
bodies, may also be included.
The conformance document shall describe the limit values found in the headers  and ,
stating values, the conditions under which those values may change, and the limits of such variations, if any.
The conformance document shall describe the behavior of the implementation for all implementation-defined features defined in
POSIX.1-2024. This requirement shall be met by listing these features and providing either a specific reference to the system
documentation or providing full syntax and semantics of these features. When the value or behavior in the implementation is
designed to be variable or customized on each instantiation of the system, the implementation provider shall document the nature
and permissible ranges of this variation.
The conformance document may specify the behavior of the implementation for those features where POSIX.1-2024 states that
implementations may vary or where features are identified as undefined or unspecified.
The conformance document shall not contain documentation other than that specified in the preceding paragraphs except where such
documentation is specifically allowed or required by other provisions of POSIX.1-2024.
The phrases "shall document" or "shall be documented" in POSIX.1-2024 mean that documentation of the feature shall appear in
the conformance document, as described previously, unless there is an explicit reference in the conformance document to show where
the information can be found in the system documentation.
The system documentation should also contain the information found in the conformance document.
2.1.3 POSIX Conformance
A conforming implementation shall meet the following criteria for POSIX conformance.
2.1.3.1 POSIX System Interfaces
The following requirements apply to the system interfaces (functions and headers):
The system shall support all the mandatory functions and headers defined in POSIX.1-2024, and shall set the symbolic constant
_POSIX_VERSION to the value 202405L.
Although all implementations conforming to POSIX.1-2024 support all the features described below, there may be system-dependent
or file system-dependent configuration procedures that can remove or modify any or all of these features. Such configurations
should not be made if strict compliance is required.
The following symbolic constants shall be defined with a value other than -1. If a constant is defined with the value zero,
applications should use the sysconf(), pathconf(), or fpathconf() functions, or
the getconf utility, to determine which features are present on the system at that
time or for the particular pathname in question.
_POSIX_CHOWN_RESTRICTED
The use of chown() is restricted to a process with appropriate privileges, and to
changing the group ID of a file only to the effective group ID of the process or to one of its supplementary group IDs.
_POSIX_NO_TRUNC
Pathname components longer than {NAME_MAX} generate an error.
The following symbolic constants shall be defined by the implementation as follows:
Symbolic constants defined with the value 202405L:
_POSIX_ASYNCHRONOUS_IO
_POSIX_BARRIERS
_POSIX_CLOCK_SELECTION
_POSIX_MAPPED_FILES
_POSIX_MEMORY_PROTECTION
_POSIX_MONOTONIC_CLOCK
_POSIX_READER_WRITER_LOCKS
_POSIX_REALTIME_SIGNALS
_POSIX_SEMAPHORES
_POSIX_SPIN_LOCKS
_POSIX_THREAD_SAFE_FUNCTIONS
_POSIX_THREADS
_POSIX_TIMEOUTS
_POSIX_TIMERS
_POSIX2_C_BIND
Symbolic constants defined with a value greater than zero:
_POSIX_JOB_CONTROL
_POSIX_REGEXP
_POSIX_SAVED_IDS
_POSIX_SHELL
Symbolic constants defined with a value other than -1.
_POSIX_VDISABLE
Note:
The symbols above represent historical options that are no longer allowed as options, but are retained here for
backwards-compatibility of applications.
The system may support one or more options (see 2.1.6 Options) denoted by the following symbolic
constants:
_POSIX_ADVISORY_INFO
_POSIX_CPUTIME
_POSIX_DEVICE_CONTROL
_POSIX_FSYNC
_POSIX_IPV6
_POSIX_MEMLOCK
_POSIX_MEMLOCK_RANGE
_POSIX_MESSAGE_PASSING
_POSIX_PRIORITIZED_IO
_POSIX_PRIORITY_SCHEDULING
_POSIX_RAW_SOCKETS
_POSIX_SHARED_MEMORY_OBJECTS
_POSIX_SPAWN
_POSIX_SPORADIC_SERVER
_POSIX_SYNCHRONIZED_IO
_POSIX_THREAD_ATTR_STACKADDR
_POSIX_THREAD_CPUTIME
_POSIX_THREAD_ATTR_STACKSIZE
_POSIX_THREAD_PRIO_INHERIT
_POSIX_THREAD_PRIO_PROTECT
_POSIX_THREAD_PRIORITY_SCHEDULING
_POSIX_THREAD_PROCESS_SHARED
_POSIX_THREAD_SPORADIC_SERVER
_POSIX_TYPED_MEMORY_OBJECTS
_XOPEN_CRYPT
_XOPEN_REALTIME
_XOPEN_REALTIME_THREADS
_XOPEN_UNIX
If the Advisory Information option is supported, there shall be at least one file system that supports the functionality.
2.1.3.2 POSIX Shell and Utilities
The following requirements apply to the shell and utilities:
The system shall provide all the mandatory utilities in the Shell and Utilities volume of POSIX.1-2024 with all the functional
behavior described therein.
The system shall support the Large File capabilities described in the Shell and Utilities volume of POSIX.1-2024.
The system may support one or more options (see 2.1.6 Options) denoted by the following symbolic
constants. (The literal names below apply to the getconf utility.)
POSIX2_C_DEV
POSIX2_CHAR_TERM
POSIX2_FORT_RUN
POSIX2_LOCALEDEF
POSIX2_SW_DEV
POSIX2_UPE
XOPEN_UNIX
XOPEN_UUCP
Additional language bindings and development utility options may be provided in other related standards or in a future version
of this standard. In the former case, additional symbolic constants of the same general form as shown in this subsection should be
defined by the related standard document and made available to the application without requiring POSIX.1-2024 to be updated.
2.1.4 XSI Conformance
[XSI]
This section describes the criteria for implementations providing conformance to the X/Open System Interfaces (XSI) option (see
3.424 XSI). The functionality described in this section shall be
provided on implementations that support the XSI option (and the rest of this section is not further marked).
POSIX.1-2024 describes utilities, functions, and facilities offered to application programs by the X/Open System Interfaces
(XSI) option. An XSI-conforming implementation shall meet the criteria for POSIX conformance and the following requirements listed
in this section.
XSI-conforming implementations shall set the symbolic constant _XOPEN_UNIX to a value other than -1 and shall set the symbolic
constant _XOPEN_VERSION to the value 800.
2.1.4.1 XSI System Interfaces
The following requirements apply to the system interfaces when the XSI option is supported:
The system shall support all the functions and headers defined in POSIX.1-2024 as part of the XSI option denoted by the XSI
marking in the SYNOPSIS section, and any extensions marked with the XSI option marking (see 1.8.1 Codes) within the text.
The system shall support the following options defined within POSIX.1-2024 (see 2.1.6 Options):
_POSIX_FSYNC
_POSIX_THREAD_ATTR_STACKADDR
_POSIX_THREAD_ATTR_STACKSIZE
_POSIX_THREAD_PROCESS_SHARED
The system may support the following XSI Option Groups (see 2.1.5.2 XSI Option Groups) defined
within POSIX.1-2024:
Encryption
Realtime
Advanced Realtime
Realtime Threads
Advanced Realtime Threads
2.1.4.2 XSI Shell and Utilities Conformance
The following requirements apply to the shell and utilities when the XSI option is supported:
The system shall support all the utilities defined in the Shell and Utilities volume of POSIX.1-2024 as part of the XSI option
denoted by the XSI marking in the SYNOPSIS section, and any extensions marked with the XSI option marking (see 1.8.1 Codes) within the text.
The system shall support the User Portability Utilities option and the Terminal Characteristics option.
The system shall support creation of locales (see 7. Locale).
The C-language Development utility c17 shall be supported.
The XSI Development Utilities option may be supported. It consists of the following software development utilities:
admin
cflow
ctags
cxref
delta
get
nm
prs
rmdel
sact
sccs
unget
val
what
2.1.5 Option Groups
An Option Group is a group of related functions or options defined within the System Interfaces volume of
POSIX.1-2024.
If an implementation supports an Option Group, then the system shall support the functional behavior described
herein.
If an implementation does not support an Option Group, then the system need not support the functional behavior
described herein.
2.1.5.1 Subprofiling Considerations
Profiling standards supporting functional requirements less than that required in POSIX.1-2024 may subset both
mandatory and optional functionality required for POSIX Conformance (see 2.1.3 POSIX Conformance) or
XSI Conformance (see 2.1.4 XSI Conformance). Such profiles shall organize the subsets into
Subprofiling Option Groups.
XRAT E. Subprofiling Considerations (Informative) describes
a representative set of such Subprofiling Option Groups for use by profiles applicable to specialized realtime systems.
POSIX.1-2024 does not require that the presence of Subprofiling Option Groups be testable at compile-time (as symbols defined in
any header) or at runtime (via sysconf() or getconf).
A Subprofiling Option Group may provide basic system functionality that other Subprofiling Option Groups and other
options depend upon.1 If a profile of POSIX.1-2024 does not require an
implementation to provide a Subprofiling Option Group that provides features utilized by a required Subprofiling Option Group (or
option),2 the profile shall specify3 all of the following:
Restricted or altered behavior of interfaces defined in POSIX.1-2024 that may differ on an implementation of the
profile
Additional behaviors that may produce undefined or unspecified results
Additional implementation-defined behavior that implementations shall be required to document in the profile's
conformance document
if any of the above is a result of the profile not requiring an interface required by POSIX.1-2024.
The following additional rules shall apply to all profiles of POSIX.1-2024:
Any application that conforms to that profile shall also conform to POSIX.1-2024, unless the application depends
on the definition of a profile support indicator macro in  (that is,
a profile shall not require restricted, altered, or extended behaviors of an implementation of POSIX.1-2024).
Profiles are permitted to require the definition of a profile support indicator macro with a name beginning
_POSIX_AEP_ in .
Profiles shall require the definition of the macro _POSIX_SUBPROFILE in  on implementations that do not meet all of the requirements of a
POSIX.1-conforming implementation.
Profiles are permitted to add additional requirements to the limits defined in  and ,
subject to the following:
For the limits in  and :
If the limit is specified as having a fixed value, it shall not be changed by a profile.
If a limit is specified as having a minimum or maximum acceptable value, it may be changed by a profile as
follows:
A profile may increase a minimum acceptable value, but shall not make a minimum acceptable value smaller.
A profile may reduce a maximum acceptable value, but shall not make a maximum acceptable value larger.
A profile shall not change a limit specified as having a minimum or maximum value into a limit specified as having
a fixed value.
A profile shall not create new limits.
Any implementation that conforms to POSIX.1-2024 (including all options and extended limits required by the
profile) shall also conform to that profile, except for the possible omission from  of a profile support indicator macro required by the profile.
2.1.5.2 XSI Option Groups
[XSI]  This section describes Option Groups to support the definition of XSI conformance within the System Interfaces volume
of POSIX.1-2024. The functionality described in this section shall be provided on implementations that support the XSI option and
the appropriate Option Group (and the rest of this section is not further marked).
The following Option Groups are defined.
Encryption
The Encryption Option Group is denoted by the symbolic constant _XOPEN_CRYPT. It includes the following
functions:
crypt(), [OB]   encrypt(), setkey()
These functions are marked CRYPT.
Due to export restrictions on the cryptographic algorithm in some countries, implementations may be restricted in
making these functions available. All the functions in the Encryption Option Group may therefore return [ENOSYS] or, alternatively,
encrypt() shall return [ENOSYS] for the decryption operation.
An implementation that claims conformance to this Option Group shall set _XOPEN_CRYPT to a value other than -1.
Realtime
The Realtime Option Group is denoted by the symbolic constant _XOPEN_REALTIME.
This Option Group includes a set of realtime functions drawn from options within POSIX.1-2024 (see 2.1.6 Options).
Where entire functions are included in the Option Group, the NAME section is marked with REALTIME. Where additional
semantics have been added to existing pages, the new material is identified by use of the appropriate margin legend for the
underlying option defined within POSIX.1-2024.
An implementation that claims conformance to this Option Group shall set _XOPEN_REALTIME to a value other than
-1.
This Option Group consists of the set of the following options from within POSIX.1-2024 (see 2.1.6 Options):
_POSIX_FSYNC
_POSIX_MEMLOCK
_POSIX_MEMLOCK_RANGE
_POSIX_MESSAGE_PASSING
_POSIX_PRIORITIZED_IO
_POSIX_PRIORITY_SCHEDULING
_POSIX_SHARED_MEMORY_OBJECTS
_POSIX_SYNCHRONIZED_IO
If the symbolic constant _XOPEN_REALTIME is defined to have a value other than -1, then the following symbolic
constants shall be defined by the implementation to have the value 202405L:
_POSIX_MEMLOCK
_POSIX_MEMLOCK_RANGE
_POSIX_MESSAGE_PASSING
_POSIX_PRIORITY_SCHEDULING
_POSIX_SHARED_MEMORY_OBJECTS
_POSIX_SYNCHRONIZED_IO
The functionality associated with _POSIX_FSYNC shall always be supported on XSI-conformant systems.
Support of _POSIX_PRIORITIZED_IO on XSI-conformant systems is optional. If _POSIX_PRIORITIZED_IO is supported, then
asynchronous I/O operations performed by aio_read(), aio_write(), and lio_listio() shall be
submitted at a priority equal to the scheduling priority equal to a base scheduling priority minus
aiocbp->aio_reqprio. If Thread Execution Scheduling is not supported, then the base scheduling priority is that of
the calling process; otherwise, the base scheduling priority is that of the calling thread. The implementation shall also document
for which files I/O prioritization is supported.
Advanced Realtime
An implementation that claims conformance to this Option Group shall also support the Realtime Option Group.
Where entire functions are included in the Option Group, the NAME section is marked with ADVANCED REALTIME. Where
additional semantics have been added to existing pages, the new material is identified by use of the appropriate margin legend for
the underlying option defined within POSIX.1-2024.
This Option Group consists of the set of the following options from within POSIX.1-2024 (see 2.1.6 Options):
_POSIX_ADVISORY_INFO
_POSIX_CPUTIME
_POSIX_SPAWN
_POSIX_SPORADIC_SERVER
_POSIX_TYPED_MEMORY_OBJECTS
If the implementation supports the Advanced Realtime Option Group, then the following symbolic constants shall be
defined by the implementation to have the value 202405L:
_POSIX_ADVISORY_INFO
_POSIX_CPUTIME
_POSIX_SPAWN
_POSIX_SPORADIC_SERVER
_POSIX_TYPED_MEMORY_OBJECTS
If the symbolic constant _POSIX_SPORADIC_SERVER is defined, then the symbolic constant _POSIX_PRIORITY_SCHEDULING
shall also be defined by the implementation to have the value 202405L.
Realtime Threads
The Realtime Threads Option Group is denoted by the symbolic constant _XOPEN_REALTIME_THREADS.
This Option Group consists of the set of the following options from within POSIX.1-2024 (see 2.1.6 Options):
_POSIX_THREAD_PRIO_INHERIT
_POSIX_THREAD_PRIO_PROTECT
_POSIX_THREAD_PRIORITY_SCHEDULING
_POSIX_THREAD_ROBUST_PRIO_INHERIT
_POSIX_THREAD_ROBUST_PRIO_PROTECT
Where applicable, whole pages are marked REALTIME THREADS, together with the appropriate option margin legend for
the SYNOPSIS section (see 1.8.1 Codes).
An implementation that claims conformance to this Option Group shall set _XOPEN_REALTIME_THREADS to a value other
than -1.
If the symbol _XOPEN_REALTIME_THREADS is defined to have a value other than -1, then the following options shall
also be defined by the implementation to have the value 202405L:
_POSIX_THREAD_PRIO_INHERIT
_POSIX_THREAD_PRIO_PROTECT
_POSIX_THREAD_PRIORITY_SCHEDULING
_POSIX_THREAD_ROBUST_PRIO_INHERIT
_POSIX_THREAD_ROBUST_PRIO_PROTECT
Advanced Realtime Threads
An implementation that claims conformance to this Option Group shall also support the Realtime Threads Option
Group.
Where entire functions are included in the Option Group, the NAME section is marked with ADVANCED REALTIME THREADS.
Where additional semantics have been added to existing pages, the new material is identified by use of the appropriate margin
legend for the underlying option defined within POSIX.1-2024.
This Option Group consists of the set of the following options from within POSIX.1-2024 (see 2.1.6 Options):
_POSIX_THREAD_CPUTIME
_POSIX_THREAD_SPORADIC_SERVER
If the symbolic constant _POSIX_THREAD_SPORADIC_SERVER is defined to have the value 202405L, then the symbolic
constant _POSIX_THREAD_PRIORITY_SCHEDULING shall also be defined by the implementation to have the value 202405L.
If the implementation supports the Advanced Realtime Threads Option Group, then the following symbolic constants
shall be defined by the implementation to have the value 202405L:
_POSIX_THREAD_CPUTIME
_POSIX_THREAD_SPORADIC_SERVER
2.1.6 Options
The symbolic constants defined in , Constants for Options and Option Groups reflect implementation options for POSIX.1-2024.
These symbols can be used by the application to determine which of three categories of support for optional facilities are provided
by the implementation.
Option not supported for compilation.
The implementation advertises at compile time (by defining the constant in  with value -1, or by leaving it undefined) that the option is not supported
for compilation and, at the time of compilation, is not supported for runtime use. In this case, the headers, data types, function
interfaces, and utilities required only for the option need not be present. A later runtime check using the fpathconf(), pathconf(), or sysconf
functions defined in the System Interfaces volume of POSIX.1-2024 or the getconf
utility defined in the Shell and Utilities volume of POSIX.1-2024 can in some circumstances indicate that the option is supported
at runtime. (For example, an old application binary might be run on a newer implementation to which support for the option has been
added.)
Option always supported.
The implementation advertises at compile time (by defining the constant in  with a value greater than zero) that the option is supported both for
compilation and for use at runtime. In this case, all headers, data types, function interfaces, and utilities required only for the
option shall be available and shall operate as specified. Runtime checks with fpathconf(), pathconf(), or sysconf shall
indicate that the option is supported.
Option might or might not be supported at runtime.
The implementation advertises at compile time (by defining the constant in  with value zero) that the option is supported for compilation and might or
might not be supported at runtime. In this case, the fpathconf(), pathconf(), or sysconf() functions defined
in the System Interfaces volume of POSIX.1-2024 or the getconf utility defined in
the Shell and Utilities volume of POSIX.1-2024 can be used to retrieve the value of each symbol on each specific implementation to
determine whether the option is supported at runtime. All headers, data types, and function interfaces required to compile and
execute applications which use the option at runtime (after checking at runtime that the option is supported) shall be provided,
but if the option is not supported at runtime they need not operate as specified. Utilities or other facilities required only for
the option, but not needed to compile and execute such applications, need not be present.
If an option is not supported for compilation, an application that attempts to use anything associated only with
the option is considered to be requiring an extension. Unless explicitly specified otherwise, the behavior of functions associated
with an option that is not supported at runtime is unspecified, and an application that uses such functions without first checking
fpathconf(), pathconf(), or
sysconf is considered to be requiring an extension.
Margin codes are defined for each option (see 1.8.1
Codes).
2.1.6.1 System Interfaces
Refer to , Constants for Options and Option Groups for the list of options.
2.1.6.2 Shell and Utilities
Each of these symbols shall be considered valid names by the implementation. Refer to , Constants for Options and Option
Groups.
The literal names shown below apply only to the getconf utility.
POSIX2_C_DEV
[CD]
The system supports the C-Language Development Utilities option.
The utilities in the C-Language Development Utilities option are used for the development of C-language
applications, including compilation or translation of C source code and complex program generators for simple lexical tasks and
processing of context-free grammars.
The utilities listed below may be provided by a conforming system; however, any system claiming conformance to the
C-Language Development Utilities option shall provide all of the utilities listed.
c17
lex
yacc
POSIX2_CHAR_TERM
The system supports the Terminal Characteristics option. This value need not be present on a system not supporting the User
Portability Utilities option.
Where applicable, the dependency is noted within the description of the utility.
This option applies only to systems supporting the User Portability Utilities option. If supported, then the system
supports at least one terminal type capable of all operations described in POSIX.1-2024; see 10.2 Output Devices and Terminal Types.
POSIX2_FORT_RUN
[FR]
The system supports the FORTRAN Runtime Utilities option.
The asa utility is the only utility in the FORTRAN Runtime Utilities
option.
The asa utility may be provided by a conforming system; however, any
system claiming conformance to the FORTRAN Runtime Utilities option shall provide the asa utility.
POSIX2_LOCALEDEF
The system supports the Locale Creation Utilities option.
If supported, the system supports the creation of locales as described in the localedef utility.
The localedef utility may be provided by a conforming system;
however, any system claiming conformance to the Locale Creation Utilities option shall provide the localedef utility.
POSIX2_SW_DEV
[SD]
The system supports the Software Development Utilities option.
The utilities in the Software Development Utilities option are used for the development of applications, including
compilation or translation of source code, the creation and maintenance of library archives, and the maintenance of groups of
inter-dependent programs.
The utilities listed below may be provided by the conforming system; however, any system claiming conformance to
the Software Development Utilities option shall provide all of the utilities listed here.
ar
make
nm
strip
POSIX2_UPE
[UP]
The system supports the User Portability Utilities option.
The utilities in the User Portability Utilities option shall be implemented on all systems that claim conformance
to this option, except for the vi utility which is noted as having features that cannot
be implemented on all terminal types; if the POSIX2_CHAR_TERM option is supported, the system shall support all such features on at
least one terminal type; see 10.2 Output Devices and Terminal Types.
The list of utilities in the User Portability Utilities option is as follows:
bg
ex
fc
fg
jobs
man
more
talk
vi
XOPEN_UNIX
[XSI]
The system supports the X/Open System Interfaces (XSI) option (see 2.1.4 XSI Conformance).
XOPEN_UUCP
[UU]
The system supports the UUCP Utilities option.
The list of utilities in the UUCP Utilities option is as follows:
uucp
uustat
uux
2.2 Application Conformance
For the purposes of POSIX.1-2024, the application conformance requirements given in this section apply.
All applications claiming conformance to POSIX.1-2024 shall use only language-dependent services for the C
programming language described in 2.3 Language-Dependent Services for the C Programming Language, shall
use only the utilities and facilities defined in the Shell and Utilities volume of POSIX.1-2024, and shall fall within one of the
following categories.
2.2.1 Strictly Conforming POSIX Application
A Strictly Conforming POSIX Application is an application that requires only the facilities described in
POSIX.1-2024. Such an application:
Shall accept any implementation behavior that results from actions it takes in areas described in POSIX.1-2024 as
implementation-defined or unspecified, or where POSIX.1-2024 indicates that implementations may vary
Shall not perform any actions that are described as producing undefined results
For symbolic constants, shall accept any value in the range permitted by POSIX.1-2024, but shall not rely on any
value in the range being greater than the minimums listed or being less than the maximums listed in POSIX.1-2024
Shall not use facilities designated as obsolescent
Is required to tolerate and permitted to adapt to the presence or absence of optional facilities whose
availability is indicated by 2.1.3 POSIX Conformance
For the C programming language, shall not produce any output dependent on any behavior described in the ISO C
standard as unspecified, undefined, or implementation-defined, unless the System Interfaces volume of
POSIX.1-2024 specifies the behavior
For the C programming language, shall not exceed any minimum implementation limit defined in the ISO C
standard, unless the System Interfaces volume of POSIX.1-2024 specifies a higher minimum implementation limit
For the C programming language, shall define _POSIX_C_SOURCE to be 202405L before any header is included
Within POSIX.1-2024, any restrictions placed upon a Conforming POSIX Application shall restrict a Strictly
Conforming POSIX Application.
2.2.2 Conforming POSIX Application
2.2.2.1 ISO/IEC Conforming POSIX Application
An ISO/IEC Conforming POSIX Application is an application that uses only the facilities described in POSIX.1-2024
and approved Conforming Language bindings for any ISO or IEC standard. Such an application shall include a statement of conformance
that documents all options and limit dependencies, and all other ISO or IEC standards used.
2.2.2.2  Conforming POSIX
Application
A  Conforming POSIX Application differs from an ISO/IEC Conforming POSIX Application in that
it also may use specific standards of a single ISO/IEC member body referred to here as . Such an
application shall include a statement of conformance that documents all options and limit dependencies, and all other  standards used.
2.2.3 Conforming POSIX Application Using Extensions
A Conforming POSIX Application Using Extensions is an application that differs from a Conforming POSIX Application
only in that it uses non-standard facilities that are consistent with POSIX.1-2024. Such an application shall fully document its
requirements for these extended facilities, in addition to the documentation required of a Conforming POSIX Application. A
Conforming POSIX Application Using Extensions shall be either an ISO/IEC Conforming POSIX Application Using Extensions or a
Conforming POSIX Application Using Extensions (see 2.2.2.1 ISO/IEC Conforming
POSIX Application and 2.2.2.2  Conforming POSIX Application).
2.2.4 Strictly Conforming XSI Application
A Strictly Conforming XSI Application is an application that requires only the facilities described in
POSIX.1-2024. Such an application:
Shall accept any implementation behavior that results from actions it takes in areas described in POSIX.1-2024 as
implementation-defined or unspecified, or where POSIX.1-2024 indicates that implementations may vary
Shall not perform any actions that are described as producing undefined results
For symbolic constants, shall accept any value in the range permitted by POSIX.1-2024, but shall not rely on any
value in the range being greater than the minimums listed or being less than the maximums listed in POSIX.1-2024
Shall not use facilities designated as obsolescent
Is required to tolerate and permitted to adapt to the presence or absence of optional facilities whose
availability is indicated by 2.1.4 XSI Conformance
For the C programming language, shall not produce any output dependent on any behavior described in the ISO C
standard as unspecified, undefined, or implementation-defined, unless the System Interfaces volume of
POSIX.1-2024 specifies the behavior
For the C programming language, shall not exceed any minimum implementation limit defined in the ISO C
standard, unless the System Interfaces volume of POSIX.1-2024 specifies a higher minimum implementation limit
For the C programming language, shall define _XOPEN_SOURCE to be 800 before any header is included
Within POSIX.1-2024, any restrictions placed upon a Conforming POSIX Application shall restrict a Strictly
Conforming XSI Application.
2.2.5 Conforming XSI Application Using Extensions
A Conforming XSI Application Using Extensions is an application that differs from a Strictly Conforming XSI
Application only in that it uses non-standard facilities that are consistent with POSIX.1-2024. Such an application shall fully
document its requirements for these extended facilities, in addition to the documentation required of a Strictly Conforming XSI
Application.
2.3 Language-Dependent Services for the C Programming Language
Implementors seeking to claim conformance using the ISO C standard shall claim POSIX conformance as described
in 2.1.3 POSIX Conformance.
2.4 Other Language-Related Specifications
POSIX.1-2024 is currently specified in terms of the shell command language and ISO C. Bindings to other
programming languages are being developed.
If conformance to POSIX.1-2024 is claimed for implementation of any programming language, the implementation of
that language shall support the use of external symbols distinct to at least 31 bytes in length in the source program text. (That
is, identifiers that differ at or before the thirty-first byte shall be distinct.) If a national or international standard
governing a language defines a maximum length that is less than this value, the language-defined maximum shall be supported.
External symbols that differ only by case shall be distinct when the character set in use distinguishes uppercase and lowercase
characters and the language permits (or requires) uppercase and lowercase characters to be distinct in external symbols.
Footnotes
1. As an example, the File System profiling option group provides underlying support
for pathname resolution and file creation which are needed by any interface in POSIX.1-2024 that parses a path argument. If
a profile requires support for the Device Input and Output profiling option group but does not require support for the File System
profiling option group, the profile needs to specify how pathname resolution is to behave in that profile, how the O_CREAT flag to
open() is to be handled (and the use of the character 'a' in the mode
argument of fopen() when a pathname argument names a file that does not exist), and
specify lots of other details.
2. As an example, POSIX.1-2024 requires that implementations claiming to support the
Range Memory Locking option also support the Process Memory Locking option. A profile could require that the Range Memory Locking
option had to be supplied without requiring that the Process Memory Locking option be supplied as long as the profile specifies
everything an application developer or system implementor would have to know to build an application or implementation conforming
to the profile.
3. Note that the profile could just specify that any use of the features not specified
by the profile would produce undefined or unspecified results.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/netinet_tcp.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
netinet/tcp.h — definitions for the Internet Transmission Control Protocol (TCP)
SYNOPSIS
#include
DESCRIPTION
The  header shall define the following symbolic constant for use as a socket option at the
IPPROTO_TCP level:
TCP_NODELAY
Avoid coalescing of small segments.
The implementation need not allow the value of the option to be set via setsockopt() or retrieved via getsockopt().
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XSH getsockopt(), setsockopt()
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
Issue 7
This reference page is clarified with respect to macros and symbolic constants.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/poll.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
poll.h — definitions for the poll() function
SYNOPSIS
#include
DESCRIPTION
The  header shall define the pollfd structure, which shall include at least the following
members:
int    fd       The following descriptor being polled.
short  events   The input event flags (see below).
short  revents  The output event flags (see below).
The  header shall define the following type through typedef:
nfds_t
An unsigned integer type used for the number of file descriptors.
The implementation shall support one or more programming environments in which the width of nfds_t is no greater than the
width of type long. The names of these programming environments can be obtained using the confstr() function or the getconf
utility.
The  header shall define the sigset_t type as described in .
The  header shall define the timespec structure as described in .
The  header shall define the following symbolic constants, zero or more of which may be OR'ed together to
form the events or revents members in the pollfd structure:
POLLIN
Data other than high-priority data may be read without blocking.
POLLRDNORM
Normal data may be read without blocking.
POLLRDBAND
Priority data may be read without blocking.
POLLPRI
High priority data may be read without blocking.
POLLOUT
Normal data may be written without blocking.
POLLWRNORM
Equivalent to POLLOUT.
POLLWRBAND
Priority data may be written.
POLLERR
An error has occurred (revents only).
POLLHUP
Device has been disconnected (revents only).
POLLNVAL
Invalid fd member (revents only).
The significance and semantics of normal, priority, and high-priority data are file and device-specific.
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
int   poll(struct pollfd [], nfds_t, int);
int   ppoll(struct pollfd [], nfds_t, const struct timespec *restrict,
const sigset_t *restrict);
Inclusion of the  header may make visible all symbols from the headers  and .
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XSH confstr(), poll()
XCU getconf
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 6
The description of the symbolic constants is updated to match the poll()
function.
Text related to STREAMS has been moved to the poll() reference page.
A note is added to the DESCRIPTION regarding the significance and semantics of normal, priority, and high-priority data.
Issue 7
The  header is moved from the XSI option to the Base.
Issue 8
Austin Group Defect 1263 is applied, adding ppoll(), requiring
to define sigset_t and struct timespec, and allowing  to make visible all
symbols from  and .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/V1_chap14.html =====
Headers
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
14. Headers
This chapter describes the contents of headers.
Headers contain function prototypes, the definition of symbolic constants, common structures, preprocessor macros, and defined
types. Each function in the System Interfaces volume of POSIX.1-2024 specifies the headers that an application shall include in
order to use that function. In most cases, only one header is required. These headers are present on an application development
system; they need not be present on the target execution system.
Format of Entries
The entries in this chapter are based on a common format as follows. The only sections relating to conformance are the SYNOPSIS
and DESCRIPTION.
NAME
This section gives the name or names of the entry and briefly states its purpose.
SYNOPSIS
This section summarizes the use of the entry being described.
DESCRIPTION
This section describes the functionality of the header.
APPLICATION USAGE
This section is informative. This section gives warnings and advice to application developers about the entry. In the event of
conflict between warnings and advice and a normative part of this volume of POSIX.1-2024, the normative material is to be taken as
correct.
RATIONALE
This section is informative. This section contains historical information concerning the contents of this volume of POSIX.1-2024
and why features were included or discarded by the standard developers.
FUTURE DIRECTIONS
This section is informative. This section provides comments which should be used as a guide to current thinking; there is not
necessarily a commitment to adopt these future directions.
SEE ALSO
This section is informative. This section gives references to related information.
CHANGE HISTORY
This section is informative. This section shows the derivation of the entry and any significant changes that have been made to
it.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/time.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
time.h — time types
SYNOPSIS
#include
DESCRIPTION
[CX]  Some of the functionality described on this reference page extends the ISO C standard. Applications shall define
the appropriate feature test macro (see XSH 2.2 The Compilation
Environment) to enable the visibility of these symbols in this header.
The  header shall define the clock_t, size_t, time_t, types as described in .
[CX]  The
header shall define the clockid_t and timer_t types as described in .
The  header shall define the locale_t type as described in .
[CPT]
The  header shall define the pid_t type as described in .
[CX]  The
tag sigevent shall be declared as naming an incomplete structure type, the contents of which are described in the  header.
The  header shall declare the tm structure, which shall include at least the following members:
int         tm_sec    Seconds [0,60].
int         tm_min    Minutes [0,59].
int         tm_hour   Hour [0,23].
int         tm_mday   Day of month [1,31].
int         tm_mon    Month of year [0,11].
int         tm_year   Years since 1900.
int         tm_wday   Day of week [0,6] (Sunday =0).
int         tm_yday   Day of year [0,365].
int         tm_isdst  Daylight Saving flag.
long        tm_gmtoff Seconds east of UTC.
const char *tm_zone   Timezone abbreviation.
When tm_isdst is set by an interface defined in this standard, its value shall be positive if Daylight Saving Time (DST)
is in effect and 0 if DST is not in effect. [CX]  It shall not be set to a negative value by any interface defined in this
standard. When tm_isdst is passed to the mktime() function, it specifies how
mktime() is to handle DST when calculating the time since the Epoch value; see
mktime().
[CX]  If
the value of tm_zone is accessed after the value of TZ is subsequently modified, and the tm_zone value was not
set by a call to gmtime() or gmtime_r(), the behavior is undefined.
The  header shall declare the timespec structure, which shall include at least the following
members:
time_t  tv_sec    Whole seconds.
long    tv_nsec   Nanoseconds [0, 999999999].
[CX]  The
header shall also declare the itimerspec structure, which shall include at least the following
members:
struct timespec  it_interval  Timer period.
struct timespec  it_value     Timer expiration.
The  header shall define the following macros:
NULL
As described in .
CLOCKS_PER_SEC
A number used to convert the value returned by the clock() function into seconds.
The value shall be an expression with type clock_t. [XSI]   The value of CLOCKS_PER_SEC shall be 1 million on XSI-conformant
systems. However, it may be variable on other systems, and it should not be assumed that CLOCKS_PER_SEC is a compile-time constant.
TIME_UTC
An integer constant greater than 0 that designates the UTC time base in calls to timespec_get(). The value shall be suitable for use in #if preprocessing
directives.
[CX]  The
header shall define the following symbolic constants. The values shall have a type that is
assignment-compatible with clockid_t.
CLOCK_MONOTONIC
[CX]
The identifier for the system-wide monotonic clock, which is defined as a clock measuring real time, whose value cannot be set via
clock_settime() and which cannot have negative clock jumps. The maximum
possible clock jump shall be implementation-defined.
CLOCK_PROCESS_CPUTIME_ID
[CPT]
The identifier of the CPU-time clock associated with the process making a clock*() or timer*() function call.
CLOCK_REALTIME
[CX]
The identifier of the system-wide clock measuring real time.
CLOCK_THREAD_CPUTIME_ID
[TCT]
The identifier of the CPU-time clock associated with the thread making a clock*() or timer*() function call.
[CX]  The
header shall define the following symbolic constant:
TIMER_ABSTIME
Flag indicating time is absolute. For functions taking timer objects, this refers to the clock associated with the timer.
[XSI]
The  header shall provide a declaration or definition for getdate_err. The getdate_err symbol
shall expand to an expression of type int. It is unspecified whether getdate_err is a macro or an identifier declared
with external linkage, and whether or not it is a modifiable lvalue. If a macro definition is suppressed in order to access an
actual object, or a program defines an identifier with the name getdate_err, the behavior is undefined.
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
[OB]
char      *asctime(const struct tm *);
clock_t    clock(void);
[CPT]
int        clock_getcpuclockid(pid_t, clockid_t *);
[CX]
int        clock_getres(clockid_t, struct timespec *);
int        clock_gettime(clockid_t, struct timespec *);
int        clock_nanosleep(clockid_t, int, const struct timespec *,
struct timespec *);
int        clock_settime(clockid_t, const struct timespec *);
[OB]
char      *ctime(const time_t *);
double     difftime(time_t, time_t);
[XSI]
struct tm *getdate(const char *);
struct tm *gmtime(const time_t *);
[CX]
struct tm *gmtime_r(const time_t *restrict, struct tm *restrict);
struct tm *localtime(const time_t *);
[CX]
struct tm *localtime_r(const time_t *restrict, struct tm *restrict);
time_t     mktime(struct tm *);
[CX]
int        nanosleep(const struct timespec *, struct timespec *);
size_t     strftime(char *restrict, size_t, const char *restrict,
const struct tm *restrict);
[CX]
size_t     strftime_l(char *restrict, size_t, const char *restrict,
const struct tm *restrict, locale_t);
[XSI]
char      *strptime(const char *restrict, const char *restrict,
struct tm *restrict);
time_t     time(time_t *);
[CX]
int        timer_create(clockid_t, struct sigevent *restrict,
timer_t *restrict);
int        timer_delete(timer_t);
int        timer_getoverrun(timer_t);
int        timer_gettime(timer_t, struct itimerspec *);
int        timer_settime(timer_t, int, const struct itimerspec *restrict,
struct itimerspec *restrict);
int        timespec_get(struct timespec *, int);
[CX]
void       tzset(void);
The  header shall declare the following as variables:
[XSI]
extern int    daylight;
extern long   timezone;
[CX]
extern char  *tzname[];
[CX]
Inclusion of the  header may make visible all symbols from the  header.
The following sections are informative.
APPLICATION USAGE
The range [0,60] for tm_sec allows for the occasional leap second.
tm_year is a signed value; therefore, years before 1900 may be represented.
To obtain the number of clock ticks per second returned by the times() function,
applications should call sysconf(_SC_CLK_TCK).
RATIONALE
The range [0,60] seconds allows for positive or negative leap seconds. The formal definition of UTC does not permit double leap
seconds, so all mention of double leap seconds has been removed, and the range shortened from the former [0,61] seconds seen in
earlier versions of this standard.
FUTURE DIRECTIONS
None.
SEE ALSO
, , ,
XSH 2.2 The Compilation Environment, asctime(), clock(), clock_getcpuclockid(), clock_getres(), clock_nanosleep(), ctime(),
difftime(), futimens(),
getdate(), gmtime(), localtime(), mktime(), mq_receive(), mq_send(), nanosleep(), pthread_getcpuclockid(), pthread_mutex_clocklock(), pthread_rwlock_clockrdlock(), pthread_rwlock_clockwrlock(), sem_clockwait(), strftime(),
strptime(), sysconf(), time(), timer_create(),
timer_delete(), timer_getoverrun(), timespec_get(), tzset()
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Realtime Extension and the POSIX Threads Extension.
Issue 6
The Open Group Corrigendum U035/6 is applied. In the DESCRIPTION, the types clockid_t and timer_t have been
described.
The following changes are made for alignment with the ISO POSIX-1:1996 standard:
The POSIX timer-related functions are marked as part of the Timers option.
The symbolic name CLK_TCK is removed. Application usage is added describing how its equivalent functionality can be obtained
using sysconf().
The clock_getcpuclockid() function and manifest constants
CLOCK_PROCESS_CPUTIME_ID and CLOCK_THREAD_CPUTIME_ID are added for alignment with IEEE Std 1003.1d-1999.
The manifest constant CLOCK_MONOTONIC and the clock_nanosleep() function
are added for alignment with IEEE Std 1003.1j-2000.
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The range for seconds is changed from [0,61] to [0,60].
The restrict keyword is added to the prototypes for asctime_r(), gmtime_r(), localtime_r(), strftime(), strptime(), timer_create(), and timer_settime().
IEEE PASC Interpretation 1003.1 #84 is applied adding the statement that symbols from the  header may be made visible when the  header is
included.
Extensions beyond the ISO C standard are marked.
Issue 7
Austin Group Interpretation 1003.1-2001 #111 is applied.
SD5-XBD-ERN-74 is applied.
The strftime_l() function is added from The Open Group Technical Standard,
2006, Extended API Set Part 4.
Functionality relating to the Timers option is moved to the Base.
This reference page is clarified with respect to macros and symbolic constants, and declarations for the locale_t and
pid_t types and the sigevent structure are added.
The description of the getdate_err value is expanded.
POSIX.1-2008, Technical Corrigendum 1, XBD/TC1-2008/0076 [212] and XBD/TC1-2008/0077 [212] are applied.
Issue 8
Austin Group Defect 1253 is applied, changing "Daylight Savings" to "Daylight Saving".
Austin Group Defect 1302 is applied, aligning this header with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1346 is applied, requiring support for Monotonic Clock.
Austin Group Defect 1410 is applied, removing the asctime_r() and ctime_r() functions.
Austin Group Defect 1533 is applied, adding tm_gmtoff and tm_zone to the tm structure.
Austin Group Defect 1597 is applied, changing clock() to clock*() in the
descriptions of CLOCK_PROCESS_CPUTIME_ID and CLOCK_THREAD_CPUTIME_ID.
Austin Group Defect 1614 is applied, clarifying the requirements for the tm_isdst member of the tm structure.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/utmpx.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
utmpx.h — user accounting database definitions
SYNOPSIS
[XSI]  #include
DESCRIPTION
The  header shall define the utmpx structure that shall include at least the following members:
char            ut_user[]  User login name.
char            ut_id[]    Unspecified initialization process identifier.
char            ut_line[]  Device name.
pid_t           ut_pid     Process ID.
short           ut_type    Type of entry.
struct timeval  ut_tv      Time entry was made.
The  header shall define the pid_t type through typedef, as described in .
The  header shall define the timeval structure as described in .
Inclusion of the  header may also make visible all symbols from .
The  header shall define the following symbolic constants as possible values for the ut_type member
of the utmpx structure:
EMPTY
No valid user accounting information.
BOOT_TIME
Identifies time of system boot.
OLD_TIME
Identifies time when system clock changed.
NEW_TIME
Identifies time after system clock changed.
USER_PROCESS
Identifies a process.
INIT_PROCESS
Identifies a process spawned by the init process.
LOGIN_PROCESS
Identifies the session leader of a logged-in user.
DEAD_PROCESS
Identifies a session leader who has exited.
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
void          endutxent(void);
struct utmpx *getutxent(void);
struct utmpx *getutxid(const struct utmpx *);
struct utmpx *getutxline(const struct utmpx *);
struct utmpx *pututxline(const struct utmpx *);
void          setutxent(void);
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
,
XSH endutxent()
CHANGE HISTORY
First released in Issue 4, Version 2.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/devctl.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
devctl.h — device control
SYNOPSIS
[DC]  #include
DESCRIPTION
The  header shall define the size_t type as described in .
The following shall be declared as a function and may also be defined as a macro. A function prototype shall be provided.
int posix_devctl(int, int, void *restrict, size_t, int *restrict);
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
,
XSH posix_devctl()
CHANGE HISTORY
First released in Issue 8. Derived from POSIX.26.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/setjmp.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
setjmp.h — stack environment declarations
SYNOPSIS
#include
DESCRIPTION
[CX]  Some of the functionality described on this reference page extends the ISO C standard. Applications shall define
the appropriate feature test macro (see XSH 2.2 The Compilation
Environment) to enable the visibility of these symbols in this header.
The  header shall define the array types jmp_buf and [CX]  sigjmp_buf.
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
_Noreturn void   longjmp(jmp_buf, int);
[CX]
_Noreturn void   siglongjmp(sigjmp_buf, int);
The following may be declared as functions, or defined as macros, or both. If functions are declared, function prototypes shall
be provided.
int    setjmp(jmp_buf);
[CX]
int    sigsetjmp(sigjmp_buf, int);
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XSH 2.2 The Compilation Environment, longjmp(), setjmp(), siglongjmp(), sigsetjmp()
CHANGE HISTORY
First released in Issue 1.
Issue 6
Extensions beyond the ISO C standard are marked.
Issue 7
SD5-XBD-ERN-6 is applied.
Issue 8
Austin Group Defect 1302 is applied, adding _Noreturn to longjmp() and
siglongjmp().
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/sys_utsname.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sys/utsname.h — system name structure
SYNOPSIS
#include
DESCRIPTION
The  header shall define the structure utsname which shall include at least the following
members:
char  sysname[]  Name of this implementation of the operating system.
char  nodename[] Name of this node within the communications
network to which this node is attached, if any.
char  release[]  Current release level of this implementation.
char  version[]  Current version level of this release.
char  machine[]  Name of the hardware type on which the system is running.
The character arrays are of unspecified size, but the data stored in them shall be terminated by a null byte.
The following shall be declared as a function and may also be defined as a macro:
int uname(struct utsname *);
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XSH uname()
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
IEEE Std 1003.1-2001/Cor 2-2004, item XBD/TC2/D6/27 is applied, changing the description of nodename
within the utsname structure from "an implementation-defined communications network" to "the communications network to
which this node is attached, if any".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/mqueue.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mqueue.h — message queues (REALTIME)
SYNOPSIS
[MSG]  #include
DESCRIPTION
The  header shall define the mqd_t type, which is used for message queue descriptors. This is not
an array type.
The  header shall define the size_t and ssize_t types as described in .
The  header shall define the struct timespec structure as described in .
The tag sigevent shall be declared as naming an incomplete structure type, the contents of which are described in the
header.
The  header shall define the mq_attr structure, which is used in getting and setting the
attributes of a message queue. Attributes are initially set when the message queue is created. An mq_attr structure shall
have at least the following fields:
long    mq_flags    Message queue flags.
long    mq_maxmsg   Maximum number of messages.
long    mq_msgsize  Maximum message size.
long    mq_curmsgs  Number of messages currently queued.
The  header shall define O_RDONLY, O_WRONLY, O_RDWR, O_CREAT, O_EXCL, and O_NONBLOCK as described in
.
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
int      mq_close(mqd_t);
int      mq_getattr(mqd_t, struct mq_attr *);
int      mq_notify(mqd_t, const struct sigevent *);
mqd_t    mq_open(const char *, int, ...);
ssize_t  mq_receive(mqd_t, char *, size_t, unsigned *);
int      mq_send(mqd_t, const char *, size_t, unsigned);
int      mq_setattr(mqd_t, const struct mq_attr *restrict,
struct mq_attr *restrict);
ssize_t  mq_timedreceive(mqd_t, char *restrict, size_t,
unsigned *restrict, const struct timespec *restrict);
int      mq_timedsend(mqd_t, const char *, size_t, unsigned,
const struct timespec *);
int      mq_unlink(const char *);
Inclusion of the  header may make visible symbols defined in the headers , , and
.
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
,
, ,
XSH mq_close(), mq_getattr(), mq_notify(), mq_open(), mq_receive(), mq_send(), mq_setattr(), mq_unlink()
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The  header is marked as part of the Message Passing option.
The mq_timedreceive() and mq_timedsend() functions are added for alignment with
IEEE Std 1003.1d-1999.
The restrict keyword is added to the prototypes for mq_setattr() and
mq_timedreceive().
Issue 7
Type and structure declarations are added.
Issue 8
Austin Group Defect 593 is applied, adding O_RDONLY, O_WRONLY, O_RDWR, O_CREAT, O_EXCL, and O_NONBLOCK.
Austin Group Defect 1282 is applied, removing the requirement for  to define pthread_attr_t.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/tgmath.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
tgmath.h — type-generic macros
SYNOPSIS
#include
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The  header shall include the headers  and
and shall define several type-generic macros.
Of the functions contained within the  and  headers without an f (float) or l (long
double) suffix, several have one or more parameters whose corresponding real type is double. For each such function,
except modf(), [XSI]  j0(), j1(), jn(), y0(), y1(), and yn(),   there shall be a
corresponding type-generic macro. The parameters whose corresponding real type is double in the function synopsis are
generic parameters. Use of the macro invokes a function whose corresponding real type and type domain are determined by the
arguments for the generic parameters.
Use of the macro invokes a function whose generic parameters have the corresponding real type determined as follows:
First, if any argument for generic parameters has type long double, the type determined is long double.
Otherwise, if any argument for generic parameters has type double or is of integer type, the type determined is
double.
Otherwise, the type determined is float.
For each unsuffixed function in the  header for which there is a
function in the  header with the same name except for a c
prefix, the corresponding type-generic macro (for both functions) has the same name as the function in the  header. The corresponding type-generic macro for fabs() and cabs() is fabs().
Function
Function
Type-Generic Macro
acos()
cacos()
acos()
asin()
casin()
asin()
atan()
catan()
atan()
acosh()
cacosh()
acosh()
asinh()
casinh()
asinh()
atanh()
catanh()
atanh()
cos()
ccos()
cos()
sin()
csin()
sin()
tan()
ctan()
tan()
cosh()
ccosh()
cosh()
sinh()
csinh()
sinh()
tanh()
ctanh()
tanh()
exp()
cexp()
exp()
log()
clog()
log()
pow()
cpow()
pow()
sqrt()
csqrt()
sqrt()
fabs()
cabs()
fabs()
If at least one argument for a generic parameter is complex, then use of the macro invokes a complex function;
otherwise, use of the macro invokes a real function.
For each unsuffixed function in the  header without a
c-prefixed counterpart in the  header, except for modf(), [XSI]  j0(), j1(), jn(), y0(), y1(), and yn(),   the corresponding
type-generic macro has the same name as the function. These type-generic macros are:
atan2()
cbrt()
ceil()
copysign()
erf()
erfc()
exp2()
expm1()
fdim()
floor()
fma()
fmax()
fmin()
fmod()
frexp()
hypot()
ilogb()
ldexp()
lgamma()
llrint()
llround()
log10()
log1p()
log2()
logb()
lrint()
lround()
nearbyint()
nextafter()
nexttoward()
remainder()
remquo()
rint()
round()
scalbln()
scalbn()
tgamma()
trunc()
If all arguments for generic parameters are real, then use of the macro invokes a real function; otherwise, use of
the macro results in undefined behavior.
For each unsuffixed function in the  header that
is not a c-prefixed counterpart to a function in the  header, the
corresponding type-generic macro has the same name as the function. These type-generic macros are:
carg()
cimag()
conj()
cproj()
creal()
Use of the macro with any real or complex argument invokes a complex function.
[MXC]  Type-generic macros that accept complex arguments shall also accept imaginary arguments. If an argument is imaginary,
the macro shall expand to an expression whose type is real, imaginary, or complex, as appropriate for the particular function: if
the argument is imaginary, then the types of cos(), cosh(), fabs(), carg(), cimag(), and creal() shall be real; the types of sin(), tan(), sinh(), tanh(), asin(), atan(), asinh(), and atanh() shall be imaginary; and the types of the others shall be complex.
Given an imaginary argument, each of the type-generic macros cos(),
sin(), tan(), cosh(), sinh(), tanh(), asin(), atan(), asinh(), and atanh() is specified by a formula in terms of real functions:
cos(iy)
=
cosh(y)
sin(iy)
=
i sinh(y)
tan(iy)
=
i tanh(y)
cosh(iy)
=
cos(y)
sinh(iy)
=
i sin(y)
tanh(iy)
=
i tan(y)
asin(iy)
=
i asinh(y)
atan(iy)
=
i atanh(y)
asinh(iy)
=
i asin(y)
atanh(iy)
=
i atan(y)
The following sections are informative.
APPLICATION USAGE
With the declarations:
#include
int n;
float f;
double d;
long double ld;
float complex fc;
double complex dc;
long double complex ldc;
functions invoked by use of type-generic macros are shown in the following table:
Macro
Use Invokes
exp(n)
exp(n), the function
acosh(f)
acoshf(f)
sin(d)
sin(d), the function
atan(ld)
atanl(ld)
log(fc)
clogf(fc)
sqrt(dc)
csqrt(dc)
pow(ldc,f)
cpowl(ldc, f)
remainder(n,n)
remainder(n, n), the function
nextafter(d,f)
nextafter(d, f), the function
nexttoward(f,ld)
nexttowardf(f, ld)
copysign(n,ld)
copysignl(n, ld)
ceil(fc)
Undefined behavior
rint(dc)
Undefined behavior
fmax(ldc,ld)
Undefined behavior
carg(n)
carg(n), the function
cproj(f)
cprojf(f)
creal(d)
creal(d), the function
cimag(ld)
cimagl(ld)
cabs(fc)
cabsf(fc)
carg(dc)
carg(dc), the function
cproj(ldc)
cprojl(ldc)
RATIONALE
Type-generic macros allow calling a function whose type is determined by the argument type, as is the case for C operators such
as '+' and '*'. For example, with a type-generic cos() macro, the
expression cos((float)x) will have type float. This feature enables writing more portably efficient
code and alleviates need for awkward casting and suffixing in the process of porting or adjusting precision. Generic math functions
are a widely appreciated feature of Fortran.
The only arguments that affect the type resolution are the arguments corresponding to the parameters that have type
double in the synopsis. Hence the type of a type-generic call to nexttoward(), whose second parameter is long double in the synopsis, is determined
solely by the type of the first argument.
The term "type-generic" was chosen over the proposed alternatives of intrinsic and overloading. The term is more
specific than intrinsic, which already is widely used with a more general meaning, and reflects a closer match to Fortran's generic
functions than to C++ overloading.
The macros are placed in their own header in order not to silently break old programs that include the  header; for example, with:
printf ("%e", sin(x))
modf(double, double *) is excluded because no way was seen to make it safe without
complicating the type resolution.
The implementation might, as an extension, endow appropriate ones of the macros that POSIX.1-2024 specifies only
for real arguments with the ability to invoke the complex functions.
POSIX.1-2024 does not prescribe any particular implementation mechanism for generic macros. It could be implemented
simply with built-in macros. The generic macro for sqrt(), for example, could be
implemented with:
#undef sqrt
#define sqrt(x) __BUILTIN_GENERIC_sqrt(x)
Generic macros are designed for a useful level of consistency with C++ overloaded math functions.
The great majority of existing C programs are expected to be unaffected when the  header is
included instead of the  or  headers. Generic macros are similar to the ISO C standard library
masking macros, though the semantic types of return values differ.
The ability to overload on integer as well as floating types would have been useful for some functions; for
example, copysign(). Overloading with different numbers of arguments would have
allowed reusing names; for example, remainder() for remquo(). However, these facilities would have complicated the specification; and their
natural consistent use, such as for a floating abs() or a two-argument atan(), would have introduced further inconsistencies with the ISO/IEC 9899:1999 standard
for insufficient benefit.
The ISO C standard in no way limits the implementation's options for efficiency, including inlining library
functions.
FUTURE DIRECTIONS
None.
SEE ALSO
,
XSH cabs(), fabs(),
modf()
CHANGE HISTORY
First released in Issue 6. Included for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
Austin Group Interpretation 1003.1-2001 #184 is applied, clarifying the functions for which a corresponding type-generic macro
exists with the same name as the function.
POSIX.1-2008, Technical Corrigendum 1, XBD/TC1-2008/0075 [357,427] is applied.
Issue 8
Austin Group Defect 1302 is applied, aligning this header with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/sys_wait.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sys/wait.h — declarations for waiting
SYNOPSIS
#include
DESCRIPTION
The  header shall define the following symbolic constants for use with waitpid():
WCONTINUED
[XSI]
Report status of continued child process.
WNOHANG
Do not hang if no status is available; return immediately.
WUNTRACED
Report status of stopped child process.
The  header shall define the following macros for analysis of process status values:
WCOREDUMP
True if WIFSIGNALED is true and creation of a core image was attempted.
Note:
The use of the word "attempted" here means that the process terminated abnormally with additional actions (see SIG_DFL in XSH
2.4.3 Signal Actions). A core image might or might not have been
produced. Some implementations do not set this bit if a core image was not produced, but this is not a requirement.
WEXITSTATUS
Return exit status.
WIFCONTINUED
[XSI]
True if child has been continued.
WIFEXITED
True if child exited normally.
WIFSIGNALED
True if child exited due to uncaught signal.
WIFSTOPPED
True if child stopped due to uncaught signal.
WSTOPSIG
Return signal number that caused process to stop.
WTERMSIG
Return signal number that caused process to terminate.
The  header shall define the following symbolic constants as possible values for the options
argument to waitid():
WEXITED
Wait for processes that have terminated.
WNOWAIT
Keep the process whose status is returned in infop in a waitable state.
WSTOPPED
Status is returned for any child that has stopped upon receipt of a signal.
The [XSI]   WCONTINUED  and WNOHANG constants, described above for
waitpid(), can also be used with waitid().
The type idtype_t shall be defined as an enumeration type whose possible values shall include at least the following:
P_ALL P_PGID P_PID
The  header shall define the id_t and pid_t types as described in .
The  header shall define the siginfo_t type and the sigval union as described in .
Inclusion of the  header may also make visible all symbols from .
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
pid_t  wait(int *);
int    waitid(idtype_t, id_t, siginfo_t *, int);
pid_t  waitpid(pid_t, int *, int);
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
, ,
XSH wait(), waitid()
CHANGE HISTORY
First released in Issue 3.
Included for alignment with the POSIX.1-1988 standard.
Issue 6
The wait3() function is removed.
Issue 7
The waitid() function and symbolic constants for its options argument are
moved to the Base.
The description of the WNOHANG constant is clarified.
The requirement for  to define the rusage structure as described in  is removed, and  is no longer allowed
to make visible all symbols from .
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0082 [579] and XBD/TC2-2008/0083 [564] are applied.
Issue 8
Austin Group Defect 1141 is applied, adding WCOREDUMP and changing the description of WIFSTOPPED.
Austin Group Defect 1332 is applied, changing the description of WEXITED.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/limits.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
limits.h — implementation-defined constants
SYNOPSIS
#include
DESCRIPTION
[CX]  Some of the functionality described on this reference page extends the ISO C standard. Applications shall define
the appropriate feature test macro (see XSH 2.2 The Compilation
Environment) to enable the visibility of these symbols in this header.
Many of the symbols listed here are not defined by the ISO C standard. Such symbols are not shown as CX shaded, except
under the heading "Numerical Limits".
The  header shall define macros and symbolic constants for various limits. Different categories of limits
are described below, representing various limits on resources that the implementation imposes on applications. All macros and
symbolic constants defined in this header shall be suitable for use in #if preprocessing directives.
Implementations may choose any appropriate value for each limit, provided it is not more restrictive than the Minimum Acceptable
Values listed below. Symbolic constant names beginning with _POSIX may be found in .
Applications should not assume any particular value for a limit. To achieve maximum portability, an application should not
require more resource than the Minimum Acceptable Value quantity. However, an application wishing to avail itself of the full
amount of a resource available on an implementation may make use of the value given in  on that particular
implementation, by using the macros and symbolic constants listed below. It should be noted, however, that many of the listed
limits are not invariant, and at runtime, the value of the limit may differ from those given in this header, for the following
reasons:
The limit is pathname-dependent.
The limit differs between the compile and runtime machines.
The limit has been changed at runtime by an application (see setrlimit()).
For these reasons, an application can use the fpathconf(), getrlimit(), pathconf(), and sysconf() functions to determine the actual value of a limit at runtime.
The items in the list ending in _MIN give the most negative values that the mathematical types are guaranteed to be capable of
representing. Numbers of a more negative value may be supported on some implementations, as indicated by the
header on the implementation, but applications requiring such numbers are not guaranteed to be portable to
all implementations. For positive constants ending in _MIN, this indicates the minimum acceptable value.
Runtime Invariant Values (Possibly Indeterminate)
A definition of one of the symbolic constants in the following list shall be omitted from  on specific
implementations where the corresponding value is equal to or greater than the stated minimum, but is unspecified.
This indetermination might depend on the amount of available memory space on a specific instance of a specific implementation.
The actual value supported by a specific instance shall be provided by the sysconf()
function.
{AIO_LISTIO_MAX}
Maximum number of I/O operations in a single list I/O call supported by the implementation.
Minimum Acceptable Value: {_POSIX_AIO_LISTIO_MAX}
{AIO_MAX}
Maximum number of outstanding asynchronous I/O operations supported by the implementation.
Minimum Acceptable Value: {_POSIX_AIO_MAX}
{AIO_PRIO_DELTA_MAX}
The maximum amount by which a process can decrease its asynchronous I/O priority level from its own scheduling priority.
Minimum Acceptable Value: 0
{ARG_MAX}
Maximum length of argument to the exec functions including environment data.
Minimum Acceptable Value: {_POSIX_ARG_MAX}
{ATEXIT_MAX}
Maximum number of functions that can be registered with atexit() or at_quick_exit(). The limit shall apply independently to each function.
Minimum Acceptable Value: 32
{CHILD_MAX}
Maximum number of simultaneous processes per real user ID.
Minimum Acceptable Value: {_POSIX_CHILD_MAX}
{DELAYTIMER_MAX}
Maximum number of timer expiration overruns.
Minimum Acceptable Value: {_POSIX_DELAYTIMER_MAX}
{HOST_NAME_MAX}
Maximum length of a host name (not including the terminating null) as returned from the gethostname() function.
Minimum Acceptable Value: {_POSIX_HOST_NAME_MAX}
{IOV_MAX}
[XSI]
Maximum number of iovec structures that one process has available for use with readv() or writev().
Minimum Acceptable Value: {_XOPEN_IOV_MAX}
{LOGIN_NAME_MAX}
Maximum length of a login name.
Minimum Acceptable Value: {_POSIX_LOGIN_NAME_MAX}
{MQ_OPEN_MAX}
[MSG]
The maximum number of open message queue descriptors a process may hold.
Minimum Acceptable Value: {_POSIX_MQ_OPEN_MAX}
{MQ_PRIO_MAX}
[MSG]
The maximum number of message priorities supported by the implementation.
Minimum Acceptable Value: {_POSIX_MQ_PRIO_MAX}
{OPEN_MAX}
A value one greater than the maximum value that the system may assign to a newly-created file descriptor.
Minimum Acceptable Value: {_POSIX_OPEN_MAX}
{PAGESIZE}
Size in bytes of a page.
Minimum Acceptable Value: 1
{PAGE_SIZE}
[XSI]
Equivalent to {PAGESIZE}. If either {PAGESIZE} or {PAGE_SIZE} is defined, the other is defined with the same value.
{PTHREAD_DESTRUCTOR_ITERATIONS}
Maximum number of attempts made to destroy a thread's thread-specific data values on thread exit.
Minimum Acceptable Value: {_POSIX_THREAD_DESTRUCTOR_ITERATIONS}
{PTHREAD_KEYS_MAX}
Maximum number of data keys that can be created by a process.
Minimum Acceptable Value: {_POSIX_THREAD_KEYS_MAX}
{PTHREAD_STACK_MIN}
Minimum size in bytes of thread stack storage.
Minimum Acceptable Value: 0
{PTHREAD_THREADS_MAX}
Maximum number of threads that can be created per process.
Minimum Acceptable Value: {_POSIX_THREAD_THREADS_MAX}
{RTSIG_MAX}
Maximum number of realtime signals reserved for application use in this implementation.
Minimum Acceptable Value: {_POSIX_RTSIG_MAX}
{SEM_NSEMS_MAX}
Maximum number of semaphores that a process may have.
Minimum Acceptable Value: {_POSIX_SEM_NSEMS_MAX}
{SEM_VALUE_MAX}
The maximum value a semaphore may have.
Minimum Acceptable Value: {_POSIX_SEM_VALUE_MAX}
{SIGQUEUE_MAX}
Maximum number of queued signals that a process may send and have pending at the receiver(s) at any time.
Minimum Acceptable Value: {_POSIX_SIGQUEUE_MAX}
{SS_REPL_MAX}
[SS|TSP]
The maximum number of replenishment operations that may be simultaneously pending for a particular sporadic server scheduler.
Minimum Acceptable Value: {_POSIX_SS_REPL_MAX}
{STREAM_MAX}
Maximum number of streams that one process can have open at one time. If defined, it has the same value as {FOPEN_MAX} (see
).
Minimum Acceptable Value: {_POSIX_STREAM_MAX}
{SYMLOOP_MAX}
Maximum number of symbolic links that can be reliably traversed in the resolution of a pathname in the absence of a loop.
Minimum Acceptable Value: {_POSIX_SYMLOOP_MAX}
{TIMER_MAX}
Maximum number of timers per process supported by the implementation.
Minimum Acceptable Value: {_POSIX_TIMER_MAX}
{TTY_NAME_MAX}
Maximum length of terminal device name.
Minimum Acceptable Value: {_POSIX_TTY_NAME_MAX}
{TZNAME_MAX}
Maximum number of bytes supported for the name of a timezone (not of the TZ variable).
Minimum Acceptable Value: {_POSIX_TZNAME_MAX}
Note:
The length given by {TZNAME_MAX} does not include the quoting characters mentioned in 8.3 Other Environment Variables.
Pathname Variable Values
The values in the following list may be constants within an implementation or may vary from one pathname to another. For
example, file systems or directories may have different characteristics.
A definition of one of the symbolic constants in the following list shall be omitted from the  header on
specific implementations where the corresponding value is equal to or greater than the stated minimum, but where the value can vary
depending on the file to which it is applied. The actual value supported for a specific pathname shall be provided by the pathconf() function.
{FILESIZEBITS}
Minimum number of bits needed to represent, as a signed integer value, the maximum size of a regular file allowed in the specified
directory.
Minimum Acceptable Value: 32
{LINK_MAX}
Maximum number of links to a single file.
Minimum Acceptable Value: {_POSIX_LINK_MAX}
{MAX_CANON}
Maximum number of bytes in a terminal canonical input line.
Minimum Acceptable Value: {_POSIX_MAX_CANON}
{MAX_INPUT}
Minimum number of bytes for which space is available in a terminal input queue; therefore, the maximum number of bytes a conforming
application may require to be typed as input before reading them.
Minimum Acceptable Value: {_POSIX_MAX_INPUT}
{NAME_MAX}
Maximum number of bytes in a filename (not including the terminating null of a filename string).
Minimum Acceptable Value: {_POSIX_NAME_MAX}
[XSI]
Minimum Acceptable Value: {_XOPEN_NAME_MAX}
{PATH_MAX}
Maximum number of bytes the implementation stores as a pathname in a user-supplied buffer of unspecified size, including the
terminating null character. Minimum number the implementation shall accept as the maximum number of bytes in a pathname.
Minimum Acceptable Value: {_POSIX_PATH_MAX}
[XSI]
Minimum Acceptable Value: {_XOPEN_PATH_MAX}
{PIPE_BUF}
Maximum number of bytes that is guaranteed to be atomic when writing to a pipe.
Minimum Acceptable Value: {_POSIX_PIPE_BUF}
{POSIX_ALLOC_SIZE_MIN}
[ADV]
Minimum number of bytes of storage actually allocated for any portion of a file.
Minimum Acceptable Value: Not specified.
{POSIX_REC_INCR_XFER_SIZE}
[ADV]
Recommended increment for file transfer sizes between the {POSIX_REC_MIN_XFER_SIZE} and {POSIX_REC_MAX_XFER_SIZE} values.
Minimum Acceptable Value: Not specified.
{POSIX_REC_MAX_XFER_SIZE}
[ADV]
Maximum recommended file transfer size.
Minimum Acceptable Value: Not specified.
{POSIX_REC_MIN_XFER_SIZE}
[ADV]
Minimum recommended file transfer size.
Minimum Acceptable Value: Not specified.
{POSIX_REC_XFER_ALIGN}
[ADV]
Recommended file transfer buffer alignment.
Minimum Acceptable Value: Not specified.
{SYMLINK_MAX}
Maximum number of bytes in a symbolic link.
Minimum Acceptable Value: {_POSIX_SYMLINK_MAX}
{TEXTDOMAIN_MAX}
Maximum length of a text domain name, not including the terminating null byte.
Minimum Acceptable Value: {_POSIX_NAME_MAX} - 3
[XSI]
Minimum Acceptable Value: {_XOPEN_NAME_MAX} - 3
Runtime Increasable Values
The magnitude limitations in the following list shall be fixed by specific implementations. An application should assume that
the value of the symbolic constant defined by  in a specific implementation is the minimum that pertains
whenever the application is run under that implementation. A specific instance of a specific implementation may increase the value
relative to that supplied by  for that implementation. The actual value supported by a specific instance
shall be provided by the sysconf() function.
{BC_BASE_MAX}
Maximum obase values allowed by the bc utility.
Minimum Acceptable Value: {_POSIX2_BC_BASE_MAX}
{BC_DIM_MAX}
Maximum number of elements permitted in an array by the bc utility.
Minimum Acceptable Value: {_POSIX2_BC_DIM_MAX}
{BC_SCALE_MAX}
Maximum scale value allowed by the bc utility.
Minimum Acceptable Value: {_POSIX2_BC_SCALE_MAX}
{BC_STRING_MAX}
Maximum length of a string constant accepted by the bc utility.
Minimum Acceptable Value: {_POSIX2_BC_STRING_MAX}
{CHARCLASS_NAME_MAX}
Maximum number of bytes in a character class name.
Minimum Acceptable Value: {_POSIX2_CHARCLASS_NAME_MAX}
{COLL_WEIGHTS_MAX}
Maximum number of weights that can be assigned to an entry of the LC_COLLATE order keyword in the locale definition
file; see 7. Locale.
Minimum Acceptable Value: {_POSIX2_COLL_WEIGHTS_MAX}
{EXPR_NEST_MAX}
Maximum number of expressions that can be nested within parentheses by the expr
utility.
Minimum Acceptable Value: {_POSIX2_EXPR_NEST_MAX}
{LINE_MAX}
Unless otherwise noted, the maximum length, in bytes, of a utility's input line (either standard input or another file), when the
utility is described as processing text files. The length includes room for the trailing .
Minimum Acceptable Value: {_POSIX2_LINE_MAX}
{NGROUPS_MAX}
Maximum number of simultaneous supplementary group IDs per process.
Minimum Acceptable Value: {_POSIX_NGROUPS_MAX}
{RE_DUP_MAX}
Maximum number of repeated occurrences of a BRE or ERE interval expression; see 9.3.6 BREs Matching Multiple Characters and 9.4.6 EREs Matching Multiple Characters.
Minimum Acceptable Value: {_POSIX_RE_DUP_MAX}
Maximum Values
The  header shall define the following symbolic constants with the values shown. These are the most
restrictive values for certain features on an implementation. A conforming implementation shall provide values no larger than these
values. A conforming application shall not require a smaller value for correct operation.
{_POSIX_CLOCKRES_MIN}
The resolution of the CLOCK_REALTIME and CLOCK_MONOTONIC clocks, in nanoseconds.
Value: 20 000 000
Minimum Values
The  header shall define the following symbolic constants with the values shown. These are the most
restrictive values for certain features on an implementation conforming to this volume of POSIX.1-2024. Related symbolic constants
are defined elsewhere in this volume of POSIX.1-2024 which reflect the actual implementation and which need not be as restrictive.
For each of these limits, a conforming implementation shall provide a value at least this large or shall have no limit. A strictly
conforming application shall not require a larger value for correct operation.
{_POSIX_AIO_LISTIO_MAX}
The number of I/O operations that can be specified in a list I/O call.
Value: 2
{_POSIX_AIO_MAX}
The number of outstanding asynchronous I/O operations.
Value: 1
{_POSIX_ARG_MAX}
Maximum length of argument to the exec functions including environment data.
Value: 4 096
{_POSIX_CHILD_MAX}
Maximum number of simultaneous processes per real user ID.
Value: 25
{_POSIX_DELAYTIMER_MAX}
The number of timer expiration overruns.
Value: 32
{_POSIX_HOST_NAME_MAX}
Maximum length of a host name (not including the terminating null) as returned from the gethostname() function.
Value: 255
{_POSIX_LINK_MAX}
Maximum number of links to a single file.
Value: 8
{_POSIX_LOGIN_NAME_MAX}
The size of the storage required for a login name, in bytes (including the terminating null).
Value: 9
{_POSIX_MAX_CANON}
Maximum number of bytes in a terminal canonical input queue.
Value: 255
{_POSIX_MAX_INPUT}
Maximum number of bytes allowed in a terminal input queue.
Value: 255
{_POSIX_MQ_OPEN_MAX}
[MSG]
The number of message queues that can be open for a single process.
Value: 8
{_POSIX_MQ_PRIO_MAX}
[MSG]
The maximum number of message priorities supported by the implementation.
Value: 32
{_POSIX_NAME_MAX}
Maximum number of bytes in a filename (not including the terminating null of a filename string).
Value: 14
{_POSIX_NGROUPS_MAX}
Maximum number of simultaneous supplementary group IDs per process.
Value: 8
{_POSIX_OPEN_MAX}
A value one greater than the maximum value that the system may assign to a newly-created file descriptor.
Value: 20
{_POSIX_PATH_MAX}
Minimum number the implementation shall accept as the maximum number of bytes in a pathname.
Value: 256
{_POSIX_PIPE_BUF}
Maximum number of bytes that is guaranteed to be atomic when writing to a pipe.
Value: 512
{_POSIX_RE_DUP_MAX}
Maximum number of repeated occurrences of a BRE or ERE interval expression; see 9.3.6 BREs Matching Multiple Characters and 9.4.6 EREs Matching Multiple Characters.
Value: 255
{_POSIX_RTSIG_MAX}
The number of realtime signal numbers reserved for application use.
Value: 8
{_POSIX_SEM_NSEMS_MAX}
The number of semaphores that a process may have.
Value: 256
{_POSIX_SEM_VALUE_MAX}
The maximum value a semaphore may have.
Value: 32 767
{_POSIX_SIGQUEUE_MAX}
The number of queued signals that a process may send and have pending at the receiver(s) at any time.
Value: 32
{_POSIX_SSIZE_MAX}
The value that can be stored in an object of type ssize_t.
Value: 32 767
{_POSIX_SS_REPL_MAX}
[SS|TSP]
The number of replenishment operations that may be simultaneously pending for a particular sporadic server scheduler.
Value: 4
{_POSIX_STREAM_MAX}
The number of streams that one process can have open at one time.
Value: 8
{_POSIX_SYMLINK_MAX}
The number of bytes in a symbolic link.
Value: 255
{_POSIX_SYMLOOP_MAX}
The number of symbolic links that can be traversed in the resolution of a pathname in the absence of a loop.
Value: 8
{_POSIX_THREAD_DESTRUCTOR_ITERATIONS}
The number of attempts made to destroy a thread's thread-specific data values on thread exit.
Value: 4
{_POSIX_THREAD_KEYS_MAX}
The number of data keys per process.
Value: 128
{_POSIX_THREAD_THREADS_MAX}
The number of threads per process.
Value: 64
{_POSIX_TIMER_MAX}
The per-process number of timers.
Value: 32
{_POSIX_TTY_NAME_MAX}
The size of the storage required for a terminal device name, in bytes (including the terminating null).
Value: 9
{_POSIX_TZNAME_MAX}
Maximum number of bytes supported for the name of a timezone (not of the TZ variable).
Value: 6
Note:
The length given by {_POSIX_TZNAME_MAX} does not include the quoting characters mentioned in 8.3 Other Environment Variables.
{_POSIX2_BC_BASE_MAX}
Maximum obase values allowed by the bc utility.
Value: 99
{_POSIX2_BC_DIM_MAX}
Maximum number of elements permitted in an array by the bc utility.
Value: 2 048
{_POSIX2_BC_SCALE_MAX}
Maximum scale value allowed by the bc utility.
Value: 99
{_POSIX2_BC_STRING_MAX}
Maximum length of a string constant accepted by the bc utility.
Value: 1 000
{_POSIX2_CHARCLASS_NAME_MAX}
Maximum number of bytes in a character class name.
Value: 14
{_POSIX2_COLL_WEIGHTS_MAX}
Maximum number of weights that can be assigned to an entry of the LC_COLLATE order keyword in the locale definition
file; see 7. Locale.
Value: 2
{_POSIX2_EXPR_NEST_MAX}
Maximum number of expressions that can be nested within parentheses by the expr
utility.
Value: 32
{_POSIX2_LINE_MAX}
Unless otherwise noted, the maximum length, in bytes, of a utility's input line (either standard input or another file), when the
utility is described as processing text files. The length includes room for the trailing .
Value: 2 048
{_POSIX2_RE_DUP_MAX}
Maximum number of repeated occurrences of a BRE or ERE interval expression; see 9.3.6 BREs Matching Multiple Characters and 9.4.6 EREs Matching Multiple Characters.
Value: 255
{_XOPEN_IOV_MAX}
[XSI]
Maximum number of iovec structures that one process has available for use with readv() or writev().
Value: 16
{_XOPEN_NAME_MAX}
[XSI]
Maximum number of bytes in a filename (not including the terminating null of a filename string).
Value: 255
{_XOPEN_PATH_MAX}
[XSI]
Minimum number the implementation shall accept as the maximum number of bytes in a pathname.
Value: 1024
Numerical Limits
The  header shall define the following macros and, except for {CHAR_BIT}, {LONG_BIT}, {MB_LEN_MAX}, and
{WORD_BIT}, they shall be replaced by expressions that have the same type as would an expression that is an object of the
corresponding type converted according to the integer promotions.
If an object of type char can hold negative values, the value of {CHAR_MIN} shall be the same as that of {SCHAR_MIN} and
the value of {CHAR_MAX} shall be the same as that of {SCHAR_MAX}. Otherwise, the value of {CHAR_MIN} shall be 0 and the value of
{CHAR_MAX} shall be the same as that of {UCHAR_MAX}.
{CHAR_BIT}
Number of bits in a type char.
[CX]  Value:
8
{CHAR_MAX}
Maximum value for an object of type char.
Value: {UCHAR_MAX} or {SCHAR_MAX}
{CHAR_MIN}
Minimum value for an object of type char.
Value: {SCHAR_MIN} or 0
{INT_MAX}
Maximum value for an object of type int.
[CX]
Minimum Acceptable Value: 2 147 483 647
{INT_MIN}
Minimum value for an object of type int.
[CX]
Maximum Acceptable Value: -2 147 483 648
{LLONG_MAX}
Maximum value for an object of type long long.
Minimum Acceptable Value: +9223372036854775807
{LLONG_MIN}
Minimum value for an object of type long long.
[CX]
Maximum Acceptable Value: -9223372036854775808
{LONG_BIT}
[CX]
Number of bits in an object of type long.
Minimum Acceptable Value: 32
{LONG_MAX}
Maximum value for an object of type long.
Minimum Acceptable Value: +2 147 483 647
{LONG_MIN}
Minimum value for an object of type long.
[CX]
Maximum Acceptable Value: -2 147 483 648
{MB_LEN_MAX}
Maximum number of bytes in a character, for any supported locale.
Minimum Acceptable Value: 1
{SCHAR_MAX}
Maximum value for an object of type signed char.
[CX]  Value:
+127
{SCHAR_MIN}
Minimum value for an object of type signed char.
[CX]  Value:
-128
{SHRT_MAX}
Maximum value for an object of type short.
Minimum Acceptable Value: +32 767
{SHRT_MIN}
Minimum value for an object of type short.
[CX]
Maximum Acceptable Value: -32 768
{SSIZE_MAX}
[CX]
Maximum value for an object of type ssize_t.
Minimum Acceptable Value: {_POSIX_SSIZE_MAX}
{UCHAR_MAX}
Maximum value for an object of type unsigned char.
[CX]  Value:
255
{UINT_MAX}
Maximum value for an object of type unsigned.
[CX]
Minimum Acceptable Value: 4 294 967 295
{ULLONG_MAX}
Maximum value for an object of type unsigned long long.
Minimum Acceptable Value: 18446744073709551615
{ULONG_MAX}
Maximum value for an object of type unsigned long.
Minimum Acceptable Value: 4 294 967 295
{USHRT_MAX}
Maximum value for an object of type unsigned short.
Minimum Acceptable Value: 65 535
{WORD_BIT}
[CX]
Number of bits in an object of type int.
Minimum Acceptable Value: 32
Other Invariant Values
The  header shall define the following symbolic constants:
{GETENTROPY_MAX}
The maximum value of the length argument in calls to the getentropy()
function.
Minimum Acceptable Value: 256
{NL_ARGMAX}
Maximum value of n in conversion specifications using the "%n$" sequence in calls to the printf() and scanf() families of functions.
Minimum Acceptable Value: 9
{NL_LANGMAX}
[XSI]
Maximum number of bytes in a LANG name.
Minimum Acceptable Value: 14
{NL_MSGMAX}
Maximum message number.
Minimum Acceptable Value: 32 767
{NL_SETMAX}
Maximum set number.
Minimum Acceptable Value: 255
{NL_TEXTMAX}
Maximum number of bytes in a message string.
Minimum Acceptable Value: {_POSIX2_LINE_MAX}
{NSIG_MAX}
Maximum possible return value of sysconf(_SC_NSIG). See XSH sysconf(). The
value of {NSIG_MAX} shall be no greater than the number of signals that the sigset_t type (see ) is capable of representing, ignoring any restrictions imposed by sigfillset() or sigaddset().
{NZERO}
[XSI]
Default process priority.
Minimum Acceptable Value: 20
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
A request was made to reduce the value of {_POSIX_LINK_MAX} from the value of 8 specified for it in the POSIX.1-1990 standard to
2. The standard developers decided to deny this request for several reasons:
They wanted to avoid making any changes to the standard that could break conforming applications, and the requested change could
have that effect.
The use of multiple hard links to a file cannot always be replaced with use of symbolic links. Symbolic links are semantically
different from hard links in that they associate a pathname with another pathname rather than a pathname with a file. This has
implications for access control, file permanence, and transparency.
The original standard developers had considered the issue of allowing for implementations that did not in general support hard
links, and decided that this would reduce consensus on the standard.
Systems that support historical versions of the development option of the ISO POSIX-2 standard retain the name
{_POSIX2_RE_DUP_MAX} as an alias for {_POSIX_RE_DUP_MAX}.
{NSIG_MAX}
Some historical implementations provided compile-time constants NSIG or SIGMAX to define the maximum number of signals the
implementation supported, but these values did not necessarily reflect the number of signals that could be handled using a
sigset_t. With the addition of real-time signals and the desire by some applications to be able to allocate additional
real-time signals at run-time, neither of these constants provided a useable, portable value. {NSIG_MAX} was added to the standard
to allow applications to determine the maximum number of signals that an implementation will support based on the size of the
sigset_t type (defined in ).
{PATH_MAX}
IEEE PASC Interpretation 1003.1 #15 addressed the inconsistency in the standard with the definition of pathname and the description
of {PATH_MAX}, allowing application developers to allocate either {PATH_MAX} or {PATH_MAX}+1 bytes. The inconsistency has been
removed by correction to the {PATH_MAX} definition to include the null character. With this change, applications that previously
allocated {PATH_MAX} bytes will continue to succeed.
{SYMLINK_MAX}
This symbol refers to space for data that is stored in the file system, as opposed to {PATH_MAX} which is the length of a name that
can be passed to a function. In some existing implementations, the pathnames pointed to by symbolic links are stored in the
inodes of the links, so it is important that {SYMLINK_MAX} not be constrained to be as large as {PATH_MAX}.
The maximum values for {SCHAR_MIN}, {SHRT_MIN}, {LONG_MIN} and {LLONG_MIN} differ from the ISO C standard because POSIX.1
requires two's complement representation for the corresponding integer types. The maximum value for {INT_MIN} differs both for that
reason and because POSIX.1 requires that int has a width of at least 32 bits. See also the RATIONALE section for .
FUTURE DIRECTIONS
None.
SEE ALSO
7. Locale, , ,
XSH 2.2 The Compilation Environment, fpathconf(), getrlimit(), sysconf()
CHANGE HISTORY
First released in Issue 1.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Realtime Extension and the POSIX Threads Extension.
{FILESIZEBITS} is added for the Large File Summit extensions.
The minimum acceptable values for {INT_MAX}, {INT_MIN}, and {UINT_MAX} are changed to make 32-bit values the minimum
requirement.
The entry is restructured to improve readability.
Issue 6
The Open Group Corrigendum U033/4 is applied. The wording is made clear for {CHAR_MIN}, {INT_MIN}, {LONG_MIN}, {SCHAR_MIN}, and
{SHRT_MIN} that these are maximum acceptable values.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The minimum value for {CHILD_MAX} is 25. This is a FIPS requirement.
The minimum value for {OPEN_MAX} is 20. This is a FIPS requirement.
The minimum value for {NGROUPS_MAX} is 8. This is also a FIPS requirement.
Symbolic constants are added for {_POSIX_SYMLINK_MAX}, {_POSIX_SYMLOOP_MAX}, {_POSIX_RE_DUP_MAX}, {RE_DUP_MAX}, {SYMLOOP_MAX},
and {SYMLINK_MAX}.
The following values are added for alignment with IEEE Std 1003.1d-1999: {_POSIX_SS_REPL_MAX} {SS_REPL_MAX}
{POSIX_ALLOC_SIZE_MIN} {POSIX_REC_INCR_XFER_SIZE} {POSIX_REC_MAX_XFER_SIZE} {POSIX_REC_MIN_XFER_SIZE} {POSIX_REC_XFER_ALIGN}
Reference to CLOCK_MONOTONIC is added in the description of {_POSIX_CLOCKRES_MIN} for alignment with
IEEE Std 1003.1j-2000.
The constants {LLONG_MIN}, {LLONG_MAX}, and {ULLONG_MAX} are added for alignment with the ISO/IEC 9899:1999 standard.
The following values are added for alignment with IEEE Std 1003.1q-2000: {_POSIX_TRACE_EVENT_NAME_MAX}
{_POSIX_TRACE_NAME_MAX} {_POSIX_TRACE_SYS_MAX} {_POSIX_TRACE_USER_EVENT_MAX} {TRACE_EVENT_NAME_MAX} {TRACE_NAME_MAX}
{TRACE_SYS_MAX} {TRACE_USER_EVENT_MAX}
The new limits {_XOPEN_NAME_MAX} and {_XOPEN_PATH_MAX} are added as minimum values for {PATH_MAX} and {NAME_MAX} limits on
XSI-conformant systems.
The LEGACY symbols {PASS_MAX} and {TMP_MAX} are removed.
The values for the limits {CHAR_BIT}, {SCHAR_MAX}, and {UCHAR_MAX} are now required to be 8, +127, and 255, respectively.
The value for the limit {CHAR_MAX} is now {UCHAR_MAX} or {SCHAR_MAX}.
The value for the limit {CHAR_MIN} is now {SCHAR_MIN} or zero.
IEEE Std 1003.1-2001/Cor 1-2002, item XBD/TC1/D6/10 is applied, correcting the value of {_POSIX_CHILD_MAX} from 6
to 25. This is for FIPS 151-2 alignment.
IEEE Std 1003.1-2001/Cor 2-2004, item XBD/TC2/D6/19 is applied, updating the values for {INT_MAX}, {UINT_MAX},
and {INT_MIN} to be CX extensions over the ISO C standard, and correcting {WORD_BIT} from 16 to 32.
IEEE Std 1003.1-2001/Cor 2-2004, item XBD/TC2/D6/20 is applied, removing {CHARCLASS_NAME_MAX} from the "Other
Invariant Values" section (it also occurs under "Runtime Increasable Values").
Issue 7
Austin Group Interpretations 1003.1-2001 #143 and #160 are applied.
Austin Group Interpretation 1003.1-2001 #173 is applied, updating the descriptions of {TRACE_EVENT_NAME_MAX} and
{TRACE_NAME_MAX} to not include the terminating null.
SD5-XBD-ERN-36 is applied, changing the description of {RE_DUP_MAX}.
SD5-XBD-ERN-90 is applied.
{NL_NMAX} is removed; it should have been removed in Issue 6.
The Trace option values are marked obsolescent.
The {ATEXIT_MAX}, {LONG_BIT}, {NL_MSGMAX}, {NL_SETMAX}, {NL_TEXTMAX}, and {WORD_BIT} values are moved from the XSI option to the
Base.
The AIO_* and _POSIX_AIO_* values are moved from the Asynchronous Input and Output option to the Base.
The {_POSIX_RTSIG_MAX}, {_POSIX_SIGQUEUE_MAX}, {RTSIG_MAX}, and {SIGQUEUE_MAX} values are moved from the Realtime Signals
Extension option to the Base.
Functionality relating to the Threads and Timers options is moved to the Base.
This reference page is clarified with respect to macros and symbolic constants.
POSIX.1-2008, Technical Corrigendum 1, XBD/TC1-2008/0052 [108], XBD/TC1-2008/0053 [291], XBD/TC1-2008/0054 [182,427],
XBD/TC1-2008/0055 [291], XBD/TC1-2008/0056 [371], XBD/TC1-2008/0057 [291], XBD/TC1-2008/0058 [108], and XBD/TC1-2008/0059 [291] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0061 [666] is applied.
Issue 8
Austin Group Defect 741 is applied, adding {NSIG_MAX}.
Austin Group Defect 1108 is applied, changing the maximum allowed value for all signed integer minimum limits.
Austin Group Defect 1122 is applied, adding {TEXTDOMAIN_MAX}.
Austin Group Defect 1134 is applied, adding {GETENTROPY_MAX}.
Austin Group Defect 1302 is applied, aligning this header with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
Austin Group Defect 1346 is applied, requiring support for Monotonic Clock.
Austin Group Defect 1446 is applied, changing the introductory paragraphs of the DESCRIPTION to include mention of setrlimit() and getrlimit().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/stdnoreturn.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
stdnoreturn.h — noreturn macro
SYNOPSIS
#include
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The  header shall define the macro noreturn which shall expand to _Noreturn.
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
None.
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/sys_resource.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sys/resource.h — definitions for resource operations
SYNOPSIS
#include
DESCRIPTION
[XSI]
The  header shall define the following symbolic constants as possible values of the which
argument of getpriority() and setpriority():
PRIO_PROCESS
Identifies the who argument as a process ID.
PRIO_PGRP
Identifies the who argument as a process group ID.
PRIO_USER
Identifies the who argument as a user ID.
The  header shall define the following type through typedef:
rlim_t
Unsigned integer type used for limit values.
The  header shall define the following symbolic constants, which shall have values suitable for use
in #if preprocessing directives:
RLIM_INFINITY
A value of rlim_t indicating no limit.
RLIM_SAVED_MAX
A value of type rlim_t indicating an unrepresentable saved hard limit.
RLIM_SAVED_CUR
A value of type rlim_t indicating an unrepresentable saved soft limit.
On implementations where all resource limits are representable in an object of type rlim_t, RLIM_SAVED_MAX and
RLIM_SAVED_CUR need not be distinct from RLIM_INFINITY.
[XSI]
The  header shall define the following symbolic constants as possible values of the who
parameter of getrusage():
RUSAGE_SELF
Returns information about the current process.
RUSAGE_CHILDREN
Returns information about children of the current process.
The  header shall define the rlimit structure, which shall include at least the following
members:
rlim_t rlim_cur  The current (soft) limit.
rlim_t rlim_max  The hard limit.
[XSI]
The  header shall define the rusage structure, which shall include at least the following
members:
struct timeval ru_utime  User time used.
struct timeval ru_stime  System time used.
The  header shall define the timeval structure as described in .
The  header shall define the following symbolic constants as possible values for the
resource argument of getrlimit() and setrlimit():
RLIMIT_CORE
Limit on size of core image.
RLIMIT_CPU
[XSI]
Limit on CPU time per process.
RLIMIT_DATA
Limit on data segment size.
RLIMIT_FSIZE
Limit on file size.
RLIMIT_NOFILE
Limit on number of open files.
RLIMIT_STACK
Limit on stack size.
RLIMIT_AS
Limit on address space size.
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
[XSI]
int  getpriority(int, id_t);
int  getrlimit(int, struct rlimit *);
[XSI]
int  getrusage(int, struct rusage *);
int  setpriority(int, id_t, int);
int  setrlimit(int, const struct rlimit *);
[XSI]
The  header shall define the id_t type through typedef, as described in .
Inclusion of the  header may also make visible all symbols from .
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
,
XSH getpriority(), getrlimit(), getrusage()
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Large File System extensions are added.
Issue 7
This reference page is clarified with respect to macros and symbolic constants.
Issue 8
Austin Group Defects 51 and 1669 are applied, moving the getrlimit() and
setrlimit() functions, excluding the RLIMIT_CPU limit, from the XSI option to the
Base.
Austin Group Defect 1141 is applied, changing the description of RLIMIT_CORE.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/strings.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strings.h — string operations
SYNOPSIS
#include
DESCRIPTION
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided for use
with ISO C standard compilers.
[XSI]
int    ffs(int);
int    ffsl(long);
int    ffsll(long long);
int    strcasecmp(const char *, const char *);
int    strcasecmp_l(const char *, const char *, locale_t);
int    strncasecmp(const char *, const char *, size_t);
int    strncasecmp_l(const char *, const char *, size_t, locale_t);
The  header shall define the locale_t type as described in .
The  header shall define the size_t type as described in .
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
,
XSH ffs(), strcasecmp()
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 6
The Open Group Corrigendum U021/2 is applied, correcting the prototype for index() to be consistent with the reference
page.
The bcmp(), bcopy(), bzero(), index(), and rindex() functions are marked LEGACY.
Issue 7
SD5-XBD-ERN-56 is applied, adding a reference to  for the
size_t type.
The LEGACY functions are removed.
The  header is moved from the XSI option to the Base.
The strcasecmp_l() and strncasecmp_l() functions are added from The Open Group Technical Standard, 2006,
Extended API Set Part 4.
A declaration for the locale_t type is added.
Issue 8
Austin Group Defect 617 is applied, adding ffsl() and ffsll().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/termios.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
termios.h — define values for termios
SYNOPSIS
#include
DESCRIPTION
The  header shall contain the definitions used by the terminal I/O interfaces (see 11. General Terminal Interface for the structures and names defined).
The termios Structure
The  header shall define the following data types through typedef:
cc_t
Used for terminal special characters.
speed_t
Used for terminal baud rates.
tcflag_t
Used for terminal modes.
The above types shall be all unsigned integer types.
The implementation shall support one or more programming environments in which the widths of cc_t, speed_t, and
tcflag_t are no greater than the width of type long. The names of these programming environments can be obtained
using the confstr() function or the getconf utility.
The  header shall define the termios structure, which shall include at least the following
members:
tcflag_t  c_iflag     Input modes.
tcflag_t  c_oflag     Output modes.
tcflag_t  c_cflag     Control modes.
tcflag_t  c_lflag     Local modes.
cc_t      c_cc[NCCS]  Control characters.
The  header shall define the following symbolic constant:
NCCS
Size of the array c_cc for control characters.
The  header shall define the following symbolic constants for use as subscripts for the array
c_cc:
Subscript Usage
Canonical Mode
Non-Canonical Mode
Description
VEOF
EOF character.
VEOL
EOL character.
VERASE
ERASE character.
VINTR
VINTR
INTR character.
VKILL
KILL character.
VMIN
MIN value.
VQUIT
VQUIT
QUIT character.
VSTART
VSTART
START character.
VSTOP
VSTOP
STOP character.
VSUSP
VSUSP
SUSP character.
VTIME
TIME value.
The subscript values shall be suitable for use in #if preprocessing directives and shall be distinct, except
that the VMIN and VTIME subscripts may have the same values as the VEOF and VEOL subscripts, respectively.
Input Modes
The  header shall define the following symbolic constants for use as flags in the
c_iflag field. The c_iflag field describes the basic terminal input control.
BRKINT
Signal interrupt on break.
ICRNL
Map CR to NL on input.
IGNBRK
Ignore break condition.
IGNCR
Ignore CR.
IGNPAR
Ignore characters with parity errors.
INLCR
Map NL to CR on input.
INPCK
Enable input parity check.
ISTRIP
Strip character.
IXANY
Enable any character to restart output.
IXOFF
Enable start/stop input control.
IXON
Enable start/stop output control.
PARMRK
Mark parity errors.
Output Modes
The  header shall define the following symbolic constants for use as flags in the
c_oflag field. The c_oflag field specifies the system treatment of output.
OPOST
Post-process output.
ONLCR
[XSI]
Map NL to CR-NL on output.
OCRNL
[XSI]
Map CR to NL on output.
ONOCR
[XSI]
No CR output at column 0.
ONLRET
[XSI]
NL performs CR function.
OFDEL
[XSI]
Fill is DEL.
OFILL
[XSI]
Use fill characters for delay.
NLDLY
[XSI]
Select newline delays:
NL0
Newline type 0.
NL1
Newline type 1.
CRDLY
[XSI]
Select carriage-return delays:
CR0
Carriage-return delay type 0.
CR1
Carriage-return delay type 1.
CR2
Carriage-return delay type 2.
CR3
Carriage-return delay type 3.
TABDLY
[XSI]
Select horizontal-tab delays:
TAB0
Horizontal-tab delay type 0.
TAB1
Horizontal-tab delay type 1.
TAB2
Horizontal-tab delay type 2.
TAB3
Expand tabs to spaces.
BSDLY
[XSI]
Select backspace delays:
BS0
Backspace-delay type 0.
BS1
Backspace-delay type 1.
VTDLY
[XSI]
Select vertical-tab delays:
VT0
Vertical-tab delay type 0.
VT1
Vertical-tab delay type 1.
FFDLY
[XSI]
Select form-feed delays:
FF0
Form-feed delay type 0.
FF1
Form-feed delay type 1.
Baud Rate Selection
The  header shall define the following symbolic constants for use as values of objects of
type speed_t.
The input and output baud rates are stored in the termios structure. These are the valid values for objects
of type speed_t. Not all baud rates need be supported by the underlying hardware.
B0
Hang up
B50
50 baud
B75
75 baud
B110
110 baud
B134
134.5 baud
B150
150 baud
B200
200 baud
B300
300 baud
B600
600 baud
B1200
1200 baud
B1800
1800 baud
B2400
2400 baud
B4800
4800 baud
B9600
9600 baud
B19200
19200 baud
B38400
38400 baud
Control Modes
The  header shall define the following symbolic constants for use as flags in the
c_cflag field. The c_cflag field describes the hardware control of the terminal; not all values specified are
required to be supported by the underlying hardware.
CSIZE
Character size:
CS5
5 bits
CS6
6 bits
CS7
7 bits
CS8
8 bits
CSTOPB
Send two stop bits, else one.
CREAD
Enable receiver.
PARENB
Parity enable.
PARODD
Odd parity, else even.
HUPCL
Hang up on last close.
CLOCAL
Ignore modem status lines.
The implementation shall support the functionality associated with the symbols CS7, CS8, CSTOPB, PARODD, and
PARENB.
Local Modes
The  header shall define the following symbolic constants for use as flags in the
c_lflag field. The c_lflag field of the argument structure is used to control various terminal functions.
ECHO
Enable echo.
ECHOE
Echo erase character as error-correcting backspace.
ECHOK
Echo KILL.
ECHONL
Echo NL.
ICANON
Canonical input (erase and kill processing).
IEXTEN
Enable extended input character processing.
ISIG
Enable signals.
NOFLSH
Disable flush after interrupt or quit.
TOSTOP
Send SIGTTOU for background output.
The winsize Structure
The  header shall define the winsize structure, which shall include at least the
following members:
unsigned short ws_row      Rows, in characters.
unsigned short ws_col      Columns, in characters.
Attribute Selection
The  header shall define the following symbolic constants for use with tcsetattr():
TCSANOW
Change attributes immediately.
TCSADRAIN
Change attributes when output has drained.
TCSAFLUSH
Change attributes when output has drained; also flush pending input.
Line Control
The  header shall define the following symbolic constants for use with tcflush():
TCIFLUSH
Flush pending input.
TCIOFLUSH
Flush both pending input and untransmitted output.
TCOFLUSH
Flush untransmitted output.
The  header shall define the following symbolic constants for use with tcflow():
TCIOFF
Transmit a STOP character, intended to suspend input data.
TCION
Transmit a START character, intended to restart input data.
TCOOFF
Suspend output.
TCOON
Restart output.
The  header shall define the pid_t type as described in .
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be
provided.
speed_t cfgetispeed(const struct termios *);
speed_t cfgetospeed(const struct termios *);
int     cfsetispeed(struct termios *, speed_t);
int     cfsetospeed(struct termios *, speed_t);
int     tcdrain(int);
int     tcflow(int, int);
int     tcflush(int, int);
int     tcgetattr(int, struct termios *);
pid_t   tcgetsid(int);
int     tcgetwinsize(int, struct winsize *);
int     tcsendbreak(int, int);
int     tcsetattr(int, int, const struct termios *);
int     tcsetwinsize(int, const struct winsize *);
The following sections are informative.
APPLICATION USAGE
The following names are reserved for XSI-conformant systems to use as an extension to the above; therefore strictly conforming
applications shall not use them:
CBAUD
EXTB
VDSUSP
DEFECHO
FLUSHO
VLNEXT
ECHOCTL
LOBLK
VREPRINT
ECHOKE
PENDIN
VSTATUS
ECHOPRT
SWTCH
VWERASE
EXTA
VDISCARD
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XSH cfgetispeed(), cfgetospeed(), cfsetispeed(),
cfsetospeed(), confstr(),
tcdrain(), tcflow(), tcflush(), tcgetattr(), tcgetsid(), tcgetwinsize(),
tcsendbreak(), tcsetattr(),
tcsetwinsize()
XCU 11. General Terminal Interface, getconf
CHANGE HISTORY
First released in Issue 3.
Included for alignment with the ISO POSIX-1 standard.
Issue 6
The LEGACY symbols IUCLC, OLCUC, and XCASE are removed.
FIPS 151-2 requirements for the symbols CS7, CS8, CSTOPB, PARODD, and PARENB are reaffirmed.
IEEE Std 1003.1-2001/Cor 1-2002, item XBD/TC1/D6/19 is applied, changing ECHOK to ECHOKE in the
APPLICATION USAGE section.
Issue 7
Austin Group Interpretation 1003.1-2001 #144 is applied, moving functionality relating to the IXANY symbol from the XSI option
to the Base.
SD5-XBD-ERN-35 is applied, adding the OFDEL output mode.
This reference page is clarified with respect to macros and symbolic constants, and a declaration for the
pid_t type is added.
Issue 8
Austin Group Defects 1151 and 1484 are applied, adding the winsize structure and the tcgetwinsize() and tcsetwinsize()
functions.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/errno.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
errno.h — system error numbers
SYNOPSIS
#include
DESCRIPTION
[CX]  Some of the functionality described on this reference page extends the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The ISO C standard only requires the symbols [EDOM], [EILSEQ], and [ERANGE] to be defined.
The  header shall provide a definition for the macro errno, which shall expand to a modifiable
lvalue of type int and thread local storage duration. If the macro definition is suppressed in order to access an actual
object, or a program defines an identifier with the name errno, the behavior is undefined.
The  header shall define the following macros which shall expand to integer constant expressions with type
int, distinct positive values (except as noted below), and which shall be suitable for use in #if preprocessing
directives:
[E2BIG]
Argument list too long.
[EACCES]
Permission denied.
[EADDRINUSE]
Address in use.
[EADDRNOTAVAIL]
Address not available.
[EAFNOSUPPORT]
Address family not supported.
[EAGAIN]
Resource unavailable, try again (may be the same value as [EWOULDBLOCK]).
[EALREADY]
Connection already in progress.
[EBADF]
Bad file descriptor.
[EBADMSG]
Bad message.
[EBUSY]
Device or resource busy.
[ECANCELED]
Operation canceled.
[ECHILD]
No child processes.
[ECONNABORTED]
Connection aborted.
[ECONNREFUSED]
Connection refused.
[ECONNRESET]
Connection reset.
[EDEADLK]
Resource deadlock would occur.
[EDESTADDRREQ]
Destination address required.
[EDOM]
Mathematics argument out of domain of function.
[EDQUOT]
Reserved.
[EEXIST]
File exists.
[EFAULT]
Bad address.
[EFBIG]
File too large.
[EHOSTUNREACH]
Host is unreachable.
[EIDRM]
Identifier removed.
[EILSEQ]
Illegal byte sequence.
[EINPROGRESS]
Operation in progress.
[EINTR]
Interrupted function.
[EINVAL]
Invalid argument.
[EIO]
I/O error.
[EISCONN]
Socket is connected.
[EISDIR]
Is a directory.
[ELOOP]
Too many levels of symbolic links.
[EMFILE]
File descriptor value too large.
[EMLINK]
Too many hard links.
[EMSGSIZE]
Message too large.
[EMULTIHOP]
Reserved.
[ENAMETOOLONG]
Filename too long.
[ENETDOWN]
Network is down.
[ENETRESET]
Connection aborted by network.
[ENETUNREACH]
Network unreachable.
[ENFILE]
Too many files open in system.
[ENOBUFS]
No buffer space available.
[ENODEV]
No such device.
[ENOENT]
No such file or directory.
[ENOEXEC]
Executable file format error.
[ENOLCK]
No locks available.
[ENOLINK]
Reserved.
[ENOMEM]
Not enough space.
[ENOMSG]
No message of the desired type.
[ENOPROTOOPT]
Protocol not available.
[ENOSPC]
No space left on device.
[ENOSYS]
Functionality not supported.
[ENOTCONN]
The socket is not connected.
[ENOTDIR]
Not a directory or a symbolic link to a directory.
[ENOTEMPTY]
Directory not empty.
[ENOTRECOVERABLE]
State not recoverable.
[ENOTSOCK]
Not a socket.
[ENOTSUP]
Not supported (may be the same value as [EOPNOTSUPP]).
[ENOTTY]
Inappropriate I/O control operation.
[ENXIO]
No such device or address.
[EOPNOTSUPP]
Operation not supported on socket (may be the same value as [ENOTSUP]).
[EOVERFLOW]
Value too large to be stored in data type.
[EOWNERDEAD]
[EPERM]
Operation not permitted.
[EPIPE]
Broken pipe.
[EPROTO]
Protocol error.
[EPROTONOSUPPORT]
Protocol not supported.
[EPROTOTYPE]
Protocol wrong type for socket.
[ERANGE]
Result too large.
[EROFS]
Read-only file system.
[ESOCKTNOSUPPORT]
Socket type not supported.
[ESPIPE]
Invalid seek.
[ESRCH]
No such process.
[ESTALE]
Reserved.
[ETIMEDOUT]
Connection timed out.
[ETXTBSY]
Text file busy.
[EWOULDBLOCK]
Operation would block (may be the same value as [EAGAIN]).
[EXDEV]
Improper hard link.
The following sections are informative.
APPLICATION USAGE
Additional error numbers may be defined on conforming systems; see the System Interfaces volume of POSIX.1-2024.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XSH 2.3 Error Numbers
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
Updated for alignment with the POSIX Realtime Extension.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The majority of the error conditions previously marked as extensions are now mandatory, except for the STREAMS-related error
conditions.
Values for errno are now required to be distinct positive values rather than non-zero values. This change is for
alignment with the ISO/IEC 9899:1999 standard.
Issue 7
Austin Group Interpretation 1003.1-2001 #050 is applied, allowing [ENOTSUP] and [EOPNOTSUPP] to be the same values.
The [ENOTRECOVERABLE] and [EOWNERDEAD] errors are added from The Open Group Technical Standard, 2006, Extended API Set Part
2.
Functionality relating to the XSI STREAMS option is marked obsolescent.
Functionality relating to the Threads option is moved to the Base.
This reference page is clarified with respect to macros and symbolic constants.
POSIX.1-2008, Technical Corrigendum 1, XBD/TC1-2008/0043 [324] is applied.
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0059 [496] is applied.
Issue 8
Austin Group Defect 1067 is applied, adding [ESOCKTNOSUPPORT].
Austin Group Defect 1302 is applied, aligning this header with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
Austin Group Defect 1380 is applied, changing the descriptions of [EMLINK] and [EXDEV].
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/ndbm.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ndbm.h — definitions for ndbm database operations
SYNOPSIS
[XSI]  #include
DESCRIPTION
The  header shall define the datum type as a structure, which shall include at least the following
members:
void   *dptr  A pointer to the application's data.
size_t  dsize The size of the object pointed to by dptr.
The  header shall define the size_t type as described in .
The  header shall define the DBM type.
The  header shall define the following symbolic constants as possible values for the store_mode
argument to dbm_store():
DBM_INSERT
Insertion of new entries only.
DBM_REPLACE
Allow replacing existing entries.
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
int     dbm_clearerr(DBM *);
void    dbm_close(DBM *);
int     dbm_delete(DBM *, datum);
int     dbm_error(DBM *);
datum   dbm_fetch(DBM *, datum);
datum   dbm_firstkey(DBM *);
datum   dbm_nextkey(DBM *);
DBM    *dbm_open(const char *, int, mode_t);
int     dbm_store(DBM *, datum, datum, int);
The  header shall define the mode_t type through typedef, as described in .
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
,
XSH dbm_clearerr()
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
References to the definitions of size_t and mode_t are added to the DESCRIPTION.
Issue 7
This reference page is clarified with respect to macros and symbolic constants.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/tar.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
tar.h — extended tar definitions
SYNOPSIS
#include
DESCRIPTION
The  header shall define the following symbolic constants with the indicated values.
General definitions:
Name
Value
Description
TMAGIC
"ustar"
Used in the magic field in the ustar header block, including the trailing null byte.
TMAGLEN
6
Length in octets of the magic field.
TVERSION
"00"
Used in the version field in the ustar header block, excluding the trailing null byte.
TVERSLEN
2
Length in octets of the version field.
Typeflag field definitions:
Name
Value
Description
REGTYPE
'0'
Regular file.
AREGTYPE
'\0'
Regular file.
LNKTYPE
'1'
Hard Link.
SYMTYPE
'2'
Symbolic link.
CHRTYPE
'3'
Character special.
BLKTYPE
'4'
Block special.
DIRTYPE
'5'
Directory.
FIFOTYPE
'6'
FIFO special.
CONTTYPE
'7'
Reserved.
Mode field bit definitions (octal):
Name
Value
Description
TSUID
04000
Set UID on execution.
TSGID
02000
Set GID on execution.
TSVTX
01000
[XSI]  On directories, restricted deletion flag.
TUREAD
00400
Read by owner.
TUWRITE
00200
Write by owner special.
TUEXEC
00100
Execute/search by owner.
TGREAD
00040
Read by group.
TGWRITE
00020
Write by group.
TGEXEC
00010
Execute/search by group.
TOREAD
00004
Read by other.
TOWRITE
00002
Write by other.
TOEXEC
00001
Execute/search by other.
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XCU pax
CHANGE HISTORY
First released in Issue 3. Derived from the POSIX.1-1988 standard.
Issue 6
The SEE ALSO section is updated to refer to pax.
Issue 7
This reference page is clarified with respect to macros and symbolic constants.
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0084 [707] is applied.
Issue 8
Austin Group Defect 1380 is applied, changing the description of LNKTYPE.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/assert.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
assert.h — verify program assertion
SYNOPSIS
#include
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The  header shall define the assert() macro. It refers to
the macro NDEBUG which is not defined in the header. If NDEBUG is defined as a macro name before the inclusion of this header, the
assert() macro shall be defined simply as:
#define assert(ignore)((void) 0)
Otherwise, the macro behaves as described in assert().
The assert() macro shall be redefined according to the current state of NDEBUG
each time  is included.
The assert() macro shall be implemented as a macro, not as a function. If the
macro definition is suppressed in order to access an actual function, the behavior is undefined.
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XSH assert()
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The definition of the assert() macro is changed for alignment with the
ISO/IEC 9899:1999 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/string.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
string.h — string operations
SYNOPSIS
#include
DESCRIPTION
[CX]  Some of the functionality described on this reference page extends the ISO C standard. Applications shall define
the appropriate feature test macro (see XSH 2.2 The Compilation
Environment) to enable the visibility of these symbols in this header.
The  header shall define NULL and size_t as described in .
[CX]  The
header shall define the locale_t type as described in .
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided for use
with ISO C standard compilers.
[XSI]
void    *memccpy(void *restrict, const void *restrict, int, size_t);
void    *memchr(const void *, int, size_t);
int      memcmp(const void *, const void *, size_t);
void    *memcpy(void *restrict, const void *restrict, size_t);
[CX]
void    *memmem(const void *, size_t, const void *, size_t);
void    *memmove(void *, const void *, size_t);
void    *memset(void *, int, size_t);
[CX]
char    *stpcpy(char *restrict, const char *restrict);
char    *stpncpy(char *restrict, const char *restrict, size_t);
char    *strcat(char *restrict, const char *restrict);
char    *strchr(const char *, int);
int      strcmp(const char *, const char *);
int      strcoll(const char *, const char *);
[CX]
int      strcoll_l(const char *, const char *, locale_t);
char    *strcpy(char *restrict, const char *restrict);
size_t   strcspn(const char *, const char *);
[CX]
char    *strdup(const char *);
char    *strerror(int);
[CX]
char    *strerror_l(int, locale_t);
int      strerror_r(int, char *, size_t);
size_t   strlcat(char *restrict, const char *restrict, size_t);
size_t   strlcpy(char *restrict, const char *restrict, size_t);
size_t   strlen(const char *);
char    *strncat(char *restrict, const char *restrict, size_t);
int      strncmp(const char *, const char *, size_t);
char    *strncpy(char *restrict, const char *restrict, size_t);
[CX]
char    *strndup(const char *, size_t);
size_t   strnlen(const char *, size_t);
char    *strpbrk(const char *, const char *);
char    *strrchr(const char *, int);
[CX]
char    *strsignal(int);
size_t   strspn(const char *, const char *);
char    *strstr(const char *, const char *);
char    *strtok(char *restrict, const char *restrict);
[CX]
char    *strtok_r(char *restrict, const char *restrict, char **restrict);
size_t   strxfrm(char *restrict, const char *restrict, size_t);
[CX]
size_t   strxfrm_l(char *restrict, const char *restrict,
size_t, locale_t);
[CX]
Inclusion of the  header may also make visible all symbols from .
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
, ,
XSH 2.2 The Compilation Environment, memccpy(), memchr(), memcmp(), memcpy(), memmem(), memmove(), memset(), strcat(), strchr(), strcmp(), strcoll(), strcpy(), strcspn(), strdup(), strerror(), strlcat(), strlen(), strncat(), strncmp(), strncpy(), strpbrk(), strrchr(), strsignal(), strspn(), strstr(), strtok(), strxfrm()
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Threads Extension.
Issue 6
The strtok_r() function is marked as part of the Thread-Safe Functions
option.
This reference page is updated to align with the ISO/IEC 9899:1999 standard.
The strerror_r() function is added in response to IEEE PASC Interpretation
1003.1c #39.
Issue 7
SD5-XBD-ERN-15 is applied, correcting the prototype for the strerror_r()
function.
The stpcpy(), stpncpy(), strndup(), strnlen(), and strsignal() functions are added from The Open Group Technical Standard, 2006, Extended API
Set Part 1.
The strcoll_l(), strerror_l(), and strxfrm_l() functions
are added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
This reference page is clarified with respect to macros and symbolic constants, and a declaration for the locale_t type
is added.
Issue 8
Austin Group Defect 986 is applied, adding strlcat() and strlcpy().
Austin Group Defect 1061 is applied, adding memmem().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/iconv.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
iconv.h — codeset conversion facility
SYNOPSIS
#include
DESCRIPTION
The  header shall define the following types:
iconv_t
Identifies the conversion from one codeset to another.
size_t
As described in .
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
size_t  iconv(iconv_t, char **restrict, size_t *restrict,
char **restrict, size_t *restrict);
int     iconv_close(iconv_t);
iconv_t iconv_open(const char *, const char *);
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XSH iconv(), iconv_close(), iconv_open()
CHANGE HISTORY
First released in Issue 4.
Issue 6
The restrict keyword is added to the prototype for iconv().
Issue 7
SD5-XBD-ERN-56 is applied, adding a reference to  for the
size_t type.
The  header is moved from the XSI option to the Base.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/stdio.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
stdio.h — standard buffered input/output
SYNOPSIS
#include
DESCRIPTION
[CX]  Some of the functionality described on this reference page extends the ISO C standard. Applications shall define
the appropriate feature test macro (see XSH 2.2 The Compilation
Environment) to enable the visibility of these symbols in this header.
The  header shall define the following data types through typedef:
FILE
A type containing information about a file. The FILE type may be an incomplete type.
fpos_t
A complete object type, other than an array type, capable of recording all the information needed to specify uniquely every
position within a file.
off_t
As described in .
size_t
As described in .
ssize_t
[CX]  As
described in .
va_list
[CX]  As
described in .
The  header shall define the following macros which shall expand to integer constant expressions:
BUFSIZ
Size of  buffers. [CX]   This shall expand to a positive value.
L_ctermid
[CX]
Maximum size of character array to hold ctermid() output.
L_tmpnam
[OB]
Maximum size of character array to hold tmpnam() output.
The  header shall define the following macros which shall expand to integer constant expressions with
distinct values:
_IOFBF
Input/output fully buffered.
_IOLBF
Input/output line buffered.
_IONBF
Input/output unbuffered.
The  header shall define the following macros which shall expand to integer constant expressions with
distinct values:
SEEK_CUR
Seek relative to current position.
SEEK_END
Seek relative to end-of-file.
SEEK_SET
Seek relative to start-of-file.
The  header shall define the following macros which shall expand to integer constant expressions denoting
implementation limits:
{FILENAME_MAX}
Maximum size in bytes of the longest pathname that the implementation guarantees can be opened.
{FOPEN_MAX}
Number of streams which the implementation guarantees can be open simultaneously. The value is at least eight.
{TMP_MAX}
[OB]
Minimum number of unique filenames generated by tmpnam(). Maximum number of times an
application can call tmpnam() reliably. The value of {TMP_MAX} is at least 25.
[OB XSI]  On XSI-conformant systems, the value of {TMP_MAX} is at least 10000.
The  header shall define the following macro which shall expand to an integer constant expression with
type int and a negative value:
EOF
End-of-file return value.
The  header shall define NULL as described in .
The  header shall define the following macros which shall expand to expressions of type "pointer to
FILE" that point to the FILE objects associated, respectively, with the standard error, input, and output
streams:
stderr
Standard error output stream.
stdin
Standard input stream.
stdout
Standard output stream.
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
void     clearerr(FILE *);
[CX]
char    *ctermid(char *);
int      dprintf(int, const char *restrict, ...)
int      fclose(FILE *);
[CX]
FILE    *fdopen(int, const char *);
int      feof(FILE *);
int      ferror(FILE *);
int      fflush(FILE *);
int      fgetc(FILE *);
int      fgetpos(FILE *restrict, fpos_t *restrict);
char    *fgets(char *restrict, int, FILE *restrict);
[CX]
int      fileno(FILE *);
void     flockfile(FILE *);
FILE    *fmemopen(void *restrict, size_t, const char *restrict);
FILE    *fopen(const char *restrict, const char *restrict);
int      fprintf(FILE *restrict, const char *restrict, ...);
int      fputc(int, FILE *);
int      fputs(const char *restrict, FILE *restrict);
size_t   fread(void *restrict, size_t, size_t, FILE *restrict);
FILE    *freopen(const char *restrict, const char *restrict,
FILE *restrict);
int      fscanf(FILE *restrict, const char *restrict, ...);
int      fseek(FILE *, long, int);
[CX]
int      fseeko(FILE *, off_t, int);
int      fsetpos(FILE *, const fpos_t *);
long     ftell(FILE *);
[CX]
off_t    ftello(FILE *);
int      ftrylockfile(FILE *);
void     funlockfile(FILE *);
size_t   fwrite(const void *restrict, size_t, size_t, FILE *restrict);
int      getc(FILE *);
int      getchar(void);
[CX]
int      getc_unlocked(FILE *);
int      getchar_unlocked(void);
ssize_t  getdelim(char **restrict, size_t *restrict, int,
FILE *restrict);
ssize_t  getline(char **restrict, size_t *restrict, FILE *restrict);
FILE    *open_memstream(char **, size_t *);
int      pclose(FILE *);
void     perror(const char *);
[CX]
FILE    *popen(const char *, const char *);
int      printf(const char *restrict, ...);
int      putc(int, FILE *);
int      putchar(int);
[CX]
int      putc_unlocked(int, FILE *);
int      putchar_unlocked(int);
int      puts(const char *);
int      remove(const char *);
int      rename(const char *, const char *);
[CX]
int      renameat(int, const char *, int, const char *);
void     rewind(FILE *);
int      scanf(const char *restrict, ...);
void     setbuf(FILE *restrict, char *restrict);
int      setvbuf(FILE *restrict, char *restrict, int, size_t);
int      snprintf(char *restrict, size_t, const char *restrict, ...);
int      sprintf(char *restrict, const char *restrict, ...);
int      sscanf(const char *restrict, const char *restrict, ...);
FILE    *tmpfile(void);
[OB]
char    *tmpnam(char *);
int      ungetc(int, FILE *);
[CX]
int      vdprintf(int, const char *restrict, va_list);
int      vfprintf(FILE *restrict, const char *restrict, va_list);
int      vfscanf(FILE *restrict, const char *restrict, va_list);
int      vprintf(const char *restrict, va_list);
int      vscanf(const char *restrict, va_list);
int      vsnprintf(char *restrict, size_t, const char *restrict,
va_list);
int      vsprintf(char *restrict, const char *restrict, va_list);
int      vsscanf(const char *restrict, const char *restrict, va_list);
[CX]
Inclusion of the  header may also make visible all symbols from .
The following sections are informative.
APPLICATION USAGE
Since standard I/O streams may use an underlying file descriptor to access the file associated with a stream, application
developers need to be aware that {FOPEN_MAX} streams may not be available if file descriptors are being used to access files that
are not associated with streams.
Since the latest revision of the ISO C standard allows FILE to be an incomplete type (and POSIX also allows it),
portable applications can no longer allocate or copy an object of type FILE; only pointers to objects of type FILE
can be allocated.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
, ,
XSH 2.2 The Compilation Environment, clearerr(), ctermid(), fclose(), fdopen(), feof(), ferror(), fflush(), fgetc(), fgetpos(), fgets(), fileno(), flockfile(), fmemopen(), fopen(), fprintf(), fputc(), fputs(), fread(), freopen(), fscanf(), fseek(), fsetpos(), ftell(), fwrite(), getc(), getchar(), getc_unlocked(), getdelim(),
getopt(), open_memstream(),
pclose(), perror(), popen(), putc(), putchar(), puts(), remove(), rename(), rewind(), setbuf(), setvbuf(), stdin, system(), tmpfile(), tmpnam(), ungetc(), vfprintf(), vfscanf()
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Threads Extension.
Large File System extensions are added.
The constant L_cuserid and the external variables optarg, opterr, optind, and optopt are marked as
extensions and LEGACY.
The cuserid() and getopt() functions are marked LEGACY.
Issue 6
The constant L_cuserid and the external variables optarg, opterr, optind, and optopt are removed as
they were previously marked LEGACY.
The cuserid(), getopt(), and getw() functions are removed as they were previously marked LEGACY.
Several functions are marked as part of the Thread-Safe Functions option.
This reference page is updated to align with the ISO/IEC 9899:1999 standard. Note that the description of the fpos_t
type is now explicitly updated to exclude array types.
Extensions beyond the ISO C standard are marked.
Issue 7
Austin Group Interpretation 1003.1-2001 #172 is applied, adding rationale about a conflict for the definition of {TMP_MAX} with
the ISO C standard.
SD5-XBD-ERN-99 is applied, adding APPLICATION USAGE.
The dprintf(), fmemopen(),
getdelim(), getline(), open_memstream(), and vdprintf()
functions are added from The Open Group Technical Standard, 2006, Extended API Set Part 1.
The renameat() function is added from The Open Group Technical Standard, 2006,
Extended API Set Part 2.
The gets(), tmpnam(), and tempnam() functions and the L_tmpnam macro
are marked obsolescent.
This reference page is clarified with respect to macros and symbolic constants, and a declaration for the off_t type is
added.
POSIX.1-2008, Technical Corrigendum 1, XBD/TC1-2008/0065 [291,427] is applied.
Issue 8
Austin Group Defect 1054 is applied, allowing FILE to be an incomplete type.
Austin Group Defect 1302 is applied, aligning this header with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/stdint.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
stdint.h — integer types
SYNOPSIS
#include
DESCRIPTION
[CX]  Some of the functionality described on this reference page extends the ISO C standard. Applications shall define
the appropriate feature test macro (see XSH 2.2 The Compilation
Environment) to enable the visibility of these symbols in this header.
The  header shall declare sets of integer types having specified widths, and shall define corresponding
sets of macros. It shall also define macros that specify limits of integer types corresponding to types defined in other standard
headers.
Note:
The "width" of an integer type is the number of bits used to store its value in a pure binary system; the actual type may use
more bits than that (for example, a 28-bit type could be stored in 32 bits of actual storage). An N-bit signed type in two's
complement representation has values in the range -2N-1 to
2N-1-1, while an N-bit unsigned type has values in the range 0 to
2N-1. While the ISO C standard also permits signed integers in sign-magnitude or one's
complement form, this standard requires an implementation to use two's complement representation for the standard integer
types.
Types are defined in the following categories:
Integer types having certain exact widths
Integer types having at least certain specified widths
Fastest integer types having at least certain specified widths
Integer types wide enough to hold pointers to objects
Integer types having greatest width
(Some of these types may denote the same type.)
Corresponding macros specify limits of the declared types and construct suitable constants.
For each type described herein that the implementation provides, the  header shall declare that
typedef name and define the associated macros. Conversely, for each type described herein that the implementation does not
provide, the  header shall not declare that typedef name, nor shall it define the associated macros.
An implementation shall provide those types described as required, but need not provide any of the others (described as
optional).
Integer Types
When typedef names differing only in the absence or presence of the initial u are defined, they shall denote
corresponding signed and unsigned types as described in the ISO C standard, Section 6.2.5; an implementation providing one of
these corresponding types shall also provide the other.
In the following descriptions, the symbol N represents an unsigned decimal integer with no leading zeros (for example, 8
or 24, but not 04 or 048).
Exact-width integer types
The typedef name int N _t designates a signed integer type with width N, no padding bits, and
a two's-complement representation. Thus, int8_t denotes such a signed integer type with a width of exactly 8 bits.
The typedef name uint N _t designates an unsigned integer type with width N and no padding
bits. Thus, uint24_t denotes such an unsigned integer type with a width of exactly 24 bits.
[CX]  The
following types are required:
int8_t
int16_t
int32_t
uint8_t
uint16_t
uint32_t
If an implementation provides integer types with width 64 that meet these requirements, then the following types are required:
int64_t uint64_t
[CX]  In
particular, this is the case if any of the following are true:
The implementation supports the _POSIX_V8_ILP32_OFFBIG programming environment and the application is being built in the
_POSIX_V8_ILP32_OFFBIG programming environment (see the Shell and Utilities volume of POSIX.1-2024, c17, Programming Environments).
The implementation supports the _POSIX_V8_LP64_OFF64 programming environment and the application is being built in the
_POSIX_V8_LP64_OFF64 programming environment.
The implementation supports the _POSIX_V8_LPBIG_OFFBIG programming environment and the application is being built in the
_POSIX_V8_LPBIG_OFFBIG programming environment.
If the representation of any of the standard types short, int, long or long long is not the same as
one of the above required types, an int N _t type with that representation shall be defined along with its
uint N _t counterpart.
All other types of this form are optional.
Minimum-width integer types
The typedef name int_least N _t designates a signed integer type with a width of at least N,
such that no signed integer type with lesser size has at least the specified width. Thus, int_least32_t denotes a signed
integer type with a width of at least 32 bits.
The typedef name uint_least N _t designates an unsigned integer type with a width of at least
N, such that no unsigned integer type with lesser size has at least the specified width. Thus, uint_least16_t denotes
an unsigned integer type with a width of at least 16 bits.
The following types are required: int_least8_t int_least16_t int_least32_t int_least64_t
uint_least8_t uint_least16_t uint_least32_t uint_least64_t
All other types of this form are optional.
Fastest minimum-width integer types
Each of the following types designates an integer type that is usually fastest to operate with among all integer types that have
at least the specified width.
The designated type is not guaranteed to be fastest for all purposes; if the implementation has no clear grounds for choosing
one type over another, it may simply pick some integer type satisfying the signedness and width requirements.
The typedef name int_fast N _t designates the fastest signed integer type with a width of at least
N. The typedef name uint_fast N _t designates the fastest unsigned integer type with a width of
at least N.
The following types are required: int_fast8_t int_fast16_t int_fast32_t int_fast64_t
uint_fast8_t uint_fast16_t uint_fast32_t uint_fast64_t
All other types of this form are optional.
Integer types capable of holding object pointers
The following type designates a signed integer type with the property that any valid pointer to void can be converted to
this type, then converted back to a pointer to void, and the result shall compare equal to the original pointer:
intptr_t
The following type designates an unsigned integer type with the property that any valid pointer to void can be converted
to this type, then converted back to a pointer to void, and the result shall compare equal to the original pointer:
uintptr_t
[XSI]
On XSI-conformant systems, the intptr_t and uintptr_t types are required;   otherwise, they are optional.
Greatest-width integer types
The following type designates a signed integer type [CX]   using two's complement representation  capable of representing any value of any signed integer type:
intmax_t
The following type designates an unsigned integer type capable of representing any value of any unsigned integer type:
uintmax_t
These types are required.
Note:
Applications can test for optional types by using the corresponding limit macro from Limits of
Specified-Width Integer Types.
Limits of Specified-Width Integer Types
The following macros specify the minimum and maximum limits of the types declared in the  header. Each
macro name corresponds to a similar type name in Integer Types.
Each instance of any defined macro shall be replaced by a constant expression suitable for use in #if preprocessing
directives, and this expression shall have the same type as would an expression that is an object of the corresponding type
converted according to the integer promotions. Its implementation-defined value shall be equal to or greater in magnitude (absolute
value) than the corresponding value given below, with the same sign, except where stated to be exactly the given value.
Limits of exact-width integer types
Minimum values of exact-width signed integer types:
{INTN_MIN}
Exactly -(2N-1)
Maximum values of exact-width signed integer types:
{INTN_MAX}
Exactly 2N-1 -1
Maximum values of exact-width unsigned integer types:
{UINTN_MAX}
Exactly  2N-1
Limits of minimum-width integer types
Minimum values of minimum-width signed integer types:
{INT_LEASTN_MIN}
[CX]
-(2N-1)
Maximum values of minimum-width signed integer types:
{INT_LEASTN_MAX}
2N-1 -1
Maximum values of minimum-width unsigned integer types:
{UINT_LEASTN_MAX}
2N -1
Limits of fastest minimum-width integer types
Minimum values of fastest minimum-width signed integer types:
{INT_FASTN_MIN}
[CX]
-(2N-1)
Maximum values of fastest minimum-width signed integer types:
{INT_FASTN_MAX}
2N-1 -1
Maximum values of fastest minimum-width unsigned integer types:
{UINT_FASTN_MAX}
2N -1
Limits of integer types capable of holding object pointers
Minimum value of pointer-holding signed integer type:
{INTPTR_MIN}
[CX]
-(215)
Maximum value of pointer-holding signed integer type:
{INTPTR_MAX}
215 -1
Maximum value of pointer-holding unsigned integer type:
{UINTPTR_MAX}
216 -1
Limits of greatest-width integer types
Minimum value of greatest-width signed integer type:
{INTMAX_MIN}
[CX]
-(263)
Maximum value of greatest-width signed integer type:
{INTMAX_MAX}
263 -1
Maximum value of greatest-width unsigned integer type:
{UINTMAX_MAX}
264 -1
Limits of Other Integer Types
The following macros specify the minimum and maximum limits of integer types corresponding to types defined in other standard
headers.
Each instance of these macros shall be replaced by a constant expression suitable for use in #if preprocessing
directives, and this expression shall have the same type as would an expression that is an object of the corresponding type
converted according to the integer promotions. Its implementation-defined value shall be equal to or greater in magnitude (absolute
value) than the corresponding value given below, with the same sign.
Limits of ptrdiff_t:
{PTRDIFF_MIN}
[CX]
-65536
{PTRDIFF_MAX}
+65535
Limits of sig_atomic_t:
{SIG_ATOMIC_MIN}
See below.
{SIG_ATOMIC_MAX}
See below.
Limit of size_t:
{SIZE_MAX}
65535
Limits of wchar_t:
{WCHAR_MIN}
See below.
{WCHAR_MAX}
See below.
Limits of wint_t:
{WINT_MIN}
See below.
{WINT_MAX}
See below.
If sig_atomic_t (see the  header) is defined as a signed
integer type, the value of {SIG_ATOMIC_MIN} shall be no greater than -127 and the value of {SIG_ATOMIC_MAX} shall be no less than
127; otherwise, sig_atomic_t shall be defined as an unsigned integer type, and the value of {SIG_ATOMIC_MIN} shall be 0 and
the value of {SIG_ATOMIC_MAX} shall be no less than 255.
If wchar_t (see the  header) is defined as a signed
integer type, the value of {WCHAR_MIN} shall be no greater than -127 and the value of {WCHAR_MAX} shall be no less than 127;
otherwise, wchar_t shall be defined as an unsigned integer type, and the value of {WCHAR_MIN} shall be 0 and the value of
{WCHAR_MAX} shall be no less than 255.
If wint_t (see the  header) is defined as a signed integer
type, the value of {WINT_MIN} shall be no greater than -32767 and the value of {WINT_MAX} shall be no less than 32767; otherwise,
wint_t shall be defined as an unsigned integer type, and the value of {WINT_MIN} shall be 0 and the value of {WINT_MAX}
shall be no less than 65535.
Macros for Integer Constant Expressions
The following macros expand to integer constant expressions suitable for initializing objects that have integer types
corresponding to types defined in the  header. Each macro name corresponds to a similar type name listed
under Minimum-width integer types and Greatest-width integer types.
Each invocation of one of these macros shall expand to an integer constant expression suitable for use in #if
preprocessing directives. The type of the expression shall have the same type as would an expression that is an object of the
corresponding type converted according to the integer promotions. The value of the expression shall be that of the argument.
The argument in any instance of these macros shall be an unsuffixed integer constant with a value that does not exceed the
limits for the corresponding type.
Macros for minimum-width integer constant expressions
The macro INTN_C( value) shall expand to an integer constant expression corresponding to the type int_least
N _t. The macro UINTN_C( value) shall expand to an integer constant expression corresponding to the
type uint_least N _t. For example, if uint_least64_t is a name for the type unsigned long long,
then UINT64_C(0x123) might expand to the integer constant 0x123ULL.
Macros for greatest-width integer constant expressions
The following macro expands to an integer constant expression having the value specified by its argument and the type
intmax_t: INTMAX_C(value)
The following macro expands to an integer constant expression having the value specified by its argument and the type
uintmax_t: UINTMAX_C(value)
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
The  header is a subset of the  header
more suitable for use in freestanding environments, which might not support the formatted I/O functions. In some environments, if
the formatted conversion support is not wanted, using this header instead of the  header avoids defining such a large number of macros.
As a consequence of adding int8_t, the following are true:
A byte is exactly 8 bits.
{CHAR_BIT} has the value 8, {SCHAR_MAX} has the value 127, {SCHAR_MIN} has the value -128, and {UCHAR_MAX} has the value
255.
Since the POSIX.1 standard explicitly requires 8-bit char with two's complement arithmetic, it is easier for application
writers if the same two's complement guarantees are extended to all of the other standard integer types. Furthermore, in
programming environments with a 32-bit long, some POSIX.1 interfaces, such as mrand48(), cannot be implemented if long does not use a two's complement
representation.
FUTURE DIRECTIONS
typedef names beginning with int or uint and ending with _t may be added to the types defined in the
header. Macro names beginning with INT or UINT and ending with _MAX, _MIN, or _C may be added to the macros
defined in the  header.
SEE ALSO
, , ,
XSH 2.2 The Compilation Environment
CHANGE HISTORY
First released in Issue 6. Included for alignment with the ISO/IEC 9899:1999 standard.
ISO/IEC 9899:1999 standard, Technical Corrigendum 1 is applied.
Issue 7
ISO/IEC 9899:1999 standard, Technical Corrigendum 3 #40 is applied.
SD5-XBD-ERN-67 is applied.
Issue 8
Austin Group Defect 1108 is applied, changing the maximum allowed value for all signed integer minimum limits.
Austin Group Defect 1302 is applied, aligning this header with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1330 is applied, changing "_V7_" to "_V8_".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/toc.html =====
Base Definitions: Table of contents
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
Base Definitions: Table of Contents
1. Introduction
1.1 Scope
1.2 Word Usage
1.3 Conformance
1.4 Normative References
1.5 Change History
1.6 Terminology
can
implementation-defined
legacy
may
shall
should
undefined
unspecified
1.7 Definitions and Concepts
1.8 Portability
1.8.1 Codes
1.8.2 Margin Code Notation
A Feature Dependent on One or Two Options
A Feature Dependent on Either of the Options Denoted
A Feature Dependent on More than Two Options
Large Sections Dependent on an Option
Footnotes
2. Conformance
2.1 Implementation Conformance
2.1.1 Requirements
2.1.2 Documentation
2.1.3 POSIX Conformance
2.1.3.1 POSIX System Interfaces
2.1.3.2 POSIX Shell and Utilities
2.1.4 XSI Conformance
2.1.4.1 XSI System Interfaces
2.1.4.2 XSI Shell and Utilities Conformance
2.1.5 Option Groups
2.1.5.1 Subprofiling Considerations
2.1.5.2 XSI Option Groups
Encryption
Realtime
Advanced Realtime
Realtime Threads
Advanced Realtime Threads
2.1.6 Options
2.1.6.1 System Interfaces
2.1.6.2 Shell and Utilities
2.2 Application Conformance
2.2.1 Strictly Conforming POSIX Application
2.2.2 Conforming POSIX Application
2.2.2.1 ISO/IEC Conforming POSIX Application
2.2.2.2  Conforming POSIX Application
2.2.3 Conforming POSIX Application Using Extensions
2.2.4 Strictly Conforming XSI Application
2.2.5 Conforming XSI Application Using Extensions
2.3 Language-Dependent Services for the C Programming Language
2.4 Other Language-Related Specifications
Footnotes
3. Definitions
3.1 Abortive Release
3.2 Absolute Pathname
3.3 Access Mode
3.4 Additional File Access Control Mechanism
3.5 Address Space
3.6 Advisory Information
3.7 Affirmative Response
3.8 Alert
3.9 Alert Character ()
3.10 Alias Name
3.11 Alignment
3.12 Alternate File Access Control Mechanism
3.13 Alternate Signal Stack
3.14 Ancillary Data
3.15 Angle Brackets
3.16 Anonymous Memory Object
3.17 Apostrophe Character ()
3.18 Application
3.19 Application Address
3.20 Application Program Interface (API)
3.21 Appropriate Privileges
3.22 Argument
3.23 Arm (a Timer)
3.24 Asterisk Character ()
3.25 Async-Cancel-Safe Function
3.26 Asynchronous Events
3.27 Asynchronous Input and Output
3.28 Async-Signal-Safe Function
3.29 Asynchronously-Generated Signal
3.30 Asynchronous I/O Completion
3.31 Asynchronous I/O Operation
3.32 Atomic Operation
3.33 Authentication
3.34 Authorization
3.35 Background Job
3.36 Background Process
3.37 Background Process Group
3.38 Backquote Character
3.39 Backslash Character ()
3.40 Backspace Character ()
3.41 Barrier
3.42 Basename
3.43 Basic Regular Expression (BRE)
3.44 Bind
3.45 Blank Character ()
3.46 Blank Line
3.47 Blocked Process (or Thread)
3.48 Blocking
3.49 Block-Mode Terminal
3.50 Block Special File
3.51 Braces
3.52 Brackets
3.53 Broadcast
3.54 Built-In Utility (or Built-In)
3.55 Byte
3.56 Byte Input/Output Functions
3.57 Carriage-Return Character ()
3.58 Character
3.59 Character Array
3.60 Character Class
3.61 Character Set
3.62 Character Special File
3.63 Character String
3.64 Child Process
3.65 Circumflex Character ()
3.66 Clock
3.67 Clock Jump
3.68 Clock Tick
3.69 Code Block
3.70 Coded Character Set
3.71 Codeset
3.72 Collating Element
3.73 Collation
3.74 Collation Sequence
3.75 Column Position
3.76 Command
3.77 Command Language Interpreter
3.78 Composite Graphic Symbol
3.79 Condition Variable
3.80 Connected Socket
3.81 Connection
3.82 Connection Mode
3.83 Connectionless Mode
3.84 Control Character
3.85 Control Operator
3.86 Controlling Process
3.87 Controlling Terminal
3.88 Conversion Descriptor
3.89 Core Image
3.90 CPU Time (Execution Time)
3.91 CPU-Time Clock
3.92 CPU-Time Timer
3.93 Current Job
3.94 Current Working Directory
3.95 Cursor Position
3.96 Datagram
3.97 Data Race
3.98 Data Segment
3.99 Decimal-Point Character
3.100 Declaration Utility
3.101 Device
3.102 Device ID
3.103 Directory
3.104 Directory Entry (or Hard Link)
3.105 Directory Stream
3.106 Disarm (a Timer)
3.107 Display
3.108 Display Line
3.109 Dollar-Sign Character ()
3.110 Dot
3.111 Dot-Dot
3.112 Dot-Po File
3.113 Double-Quote Character
3.114 Downshifting
3.115 Driver
3.116 Effective Group ID
3.117 Effective User ID
3.118 Eight-Bit Transparency
3.119 Empty Directory
3.120 Empty Line
3.121 Empty String (or Null String)
3.122 Empty Wide-Character String
3.123 Encoding Rule
3.124 Entire Regular Expression
3.125 Epoch
3.126 Equivalence Class
3.127 Era
3.128 Event Management
3.129 Executable File
3.130 Execute
3.131 Execution Time
3.132 Execution Time Monitoring
3.133 Expand
3.134 Extended Regular Expression (ERE)
3.135 Extended Security Controls
3.136 Feature Test Macro
3.137 Field
3.138 FIFO Special File (or FIFO)
3.139 File
3.140 File Description
3.141 File Descriptor
3.142 File Group Class
3.143 File Lock
3.144 File Mode
3.145 File Mode Bits
3.146 Filename
3.147 Filename String
3.148 File Offset
3.149 File Other Class
3.150 File Owner Class
3.151 File Permission Bits
3.152 File Serial Number
3.153 File System
3.154 File Type
3.155 Filter
3.156 First Open (of a File)
3.157 Flow Control
3.158 Foreground Job
3.159 Foreground Process
3.160 Foreground Process Group
3.161 Foreground Process Group ID
3.162 Form-Feed Character ()
3.163 Graphic Character
3.164 Group Database
3.165 Group ID
3.166 Group Name
3.167 Hard Limit
3.168 Hard Link
3.169 Hole
3.170 Home Directory
3.171 Host Byte Order
3.172 Incomplete Line
3.173 Inf
3.174 Interactive Device
3.175 Interactive Shell
3.176 Internationalization
3.177 Interprocess Communication
3.178 Intrinsic Utility
3.179 Invoke
3.180 Job
3.181 Job Control
3.182 Job ID
3.183 Joinable Thread
3.184 Last Close (of a File)
3.185 Line
3.186 Linger
3.187 Link
3.188 Link Count
3.189 Live Process
3.190 Live Thread
3.191 Local Customs
3.192 Local Interprocess Communication (Local IPC)
3.193 Locale
3.194 Localization
3.195 Lock-Free Operation
3.196 Login
3.197 Login Name
3.198 Map
3.199 Matched
3.200 Memory Mapped Files
3.201 Memory Object
3.202 Memory-Resident
3.203 Message
3.204 Message Catalog
3.205 Message Catalog Descriptor
3.206 Message Queue
3.207 Messages Object
3.208 Mode
3.209 Monotonic Clock
3.210 Mount Point
3.211 Multi-Character Collating Element
3.212 Multi-Threaded Library
3.213 Multi-Threaded Process
3.214 Multi-Threaded Program
3.215 Mutex
3.216 Name
3.217 NaN (Not a Number)
3.218 Native Language
3.219 Negative
3.220 Negative Response
3.221 Network
3.222 Network Address
3.223 Network Byte Order
3.224 Newline Character ()
3.225 Nice Value
3.226 Non-Blocking
3.227 Non-Spacing Characters
3.228 NUL
3.229 Null Byte
3.230 Null Pointer
3.231 Null String
3.232 Null Terminator
3.233 Null Wide-Character Code
3.234 Number-Sign Character ()
3.235 Object File
3.236 Octet
3.237 OFD-Owned File Lock
3.238 Offset Maximum
3.239 Opaque Address
3.240 Open File
3.241 Open File Description
3.242 Operand
3.243 Operator
3.244 Option
3.245 Option-Argument
3.246 Orientation
3.247 Orphaned Process Group
3.248 Page
3.249 Page Size
3.250 Parameter
3.251 Parent Directory
3.252 Parent Process
3.253 Parent Process ID
3.254 Pathname
3.255 Pathname Component
3.256 Path Prefix
3.257 Pattern
3.258 Period Character ()
3.259 Permissions
3.260 Persistence
3.261 Pipe
3.262 Polling
3.263 Portable Character Set
3.264 Portable Filename
3.265 Portable Filename Character Set
3.266 Portable Messages Object Source File (or Dot-Po File)
3.267 Positional Parameter
3.268 Positive
3.269 Preallocation
3.270 Preempted Process (or Thread)
3.271 Previous Job
3.272 Printable Character
3.273 Printable File
3.274 Priority
3.275 Priority Inversion
3.276 Priority Scheduling
3.277 Priority-Based Scheduling
3.278 Privilege
3.279 Process
3.280 Process Group
3.281 Process Group ID
3.282 Process Group Leader
3.283 Process Group Lifetime
3.284 Process ID
3.285 Process Lifetime
3.286 Process Memory Locking
3.287 Process Termination
3.288 Process Virtual Time
3.289 Process-Owned File Lock
3.290 Process-To-Process Communication
3.291 Program
3.292 Protocol
3.293 Pseudo-Terminal
3.294 Radix Character (or Decimal-Point Character)
3.295 Read-Only File System
3.296 Read-Write Lock
3.297 Real Group ID
3.298 Real Time
3.299 Realtime Signal Extension
3.300 Real User ID
3.301 Record
3.302 Record Lock
3.303 Redirection
3.304 Redirection Operator
3.305 Referenced Shared Memory Object
3.306 Refresh
3.307 Regular Built-In Utility (or Regular Built-In)
3.308 Regular Expression
3.309 Region
3.310 Regular File
3.311 Relative Pathname
3.312 Relocatable File
3.313 Relocation
3.314 (Time) Resolution
3.315 Robust Mutex
3.316 Root Directory
3.317 Runnable Process (or Thread)
3.318 Running Process (or Thread)
3.319 Saved Resource Limits
3.320 Saved Set-Group-ID
3.321 Saved Set-User-ID
3.322 Scheduling
3.323 Scheduling Allocation Domain
3.324 Scheduling Contention Scope
3.325 Scheduling Policy
3.326 Screen
3.327 Scroll
3.328 Semaphore
3.329 Session
3.330 Session Leader
3.331 Session Lifetime
3.332 Shared Memory Object
3.333 Shell
3.334 Shell, the
3.335 Shell Script
3.336 Signal
3.337 Signal Stack
3.338 Single-Quote Character
3.339 Single-Threaded Process
3.340 Single-Threaded Program
3.341 Slash Character ()
3.342 Socket
3.343 Socket Address
3.344 Soft Limit
3.345 Source Code
3.346 Space Character ()
3.347 Sparse File
3.348 Spawn
3.349 Special Built-In Utility (or Special Built-In)
3.350 Special Parameter
3.351 Spin Lock
3.352 Sporadic Server
3.353 Standard Error
3.354 Standard Input
3.355 Standard Output
3.356 Standard Utilities
3.357 Stream
3.358 String
3.359 Subshell
3.360 Successfully Transferred
3.361 Supplementary Group ID
3.362 Suspended Job
3.363 Symbolic Constant
3.364 Symbolic Link
3.365 Synchronization Operation
3.366 Synchronized Input and Output
3.367 Synchronized I/O Completion
3.368 Synchronized I/O Data Integrity Completion
3.369 Synchronized I/O File Integrity Completion
3.370 Synchronized I/O Operation
3.371 Synchronous I/O Operation
3.372 Synchronously-Generated Signal
3.373 System
3.374 System Boot
3.375 System Clock
3.376 System Console
3.377 System Crash
3.378 System Databases
3.379 System Documentation
3.380 System Process
3.381 System Reboot
3.382 System-Wide
3.383 Tab Character ()
3.384 Terminal (or Terminal Device)
3.385 Text Column
3.386 Text Domain
3.387 Text File
3.388 Thread
3.389 Thread ID
3.390 Thread Lifetime
3.391 Thread List
3.392 Thread Termination
3.393 Thread-Safe
3.394 Thread-Specific Data Key
3.395 Tilde Character ()
3.396 Timeouts
3.397 Timer
3.398 Timer Overrun
3.399 Token
3.400 Typed Memory Name Space
3.401 Typed Memory Object
3.402 Typed Memory Pool
3.403 Typed Memory Port
3.404 Unbind
3.405 Unit Data
3.406 Upshifting
3.407 User Database
3.408 User ID
3.409 User Name
3.410 Utility
3.411 Variable
3.412 Vertical-Tab Character ()
3.413 White Space
3.414 White-Space Byte
3.415 White-Space Character
3.416 White-Space Wide Character
3.417 Wide-Character Code (C Language)
3.418 Wide-Character Input/Output Functions
3.419 Wide-Character String
3.420 Word
3.421 Working Directory (or Current Working Directory)
3.422 Worldwide Portability Interface
3.423 Write
3.424 XSI
3.425 XSI-Conformant
3.426 Zombie Process
3.427 Zombie Thread
3.428 ±0
4. General Concepts
4.1 Case Insensitive Comparisons
4.2 Concurrent Execution
4.3 Default Initialization
4.4 Directory Operations
4.5 Directory Protection
4.6 Extended Security Controls
4.7 File Access Permissions
4.8 File Hierarchy
4.9 Filenames
4.10 Filename Portability
4.11 File System Cache
4.12 File Times Update
4.13 Host and Network Byte Orders
4.14 Measurement of Execution Time
4.15 Memory Ordering and Synchronization
4.15.1 Memory Ordering
4.15.1.1 Data Races
4.15.1.2 Memory Order and Consistency
4.15.2 Memory Synchronization
4.16 Pathname Resolution
4.17 Process ID Reuse
4.18 Scheduling Policy
4.19 Seconds Since the Epoch
4.20 Semaphore
Semaphore Lock Operation
Semaphore Unlock Operation
4.21 Special Device Drivers
4.22 Thread-Safety
4.23 Treatment of Error Conditions for Mathematical Functions
4.23.1 Domain Error
4.23.2 Pole Error
4.23.3 Range Error
4.23.3.1 Result Overflows
4.23.3.2 Result Underflows
4.24 Treatment of NaN Arguments for the Mathematical Functions
4.25 Utility
4.26 Variable Assignment
Footnotes
5. File Format Notation
Examples
6. Character Set
6.1 Portable Character Set
6.2 Character Encoding
6.3 C Language Wide-Character Codes
6.4 Character Set Description File
Example
6.4.1 State-Dependent Character Encodings
7. Locale
7.1 General
7.2 POSIX Locale
7.3 Locale Definition
7.3.1 LC_CTYPE
7.3.1.1 LC_CTYPE Category in the POSIX Locale
7.3.2 LC_COLLATE
7.3.2.1 The collating-element Keyword
7.3.2.2 The collating-symbol Keyword
7.3.2.3 The order_start Keyword
7.3.2.4 Collation Order
7.3.2.5 The order_end Keyword
7.3.2.6 LC_COLLATE Category in the POSIX Locale
7.3.3 LC_MONETARY
7.3.3.1 LC_MONETARY Category in the POSIX Locale
7.3.4 LC_NUMERIC
7.3.4.1 LC_NUMERIC Category in the POSIX Locale
7.3.5 LC_TIME
7.3.5.1 LC_TIME Locale Definition
7.3.5.2 LC_TIME C-Language Access
7.3.5.3 LC_TIME Category in the POSIX Locale
7.3.6 LC_MESSAGES
7.3.6.1 LC_MESSAGES Category in the POSIX Locale
7.4 Locale Definition Grammar
7.4.1 Locale Lexical Conventions
7.4.2 Locale Grammar
8. Environment Variables
8.1 Environment Variable Definition
8.2 Internationalization Variables
8.3 Other Environment Variables
9. Regular Expressions
9.1 Regular Expression Definitions
entire regular expression
escape sequence
leftmost
matched
BRE (ERE) matching a single character
BRE (ERE) matching multiple characters
invalid
9.2 Regular Expression General Requirements
9.3 Basic Regular Expressions
9.3.1 BREs Matching a Single Character or Collating Element
9.3.2 BRE Ordinary Characters
9.3.3 BRE Special Characters
9.3.4 Periods in BREs
9.3.5 RE Bracket Expression
9.3.6 BREs Matching Multiple Characters
9.3.7 BRE Precedence
9.3.8 BRE Expression Anchoring
9.4 Extended Regular Expressions
9.4.1 EREs Matching a Single Character or Collating Element
9.4.2 ERE Ordinary Characters
9.4.3 ERE Special Characters
9.4.4 Periods in EREs
9.4.5 ERE Bracket Expression
9.4.6 EREs Matching Multiple Characters
9.4.7 ERE Alternation
9.4.8 ERE Precedence
9.4.9 ERE Expression Anchoring
9.5 Regular Expression Grammar
9.5.1 BRE/ERE Grammar Lexical Conventions
9.5.2 RE and Bracket Expression Grammar
9.5.3 ERE Grammar
10. Directory Structure and Devices
10.1 Directory Structure and Files
10.2 Output Devices and Terminal Types
11. General Terminal Interface
11.1 Interface Characteristics
11.1.1 Opening a Terminal Device File
11.1.2 Process Groups
11.1.3 The Controlling Terminal
11.1.4 Terminal Access Control
11.1.5 Input Processing and Reading Data
11.1.6 Canonical Mode Input Processing
11.1.7 Non-Canonical Mode Input Processing
Case A: MIN>0, TIME>0
Case B: MIN>0, TIME=0
Case C: MIN=0, TIME>0
Case D: MIN=0, TIME=0
11.1.8 Writing Data and Output Processing
11.1.9 Special Characters
11.1.10 Modem Disconnect
11.1.11 Closing a Terminal Device File
11.2 Parameters that Can be Set
11.2.1 The termios Structure
11.2.2 Input Modes
11.2.3 Output Modes
11.2.4 Control Modes
11.2.5 Local Modes
11.2.6 Special Control Characters
12. Utility Conventions
12.1 Utility Argument Syntax
12.2 Utility Syntax Guidelines
13. Namespace and Future Directions
14. Headers
Format of Entries
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index |
XBD |
XSH |
XCU |
XRAT ]
===== susv5-html/basedefs/V1_chap03.html =====
Definitions
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
3. Definitions
For the purposes of POSIX.1-2024, the following terms and definitions apply. The Authoritative Dictionary of IEEE Standards
Terms, Seventh Edition should be referenced for terms not defined in this section.
Note:
No shading to denote extensions or options occurs in this chapter. Where the terms and definitions given in this chapter are
used elsewhere in text related to extensions and options, they are shaded as appropriate.
3.1 Abortive Release
An abrupt termination of a network connection that may result in the loss of data.
3.2 Absolute Pathname
A pathname beginning with a single or more than two  characters; see also 3.254 Pathname
.
Note:
Pathname Resolution is defined in detail in 4.16 Pathname Resolution
.
3.3 Access Mode
A particular form of access permitted to a file.
3.4 Additional File Access Control Mechanism
An implementation-defined mechanism that is layered upon the access control mechanisms defined here, but which do not grant
permissions beyond those defined herein, although they may further restrict them.
Note:
File Access Permissions are defined in detail in 4.7 File Access
Permissions.
3.5 Address Space
The memory locations that can be referenced by a process or the threads of a process.
3.6 Advisory Information
An interface that advises the implementation on (portable) application behavior so that it can optimize the system.
3.7 Affirmative Response
An input string that matches one of the responses acceptable to the LC_MESSAGES category keyword yesexpr, matching
an extended regular expression in the current locale.
Note:
The LC_MESSAGES category is defined in detail in 7.3.6
LC_MESSAGES.
3.8 Alert
To cause the user's terminal to give some audible or visual indication that an error or some other event has occurred. When the
standard output is directed to a terminal device, the method for alerting the terminal user is unspecified. When the standard
output is not directed to a terminal device, the alert is accomplished by writing the alert to standard output (unless the utility
description indicates that the use of standard output produces undefined results in this case).
3.9 Alert Character ()
A character that in the output stream should cause a terminal to alert its user via a visual or audible notification. It is the
character designated by '\a' in the C language. It is unspecified whether this character is the exact sequence transmitted
to an output device by the system to accomplish the alert function.
3.10 Alias Name
In the shell command language, a word consisting solely of alphabetics and digits from the portable character set and any of the
following characters: '!', '%', ',', '-', '@', '_'.
Implementations may allow other characters within alias names as an extension.
Note:
The Portable Character Set is defined in detail in 6.1 Portable Character
Set.
3.11 Alignment
A requirement that objects of a particular type be located on storage boundaries with addresses that are particular multiples of
a byte address.
Note:
See also the ISO C standard, Section 6.2.8.
3.12 Alternate File Access Control Mechanism
An implementation-defined mechanism that is independent of the access control mechanisms defined herein, and which if enabled on
a file may either restrict or extend the permissions of a given user. POSIX.1-2024 defines when such mechanisms can be enabled and
when they are disabled.
Note:
File Access Permissions are defined in detail in 4.7 File Access
Permissions.
3.13 Alternate Signal Stack
Memory associated with a thread, established upon request by the implementation for a thread, separate from the thread signal
stack, in which signal handlers responding to signals sent to that thread may be executed.
3.14 Ancillary Data
Protocol-specific, local system-specific, or optional information. The information can be both local or end-to-end significant,
header information, part of a data portion, protocol-specific, and implementation or system-specific.
3.15 Angle Brackets
The characters '' (right-angle-bracket). When used in the phrase
"enclosed in angle brackets", the symbol ''
immediately follows it. When describing these characters in the portable character set, the names  and
are used.
3.16 Anonymous Memory Object
An object that represents memory not associated with any other memory objects.
3.17 Apostrophe Character ()
The character designated by '\'' in the C language, also known as the single-quote character.
3.18 Application
A computer program that performs some desired function.
When the User Portability Utilities option is supported, requirements placed on applications relating to the use of standard
utilities shall also apply to the actions of a user who is entering shell command language statements into an interactive
shell.
3.19 Application Address
Endpoint address of a specific application.
3.20 Application Program Interface (API)
The definition of syntax and semantics for providing computer system services.
3.21 Appropriate Privileges
An implementation-defined means of associating privileges with a process with regard to the function calls, function call
options, and the commands that need special privileges. There may be zero or more such means. These means (or lack thereof) are
described in the conformance document.
Note:
Function calls are defined in the System Interfaces volume of POSIX.1-2024, and commands are defined in the Shell and Utilities
volume of POSIX.1-2024.
3.22 Argument
In the shell command language, a parameter passed to a utility as the equivalent of a single string in the argv array
created by one of the exec functions. An argument is one of the options, option-arguments, or operands following the command
name.
Note:
The Utility Argument Syntax is defined in detail in 12.1 Utility Argument
Syntax and XCU 2.9.1.4 Command Search and Execution.
In the C language, an expression in a function call expression or a sequence of preprocessing tokens in a function-like macro
invocation.
3.23 Arm (a Timer)
To start a timer measuring the passage of time, enabling notifying a process when the specified time or time interval has
passed.
3.24 Asterisk Character ()
The character '*'.
3.25 Async-Cancel-Safe Function
A function that may be safely invoked by an application while the asynchronous form of cancellation is enabled. No function is
async-cancel-safe unless explicitly described as such.
3.26 Asynchronous Events
Events that occur independently of the execution of the application.
3.27 Asynchronous Input and Output
A functionality enhancement to allow an application process to queue data input and output commands with asynchronous
notification of completion.
3.28 Async-Signal-Safe Function
A function that can be called, without restriction, from signal-catching functions. Note that, although there is no restriction
on the calls themselves, for certain functions there are restrictions on subsequent behavior after the function is called from a
signal-catching function. No function is async-signal-safe unless explicitly described as such.
Note:
Async-signal-safety is defined in detail in XSH 2.4.3 Signal
Actions.
3.29 Asynchronously-Generated Signal
A signal that is not attributable to a specific thread. Examples are signals sent via kill(), signals sent from the keyboard, and signals delivered to process groups. Being
asynchronous is a property of how the signal was generated and not a property of the signal number. All signals may be generated
asynchronously.
Note:
The kill() function is defined in detail in the System Interfaces volume of
POSIX.1-2024.
3.30 Asynchronous I/O Completion
For an asynchronous read or write operation, when a corresponding synchronous read or write would have completed and when any
associated status fields have been updated.
3.31 Asynchronous I/O Operation
An I/O operation that does not of itself cause the thread requesting the I/O to be blocked from further use of the
processor.
This implies that the process and the I/O operation may be running concurrently.
3.32 Atomic Operation
An operation that cannot be broken up into smaller parts that could be performed separately. An atomic operation is guaranteed
to complete either fully or not at all. In the context of the functionality provided by the  header, there are different types of atomic operation that are
defined in detail in 4.15.1 Memory Ordering.
3.33 Authentication
The process of validating a user or process to verify that the user or process is not a counterfeit.
3.34 Authorization
The process of verifying that a user or process has permission to use a resource in the manner requested.
To assure security, the user or process would also need to be authenticated before granting access.
3.35 Background Job
In the context of the System Interfaces volume of POSIX.1-2024, a background process group (see 3.37
Background Process Group).
In the context of the shell, a job that the shell is not waiting for before it executes further commands or, if interactive,
prompts for further commands. A background job can be a job-control background job or a non-job-control background job. A
job-control background job is a job that started execution (either in the background or the foreground) while job control was
enabled and is currently in the background. A non-job-control background job is an asynchronous AND-OR list that started execution
while job control was disabled and was assigned a job number. An implementation need not support non-job-control background jobs;
that is, the shell may, but need not, assign job numbers to asynchronous AND-OR lists that start execution while job control is
disabled.
Note:
Asynchronous AND-OR lists are defined in detail in XCU 2.9.3.1
Asynchronous AND-OR Lists.
Note:
See also 3.158 Foreground Job, 3.180 Job, 3.181 Job
Control, and 3.362 Suspended Job.
3.36 Background Process
A process that is a member of a background process group.
3.37 Background Process Group
Any process group, other than a foreground process group, that is a member of a session that has established a connection with a
controlling terminal.
Note:
See also 3.35 Background Job.
3.38 Backquote Character
The character '`', also known as .
3.39 Backslash Character ()
The character designated by '\\' in the C language, also known as reverse solidus.
3.40 Backspace Character ()
A character that, in the output stream, should cause printing (or displaying) to occur one column position previous to the
position about to be printed. If the position about to be printed is at the beginning of the current line, the behavior is
unspecified. It is the character designated by '\b' in the C language. It is unspecified whether this character is the
exact sequence transmitted to an output device by the system to accomplish the backspace function. The backspace defined here is
not necessarily the ERASE special character.
Note:
Special Characters are defined in detail in 11.1.9 Special
Characters.
3.41 Barrier
A synchronization object that allows multiple threads to synchronize at a particular point in their execution.
3.42 Basename
For pathnames containing at least one filename: the final, or only, filename in the pathname. For pathnames consisting only of
characters: either '/' or "//" if the pathname consists of exactly two  characters,
and '/' otherwise.
3.43 Basic Regular Expression (BRE)
A regular expression (see 3.308 Regular Expression) used by the majority of utilities that select
strings from a set of character strings.
Note:
Basic Regular Expressions are described in detail in 9.3 Basic Regular
Expressions.
3.44 Bind
The process of assigning a network address to an endpoint.
3.45 Blank Character ()
One of the characters that belong to the blank character class as defined via the LC_CTYPE category in the current
locale. In the POSIX locale, a  character is either a  or a .
3.46 Blank Line
A line consisting solely of zero or more  characters terminated by a ; see also 3.120 Empty Line.
3.47 Blocked Process (or Thread)
A process (or thread) that is waiting for some condition (other than the availability of a processor) to be satisfied before it
can continue execution.
3.48 Blocking
A property of an open file description that causes function calls associated with it to wait for the requested action to be
performed before returning.
3.49 Block-Mode Terminal
A terminal device operating in a mode incapable of the character-at-a-time input and output operations described by some of the
standard utilities.
Note:
Output Devices and Terminal Types are defined in detail in 10.2 Output
Devices and Terminal Types.
3.50 Block Special File
A file that refers to a device. A block special file is normally distinguished from a character special file by providing access
to the device in a manner such that the hardware characteristics of the device are not visible.
3.51 Braces
The characters '{' (left-curly-bracket) and '}' (right-curly-bracket). When used in the phrase "enclosed in
(curly) braces" the symbol '{' immediately precedes the object to be enclosed, and '}' immediately follows it.
When describing these characters in the portable character set, the names  and  are
used for '{', and  and  are used for '}'.
3.52 Brackets
The characters '[' (left-square-bracket) and ']' (right-square-bracket). When used in the phrase "enclosed in
(square) brackets" the symbol '[' immediately precedes the object to be enclosed, and ']' immediately follows
it. When describing these characters in the portable character set, the names  and
are used.
3.53 Broadcast
The transfer of data from one endpoint to several endpoints, as described in RFC 919 and RFC 922.
3.54 Built-In Utility (or Built-In)
A utility implemented within a shell. There are two main types of built-in utilities: special built-ins and regular built-ins.
Unless qualified, the term "built-in" includes both types. The utilities referred to as special built-ins have special qualities.
Regular built-ins are not required to be actually built into the shell on the implementation, but they usually have special
command-search qualities, or affect the current execution environment.
Note:
Special Built-In Utilities are defined in detail in XCU 2.15 Special
Built-In Utilities.
Regular Built-In Utilities are defined in detail in XCU 1.6 Built-In
Utilities.
3.55 Byte
An individually addressable unit of data storage that is exactly an octet, used to store a character or a portion of a
character; see also 3.58 Character. A byte is composed of a contiguous sequence of 8 bits. The least
significant bit is called the "low-order" bit; the most significant is called the "high-order" bit.
Note:
The definition of byte from the ISO C standard is broader than the above and might accommodate hardware architectures with
different sized addressable units than octets.
3.56 Byte Input/Output Functions
The functions that perform byte-oriented input from streams or byte-oriented output to streams: fgetc(), fgets(), fprintf(), fputc(), fputs(), fread(), fscanf(), fwrite(), getc(), getchar(), getdelim(), getline(), printf(), putc(), putchar(), puts(), scanf(), ungetc(), vfprintf(), and vprintf().
Note:
Functions are defined in detail in the System Interfaces volume of POSIX.1-2024.
3.57 Carriage-Return Character ()
A character that in the output stream indicates that printing should start at the beginning of the same physical line in which
the carriage-return occurred. It is the character designated by '\r' in the C language. It is unspecified whether this
character is the exact sequence transmitted to an output device by the system to accomplish the movement to the beginning of the
line.
3.58 Character
A sequence of one or more bytes representing a member of a character set.
Note:
This term corresponds to the ISO C standard term multi-byte character, where a single-byte character is a special case of
a multi-byte character. Unlike the usage in the ISO C standard, character here has no necessary relationship with
storage space, and byte is used when storage space is discussed.
See the definition of the portable character set in 6.1 Portable Character
Set for a further explanation of the graphical representations of (abstract) characters, as opposed to character
encodings.
3.59 Character Array
An array of elements of type char.
3.60 Character Class
A named set of characters sharing an attribute associated with the name of the class. The classes and the characters that they
contain are dependent on the value of the LC_CTYPE category in the current locale.
Note:
The LC_CTYPE category is defined in detail in 7.3.1
LC_CTYPE.
3.61 Character Set
A finite set of different characters used for the representation, organization, or control of data.
3.62 Character Special File
A file that refers to a device (such as a terminal device file) or that has special properties (such as /dev/null).
Note:
The General Terminal Interface is defined in detail in 11. General Terminal
Interface.
3.63 Character String
A contiguous sequence of characters terminated by and including the first null byte.
3.64 Child Process
A new process created (by fork(), posix_spawn(), or posix_spawnp()) by
a given process. A child process remains the child of the creating process as long as both processes continue to exist.
Note:
The fork(), posix_spawn(), and
posix_spawnp() functions are defined in detail in the System Interfaces volume
of POSIX.1-2024.
3.65 Circumflex Character ()
The character '^'.
3.66 Clock
A software or hardware object that can be used to measure the apparent or actual passage of time.
The current value of the time measured by a clock can be queried and, possibly, set to a value within the legal range of the
clock.
3.67 Clock Jump
The difference between two successive distinct values of a clock, as observed from the application via one of the "get time"
operations.
3.68 Clock Tick
An interval of time; an implementation-defined number of these occur each second. Clock ticks are one of the units that may be
used to express a value found in type clock_t.
3.69 Code Block
In the context of the System Interfaces volume of POSIX.1-2024, a block as defined in the ISO C standard.
3.70 Coded Character Set
A set of unambiguous rules that establishes a character set and the one-to-one relationship between each character of the set
and its bit representation.
3.71 Codeset
The result of applying rules that map a numeric code value to each element of a character set. An element of a character set may
be related to more than one numeric code value but the reverse is not true. However, for state-dependent encodings the relationship
between numeric code values and elements of a character set may be further controlled by state information. The character set may
contain fewer elements than the total number of possible numeric code values; that is, some code values may be unassigned.
Note:
Character Encoding is defined in detail in 6.2 Character Encoding
.
3.72 Collating Element
The smallest entity used to determine the logical ordering of character or wide-character strings; see also 3.74 Collation Sequence. A collating element consists of either a single character, or two or more characters
collating as a single entity. The value of the LC_COLLATE category in the current locale determines the current set of
collating elements.
3.73 Collation
The logical ordering of character or wide-character strings according to defined precedence rules. These rules identify a
collation sequence between the collating elements, and such additional rules that can be used to order strings consisting of
multiple collating elements.
3.74 Collation Sequence
The relative order of collating elements as determined by the setting of the LC_COLLATE category in the current locale.
The collation sequence is used for sorting and is determined from the collating weights assigned to each collating element. In the
absence of weights, the collation sequence is the order in which collating elements are specified between order_start and
order_end keywords in the LC_COLLATE category.
Multi-level sorting is accomplished by assigning elements one or more collation weights, up to the limit {COLL_WEIGHTS_MAX}. On
each level, elements may be given the same weight (at the primary level, called an equivalence class; see also 3.126 Equivalence Class) or be omitted from the sequence. Strings that collate equally using the first assigned
weight (primary ordering) are then compared using the next assigned weight (secondary ordering), and so on.
Note:
{COLL_WEIGHTS_MAX} is defined in detail in .
3.75 Column Position
A unit of horizontal measure related to characters in a line.
It is assumed that each character in a character set has an intrinsic column width independent of any output device. Each
printable character in the portable character set has a column width of one. The standard utilities, when used as described in
POSIX.1-2024, assume that all characters have integral column widths. The column width of a character is not necessarily related to
the internal representation of the character (numbers of bits or bytes).
The column position of a character in a line is defined as one plus the sum of the column widths of the preceding characters in
the line. Column positions are numbered starting from 1.
3.76 Command
A directive to the shell to perform a particular task.
Note:
Shell Commands are defined in detail in XCU 2.9 Shell Commands
.
3.77 Command Language Interpreter
An interface that interprets sequences of text input as commands. It may operate on an input stream or it may interactively
prompt and read commands from a terminal. It is possible for applications to invoke utilities through a number of interfaces, which
are collectively considered to act as command interpreters. The most obvious of these are the sh utility and the system() function, although
popen() and the various forms of exec may also be considered to behave as
interpreters.
Note:
The sh utility is defined in detail in the Shell and Utilities volume of
POSIX.1-2024.
The system(), popen(), and
exec functions are defined in detail in the System Interfaces volume of POSIX.1-2024.
3.78 Composite Graphic Symbol
A graphic symbol consisting of a combination of two or more other graphic symbols in a single character position, such as a
diacritical mark and a base character.
3.79 Condition Variable
A synchronization object which allows a thread to suspend execution, repeatedly, until some associated predicate becomes true. A
thread whose execution is suspended on a condition variable is said to be blocked on the condition variable.
There are two types of condition variable: those of type pthread_cond_t which are initialized using pthread_cond_init() and those of type cnd_t which are initialized using
cnd_init(). If an application attempts to use the two types interchangeably (that
is, pass a condition variable of type pthread_cond_t to a function that takes a cnd_t, or vice versa), the behavior
is undefined.
Note:
The pthread_cond_init() and cnd_init() functions are defined in detail in the System Interfaces volume of
POSIX.1-2024.
3.80 Connected Socket
A connection-mode socket for which a connection has been established, or a connectionless-mode socket for which a peer address
has been set. See also 3.81 Connection, 3.82 Connection Mode, 3.83 Connectionless Mode, and 3.342 Socket.
3.81 Connection
An association established between two or more endpoints for the transfer of data
3.82 Connection Mode
The transfer of data in the context of a connection; see also 3.83 Connectionless Mode.
3.83 Connectionless Mode
The transfer of data other than in the context of a connection; see also 3.82 Connection Mode and
3.96 Datagram.
3.84 Control Character
A character, other than a graphic character, that affects the recording, processing, transmission, or interpretation of
text.
3.85 Control Operator
In the shell command language, a token that performs a control function. It is one of the following symbols:
&   &&   (   )   ;   ;;   ;&   newline   |   ||
The end-of-input indicator used internally by the shell is also considered a control operator.
Note:
Token Recognition is defined in detail in XCU 2.3 Token Recognition
.
3.86 Controlling Process
The session leader that established the connection to the controlling terminal. If the terminal subsequently ceases to be a
controlling terminal for this session, the session leader ceases to be the controlling process.
3.87 Controlling Terminal
A terminal that is associated with a session. Each session may have at most one controlling terminal associated with it, and a
controlling terminal is associated with exactly one session. Certain input sequences from the controlling terminal cause signals to
be sent to all processes in the foreground process group associated with the controlling terminal.
Note:
The General Terminal Interface is defined in detail in 11. General Terminal
Interface.
3.88 Conversion Descriptor
A per-process unique value used to identify an open codeset conversion.
3.89 Core Image
An unspecified object of unspecified format that may be generated when a process terminates abnormally.
3.90 CPU Time (Execution Time)
The time spent executing a process or thread, including the time spent executing system services on behalf of that process or
thread. The value of the CPU-time clock for a process is implementation-defined. With this definition the sum of all the execution
times of all the threads in a process might not equal the process execution time, even in a single-threaded process, because
implementations may differ in how they account for time during context switches or for other reasons.
3.91 CPU-Time Clock
A clock that measures the execution time of a particular process or thread.
3.92 CPU-Time Timer
A timer attached to a CPU-time clock.
3.93 Current Job
In the context of job control, the job that will be used as the default for the fg or
bg utilities. There is at most one current job; see also 3.182 Job
ID.
3.94 Current Working Directory
See Working Directory in 3.421 Working Directory (or Current Working Directory).
3.95 Cursor Position
The line and column position on the screen denoted by the terminal's cursor.
3.96 Datagram
A unit of data transferred from one endpoint to another in connectionless mode service.
3.97 Data Race
A situation in which there are two conflicting actions in different threads, at least one of which is not atomic, and neither
"happens before" the other, where the "happens before" relation is defined formally in 4.15.1 Memory Ordering.
3.98 Data Segment
Memory associated with a process, that can contain dynamically allocated data.
3.99 Decimal-Point Character
See Radix Character in 3.294 Radix Character (or Decimal-Point Character).
3.100 Declaration Utility
A utility which can take arguments that cause variable assignments (of the form varname=value) which will persist in
the current shell environment. When the shell recognizes a declaration utility as the command name, subsequent arguments that would
be a valid variable assignment in isolation are subject to different expansion rules (field splitting and pathname expansion are
suppressed, and tilde expansion occurs after the  and any unquoted ). Arguments which are not a
valid variable assignment in isolation are processed according to normal argument expansion rules.
The following standard utilities are declaration utilities: export, readonly, and, under certain conditions, command. An implementation may provide other declaration utilities.
3.101 Device
A computer peripheral or an object that appears to the application as such.
3.102 Device ID
A non-negative integer used to identify a device.
3.103 Directory
A file that contains directory entries. No two directory entries in the same directory have the same name.
3.104 Directory Entry (or Hard Link)
An object that associates a filename with a file. Several directory entries can associate names with the same file.
3.105 Directory Stream
A sequence of all the directory entries in a particular directory. An open directory stream may be implemented using a file
descriptor.
3.106 Disarm (a Timer)
To stop a timer from measuring the passage of time, disabling any future process notifications (until the timer is armed
again).
3.107 Display
To output to the user's terminal. If the output is not directed to a terminal, the results are undefined.
3.108 Display Line
A line of text on a physical device or an emulation thereof. Such a line has a maximum number of characters which can be
presented.
Note:
This may also be written as "line on the display".
3.109 Dollar-Sign Character ()
The character '$'.
3.110 Dot
In the context of naming files, the filename consisting of a single  character ('.').
Note:
In the context of shell special built-in utilities, see dot in XCU
2.15 Special Built-In Utilities.
Pathname Resolution is defined in detail in 4.16 Pathname Resolution
.
3.111 Dot-Dot
The filename consisting solely of two  characters ("..").
Note:
Pathname Resolution is defined in detail in 4.16 Pathname Resolution
.
3.112 Dot-Po File
See Portable Messages Object Source File in 3.266 Portable Messages Object Source File (or Dot-Po
File).
3.113 Double-Quote Character
The character '"' , also known as .
Note:
The "double" adjective in this term refers to the two strokes in the character glyph. POSIX.1-2024 never uses the term
"double-quote" to refer to two apostrophes or quotation-marks.
3.114 Downshifting
The conversion of an uppercase character that has a single-character lowercase representation into this lowercase
representation.
3.115 Driver
A module that controls data transferred to and received from devices.
Note:
Drivers are traditionally written to be a part of the system implementation, although they are frequently written separately
from the writing of the implementation. A driver may contain processor-specific code, and therefore be non-portable.
3.116 Effective Group ID
An attribute of a process that is used in determining various permissions, including file access permissions; see also 3.165 Group ID.
3.117 Effective User ID
An attribute of a process that is used in determining various permissions, including file access permissions; see also 3.408 User ID.
3.118 Eight-Bit Transparency
The ability of a software component to process 8-bit characters without modifying or utilizing any part of the character in a
way that is inconsistent with the rules of the current coded character set.
3.119 Empty Directory
A directory that contains, at most, directory entries for dot and dot-dot, and has exactly one hard link to it other than its
own dot entry (if one exists), in dot-dot. No other hard links to the directory can exist. It is unspecified whether an
implementation can ever consider the root directory to be empty.
3.120 Empty Line
A line consisting of only a ; see also 3.46 Blank Line.
3.121 Empty String (or Null String)
A string whose first byte is a null byte.
3.122 Empty Wide-Character String
A wide-character string whose first element is a null wide-character code.
3.123 Encoding Rule
The rules used to convert between wide-character codes and multi-byte character codes.
Note:
Stream Orientation and Encoding Rules are defined in detail in XSH 2.5.2
Stream Orientation and Encoding Rules.
3.124 Entire Regular Expression
The concatenated set of one or more basic regular expressions or extended regular expressions that make up the pattern specified
for string selection.
Note:
Regular Expressions are defined in detail in 9. Regular Expressions
.
3.125 Epoch
The time zero hours, zero minutes, zero seconds, on January 1, 1970 Coordinated Universal Time (UTC).
Note:
See also Seconds Since the Epoch defined in 4.19 Seconds Since the
Epoch.
3.126 Equivalence Class
A set of collating elements with the same primary collation weight.
Elements in an equivalence class are typically elements that naturally group together, such as all accented letters based on the
same base letter.
The collation order of elements within an equivalence class is determined by the weights assigned on any subsequent levels after
the primary weight.
3.127 Era
A locale-specific method for counting and displaying years.
Note:
The LC_TIME category is defined in detail in 7.3.5 LC_TIME
.
3.128 Event Management
The mechanism that enables applications to register for and be made aware of external events such as data becoming available for
reading.
3.129 Executable File
A regular file acceptable as a new process image file by the equivalent of the exec family of functions, and thus usable
as one form of a utility. The standard utilities described as compilers can produce executable files, but other unspecified methods
of producing executable files may also be provided. The internal format of an executable file is unspecified, but a conforming
application cannot assume an executable file is a text file.
3.130 Execute
To perform command search and execution actions, as defined in the Shell and Utilities volume of POSIX.1-2024; see also 3.179 Invoke.
Note:
Command Search and Execution is defined in detail in XCU 2.9.1.4
Command Search and Execution.
3.131 Execution Time
See CPU Time in 3.90 CPU Time (Execution Time).
3.132 Execution Time Monitoring
A set of execution time monitoring primitives that allow online measuring of thread and process execution times.
3.133 Expand
In the shell command language, when not qualified, the act of applying word expansions.
Note:
Word Expansions are defined in detail in XCU 2.6 Word Expansions
.
3.134 Extended Regular Expression (ERE)
A regular expression (see also 3.308 Regular Expression) that is an alternative to the Basic Regular
Expression using a more extensive syntax, occasionally used by some utilities.
Note:
Extended Regular Expressions are described in detail in 9.4 Extended Regular
Expressions.
3.135 Extended Security Controls
Implementation-defined security controls allowed by the file access permission and appropriate privileges (see also 3.21 Appropriate Privileges) mechanisms, through which an implementation can support different security policies
from those described in POSIX.1-2024.
Note:
See also Extended Security Controls defined in 4.6 Extended Security
Controls.
File Access Permissions are defined in detail in 4.7 File Access
Permissions.
3.136 Feature Test Macro
A macro used to determine whether a particular set of features is included from a header.
Note:
See also XSH 2.2 The Compilation Environment.
3.137 Field
In the shell command language, a unit of text that is the result of parameter expansion, arithmetic expansion, command
substitution, or field splitting. During command processing, the resulting fields are used as the command name and its arguments.
Note:
Parameter Expansion is defined in detail in XCU 2.6.2 Parameter
Expansion.
Arithmetic Expansion is defined in detail in XCU 2.6.4 Arithmetic
Expansion.
Command Substitution is defined in detail in XCU 2.6.3 Command
Substitution.
Field Splitting is defined in detail in XCU 2.6.5 Field Splitting
.
For further information on command processing, see XCU 2.9.1 Simple
Commands.
3.138 FIFO Special File (or FIFO)
A type of file with the property that data written to such a file is read on a first-in-first-out basis.
Note:
Other characteristics of FIFOs are described in the System Interfaces volume of POSIX.1-2024, lseek(), open(), read(), and write().
3.139 File
An object that can be written to, or read from, or both. A file has certain attributes, including access permissions and type.
File types include regular file, character special file, block special file, FIFO special file, symbolic link, socket, and
directory. Other types of files may be supported by the implementation.
3.140 File Description
See Open File Description in 3.241 Open File Description.
3.141 File Descriptor
A per-process unique, non-negative integer used to identify an open file for the purpose of file access. The values 0, 1, and 2
have special meaning and conventional uses, and are referred to as standard input, standard output, and standard
error, respectively. Programs usually take their input from standard input, and write output on standard output. Diagnostic
messages are usually written on standard error. The value of a newly-created file descriptor is from zero to {OPEN_MAX}-1. A file
descriptor can have a value greater than or equal to {OPEN_MAX} if the value of {OPEN_MAX} has decreased (see sysconf()) since the file descriptor was opened. File descriptors may also be used to
implement message catalog descriptors and directory streams; see also 3.241 Open File Description.
Note:
{OPEN_MAX} is defined in detail in .
3.142 File Group Class
The property of a file indicating access permissions for a process related to the group identification of a process. A process
is in the file group class of a file if the process is not in the file owner class and if the effective group ID or one of the
supplementary group IDs of the process matches the group ID associated with the file. Other members of the class may be
implementation-defined.
3.143 File Lock
Any advisory lock, including a record lock (see 3.302 Record Lock), obtained on a file for the
purpose of coordinating transactions among cooperating processes accessing the same file with the same lock type. See also 3.237 OFD-Owned File Lock and 3.289 Process-Owned File Lock.
Note:
All file locks created by interfaces defined in this standard are record locks; however, implementations commonly also support
a file lock extension interface named flock(), which creates non-record locks (that is, a file lock that can only be held on
the whole file).
Note:
Advisory locks do not prevent a process with sufficient access permissions from modifying the file without taking locks.
3.144 File Mode
An object containing the file mode bits and some information about the file type of a file.
Note:
File mode bits and file types are defined in detail in
.
3.145 File Mode Bits
A file's file permission bits, set-user-ID-on-execution bit (S_ISUID), set-group-ID-on-execution bit (S_ISGID), and, on
directories, the restricted deletion flag bit (S_ISVTX).
Note:
File Mode Bits are defined in detail in .
3.146 Filename
A sequence of bytes consisting of 1 to {NAME_MAX} bytes used to name a file. The bytes composing the name shall not contain the
or  characters. In the context of a pathname, each filename shall be followed by a  or a
character; elsewhere, a filename followed by a  character forms a string (but not necessarily a character
string). The filenames dot and dot-dot have special meaning. A filename is sometimes referred to as a "pathname
component". See also 3.254 Pathname.
Note:
Pathname Resolution is defined in detail in 4.16 Pathname Resolution
.
3.147 Filename String
A string consisting of a filename followed by a  character.
3.148 File Offset
The byte position in the file where the next I/O operation begins. Each open file description associated with a regular file,
block special file, or directory has a file offset. A character special file that does not refer to a terminal device may have a
file offset. There is no file offset specified for a pipe or FIFO.
3.149 File Other Class
The property of a file indicating access permissions for a process related to the user and group identification of a process. A
process is in the file other class of a file if the process is not in the file owner class or file group class.
3.150 File Owner Class
The property of a file indicating access permissions for a process related to the user identification of a process. A process is
in the file owner class of a file if the effective user ID of the process matches the user ID of the file.
3.151 File Permission Bits
Information about a file that is used, along with other information, to determine whether a process has read, write, or
execute/search permission to a file. The bits are divided into three parts: owner, group, and other. Each part is used with the
corresponding file class of processes. These bits are contained in the file mode.
Note:
File modes are defined in detail in .
File Access Permissions are defined in detail in 4.7 File Access
Permissions.
3.152 File Serial Number
A per-file system unique identifier for a file.
3.153 File System
A collection of files and certain of their attributes. It provides a name space for file serial numbers referring to those
files.
3.154 File Type
See File in 3.139 File.
3.155 Filter
A command whose operation consists of reading data from standard input or a list of input files and writing data to standard
output. Typically, its function is to perform some transformation on the data stream.
3.156 First Open (of a File)
When a process opens a file that is not currently an open file within any process.
3.157 Flow Control
The mechanism employed by a communications provider that constrains a sending entity to wait until the receiving entities can
safely receive additional data without loss.
3.158 Foreground Job
In the context of the System Interfaces volume of POSIX.1-2024, a foreground process group (see 3.160
Foreground Process Group).
In the context of the shell, a job that the shell is waiting for before it executes further commands or, if interactive, prompts
for further commands.
Note:
See also 3.35 Background Job, 3.180 Job, and 3.362
Suspended Job.
3.159 Foreground Process
A process that is a member of a foreground process group.
3.160 Foreground Process Group
A process group whose member processes have certain privileges, denied to processes in background process groups, when accessing
their controlling terminal. Each session that has established a connection with a controlling terminal has at most one process
group of the session as the foreground process group of that controlling terminal.
Note:
The General Terminal Interface is defined in detail in 11. General Terminal
Interface.
Note:
See also 3.158 Foreground Job.
3.161 Foreground Process Group ID
The process group ID of the foreground process group.
3.162 Form-Feed Character ()
A character that in the output stream indicates that printing should start on the next page of an output device. It is the
character designated by '\f' in the C language. If the form-feed is not the first character of an output line, the result
is unspecified. It is unspecified whether this character is the exact sequence transmitted to an output device by the system to
accomplish the movement to the next page.
3.163 Graphic Character
A member of the graph character class of the current locale.
Note:
The graph character class is defined in detail in 7.3.1
LC_CTYPE.
3.164 Group Database
A system database that contains at least the following information for each group ID:
Group name
Numerical group ID
List of users allowed in the group
The list of users allowed in the group is used by the newgrp utility.
Note:
The newgrp utility is defined in detail in the Shell and Utilities volume of
POSIX.1-2024.
3.165 Group ID
A non-negative integer, which can be contained in an object of type gid_t, that is used to identify a group of system
users. Each system user is a member of at least one group. When the identity of a group is associated with a process, a group ID
value is referred to as a real group ID, an effective group ID, one of the supplementary group IDs, or a saved set-group-ID. The
value (gid_t)-1 shall not be a valid group ID, but does have a defined use in some interfaces defined in this standard.
3.166 Group Name
A string that is used to identify a group; see also 3.164 Group Database. To be portable across
conforming systems, the value is composed of characters from the portable filename character set. The  should
not be used as the first character of a portable group name.
3.167 Hard Limit
A system resource limitation that may be reset to a lesser or greater limit by a privileged process. A non-privileged process is
restricted to only lowering its hard limit.
3.168 Hard Link
See Directory Entry in 3.104 Directory Entry (or Hard Link). A file can have multiple hard links as a
result of an execution of the ln utility (without the -s option) or the link() function. This term is contrasted against symbolic link; see also 3.364 Symbolic Link.
3.169 Hole
A contiguous region of bytes within a file, all having the value of zero. Not all bytes with the value zero need belong to a
hole; however, all seekable files shall have a virtual hole starting at the current size of the file. A hole is typically created
via truncate(), or if an lseek() call
has been made to position beyond the end of a file and data subsequently written at that point, although it is up to the
implementation to define when sparse files can be created and with what granularity for the size of holes.
3.170 Home Directory
The directory specified by the HOME environment variable.
3.171 Host Byte Order
The arrangement of bytes in any integer type when using a specific machine architecture.
Note:
Two common methods of byte ordering are big-endian and little-endian. Big-endian is a format for storage of binary data in
which the most significant byte is placed first, with the rest in descending order. Little-endian is a format for storage or
transmission of binary data in which the least significant byte is placed first, with the rest in ascending order. See also
4.13 Host and Network Byte Orders.
3.172 Incomplete Line
A sequence of one or more non- characters at the end of the file.
3.173 Inf
A value representing +infinity or a value representing -infinity that can be stored in a floating type. Not all systems support
the Inf values.
3.174 Interactive Device
A terminal device.
Note:
This definition is intended to align with the ISO C standard's use of "interactive device".
3.175 Interactive Shell
A processing mode of the shell that is suitable for direct user interaction.
3.176 Internationalization
The provision within a computer program of the capability of making itself adaptable to the requirements of different native
languages, local customs, and coded character sets.
3.177 Interprocess Communication
A functionality enhancement to add a high-performance, deterministic interprocess communication facility for local
communication.
3.178 Intrinsic Utility
A utility that is not subject to a PATH search during command search, usually implemented as a regular built-in utility.
Note:
Intrinsic Utilities are defined in detail in XCU 1.7 Intrinsic
Utilities.
3.179 Invoke
To perform command search and execution actions, except that searching for shell functions and special built-in utilities is
suppressed; see also 3.130 Execute.
Note:
Command Search and Execution is defined in detail in XCU 2.9.1.4
Command Search and Execution.
3.180 Job
A background job, a foreground job, or a suspended job.
In the context of the shell, jobs are created when a list (see XCU 2.9.3
Lists) is executed while job control is enabled, and may be created when an asynchronous AND-OR list is executed while job
control is disabled.
Note:
Job control in the shell is defined in detail in XCU 2.11 Job
Control.
Note:
See also 3.35 Background Job, 3.158 Foreground Job, and 3.362 Suspended Job.
3.181 Job Control
A facility that allows users selectively to stop (suspend) the execution of processes and continue (resume) their execution at a
later point. The user typically employs this facility via the interactive interface jointly supplied by the terminal I/O driver and
a command interpreter.
The term is also used in connection with system interfaces that can be used by a command interpreter to implement job control
(see for example setpgid()).
Note:
Job control in the shell is defined in detail in XCU 2.11 Job
Control.
3.182 Job ID
A handle that is used to refer to a job. The job ID can be any of the forms shown in the following table:
Table: Job ID Formats
Job ID
Meaning
%%
Current job.
%+
Current job.
%-
%n
Job number n.
%string
Job whose command begins with string.
%?string
Job whose command contains string.
3.183 Joinable Thread
A thread that was created either using pthread_create() with
the detachstate attribute not set to PTHREAD_CREATE_DETACHED or using thrd_create(), and for which neither pthread_detach() nor pthread_join() has been called and returned zero, and neither thrd_detach() nor thrd_join() has been
called and returned thrd_success.
Note:
The pthread_attr_setdetachstate(), pthread_create(), pthread_detach(), pthread_join(),
thrd_create(), thrd_detach(),
and thrd_join() functions are defined in detail in the System Interfaces volume of
POSIX.1-2024.
3.184 Last Close (of a File)
When a process closes a file, resulting in the file not being an open file within any process.
3.185 Line
A sequence of zero or more non- characters plus a terminating  character.
3.186 Linger
The period of time before terminating a connection, to allow outstanding data to be transferred.
3.187 Link
In the context of the file hierarchy, either a hard link or a symbolic link.
In the context of the c17 utility, the action performed by the link
editor (or linker).
Note:
The c17 utility is defined in detail in the Shell and Utilities volume of
POSIX.1-2024.
3.188 Link Count
The number of directory entries that refer to a particular file.
3.189 Live Process
An address space with one or more threads executing within that address space, and the required system resources
for those threads.
Note:
Many of the system resources defined by POSIX.1-2024 are shared among all of the threads within a process. These include the
process ID, the parent process ID, process group ID, session membership, real, effective, and saved set-user-ID, real, effective,
and saved set-group-ID, supplementary group IDs, current working directory, root directory, file mode creation mask, and file
descriptors.
3.190 Live Thread
A single flow of control within a process. Each thread has its own thread ID, scheduling priority and policy,
errno value, floating point environment, thread-specific key/value bindings, and the required system resources to support a
flow of control. Anything whose address can be determined by a thread, including but not limited to static variables, storage
obtained via malloc(), directly addressable storage obtained through
implementation-defined functions, and automatic variables, are accessible to all live threads in the same process.
Note:
The malloc() function is defined in detail in the System Interfaces volume of
POSIX.1-2024.
3.191 Local Customs
The conventions of a geographical area or territory for such things as date, time, and currency formats.
3.192 Local Interprocess Communication (Local IPC)
The transfer of data between processes in the same system.
3.193 Locale
The definition of the subset of a user's environment that depends on language and cultural conventions.
Note:
Locales are defined in detail in 7. Locale.
3.194 Localization
The process of establishing information within a computer system specific to the operation of particular native
languages, local customs, and coded character sets.
3.195 Lock-Free Operation
An operation that does not require the use of a lock such as a mutex in order to avoid data races.
3.196 Login
The unspecified activity by which a user gains access to the system. Each login is associated with exactly one
login name.
3.197 Login Name
A user name that is associated with a login.
3.198 Map
To create an association between a page-aligned range of the address space of a process and some memory object,
such that a reference to an address in that range of the address space results in a reference to the associated memory object. The
mapped memory object is not necessarily memory-resident.
3.199 Matched
A state applying to a sequence of zero or more characters when the characters in the sequence correspond to a
sequence of characters defined by a basic regular expression or extended regular expression pattern.
Note:
Regular Expressions are defined in detail in 9. Regular Expressions
.
3.200 Memory Mapped Files
A facility to allow applications to access files as part of the address space.
3.201 Memory Object
One of:
A file (see 3.139 File)
An anonymous memory object (see 3.16 Anonymous Memory Object)
A shared memory object (see 3.332 Shared Memory Object)
A typed memory object (see 3.401 Typed Memory Object)
When used in conjunction with mmap(), a memory object appears in the
address space of the calling process.
Note:
The mmap() function is defined in detail in the System Interfaces volume of
POSIX.1-2024.
3.202 Memory-Resident
The process of managing the implementation in such a way as to provide an upper bound on memory access times.
3.203 Message
In the context of programmatic message passing, information that can be transferred between processes or threads by
being added to and removed from a message queue. A message consists of a fixed-size message buffer.
3.204 Message Catalog
In the context of providing natural language messages to the user, a file or storage area containing program
messages, command prompts, and responses to prompts for a particular native language, territory, and codeset.
3.205 Message Catalog Descriptor
In the context of providing natural language messages to the user, a per-process unique value used to identify an
open message catalog. A message catalog descriptor may be implemented using a file descriptor.
3.206 Message Queue
In the context of programmatic message passing, an object to which messages can be added and removed. Messages may
be removed in the order in which they were added or in priority order.
3.207 Messages Object
A file containing message identifiers and translations in an unspecified format. Used by the gettext family
of functions and the gettext and ngettext utilities for internationalization and localization of programs and scripts.
Messages objects have the filename suffix .mo, and can be created by the msgfmt utility.
See also 3.386 Text Domain.
3.208 Mode
A collection of attributes that specifies a file's type and its access permissions.
Note:
File Access Permissions are defined in detail in 4.7 File Access
Permissions.
3.209 Monotonic Clock
A clock measuring real time, whose value cannot be set via clock_settime() and which cannot have negative clock jumps.
3.210 Mount Point
Either the system root directory or a directory for which the st_dev field of structure stat differs
from that of its parent directory.
Note:
The stat structure is defined in detail in .
3.211 Multi-Character Collating Element
A sequence of two or more characters that collate as an entity. For example, in some coded character sets, an
accented character is represented by a non-spacing accent, followed by the letter. Other examples are the Spanish elements
ch and ll.
3.212 Multi-Threaded Library
A library containing object files that were produced by compiling with c17 using the flags output by getconf
POSIX_V8_THREADS_CFLAGS, or by compiling using a non-standard utility with equivalent flags, and which makes use of interfaces that
are only made available by c17 when the -l pthread option is used or makes use of
SIGEV_THREAD notifications.
3.213 Multi-Threaded Process
A process that contains more than one thread.
3.214 Multi-Threaded Program
A program whose executable file was produced by compiling with c17 using
the flags output by getconf POSIX_V8_THREADS_CFLAGS, and linking with c17 using the flags output by getconf
POSIX_V8_THREADS_LDFLAGS and the -l pthread option, or by compiling and linking using a non-standard utility with equivalent
flags. Execution of a multi-threaded program initially creates a single-threaded process; the process can create additional threads
using pthread_create(), thrd_create(), or SIGEV_THREAD notifications.
3.215 Mutex
A synchronization object used to allow multiple threads to serialize their access to shared data. The name derives
from the capability it provides; namely, mutual-exclusion. The thread that has locked a mutex becomes its owner and remains the
owner until that same thread unlocks the mutex.
There are two types of mutex: those of type pthread_mutex_t which are initialized using pthread_mutex_init() and those of type mtx_t which are initialized using
mtx_init(). If an application attempts to use the two types interchangeably (that
is, pass a mutex of type pthread_mutex_t to a function that takes a mtx_t, or vice versa), the behavior is undefined.
Note:
The pthread_mutex_init() and mtx_init() functions are defined in detail in the System Interfaces volume of
POSIX.1-2024.
3.216 Name
In the shell command language, a word consisting solely of underscores, digits, and alphabetics from the portable
character set. The first character of a name is not a digit.
Note:
The Portable Character Set is defined in detail in 6.1 Portable Character
Set.
3.217 NaN (Not a Number)
A set of values that may be stored in a floating type but that are neither Inf nor valid floating-point numbers.
Not all systems support NaN values.
3.218 Native Language
A computer user's spoken or written language, such as American English, British English, Danish, Dutch, French,
German, Italian, Japanese, Norwegian, or Swedish.
3.219 Negative
When describing a value (not a sign), less than zero. Note that in the phrase "negative zero" it describes a
sign, and therefore negative zero (also represented as -0.0) is not a negative value.
3.220 Negative Response
An input string that matches one of the responses acceptable to the LC_MESSAGES category keyword
noexpr, matching an extended regular expression in the current locale.
Note:
The LC_MESSAGES category is defined in detail in 7.3.6
LC_MESSAGES.
3.221 Network
A collection of interconnected hosts.
Note:
The term "network" in POSIX.1-2024 is used to refer to the network of hosts. The term "batch system" is used to refer to
the network of batch servers.
3.222 Network Address
A network-visible identifier used to designate specific endpoints in a network. Specific endpoints on host systems
have addresses, and host systems may also have addresses.
3.223 Network Byte Order
The way of representing any integer type such that, when transmitted over a network via a network endpoint, the
int type is transmitted as an appropriate number of octets with the most significant octet first, followed by any other
octets in descending order of significance.
Note:
This order is more commonly known as big-endian ordering. See also 4.13 Host
and Network Byte Orders.
3.224 Newline Character ()
A character that in the output stream indicates that printing should start at the beginning of the next line. It is
the character designated by '\n' in the C language. It is unspecified whether this character is the exact sequence
transmitted to an output device by the system to accomplish the movement to the next line.
3.225 Nice Value
A number used as advice to the system to alter process scheduling. Numerically smaller values give a process
additional preference when scheduling a process to run. Numerically larger values reduce the preference and make a process less
likely to run. Typically, a process with a smaller nice value runs to completion more quickly than an equivalent process with a
higher nice value. The symbol {NZERO} specifies the default nice value of the system.
3.226 Non-Blocking
A property of an open file description that causes function calls involving it to return without delay when it is
detected that the requested action associated with the function call cannot be completed without unknown delay.
Note:
The exact semantics are dependent on the type of file associated with the open file description. For data reads from devices
such as ttys and FIFOs, this property causes the read to return immediately when no data was available. Similarly, for writes, it
causes the call to return immediately when the thread would otherwise be delayed in the write operation; for example, because no
space was available. For networking, it causes functions not to await protocol events (for example, acknowledgements) to occur. See
also XSH 2.10.7 Socket I/O Mode.
3.227 Non-Spacing Characters
A character, such as a character representing a diacritical mark in the ISO/IEC 6937:2001 standard coded
graphic character set, which is used in combination with other characters to form composite graphic symbols.
3.228 NUL
A character with all bits set to zero.
3.229 Null Byte
A byte with all bits set to zero.
3.230 Null Pointer
A pointer obtained by converting an integer constant expression with the value 0, or such an expression cast to
type void *, to a pointer type; for example, (char *)0. The C language guarantees that a null pointer compares
unequal to a pointer to any object or function, so it is used by many functions that return pointers to indicate an error.
POSIX.1-2024 additionally guarantees that any pointer object whose representation has all bits set to zero, perhaps by memset() to 0 or by calloc(), is interpreted as
a null pointer.
3.231 Null String
See Empty String in 3.121 Empty String (or Null String).
3.232 Null Terminator
A term used for the null byte when used as a terminator for a string.
3.233 Null Wide-Character Code
A wide-character code with all bits set to zero.
3.234 Number-Sign Character ()
The character '#', also known as hash sign.
3.235 Object File
A regular file containing the output of a compiler, formatted as input to a linkage editor for linking with other
object files into an executable form. The methods of linking are unspecified and may involve the dynamic linking of objects at
runtime. The internal format of an object file is unspecified, but a conforming application cannot assume an object file is a text
file.
3.236 Octet
Unit of data representation that consists of eight contiguous bits.
3.237 OFD-Owned File Lock
A record lock owned by an open file description. OFD-owned file locks are obtained through the use of fcntl() with F_OFD_SETLK or F_OFD_SETLKW. Whenever a file descriptor associated with the
owning open file description is inherited these locks remain in effect. OFD-owned file locks are automatically released on the last
close of the open file description. These locks are only shared among file descriptors associated with the same open file
description. Thus, a multi-threaded process can use multiple open file descriptions (such as by open()) to create independent OFD-owned locks that can then be used to coordinate access
patterns to the same file, while multiple file descriptors associated with the same open file description (such as by dup()) share lock actions among all other descriptors associated with the same open file
description.
3.238 Offset Maximum
An attribute of an open file description representing the largest value that can be used as a file offset.
3.239 Opaque Address
An address such that the entity making use of it requires no details about its contents or format.
3.240 Open File
A file that is currently associated with a file descriptor.
3.241 Open File Description
A record of how a process or group of processes is accessing a file. Each file descriptor refers to exactly one
open file description, but an open file description can be referred to by more than one file descriptor. The file offset, file
status, and file access modes are attributes of an open file description.
3.242 Operand
An argument to a command that is generally used as an object supplying information to a utility necessary to
complete its processing. Operands generally follow the options in a command line.
Note:
Utility Argument Syntax is defined in detail in 12.1 Utility Argument
Syntax.
3.243 Operator
In the shell command language, either a control operator or a redirection operator.
3.244 Option
An argument to a command that is generally used to specify changes in the utility's default behavior.
Note:
Utility Argument Syntax is defined in detail in 12.1 Utility Argument
Syntax.
3.245 Option-Argument
A parameter that follows certain options. In some cases an option-argument immediately follows the option character
within the same argument string as the option; otherwise the option-argument is the next argument string.
Note:
Utility Argument Syntax is defined in detail in 12.1 Utility Argument
Syntax.
3.246 Orientation
A stream has one of three orientations: unoriented, byte-oriented, or wide-oriented.
Note:
For further information, see XSH 2.5.2 Stream Orientation and Encoding
Rules.
3.247 Orphaned Process Group
A process group in which the parent of every member is either itself a member of the group or is not a member of
the group's session.
3.248 Page
The granularity of process memory mapping or locking.
Physical memory and memory objects can be mapped into the address space of a process on page boundaries and in
integral multiples of pages. Process address space can be locked into memory (made memory-resident) on page boundaries and in
integral multiples of pages.
3.249 Page Size
The size, in bytes, of the system unit of memory allocation, protection, and mapping. On systems that have segment
rather than page-based memory architectures, the term "page" means a segment.
3.250 Parameter
In the shell command language, an entity that stores values. There are three types of parameters: variables (named
parameters), positional parameters, and special parameters. Parameter expansion is accomplished by introducing a parameter with the
'$' character.
Note:
See also XCU 2.5 Parameters and Variables.
In the C language, an object declared as part of a function declaration or definition that acquires a value on
entry to the function, or an identifier following the macro name in a function-like macro definition.
3.251 Parent Directory
When discussing a given directory, the directory that both contains a directory entry for the given directory and
is represented by the pathname dot-dot in the given directory.
When discussing other types of files, a directory containing a directory entry for the file under discussion.
This concept does not apply to dot and dot-dot.
3.252 Parent Process
The process which created (or inherited) the process under discussion.
3.253 Parent Process ID
An attribute of a new process identifying the parent of the process. The parent process ID of a process is the
process ID of its creator, for the lifetime of the creator. After the creator's lifetime has ended, the parent process ID is the
process ID of an implementation-defined system process.
3.254 Pathname
A string that is used to identify a file. In the context of POSIX.1-2024, a pathname may be limited to {PATH_MAX}
bytes, including the terminating null byte. It has optional beginning  characters, followed by zero or more filenames
separated by  characters. A pathname can optionally contain one or more trailing  characters. Multiple
successive  characters are considered to be the same as one , except it is implementation-defined whether
the case of exactly two leading  characters is treated specially.
Note:
If a pathname consists of only bytes corresponding to characters from the portable filename character set (see 3.265 Portable Filename Character Set),  characters, and a single terminating
character, the pathname will be usable as a character string in all supported locales; otherwise, the pathname might only be a
string (rather than a character string). Additionally, since the single-byte encoding of the  character is required to
be the same across all locales and to not occur within a multi-byte character, references to a  character within a
pathname are well-defined even when the pathname is not a character string. However, this property does not necessarily hold for
the remaining characters within the portable filename character set.
Pathname Resolution is defined in detail in 4.16 Pathname
Resolution.
3.255 Pathname Component
See Filename in 3.146 Filename.
3.256 Path Prefix
The part of a pathname up to, but not including, the last component and any trailing  characters,
unless the pathname consists entirely of  characters, in which case the path prefix is '/' for a pathname
containing either a single  or three or more  characters, and '//' for the pathname //.
The path prefix of a pathname containing no  characters is empty, but is treated as referring to the current working
directory.
Note:
The term is used both in the sense of identifying part of a pathname that forms the prefix and of joining a non-empty path
prefix to a filename to form a pathname. In the latter case, the path prefix need not have a trailing  (in which case
the joining is done with a  character).
3.257 Pattern
A sequence of characters used either with regular expression notation or with shell pattern matching notation.
Note:
Regular Expressions are defined in detail in 9. Regular Expressions.
Shell pattern matching notation is defined in detail in 2.14
Pattern Matching Notation.
The syntaxes of the two types of patterns are similar, but not identical; POSIX.1-2024 always indicates the type of
pattern being referred to in the immediate context of the use of the term.
3.258 Period Character ()
The character '.'. The term "period" is contrasted with dot (see also 3.110
Dot), which is used to describe a specific directory entry.
3.259 Permissions
Attributes of an object that determine the privilege necessary to access or manipulate the object.
Note:
File Access Permissions are defined in detail in 4.7 File Access
Permissions.
3.260 Persistence
A mode for semaphores, shared memory, and message queues requiring that the object and its state (including data,
if any) are preserved after the object is no longer referenced by any process.
Persistence of an object does not imply that the state of the object is maintained across a system crash or a
system reboot.
3.261 Pipe
An object identical to a FIFO which has no links in the file hierarchy.
Note:
The pipe() function is defined in detail in the System Interfaces volume of
POSIX.1-2024.
3.262 Polling
A scheduling scheme whereby the local process periodically checks until the pre-specified events (for example,
read, write) have occurred.
3.263 Portable Character Set
The collection of characters that are required to be present in all locales supported by conforming systems.
Note:
The Portable Character Set is defined in detail in 6.1 Portable Character
Set.
This term is contrasted against the smaller portable filename character set; see also 3.265
Portable Filename Character Set.
3.264 Portable Filename
A filename consisting only of characters from the portable filename character set.
Note:
Applications should avoid using filenames that have the  character as the first character since this may
cause problems when filenames are passed as command line arguments.
3.265 Portable Filename Character Set
The set of characters from which portable filenames are constructed.
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
a b c d e f g h i j k l m n o p q r s t u v w x y z
0 1 2 3 4 5 6 7 8 9 . _ -
The last three characters are the , , and  characters,
respectively. See also 3.254 Pathname.
3.266 Portable Messages Object Source File (or Dot-Po File)
A text file containing messages and directives. A portable messages object source file can be compiled into a
messages object by the msgfmt utility.
Note:
By convention, portable messages object source files have filenames ending with the .po suffix. Utility descriptions in
this standard frequently use dot-po file as a shorthand for portable messages object source file (even though the .po suffix
need not be included in the filename). Template portable messages object source files can be created from C-language source files
by the xgettext utility.
3.267 Positional Parameter
In the shell command language, a parameter denoted by a decimal representation of a positive integer.
Note:
For further information, see XCU 2.5.1 Positional Parameters
.
3.268 Positive
When describing a value (not a sign), greater than zero. Note that in the common phrase "positive zero" (which is
not used in this standard, although the representation +0.0 is) it describes a sign, and therefore positive zero (+0.0) is not a
positive value.
3.269 Preallocation
The reservation of resources in a system for a particular use.
Preallocation does not imply that the resources are immediately allocated to that use, but merely indicates that
they are guaranteed to be available in bounded time when needed.
3.270 Preempted Process (or Thread)
A running thread whose execution is suspended due to another thread becoming runnable at a higher priority.
3.271 Previous Job
In the context of job control, the job used as the default for the fg or
bg utilities if the current job exits. There is at most one previous job; see also
3.182 Job ID.
3.272 Printable Character
One of the characters included in the print character classification of the LC_CTYPE category in the
current locale.
Note:
The LC_CTYPE category is defined in detail in 7.3.1
LC_CTYPE.
3.273 Printable File
A text file consisting only of the characters included in the print and space character
classifications of the LC_CTYPE category and the , all in the current locale.
Note:
The LC_CTYPE category is defined in detail in 7.3.1
LC_CTYPE.
3.274 Priority
A non-negative integer associated with processes or threads whose value is constrained to a range defined by the
applicable scheduling policy. Numerically higher values represent higher priorities.
3.275 Priority Inversion
A condition in which a thread that is not voluntarily suspended (waiting for an event or time delay) is not running
while a lower priority thread is running. Such blocking of the higher priority thread is often caused by contention for a shared
resource.
3.276 Priority Scheduling
A performance and determinism improvement facility to allow applications to determine the order in which threads
that are ready to run are granted access to processor resources.
3.277 Priority-Based Scheduling
Scheduling in which the selection of a running thread is determined by the priorities of the runnable processes or
threads.
3.278 Privilege
See Appropriate Privileges in 3.21 Appropriate Privileges.
3.279 Process
A live process (see 3.189 Live Process) or a zombie process (see 3.426 Zombie Process). The lifetime of a process is described in 3.285 Process
Lifetime.
3.280 Process Group
A collection of processes that permits the signaling of related processes. Each process in the system is a member
of a process group that is identified by a process group ID. A newly created process joins the process group of its creator.
3.281 Process Group ID
The unique positive integer identifier representing a process group during its lifetime.
Note:
See also Process Group ID Reuse defined in 4.17 Process ID
Reuse.
3.282 Process Group Leader
A process whose process ID is the same as its process group ID.
3.283 Process Group Lifetime
The period of time that begins when a process group is created and ends when the last remaining process in the
group leaves the group, due either to the end of the lifetime of the last process or to the last remaining process calling the
setsid() or setpgid() functions.
Note:
The setsid() and setpgid()
functions are defined in detail in the System Interfaces volume of POSIX.1-2024.
3.284 Process ID
The unique positive integer identifier representing a process during its lifetime.
Note:
See also Process ID Reuse defined in 4.17 Process ID Reuse
.
3.285 Process Lifetime
The period of time that begins when a process is created and ends when its process ID is returned to the
system.
See also 3.189 Live Process, 3.287 Process Termination, and
3.426 Zombie Process.
Note:
Process creation is defined in detail in the descriptions of the fork(), posix_spawn(), and posix_spawnp()
functions in the System Interfaces volume of POSIX.1-2024.
3.286 Process Memory Locking
A performance improvement facility to bind application programs into the high-performance random access memory of a
computer system. This avoids potential latencies introduced by the operating system in storing parts of a program that were not
recently referenced on secondary memory devices.
3.287 Process Termination
There are two kinds of process termination:
Normal termination occurs by a return from main(), when requested with the exit(), _exit(), or _Exit() functions; or when the last thread in the process terminates by returning from its
start function, by calling the pthread_exit() or thrd_exit() function, or through cancellation.
Abnormal termination occurs when requested by the abort() function or
when some signals are received.
Note:
The consequences of process termination can be found in the description of the _Exit() function in the System Interfaces volume of POSIX.1-2024. The _exit(), _Exit(), abort(), and exit() functions are defined in
detail in the System Interfaces volume of POSIX.1-2024.
3.288 Process Virtual Time
The measurement of time in units elapsed by the system clock while a process is executing.
3.289 Process-Owned File Lock
A record lock owned by a process. Process-owned file locks are obtained through the use of fcntl() with F_SETLK or F_SETLKW, or the use of lockf(). Process-owned file locks are not inherited by child processes, but are preserved
across the exec family of functions. A process-owned file lock is released when the process exits, or when any file
descriptor in the process referring to the same file is closed (even if via a different open file description). These locks are
shared among all open file descriptions referring to the same file in the process, making the use of process-owned file locks
unsuitable for use for coordination of record access among multiple threads in a process.
3.290 Process-To-Process Communication
The transfer of data between processes.
3.291 Program
A prepared sequence of instructions to the system to accomplish a defined task. The term "program" in
POSIX.1-2024 encompasses applications written in the Shell Command Language, complex utility input languages (for example, awk, lex, sed, and so on), and high-level languages.
3.292 Protocol
A set of semantic and syntactic rules for exchanging information.
3.293 Pseudo-Terminal
A facility that provides an interface that is identical to the terminal subsystem, except where noted otherwise in
POSIX.1-2024. A pseudo-terminal is composed of two devices: the "manager device" and a "subsidiary device". The subsidiary
device provides processes with an interface that is identical to the terminal interface, although there need not be hardware behind
that interface. Anything written on the manager device is presented to the subsidiary as an input and anything written on the
subsidiary device is presented as an input on the manager side.
3.294 Radix Character (or Decimal-Point Character)
The character that separates the integer part of a number from the fractional part.
3.295 Read-Only File System
A file system that has implementation-defined characteristics restricting modifications.
Note:
File Times Update is described in detail in 4.12 File Times Update
.
3.296 Read-Write Lock
Multiple readers, single writer (read-write) locks allow many threads to have simultaneous read-only access to data
while allowing only one thread to have write access at any given time. They are typically used to protect data that is read-only
more frequently than it is changed.
Read-write locks can be used to synchronize threads in the current process and other processes if they are
allocated in memory that is writable and shared among the cooperating processes and have been initialized for this behavior.
3.297 Real Group ID
The attribute of a process that, at the time of process creation, identifies the group of the user who created the
process; see also 3.165 Group ID.
3.298 Real Time
Time measured as total units elapsed by the system clock without regard to which thread is executing.
3.299 Realtime Signal Extension
A determinism improvement facility to enable asynchronous signal notifications to an application to be queued
without impacting compatibility with the existing signal functions.
3.300 Real User ID
The attribute of a process that, at the time of process creation, identifies the user who created the process; see
also 3.408 User ID.
3.301 Record
A collection of related data units or words which is treated as a unit.
3.302 Record Lock
A file lock held on a record within a file. A record lock can be used to lock a whole file by specifying a special
record with starting offset zero and length zero. (This special record extends to any future end-of-file, not just the current
end-of-file.) This includes an OFD-owned file lock (see 3.237 OFD-Owned File Lock) or a process-owned
file lock (see 3.289 Process-Owned File Lock). It is unspecified whether an implementation will detect
and prevent deadlocks caused by two competing lock owners holding separate locks where each tries to obtain a lock that is blocked
by the other's lock.
3.303 Redirection
In the shell command language, a method of associating files with the input or output of commands.
Note:
For further information, see XCU 2.7 Redirection.
3.304 Redirection Operator
In the shell command language, a token that performs a redirection function. It is one of the following
symbols:
>|     >     &
3.305 Referenced Shared Memory Object
A shared memory object that is open or has one or more mappings defined on it.
3.306 Refresh
Make the information on the user's terminal screen up-to-date.
3.307 Regular Built-In Utility (or Regular Built-In)
See Built-In Utility in 3.54 Built-In Utility (or Built-In).
3.308 Regular Expression
A pattern that selects specific strings from a set of character strings.
Note:
Regular Expressions are described in detail in 9. Regular Expressions
.
3.309 Region
In the context of the address space of a process, a sequence of addresses.
In the context of a file, a sequence of offsets.
3.310 Regular File
A file that is a randomly accessible sequence of bytes, with no further structure imposed by the system.
3.311 Relative Pathname
A pathname not beginning with a  character.
Note:
Pathname Resolution is defined in detail in 4.16 Pathname Resolution
.
3.312 Relocatable File
A file holding code or data suitable for linking with other object files to create an executable or a shared object
file.
3.313 Relocation
The process of connecting symbolic references with symbolic definitions. For example, when a program calls a
function, the associated call instruction transfers control to the proper destination address at execution.
3.314 (Time) Resolution
The minimum time interval that a clock can measure or whose passage a timer can detect.
3.315 Robust Mutex
A mutex with the robust attribute set.
Note:
The robust attribute is defined in detail by the pthread_mutexattr_getrobust() function.
3.316 Root Directory
A directory, associated with a process, that is used in pathname resolution for pathnames that begin with a
character.
3.317 Runnable Process (or Thread)
A thread that is capable of being a running thread, but for which no processor is available.
3.318 Running Process (or Thread)
A thread currently executing on a processor. On multi-processor systems there may be more than one such thread in a
system at a time.
3.319 Saved Resource Limits
An attribute of a process that provides some flexibility in the handling of unrepresentable resource limits, as
described in the exec family of functions and setrlimit().
Note:
The exec and setrlimit() functions are defined in detail in the System
Interfaces volume of POSIX.1-2024.
3.320 Saved Set-Group-ID
An attribute of a process that allows some flexibility in the assignment of the effective group ID attribute, as
described in the exec family of functions and setgid().
Note:
The exec and setgid() functions are defined in detail in the System
Interfaces volume of POSIX.1-2024.
3.321 Saved Set-User-ID
An attribute of a process that allows some flexibility in the assignment of the effective user ID attribute, as
described in the exec family of functions and setuid().
Note:
The exec and setuid() functions are defined in detail in the System
Interfaces volume of POSIX.1-2024.
3.322 Scheduling
The application of a policy to select a runnable process or thread to become a running process or thread, or to
alter one or more of the thread lists.
3.323 Scheduling Allocation Domain
The set of processors on which an individual thread can be scheduled at any given time.
3.324 Scheduling Contention Scope
A property of a thread that defines the set of threads against which that thread competes for resources.
For example, in a scheduling decision, threads sharing scheduling contention scope compete for processor resources.
In POSIX.1-2024, a thread has scheduling contention scope of either PTHREAD_SCOPE_SYSTEM or PTHREAD_SCOPE_PROCESS.
3.325 Scheduling Policy
A set of rules that is used to determine the order of execution of processes or threads to achieve some goal.
Note:
Scheduling Policy is defined in detail in 4.18 Scheduling Policy
.
3.326 Screen
A rectangular region of columns and lines on a terminal display. A screen may be a portion of a physical display
device or may occupy the entire physical area of the display device.
3.327 Scroll
To move the representation of data vertically or horizontally relative to the terminal screen. There are two types
of scrolling:
The cursor moves with the data.
The cursor remains stationary while the data moves.
3.328 Semaphore
A minimum synchronization primitive to serve as a basis for more complex synchronization mechanisms to be defined
by the application program.
Note:
Semaphores are defined in detail in 4.20 Semaphore.
3.329 Session
A collection of process groups established for job control purposes. Each process group is a member of a session. A
process is considered to be a member of the session of which its process group is a member. A newly created process joins the
session of its creator. A process can alter its session membership; see setsid().
There can be multiple process groups in the same session.
Note:
The setsid() function is defined in detail in the System Interfaces volume of
POSIX.1-2024.
3.330 Session Leader
A process that has created a session.
Note:
For further information, see the setsid() function defined in the System
Interfaces volume of POSIX.1-2024.
3.331 Session Lifetime
The period between when a session is created and the end of the lifetime of all the process groups that remain as
members of the session.
3.332 Shared Memory Object
An object that represents memory that can be mapped concurrently into the address space of more than one
process.
3.333 Shell
A program that interprets sequences of text input as commands. It may operate on an input stream or it may
interactively prompt and read commands from a terminal.
3.334 Shell, the
The Shell Command Language Interpreter; a specific instance of a shell.
Note:
For further information, see the sh utility defined in the Shell and Utilities volume
of POSIX.1-2024.
3.335 Shell Script
A file containing shell commands. If the file is made executable, it can be executed by specifying its name as a
simple command. Execution of a shell script causes a shell to execute the commands within the script. Alternatively, a shell can be
requested to execute the commands in a shell script by specifying the name of the shell script as the operand to the sh utility.
Note:
Simple Commands are defined in detail in XCU 2.9.1 Simple
Commands.
The sh utility is defined in detail in the Shell and Utilities volume of
POSIX.1-2024.
3.336 Signal
A mechanism by which a process or thread may be notified of, or affected by, an event occurring in the system.
Examples of such events include hardware exceptions and specific actions by processes. The term signal is also used to refer to the
event itself.
3.337 Signal Stack
Memory established for a thread, in which signal handlers catching signals sent to that thread are executed.
3.338 Single-Quote Character
The character designated by '\'' in the C language, also known as .
3.339 Single-Threaded Process
A process that contains a single thread.
3.340 Single-Threaded Program
A program whose executable file was produced by compiling with c17
without using the flags output by getconf POSIX_V8_THREADS_CFLAGS and linking with
c17 using neither the flags output by getconf POSIX_V8_THREADS_LDFLAGS nor the -l pthread option, or by compiling and
linking using a non-standard utility with equivalent flags. Execution of a single-threaded program creates a single-threaded
process; if the process attempts to create additional threads using pthread_create(), thrd_create(),
or SIGEV_THREAD notifications, the behavior is undefined. If the process uses dlopen() to load a multi-threaded library, the behavior is undefined.
3.341 Slash Character ()
The character '/', also known as solidus.
3.342 Socket
A file of a particular type that is used as a communications endpoint for process-to-process communication as
described in the System Interfaces volume of POSIX.1-2024.
3.343 Socket Address
An address associated with a socket or remote endpoint, including an address family identifier and addressing
information specific to that address family. The address may include multiple parts, such as a network address associated with a
host system and an identifier for a specific endpoint.
3.344 Soft Limit
A resource limitation established for each process that the process may set to any value less than or equal to the
hard limit.
3.345 Source Code
When dealing with the Shell Command Language, input to the command language interpreter. The term "shell script"
is synonymous with this meaning.
When dealing with an ISO/IEC-conforming programming language, source code is input to a compiler conforming to that
ISO/IEC standard.
Source code also refers to the input statements prepared for the following standard utilities: awk, bc, ed,
ex, lex, localedef, make, sed, and yacc.
Source code can also refer to a collection of sources meeting any or all of these meanings.
Note:
The awk, bc, ed, ex, lex,
localedef, make, sed, and yacc utilities are defined in detail in the
Shell and Utilities volume of POSIX.1-2024.
3.346 Space Character ()
The character defined in the portable character set as . The  character is a member of
the space character class of the current locale, but represents the single character, and not all of the possible members of
the class; see also 3.413 White Space.
3.347 Sparse File
A file that contains more holes than just the virtual hole at the end of the file.
3.348 Spawn
A process creation primitive useful for systems that have difficulty with fork() and as an efficient replacement for fork()/exec.
3.349 Special Built-In Utility (or Special Built-In)
See Built-In Utility in 3.54 Built-In Utility (or Built-In).
3.350 Special Parameter
In the shell command language, a parameter named by a single character from the following list:
*   @   #   ?   !   -   $   0
Note:
For further information, see XCU 2.5.2 Special Parameters.
3.351 Spin Lock
A synchronization object used to allow multiple threads to serialize their access to shared data.
3.352 Sporadic Server
A scheduling policy for threads and processes that reserves a certain amount of execution capacity for processing
aperiodic events at a given priority level.
3.353 Standard Error
In the context of file descriptors (see 3.141 File Descriptor), file descriptor number
2.
In the context of standard I/O streams (see XSH 2.5 Standard I/O
Streams), an output stream usually intended to be used for diagnostic messages, and accessed using the global variable
stderr.
Note:
The file descriptor underlying stderr is initially 2, but it can be changed by freopen() to 0 or 1 (and implementations may have extensions that allow it to be changed to
other numbers). Therefore, writing to the standard error stream does not always produce output on the standard error file
descriptor.
3.354 Standard Input
In the context of file descriptors (see 3.141 File Descriptor), file descriptor number
0.
In the context of standard I/O streams (see XSH 2.5 Standard I/O
Streams), an input stream usually intended to be used for primary data input, and accessed using the global variable
stdin.
Note:
The file descriptor underlying stdin is initially 0; this cannot change through the use of interfaces defined in this
standard, but implementations may have extensions that allow it to be changed. Therefore, in conforming applications using
extensions, reading from the standard input stream does not always obtain input from the standard input file descriptor.
3.355 Standard Output
In the context of file descriptors (see 3.141 File Descriptor), file descriptor number
1.
In the context of standard I/O streams (see XSH 2.5 Standard I/O
Streams), an output stream usually intended to be used for primary data output, and accessed using the global variable
stdout.
Note:
The file descriptor underlying stdout is initially 1, but it can be changed by freopen() to 0 (and implementations may have extensions that allow it to be changed to other
numbers). Therefore, writing to the standard output stream does not always produce output on the standard output file
descriptor.
3.356 Standard Utilities
The utilities described in the Shell and Utilities volume of POSIX.1-2024.
3.357 Stream
Appearing in lowercase, a stream is an ordered sequence of bytes, as described by the ISO C standard.
In the shell command language, each stream is associated with a file descriptor. These can be opened using
redirection operators.
Note:
Redirection is defined in detail in XCU 2.7 Redirection.
In the C language, each stream is accessed via a file access object and is either a stream associated with a file
descriptor or a memory stream. A file access object associated with a file descriptor can be created by the fdopen(), fopen(), or popen() functions. A file access object for a memory stream can be created by the fmemopen() or open_memstream()
functions. A stream provides the additional services of user-selectable buffering and formatted input and output.
Note:
For further information, see XSH 2.5 Standard I/O Streams.
The fdopen(), fmemopen(), fopen(), open_memstream(), and popen() functions
are defined in detail in the System Interfaces volume of POSIX.1-2024.
3.358 String
A contiguous sequence of bytes terminated by and including the first null byte.
3.359 Subshell
A shell execution environment, distinguished from the main or current shell execution environment.
Note:
For further information, see XCU 2.13 Shell Execution Environment
.
3.360 Successfully Transferred
For a write operation to a regular file, when the system ensures that all data written is readable on any
subsequent open of the file (even one that follows a system or power failure) in the absence of a failure of the physical storage
medium.
For a read operation, when an image of the data on the physical storage medium is available to the requesting
process.
3.361 Supplementary Group ID
An attribute of a process used in determining file access permissions. A process has up to {NGROUPS_MAX}
supplementary group IDs in addition to the effective group ID. The supplementary group IDs of a process are set to the
supplementary group IDs of the parent process when the process is created.
3.362 Suspended Job
In the context of the System Interfaces volume of POSIX.1-2024, a job that has received a SIGSTOP, SIGTSTP,
SIGTTIN, or SIGTTOU signal that caused the process group to stop.
In the context of the shell, a job, other than a non-job-control background job, that became suspended when a
process returned a wait status to the shell indicating that the process was stopped by a SIGSTOP, SIGTSTP, SIGTTIN, or SIGTTOU
signal.
A suspended job is a job-control background job, but a job-control background job is not necessarily a suspended
job. A non-job-control background job is never a suspended job, even if it includes processes that have been stopped by a SIGSTOP,
SIGTSTP, SIGTTIN, or SIGTTOU signal.
Note:
See also 3.35 Background Job, 3.180 Job, and 3.158
Foreground Job.
3.363 Symbolic Constant
An object-like macro defined with a constant value.
Unless stated otherwise, the following shall apply to every symbolic constant:
It expands to a compile-time constant expression with an integer type.
It may be defined as another type of constant—e.g., an enumeration constant—as well as being a macro.
It need not be usable in #if preprocessing directives.
3.364 Symbolic Link
A type of file with the property that when the file is encountered during pathname resolution, a string stored by
the file is used to modify the pathname resolution. The stored string has a length of {SYMLINK_MAX} bytes or fewer.
Note:
Pathname Resolution is defined in detail in 4.16 Pathname Resolution
.
3.365 Synchronization Operation
An operation that synchronizes memory. See 4.15 Memory Ordering
and Synchronization.
3.366 Synchronized Input and Output
A determinism and robustness improvement mechanism to enhance the data input and output mechanisms, so that an
application can be assured that the data being manipulated is physically present on secondary mass storage devices.
3.367 Synchronized I/O Completion
The state of an I/O operation that has either been successfully transferred or diagnosed as unsuccessful.
3.368 Synchronized I/O Data Integrity Completion
For read, when the operation has been completed or diagnosed if unsuccessful. The read is complete only when an
image of the data has been successfully transferred to the requesting process. If there were any pending write requests affecting
the data to be read at the time that the synchronized read operation was requested, these write requests are successfully
transferred prior to reading the data.
For write, when the operation has been completed or diagnosed if unsuccessful. The write is complete only when the
data specified in the write request is successfully transferred and all file system information required to retrieve the data is
successfully transferred.
For the purpose of this definition, an operation that reads or searches a directory is considered to be a read
operation, an operation that modifies a directory is considered to be a write operation, and a directory's entries are considered
to be the data read or written.
This standard provides no way to synchronize the contents or attributes of a symbolic link.
File attributes that are not necessary for data retrieval (access time, modification time, status change time) need
not be successfully transferred prior to returning to the calling process.
3.369 Synchronized I/O File Integrity Completion
Identical to a synchronized I/O data integrity completion with the addition that all file attributes relative to
the I/O operation (including access time, modification time, status change time) are successfully transferred prior to returning to
the calling process.
3.370 Synchronized I/O Operation
An I/O operation performed on a file that provides the application assurance of the integrity of its data and
files.
3.371 Synchronous I/O Operation
An I/O operation that causes the thread requesting the I/O to be blocked from further use of the processor until
that I/O operation completes.
Note:
A synchronous I/O operation does not imply synchronized I/O data integrity completion or synchronized I/O file integrity
completion.
3.372 Synchronously-Generated Signal
A signal that is attributable to a specific thread.
For example, a thread executing an illegal instruction or touching invalid memory causes a synchronously-generated
signal. Being synchronous is a property of how the signal was generated and not a property of the signal number.
3.373 System
An implementation of POSIX.1-2024.
3.374 System Boot
An unspecified sequence of events that may result in the loss of transitory data; that is, data that is not saved
in permanent storage. For example, message queues, shared memory, semaphores, and processes.
3.375 System Clock
A clock with at least one second resolution that contains seconds since the Epoch.
3.376 System Console
A device that receives messages sent by the syslog() function, and
the fmtmsg() function when the MM_CONSOLE flag is set.
Note:
The syslog() and fmtmsg() functions
are defined in detail in the System Interfaces volume of POSIX.1-2024.
3.377 System Crash
An interval initiated by an unspecified circumstance that causes all processes (possibly other than special system
processes) to be terminated in an undefined manner, after which any changes to the state and contents of files created or written
to by an application prior to the interval are undefined, except as required elsewhere in POSIX.1-2024.
3.378 System Databases
An implementation provides two system databases: the "group database" (see also 3.164 Group
Database) and the "user database" (see also 3.407 User Database).
3.379 System Documentation
All documentation provided with an implementation except for the conformance document. Electronically distributed
documents for an implementation are considered part of the system documentation.
3.380 System Process
An object other than a process executing an application, that is provided by the system and has a process ID.
3.381 System Reboot
See System Boot defined in 3.374 System Boot.
3.382 System-Wide
Pertaining to events occurring in all processes existing in an implementation at a given point in time.
3.383 Tab Character ()
A character that in the output stream indicates that printing or displaying should start at the next horizontal
tabulation position on the current line. It is the character designated by '\t' in the C language. If the current position
is at or past the last defined horizontal tabulation position, the behavior is unspecified. It is unspecified whether this
character is the exact sequence transmitted to an output device by the system to accomplish the tabulation.
3.384 Terminal (or Terminal Device)
A character special file that obeys the specifications of the general terminal interface.
Note:
The General Terminal Interface is defined in detail in 11. General Terminal
Interface.
3.385 Text Column
A roughly rectangular block of characters capable of being laid out side-by-side next to other text columns on an
output page or terminal screen. The widths of text columns are measured in column positions.
3.386 Text Domain
A named collection of messages objects (one messages object per supported language) for internationalization and
localization purposes. A text domain is often named after the application or library that provides the collection, but may have a
more general name if it is intended to be shared by multiple applications or libraries.
Note:
The use of text domains is defined in detail in the descriptions of the bindtextdomain() and gettext() family of functions in the System Interfaces volume of
POSIX.1-2024.
3.387 Text File
A file that contains characters organized into zero or more lines. The lines do not contain NUL characters and none
can exceed {LINE_MAX} bytes in length, including the  character. Although POSIX.1-2024 does not distinguish between
text files and binary files (see the ISO C standard), many utilities only produce predictable or meaningful output when
operating on text files. The standard utilities that have such restrictions always specify "text files" in their STDIN or INPUT
FILES sections.
3.388 Thread
A live thread (see 3.190 Live Thread) or a zombie thread (see 3.427 Zombie Thread). The lifetime of a thread is described in 3.390 Thread Lifetime
.
3.389 Thread ID
A value that uniquely identifies each thread in a process during the thread's lifetime. The value shall be unique
across all threads in a process, regardless of whether the thread is:
The initial thread
A thread created using pthread_create()
A thread created using thrd_create()
A thread created via a SIGEV_THREAD notification
Note:
Since pthread_create() returns an ID of type pthread_t and
thrd_create() returns an ID of type thrd_t, this uniqueness requirement
necessitates that these two types are defined as the same underlying type because calls to pthread_self() and thrd_current()
from the initial thread need to return the same thread ID. The pthread_create(), pthread_self(),
thrd_create(), and thrd_current() functions and SIGEV_THREAD notifications are defined in detail in the
System Interfaces volume of POSIX.1-2024.
3.390 Thread Lifetime
The period of time that begins when a thread is created and ends when its thread ID is returned to the process.
See also Live Thread in 3.190 Live Thread, Thread Termination in 3.392 Thread Termination, and Zombie Thread in 3.427 Zombie Thread.
Note:
Thread creation is defined in detail in the descriptions of the pthread_create() and thrd_create()
functions in the System Interfaces volume of POSIX.1-2024.
3.391 Thread List
An ordered set of runnable threads that all have the same ordinal value for their priority.
The ordering of threads on the list is determined by a scheduling policy or policies. The set of thread lists
includes all runnable threads in the system.
3.392 Thread Termination
Thread termination occurs when a thread executes pthread_exit()
or thrd_exit(), when it returns from the start_routine function passed to
pthread_create() or from the func function passed to thrd_create(), or when it acts on a cancellation request initiated by pthread_cancel().
Note:
The pthread_cancel(), pthread_create(), pthread_exit(),
thrd_create(), and thrd_exit()
functions are defined in detail in the System Interfaces volume of POSIX.1-2024.
3.393 Thread-Safe
A thread-safe function shall avoid data races with other calls to the same function, and with calls to any other
thread-safe functions, by multiple threads. Each function defined in the System Interfaces volume of POSIX.1-2024 is thread-safe
unless explicitly stated otherwise. Examples are any "pure" function, a function which holds a mutex locked while it is accessing
static storage, or objects shared among threads.
A function that is not required to be thread-safe need not avoid data races with other calls to the same function,
nor with calls to any other function (including thread-safe functions), by multiple threads, unless explicitly stated
otherwise.
3.394 Thread-Specific Data Key
A process global handle which is used for naming thread-specific data. There are two types of key: those of type
pthread_key_t which are created using pthread_key_create() and
those of type tss_t which are created using tss_create(). If an
application attempts to use the two types of key interchangeably (that is, pass a key of type pthread_key_t to a function
that takes a tss_t, or vice versa), the behavior is undefined.
Although the same key value can be used by different threads, the values bound to the key by pthread_setspecific() for keys of type pthread_key_t, and by tss_set() for keys of type tss_t, are maintained on a per-thread basis and persist
for the life of the calling thread.
Note:
The pthread_getspecific(), pthread_setspecific(), tss_create(), and tss_set() functions are
defined in detail in the System Interfaces volume of POSIX.1-2024.
3.395 Tilde Character ()
The character '~'.
3.396 Timeouts
A method of limiting the length of time an interface will block; see also 3.47 Blocked Process
(or Thread).
3.397 Timer
A mechanism that can notify a thread when the time as measured by a particular clock has reached or passed a
specified value, or when a specified amount of time has passed.
3.398 Timer Overrun
A condition that occurs each time a timer, for which there is already an expiration signal queued to the process,
expires.
3.399 Token
In the shell command language, a sequence of characters that the shell considers as a single unit when reading
input. A token is either an operator or a word.
Note:
The rules for reading input are defined in detail in XCU 2.3 Token
Recognition.
3.400 Typed Memory Name Space
A system-wide name space that contains the names of the typed memory objects present in the system. It is
configurable for a given implementation.
3.401 Typed Memory Object
A combination of a typed memory pool and a typed memory port. The entire contents of the pool are accessible from
the port. The typed memory object is identified through a name that belongs to the typed memory name space.
3.402 Typed Memory Pool
An extent of memory with the same operational characteristics. Typed memory pools may be contained within each
other.
3.403 Typed Memory Port
A hardware access path to one or more typed memory pools.
3.404 Unbind
Remove the association between a network address and an endpoint.
3.405 Unit Data
See Datagram in 3.96 Datagram.
3.406 Upshifting
The conversion of a lowercase character that has a single-character uppercase representation into this uppercase
representation.
3.407 User Database
A system database that contains at least the following information for each user ID:
User name
Numerical user ID
Initial numerical group ID
Initial working directory
Initial user program
The initial numerical group ID is used by the newgrp utility. Any
other circumstances under which the initial values are operative are implementation-defined.
If the initial user program field is null, an implementation-defined program is used.
If the initial working directory field is null, the interpretation of that field is implementation-defined.
Note:
The newgrp utility is defined in detail in the Shell and Utilities volume of
POSIX.1-2024.
3.408 User ID
A non-negative integer that is used to identify a system user. When the identity of a user is associated with a
process, a user ID value is referred to as a real user ID, an effective user ID, or a saved set-user-ID. The value (uid_t)-1
shall not be a valid user ID, but does have a defined use in some interfaces defined in this standard.
3.409 User Name
A string that is used to identify a user; see also 3.407 User Database. To be portable
across systems conforming to POSIX.1-2024, the value is composed of characters from the portable filename character set. The
character should not be used as the first character of a portable user name.
3.410 Utility
A program, excluding special built-in utilities provided as part of the Shell Command Language, that can be called
by name from a shell to perform a specific task, or related set of tasks.
Note:
For further information on special built-in utilities, see XCU 2.15 Special
Built-In Utilities.
3.411 Variable
In the shell command language, a named parameter.
Note:
For further information, see XCU 2.5 Parameters and Variables.
3.412 Vertical-Tab Character ()
A character that in the output stream indicates that printing should start at the next vertical tabulation
position. It is the character designated by '\v' in the C language. If the current position is at or past the last defined
vertical tabulation position, the behavior is unspecified. It is unspecified whether this character is the exact sequence
transmitted to an output device by the system to accomplish the tabulation.
3.413 White Space
A sequence of one or more characters that belong to the space character class as defined via the
LC_CTYPE category in the current locale or a specified locale.
In the POSIX locale, white space consists of one or more  ( and  characters),
, , , and  characters.
3.414 White-Space Byte
A single-byte white-space character; that is, a character for which the isspace() or isspace_l() function returns a
non-zero value.
3.415 White-Space Character
A character that belongs to the space character class as defined via the LC_CTYPE category in the
current locale or a specified locale.
3.416 White-Space Wide Character
A wide-character code that belongs to the space character class as defined via the LC_CTYPE category
in the current locale or a specified locale.
3.417 Wide-Character Code (C Language)
An integer value corresponding to a single graphic symbol or control code.
Note:
C Language Wide-Character Codes are defined in detail in 6.3 C Language
Wide-Character Codes.
3.418 Wide-Character Input/Output Functions
The functions that perform wide-oriented input from streams or wide-oriented output to streams: fgetwc(), fgetws(), fputwc(), fputws(), fwprintf(), fwscanf(), getwc(), getwchar(), putwc(), putwchar(), ungetwc(), vfwprintf(), vfwscanf(), vwprintf(), vwscanf(), wprintf(), and wscanf().
Note:
These functions are defined in detail in the System Interfaces volume of POSIX.1-2024.
3.419 Wide-Character String
A contiguous sequence of wide-character codes terminated by and including the first null wide-character code.
3.420 Word
In the shell command language, a token other than an operator. In some cases a word is also a portion of a word
token: in the various forms of parameter expansion, such as ${name-word}, and variable assignment, such as
name=word, the word is the portion of the token depicted by word. The concept of a word is no longer
applicable following word expansions—only fields remain.
Note:
For further information, see XCU 2.6.2 Parameter Expansion and
2.6 Word Expansions.
3.421 Working Directory (or Current Working Directory)
A directory, associated with a process, that is used in pathname resolution for pathnames that do not begin with a
character.
3.422 Worldwide Portability Interface
Functions for handling characters in a codeset-independent manner.
3.423 Write
To output characters to a file, such as standard output or standard error. Unless otherwise stated, standard output
is the default output destination for all uses of the term "write"; see the distinction between display and write in 3.107 Display.
3.424 XSI
The X/Open System Interfaces (XSI) option is the core application programming interface for C and sh programming for systems conforming to the Single UNIX Specification. This is a superset of the
mandatory requirements for conformance to POSIX.1-2024.
3.425 XSI-Conformant
A system which allows an application to be built using a set of services that are consistent across all systems
that conform to POSIX.1-2024 and that support the XSI option.
Note:
See also 2. Conformance.
3.426 Zombie Process
The remains of a live process (see 3.189 Live Process) after it terminates (see 3.287 Process Termination) and before its status information (see XSH 2.12 Status Information) is consumed by its parent process.
3.427 Zombie Thread
The remains of a joinable live thread (see 3.183 Joinable Thread and 3.190 Live Thread) after it terminates (see 3.392 Thread Termination) and before it
has been joined with pthread_join() or thrd_join() or detached with pthread_detach() or thrd_detach().
Note:
The pthread_detach(), pthread_join(), thrd_detach(), and
thrd_join() functions are defined in detail in the System Interfaces volume of
POSIX.1-2024.
3.428 ±0
The algebraic sign provides additional information about any variable that has the value zero when the
representation allows the sign to be determined.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/endian.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
endian.h — system endianness
SYNOPSIS
#include
DESCRIPTION
The  header shall define at least the following macros for use in determining host byte order for integer
types.
BYTE_ORDER
This macro shall have a value equal to one of the *_ENDIAN macros in this header.
LITTLE_ENDIAN
If BYTE_ORDER == LITTLE_ENDIAN, the host byte order is from least significant to most significant.
BIG_ENDIAN
If BYTE_ORDER == BIG_ENDIAN, the host byte order is from most significant to least significant.
These macros shall be suitable for use in #if preprocessing directives. The macros BIG_ENDIAN and LITTLE_ENDIAN shall
have distinct values. Implementations may define other macros with the _ENDIAN suffix.
The following shall be declared as functions, or defined as macros, or both. If functions are declared, function prototypes
shall be provided.
uint16_t  be16toh(uint16_t);
uint32_t  be32toh(uint32_t);
uint64_t  be64toh(uint64_t);
uint16_t  htobe16(uint16_t);
uint32_t  htobe32(uint32_t);
uint64_t  htobe64(uint64_t);
uint16_t  htole16(uint16_t);
uint32_t  htole32(uint32_t);
uint64_t  htole64(uint64_t);
uint16_t  le16toh(uint16_t);
uint32_t  le32toh(uint32_t);
uint64_t  le64toh(uint64_t);
The  header shall define the uint16_t, uint32_t, and uint64_t types as described in
.
Inclusion of the  header may also make visible all symbols from .
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
Many implementations also include PDP_ENDIAN to indicate a byte ordering where each pair of bytes is swapped. If BIG_ENDIAN is
defined as 4321, PDP_ENDIAN would be 3412. However, this scheme is not universal, and derives its name from an obsolete
processor.
FUTURE DIRECTIONS
None.
SEE ALSO
XSH be16toh(), htonl(), swab()
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/sys_time.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sys/time.h — time types
SYNOPSIS
[XSI]  #include
DESCRIPTION
The  header shall define the fd_set type and the timeval structure, as described in
.
The  header shall define the time_t and suseconds_t types as described in .
The  header shall define the following as described in : FD_CLR() FD_ISSET() FD_SET() FD_ZERO() FD_SETSIZE
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
int   select(int, fd_set *restrict, fd_set *restrict, fd_set *restrict,
struct timeval *restrict);
int   utimes(const char *, const struct timeval [2]);
Inclusion of the  header may make visible all symbols from the  header.
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
The  header refers to  for the
definition of the timeval structure, instead of the other way round, because  is an optional (XSI)
header whereas  is mandatory.
FUTURE DIRECTIONS
None.
SEE ALSO
,
XSH futimens(), pselect()
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
The type of tv_usec is changed from long to suseconds_t.
Issue 6
The restrict keyword is added to the prototypes for gettimeofday(), select(), and setitimer().
The note is added that inclusion of this header may also make symbols visible from .
The utimes() function is marked LEGACY.
Issue 7
This reference page is clarified with respect to macros and symbolic constants.
Issue 8
Austin Group Defect 1171 is applied, replacing the timeval structure definition with a reference to its description in
.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/V1_chap08.html =====
Environment Variables
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
8. Environment Variables
8.1 Environment Variable Definition
Environment variables defined in this chapter affect the operation of multiple utilities, functions, and applications. There are
other environment variables that are of interest only to specific utilities. Environment variables that apply to a single utility
only are defined as part of the utility description. See the ENVIRONMENT VARIABLES section of the utility descriptions in the Shell
and Utilities volume of POSIX.1-2024 for information on environment variable usage.
The value of an environment variable is an arbitrary sequence of bytes, except for the null byte. For a C-language program, an
array of strings called the environment shall be made available when a process begins. The array is pointed to by the external
variable environ, which is defined as:
extern char **environ;
These strings have the form name=value; names shall not contain any bytes that have the encoded value of
the character '='. For values to be portable across systems conforming to POSIX.1-2024, the value shall be composed of
bytes that have the encoded value of characters from the portable character set (except NUL and as indicated below). There is no
meaning associated with the order of strings in the environment. If more than one string in an environment of a process has the
same name, the consequences are undefined.
Environment variable names used by the utilities in the Shell and Utilities volume of POSIX.1-2024 consist solely of uppercase
letters, digits, and the  ('_') from the characters defined in Portable Character Set and do not begin with a digit. Other characters, and byte
sequences that do not form valid characters, may be permitted by an implementation; applications shall tolerate the presence of
such names. Uppercase and lowercase letters shall retain their unique identities and shall not be folded together. The name space
of environment variable names containing lowercase letters is reserved for applications. Applications can define any environment
variables with names from this name space without modifying the behavior of the standard utilities.
Note:
Other applications may have difficulty dealing with environment variable names that start with a digit. For this reason, use of
such names is not recommended anywhere.
The values that the environment variables may be assigned are not restricted except that they are considered to end with
a null byte and the total space used to store the environment and the arguments to the process is limited to {ARG_MAX} bytes.
Other name=value pairs may be placed in the environment by, for example, calling any of the setenv(), unsetenv(), [XSI]   or putenv()  functions, assigning
a new value to the environ variable, or by using envp arguments when creating a process; see exec in the
System Interfaces volume of POSIX.1-2024.
If the application modifies the pointers to which environ points, the behavior of all interfaces described in the System
Interfaces volume of POSIX.1-2024 is undefined.
It is unwise to conflict with certain variables that are frequently exported by widely used command interpreters and
applications:
ARFLAGS
IFS
MAILPATH
PS1
CC
LANG
MAILRC
PS2
CDPATH
LC_ALL
MAKEFLAGS
PS3
CFLAGS
LC_COLLATE
MAKESHELL
PS4
CHARSET
LC_CTYPE
MANPATH
PWD
COLUMNS
LC_MESSAGES
MBOX
RANDOM
DATEMSK
LC_MONETARY
MORE
SECONDS
DEAD
LC_NUMERIC
MSGVERB
SHELL
EDITOR
LC_TIME
NLSPATH
TERM
ENV
LDFLAGS
NPROC
TERMCAP
EXINIT
LEX
OLDPWD
TERMINFO
FC
LFLAGS
OPTARG
TMPDIR
FCEDIT
LINENO
OPTERR
TZ
FFLAGS
LINES
OPTIND
USER
GET
LISTER
PAGER
VISUAL
GFLAGS
LOGNAME
PATH
YACC
HISTFILE
LPDEST
PPID
YFLAGS
HISTORY
MAIL
PRINTER
HISTSIZE
MAILCHECK
PROCLANG
HOME
MAILER
PROJECTDIR
Additionally, a subset of the above variables are manipulated by shell built-in utilities outside of shell
assignments. If an attempt is made to mark any of the following variables as readonly, then either the readonly utility shall reject the attempt, or readonly shall succeed but the shell can still modify the variables outside of assignment
context, or readonly shall succeed but use of a shell built-in that would otherwise
modify such a variable shall fail.
LINENO
OLDPWD
OPTARG
OPTIND
PWD
Implementations may provide an implementation-defined set of additional variables which are manipulated by implementation-specific
built-in utilities not defined in this standard. The readonly utility shall not
reject marking these additional variables as readonly, but when marked readonly, those extension utilities shall
either continue to modify the variables, or shall fail because the variable is readonly. None of the variables defined by
this standard shall be in this implementation-defined set.
If the variables in the following two sections are present in the environment during the execution of an
application or utility, they shall be given the meaning described below. Some are placed into the environment by the implementation
at the time the user logs in; all can be added or changed by the user or any ancestor of the current process. The implementation
adds or changes environment variables named in POSIX.1-2024 only as specified in POSIX.1-2024. If they are defined in the
application's environment, the utilities in the Shell and Utilities volume of POSIX.1-2024 and the functions in the System
Interfaces volume of POSIX.1-2024 assume they have the specified meaning. Conforming applications shall not set these environment
variables to have meanings other than as described. See getenv() and XCU 2.13 Shell Execution Environment for methods of accessing these variables.
Implementations may ignore some environment variables at the point of use for security reasons, for example in
programs whose real and effective user IDs or real and effective group IDs were not equal at program startup. The behavior shall be
as if the implementation obtains the values for these environment variables using secure_getenv() instead of getenv() (see
getenv()); they shall not be removed from the environment of affected processes and
shall be inherited as required by this standard.
8.2 Internationalization Variables
This section describes environment variables that are relevant to the operation of internationalized interfaces
described in POSIX.1-2024.
Users may use the following environment variables to announce specific localization requirements to applications.
Applications can retrieve this information using the setlocale() function to
initialize the correct behavior of the internationalized interfaces. The descriptions of the internationalization environment
variables describe the resulting behavior only when the application locale is initialized in this way. The use of the
internationalization variables by utilities described in the Shell and Utilities volume of POSIX.1-2024 is described in the
ENVIRONMENT VARIABLES section for those utilities in addition to the global effects described in this section.
LANG
This variable shall determine the locale category for native language, local customs, and coded character set in the absence of
the LC_ALL and other LC_* (LC_COLLATE , LC_CTYPE , LC_MESSAGES , LC_MONETARY ,
LC_NUMERIC , LC_TIME ) environment variables. This can be used by applications to determine the language to use for
error messages and instructions, collating sequences, date formats, and so on.
LANGUAGE
The LANGUAGE environment variable shall be examined to determine the messages object to be used for the gettext
family of functions or the gettext and ngettext utilities [XSI]   if NLSPATH is not set or the evaluation of NLSPATH
did not lead to a suitable messages object being found.  The value
of LANGUAGE shall be a list of locale names separated by a  (':') character. If LANGUAGE is set
to a non-empty string, each locale name shall be tried in the specified order and if a messages object is found, it shall be used
for translation. If a locale name has the format
language[_territory][.codeset][@modifier], additional searches of locale names
without .codeset (if present), without _territory (if present), and without @modifier (if present) may be performed; if .codeset is
not present, additional searches of locale names with an added .codeset may be performed. If locale names contain a
('/') character, or consist entirely of a dot (".") or dot-dot ("..") character sequence, or are empty
the behavior is implementation defined and they may be ignored for security reasons.
The locale names in LANGUAGE shall override the locale name associated with the "active category" of the
current locale or, in the case of functions with an _l suffix, the provided locale object, and the language-specific part of the
default search path for messages objects, unless the locale name that would be overridden is C or POSIX. For the dcgettext(), dcgettext_l(), dcngettext(), and dcngettext_l()
functions, the active category is specified by the category argument; for all other gettext family functions and for the gettext and ngettext utilities, the active
category is LC_MESSAGES .
For example, if:
The LC_MESSAGES environment variable is "de_DE" (and LC_ALL is unset) and
setlocale(LC_ALL, "") has been used to set the current locale
The LANGUAGE environment variable is "fr_FR:it"
Messages objects are by default searched for in /gettextlib
then the following pathnames are tried in this order by gettext family functions that have neither a category
argument nor an _l suffix until a valid messages object is found:
/gettextlib/fr_FR/LC_MESSAGES/textdomain.mo
(Optionally) /gettextlib/fr/LC_MESSAGES/textdomain.mo
(Optionally) the above two pathnames with added .codeset elements
/gettextlib/it/LC_MESSAGES/textdomain.mo
(Optionally) the above pathname with added .codeset elements
/gettextlib/de_DE/LC_MESSAGES/textdomain.mo
LC_ALL
This variable shall determine the values for all locale categories. The value of the LC_ALL environment variable has
precedence over any of the other environment variables starting with LC_ (LC_COLLATE , LC_CTYPE ,
LC_MESSAGES , LC_MONETARY , LC_NUMERIC , LC_TIME ) and the LANG environment variable.
LC_COLLATE
This variable shall determine the locale category for character collation. It determines collation information for regular
expressions and sorting, including equivalence classes and multi-character collating elements, in various utilities and the
strcoll() and strxfrm() functions.
Additional semantics of this variable, if any, are implementation-defined.
LC_CTYPE
This variable shall determine the locale category for character handling functions, such as tolower(), toupper(), and isalpha(). This environment variable determines the interpretation of sequences of bytes of
text data as characters (for example, single as opposed to multi-byte characters), the classification of characters (for example,
alpha, digit, graph), and the behavior of character classes. Additional semantics of this variable, if any, are
implementation-defined.
LC_MESSAGES
This variable shall determine the locale category for processing affirmative and negative responses and the language and cultural
conventions in which messages should be written. It also affects the behavior of the catopen() function in determining the message catalog. Additional semantics of this
variable, if any, are implementation-defined. The language and cultural conventions of diagnostic and informative messages whose
format is unspecified by POSIX.1-2024 should be affected by the setting of LC_MESSAGES .
LC_MONETARY
This variable shall determine the locale category for monetary-related numeric formatting information. Additional semantics of this
variable, if any, are implementation-defined.
LC_NUMERIC
This variable shall determine the locale category for numeric formatting (for example, thousands separator and radix character)
information in various utilities as well as the formatted I/O operations in printf()
and scanf() and the string conversion functions in strtod(). Additional semantics of this variable, if any, are implementation-defined.
LC_TIME
This variable shall determine the locale category for date and time formatting information. It affects the behavior of the time
functions in strftime(). Additional semantics of this variable, if any, are
implementation-defined.
NLSPATH
[XSI]
This variable shall contain a sequence of templates to be used by catopen() when
attempting to locate message catalogs, and by the gettext family of functions when locating messages objects. Each template
consists of an optional prefix, one or more conversion specifications, and an optional suffix.
The conversion specification descriptions below refer to a "currently active text domain". The currently active
text domain is, in decreasing order of precedence:
The domain parameter of the gettext family of functions or the gettext and ngettext utilities
The text domain bound by the last call to textdomain() when
using a gettext family function, or the TEXTDOMAIN environment variable when using the gettext and ngettext utilities
The default text domain
Conversion specifications consist of a '%' symbol, followed by a single-letter keyword. The following
conversion specifications are currently defined:
%N
The value of the name parameter passed to catopen() or the currently
active text domain of the gettext family of functions and the gettext and
ngettext utilities (see above).
%L
The locale name given by the value of the active category (see LANGUAGE above) in either the current locale or, in the
case of functions with an _l suffix, the provided locale object.
%l
The language element of the locale name that would result from a %L conversion.
%t
The territory element of the locale name that would result from a %L conversion.
%c
The codeset element of the locale name that would result from a %L conversion.
%%
A single '%' character.
An empty string shall be substituted if the specified value is not currently defined. The separators
('_') and  ('.') shall not be included in the %t and %c
conversion specifications.
Templates defined in NLSPATH are separated by  characters (':'). A leading, trailing,
or two adjacent  characters ("::") shall be equivalent to specifying %N.
Since  is a separator in this context, directory names that might be used in NLSPATH should not
include a  character.
Example 1, for an application that uses catopen() but does not use
the gettext family of functions:
NLSPATH="/system/nlslib/%N.cat"
indicates that catopen() should look for all message catalogs in the
directory /system/nlslib, where the catalog name should be constructed from the name argument (replacing %N)
passed to catopen(), with the suffix .cat.
Example 2, for an application that uses the gettext family of functions but does not use catopen():
NLSPATH="/usr/lib/locale/fr/LC_MESSAGES/%N.mo"
indicates that the gettext family of functions (and the gettext and ngettext utilities) should look for all messages objects in the directory
/usr/lib/locale/fr/LC_MESSAGES, where the messages object's name should be constructed from the currently active text domain
(replacing %N), with the suffix .mo.
Example 3, for an application that uses catopen() but does not use
the gettext family of functions:
NLSPATH=":%N.cat:/nlslib/%L/%N.cat"
indicates that catopen() should look for the requested message
catalog in name, name.cat, and /nlslib/localename/name.cat, where
localename is the locale name given by the value of the LC_MESSAGES category of the current locale.
Example 4, for an application that uses the gettext family of functions but does not use catopen():
NLSPATH="/usr/lib/locale/%L/%N.mo:/usr/lib/locale/fr/%N.mo"
indicates that the gettext family of functions (and the gettext and ngettext utilities) should look
for all messages objects first in /usr/lib/locale/localename/textdomain.mo, and if not
found there, then try in /usr/lib/locale/fr/textdomain.mo, where localename is the locale name
given by the value of the active category in the current locale or provided locale object.
Example 5, for an application that uses catopen() and the
gettext family of functions:
NLSPATH="/usr/lib/locale/%L/%N.mo:/system/nlslib/%L/%N.cat"
indicates that the gettext family of functions (and the gettext and ngettext utilities) should look
for all messages objects in /usr/lib/locale/localename/textdomain.mo, where
localename is the locale name given by the value of the active category in the current locale or provided locale object.
Also, catopen() should look for all message catalogs in the directory
/system/nlslib/localename/name.cat, (assuming that
/usr/lib/locale/localename/name.mo is not a message catalog). In this scenario, catopen() ignores all files that are not valid message catalogs while traversing NLSPATH
. Furthermore, the gettext family of functions and the gettext and
ngettext utilities ignore all files that are not valid messages objects found while
traversing NLSPATH .
Users should not set the NLSPATH variable unless they have a specific reason to override the default system
path. Setting NLSPATH to override the default system path may produce undefined results in the standard utilities other than
gettext and ngettext, and in
applications with appropriate privileges.
Specifying a relative pathname in the NLSPATH environment variable should be avoided without a specific
reason, including the use of a leading, trailing, or two adjacent  characters, since it may result in messages objects
being searched for in a directory relative to the current working directory of the calling process; if the process calls the
chdir() function, the directory searched for may also be changed.
TEXTDOMAIN
Specify the text domain name that the gettext and ngettext utilities use during the search for messages objects. This is identical to the
messages object filename without the .mo suffix.
TEXTDOMAINDIR
Specify the pathname to the root directory of the messages object hierarchy the gettext and ngettext utilities use during
the search for messages objects. If present, it shall replace the default root directory pathname. [XSI]  NLSPATH has
precedence over TEXTDOMAINDIR .
The environment variables LANG , LC_ALL , LC_COLLATE , LC_CTYPE , LC_MESSAGES ,
LC_MONETARY , LC_NUMERIC , LC_TIME , and NLSPATH provide for the support of internationalized
applications. The standard utilities shall make use of these environment variables as described in this section and the individual
ENVIRONMENT VARIABLES sections for the utilities. See 7.1 General for the
consequences of setting these variables to locales with different character sets.
The values of locale categories shall be determined by a precedence order; the first condition met below determines
the value:
If the LC_ALL environment variable is defined and is not null, the value of LC_ALL shall be
used.
If the LC_* environment variable (LC_COLLATE , LC_CTYPE , LC_MESSAGES , LC_MONETARY
, LC_NUMERIC , LC_TIME ) is defined and is not null, the value of the environment variable shall be used to
initialize the category that corresponds to the environment variable.
If the LANG environment variable is defined and is not null, the value of the LANG environment
variable shall be used.
Otherwise, the implementation-defined default locale shall be used.
If the locale value is "C" or "POSIX", the POSIX locale shall be used and the standard utilities
behave in accordance with the rules in 7.2 POSIX Locale for the
associated category.
If the locale value begins with a , it shall be interpreted as the pathname of a file that was created
in the output format used by the localedef utility; see OUTPUT FILES under
localedef. Referencing such a pathname shall result in that locale being used for
the indicated category.
[XSI]  If the locale value has the form:
language[_territory][.codeset]
it refers to an implementation-provided locale, where settings of language, territory, and codeset are
implementation-defined.
LC_COLLATE , LC_CTYPE , LC_MESSAGES , LC_MONETARY , LC_NUMERIC , and
LC_TIME are defined to accept an additional field @modifier, which allows the user to select a specific instance of
localization data within a single category (for example, for selecting the dictionary as opposed to the character ordering of
data). The syntax for these environment variables is thus defined as:
[language[_territory][.codeset][@modifier]]
For example, if a user wanted to interact with the system in French, but required to sort German text files,
LANG and LC_COLLATE could be defined as:
LANG=Fr_FR
LC_COLLATE=De_DE
This could be extended to select dictionary collation (say) by use of the @modifier field; for example:
LC_COLLATE=De_DE@dict
An implementation may support other formats.
If the locale value is not recognized by the implementation, the behavior is unspecified.
These environment variables are used by the newlocale() and
setlocale() functions, and by the standard utilities.
Additional criteria for determining a valid locale name are implementation-defined.
8.3 Other Environment Variables
COLUMNS
This variable shall represent a decimal integer >0 used to indicate the user's preferred width in column positions for the
terminal screen or window; see 3.75 Column Position. If this variable is
unset or null, the number of columns shall be set according to the terminal window size (see XSH tcgetwinsize()); if the terminal window size cannot be obtained, the implementation
determines the number of columns, appropriate for the terminal or window, in an unspecified manner. When COLUMNS is set, the
number of columns in the terminal window size and any terminal-width information implied by TERM are overridden. Users and
conforming applications should not set COLUMNS unless they wish to override the system selection and produce output
unrelated to the terminal characteristics.
Users should not need to set this variable in the environment unless there is a specific reason to override the
implementation's default behavior, such as to display data in an area arbitrarily smaller than the terminal or window.
DATEMSK
[XSI]
Indicates the pathname of the template file used by getdate().
HOME
The system shall initialize this variable at the time of login to be a pathname of the user's home directory. See .
LINES
This variable shall represent a decimal integer >0 used to indicate the user's preferred number of lines on a page or the
vertical screen or window size in lines. A line in this case is a vertical measure large enough to hold the tallest character in
the character set being displayed. If this variable is unset or null, the number of lines shall be set either to the number of rows
in the terminal window size (see XSH tcgetwinsize()) or to a smaller number
if appropriate for the terminal or window (for example, if the terminal baud rate is low); if the terminal window size cannot be
obtained, the implementation determines the number of lines, appropriate for the terminal or window, in an unspecified manner. When
LINES is set, the number of rows in the terminal window size and any terminal-height information implied by TERM are
overridden. Users and conforming applications should not set LINES unless they wish to override the system selection and
produce output unrelated to the terminal characteristics.
Users should not need to set this variable in the environment unless there is a specific reason to override the
implementation's default behavior, such as to display data in an area arbitrarily smaller than the terminal or window.
LOGNAME
The system shall initialize this variable at the time of login to be the user's login name. See . For a value of LOGNAME to be portable across implementations of
POSIX.1-2024, the value should be composed of characters from the portable filename character set.
MSGVERB
[XSI]
Describes which message components shall be used in writing messages by fmtmsg().
PATH
This variable shall represent the sequence of path prefixes that certain functions and utilities apply in searching for an
executable file. The prefixes shall be separated by a  (':'). If the pathname being sought contains no
('/') characters, and hence is a filename, the list shall be searched from beginning to end, applying the
filename to each prefix and attempting to resolve the resulting pathname (see 4.16 Pathname Resolution), until an executable file with appropriate execution
permissions is found. When a non-zero-length prefix is applied to this filename, a  shall be inserted between the
prefix and the filename if the prefix did not end in . A zero-length prefix is a legacy feature that indicates the
current working directory. It appears as two adjacent  characters ("::"), as an initial
preceding the rest of the list, or as a trailing  following the rest of the list. A strictly conforming application
shall use an actual pathname (such as .) to represent the current working directory in PATH . If the pathname being
sought contains any  characters, the search through the path prefixes shall not be performed and the pathname shall be
resolved as described in 4.16 Pathname Resolution. If PATH is
unset or is set to null, or if a path prefix in PATH contains a  character ('%'), the path
search is implementation-defined.
Since  is a separator in this context, directory names that might be used in PATH should not
include a  character. Since  may have an implementation-defined meaning when searching for
built-in utilities, directory names in PATH to be used to search for non-built-in utilities should not contain a
character.
PWD
This variable shall represent an absolute pathname of the current working directory. It shall not contain any components that
are dot or dot-dot. The value is set by the cd utility, and by the sh utility during initialization.
SHELL
This variable shall represent a pathname of the user's preferred command language interpreter. If this interpreter does not
conform to the Shell Command Language in XCU 2. Shell Command Language,
utilities may behave differently from those described in POSIX.1-2024.
TMPDIR
This variable shall represent a pathname of a directory made available for programs that need a place to create temporary
files.
TERM
This variable shall represent the terminal type for which output is to be prepared. This information is used by utilities and
application programs wishing to exploit special capabilities specific to a terminal. The format and allowable values of this
environment variable are unspecified.
TZ
This variable shall represent timezone information. The contents of the environment variable named TZ shall be used by
the ctime(), localtime(), localtime_r(), strftime(), and mktime() functions, and by various utilities, to override the default timezone. The
application shall ensure that the value of TZ is in one of the three formats (spaces inserted for clarity):
:characters
or:
std offset dst offset, rule
or:
A format specifying a geographical timezone or a special timezone.
If TZ is of the first format (that is, if the first character is a ), the characters following
the  are handled in an implementation-defined manner.
The expanded form of the second format (without the inserted spaces) is as follows:
stdoffset[dst[offset][,start[/time],end[/time]]]
Where:
std and dst
Indicate no less than three, nor more than {TZNAME_MAX}, bytes that are the designation for the standard (std) or the
Daylight Saving (dst) timezone. Only std is required; if dst is missing, then Daylight Saving Time does not
apply in this locale.
Note:
The usage of the terms "Standard Time" and "Daylight Saving Time" is not necessarily related to any legislated
timezone.
Each of these fields may occur in either of two formats quoted or unquoted:
In the quoted form, the first character shall be the  (' ('>') character. All characters between these quoting characters
shall be alphanumeric characters from the portable character set in the current locale, the  ('+')
character, or the  ('-') character. The std and dst fields in this case shall not
include the quoting characters and the quoting characters do not contribute to the three byte minimum length and {TZNAME_MAX}
maximum length.
In the unquoted form, all characters in these fields shall be alphabetic characters from the portable character
set in the current locale.
The interpretation of std and, if present, dst is unspecified if the field is less than three bytes
or more than {TZNAME_MAX} bytes, or if it contains characters other than those specified.
offset
Indicates the value added to the local time to arrive at Coordinated Universal Time. The offset has the form:
hh[:mm[:ss]]
The minutes (mm) and seconds (ss) are optional. The hour (hh) shall be required and may be a
single digit. The offset following std shall be required. If no offset follows dst, Daylight Saving
Time is assumed to be one hour ahead of standard time. One or more digits may be used; the value is always interpreted as a decimal
number. The hour shall be between zero and 24, and the minutes (and seconds)—if present—between zero and 59. The result of using
values outside of this range is unspecified. If preceded by a '-', the timezone shall be east of the Prime Meridian;
otherwise, it shall be west (which may be indicated by an optional preceding '+').
rule
Indicates when to change from standard time to Daylight Saving Time, and when to change back. The rule has the form:
date[/time],date[/time]
where the first date describes when the change from standard time to Daylight Saving Time occurs and the
second date describes when it ends; if the second date is specified as earlier in the year than the first, then the
year begins and ends in Daylight Saving Time. Each time field describes when, in current local time, the change to the other
time is made.
The format of date is one of the following:
Jn
The Julian day n (1  and the value does not
match the syntax for the second format), the value indicates either a geographical timezone or a special timezone from an
implementation-defined timezone database. Typically these take the form
Area/Location
as in the IANA timezone database. Examples of geographical timezones that may be supported include
Africa/Cairo, America/New_York, America/Indiana/Indianapolis, Asia/Tokyo, and
Europe/London. The data for each geographical timezone shall include:
The offset from Coordinated Universal Time of the timezone's standard time.
If Daylight Saving Time (DST) is, or has historically been, observed: a method to discover the dates and times of
transitions to and from DST and the offset from Coordinated Universal Time during periods when DST was, is, or is predicted to be,
in effect.
The timezone names for standard time (std) and, if observed, for DST (dst) to be used by tzset(). These shall each contain no more than {TZNAME_MAX} bytes.
If there are any historical variations, or known future variations, of the above data for a geographical timezone,
these variations shall be included in the database, except that historical variations from before the Epoch need not be
included.
If the database incorporates an external database such as the one maintained by IANA, the implementation shall
provide an implementation-defined method to allow the database to be updated, for example the method specified by RFC 6557.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/stdarg.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
stdarg.h — handle variable argument list
SYNOPSIS
#include
void va_start(va_list ap, argN);
void va_copy(va_list dest, va_list src); type va_arg(va_list
ap, type);
void va_end(va_list ap);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The  header shall contain a set of macros which allows portable functions that accept variable argument
lists to be written. Functions that have variable argument lists (such as printf())
but do not use these macros are inherently non-portable, as different systems use different argument-passing conventions.
The  header shall define the va_list type for variables used to traverse the list.
The va_start() macro is invoked to initialize ap to the beginning of the list before any calls to
va_arg().
The va_copy() macro initializes dest as a copy of src, as if the va_start() macro had been applied
to dest followed by the same sequence of uses of the va_arg() macro as had previously been used to reach the present
state of src. Neither the va_copy() nor va_start() macro shall be invoked to reinitialize dest without
an intervening invocation of the va_end() macro for the same dest.
The object ap may be passed as an argument to another function; if that function invokes the va_arg() macro with
parameter ap, the value of ap in the calling function is unspecified and shall be passed to the va_end() macro
prior to any further reference to ap. The parameter argN is the identifier of the rightmost parameter in the variable
parameter list in the function definition (the one just before the ...). If the parameter argN is declared with the
register storage class, with a function type or array type, or with a type that is not compatible with the type that results
after application of the default argument promotions, the behavior is undefined.
The va_arg() macro shall return the next argument in the list pointed to by ap. Each invocation of va_arg()
modifies ap so that the values of successive arguments are returned in turn. The type parameter shall be a type name
specified such that the type of a pointer to an object that has the specified type can be obtained simply by postfixing a
'*' to type. If there is no actual next argument, or if type is not compatible with the type of the actual next
argument (as promoted according to the default argument promotions), the behavior is undefined, except for the following cases:
One type is a signed integer type, the other type is the corresponding unsigned integer type, and the value is representable in
both types.
One type is a pointer to void and the other is a pointer to a character type.
[XSI]
Both types are pointers.
Different types can be mixed, but it is up to the routine to know what type of argument is expected.
The va_end() macro is used to clean up; it invalidates ap for use (unless va_start() or va_copy() is
invoked again).
Each invocation of the va_start() and va_copy() macros shall be matched by a corresponding invocation of the
va_end() macro in the same function.
Multiple traversals, each bracketed by va_start() ... va_end(), are possible.
The following sections are informative.
EXAMPLES
This example is a possible implementation of execl():
#include
#define  MAXARGS     31
/*
* execl is called by
* execl(file, arg1, arg2, ..., (char *)(0));
*/
int execl(const char *file, const char *args, ...)
{
va_list ap;
char *array[MAXARGS +1];
int argno = 0;
va_start(ap, args);
while (args != 0 && argno >>
===== susv5-html/basedefs/cpio.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cpio.h — cpio archive values
SYNOPSIS
#include
DESCRIPTION
The  header shall define the symbolic constants needed by the c_mode field of the cpio
archive format, with the names and values given in the following table:
Name
Description
Value (Octal)
C_IRUSR
Read by owner.
0000400
C_IWUSR
Write by owner.
0000200
C_IXUSR
Execute by owner.
0000100
C_IRGRP
Read by group.
0000040
C_IWGRP
Write by group.
0000020
C_IXGRP
Execute by group.
0000010
C_IROTH
Read by others.
0000004
C_IWOTH
Write by others.
0000002
C_IXOTH
Execute by others.
0000001
C_ISUID
Set user ID.
0004000
C_ISGID
Set group ID.
0002000
C_ISVTX
On directories, restricted deletion flag.
0001000
C_ISDIR
Directory.
0040000
C_ISFIFO
FIFO.
0010000
C_ISREG
Regular file.
0100000
C_ISBLK
Block special.
0060000
C_ISCHR
Character special.
0020000
C_ISCTG
Reserved.
0110000
C_ISLNK
Symbolic link.
0120000
C_ISSOCK
Socket.
0140000
The  header shall define the following symbolic constant as a string:
MAGIC    "070707"
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XCU pax
CHANGE HISTORY
First released in the Headers Interface, Issue 3 specification. Derived from the POSIX.1-1988 standard.
Issue 6
The SEE ALSO is updated to refer to pax.
Issue 7
The  header is moved from the XSI option to the Base.
This reference page is clarified with respect to macros and symbolic constants.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/stdlib.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
stdlib.h — standard library definitions
SYNOPSIS
#include
DESCRIPTION
[CX]  Some of the functionality described on this reference page extends the ISO C standard. Applications shall define
the appropriate feature test macro (see XSH 2.2 The Compilation
Environment) to enable the visibility of these symbols in this header.
The  header shall define the following macros which shall expand to integer constant expressions:
EXIT_FAILURE
Unsuccessful termination for exit(); [CX]   the value
shall be between 1 and 125 inclusive.
EXIT_SUCCESS
Successful termination for exit(); the value shall be 0.
{RAND_MAX}
Maximum value returned by rand(); at least 32767.
The  header shall define the following macro which shall expand to a positive integer expression with
type size_t:
{MB_CUR_MAX}
Maximum number of bytes in a character specified by the current locale (category LC_CTYPE ).
[CX]  In
the POSIX locale the value of {MB_CUR_MAX} shall be 1.
The  header shall define NULL as described in .
The  header shall define the following data types through typedef:
div_t
Structure type returned by the div() function.
ldiv_t
Structure type returned by the ldiv() function.
lldiv_t
Structure type returned by the lldiv() function.
size_t
As described in .
wchar_t
As described in .
[CX]  In
addition, the  header shall define the following symbolic constants and macros as described in :
WCOREDUMP
WEXITSTATUS
WIFEXITED
WIFSIGNALED
WIFSTOPPED
WNOHANG
WSTOPSIG
WTERMSIG
WUNTRACED
[CX]  The
header shall define the following symbolic constants as described in :
O_APPEND
O_CLOEXEC
O_CLOFORK
[SIO]
O_DSYNC
[XSI]
O_NOCTTY
O_RDWR
[SIO]
O_RSYNC
[CX]
O_SYNC
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
_Noreturn void  _Exit(int);
[XSI]
long            a64l(const char *);
_Noreturn void  abort(void);
int             abs(int);
void           *aligned_alloc(size_t, size_t);
int             at_quick_exit(void (*)(void));
int             atexit(void (*)(void));
double          atof(const char *);
int             atoi(const char *);
long            atol(const char *);
long long       atoll(const char *);
void           *bsearch(const void *, const void *, size_t, size_t,
int (*)(const void *, const void *));
void           *calloc(size_t, size_t);
div_t           div(int, int);
[XSI]
double          drand48(void);
double          erand48(unsigned short [3]);
_Noreturn void  exit(int);
void            free(void *);
char           *getenv(const char *);
[CX]
int             getsubopt(char **restrict, char *const *restrict,
char **restrict);
[XSI]
int             grantpt(int);
char           *initstate(unsigned, char *, size_t);
long            jrand48(unsigned short [3]);
char           *l64a(long);
long            labs(long);
[XSI]
void            lcong48(unsigned short [7]);
ldiv_t          ldiv(long, long);
long long       llabs(long long);
lldiv_t         lldiv(long long, long long);
[XSI]
long            lrand48(void);
void           *malloc(size_t);
int             mblen(const char *, size_t);
size_t          mbstowcs(wchar_t *restrict, const char *restrict,
size_t);
int             mbtowc(wchar_t *restrict, const char *restrict, size_t);
[CX]
char           *mkdtemp(char *);
int             mkostemp(char *, int);
int             mkstemp(char *);
[XSI]
long            mrand48(void);
long            nrand48(unsigned short [3]);
[ADV]
int             posix_memalign(void **, size_t, size_t);
[XSI]
int             posix_openpt(int);
char           *ptsname(int);
int             ptsname_r(int, char *, size_t);
int             putenv(char *);
void            qsort(void *, size_t, size_t, int (*)(const void *,
const void *));
_Noreturn void  quick_exit(int);
[CX]
void            qsort_r(void *, size_t, size_t, int (*)(const void *,
const void *, void *), void *);
int             rand(void);
[XSI]
long            random(void);
void           *realloc(void *, size_t);
[CX]
void           *reallocarray(void *, size_t, size_t);
char           *realpath(const char *restrict, char *restrict);
char           *secure_getenv(const char *);
[XSI]
unsigned short *seed48(unsigned short [3]);
[CX]
int             setenv(const char *, const char *, int);
[OB XSI]
void            setkey(const char *);
[XSI]
char            *setstate(char *);
void            srand(unsigned);
[XSI]
void            srand48(long);
void            srandom(unsigned);
double          strtod(const char *restrict, char **restrict);
float           strtof(const char *restrict, char **restrict);
long            strtol(const char *restrict, char **restrict, int);
long double     strtold(const char *restrict, char **restrict);
long long       strtoll(const char *restrict, char **restrict, int);
unsigned long   strtoul(const char *restrict, char **restrict, int);
unsigned long long
strtoull(const char *restrict, char **restrict, int);
int             system(const char *);
[XSI]
int             unlockpt(int);
[CX]
int             unsetenv(const char *);
size_t          wcstombs(char *restrict, const wchar_t *restrict,
size_t);
int             wctomb(char *, wchar_t);
[CX]
Inclusion of the  header may also make visible all symbols from , , , , and .
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
The ISO C standard requires that exit(EXIT_FAILURE) returns "unsuccessful termination status" to the host
environment. In a POSIX host environment this means that the lower 8 bits of EXIT_FAILURE must have at least one bit set. The
standard developers decided to further restrict the allowed values for the following reasons:
Exit statuses of 126 and greater are ambiguous in certain circumstances because they have special meanings in the shell (see XCU
2.8.2 Exit Status for Commands and the EXIT STATUS section of
sh).
The xargs utility quits when a command execution exits with status 255 (see XCU
xargs).
Calling exit() with a value greater than 255 or less than 0 is something that only
programs which are specifically designed to have their exit status obtained by waitid() should do (since it does not truncate the exit status to 8 bits). "Pure ISO C"
programs that call exit(EXIT_FAILURE) do not meet this design criterion.
The requirement that the value of EXIT_SUCCESS is 0 is not shaded CX because this matches the requirement in the ISO C
standard that exit(EXIT_SUCCESS) returns "successful termination status" to the host environment (when the host
environment is a POSIX implementation).
FUTURE DIRECTIONS
None.
SEE ALSO
, ,
, ,
XSH 2.2 The Compilation Environment, _Exit(), a64l(), abort(), abs(), atexit(), atof(), atoi(), atol(), bsearch(), calloc(), div(), drand48(), exit(), free(), getenv(), getsubopt(), grantpt(), initstate(), labs(), ldiv(), malloc(), mblen(), mbstowcs(), mbtowc(), mkdtemp(), posix_memalign(),
posix_openpt(), ptsname(),
putenv(), qsort(), rand(), realloc(), realpath(), setenv(), setkey(), strtod(), strtol(), strtoul(), system(), unlockpt(), unsetenv(), waitid(), wcstombs(), wctomb()
CHANGE HISTORY
First released in Issue 3.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Threads Extension.
The ttyslot() and valloc() functions are marked LEGACY.
The type of the third argument to initstate() is changed from int to
size_t. The type of the return value from setstate() is changed from
char to char *, and the type of the first argument is changed from char * to const char *.
Issue 6
The Open Group Corrigendum U021/1 is applied, correcting the prototype for realpath() to be consistent with the reference page.
The Open Group Corrigendum U028/13 is applied, correcting the prototype for putenv() to be consistent with the reference page.
The rand_r() function is marked as part of the Thread-Safe Functions option.
Function prototypes for setenv() and unsetenv() are added.
The posix_memalign() function is added for alignment with
IEEE Std 1003.1d-1999.
This reference page is updated to align with the ISO/IEC 9899:1999 standard.
The ecvt(), fcvt(), gcvt(), and mktemp() functions are marked LEGACY.
The ttyslot() and valloc() functions are removed as they were previously marked LEGACY.
Extensions beyond the ISO C standard are marked.
Issue 7
SD5-XBD-ERN-79 and SD5-XBD-ERN-105 are applied.
The LEGACY functions are removed.
The mkdtemp() function is added from The Open Group Technical Standard, 2006,
Extended API Set Part 1.
The rand_r() function is marked obsolescent.
This reference page is clarified with respect to macros and symbolic constants.
The type of the first argument to setstate() is changed from const char *
to char *.
POSIX.1-2008, Technical Corrigendum 1, XBD/TC1-2008/0066 [197] is applied.
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0075 [663] is applied.
Issue 8
Austin Group Defect 411 is applied, adding mkostemp().
Austin Group Defect 444 is applied, adding the restrict keyword to the getsubopt() prototype.
Austin Group Defect 508 is applied, adding the ptsname_r() function.
Austin Group Defects 593 and 1350 are applied, adding some O_* symbolic constants and allowing  to make
visible all symbols from .
Austin Group Defect 900 is applied, adding the qsort_r() function.
Austin Group Defect 922 is applied, adding the secure_getenv()
function.
Austin Group Defect 1141 is applied, adding WCOREDUMP.
Austin Group Defect 1192 is applied, marking the setkey() function as
obsolescent.
Austin Group Defect 1218 is applied, adding reallocarray().
Austin Group Defect 1229 is applied, changing the descriptions of EXIT_FAILURE and EXIT_SUCCESS, and the RATIONALE section.
Austin Group Defect 1302 is applied, aligning this header with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
Austin Group Defect 1629 is applied, changing the RATIONALE section.
Austin Group Defect 1663 is applied, removing XSI shading from realpath().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/net_if.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
net/if.h — sockets local interfaces
SYNOPSIS
#include
DESCRIPTION
The  header shall define the if_nameindex structure, which shall include at least the following
members:
unsigned  if_index  Numeric index of the interface.
char     *if_name   Null-terminated name of the interface.
The  header shall define the following symbolic constant for the length of a buffer containing an
interface name (including the terminating NULL character):
IF_NAMESIZE
Interface name length.
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
void                  if_freenameindex(struct if_nameindex *);
char                 *if_indextoname(unsigned, char *);
struct if_nameindex  *if_nameindex(void);
unsigned              if_nametoindex(const char *);
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XSH if_freenameindex(), if_indextoname(), if_nameindex(), if_nametoindex()
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
Issue 7
This reference page is clarified with respect to macros and symbolic constants.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/glob.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
glob.h — pathname pattern-matching types
SYNOPSIS
#include
DESCRIPTION
The  header shall define the structures and symbolic constants used by the glob() function.
The  header shall define the glob_t structure type, which shall include at least the following
members:
size_t   gl_pathc Count of paths matched by pattern.
char   **gl_pathv Pointer to a list of matched pathnames.
size_t   gl_offs  Slots to reserve at the beginning of gl_pathv.
The  header shall define the size_t type as described in .
The  header shall define the following symbolic constants as values for the flags argument:
GLOB_APPEND
Append generated pathnames to those previously obtained.
GLOB_DOOFFS
Specify how many null pointers to add to the beginning of gl_pathv.
GLOB_ERR
Cause glob() to return on error.
GLOB_MARK
Each pathname that is a directory that matches pattern has a  appended.
GLOB_NOCHECK
If pattern does not match any pathname, then return a list consisting of only pattern.
GLOB_NOESCAPE
Disable backslash escaping.
GLOB_NOSORT
Do not sort the pathnames returned.
The  header shall define the following symbolic constants as error return values:
GLOB_ABORTED
The scan was stopped because GLOB_ERR was set or (*errfunc)() returned non-zero.
GLOB_NOMATCH
The pattern does not match any existing pathname, and GLOB_NOCHECK was not set in flags.
GLOB_NOSPACE
An attempt to allocate memory failed.
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
int  glob(const char *restrict, int, int(*)(const char *, int),
glob_t *restrict);
void globfree(glob_t *);
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XSH glob()
CHANGE HISTORY
First released in Issue 4. Derived from the ISO POSIX-2 standard.
Issue 6
The restrict keyword is added to the prototype for glob().
The GLOB_NOSYS constant is marked obsolescent.
IEEE Std 1003.1-2001/Cor 1-2002, item XBD/TC1/D6/8 is applied, correcting the glob() prototype definition by removing the restrict qualifier from the function pointer
argument.
Issue 7
SD5-XBD-ERN-56 is applied, adding a reference to  for the
size_t
The obsolescent GLOB_NOSYS constant is removed.
This reference page is clarified with respect to macros and symbolic constants.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/V1_chap04.html =====
General Concepts
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
4. General Concepts
For the purposes of POSIX.1-2024, the general concepts given in 4. General Concepts apply.
Note:
No shading to denote extensions or options occurs in this chapter. Where the terms and definitions given in this chapter are
used elsewhere in text related to extensions and options, they are shaded as appropriate.
4.1 Case Insensitive Comparisons
When a standard utility or function that uses regular expressions or pattern matching specifies that matching shall be case
insensitive, then if a string would match the regular expression or pattern when doing a case-sensitive match, the same string with
any of its characters replaced with their case counterparts, as defined by the toupper and tolower character mappings
(see 7.3.1 LC_CTYPE), shall also match when doing a case-insensitive
match.
This definition of case-insensitive processing is intended to allow matching of multi-character collating elements as well as
characters, as each character in the string is matched using both its cases. For example, in a locale with a "Ch"
multi-character collating element (see 7.3.2 LC_COLLATE), the bracket
expression "[[.Ch.]]" (see 9.3.5 RE Bracket Expression item
4) matches the strings "ch", "Ch", "cH", and "CH" when matching without regard to case.
4.2 Concurrent Execution
Functions that suspend the execution of the calling thread shall not cause the execution of other threads to be indefinitely
suspended.
4.3 Default Initialization
Default initialization causes an object to be initialized according to these rules:
If it has pointer type, it is initialized to a null pointer.
If it has arithmetic type, it is initialized to (positive or unsigned) zero.
If it is an aggregate, every member is initialized (recursively) according to these rules.
If it is a union, the first named member is initialized (recursively) according to these rules.
For an object of aggregate type with an explicit initializer, the initialization shall occur in initializer list order, each
initializer provided for a particular subobject overriding any previously listed initializer for the same subobject; all subobjects
that are not initialized explicitly shall be initialized implicitly according to the rules for default initialization.
Objects with static storage duration but no explicit initializer shall be initialized implicitly according to the rules for
default initialization.
An explicit initializer of { 0 } works to perform explicit default initialization for any object of scalar or aggregate
type, and for any storage duration.
Notes:
The ISO C standard does not require a compiler to set any field alignment padding bits in a structure or array definition
to a particular value. Because of this, a structure initialized using { 0 } might not memcmp() as equal to the same structure initialized using memset() to zero. For consistent results, portable applications comparing structures should
test each field individually.
If an implementation treats the all-zero bit pattern of a floating-point object as equivalent to positive 0, then memset() to zero and calloc() have the same
effects as default initialization for all named members of a structure. Implementations that define __STDC_IEC_559__ guarantee that
the all-zero bit pattern of a floating-point object represents 0.0.
4.4 Directory Operations
All file system operations that read or search a directory or that modify the contents of a directory (for example creating,
unlinking, or renaming a file) shall operate atomically. That is, each operation shall either have its entire effect and succeed,
or shall not affect the file system and shall fail. Furthermore, these operations shall be serializable; that is, the state of the
file system and of the results of each operation shall always be values that would be obtained if the operations were executed one
after the other.
4.5 Directory Protection
If a directory is writable and the mode bit S_ISVTX is set on the directory, a process may remove or rename files within that
directory only if one or more of the following is true:
The effective user ID of the process is the same as that of the owner ID of the file.
The effective user ID of the process is the same as that of the owner ID of the directory.
The process has appropriate privileges.
Optionally, the file is writable by the process. Whether or not files that are writable by the process can be removed or renamed
is implementation-defined.
If the S_ISVTX bit is set on a non-directory file, the behavior is unspecified.
4.6 Extended Security Controls
An implementation may provide implementation-defined extended security controls (see 3.135 Extended Security Controls). These permit an implementation to provide
security mechanisms to implement different security policies than those described in POSIX.1-2024. These mechanisms shall not alter
or override the defined semantics of any of the interfaces in POSIX.1-2024.
4.7 File Access Permissions
The standard file access control mechanism uses the file permission bits, as described below.
Implementations may provide additional or alternate file access control mechanisms, or both. An additional access
control mechanism shall only further restrict the access permissions defined by the file permission bits. An alternate file access
control mechanism shall:
Specify file permission bits for the file owner class, file group class, and file other class of that file, corresponding to the
access permissions.
Be enabled only by explicit user action, on a per-file basis by the file owner or a user with appropriate privileges.
Be disabled for a file after the file permission bits are changed for that file with chmod(). The disabling of the alternate mechanism need not disable any additional mechanisms
supported by an implementation.
Whenever a process requests file access permission for read, write, or execute/search, if no additional mechanism denies access,
access shall be determined as follows:
If a process has appropriate privileges:
If read, write, or directory search permission is requested, access shall be granted.
If execute permission is requested, access shall be granted if execute permission is granted to at least one user by the file
permission bits or by an alternate access control mechanism; otherwise, access shall be denied.
Otherwise:
The file permission bits of a file contain read, write, and execute/search permissions for the file owner class, file group
class, and file other class.
Access shall be granted if an alternate access control mechanism is not enabled and the requested access permission bit is set
for the class (file owner class, file group class, or file other class) to which the process belongs, or if an alternate access
control mechanism is enabled and it allows the requested access; otherwise, access shall be denied.
4.8 File Hierarchy
Files in the system are organized in a hierarchical structure in which all of the non-terminal nodes are directories and all of
the terminal nodes are any other type of file. Since multiple directory entries may refer to the same file, the hierarchy is
properly described as a "directed graph".
4.9 Filenames
Uppercase and lowercase letters shall retain their unique identities between conforming implementations.
4.10 Filename Portability
For a filename to be portable across implementations conforming to POSIX.1-2024, it shall consist only of the portable filename
character set as defined in 3.265 Portable Filename Character Set.
Note:
Applications should avoid using filenames that have the  character as the first character since this may
cause problems when filenames are passed as command line arguments.
4.11 File System Cache
If the file system is accessed via a memory cache, file-related requirements stated in the rest of this standard shall apply to
the cache, except where explicitly stated otherwise: this includes directory atomicity and serializability requirements (see
4.4 Directory Operations), file times update requirements (see 4.12 File Times
Update), and read-write serializability requirements (see write()).
Cache entries shall be transferred to the underlying storage as the result of successful calls to fdatasync(), fsync(), or aio_fsync(), and may be transferred to storage automatically at other times. Such
transfers shall be atomic, with minimum units being directory entries (for directory contents), aligned data blocks of the
fundamental file system block size (for regular-file contents; see ), and all attributes of a single file (for file attributes).
Note:
If the system crashes before the cache is fully transferred, later operations' effects may be present in storage with earlier
effects missing.
Note:
Operations that create or modify multiple directory entries, aligned data blocks, or file attributes (e.g., mkdir(), rename(), write() with large buffer size, open() with
O_CREAT) may have only part of their effects transferred to storage, and after a crash these operations may appear to have been
only partly done, with the parts not necessarily done in any order. For example, only the second half of a write() may be transferred; or rename("a","b") may result in b being created
without a being removed.
Note:
Although conforming file systems are required to perform all caching as described above, some file systems may support
non-conforming configurations (for example via mount options) for which this is not the case. Applications that are used on
non-conforming file systems cannot rely on files being synchronized properly.
4.12 File Times Update
Many operations have requirements to update file timestamps. These requirements do not apply to streams that have no underlying
file description (for example, memory streams created by open_memstream()
have no underlying file description).
Each file has three distinct associated timestamps: the time of last data access, the time of last data modification, and the
time the file status last changed. These values are returned in the file characteristics structure struct stat, as described
in .
Each function or utility in POSIX.1-2024 that reads or writes data (even if the data does not change) or performs an operation
to change file status (even if the file status does not change) indicates which of the appropriate timestamps shall be marked for
update. If an implementation of such a function or utility marks for update one of these timestamps in a place or time not
specified by POSIX.1-2024, this shall be documented, except that any changes caused by pathname resolution need not be documented.
For the other functions or utilities in POSIX.1-2024 (those that are not explicitly required to read or write file data or change
file status, but that in some implementations happen to do so), the effect is unspecified.
An implementation may update timestamps that are marked for update immediately, or it may update such timestamps periodically.
At the point in time when an update occurs, any marked timestamps shall be set to the current time and the update marks shall be
cleared. All timestamps that are marked for update shall be updated when the file ceases to be open by any process or before a
fstat(), fstatat(), fsync(), futimens(), lstat(), stat(), utimensat(), or utimes() is successfully
performed on the file. Other times at which updates are done are unspecified. Marks for update, and updates themselves, shall not
be done for files on read-only file systems; see 3.295 Read-Only File
System.
The resolution of timestamps of files in a file system is implementation-defined, but shall be no coarser than one-second
resolution. The three timestamps shall always have values that are supported by the file system. Whenever any of a file's
timestamps are to be set to a value V according to the rules of the preceding paragraphs of this section, the implementation
shall immediately set the timestamp to the greatest value supported by the file system that is not greater than V.
4.13 Host and Network Byte Orders
When data is transmitted over the network, it is sent as a sequence of octets (8-bit unsigned values). If an entity (such as an
address or a port number) can be larger than 8 bits, it needs to be stored in several octets. The convention is that all such
values are stored with 8 bits in each octet, and with the first (lowest-addressed) octet holding the most-significant bits. This is
called "network byte order".
Network byte order may not be convenient for processing actual values. For this, it is more sensible for values to be stored as
ordinary integers. This is known as "host byte order". In host byte order:
The most significant bit might not be stored in the first byte in address order.
Bits might not be allocated to bytes in any obvious order at all.
8-bit values stored in uint8_t objects do not require conversion to or from host byte order, as they have the same
representation. 16 and 32-bit values can be converted using the htonl(), htons(), ntohl(), and ntohs() functions. When reading data that is to be converted to host byte order, it should
either be received directly into a uint16_t or uint32_t object or should be copied from an array of bytes using
memcpy() or similar. Passing the data through other types could cause the byte order
to be changed. Similar considerations apply when sending data.
4.14 Measurement of Execution Time
The mechanism used to measure execution time shall be implementation-defined. The implementation shall also define to whom the
CPU time that is consumed by interrupt handlers and system services on behalf of the operating system will be charged. See 3.90 CPU Time (Execution Time).
4.15 Memory Ordering and Synchronization
4.15.1 Memory Ordering
4.15.1.1 Data Races
The value of an object visible to a thread T at a particular point is the initial value of the object, a value stored in
the object by T, or a value stored in the object by another thread, according to the rules below.
Two expression evaluations conflict if one of them modifies a memory location and the other one reads or modifies the
same memory location.
This standard defines a number of atomic operations (see )
and operations on mutexes (see ) that are specially identified as
synchronization operations. These operations play a special role in making assignments in one thread visible to another. A
synchronization operation on one or more memory locations is either an acquire operation, a release operation, both
an acquire and release operation, or a consume operation. A synchronization operation without an associated memory location
is a fence and can be either an acquire fence, a release fence, or both an acquire and release fence. In addition, there are
relaxed atomic operations, which are not synchronization operations, and atomic read-modify-write operations, which
have special characteristics.
Note:
For example, a call that acquires a mutex will perform an acquire operation on the locations composing the mutex.
Correspondingly, a call that releases the same mutex will perform a release operation on those same locations. Informally,
performing a release operation on A forces prior side effects on other memory locations to become visible to other threads
that later perform an acquire or consume operation on A. Relaxed atomic operations are not included as synchronization
operations although, like synchronization operations, they cannot contribute to data races.
All modifications to a particular atomic object M occur in some particular total order, called the modification order of
M. If A and B are modifications of an atomic object M, and A happens before B, then
A shall precede B in the modification order of M, which is defined below.
Note:
This states that the modification orders must respect the "happens before" relation.
Note:
There is a separate order for each atomic object. There is no requirement that these can be combined into a single total order
for all objects. In general this will be impossible since different threads may observe modifications to different variables in
inconsistent orders.
A release sequence headed by a release operation A on an atomic object M is a maximal contiguous
sub-sequence of side effects in the modification order of M, where the first operation is A and every subsequent
operation either is performed by the same thread that performed the release or is an atomic read-modify-write operation.
Certain system interfaces synchronize with other system interfaces performed by another thread. In particular, an atomic
operation A that performs a release operation on an object M shall synchronize with an atomic operation B that
performs an acquire operation on M and reads a value written by any side effect in the release sequence headed by A.
Note:
Except in the specified cases, reading a later value does not necessarily ensure visibility as described below. Such a
requirement would sometimes interfere with efficient implementation.
Note:
The specifications of the synchronization operations define when one reads the value written by another. For atomic variables,
the definition is clear. All operations on a given mutex occur in a single total order. Each mutex acquisition "reads the value
written" by the last mutex release.
An evaluation A carries a dependency to an evaluation B if:
the value of A is used as an operand of B, unless:
B is an invocation of the kill_dependency() macro,
A is the left operand of a && or || operator,
A is the left operand of a ?: operator, or
A is the left operand of a , (comma) operator; or
A writes a scalar object or bit-field M, B reads from M the value written by A, and A
is sequenced before B, or
for some evaluation X, A carries a dependency to X and X carries a dependency to B.
An evaluation A is dependency-ordered before an evaluation B if:
A performs a release operation on an atomic object M, and, in another thread, B performs a consume
operation on M and reads a value written by any side effect in the release sequence headed by A, or
for some evaluation X, A is dependency-ordered before X and X carries a dependency to B.
An evaluation A inter-thread happens before an evaluation B if A synchronizes with B,
A is dependency-ordered before B, or, for some evaluation X:
A synchronizes with X and X is sequenced before B,
A is sequenced before X and X inter-thread happens before B, or
A inter-thread happens before X and X inter-thread happens before B.
Note:
The "inter-thread happens before" relation describes arbitrary concatenations of "sequenced before", "synchronizes with",
and "dependency-ordered before" relationships, with two exceptions. The first exception is that a concatenation is not permitted
to end with "dependency-ordered before" followed by "sequenced before". The reason for this limitation is that a consume
operation participating in a "dependency-ordered before" relationship provides ordering only with respect to operations to which
this consume operation actually carries a dependency. The reason that this limitation applies only to the end of such a
concatenation is that any subsequent release operation will provide the required ordering for a prior consume operation. The second
exception is that a concatenation is not permitted to consist entirely of "sequenced before". The reasons for this limitation are
(1) to permit "inter-thread happens before" to be transitively closed and (2) the "happens before" relation, defined below,
provides for relationships consisting entirely of "sequenced before".
An evaluation A happens before an evaluation B if A is sequenced before B or A
inter-thread happens before B. The implementation shall ensure that a cycle in the "happens before" relation never occurs.
Note:
This cycle would otherwise be possible only through the use of consume operations.
A visible side effect A on an object M with respect to a value computation B of M satisfies
the conditions:
A happens before B, and
there is no other side effect X to M such that A happens before X and X happens before
B.
The value of a non-atomic scalar object M, as determined by evaluation B, shall be the value stored by the visible
side effect A.
Note:
If there is ambiguity about which side effect to a non-atomic object is visible, then there is a data race and the behavior is
undefined.
Note:
This states that operations on ordinary variables are not visibly reordered. This is not actually detectable without data
races, but it is necessary to ensure that data races, as defined here, and with suitable restrictions on the use of atomics,
correspond to data races in a simple interleaved (sequentially consistent) execution.
The value of an atomic object M, as determined by evaluation B, shall be the value stored by some side effect
A that modifies M, where B does not happen before A.
Note:
The set of side effects from which a given evaluation might take its value is also restricted by the rest of the rules
described here, and in particular, by the coherence requirements below.
If an operation A that modifies an atomic object M happens before an operation B that modifies M,
then A shall be earlier than B in the modification order of M. (This is known as "write-write
coherence".)
If a value computation A of an atomic object M happens before a value computation B of M, and
A takes its value from a side effect X on M, then the value computed by B shall either be the value
stored by X or the value stored by a side effect Y on M, where Y follows X in the modification
order of M. (This is known as "read-read coherence".)
If a value computation A of an atomic object M happens before an operation B on M, then A
shall take its value from a side effect X on M, where X precedes B in the modification order of
M. (This is known as "read-write coherence".)
If a side effect X on an atomic object M happens before a value computation B of M, then the
evaluation B shall take its value from X or from a side effect Y that follows X in the modification
order of M. (This is known as "write-read coherence".)
Note:
This effectively disallows implementation reordering of atomic operations to a single object, even if both operations are
"relaxed" loads. By doing so, it effectively makes the "cache coherence" guarantee provided by most hardware available to POSIX
atomic operations.
Note:
The value observed by a load of an atomic object depends on the "happens before" relation, which in turn depends on the
values observed by loads of atomic objects. The intended reading is that there must exist an association of atomic loads with
modifications they observe that, together with suitably chosen modification orders and the "happens before" relation derived as
described above, satisfy the resulting constraints as imposed here.
An application contains a data race if it contains two conflicting actions in different threads, at least one of which is not
atomic, and neither happens before the other. Any such data race results in undefined behavior.
4.15.1.2 Memory Order and Consistency
The enumerated type memory_order, defined in  (if
supported), specifies the detailed regular (non-atomic) memory synchronization operations as defined in 4.15.1.1 Data Races and may provide for operation ordering. Its enumeration constants specify memory order
as follows:
For memory_order_relaxed, no operation orders memory.
For memory_order_release, memory_order_acq_rel, and memory_order_seq_cst, a store operation performs
a release operation on the affected memory location.
For memory_order_acquire, memory_order_acq_rel, and memory_order_seq_cst, a load operation performs
an acquire operation on the affected memory location.
For memory_order_consume, a load operation performs a consume operation on the affected memory location.
There shall be a single total order S on all memory_order_seq_cst operations, consistent with the "happens
before" order and modification orders for all affected locations, such that each memory_order_seq_cst operation B
that loads a value from an atomic object M observes one of the following values:
the result of the last modification A of M that precedes B in S, if it exists, or
if A exists, the result of some modification of M that is not memory_order_seq_cst and that does not
happen before A, or
if A does not exist, the result of some modification of M that is not memory_order_seq_cst.
Note:
Although it is not explicitly required that S include lock operations, it can always be extended to an order that does
include lock and unlock operations, since the ordering between those is already included in the "happens before" ordering.
Note:
Atomic operations specifying memory_order_relaxed are relaxed only with respect to memory ordering. Implementations
must still guarantee that any given atomic access to a particular atomic object be indivisible with respect to all other atomic
accesses to that object.
For an atomic operation B that reads the value of an atomic object M, if there is a memory_order_seq_cst
fence X sequenced before B, then B observes either the last memory_order_seq_cst modification of
M preceding X in the total order S or a later modification of M in its modification order.
For atomic operations A and B on an atomic object M, where A modifies M and B takes
its value, if there is a memory_order_seq_cst fence X such that A is sequenced before X and B
follows X in S, then B observes either the effects of A or a later modification of M in its
modification order.
For atomic modifications A and B of an atomic object M, B occurs later than A in the
modification order of M if:
there is a memory_order_seq_cst fence X such that A is sequenced before X, and X precedes
B in S, or
there is a memory_order_seq_cst fence Y such that Y is sequenced before B, and A precedes
Y in S, or
there are memory_order_seq_cst fences X and Y such that A is sequenced before X, Y
is sequenced before B, and X precedes Y in S.
Atomic read-modify-write operations shall always read the last value (in the modification order) stored before the write
associated with the read-modify-write operation.
An atomic store shall only store a value that has been computed from constants and input values by a finite sequence of
evaluations, such that each evaluation observes the values of variables as computed by the last prior assignment in the sequence.
The ordering of evaluations in this sequence shall be such that:
If an evaluation B observes a value computed by A in a different thread, then B does not happen before
A.
If an evaluation A is included in the sequence, then all evaluations that assign to the same variable and happen before
A are also included.
Note:
The second requirement disallows "out-of-thin-air", or "speculative" stores of atomics when relaxed atomics are used. Since
unordered operations are involved, evaluations can appear in this sequence out of thread order.
4.15.2 Memory Synchronization
In order to avoid data races, applications shall ensure that non-lock-free access to any memory location by more than one thread
of control (threads or processes) is restricted such that no thread of control can read or modify a memory location while another
thread of control might be modifying it. Such access can be restricted using functions that synchronize thread execution and also
synchronize memory with respect to other threads. The following functions shall synchronize memory with respect to other threads on
all successful calls:
cnd_broadcast()
cnd_signal()
fork()
pthread_barrier_wait()
pthread_cond_broadcast()
pthread_cond_signal()
pthread_create()
pthread_join()
pthread_spin_lock()
pthread_spin_trylock()
pthread_spin_unlock()
pthread_rwlock_clockrdlock()
pthread_rwlock_clockwrlock()
pthread_rwlock_rdlock()
pthread_rwlock_timedrdlock()
pthread_rwlock_timedwrlock()
pthread_rwlock_tryrdlock()
pthread_rwlock_trywrlock()
pthread_rwlock_unlock()
pthread_rwlock_wrlock()
sem_clockwait()
sem_post()
sem_timedwait()
sem_trywait()
sem_wait()
semctl()
semop()
thrd_create()
thrd_join()
wait()
waitid()
waitpid()
The pthread_once() and call_once() functions shall synchronize memory for the first successful call in each
thread for a given pthread_once_t or once_flag object, respectively. If the init_routine called by pthread_once() or call_once() is a
cancellation point and is canceled, a successful call to pthread_once() for the
same pthread_once_t object or to call_once() for the same once_flag
object, made from a cancellation cleanup handler shall also synchronize memory.
The pthread_mutex_clocklock(), pthread_mutex_lock(), [RPP|TPP]  pthread_mutex_setprioceiling(),  pthread_mutex_timedlock(), and pthread_mutex_trylock() functions shall synchronize memory on all calls that
acquire the mutex, including those that return [EOWNERDEAD]. The pthread_mutex_unlock() function shall synchronize memory on all calls that
release the mutex.
Note:
If the mutex type is PTHREAD_MUTEX_RECURSIVE, calls to the locking functions do not acquire the mutex if the calling thread
already owns it, and calls to pthread_mutex_unlock() do not release the
mutex if it has a lock count greater than one.
The pthread_cond_clockwait(), pthread_cond_wait(), and pthread_cond_timedwait() functions shall synchronize memory on all calls that
release and re-acquire the specified mutex, including calls that return [EOWNERDEAD], both when the mutex is released and when it
is re-acquired.
Note:
If the mutex type is PTHREAD_MUTEX_RECURSIVE, calls to pthread_cond_clockwait(), pthread_cond_wait(), and pthread_cond_timedwait() do not release and re-acquire the mutex if it has a
lock count greater than one.
The mtx_lock(), mtx_timedlock(), and mtx_trylock()
functions shall synchronize memory on all calls that acquire the mutex. The mtx_unlock() function shall synchronize memory on all calls that release the mutex.
Note:
If the mutex is a recursive mutex, calls to the locking functions do not acquire the mutex if the calling thread already owns
it, and calls to mtx_unlock() do not release the mutex if it has a lock count
greater than one.
The cnd_wait() and cnd_timedwait() functions shall synchronize memory on all calls that release and
re-acquire the specified mutex, both when the mutex is released and when it is re-acquired.
Note:
If the mutex is a recursive mutex, calls to cnd_wait() and cnd_timedwait() do not release and re-acquire the mutex if it has a lock count greater
than one.
Unless explicitly stated otherwise, if one of the functions named in this section returns an error, it is
unspecified whether the invocation causes memory to be synchronized.
Applications can allow more than one thread of control to read a memory location simultaneously.
For purposes of determining the existence of a data race, all lock and unlock operations on a particular
synchronization object that synchronize memory shall behave as atomic operations, and they shall occur in some particular total
order (see 4.15.1 Memory Ordering).
4.16 Pathname Resolution
Pathname resolution is performed for a process to resolve a pathname to a particular directory entry for a file in
the file hierarchy. There may be multiple pathnames that resolve to the same directory entry, and multiple directory entries for
the same file. When a process resolves a pathname of an existing directory entry, the entire pathname shall be resolved as
described below. When a process resolves a pathname of a directory entry that is to be created immediately after the pathname is
resolved, pathname resolution terminates when all components of the path prefix of the last component have been resolved. It is
then the responsibility of the process to create the final component.
Each filename in the pathname is located in the directory specified by its predecessor (for example, in the
pathname fragment a/b, file b is located in the directory specified by a). Pathname resolution shall fail if
this cannot be accomplished. If the pathname begins with a , the predecessor of the first filename in the pathname
shall be taken to be the root directory of the process (such pathnames are referred to as "absolute pathnames"). If the pathname
does not begin with a , the predecessor of the first filename of the pathname shall be taken to be either the current
working directory of the process or for certain interfaces the directory identified by a file descriptor passed to the interface
(such pathnames are referred to as "relative pathnames").
The interpretation of a pathname component is dependent on the value of {NAME_MAX} and _POSIX_NO_TRUNC associated
with the path prefix of that component. If any pathname component is longer than {NAME_MAX}, the implementation shall consider this
an error.
A pathname that contains at least one non- character and that ends with one or more trailing
characters shall not be resolved successfully unless the last pathname component before the trailing
characters resolves (with symbolic links followed—see below) to an existing directory or a directory entry that is to be created
for a directory immediately after the pathname is resolved. Interfaces using pathname resolution may specify additional
constraints1 when a pathname that does not name an existing directory contains
at least one non- character and contains one or more trailing  characters.
If a symbolic link is encountered during pathname resolution, the behavior shall depend on whether the pathname
component is at the end of the pathname and on the function being performed. If all of the following are true, then pathname
resolution is complete:
This is the last pathname component of the pathname.
The pathname has no trailing .
The function is required to act on the symbolic link itself, or certain arguments direct that the function act on
the symbolic link itself.
In all other cases, the system shall prefix the remaining pathname, if any, with the contents of the symbolic link,
except that if the contents of the symbolic link is the empty string, then either pathname resolution shall fail with functions
reporting an [ENOENT] error and utilities writing an equivalent diagnostic message, or the pathname of the directory containing the
symbolic link shall be used in place of the contents of the symbolic link. If the contents of the symbolic link consist solely of
characters, then all leading  characters of the remaining pathname shall be omitted from the resulting
combined pathname, leaving only the leading  characters from the symbolic link contents. In the cases where prefixing
occurs, if the combined length exceeds {PATH_MAX}, and the implementation considers this to be an error, pathname resolution shall
fail with functions reporting an [ENAMETOOLONG] error and utilities writing an equivalent diagnostic message. Otherwise, the
resolved pathname shall be the resolution of the pathname just created. If the resulting pathname does not begin with a
, the predecessor of the first filename of the pathname is taken to be the directory containing the symbolic link.
If the system detects a loop in the pathname resolution process, pathname resolution shall fail with functions
reporting an [ELOOP] error and utilities writing an equivalent diagnostic message. The same may happen if during the resolution
process more symbolic links were followed than the implementation allows. This implementation-defined limit shall not be smaller
than {SYMLOOP_MAX}.
The special filename dot shall refer to the directory specified by its predecessor. The special filename dot-dot
shall refer to the parent directory of its predecessor directory. As a special case, in the root directory, dot-dot may refer to
the root directory itself.
A pathname consisting of a single  shall resolve to the root directory of the process. A null pathname
shall not be successfully resolved. If a pathname begins with two successive  characters, the first component
following the leading  characters may be interpreted in an implementation-defined manner, although more than two
leading  characters shall be treated as a single  character.
Pathname resolution for a given pathname shall yield the same results when used by any interface in POSIX.1-2024 as
long as there are no changes to any files evaluated during pathname resolution for the given pathname between resolutions.
4.17 Process ID Reuse
A process group ID shall not be reused by the system until the process group lifetime ends.
A process ID shall not be reused by the system until the process lifetime ends. In addition, if there exists a
process group whose process group ID is equal to that process ID, the process ID shall not be reused by the system until the
process group lifetime ends. A process that is not a system process shall not have a process ID of 1.
4.18 Scheduling Policy
A scheduling policy affects process or thread ordering:
When a process or thread is a running thread and it becomes a blocked thread
When a process or thread is a running thread and it becomes a preempted thread
When a process or thread is a blocked thread and it becomes a runnable thread
When a running thread calls a function that can change the priority or scheduling policy of a process or
thread
In other scheduling policy-defined circumstances
Conforming implementations shall define the manner in which each of the scheduling policies may modify the
priorities or otherwise affect the ordering of processes or threads at each of the occurrences listed above. Additionally,
conforming implementations shall define in what other circumstances and in what manner each scheduling policy may modify the
priorities or affect the ordering of processes or threads.
4.19 Seconds Since the Epoch
A value that approximates the number of seconds that have elapsed since the Epoch. A Coordinated Universal Time
name (specified in terms of seconds (tm_sec), minutes (tm_min), hours (tm_hour), days since January 1 of the
year (tm_yday), and calendar year minus 1900 (tm_year)) is related to a time represented as seconds since the Epoch,
according to the expression below.
If the year is =1970 and the
value is non-negative, the value is related to a Coordinated Universal Time name according to the C-language expression, where
tm_sec, tm_min, tm_hour, tm_yday, and tm_year are all integer types:
tm_sec + tm_min*60 + tm_hour*3600 + tm_yday*86400 +
(tm_year-70)*31536000 + ((tm_year-69)/4)*86400 -
((tm_year-1)/100)*86400 + ((tm_year+299)/400)*86400
The relationship between the actual date and time in Coordinated Universal Time, as determined by the International
Earth Rotation Service, and the system's current value for seconds since the Epoch is unspecified.
How any changes to the value of seconds since the Epoch are made to align to a desired relationship with the
current actual time is implementation-defined. As represented in seconds since the Epoch, each and every day shall be accounted for
by exactly 86400 seconds.
Note:
The last three terms of the expression add in a day for each year that follows a leap year starting with the first leap year
since the Epoch. The first term adds a day every 4 years starting in 1973, the second subtracts a day back out every 100 years
starting in 2001, and the third adds a day back in every 400 years starting in 2001. The divisions in the formula are integer
divisions; that is, the remainder is discarded leaving only the integer quotient.
4.20 Semaphore
A minimum synchronization primitive to serve as a basis for more complex synchronization mechanisms to be defined
by the application program.
For the mandatory semaphores (those not associated with the X/Open System Interfaces (XSI) option), a semaphore is
represented as a shareable resource that has a non-negative integer value. When the value is zero, there is a (possibly empty) set
of threads awaiting the availability of the semaphore.
For the semaphores associated with the X/Open System Interfaces (XSI) option, a semaphore is an integer with
minimum value 0 and an implementation-defined maximum value which shall be at least 32767. The semget() function can be called to create a set or array of semaphores. A semaphore set can
contain one or more semaphores up to an implementation-defined value.
Semaphore Lock Operation
An operation that is applied to a semaphore. If, prior to the operation, the value of the semaphore is zero, the
semaphore lock operation shall cause the calling thread to be blocked and added to the set of threads awaiting the semaphore;
otherwise, the value shall be decremented.
Semaphore Unlock Operation
An operation that is applied to a semaphore. If, prior to the operation, there are any threads in the set of
threads awaiting the semaphore, then some thread from that set shall be removed from the set and becomes unblocked; otherwise, the
semaphore value shall be incremented.
4.21 Special Device Drivers
Some devices require control operations, other than the operations that are common to most devices (such as
read(), write(), open(), and close()), but because the device
belongs to a class that is not present in the majority of systems, standardization of a device-specific application program
interface (API) for controlling it has not been practical. The driver for such a device may respond to the write() function to transfer data to the device or the read() function to collect information from the device. The interpretation of the information
is defined by the implementor of the driver.
The term special device refers to hardware, or an object that appears to the application as such; access to
the driver for this hardware uses the file abstraction character special file. Implementations supporting the Device Control
option shall provide the means to integrate a device driver into the system. The means available to integrate drivers into the
system and the way character special files that refer to them are created are implementation defined. Character special files that
have no structure defined by this standard can be accessed using the posix_devctl() function defined in the System Interfaces volume of POSIX.1-2024.
4.22 Thread-Safety
Refer to XSH 2.9 Threads.
4.23 Treatment of Error Conditions for Mathematical Functions
For all the functions in the  header, an application
wishing to check for error situations should set errno to 0 and call feclearexcept(FE_ALL_EXCEPT) before calling the
function. On return, if errno is non-zero or fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is
non-zero, an error has occurred.
On implementations that support the IEC 60559 Floating-Point option, whether or when functions in the  header raise an undeserved underflow floating-point exception is unspecified.
Otherwise, as implied by XSH feraiseexcept(), the  functions do not raise spurious floating-point exceptions (detectable by the
user), other than the inexact floating-point exception.
The error conditions defined for all functions in the
header are domain, pole and range errors, described below. If a domain, pole, or range error occurs and the integer expression
(math_errhandling & MATH_ERRNO) is zero, then errno shall either be set to the value corresponding to the error, as
specified below, or be left unmodified. If no such error occurs, errno shall be left unmodified regardless of the setting of
math_errhandling.
4.23.1 Domain Error
A "domain error" shall occur if an input argument is outside the domain over which the mathematical function is
defined. The description of each function lists any required domain errors; an implementation may define additional domain errors,
provided that such errors are consistent with the mathematical definition of the function.
On a domain error, the function shall return an implementation-defined value; if the integer expression
(math_errhandling & MATH_ERRNO) is non-zero, errno shall be set to [EDOM]; if the integer expression (math_errhandling &
MATH_ERREXCEPT) is non-zero, the "invalid" floating-point exception shall be raised.
4.23.2 Pole Error
A "pole error" shall occur if the mathematical result of the function has an exact infinite result as the finite
input argument(s) are approached in the limit (for example, log(0.0)). The description of each function lists any required
pole errors; an implementation may define additional pole errors, provided that such errors are consistent with the mathematical
definition of the function.
On a pole error, the function shall return the value of the macro HUGE_VAL, HUGE_VALF, or HUGE_VALL according to
the return type, with the same sign as the correct value of the function; if the integer expression (math_errhandling & MATH_ERRNO)
is non-zero, errno shall be set to [ERANGE]; if the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, the
"divide-by-zero" floating-point exception shall be raised.
4.23.3 Range Error
A "range error" shall occur if the finite mathematical result of the function cannot be represented in an object
of the specified type, due to extreme magnitude. The description of each function lists any required range errors; an
implementation may define additional range errors, provided that such errors are consistent with the mathematical definition of the
function and are the result of either overflow or underflow.
4.23.3.1 Result Overflows
A floating result overflows if the magnitude of the mathematical result is finite but so large that the
mathematical result cannot be represented without extraordinary roundoff error in an object of the specified type. If a floating
result overflows and default rounding is in effect, then the function shall return the value of the macro HUGE_VAL, HUGE_VALF, or
HUGE_VALL according to the return type, with the same sign as the correct value of the function; if the integer expression
(math_errhandling & MATH_ERRNO) is non-zero, errno shall be set to [ERANGE]; if the integer expression (math_errhandling &
MATH_ERREXCEPT) is non-zero, the "overflow" floating-point exception shall be raised.
4.23.3.2 Result Underflows
The result underflows if the magnitude of the mathematical result is so small that the mathematical result cannot
be represented, without extraordinary roundoff error, in an object of the specified type. If the result underflows, the function
shall return an implementation-defined value whose magnitude is no greater than the smallest normalized positive number in the
specified type; if the integer expression (math_errhandling & MATH_ERRNO) is non-zero, whether errno is set to [ERANGE] is
implementation-defined; if the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, whether the "underflow"
floating-point exception is raised is implementation-defined.
4.24 Treatment of NaN Arguments for the Mathematical Functions
For functions called with a NaN argument, no errors shall occur and a NaN shall be returned, except where stated
otherwise.
If a function with one or more NaN arguments returns a NaN result, the result should be the same as one of the NaN
arguments (after possible type conversion), except perhaps for the sign.
On implementations that support the IEC 60559:1989 standard floating point, functions with signaling NaN
argument(s) shall be treated as if the function were called with an argument that is a required domain error and shall return a
quiet NaN result, except where stated otherwise.
Note:
The function might never see the signaling NaN, since it might trigger when the arguments are evaluated during the function
call.
On implementations that support the IEC 60559:1989 standard floating point, for those functions that do not
have a documented domain error, the following shall apply:
These functions shall fail if:
Domain Error
Any argument is a signaling NaN.
Either, the integer expression (math_errhandling & MATH_ERRNO) is non-zero and errno shall be set to [EDOM],
or the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero and the invalid floating-point exception shall be
raised.
4.25 Utility
A utility program shall be either an executable file, such as might be produced by a compiler or linker system from
computer source code, or a file of shell source code, directly interpreted by the shell. The program may have been produced by the
user, provided by the system implementor, or acquired from an independent distributor.
The system may implement certain utilities as shell functions (see XCU 2.9.5 Function Definition Command) or built-in utilities, but only an
application that is aware of the command search order (as described in XCU 2.9.1.4 Command Search and Execution) or of performance characteristics
can discern differences between the behavior of such a function or built-in utility and that of an executable file.
4.26 Variable Assignment
In the shell command language, a word consisting of the following parts:
varname=value
When used in a context where assignment is defined to occur and at no other time, the value (representing a
word or field) shall be assigned as the value of the variable denoted by varname. Assignment context occurs in the
cmd_prefix portion of a shell simple command, as well as in arguments of a recognized declaration utility.
Note:
For further information, see XCU 2.9.1 Simple Commands.
The varname and value parts shall meet the requirements for a name and a word, respectively, except
that they are delimited by the embedded unquoted , in addition to other delimiters.
Note:
Additional delimiters are described in XCU 2.3 Token Recognition
.
When a variable assignment is done, the variable shall be created if it did not already exist. If value is
not specified, the variable shall be given a null value.
Note:
An alternative form of variable assignment:
symbol=value
(where symbol is a valid word delimited by an , but not a valid name) produces
unspecified results. The form symbol=value is used by the KornShell name[expression]=value
syntax.
Footnotes
1. The only interfaces that further constrain pathnames in POSIX.1-2024 are the
rename() and renameat() functions
(see XSH rename()) and the mv utility
(see XCU mv).
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/V1_chap12.html =====
Utility Conventions
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
12. Utility Conventions
12.1 Utility Argument Syntax
This section describes the argument syntax of the standard utilities and introduces terminology used throughout POSIX.1-2024 for
describing the arguments processed by the utilities.
Within POSIX.1-2024, a special notation is used for describing the syntax of a utility's arguments. Unless otherwise noted, all
utility descriptions use this notation, which is illustrated by this example (see XCU 2.9.1 Simple Commands):
utility_name [-a] [-b] [-c option_argument]
[-d|-e] [-f[option_argument]] [operand...]
The notation used for the SYNOPSIS sections imposes requirements on the implementors of the standard utilities and provides a
simple reference for the application developer or system user.
The utility in the example is named utility_name. It is followed by options, option-arguments, and operands. The
arguments that consist of  characters and single letters or digits, such as 'a', are known as
"options" (or, historically, "flags"). Certain options are followed by an "option-argument", as shown with [-c
option_argument]. The arguments following the last options and option-arguments are named "operands".
Option-arguments are shown separated from their options by  characters, except when the option-argument is enclosed
in the '[' and ']' notation to indicate that it is optional. This reflects the situation in which an optional
option-argument (if present) is included within the same argument string as the option; for a mandatory option-argument, it is the
next argument. The Utility Syntax Guidelines in 12.2 Utility Syntax Guidelines require that the option be
a separate argument from its option-argument and that option-arguments not be optional, but there are some exceptions in
POSIX.1-2024 to provide for continued operation of historical applications:
If the SYNOPSIS of a standard utility shows an option with a mandatory option-argument (as with [-c
option_argument] in the example), a conforming application shall use separate arguments for that option and its
option-argument. However, a conforming implementation shall also permit applications to specify the option and option-argument in
the same argument string without intervening  characters.
If the SYNOPSIS shows an optional option-argument (as with [-f[option_argument]] in the example), a conforming
application shall place any option-argument for that option directly adjacent to the option in the same argument string, without
intervening  characters. If the utility receives an argument containing only the option, it shall behave as specified
in its description for an omitted option-argument; it shall not treat the next argument (if any) as the option-argument for that
option.
Options are usually listed in alphabetical order unless this would make the utility description more confusing. There are no
implied relationships between the options based upon the order in which they appear, unless otherwise stated in the OPTIONS
section, or unless the exception in Guideline 11 of 12.2 Utility Syntax Guidelines applies. If an option
that does not have option-arguments is repeated, the results are undefined, unless otherwise stated.
Frequently, names of parameters that require substitution by actual values are shown with embedded
characters. Alternatively, parameters are shown as follows:
The angle brackets are used for the symbolic grouping of a phrase representing a single parameter and conforming applications
shall not include them in data submitted to the utility.
When a utility has only a few permissible options, they are sometimes shown individually, as in the example. Utilities with many
flags generally show all of the individual flags (that do not take option-arguments) grouped, as in:
utility_name [-abcDxyz] [-p arg] [operand]
Utilities with very complex arguments may be shown as follows:
utility_name [options] [operands]
Unless otherwise specified, whenever an operand or option-argument is, or contains, a numeric value:
The number is interpreted as a decimal integer.
Numerals in the range 0 to 2147483647 are syntactically recognized as numeric values.
When the utility description states that it accepts negative numbers as operands or option-arguments, numerals in the range
-2147483647 to 2147483647 are syntactically recognized as numeric values.
When the utility description states that the number is a file size-related value (such as a file size or offset, line number, or
block count), numerals in the range 0 to the maximum file size supported by the implementation are syntactically recognized as
numeric values (see XCU 1.5 Considerations for Utilities in Support of Files of
Arbitrary Size). Where negative values are permitted, any value in the range -(maximum file size) to the maximum file size
is accepted.
Ranges greater than those listed here are allowed.
This does not mean that all numbers within the allowable range are necessarily semantically correct. A standard utility that
accepts an option-argument or operand that is to be interpreted as a number, and for which a range of values smaller than that
shown above is permitted by the POSIX.1-2024, describes that smaller range along with the description of the option-argument or
operand. If an error is generated, the utility's diagnostic message shall indicate that the value is out of the supported range,
not that it is syntactically incorrect.
Arguments or option-arguments enclosed in the '[' and ']' notation are optional and can be omitted. Conforming
applications shall not include the '[' and ']' symbols in data submitted to the utility.
Arguments separated by the '|' () bar notation are mutually-exclusive. Conforming applications
shall not include the '|' symbol in data submitted to the utility. Alternatively, mutually-exclusive options and operands
may be listed with multiple synopsis lines.
For example:
utility_name -d [-a] [-c option_argument] [operand...]
utility_name [-a] [-b] [operand...]
When multiple synopsis lines are given for a utility, it is an indication that the utility has mutually-exclusive arguments.
These mutually-exclusive arguments alter the functionality of the utility so that only certain other arguments are valid in
combination with one of the mutually-exclusive arguments. Only one of the mutually-exclusive arguments is allowed for invocation of
the utility. Unless otherwise stated in an accompanying OPTIONS section, the relationships between arguments depicted in the
SYNOPSIS sections are mandatory requirements placed on conforming applications. The use of conflicting mutually-exclusive arguments
produces undefined results, unless a utility description specifies otherwise. When an option is shown without the '[' and
']' brackets, it means that option is required for that version of the SYNOPSIS. However, it is not required to be the
first argument, as shown in the example above, unless otherwise stated.
Ellipses ("...") are used to denote that one or more occurrences of an operand are allowed. When an option or an
operand followed by ellipses is enclosed in brackets, zero or more options or operands can be specified. The form:
utility_name [-g option_argument]... [operand...]
indicates that multiple occurrences of the option and its option-argument preceding the ellipses are valid, with semantics as
indicated in the OPTIONS section of the utility. (See also Guideline 11 in 12.2 Utility Syntax Guidelines
.)
The form:
utility_name -f option_argument [-f option_argument]... [operand...]
indicates that the -f option is required to appear at least once and may appear multiple times.
When the synopsis line is too long to be printed on a single line in the Shell and Utilities volume of POSIX.1-2024, the
indented lines following the initial line are continuation lines. An actual use of the command would appear on a single logical
line.
12.2 Utility Syntax Guidelines
The following guidelines are established for the naming of utilities and for the specification of options, option-arguments, and
operands. The getopt() function in the System Interfaces volume of POSIX.1-2024
assists utilities in handling options and operands that conform to these guidelines.
Operands and option-arguments can contain characters not specified in the portable character set.
The guidelines are intended to provide guidance to the authors of future utilities, such as those written specific to a local
system or that are components of a larger application. Some of the standard utilities do not conform to all of these guidelines; in
those cases, the OPTIONS sections describe the deviations.
Guideline 1:
Utility names should be between two and nine characters, inclusive.
Guideline 2:
Utility names should include lowercase letters (the lower character classification) and digits only from the portable
character set.
Guideline 3:
Each option name should be a single alphanumeric character (the alnum character classification) from the portable
character set. The -W (capital-W) option shall be reserved for vendor options.
Multi-digit options should not be allowed.
Guideline 4:
All options should be preceded by the '-' delimiter character.
Guideline 5:
One or more options without option-arguments, followed by at most one option that takes an option-argument, should be accepted
when grouped behind one '-' delimiter.
Guideline 6:
Each option and option-argument should be a separate argument, except as noted in 12.1 Utility Argument
Syntax, item (2).
Guideline 7:
Option-arguments should not be optional.
Guideline 8:
When multiple option-arguments are specified to follow a single option, they should be presented as a single argument, using
characters within that argument or  characters within that argument to separate them.
Guideline 9:
All options should precede operands on the command line.
Guideline 10:
The first -- argument that is not an option-argument should be accepted as a delimiter indicating the end of options.
Any following arguments should be treated as operands, even if they begin with the '-' character.
Guideline 11:
The order of different options relative to one another should not matter, unless the options are documented as
mutually-exclusive and such an option is documented to override any incompatible options preceding it. If an option that has
option-arguments is repeated, the option and option-argument combinations should be interpreted in the order specified on the
command line.
Guideline 12:
The order of operands may matter and position-related interpretations should be determined on a utility-specific basis.
Guideline 13:
For utilities that use operands to represent files to be opened for either reading or writing, the '-' operand should
be used to mean only standard input (or standard output when it is clear from context that an output file is being specified) or a
file named -.
Guideline 14:
If an argument can be identified according to Guidelines 3 through 10 as an option, or as a group of options without
option-arguments behind one '-' delimiter, then it should be treated as such.
The utilities in the Shell and Utilities volume of POSIX.1-2024 that claim conformance to these guidelines shall conform
completely to these guidelines as if these guidelines contained the term "shall" instead of "should". On some implementations,
the utilities accept usage in violation of these guidelines for backwards-compatibility as well as accepting the required form.
Where a utility described in the Shell and Utilities volume of POSIX.1-2024 as conforming to these guidelines is required to
accept, or not to accept, the operand '-' to mean standard input or output, this usage is explained in the OPERANDS
section. Otherwise, if such a utility uses operands to represent files, it is implementation-defined whether the operand
'-' stands for standard input (or standard output), or for a file named -.
It is recommended that all future utilities and applications use these guidelines to enhance user portability. The fact that
some historical utilities could not be changed (to avoid breaking existing applications) should not deter this future goal.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/contents.html =====
Base Definitions: Table of contents
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
Base Definitions: Table of Contents
1. Introduction
1.1 Scope
1.2 Word Usage
1.3 Conformance
1.4 Normative References
1.5 Change History
1.6 Terminology
can
implementation-defined
legacy
may
shall
should
undefined
unspecified
1.7 Definitions and Concepts
1.8 Portability
1.8.1 Codes
1.8.2 Margin Code Notation
A Feature Dependent on One or Two Options
A Feature Dependent on Either of the Options Denoted
A Feature Dependent on More than Two Options
Large Sections Dependent on an Option
Footnotes
2. Conformance
2.1 Implementation Conformance
2.1.1 Requirements
2.1.2 Documentation
2.1.3 POSIX Conformance
2.1.3.1 POSIX System Interfaces
2.1.3.2 POSIX Shell and Utilities
2.1.4 XSI Conformance
2.1.4.1 XSI System Interfaces
2.1.4.2 XSI Shell and Utilities Conformance
2.1.5 Option Groups
2.1.5.1 Subprofiling Considerations
2.1.5.2 XSI Option Groups
Encryption
Realtime
Advanced Realtime
Realtime Threads
Advanced Realtime Threads
2.1.6 Options
2.1.6.1 System Interfaces
2.1.6.2 Shell and Utilities
2.2 Application Conformance
2.2.1 Strictly Conforming POSIX Application
2.2.2 Conforming POSIX Application
2.2.2.1 ISO/IEC Conforming POSIX Application
2.2.2.2  Conforming POSIX Application
2.2.3 Conforming POSIX Application Using Extensions
2.2.4 Strictly Conforming XSI Application
2.2.5 Conforming XSI Application Using Extensions
2.3 Language-Dependent Services for the C Programming Language
2.4 Other Language-Related Specifications
Footnotes
3. Definitions
3.1 Abortive Release
3.2 Absolute Pathname
3.3 Access Mode
3.4 Additional File Access Control Mechanism
3.5 Address Space
3.6 Advisory Information
3.7 Affirmative Response
3.8 Alert
3.9 Alert Character ()
3.10 Alias Name
3.11 Alignment
3.12 Alternate File Access Control Mechanism
3.13 Alternate Signal Stack
3.14 Ancillary Data
3.15 Angle Brackets
3.16 Anonymous Memory Object
3.17 Apostrophe Character ()
3.18 Application
3.19 Application Address
3.20 Application Program Interface (API)
3.21 Appropriate Privileges
3.22 Argument
3.23 Arm (a Timer)
3.24 Asterisk Character ()
3.25 Async-Cancel-Safe Function
3.26 Asynchronous Events
3.27 Asynchronous Input and Output
3.28 Async-Signal-Safe Function
3.29 Asynchronously-Generated Signal
3.30 Asynchronous I/O Completion
3.31 Asynchronous I/O Operation
3.32 Atomic Operation
3.33 Authentication
3.34 Authorization
3.35 Background Job
3.36 Background Process
3.37 Background Process Group
3.38 Backquote Character
3.39 Backslash Character ()
3.40 Backspace Character ()
3.41 Barrier
3.42 Basename
3.43 Basic Regular Expression (BRE)
3.44 Bind
3.45 Blank Character ()
3.46 Blank Line
3.47 Blocked Process (or Thread)
3.48 Blocking
3.49 Block-Mode Terminal
3.50 Block Special File
3.51 Braces
3.52 Brackets
3.53 Broadcast
3.54 Built-In Utility (or Built-In)
3.55 Byte
3.56 Byte Input/Output Functions
3.57 Carriage-Return Character ()
3.58 Character
3.59 Character Array
3.60 Character Class
3.61 Character Set
3.62 Character Special File
3.63 Character String
3.64 Child Process
3.65 Circumflex Character ()
3.66 Clock
3.67 Clock Jump
3.68 Clock Tick
3.69 Code Block
3.70 Coded Character Set
3.71 Codeset
3.72 Collating Element
3.73 Collation
3.74 Collation Sequence
3.75 Column Position
3.76 Command
3.77 Command Language Interpreter
3.78 Composite Graphic Symbol
3.79 Condition Variable
3.80 Connected Socket
3.81 Connection
3.82 Connection Mode
3.83 Connectionless Mode
3.84 Control Character
3.85 Control Operator
3.86 Controlling Process
3.87 Controlling Terminal
3.88 Conversion Descriptor
3.89 Core Image
3.90 CPU Time (Execution Time)
3.91 CPU-Time Clock
3.92 CPU-Time Timer
3.93 Current Job
3.94 Current Working Directory
3.95 Cursor Position
3.96 Datagram
3.97 Data Race
3.98 Data Segment
3.99 Decimal-Point Character
3.100 Declaration Utility
3.101 Device
3.102 Device ID
3.103 Directory
3.104 Directory Entry (or Hard Link)
3.105 Directory Stream
3.106 Disarm (a Timer)
3.107 Display
3.108 Display Line
3.109 Dollar-Sign Character ()
3.110 Dot
3.111 Dot-Dot
3.112 Dot-Po File
3.113 Double-Quote Character
3.114 Downshifting
3.115 Driver
3.116 Effective Group ID
3.117 Effective User ID
3.118 Eight-Bit Transparency
3.119 Empty Directory
3.120 Empty Line
3.121 Empty String (or Null String)
3.122 Empty Wide-Character String
3.123 Encoding Rule
3.124 Entire Regular Expression
3.125 Epoch
3.126 Equivalence Class
3.127 Era
3.128 Event Management
3.129 Executable File
3.130 Execute
3.131 Execution Time
3.132 Execution Time Monitoring
3.133 Expand
3.134 Extended Regular Expression (ERE)
3.135 Extended Security Controls
3.136 Feature Test Macro
3.137 Field
3.138 FIFO Special File (or FIFO)
3.139 File
3.140 File Description
3.141 File Descriptor
3.142 File Group Class
3.143 File Lock
3.144 File Mode
3.145 File Mode Bits
3.146 Filename
3.147 Filename String
3.148 File Offset
3.149 File Other Class
3.150 File Owner Class
3.151 File Permission Bits
3.152 File Serial Number
3.153 File System
3.154 File Type
3.155 Filter
3.156 First Open (of a File)
3.157 Flow Control
3.158 Foreground Job
3.159 Foreground Process
3.160 Foreground Process Group
3.161 Foreground Process Group ID
3.162 Form-Feed Character ()
3.163 Graphic Character
3.164 Group Database
3.165 Group ID
3.166 Group Name
3.167 Hard Limit
3.168 Hard Link
3.169 Hole
3.170 Home Directory
3.171 Host Byte Order
3.172 Incomplete Line
3.173 Inf
3.174 Interactive Device
3.175 Interactive Shell
3.176 Internationalization
3.177 Interprocess Communication
3.178 Intrinsic Utility
3.179 Invoke
3.180 Job
3.181 Job Control
3.182 Job ID
3.183 Joinable Thread
3.184 Last Close (of a File)
3.185 Line
3.186 Linger
3.187 Link
3.188 Link Count
3.189 Live Process
3.190 Live Thread
3.191 Local Customs
3.192 Local Interprocess Communication (Local IPC)
3.193 Locale
3.194 Localization
3.195 Lock-Free Operation
3.196 Login
3.197 Login Name
3.198 Map
3.199 Matched
3.200 Memory Mapped Files
3.201 Memory Object
3.202 Memory-Resident
3.203 Message
3.204 Message Catalog
3.205 Message Catalog Descriptor
3.206 Message Queue
3.207 Messages Object
3.208 Mode
3.209 Monotonic Clock
3.210 Mount Point
3.211 Multi-Character Collating Element
3.212 Multi-Threaded Library
3.213 Multi-Threaded Process
3.214 Multi-Threaded Program
3.215 Mutex
3.216 Name
3.217 NaN (Not a Number)
3.218 Native Language
3.219 Negative
3.220 Negative Response
3.221 Network
3.222 Network Address
3.223 Network Byte Order
3.224 Newline Character ()
3.225 Nice Value
3.226 Non-Blocking
3.227 Non-Spacing Characters
3.228 NUL
3.229 Null Byte
3.230 Null Pointer
3.231 Null String
3.232 Null Terminator
3.233 Null Wide-Character Code
3.234 Number-Sign Character ()
3.235 Object File
3.236 Octet
3.237 OFD-Owned File Lock
3.238 Offset Maximum
3.239 Opaque Address
3.240 Open File
3.241 Open File Description
3.242 Operand
3.243 Operator
3.244 Option
3.245 Option-Argument
3.246 Orientation
3.247 Orphaned Process Group
3.248 Page
3.249 Page Size
3.250 Parameter
3.251 Parent Directory
3.252 Parent Process
3.253 Parent Process ID
3.254 Pathname
3.255 Pathname Component
3.256 Path Prefix
3.257 Pattern
3.258 Period Character ()
3.259 Permissions
3.260 Persistence
3.261 Pipe
3.262 Polling
3.263 Portable Character Set
3.264 Portable Filename
3.265 Portable Filename Character Set
3.266 Portable Messages Object Source File (or Dot-Po File)
3.267 Positional Parameter
3.268 Positive
3.269 Preallocation
3.270 Preempted Process (or Thread)
3.271 Previous Job
3.272 Printable Character
3.273 Printable File
3.274 Priority
3.275 Priority Inversion
3.276 Priority Scheduling
3.277 Priority-Based Scheduling
3.278 Privilege
3.279 Process
3.280 Process Group
3.281 Process Group ID
3.282 Process Group Leader
3.283 Process Group Lifetime
3.284 Process ID
3.285 Process Lifetime
3.286 Process Memory Locking
3.287 Process Termination
3.288 Process Virtual Time
3.289 Process-Owned File Lock
3.290 Process-To-Process Communication
3.291 Program
3.292 Protocol
3.293 Pseudo-Terminal
3.294 Radix Character (or Decimal-Point Character)
3.295 Read-Only File System
3.296 Read-Write Lock
3.297 Real Group ID
3.298 Real Time
3.299 Realtime Signal Extension
3.300 Real User ID
3.301 Record
3.302 Record Lock
3.303 Redirection
3.304 Redirection Operator
3.305 Referenced Shared Memory Object
3.306 Refresh
3.307 Regular Built-In Utility (or Regular Built-In)
3.308 Regular Expression
3.309 Region
3.310 Regular File
3.311 Relative Pathname
3.312 Relocatable File
3.313 Relocation
3.314 (Time) Resolution
3.315 Robust Mutex
3.316 Root Directory
3.317 Runnable Process (or Thread)
3.318 Running Process (or Thread)
3.319 Saved Resource Limits
3.320 Saved Set-Group-ID
3.321 Saved Set-User-ID
3.322 Scheduling
3.323 Scheduling Allocation Domain
3.324 Scheduling Contention Scope
3.325 Scheduling Policy
3.326 Screen
3.327 Scroll
3.328 Semaphore
3.329 Session
3.330 Session Leader
3.331 Session Lifetime
3.332 Shared Memory Object
3.333 Shell
3.334 Shell, the
3.335 Shell Script
3.336 Signal
3.337 Signal Stack
3.338 Single-Quote Character
3.339 Single-Threaded Process
3.340 Single-Threaded Program
3.341 Slash Character ()
3.342 Socket
3.343 Socket Address
3.344 Soft Limit
3.345 Source Code
3.346 Space Character ()
3.347 Sparse File
3.348 Spawn
3.349 Special Built-In Utility (or Special Built-In)
3.350 Special Parameter
3.351 Spin Lock
3.352 Sporadic Server
3.353 Standard Error
3.354 Standard Input
3.355 Standard Output
3.356 Standard Utilities
3.357 Stream
3.358 String
3.359 Subshell
3.360 Successfully Transferred
3.361 Supplementary Group ID
3.362 Suspended Job
3.363 Symbolic Constant
3.364 Symbolic Link
3.365 Synchronization Operation
3.366 Synchronized Input and Output
3.367 Synchronized I/O Completion
3.368 Synchronized I/O Data Integrity Completion
3.369 Synchronized I/O File Integrity Completion
3.370 Synchronized I/O Operation
3.371 Synchronous I/O Operation
3.372 Synchronously-Generated Signal
3.373 System
3.374 System Boot
3.375 System Clock
3.376 System Console
3.377 System Crash
3.378 System Databases
3.379 System Documentation
3.380 System Process
3.381 System Reboot
3.382 System-Wide
3.383 Tab Character ()
3.384 Terminal (or Terminal Device)
3.385 Text Column
3.386 Text Domain
3.387 Text File
3.388 Thread
3.389 Thread ID
3.390 Thread Lifetime
3.391 Thread List
3.392 Thread Termination
3.393 Thread-Safe
3.394 Thread-Specific Data Key
3.395 Tilde Character ()
3.396 Timeouts
3.397 Timer
3.398 Timer Overrun
3.399 Token
3.400 Typed Memory Name Space
3.401 Typed Memory Object
3.402 Typed Memory Pool
3.403 Typed Memory Port
3.404 Unbind
3.405 Unit Data
3.406 Upshifting
3.407 User Database
3.408 User ID
3.409 User Name
3.410 Utility
3.411 Variable
3.412 Vertical-Tab Character ()
3.413 White Space
3.414 White-Space Byte
3.415 White-Space Character
3.416 White-Space Wide Character
3.417 Wide-Character Code (C Language)
3.418 Wide-Character Input/Output Functions
3.419 Wide-Character String
3.420 Word
3.421 Working Directory (or Current Working Directory)
3.422 Worldwide Portability Interface
3.423 Write
3.424 XSI
3.425 XSI-Conformant
3.426 Zombie Process
3.427 Zombie Thread
3.428 ±0
4. General Concepts
4.1 Case Insensitive Comparisons
4.2 Concurrent Execution
4.3 Default Initialization
4.4 Directory Operations
4.5 Directory Protection
4.6 Extended Security Controls
4.7 File Access Permissions
4.8 File Hierarchy
4.9 Filenames
4.10 Filename Portability
4.11 File System Cache
4.12 File Times Update
4.13 Host and Network Byte Orders
4.14 Measurement of Execution Time
4.15 Memory Ordering and Synchronization
4.15.1 Memory Ordering
4.15.1.1 Data Races
4.15.1.2 Memory Order and Consistency
4.15.2 Memory Synchronization
4.16 Pathname Resolution
4.17 Process ID Reuse
4.18 Scheduling Policy
4.19 Seconds Since the Epoch
4.20 Semaphore
Semaphore Lock Operation
Semaphore Unlock Operation
4.21 Special Device Drivers
4.22 Thread-Safety
4.23 Treatment of Error Conditions for Mathematical Functions
4.23.1 Domain Error
4.23.2 Pole Error
4.23.3 Range Error
4.23.3.1 Result Overflows
4.23.3.2 Result Underflows
4.24 Treatment of NaN Arguments for the Mathematical Functions
4.25 Utility
4.26 Variable Assignment
Footnotes
5. File Format Notation
Examples
6. Character Set
6.1 Portable Character Set
6.2 Character Encoding
6.3 C Language Wide-Character Codes
6.4 Character Set Description File
Example
6.4.1 State-Dependent Character Encodings
7. Locale
7.1 General
7.2 POSIX Locale
7.3 Locale Definition
7.3.1 LC_CTYPE
7.3.1.1 LC_CTYPE Category in the POSIX Locale
7.3.2 LC_COLLATE
7.3.2.1 The collating-element Keyword
7.3.2.2 The collating-symbol Keyword
7.3.2.3 The order_start Keyword
7.3.2.4 Collation Order
7.3.2.5 The order_end Keyword
7.3.2.6 LC_COLLATE Category in the POSIX Locale
7.3.3 LC_MONETARY
7.3.3.1 LC_MONETARY Category in the POSIX Locale
7.3.4 LC_NUMERIC
7.3.4.1 LC_NUMERIC Category in the POSIX Locale
7.3.5 LC_TIME
7.3.5.1 LC_TIME Locale Definition
7.3.5.2 LC_TIME C-Language Access
7.3.5.3 LC_TIME Category in the POSIX Locale
7.3.6 LC_MESSAGES
7.3.6.1 LC_MESSAGES Category in the POSIX Locale
7.4 Locale Definition Grammar
7.4.1 Locale Lexical Conventions
7.4.2 Locale Grammar
8. Environment Variables
8.1 Environment Variable Definition
8.2 Internationalization Variables
8.3 Other Environment Variables
9. Regular Expressions
9.1 Regular Expression Definitions
entire regular expression
escape sequence
leftmost
matched
BRE (ERE) matching a single character
BRE (ERE) matching multiple characters
invalid
9.2 Regular Expression General Requirements
9.3 Basic Regular Expressions
9.3.1 BREs Matching a Single Character or Collating Element
9.3.2 BRE Ordinary Characters
9.3.3 BRE Special Characters
9.3.4 Periods in BREs
9.3.5 RE Bracket Expression
9.3.6 BREs Matching Multiple Characters
9.3.7 BRE Precedence
9.3.8 BRE Expression Anchoring
9.4 Extended Regular Expressions
9.4.1 EREs Matching a Single Character or Collating Element
9.4.2 ERE Ordinary Characters
9.4.3 ERE Special Characters
9.4.4 Periods in EREs
9.4.5 ERE Bracket Expression
9.4.6 EREs Matching Multiple Characters
9.4.7 ERE Alternation
9.4.8 ERE Precedence
9.4.9 ERE Expression Anchoring
9.5 Regular Expression Grammar
9.5.1 BRE/ERE Grammar Lexical Conventions
9.5.2 RE and Bracket Expression Grammar
9.5.3 ERE Grammar
10. Directory Structure and Devices
10.1 Directory Structure and Files
10.2 Output Devices and Terminal Types
11. General Terminal Interface
11.1 Interface Characteristics
11.1.1 Opening a Terminal Device File
11.1.2 Process Groups
11.1.3 The Controlling Terminal
11.1.4 Terminal Access Control
11.1.5 Input Processing and Reading Data
11.1.6 Canonical Mode Input Processing
11.1.7 Non-Canonical Mode Input Processing
Case A: MIN>0, TIME>0
Case B: MIN>0, TIME=0
Case C: MIN=0, TIME>0
Case D: MIN=0, TIME=0
11.1.8 Writing Data and Output Processing
11.1.9 Special Characters
11.1.10 Modem Disconnect
11.1.11 Closing a Terminal Device File
11.2 Parameters that Can be Set
11.2.1 The termios Structure
11.2.2 Input Modes
11.2.3 Output Modes
11.2.4 Control Modes
11.2.5 Local Modes
11.2.6 Special Control Characters
12. Utility Conventions
12.1 Utility Argument Syntax
12.2 Utility Syntax Guidelines
13. Namespace and Future Directions
14. Headers
Format of Entries
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index |
XBD |
XSH |
XCU |
XRAT ]
===== susv5-html/basedefs/stdalign.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
stdalign.h — alignment macros
SYNOPSIS
#include
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The  header shall define the following macros:
alignas
Expands to _Alignas
alignof
Expands to _Alignof
__alignas_is_defined
Expands to the integer constant 1
__alignof_is_defined
Expands to the integer constant 1
The __alignas_is_defined and __alignof_is_defined macros shall be suitable for use in #if preprocessing directives.
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
None.
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/locale.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
locale.h — category macros
SYNOPSIS
#include
DESCRIPTION
[CX]  Some of the functionality described on this reference page extends the ISO C standard. Applications shall define
the appropriate feature test macro (see XSH 2.2 The Compilation
Environment) to enable the visibility of these symbols in this header.
The  header shall define the lconv structure, which shall include at least the following members.
(See the definitions of LC_MONETARY in 7.3.3 LC_MONETARY and
7.3.4 LC_NUMERIC.)
char    *currency_symbol
char    *decimal_point
char     frac_digits
char    *grouping
char    *int_curr_symbol
char     int_frac_digits
char     int_n_cs_precedes
char     int_n_sep_by_space
char     int_n_sign_posn
char     int_p_cs_precedes
char     int_p_sep_by_space
char     int_p_sign_posn
char    *mon_decimal_point
char    *mon_grouping
char    *mon_thousands_sep
char    *negative_sign
char     n_cs_precedes
char     n_sep_by_space
char     n_sign_posn
char    *positive_sign
char     p_cs_precedes
char     p_sep_by_space
char     p_sign_posn
char    *thousands_sep
The  header shall define NULL (as described in ) and at least the following as macros:
LC_ALL
LC_COLLATE
LC_CTYPE
[CX]
LC_MESSAGES
LC_MONETARY
LC_NUMERIC
LC_TIME
which shall expand to integer constant expressions with distinct values for use as the first argument to the setlocale() function.
Additional macro definitions, beginning with the characters LC_ and an uppercase letter, may also be specified by the
implementation.
[CX]  The
header shall contain at least the following macros representing bitmasks for use with the newlocale() function for each supported locale category: LC_COLLATE_MASK LC_CTYPE_MASK
LC_MESSAGES_MASK LC_MONETARY_MASK LC_NUMERIC_MASK LC_TIME_MASK
In addition, a macro to set the bits for all categories set shall be defined: LC_ALL_MASK
The  header shall define LC_GLOBAL_LOCALE, a special locale object descriptor used by the duplocale() and uselocale()
functions.
The  header shall define the locale_t type, representing a locale object.
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided for use
with ISO C standard compilers.
[CX]
locale_t      duplocale(locale_t);
void          freelocale(locale_t);
const char   *getlocalename_l(int, locale_t);
struct lconv *localeconv(void);
[CX]
locale_t      newlocale(int, const char *, locale_t);
char         *setlocale(int, const char *);
[CX]
locale_t      uselocale (locale_t);
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
It is suggested that each category macro name for use in setlocale() have a
corresponding macro name ending in _MASK for use in newlocale().
FUTURE DIRECTIONS
None.
SEE ALSO
8. Environment Variables,
XSH duplocale(), freelocale(), getlocalename_l()
, localeconv(), newlocale(),
setlocale(), uselocale()
CHANGE HISTORY
First released in Issue 3.
Included for alignment with the ISO C standard.
Issue 6
The lconv structure is expanded with new members (int_n_cs_precedes, int_n_sep_by_space,
int_n_sign_posn, int_p_cs_precedes, int_p_sep_by_space, and int_p_sign_posn) for alignment with the
ISO/IEC 9899:1999 standard.
Extensions beyond the ISO C standard are marked.
Issue 7
The duplocale(), freelocale(), newlocale(), and uselocale() functions are added from The Open Group Technical Standard, 2006, Extended API
Set Part 4.
This reference page is clarified with respect to macros and symbolic constants.
POSIX.1-2008, Technical Corrigendum 1, XBD/TC1-2008/0060 [301,427] is applied.
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0062 [781] is applied.
Issue 8
Austin Group Defect 1220 is applied, adding getlocalename_l().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/sys_shm.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sys/shm.h — XSI shared memory facility
SYNOPSIS
[XSI]  #include
DESCRIPTION
The  header shall define the following symbolic constants:
SHM_RDONLY
Attach read-only (else read-write).
SHM_RND
Round attach address to SHMLBA.
SHMLBA
Segment low boundary address multiple.
The  header shall define the symbolic constant SHM_FAILED which shall evaluate to the same value as
((void *)(intptr_t)-1).
The  header shall define the type intptr_t as described in .
The  header shall define the following data type through typedef:
shmatt_t
Unsigned integer used for the number of current attaches that shall be able to store values at least as large as a type
unsigned short.
The  header shall define the shmid_ds structure, which shall include the following members:
struct ipc_perm shm_perm   Operation permission structure.
size_t          shm_segsz  Size of segment in bytes.
pid_t           shm_lpid   Process ID of last shared memory operation.
pid_t           shm_cpid   Process ID of creator.
shmatt_t        shm_nattch Number of current attaches.
time_t          shm_atime  Time of last shmat().
time_t          shm_dtime  Time of last shmdt().
time_t          shm_ctime  Time of last change by shmctl().
The  header shall define the pid_t, size_t, and time_t types as described in
.
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
void *shmat(int, const void *, int);
int   shmctl(int, int, struct shmid_ds *);
int   shmdt(const void *);
int   shmget(key_t, size_t, int);
In addition, the  header shall include the  header.
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
,
XSH shmat(), shmctl(), shmdt(), shmget()
CHANGE HISTORY
First released in Issue 2. Derived from System V Release 2.0.
Issue 5
The type of shm_segsz is changed from int to size_t.
Issue 7
Austin Group Interpretation 1003.1-2001 #179 is applied.
This reference page is clarified with respect to macros and symbolic constants.
Issue 8
Austin Group Defect 1239 is applied, adding SHM_FAILED and requiring  to define intptr_t.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/sys_ipc.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sys/ipc.h — XSI interprocess communication access structure
SYNOPSIS
[XSI]  #include
DESCRIPTION
The  header is used by three mechanisms for XSI interprocess communication (IPC): messages, semaphores,
and shared memory. All use a common structure type, ipc_perm, to pass information used in determining permission to perform
an IPC operation.
The  header shall define the ipc_perm structure, which shall include the following members:
uid_t    uid    Owner's user ID.
gid_t    gid    Owner's group ID.
uid_t    cuid   Creator's user ID.
gid_t    cgid   Creator's group ID.
mode_t   mode   Read/write permission.
The  header shall define the uid_t, gid_t, mode_t, and key_t types as
described in .
The  header shall define the following symbolic constants.
Mode bits:
IPC_CREAT
Create entry if key does not exist.
IPC_EXCL
Fail if key exists.
IPC_NOWAIT
Error if request would need to wait.
Keys:
IPC_PRIVATE
Private key.
Control commands:
IPC_RMID
Remove identifier.
IPC_SET
Set options.
IPC_STAT
Get options.
The following shall be declared as a function and may also be defined as a macro. A function prototype shall be provided.
key_t  ftok(const char *, int);
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XSH ftok()
CHANGE HISTORY
First released in Issue 2. Derived from System V Release 2.0.
Issue 7
This reference page is clarified with respect to macros and symbolic constants.
Issue 8
The description of IPC_NOWAIT is updated to eliminate the use of "must".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/V1_chap13.html =====
Namespace and Future Directions
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
13. Namespace and Future Directions
In order to prevent future versions of this standard from introducing features that could cause older applications to fail, the
prefixes posix_, POSIX_, and _POSIX_ are reserved for use by this standard for any name (e.g. function, variable, utility, etc.).
Neither implementations nor applications shall introduce objects in this namespace.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/stddef.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
stddef.h — standard type definitions
SYNOPSIS
#include
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The  header shall define the following macros:
NULL
Null pointer constant. [CX]   The macro shall expand to an integer constant expression with the value 0 cast to type void
*. Additionally, any pointer object whose representation has all bits set to zero, perhaps by memset() to 0 or by calloc(), shall be treated
as a null pointer.
offsetof(type, member-designator)
Integer constant expression of type size_t, the value of which is the offset in bytes to the structure member
(member-designator), from the beginning of its structure (type).
The  header shall define the following types:
max_align_t
Object type whose alignment is the greatest fundamental alignment.
ptrdiff_t
Signed integer type of the result of subtracting two pointers.
wchar_t
Integer type whose range of values can represent distinct codes for all members of the largest extended character set specified
among the supported locales; the null character shall have the code value zero. Each member of the basic character set shall have a
code value equal to its value when used as the lone character in an integer character constant if an implementation does not define
__STDC_MB_MIGHT_NEQ_WC__.
size_t
Unsigned integer type of the result of the sizeof operator.
The implementation shall support one or more programming environments in which the widths of ptrdiff_t, size_t,
and wchar_t are no greater than the width of type long. The names of these programming environments can be obtained
using the confstr() function or the getconf utility.
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
The ISO C standard does not require the NULL macro to include the cast to type void * and specifies that the NULL
macro be implementation-defined. POSIX.1-2024 requires the cast and therefore need not be implementation-defined.
Likewise, the ISO C standard does not require a pointer object whose representation has all bits set to zero to be treated
as a null pointer. While there has been historical hardware where non-zero patterns were more efficient for use as the canonical
null pointer, no known POSIX system has tried to target such hardware. However, though unlikely in modern hardware, a compiler is
still allowed to treat more than one bit pattern as a representation of the null pointer (all such patterns will compare equal to
one another, and unequal to any pointer to any other object). Thus, applications should not assume that a pointer object with
non-zero representation is not a null pointer.
FUTURE DIRECTIONS
None.
SEE ALSO
,
XSH confstr()
XCU getconf
CHANGE HISTORY
First released in Issue 4. Derived from the ANSI C standard.
Issue 7
This reference page is clarified with respect to macros and symbolic constants.
SD5-XBD-ERN-53 is applied, updating the definition of wchar_t to align with ISO/IEC 9899:1999 standard, Technical
Corrigendum 3.
Issue 8
Austin Group Defect 940 is applied, adding a requirement that any pointer object whose representation has all bits set to zero
is interpreted as a null pointer.
Austin Group Defect 1302 is applied, adding max_align_t.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/libintl.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
libintl.h — international messaging
SYNOPSIS
#include
DESCRIPTION
The  header may define the macro TEXTDOMAINMAX. If defined, it shall have the same value as
{TEXTDOMAIN_MAX} in .
The  header shall define the locale_t type as described in .
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
char   *bindtextdomain(const char *, const char *);
char   *bind_textdomain_codeset(const char *, const char *);
char   *dcgettext(const char *, const char *, int);
char   *dcgettext_l(const char *, const char *, int, locale_t);
char   *dcngettext(const char *, const char *, const char *,
unsigned long int, int);
char   *dcngettext_l(const char *, const char *, const char *,
unsigned long int, int, locale_t);
char   *dgettext(const char *, const char *);
char   *dgettext_l(const char *, const char *, locale_t);
char   *dngettext(const char *, const char *, const char *,
unsigned long int);
char   *dngettext_l(const char *, const char *, const char *,
unsigned long int, locale_t);
char   *gettext(const char *);
char   *gettext_l(const char *, locale_t);
char   *ngettext(const char *, const char *, unsigned long int);
char   *ngettext_l(const char *, const char *,
unsigned long int, locale_t);
char   *textdomain(const char *);
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
Some historical implementations defined TEXTDOMAINMAX in this header. This standard instead defines {TEXTDOMAIN_MAX} in . This was done to allow the maximum length of a text domain name to vary
depending on the filesystem type used to store message catalogs. Implementations are allowed to continue to define TEXTDOMAINMAX in
this header as an extension to the standard (see XSH 2.2.2 The Name
Space).
FUTURE DIRECTIONS
None.
SEE ALSO
XSH gettext(), bindtextdomain()
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/V1_chap05.html =====
File Format Notation
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
5. File Format Notation
The STDIN, STDOUT, STDERR, INPUT FILES, and OUTPUT FILES sections of the utility descriptions use a syntax to describe the data
organization within the files, when that organization is not otherwise obvious. The syntax is similar to that used by the System
Interfaces volume of POSIX.1-2024 printf() function, as described in this chapter.
When used in STDIN or INPUT FILES sections of the utility descriptions, this syntax describes the format that could have been used
to write the text to be read, not a format that could be used by the System Interfaces volume of POSIX.1-2024 scanf() function to read the input file.
The description of an individual record is as follows:
"", [, ,..., ]
The format is a character string that contains three types of objects defined below:
Characters that are not "escape sequences" or "conversion specifications", as described below, shall be copied to the
output.
Escape Sequences represent non-graphic characters and the escape character ().
Conversion Specifications specify the output format of each argument; see below.
The following characters have the following special meaning in the format string:
''
(An empty character position.) Represents one or more  characters from the portable character set.
Δ
Represents exactly one  character.
Escape Sequences and Associated Actions lists escape sequences and associated actions on display
devices capable of the action.
Table: Escape Sequences and Associated Actions
Escape Sequence
Represents Character
Terminal Action
\\
Print the  character.
\a
Attempt to alert the user through audible or visible notification.
\b
Move the printing position to one column before the current position, unless the current position is the start of a
line.
\f
Move the printing position to the initial printing position of the next logical page.
\n
Move the printing position to the start of the next line.
\r
Move the printing position to the start of the current line.
\t
Move the printing position to the next tab position on the current line. If there are no more tab positions
remaining on the line, the behavior is undefined.
\v
Move the printing position to the start of the next  position. If there are no more
positions left on the page, the behavior is undefined.
Each conversion specification is introduced by the  character ('%'). After the
character '%', the following shall appear in sequence:
flags
Zero or more flags, in any order, that modify the meaning of the conversion specification.
field width
An optional string of decimal digits to specify a minimum field width. For an output field, if the converted value has fewer
bytes than the field width, it shall be padded on the left (or right, if the left-adjustment flag ('-'), described below,
has been given) to the field width.
precision
Gives the minimum number of digits to appear for the d, o, i, u, x, or X
conversion specifiers (the field is padded with leading zeros), the number of digits to appear after the radix character for the
e and f conversion specifiers, the maximum number of significant digits for the g conversion specifier;
or the maximum number of bytes to be written from a string in the s conversion specifier. The precision shall take the
form of a  ('.') followed by a decimal digit string; a null digit string is treated as zero.
conversion specifier characters
A conversion specifier character (see below) that indicates the type of conversion to be applied.
The flag characters and their meanings are:
-
The result of the conversion shall be left-justified within the field.
+
The result of a signed conversion shall always begin with a sign ('+' or '-').
If the first character of a signed conversion is not a sign, a  shall be prefixed to the result. This means that
if the  and '+' flags both appear, the  flag shall be ignored.
#
The value shall be converted to an alternative form. For c, d, i, u, and s
conversion specifiers, the behavior is undefined. For the o conversion specifier, it shall increase the precision to force
the first digit of the result to be a zero. For x or X conversion specifiers, a non-zero result has 0x or 0X
prefixed to it, respectively. For a, A, e, E, f, F, g, and
G conversion specifiers, the result shall always contain a radix character, even if no digits follow the radix character.
For g and G conversion specifiers, trailing zeros shall not be removed from the result as they usually are.
0
For a, A, d, e, E, f, F, g, G, i,
o, u, x, and X conversion specifiers, leading zeros (following any indication of sign or base)
shall be used to pad to the field width rather than performing space padding, except when converting an infinity or NaN. If the
'0' and '-' flags both appear, the '0' flag shall be ignored. For d, i, o,
u, x, and X conversion specifiers, if a precision is specified, the '0' flag shall be ignored.
For other conversion specifiers, the behavior is undefined.
Each conversion specifier character shall result in fetching zero or more arguments. The results are undefined if
there are insufficient arguments for the format. If the format is exhausted while arguments remain, the excess arguments shall be
ignored.
The conversion specifiers and their meanings are:
a,A
The floating-point number argument representing a floating-point number shall be converted in the style
"[-]0xh.hhhhp±d", where there is one hexadecimal digit (which shall be
non-zero if the argument is a normalized floating-point number and is otherwise unspecified) before the decimal-point character and
the number of hexadecimal digits after it is equal to the precision; if the precision is missing and FLT_RADIX is a power of 2,
then the precision shall be sufficient for an exact representation of the value; if the precision is missing and FLT_RADIX is not a
power of 2, then the precision shall be sufficient to distinguish different floating-point values in the internal representation
used by the utility, except that trailing zeros may be omitted; if the precision is zero and the # flag is not specified,
no decimal-point character shall appear. The letters "abcdef" shall be used for a conversion and the letters
"ABCDEF" for A conversion. The A conversion specifier produces a number with X and P
instead of x and p. The exponent shall always contain at least one digit, and only as many more digits as
necessary to represent the decimal exponent of 2. If the value is zero, the exponent shall be zero. A floating-point number
argument representing an infinity or NaN shall be converted in the style of an f or F conversion specifier.
d,i,o,u,x,X
The integer argument shall be written as signed decimal (d or i), unsigned octal (o), unsigned
decimal (u), or unsigned hexadecimal notation (x and X). The d and i specifiers shall
convert to signed decimal in the style "[-]dddd". The x conversion specifier shall use the
numbers and letters "0123456789abcdef" and the X conversion specifier shall use the numbers and letters
"0123456789ABCDEF". The precision component of the argument shall specify the minimum number of digits to appear.
If the value being converted can be represented in fewer digits than the specified minimum, it shall be expanded with leading
zeros. The default precision shall be 1. The result of converting a zero value with a precision of 0 shall be no characters. If
both the field width and precision are omitted, the implementation may precede, follow, or precede and follow numeric arguments of
types d, i, and u with  characters from the portable character set; arguments of type
o (octal) may be preceded with leading zeros.
f,F
The floating-point number argument shall be written in decimal notation in the style [-]ddd.ddd, where the
number of digits after the radix character (shown here as a decimal point) shall be equal to the precision specification.
The LC_NUMERIC locale category shall determine the radix character to use in this format. If the precision is omitted
from the argument, six digits shall be written after the radix character; if the precision is explicitly 0, no radix
character shall appear.
A floating-point number argument representing an infinity shall be converted in one of the styles "[-]inf"
or "[-]infinity"; which style is implementation-defined. A floating-point number argument representing a NaN shall be
converted in one of the styles "[-]nan(n-char-sequence)" or "[-]nan"; which style, and the
meaning of any n-char-sequence, is implementation-defined. The F conversion specifier produces "INF",
"INFINITY", or "NAN" instead of "inf", "infinity", or "nan", respectively.
e,E
The floating-point number argument shall be written in the style [-]d.ddde±dd (the symbol
'±' indicates either a  or ), where there is one digit before the radix character
(shown here as a decimal point) and the number of digits after it is equal to the precision. The LC_NUMERIC locale category
shall determine the radix character to use in this format. When the precision is missing, six digits shall be written after the
radix character; if the precision is 0, no radix character shall appear. The E conversion specifier shall produce a number
with E instead of e introducing the exponent. The exponent shall always contain at least two digits. However, if
the value to be written requires an exponent greater than two digits, additional exponent digits shall be written as necessary.
A floating-point number argument representing an infinity or NaN shall be converted in the style of an f
or F conversion specifier.
g,G
The floating-point number argument shall be written in style f or e (or in style F or E in
the case of a G conversion specifier), with the precision specifying the number of significant digits. The style used
depends on the value converted: style e (or E) shall be used only if the exponent resulting from the conversion
is less than -4 or greater than or equal to the precision. Trailing zeros are removed from the result. A radix character shall
appear only if it is followed by a digit.
A floating-point number argument representing an infinity or NaN shall be converted in the style of an f
or F conversion specifier.
c
The single-byte character argument shall be written.
s
The argument shall be taken to be a string and bytes from the string shall be written until the end of the string or the number
of bytes indicated by the precision specification of the argument is reached. If the precision is omitted from the argument,
it shall be taken to be infinite, so all bytes up to the end of the string shall be written.
%
Write a '%' character; no argument shall be converted. Applications using the printf utility shall ensure that the complete conversion specification is %%.
In no case does a nonexistent or insufficient field width cause truncation of a field; if the result of a
conversion is wider than the field width, the field is simply expanded to contain the conversion result. The term "field width"
should not be confused with the term "precision" used in the description of %s.
The following sections are informative.
Examples
To represent the output of a program that prints a date and time in the form Sunday, July 3, 10:02, where
weekday and month are strings:
"%s,Δ%sΔ%d,Δ%d:%.2d\n" , , , ,
To show 'ℼ' written to 5 decimal places:
"piΔ=Δ%.5f\n",
To show an input file format consisting of five -separated fields:
"%s:%s:%s:%s:%s\n", , , , ,
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/iso646.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
iso646.h — alternative spellings
SYNOPSIS
#include
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The  header shall define the following eleven macros (on the left) that expand to the corresponding
tokens (on the right):
and
&&
and_eq
&=
bitand
&
bitor
|
compl
~
not
!
not_eq
!=
or
||
or_eq
|=
xor
^
xor_eq
^=
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
None.
CHANGE HISTORY
First released in Issue 5. Derived from ISO/IEC 9899:1990/Amendment 1:1995 (E).
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/libgen.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
libgen.h — definitions for pattern matching functions
SYNOPSIS
[XSI]  #include
DESCRIPTION
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
char  *basename(char *);
char  *dirname(char *);
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XSH basename(), dirname()
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
The function prototypes for basename() and dirname() are changed to indicate that the first argument is of type char * rather
than const char *.
Issue 6
The __loc1 symbol and the regcmp() and regex() functions are removed.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/sys_socket.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sys/socket.h — main sockets header
SYNOPSIS
#include
DESCRIPTION
The  header shall define the socklen_t type, which is an integer type of width of at least 32
bits; see APPLICATION USAGE.
The  header shall define the sa_family_t unsigned integer type.
The  header shall define the sockaddr structure, which shall include at least the following
members:
sa_family_t  sa_family  Address family.
char         sa_data[]  Socket address (variable-length data).
The sockaddr structure is used to define a socket address which is used in the bind(), connect(), getpeername(), getsockname(),
recvfrom(), and sendto()
functions.
The  header shall define the sockaddr_storage structure, which shall be:
Large enough to accommodate all supported protocol-specific address structures
Aligned at an appropriate boundary so that pointers to it can be cast as pointers to protocol-specific address structures and
used to access the fields of those structures without alignment problems
The sockaddr_storage structure shall include at least the following members:
sa_family_t   ss_family
When a pointer to a sockaddr_storage structure is converted to a pointer to a sockaddr structure, or vice versa,
the ss_family member of the sockaddr_storage structure shall map onto the sa_family member of the
sockaddr structure. When a pointer to a sockaddr_storage structure is converted to a pointer to a protocol-specific
address structure, or vice versa, the ss_family member shall map onto a member of that structure that is of type
sa_family_t that identifies the protocol's address family. When a pointer to a sockaddr structure is converted to a
pointer to a protocol-specific address structure, or vice versa, the sa_family member shall map onto a member of that
structure that is of type sa_family_t that identifies the protocol's address family. Additionally, the structures shall be
defined in such a way that the compiler treats an access to the stored value of the sa_family_t member of any of these
structures, via an lvalue expression whose type involves any other one of these structures, as permissible, despite the more
restrictive expression rules on stored value access as stated in the ISO C standard. Similarly, when a pointer to a
sockaddr_storage or sockaddr structure is converted to a pointer to a protocol-specific address structure, the
compiler shall treat an access (using this converted pointer) to the stored value of any member of the protocol-specific structure
as permissible. The application shall ensure that the protocol-specific address structure corresponds to the family indicated by
the member with type sa_family_t of that structure and the pointed-to object has sufficient memory for addressing all
members of the protocol-specific structure.
The  header shall define the msghdr structure, which shall include at least the following
members:
void          *msg_name        Optional address.
socklen_t      msg_namelen     Size of address.
struct iovec  *msg_iov         Scatter/gather array.
int            msg_iovlen      Members in msg_iov.
void          *msg_control     Ancillary data; see below.
socklen_t      msg_controllen  Ancillary data buffer len.
int            msg_flags       Flags on received message.
The msghdr structure is used to reduce the number of directly supplied parameters to the recvmsg() and sendmsg() functions. This
structure is used as a value-result parameter in the recvmsg()
function and value only for the sendmsg() function.
The  header shall define the iovec structure as described in .
The  header shall define the cmsghdr structure, which shall include at least the following
members:
socklen_t  cmsg_len    Data byte count, including the cmsghdr.
int        cmsg_level  Originating protocol.
int        cmsg_type   Protocol-specific type.
The cmsghdr structure is used for storage of ancillary data object information.
Ancillary data consists of a sequence of pairs, each consisting of a cmsghdr structure followed by a data array. The data
array contains the ancillary data message, and the cmsghdr structure contains descriptive information that allows an
application to correctly parse the data.
The values for cmsg_level shall be legal values for the level argument to the getsockopt() and setsockopt()
functions. The system documentation shall specify the cmsg_type definitions for the supported protocols.
Ancillary data is also possible at the socket level. The  header shall define the following symbolic
constant for use as the cmsg_type value when cmsg_level is SOL_SOCKET:
SCM_RIGHTS
Indicates that the data array contains the access rights to be sent or received.
The  header shall define the following macros to gain access to the data arrays in the ancillary data
associated with a message header:
CMSG_DATA(cmsg)
If the argument is a pointer to a cmsghdr structure, this macro shall return an unsigned character pointer to the data array
associated with the cmsghdr structure.
CMSG_NXTHDR(mhdr,cmsg)
If the first argument is a pointer to a msghdr structure and the second argument is a pointer to a cmsghdr structure
in the ancillary data pointed to by the msg_control field of that msghdr structure, this macro shall return a pointer
to the next cmsghdr structure, or a null pointer if the second argument points to the last cmsghdr and data array
pair in the ancillary data. If the ancillary data contains another cmsghdr structure after this one but the cmsg_len
value in that structure is such that the data array following that structure would extend beyond the end of the ancillary data, it
is unspecified whether this macro returns a pointer to that cmsghdr structure or returns a null pointer.
If the first argument is a pointer to a msghdr structure and the second argument is a null pointer, this macro shall be
equivalent to CMSG_FIRSTHDR(mhdr).
CMSG_FIRSTHDR(mhdr)
If the argument is a pointer to a msghdr structure, this macro shall return a pointer to the first cmsghdr structure
in the ancillary data associated with this msghdr structure, or a null pointer if either there is no ancillary data
associated with the msghdr structure (msg_controllen is zero) or there is insufficient room in the ancillary data for
a complete cmsghdr structure (msg_controllen is non-zero but less than sizeof(struct cmsghdr)).
CMSG_SPACE(length)
If the argument has a type such that its value can be assigned to an object of type socklen_t, this macro shall return the
space required by an ancillary data object of the specified length and its cmsghdr structure, including any padding needed
to satisfy alignment requirements. This macro can be used, for example, to allocate space dynamically for the ancillary data. This
macro should not be used to initialize the cmsg_len member of a cmsghdr structure. If the argument is an integer
constant expression, this macro shall expand to an integer constant expression.
CMSG_LEN(length)
If the argument has a type such that its value can be assigned to an object of type socklen_t, this macro shall return the
value to store in the cmsg_len member of the cmsghdr structure for an ancillary data object of the specified length,
taking into account any padding needed to satisfy alignment requirements. If the argument is an integer constant expression, this
macro shall expand to an integer constant expression.
The  header shall define the linger structure, which shall include at least the following
members:
int  l_onoff   Indicates whether linger option is enabled.
int  l_linger  Linger time, in seconds.
The  header shall define the following socket types (see XSH 2.10.6 Socket Types) as symbolic constants with distinct values:
SOCK_DGRAM
Datagram socket.
SOCK_RAW
[RS]
Raw Protocol Interface.
SOCK_SEQPACKET
Sequenced-packet socket.
SOCK_STREAM
Byte-stream socket.
Implementations may provide additional socket types.
The header shall define the following socket creation flags, for use in socket(),
socketpair(), and accept4(). These
flags shall be symbolic constants with values that are bitwise distinct from each other and from all SOCK_* constants representing
socket types:
SOCK_NONBLOCK
Create a socket file descriptor with the O_NONBLOCK flag atomically set on the new open file description.
SOCK_CLOEXEC
Create a socket file descriptor with the FD_CLOEXEC flag atomically set on that file descriptor.
SOCK_CLOFORK
Create a socket file descriptor with the FD_CLOFORK flag atomically set on that file descriptor.
Implementations may provide additional socket creation flags.
The  header shall define the following symbolic constant for use as the level argument of
setsockopt() and getsockopt().
SOL_SOCKET
Options to be accessed at socket level, not protocol level.
The  header shall define the following symbolic constants with distinct values for use as the
option_name argument in getsockopt() or setsockopt() calls (see XSH 2.10.16
Use of Options):
SO_ACCEPTCONN
Socket is accepting connections.
SO_BROADCAST
Transmission of broadcast messages is supported.
SO_DEBUG
Debugging information is being recorded.
SO_DOMAIN
Socket domain.
SO_DONTROUTE
Bypass normal routing.
SO_ERROR
Socket error status.
SO_KEEPALIVE
Connections are kept alive with periodic messages.
SO_LINGER
Socket lingers on close.
SO_OOBINLINE
Out-of-band data is transmitted in line.
SO_PROTOCOL
Socket protocol.
SO_RCVBUF
Receive buffer size.
SO_RCVLOWAT
Receive "low water mark".
SO_RCVTIMEO
Receive timeout.
SO_REUSEADDR
Reuse of local addresses is supported.
SO_SNDBUF
Send buffer size.
SO_SNDLOWAT
Send "low water mark".
SO_SNDTIMEO
Send timeout.
SO_TYPE
Socket type.
The  header shall define the following symbolic constant for use as the maximum backlog queue
length which may be specified by the backlog field of the listen()
function:
SOMAXCONN
The maximum backlog queue length.
The  header shall define the following symbolic constants with distinct values for use as the valid
values for the msg_flags field in the msghdr structure, or the flags parameter in recv(), recvfrom(), recvmsg(), send(), sendmsg(), or sendto() calls:
MSG_CMSG_CLOEXEC
Atomically set the FD_CLOEXEC flag on any file descriptors created via SCM_RIGHTS during recvmsg().
MSG_CMSG_CLOFORK
Atomically set the FD_CLOFORK flag on any file descriptors created via SCM_RIGHTS during recvmsg().
MSG_CTRUNC
Control data truncated.
MSG_DONTROUTE
Send without using routing tables.
MSG_EOR
Terminates a record (if supported by the protocol).
MSG_OOB
Out-of-band data.
MSG_NOSIGNAL
No SIGPIPE generated when an attempt to send is made on a stream-oriented socket that is no longer connected.
MSG_PEEK
Leave received data in queue.
MSG_TRUNC
Normal data truncated.
MSG_WAITALL
Attempt to fill the read buffer.
The  header shall define the following symbolic constants with distinct values:
AF_INET
Internet domain sockets for use with IPv4 addresses.
AF_INET6
[IP6]
Internet domain sockets for use with IPv6 addresses.
AF_UNIX
UNIX domain sockets.
AF_UNSPEC
Unspecified.
The value of AF_UNSPEC shall be 0.
The  header shall define the following symbolic constants with distinct values:
SHUT_RD
Disables further receive operations.
SHUT_RDWR
Disables further send and receive operations.
SHUT_WR
Disables further send operations.
The  header shall define the size_t and ssize_t types as described in .
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
int     accept(int, struct sockaddr *restrict, socklen_t *restrict);
int     accept4(int, struct sockaddr *restrict, socklen_t *restrict,
int);
int     bind(int, const struct sockaddr *, socklen_t);
int     connect(int, const struct sockaddr *, socklen_t);
int     getpeername(int, struct sockaddr *restrict, socklen_t *restrict);
int     getsockname(int, struct sockaddr *restrict, socklen_t *restrict);
int     getsockopt(int, int, int, void *restrict, socklen_t *restrict);
int     listen(int, int);
ssize_t recv(int, void *, size_t, int);
ssize_t recvfrom(int, void *restrict, size_t, int,
struct sockaddr *restrict, socklen_t *restrict);
ssize_t recvmsg(int, struct msghdr *, int);
ssize_t send(int, const void *, size_t, int);
ssize_t sendmsg(int, const struct msghdr *, int);
ssize_t sendto(int, const void *, size_t, int, const struct sockaddr *,
socklen_t);
int     setsockopt(int, int, int, const void *, socklen_t);
int     shutdown(int, int);
int     sockatmark(int);
int     socket(int, int, int);
int     socketpair(int, int, int, int [2]);
Inclusion of  may also make visible all symbols from .
The following sections are informative.
APPLICATION USAGE
To forestall portability problems, it is recommended that applications not use values larger than 231
-1 for the socklen_t type.
The sockaddr_storage structure solves the problem of declaring storage for automatic variables which is both large enough
and aligned enough for storing the socket address data structure of any family. For example, code with a file descriptor and
without the context of the address family can pass a pointer to a variable of this type, where a pointer to a socket address
structure is expected in calls such as getpeername(), and determine the address
family by accessing the received content after the call.
The example below illustrates a data structure which aligns on a 64-bit boundary. An implementation-defined field
_ss_align following _ss_pad1 is used to force a 64-bit alignment which covers proper alignment good enough for needs
of at least sockaddr_in6 (IPv6) and sockaddr_in (IPv4) address data structures. The size of padding field
_ss_pad1 depends on the chosen alignment boundary. The size of padding field _ss_pad2 depends on the value of overall
size chosen for the total size of the structure. This size and alignment are represented in the above example by
implementation-defined (not required) constants _SS_MAXSIZE (chosen value 128) and _SS_ALIGNMENT (with chosen value 8). Constants
_SS_PAD1SIZE (derived value 6) and _SS_PAD2SIZE (derived value 112) are also for illustration and not required. The
implementation-defined definitions and structure field names above start with an  to denote implementation
private name space. Portable code is not expected to access or reference those fields or constants. Note that this example only
deals with size and alignment; see RATIONALE for additional issues related to these structures.
/*
*  Desired design of maximum size and alignment.
*/
#define _SS_MAXSIZE 128
/* Implementation-defined maximum size. */
#define _SS_ALIGNSIZE (sizeof(int64_t))
/* Implementation-defined desired alignment. */
/*
*  Definitions used for sockaddr_storage structure paddings design.
*/
#define _SS_PAD1SIZE (_SS_ALIGNSIZE - sizeof(sa_family_t))
#define _SS_PAD2SIZE (_SS_MAXSIZE - (sizeof(sa_family_t)+ \
_SS_PAD1SIZE + _SS_ALIGNSIZE))
struct sockaddr_storage {
sa_family_t  ss_family;  /* Address family. */
/*
*  Following fields are implementation-defined.
*/
char _ss_pad1[_SS_PAD1SIZE];
/* 6-byte pad; this is to make implementation-defined
pad up to alignment field that follows explicit in
the data structure. */
int64_t _ss_align;  /* Field to force desired structure
storage alignment. */
char _ss_pad2[_SS_PAD2SIZE];
/* 112-byte pad to achieve desired size,
_SS_MAXSIZE value minus size of ss_family
__ss_pad1, __ss_align fields is 112. */
};
Portable applications need to account for the alternative behaviors of the CMSG_NXTHDR macro as follows:
When constructing ancillary data in a msghdr structure, ensure that all locations within the ancillary data that might be
returned by CMSG_NXTHDR contain a cmsg_len value of zero (typically this is achieved by using memset() to initialize the entire msg_control buffer to null bytes before populating
the first cmsghdr structure).
When extracting ancillary data from a received msghdr structure, check that the data array following the last
cmsghdr structure does not extend beyond the end of the ancillary data.
RATIONALE
Note that defining the sockaddr_storage and sockaddr structures using only mechanisms defined in early editions of
the ISO C standard may produce aliasing diagnostics when applications use casting between pointers to the various socket
address structures. Because of the large body of existing code utilizing sockets in a way that could trigger undefined behavior due
to strict aliasing rules, this standard mandates that these structures can alias each other for accessing the sa_family_t
member of the structures (or other members for protocol-specific structure references), so as to preserve well-defined semantics.
An implementation's header files may need to use anonymous unions, or even an implementation-specific extension, to comply with the
requirements of this standard.
FUTURE DIRECTIONS
None.
SEE ALSO
,
XSH accept(), bind(), connect(), getpeername(), getsockname(), getsockopt(),
listen(), recv(), recvfrom(), recvmsg(), send(), sendmsg(), sendto(), setsockopt(), shutdown(), sockatmark(), socket(), socketpair()
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
The restrict keyword is added to the prototypes for accept(), getpeername(), getsockname(),
getsockopt(), and recvfrom().
Issue 7
SD5-XBD-ERN-56 is applied, adding a reference to  for the
ssize_t type.
SD5-XBD-ERN-62 is applied.
The MSG_NOSIGNAL symbolic constant is added from The Open Group Technical Standard, 2006, Extended API Set Part 2.
This reference page is clarified with respect to macros and symbolic constants, and a declaration for the size_t type is
added.
POSIX.1-2008, Technical Corrigendum 1, XBD/TC1-2008/0067 [355] is applied.
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0077 [934] is applied.
Issue 8
Austin Group Defects 411 and 1318 are applied, adding SOCK_NONBLOCK, SOCK_CLOEXEC, SOCK_CLOFORK, MSG_CMSG_CLOEXEC,
MSG_CMSG_CLOFORK, and accept4().
Austin Group Defect 840 is applied, adding SO_DOMAIN and SO_PROTOCOL.
Austin Group Defect 978 is applied, adding CMSG_SPACE and CMSG_LEN, and clarifying the behavior of CMSG_NXTHDR when the second
argument is a null pointer.
Austin Group Defect 1056 is applied, clarifying the conditions under which CMSG_NXTHDR and CMSG_FIRSTHDR return a null pointer,
and adding a new paragraph to APPLICATION USAGE.
Austin Group Defect 1641 is applied, clarifying the requirements for conversions between pointers to sockaddr_storage and
storage structures and between pointers to those structures and pointers to protocol-specific address structures.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/V1_chap09.html =====
Regular Expressions
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
9. Regular Expressions
Regular Expressions (REs) provide a mechanism to select specific strings from a set of character strings.
Regular expressions are a context-independent syntax that can represent a wide variety of character sets and character set
orderings, where these character sets are interpreted according to the current locale. While many regular expressions can be
interpreted differently depending on the current locale, many features, such as character class expressions, provide for contextual
invariance across locales.
The Basic Regular Expression (BRE) notation and construction rules in 9.3 Basic Regular Expressions
shall apply to most utilities supporting regular expressions. Some utilities, instead, support the Extended Regular Expressions
(ERE) described in 9.4 Extended Regular Expressions; any exceptions for both cases are noted in the
descriptions of the specific utilities using regular expressions. Both BREs and EREs are supported by the Regular Expression
Matching interface in the System Interfaces volume of POSIX.1-2024 under regcomp(),
regexec(), and related functions.
9.1 Regular Expression Definitions
For the purposes of this section, the following definitions shall apply:
entire regular expression
The concatenated set of one or more BREs or EREs that make up the pattern specified for string selection.
escape sequence
The escape character followed by any single character, which is thereby "escaped". The escape character is a
that is neither in a bracket expression nor itself escaped.
leftmost
The characters closest to the beginning of the string.
matched
A sequence of zero or more characters shall be said to be matched by a BRE or ERE when the characters in the sequence correspond
to a sequence of characters defined by the pattern.
Matching shall be based on the bit pattern used for encoding the character, not on the graphic representation of the character.
This means that if a character set contains two or more encodings for a graphic symbol, or if the strings searched contain text
encoded in more than one codeset, no attempt is made to search for any other representation of the encoded symbol. If that is
required, the user can specify equivalence classes containing all variations of the desired graphic symbol.
The search for a matching sequence starts at the beginning of a string and stops when the first sequence matching the expression
is found, where "first" is defined to mean "begins earliest in the string". If the pattern permits a variable number of
matching characters and thus there is more than one such sequence starting at that point, the longest such sequence is matched. For
example, the BRE "bb*" matches the second to fourth characters of the string "abbbc", and the ERE
"(wee|week)(knights|night)" matches all ten characters of the string "weeknights".
Consistent with the whole match being the longest of the leftmost matches, each subpattern, from left to right, shall match the
longest possible string. For this purpose, a null string shall be considered to be longer than no match at all. For example,
matching the BRE "\(.*\).*" against "abcdef", the subexpression "(\1)" is "abcdef", and
matching the BRE "\(a*\)*" against "bc", the subexpression "(\1)" is the null string. However, matching
the ERE "(.*?).*" against "abcdef", the subpattern "(.*?)" matches the empty string, since that is the
longest possible match for the ERE ".*?".
When a multi-character collating element in a bracket expression (see 9.3.5 RE Bracket Expression)
is involved, the longest sequence shall be measured in characters consumed from the string to be matched; that is, the collating
element counts not as one element, but as the number of characters it matches.
BRE (ERE) matching a single character
A BRE or ERE that shall match either a single character or a single collating element.
Only a BRE or ERE of this type that includes a bracket expression (see 9.3.5 RE Bracket Expression)
can match a collating element.
BRE (ERE) matching multiple characters
A BRE or ERE that shall match a concatenation of single characters or collating elements.
Such a BRE or ERE is made up from a BRE (ERE) matching a single character and BRE (ERE) special characters.
invalid
This section uses the term "invalid" for certain constructs or conditions. Invalid REs shall cause the utility or function
using the RE to generate an error condition. When invalid is not used, violations of the specified syntax or semantics for REs
produce undefined results: this may entail an error, enabling an extended syntax for that RE, or using the construct in error as
literal characters to be matched. For example, the BRE construct "\{1,2,3\}" does not comply with the grammar. A
conforming application cannot rely on it producing an error nor matching the literal characters "\{1,2,3\}".
9.2 Regular Expression General Requirements
The requirements in this section shall apply to both basic and extended regular expressions.
The use of regular expressions is generally associated with text processing. REs (BREs and EREs) operate on text strings; that
is, zero or more characters followed by an end-of-string delimiter (typically NUL). Some utilities employing regular expressions
limit the processing to lines; that is, zero or more characters followed by a .
In the functions processing regular expressions described in System Interfaces volume of POSIX.1-2024, the  is
regarded as an ordinary character and both a  and a non-matching list can match one. The Shell and Utilities volume
of POSIX.1-2024 specifies within the individual descriptions of those standard utilities employing regular expressions whether they
permit matching of  characters; if not stated otherwise, the use of literal  characters or any escape
sequence equivalent in either patterns or matched text produces undefined results. Those utilities (like grep) that do not allow  characters to match are responsible for eliminating any
from strings before matching against the RE. The regcomp() function
in the System Interfaces volume of POSIX.1-2024, however, can provide support for such processing without violating the rules of
this section.
The interfaces specified in POSIX.1-2024 do not permit the inclusion of a NUL character in an RE or in the string to be matched.
If during the operation of a standard utility a NUL is included in the text designated to be matched, that NUL may designate the
end of the text string for the purposes of matching.
Some standard utilities and functions support case-insensitive regular expression matching. When this type of matching is in
effect, the matching process shall be modified as described in 4.1 Case
Insensitive Comparisons.
The implementation shall support any regular expression that does not exceed 256 bytes in length.
9.3 Basic Regular Expressions
9.3.1 BREs Matching a Single Character or Collating Element
When not inside a bracket expression, the following shall match a single character:
a BRE ordinary character
a BRE special character or ']' preceded by an unescaped
a
A bracket expression shall match a single character or a single collating element.
9.3.2 BRE Ordinary Characters
An ordinary character is a BRE that matches itself: any character in the supported character set, except for the BRE special
characters listed in 9.3.3 BRE Special Characters.
When not inside a bracket expression, the interpretation of an ordinary character preceded by an unescaped  is
undefined, except for:
The characters ')', '(', '{', and '}'
The digits 1 to 9 inclusive (see 9.3.6 BREs Matching Multiple Characters)
The ']' character; "\]" shall match a ']' character
The '?', '+', and '|' characters; it is implementation-defined whether "\?", "\+",
and "\|" each match the literal character '?', '+', or '|', respectively, or behave as
described for the ERE special characters '?', '+', and '|', respectively (see 9.4.3 ERE Special Characters).
Note:
A future version of this standard may require "\?", "\+", and "\|" to behave as described for the
ERE special characters '?', '+', and '|', respectively.
9.3.3 BRE Special Characters
A BRE special character has special properties in certain contexts. Outside those contexts, or when preceded by an unescaped
, such a character is a BRE that matches the special character itself. The BRE special characters and the contexts
in which they have their special meaning are as follows:
.[\
The , , and  shall be special except when used in a bracket
expression (see 9.3.5 RE Bracket Expression). An expression containing a '[' that is
unescaped and is not part of a bracket expression produces undefined results.
*
The  shall be special except when used:
In a bracket expression
As the first character of an entire BRE (after an initial '^', if any)
Immediately following a "\|" escape sequence (after an initial '^', if any), if the implementation does not
match the escape sequence "\|" to the literal character '|'.
As the first character of a subexpression (after an initial '^', if any); see 9.3.6 BREs
Matching Multiple Characters
^
The  shall be special when used as an anchor (see 9.3.8 BRE Expression Anchoring
). The  shall signify a non-matching list expression when it occurs first in a list, immediately following a
(see 9.3.5 RE Bracket Expression).
$
The  shall be special when used as an anchor.
9.3.4 Periods in BREs
When not inside a bracket expression, a  ('.') is a BRE that shall match any character in the supported
character set except NUL.
9.3.5 RE Bracket Expression
A bracket expression (an expression enclosed in square brackets, "[]") is an RE that shall match a specific set of
single characters, and may match a specific set of multi-character collating elements, based on the non-empty set of list
expressions contained in the bracket expression.
The following rules and definitions apply to bracket expressions:
A bracket expression is either a matching list expression or a non-matching list expression. It consists of one or more
expressions: ordinary characters, collating elements, collating symbols, equivalence classes, character classes, or range
expressions. The  (']') shall lose its special meaning and represent itself in a bracket
expression if it occurs first in the list (after an initial  ('^'), if any). Otherwise, it shall
terminate the bracket expression, unless it appears in a collating symbol (such as "[.].]") or is the ending
for a collating symbol, equivalence class, or character class. When the bracket expression appears
within a BRE, the special characters '.', '*', '[', and '\\' (, ,
, and , respectively) shall lose their special meaning within the bracket expression.
When the bracket expression appears within an ERE, the special characters '.', '(', '*', '+',
'?', '{', '|', '$', '[', and '\\' (, ,
, , , , , ,
, and , respectively) shall lose their special meaning within the bracket expression;
('^') shall lose its special meaning as an anchor. When the bracket expression appears within a shell
pattern (see XCU 2.14 Pattern Matching Notation), the special
characters '?', '*', and '[' (, , and ,
respectively) shall lose their special meaning within the bracket expression; whether or not  ('\\')
loses its special meaning as a pattern matching character is described in XCU 2.14.1 Patterns Matching a Single Character, but in contexts where a
shell-quoting  can be used it shall retain its special meaning (see XCU 2.2 Quoting). For example:
$ ls
! $ - \ a b c
$ echo [a\-c]
- a c
$ echo [\!a]
! a
$ echo ["!\$a-c"]
! $ - a c
$ echo [!"\$a-c"]
! \ b
$ echo [!\]\\]
! $ - a b c
The character sequences "[.", "[=", and "[:" ( followed by a
, , or ) shall be special inside a bracket expression and are used to delimit
collating symbols, equivalence class expressions, and character class expressions. These symbols shall be followed by a valid
expression and the matching terminating sequence ".]", "=]", or ":]", as described in the following
items.
A matching list expression specifies a list that shall match any single character that is matched by one of the expressions
represented in the list. The first character in the list cannot be the . An ordinary character in the list shall
only match that character; for example, "[abc]" is an RE that only matches one of the characters 'a',
'b', or 'c'.
It is unspecified whether a matching list expression matches a multi-character collating element that is matched by one of the
expressions.
A non-matching list expression begins with a  ('^'), and the matching behavior shall be the logical
inverse of the corresponding matching list expression (the same bracket expression but without the leading ). For
example, since the RE "[abc]" only matches 'a', 'b', or 'c', it follows that "[^abc]"
is an RE that matches any character except 'a', 'b', or 'c'. It is unspecified whether a non-matching
list expression matches a multi-character collating element that is not matched by any of the expressions. The
shall have this special meaning only when it occurs first in the list, immediately following the .
A collating symbol is a collating element enclosed within bracket-period ("[." and ".]") delimiters. Collating
elements are defined as described in 7.3.2.4 Collation Order.
Conforming applications shall represent multi-character collating elements as collating symbols when it is necessary to distinguish
them from a list of the individual characters that make up the multi-character collating element. For example, if the string
"ch" is a collating element defined using the line:
collating-element  from ""
in the locale definition, the expression "[[.ch.]]" shall be treated as an RE containing the collating symbol
'ch', while "[ch]" shall be treated as an RE matching 'c' or 'h'. Collating symbols are
recognized only inside bracket expressions. If the string is not a collating element in the current locale, the expression is
invalid.
An equivalence class expression shall represent the set of collating elements belonging to an equivalence class, as described in
7.3.2.4 Collation Order. Only primary equivalence classes shall be
recognized. The class shall be expressed by enclosing any one of the collating elements in the equivalence class within
bracket-equal ("[=" and "=]") delimiters. For example, if 'a', 'à', and 'â' belong to
the same equivalence class, then "[[=a=]b]", "[[=à=]b]", and "[[=â=]b]" are each equivalent to
"[aàâb]". If the collating element does not belong to an equivalence class, the equivalence class expression shall be
treated as a collating symbol.
A character class expression shall represent the union of two sets:
The set of single characters that belong to the character class, as defined in the LC_CTYPE category in the current
locale.
An unspecified set of multi-character collating elements.
All character classes specified in the current locale shall be recognized. A character class expression is expressed as a
character class name enclosed within bracket- ("[:" and ":]") delimiters.
The following character class expressions shall be supported in all locales:
[:alnum:]   [:cntrl:]   [:lower:]   [:space:]
[:alpha:]   [:digit:]   [:print:]   [:upper:]
[:blank:]   [:graph:]   [:punct:]   [:xdigit:]
In addition, character class expressions of the form:
[:name:]
are recognized in those locales where the name keyword has been given a charclass definition in the
LC_CTYPE category.
In the POSIX locale, a range expression represents the set of collating elements that fall between two elements in the collation
sequence, inclusive. In other locales, a range expression has unspecified behavior: strictly conforming applications shall not rely
on whether the range expression is valid, or on the set of collating elements matched. A range expression shall be expressed as the
starting point and the ending point separated by a  ('-').
In the following, all examples assume the POSIX locale.
The starting range point and the ending range point shall be a collating element or collating symbol. An equivalence class
expression used as a starting or ending point of a range expression produces unspecified results. An equivalence class can be used
portably within a bracket expression, but only outside the range. If the represented set of collating elements is empty, it is
unspecified whether the expression matches nothing, or is treated as invalid.
The interpretation of range expressions where the ending range point is also the starting range point of a subsequent range
expression (for example, "[a-m-o]") is undefined.
The  character shall be treated as itself if it occurs first (after an initial '^', if any) or last
in the list, or as an ending range point in a range expression. As examples, the expressions "[-ac]" and "[ac-]"
are equivalent and match any of the characters 'a', 'c', or '-'; "[^-ac]" and "[^ac-]"
are equivalent and match any characters except 'a', 'c', or '-'; the expression "[%--]" matches
any of the characters between '%' and '-' inclusive; the expression "[--@]" matches any of the
characters between '-' and '@' inclusive; and the expression "[a--@]" is either invalid or equivalent to
'@', because the letter 'a' follows the symbol '-' in the POSIX locale. To use a  as
the starting range point, it shall either come first in the bracket expression or be specified as a collating symbol; for example,
"[][.-.]-0]", which matches either a  or any character or collating element that collates
between  and 0, inclusive.
If a bracket expression specifies both '-' and ']', the ']' shall be placed first (after the
'^', if any) and the '-' last within the bracket expression.
If a bracket expression contains at least three list elements, where the first and last list elements are the same
single-character element of , , or , then it is unspecified whether the bracket
expression will be treated as a collating symbol, equivalence class, or character class, respectively; treated as a matching list
expression; or treated as an invalid bracket expression.
9.3.6 BREs Matching Multiple Characters
The following rules can be used to construct BREs matching multiple characters from BREs matching a single character:
The concatenation of BREs shall match the concatenation of the strings matched by each component of the BRE.
A subexpression can be defined within a BRE by enclosing it between the character pairs "\(" and "\)". Such a
subexpression shall match whatever it would have matched without the "\(" and "\)", except that anchoring within
subexpressions is optional behavior; see 9.3.8 BRE Expression Anchoring. Subexpressions can be
arbitrarily nested.
The back-reference expression '\n' shall match the same (possibly empty) string of characters as was matched by a
subexpression enclosed between "\(" and "\)" preceding the '\n'. The character 'n' shall be a
digit from 1 through 9, specifying the nth subexpression (the one that begins with the nth "\(" from the
beginning of the pattern and ends with the corresponding paired "\)"). The expression is invalid if less than n
subexpressions precede the '\n'. The string matched by a contained subexpression shall be within the string matched by the
containing subexpression. If the containing subexpression does not match, or if there is no match for the contained subexpression
within the string matched by the containing subexpression, then back-reference expressions corresponding to the contained
subexpression shall not match. When a subexpression matches more than one string, a back-reference expression corresponding to the
subexpression shall refer to the last matched string. For example, the expression "^\(.*\)\1$" matches strings consisting
of two adjacent appearances of the same substring, and the expression "\(a\)*\1" fails to match 'a', the
expression "\(a\(b\)*\)*\2" fails to match 'abab', and the expression "^\(ab*\)*\1$" matches
'ababbabb', but fails to match 'ababbab'.
When a BRE matching a single character, a subexpression, or a back-reference is followed by the special character
('*'), together with that  it shall match what zero or more consecutive occurrences of
the BRE would match. For example, "[ab]*" and "[ab][ab]" are equivalent when matching the string
"ab".
When a BRE matching a single character, a subexpression, or a back-reference is followed by an interval expression of the format
"\{m\}", "\{m,\}", or "\{m,n\}", together with that interval expression it shall match what repeated
consecutive occurrences of the BRE would match. The values of m and n are decimal integers in the range 0
('*') or an interval expression shall not match a null expression
unless this is the only match for the repetition or it is necessary to satisfy the exact or minimum number of occurrences for the
interval expression.
9.3.7 BRE Precedence
The order of precedence shall be as shown in the following table:
BRE Precedence (from high to low)
Collation-related bracket symbols
[==] [::] [..]
Escaped characters
\
Bracket expression
[]
Subexpressions/back-references
\(\) \n
Single-character-BRE duplication
* \{m,n\}
Concatenation
Anchoring
^ $
9.3.8 BRE Expression Anchoring
A BRE can be limited to matching expressions that begin or end a string; this is called "anchoring". The
and  special characters shall be considered BRE anchors in the following contexts:
A  ('^') shall be an anchor when used as the first character of an entire BRE and, if
the implementation does not match the escape sequence "\|" to the literal character '|', when used immediately
following a "\|" escape sequence that is not inside a subexpression. The implementation may also treat a
as an anchor when used inside a subexpression; in this case it shall be an anchor only when either of the
following is true:
It is the first character of the subexpression.
It immediately follows a "\|" escape sequence and the implementation does not match the escape sequence
"\|" to the literal character '|'.
The  shall anchor the expression (or optionally subexpression) to the beginning of a string; only
sequences starting at the first character of a string shall be matched by the BRE. For example, the BRE "^ab" matches
"ab" in the string "abcdef", but fails to match in the string "cdefab". The BRE "\(^ab\)" may
match the former string. A portable BRE shall escape a leading  in a subexpression to match a literal
.
A  ('$') shall be an anchor when used as the last character of an entire BRE and, if
the implementation does not match the escape sequence "\|" to the literal character '|', when used immediately
preceding a "\|" escape sequence that is not inside a subexpression. The implementation may also treat a
as an anchor when used inside a subexpression; in this case it shall be an anchor only when either of the
following is true:
It is the last character of the subexpression.
It immediately precedes a "\|" escape sequence and the implementation does not match the escape sequence
"\|" to the literal character '|'.
The  shall anchor the expression (or optionally subexpression) to the end of the string being
matched; the  can be said to match the end-of-string following the last character. A portable BRE shall escape a
trailing  in a subexpression to match a literal .
A BRE anchored by both '^' and '$' shall match only an entire string. For example, the BRE
"^abcdef$" matches strings consisting only of "abcdef".
9.4 Extended Regular Expressions
The extended regular expression (ERE) notation and construction rules shall apply to utilities defined as using
extended regular expressions; any exceptions to the following rules are noted in the descriptions of the specific utilities using
EREs.
9.4.1 EREs Matching a Single Character or Collating Element
When not inside a bracket expression, the following shall match a single character:
an ERE ordinary character
an ERE special character, ']', or '}' preceded by an unescaped
a
A bracket expression shall match a single character or a single collating element. An ERE matching a single
character enclosed in parentheses shall match the same as the ERE without parentheses would have matched.
9.4.2 ERE Ordinary Characters
An ordinary character is an ERE that matches itself. An ordinary character is any character in the supported
character set, except for the ERE special characters listed in 9.4.3 ERE Special Characters. When not
inside a bracket expression, the interpretation of an ordinary character preceded by an unescaped  is undefined,
except for the ']' and '}' characters; "\]" and "\}" shall match the ']' and
'}' characters, respectively.
9.4.3 ERE Special Characters
An ERE special character has special properties in certain contexts. Outside those contexts, or when preceded by an
unescaped , such a character shall be an ERE that matches the special character itself. The extended regular
expression special characters and the contexts in which they shall have their special meaning are as follows:
.[\(
The , , , and  shall be special except when
used in a bracket expression (see 9.3.5 RE Bracket Expression). When not inside a bracket expression,
an unescaped  immediately followed by a  produces undefined results. A
that is unescaped and is not part of a bracket expression also produces undefined results.
)
The  shall be special when matched with a preceding , both not inside a
bracket expression.
*+?{
The , , , and  shall be special except when used in a
bracket expression (see 9.3.5 RE Bracket Expression). Any of the following uses produce undefined
results:
If these characters appear first in an ERE, or immediately following an unescaped ,
, , or
If a  is not part of a valid interval expression (see 9.4.6 EREs
Matching Multiple Characters)
|
The  is special except when used in a bracket expression (see 9.3.5 RE Bracket
Expression). A  appearing first or last in an ERE, or immediately following a  or a
, or immediately preceding a , produces undefined results.
^
The  shall be special when used as an anchor (see 9.4.9 ERE Expression Anchoring
). The  shall signify a non-matching list expression when it occurs first in a list, immediately following a
(see 9.3.5 RE Bracket Expression).
$
The  shall be special when used as an anchor.
9.4.4 Periods in EREs
When not inside a bracket expression, a  ('.') is an ERE that shall match any character in
the supported character set except NUL.
9.4.5 ERE Bracket Expression
The rules for ERE Bracket Expressions are the same as for Basic Regular Expressions; see 9.3.5 RE Bracket Expression.
9.4.6 EREs Matching Multiple Characters
The following rules shall be used to construct EREs matching multiple characters from EREs matching a single
character:
A concatenation of EREs shall match the concatenation of the character sequences matched by each component of the
ERE. A concatenation of EREs enclosed in parentheses shall match whatever the concatenation without the parentheses matches. For
example, both the ERE "cd" and the ERE "(cd)" are matched by the third and fourth character of the string
"abcdefabcdef".
When an ERE matching a single character or an ERE enclosed in parentheses is followed by the special character
('+'), together with that  it shall match what one or more consecutive occurrences of
the ERE would match. For example, the ERE "b+(bc)" matches the fourth to seventh characters in the string
"acabbbcde". And, "[ab]+" and "[ab][ab]*" are equivalent.
When an ERE matching a single character or an ERE enclosed in parentheses is followed by the special character
('*'), together with that  it shall match what zero or more consecutive occurrences of
the ERE would match. For example, the ERE "b*c" matches the first character in the string "cabbbcde", and the ERE
"b*cd" matches the third to seventh characters in the string "cabbbcdebbbbbbcdbc". And, "[ab]*" and
"[ab][ab]" are equivalent when matching the string "ab".
When an ERE matching a single character or an ERE enclosed in parentheses is followed by the special character
('?'), together with that  it shall match what zero or one consecutive
occurrences of the ERE would match. For example, the ERE "b?c" matches the second character in the string
"acabbbcde".
When an ERE matching a single character or an ERE enclosed in parentheses is followed by an interval expression of
the format "{m}", "{m,}", or "{m,n}", together with that interval expression it shall match what
repeated consecutive occurrences of the ERE would match. The values of m and n are decimal integers in the range 0
), in which case matching behavior for that repetition shall be changed from
the leftmost longest possible match to the leftmost shortest possible match, including the null match (see A.9 Regular Expressions). For example, the ERE ".*c" matches up to and
including the last character ('c') in the string "abc abc", whereas the ERE ".*?c" matches up to and
including the first character 'c', the third character in the string.
If the REG_MINIMAL flag, defined in the  header, is
used when compiling an ERE via regcomp(), the leftmost shortest possible match shall
be the default for all duplication symbols, and the repetition modifier '?' can be used to select the leftmost longest
possible match for the repetition it modifies.
The behavior of multiple adjacent duplication symbols ('+', '*', '?', and intervals,
possibly suffixed by the repetition modifier '?') produces undefined results.
An ERE matching a single character repeated by an '*', '?', or an interval expression shall not
match a null expression unless this is the only match for the repetition or it is necessary to satisfy the exact or minimum number
of occurrences for the interval expression.
9.4.7 ERE Alternation
Two EREs separated by the special character  ('|') shall match a string that is
matched by either. For example, the ERE "a((bc)|d)" matches the string "abc" and the string "ad". Single
characters, or expressions matching single characters, separated by the  and enclosed in parentheses, shall be
treated as an ERE matching a single character.
9.4.8 ERE Precedence
The order of precedence shall be as shown in the following table:
ERE Precedence (from high to low)
Collation-related bracket symbols
[==] [::] [..]
Escaped characters
\
Bracket expression
[]
Grouping
()
Single-character-ERE duplication
* + ? {m,n}
Concatenation
Anchoring
^ $
Alternation
|
For example, the ERE "abba|cde" matches either the string "abba" or the string "cde"
(rather than the string "abbade" or "abbcde", because concatenation has a higher order of precedence than
alternation).
9.4.9 ERE Expression Anchoring
An ERE can be limited to matching expressions that begin or end a string; this is called "anchoring". The
and  special characters shall be considered ERE anchors when used anywhere except inside a
bracket expression. This shall have the following effects:
When not inside a bracket expression, a  ('^') shall anchor the expression or
subexpression it begins to the beginning of a string; such an expression or subexpression can match only a sequence starting at the
first character of a string. For example, the EREs "^ab" and "(^ab)" match "ab" in the string
"abcdef", but fail to match in the string "cdefab", and the ERE "a^b" is valid, but can never match
because the 'a' prevents the expression "^b" from matching starting at the first character.
When not inside a bracket expression, a  ('$') shall anchor the expression or
subexpression it ends to the end of a string; such an expression or subexpression can match only a sequence ending at the last
character of a string. For example, the EREs "ef$" and "(ef$)" match "ef" in the string
"abcdef", but fail to match in the string "cdefab", and the ERE "e$f" is valid, but can never match
because the 'f' prevents the expression "e$" from matching ending at the last character.
9.5 Regular Expression Grammar
Grammars describing the syntax of both basic and extended regular expressions are presented in this section. The
grammar takes precedence over the text. See XCU 1.3 Grammar Conventions
.
9.5.1 BRE/ERE Grammar Lexical Conventions
The lexical conventions for regular expressions are as described in this section.
Except as noted, the longest possible token or delimiter beginning at a given point is recognized.
The following tokens are processed (in addition to those string constants shown in the grammar):
COLL_ELEM_SINGLE
Any single-character collating element, unless it is a META_CHAR.
COLL_ELEM_MULTI
Any multi-character collating element.
BACKREF
Applicable only to basic regular expressions. The character string consisting of a  character followed by a
single-digit numeral, '1' to '9'.
DUP_COUNT
Represents a numeric constant. It shall be an integer in the range 0
character are treated as ORD_CHAR.
META_CHAR
One of the characters:
^
When found first in a bracket expression
-
When found anywhere but first (after an initial '^', if any) or last in a bracket expression, or as the ending range
point in a range expression
]
When found anywhere but first (after an initial '^', if any) in a bracket expression
L_ANCHOR
Applicable only to basic regular expressions. The character '^' when it appears either as the first character of a
basic regular expression or, if the implementation does not match the escape sequence "\|" to the literal character
'|', when used immediately following a "\|" escape sequence that is not inside a subexpression, and when not
QUOTED_CHAR. The '^' may be recognized as an anchor elsewhere; see 9.3.8 BRE Expression
Anchoring.
ORD_CHAR
A character, other than one of the special characters in SPEC_CHAR.
QUOTED_CHAR
In a BRE, one of the character sequences:
\^    \.    \*    \[    \]    \$    \\
On implementations where the escape sequences "\?", "\+", and "\|" match the literal
characters '?', '+', and '|', respectively, QUOTED_CHAR shall also include:
\?    \+    \|
In an ERE, one of the character sequences:
\^    \.    \[    \]    \$    \(    \)    \|
\*    \+    \?    \{    \}    \\
R_ANCHOR
(Applicable only to basic regular expressions.) The character '$' when it appears either as the last character of a
basic regular expression or, if the implementation does not match the escape sequence "\|" to the literal character
'|', when used immediately preceding a "\|" escape sequence that is not inside a subexpression, and when not
QUOTED_CHAR. The '$' may be recognized as an anchor elsewhere; see 9.3.8 BRE Expression
Anchoring.
SPEC_CHAR
For basic regular expressions, one of the following special characters:
.
Anywhere except inside bracket expressions
\
Anywhere except inside bracket expressions
[
Anywhere except inside bracket expressions
^
When used as an anchor (see 9.3.8 BRE Expression Anchoring)
$
When used as an anchor
*
Anywhere except first in an entire RE, anywhere in a bracket expression, directly following "\(", directly following
an anchoring '^'
For extended regular expressions, shall be one of the following special characters found anywhere except inside
bracket expressions:
^    .    [    $    (    )    |
*    +    ?    {    \
The close-parenthesis shall be considered special in this context only if matched with a preceding
open-parenthesis.
9.5.2 RE and Bracket Expression Grammar
This section presents the grammar for basic regular expressions, including the bracket expression grammar that is
common to both BREs and EREs.
%token    ORD_CHAR QUOTED_CHAR DUP_COUNT
%token    BACKREF L_ANCHOR R_ANCHOR
%token    Back_open_paren  Back_close_paren
/*          '\('             '\)'        */
%token    Back_open_brace  Back_close_brace
/*          '\{'             '\}'        */
/* The following shall be tokens on implementations where
\?, \+, and \| are not included in QUOTED_CHAR */
%token    Back_qm  Back_plus  Back_bar
/*          '\?'     '\+'       '\|'     */
/* The following tokens are for the Bracket Expression
grammar common to both REs and EREs. */
%token    COLL_ELEM_SINGLE COLL_ELEM_MULTI META_CHAR
%token    Open_equal Equal_close Open_dot Dot_close Open_colon Colon_close
/*           '[='       '=]'        '[.'     '.]'      '[:'       ':]'  */
%token    class_name
/* class_name is a keyword to the LC_CTYPE locale category */
/* (representing a character class) in the current locale */
/* and is only recognized between [: and :] */
%start    basic_reg_exp
%%
/* --------------------------------------------
Basic Regular Expression
--------------------------------------------
*/
basic_reg_exp   :                        BRE_branch
| basic_reg_exp Back_bar BRE_branch /* if Back_bar
is a token */
;
BRE_branch      :            BRE_expression
| BRE_branch BRE_expression
;
BRE_expression  :          simple_BRE
| L_ANCHOR
|                     R_ANCHOR
| L_ANCHOR            R_ANCHOR
| L_ANCHOR simple_BRE
|          simple_BRE R_ANCHOR
| L_ANCHOR simple_BRE R_ANCHOR
;
simple_BRE      : nondupl_BRE
| nondupl_BRE BRE_dupl_symbol
;
nondupl_BRE     : one_char_or_coll_elem_BRE
| Back_open_paren basic_reg_exp Back_close_paren
| BACKREF
;
one_char_or_coll_elem_BRE  : ORD_CHAR
| QUOTED_CHAR
| '.'
| bracket_expression
;
BRE_dupl_symbol : '*'
| Back_qm   /* if Back_qm is a token */
| Back_plus /* if Back_plus is a token */
| Back_open_brace DUP_COUNT               Back_close_brace
| Back_open_brace DUP_COUNT ','           Back_close_brace
| Back_open_brace DUP_COUNT ',' DUP_COUNT Back_close_brace
;
/* --------------------------------------------
Bracket Expression
-------------------------------------------
*/
bracket_expression : '[' matching_list ']'
| '[' nonmatching_list ']'
;
matching_list  : bracket_list
;
nonmatching_list : '^' bracket_list
;
bracket_list   : follow_list
| follow_list '-'
;
follow_list    :             expression_term
| follow_list expression_term
;
expression_term : single_expression
| range_expression
;
single_expression : end_range
| character_class
| equivalence_class
;
range_expression : start_range end_range
| start_range '-'
;
start_range    : end_range '-'
;
end_range      : COLL_ELEM_SINGLE
| collating_symbol
;
collating_symbol : Open_dot COLL_ELEM_SINGLE Dot_close
| Open_dot COLL_ELEM_MULTI Dot_close
| Open_dot META_CHAR Dot_close
;
equivalence_class : Open_equal COLL_ELEM_SINGLE Equal_close
| Open_equal COLL_ELEM_MULTI Equal_close
;
character_class : Open_colon class_name Colon_close
;
Note that although the BRE grammar appears always to permit L_ANCHOR or R_ANCHOR inside "\("
and "\)", the lexical conventions (see 9.5.1 BRE/ERE Grammar Lexical Conventions) imply that
'^' and '$' may be ordinary characters there. This reflects the semantic limits on the application, as noted in
9.3.8 BRE Expression Anchoring. Since it is an implementation option whether to interpret '^'
and '$' as anchors in these locations, conforming applications cannot use unescaped '^' and '$' in
positions inside "\(" and "\)" that might be interpreted as anchors.
9.5.3 ERE Grammar
This section presents the grammar for extended regular expressions, excluding the bracket expression grammar.
Note:
The bracket expression grammar and the associated %token lines are identical between BREs and EREs. It has been omitted
from the ERE section to avoid unnecessary editorial duplication.
%token  ORD_CHAR QUOTED_CHAR DUP_COUNT
%start  extended_reg_exp
%%
/* --------------------------------------------
Extended Regular Expression
--------------------------------------------
*/
extended_reg_exp   :                      ERE_branch
| extended_reg_exp '|' ERE_branch
;
ERE_branch         :            ERE_expression
| ERE_branch ERE_expression
;
ERE_expression     : one_char_or_coll_elem_ERE
| '^'
| '$'
| '(' extended_reg_exp ')'
| ERE_expression ERE_dupl_symbol
;
one_char_or_coll_elem_ERE  : ORD_CHAR
| QUOTED_CHAR
| '.'
| bracket_expression
;
ERE_dupl_symbol    : '*'
| '+'
| '?'
| '{' DUP_COUNT               '}'
| '{' DUP_COUNT ','           '}'
| '{' DUP_COUNT ',' DUP_COUNT '}'
;
The ERE grammar does not permit several constructs that previous sections specify as having undefined results.
Additionally, there are some constructs which the grammar permits but which still give undefined results:
ORD_CHAR preceded by an unescaped  character
One or more ERE_dupl_symbols appearing first in an ERE, or immediately following '|',
'^', '(', or '$'
'{' not part of a valid ERE_dupl_symbol
'|' appearing first or last in an ERE, or immediately following '|' or '(', or
immediately preceding ')'
Implementations are permitted to extend the language to allow these. Strictly Conforming applications cannot use
such constructs.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/float.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
float.h — floating types
SYNOPSIS
#include
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The characteristics of floating types are defined in terms of a model that describes a representation of floating-point numbers
and values that provide information about an implementation's floating-point arithmetic.
The following parameters are used to define the model for each floating-point type:
s
Sign (±1).
b
Base or radix of exponent representation (an integer >1).
e
Exponent (an integer between a minimum \(e_{min}\) and a maximum \(e_{max}\)).
p
Precision (the number of base-b digits in the significand).
\(f_{k}\)
Non-negative integers less than b (the significand digits).
A floating-point number x is defined by the following model:
\(x=s b^e \sum_{k=1}^p f_k b^{-k}, e_{\min } \leq e \leq e_{\max }\)
In addition to normalized floating-point numbers (\(f_{1}\)>0 if x!=0), floating types may be able to contain other
kinds of floating-point numbers, such as subnormal floating-point numbers (x!=0, \(e=e_{min}\), \(f_{1}=0\)) and
unnormalized floating-point numbers ( x!=0, \(e> e_{min}, f_{1}=0\)), and values that are not floating-point
numbers, such as infinities and NaNs. A NaN is an encoding signifying Not-a-Number. A quiet NaN propagates through
almost every arithmetic operation without raising a floating-point exception; a signaling NaN generally raises a
floating-point exception when occurring as an arithmetic operand.
An implementation may give zero and non-numeric values, such as infinities and NaNs, a sign, or may leave them unsigned.
Wherever such values are unsigned, any requirement in POSIX.1-2024 to retrieve the sign shall produce an unspecified sign and any
requirement to set the sign shall be ignored.
The accuracy of the floating-point operations ( '+' , '-' , '*' , '/' ) and of the functions
in  and  that return floating-point results is implementation-defined, as is the
accuracy of the conversion between floating-point internal representations and string representations performed by the functions in
, , and
. The implementation may state that the accuracy is unknown.
All integer values in the  header, except FLT_ROUNDS, shall be constant expressions suitable for use in
#if preprocessing directives; all floating values shall be constant expressions. All except DECIMAL_DIG, FLT_EVAL_METHOD,
FLT_RADIX, and FLT_ROUNDS have separate names for all three floating-point types. The floating-point model representation is
provided for all values except FLT_EVAL_METHOD and FLT_ROUNDS.
The rounding mode for floating-point addition is characterized by the implementation-defined value of FLT_ROUNDS:
-1
Indeterminable.
0
Toward zero.
1
To nearest.
2
Toward positive infinity.
3
Toward negative infinity.
All other values for FLT_ROUNDS characterize implementation-defined rounding behavior.
The values of operations with floating operands and values subject to the usual arithmetic conversions and of floating constants
are evaluated to a format whose range and precision may be greater than required by the type. The use of evaluation formats is
characterized by the implementation-defined value of FLT_EVAL_METHOD:
-1
Indeterminable.
0
Evaluate all operations and constants just to the range and precision of the type.
1
Evaluate operations and constants of type float and double to the range and precision of the double type;
evaluate long double operations and constants to the range and precision of the long double type.
2
Evaluate all operations and constants to the range and precision of the long double type.
All other negative values for FLT_EVAL_METHOD characterize implementation-defined behavior.
The presence or absence of subnormal numbers is characterized by the implementation-defined values of FLT_HAS_SUBNORM,
DBL_HAS_SUBNORM, and LDBL_HAS_SUBNORM:
-1
Indeterminable.
0
Absent (type does not support subnormal numbers).
1
Present (type does support subnormal numbers).
Note:
Characterization as indeterminable is intended if floating-point operations do not consistently interpret subnormal
representations as zero, nor as non-zero. Characterization as absent is intended if no floating-point operations produce subnormal
results from non-subnormal inputs, even if the type format includes representations of subnormal numbers.
The  header shall define the following values as constant expressions with implementation-defined values
that are greater or equal in magnitude (absolute value) to those shown, with the same sign.
Radix of exponent representation, b.
FLT_RADIX
2
Number of base-FLT_RADIX digits in the floating-point significand, p.
FLT_MANT_DIG
DBL_MANT_DIG
LDBL_MANT_DIG
Number of decimal digits, n, such that any floating-point number with p radix b digits can be rounded to a
floating-point number with n decimal digits and back again without change to the value.
\(
\begin{cases}p \log _{10} b & \text { if } b \text { is a power of } 10 \\ \Big\lceil 1+p \log _{10} b\Big\rceil & \text { otherwise }\end{cases}
\)
FLT_DECIMAL_DIG
6
DBL_DECIMAL_DIG
10
LDBL_DECIMAL_DIG
10
Number of decimal digits, n, such that any floating-point number in the widest supported floating type with \(p_{max}\)
radix b digits can be rounded to a floating-point number with n decimal digits and back again without change to the
value.
\(
\begin{cases}p_{\max } \log _{10} b & \text { if } b \text { is a power of } 10 \\ \Big\lceil 1+p_{\max } \log _{10} b\Big\rceil & \text { otherwise }\end{cases}
\)
DECIMAL_DIG
10
Number of decimal digits, q, such that any floating-point number with q decimal digits can be rounded into a
floating-point number with p radix b digits and back again without change to the q decimal digits.
\(
\begin{cases}p \log _{10} b & \text { if } b \text { is a power of } 10 \\ \Big\lfloor(p-1) \log _{10} b \Big\rfloor & \text { otherwise }\end{cases}
\)
FLT_DIG
6
DBL_DIG
10
LDBL_DIG
10
Minimum negative integer such that FLT_RADIX raised to that power minus 1 is a normalized floating-point number, \(e_{min}\).
FLT_MIN_EXP
DBL_MIN_EXP
LDBL_MIN_EXP
Minimum negative integer such that 10 raised to that power is in the range of normalized floating-point numbers.
\(
\Big\lceil\log _{10} b^{e_{\min }-1}\Big\rceil
\)
FLT_MIN_10_EXP
-37
DBL_MIN_10_EXP
-37
LDBL_MIN_10_EXP
-37
Maximum integer such that FLT_RADIX raised to that power minus 1 is a representable finite floating-point number, \(e_{max}\).
FLT_MAX_EXP
DBL_MAX_EXP
LDBL_MAX_EXP
[CX]
Additionally, FLT_MAX_EXP shall be at least as large as FLT_MANT_DIG, DBL_MAX_EXP shall be at least as large as DBL_MANT_DIG, and
LDBL_MAX_EXP shall be at least as large as LDBL_MANT_DIG; which has the effect that FLT_MAX, DBL_MAX, and LDBL_MAX are integral.
Maximum integer such that 10 raised to that power is in the range of representable finite floating-point numbers.
\(
\Big\lfloor\log _{10}\left(\left(1-b^{-p}\right) b^{e_{\max }}\right)\Big\rfloor
\)
FLT_MAX_10_EXP
+37
DBL_MAX_10_EXP
+37
LDBL_MAX_10_EXP
+37
The  header shall define the following values as constant expressions with implementation-defined values
that are greater than or equal to those shown:
Maximum representable finite floating-point number.
\(\left(1-b^{-p}\right) b^{e_{\max }}\)
FLT_MAX
1E+37
DBL_MAX
1E+37
LDBL_MAX
1E+37
The  header shall define the following values as constant expressions with implementation-defined
(positive) values that are less than or equal to those shown:
The difference between 1 and the least value greater than 1 that is representable in the given floating-point type, \(b^{1 - {p}}\)
FLT_EPSILON
1E-5
DBL_EPSILON
1E-9
LDBL_EPSILON
1E-9
Minimum normalized positive floating-point number,
\(b^{e_{\min}-1}\)
FLT_MIN
1E-37
DBL_MIN
1E-37
LDBL_MIN
1E-37
Minimum positive floating-point number.
FLT_TRUE_MIN
1E-37
DBL_TRUE_MIN
1E-37
LDBL_TRUE_MIN
1E-37
Note:
If the presence or absence of subnormal numbers is indeterminable, then the value is intended to be a positive number no
greater than the minimum normalized positive number for the type.
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
All known hardware floating-point formats satisfy the property that the exponent range is larger than the number of digits in
the significand. The ISO C standard permits a floating-point format where this property is not true, such that the largest
finite value would not be integral; however, it is unlikely that there will ever be hardware support for such a floating-point
format, and it introduces boundary cases that portable programs should not have to be concerned with (for example, a non-integral
DBL_MAX means that ceil() would have to worry about overflow). Therefore, this standard
imposes an additional requirement that the largest representable finite value is integral.
FUTURE DIRECTIONS
The formula for calculating FLT_MAX, DBL_MAX, and LDBL_MAX is expected to change in the next revision of the ISO C standard
such that it only applies if the values are normalized.
SEE ALSO
,
, , ,
CHANGE HISTORY
First released in Issue 4. Derived from the ISO C standard.
Issue 6
The description of the operations with floating-point values is updated for alignment with the ISO/IEC 9899:1999
standard.
Issue 7
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #4 (SD5-XBD-ERN-50) and #5 (SD5-XBD-ERN-51) are applied.
POSIX.1-2008, Technical Corrigendum 1, XBD/TC1-2008/0046 [346] and XBD/TC1-2008/0047 [346] are applied.
Issue 8
Austin Group Defect 1302 is applied, aligning this header with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1752 is applied, changing "the number of mantissa digits" to "the number of digits in the
significand".
Austin Group Defect 1754 is applied, changing the FUTURE DIRECTIONS section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/inttypes.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
inttypes.h — fixed size integer types
SYNOPSIS
#include
DESCRIPTION
[CX]  Some of the functionality described on this reference page extends the ISO C standard. Applications shall define
the appropriate feature test macro (see XSH 2.2 The Compilation
Environment) to enable the visibility of these symbols in this header.
The  header shall include the
header.
The  header shall define at least the following types:
imaxdiv_t
Structure type that is the type of the value returned by the imaxdiv()
function.
wchar_t
[CX]  As
described in .
The  header shall define the following macros. Each expands to a character string literal containing a
conversion specifier, possibly modified by a length modifier, suitable for use within the format argument of a formatted
input/output function when converting the corresponding integer type. These macros have the general form of PRI (character string
literals for the fprintf() and fwprintf() family of functions) or SCN (character string literals for the fscanf() and fwscanf() family of functions),
followed by the conversion specifier, followed by a name corresponding to a similar type name in . In these names, N represents the width of the type as described in
. For example, PRIdFAST32 can be used in a format string to
print the value of an integer of type int_fast32_t.
The fprintf() macros for signed integers are:
PRIdN
PRIdLEASTN
PRIdFASTN
PRIdMAX
PRIdPTR
PRIiN
PRIiLEASTN
PRIiFASTN
PRIiMAX
PRIiPTR
The fprintf() macros for unsigned integers are:
PRIoN
PRIoLEASTN
PRIoFASTN
PRIoMAX
PRIoPTR
PRIuN
PRIuLEASTN
PRIuFASTN
PRIuMAX
PRIuPTR
PRIxN
PRIxLEASTN
PRIxFASTN
PRIxMAX
PRIxPTR
PRIXN
PRIXLEASTN
PRIXFASTN
PRIXMAX
PRIXPTR
The fscanf() macros for signed integers are:
SCNdN
SCNdLEASTN
SCNdFASTN
SCNdMAX
SCNdPTR
SCNiN
SCNiLEASTN
SCNiFASTN
SCNiMAX
SCNiPTR
The fscanf() macros for unsigned integers are:
SCNoN
SCNoLEASTN
SCNoFASTN
SCNoMAX
SCNoPTR
SCNuN
SCNuLEASTN
SCNuFASTN
SCNuMAX
SCNuPTR
SCNxN
SCNxLEASTN
SCNxFASTN
SCNxMAX
SCNxPTR
For each type that the implementation provides in ,
the corresponding fprintf() and fwprintf() macros shall be defined and the corresponding fscanf() and fwscanf() macros shall be defined
unless the implementation does not have a suitable modifier for the type.
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be
provided.
intmax_t  imaxabs(intmax_t);
imaxdiv_t imaxdiv(intmax_t, intmax_t);
intmax_t  strtoimax(const char *restrict, char **restrict, int);
uintmax_t strtoumax(const char *restrict, char **restrict, int);
intmax_t  wcstoimax(const wchar_t *restrict, wchar_t **restrict, int);
uintmax_t wcstoumax(const wchar_t *restrict, wchar_t **restrict, int);
The following sections are informative.
EXAMPLES
#include
#include
int main(void)
{
uintmax_t i = UINTMAX_MAX; // This type always exists.
wprintf(L"The largest integer value is %020"
PRIxMAX "\n", i);
return 0;
}
APPLICATION USAGE
The purpose of  is to provide a set of integer types whose definitions are consistent across machines
and independent of operating systems and other implementation idiosyncrasies. It defines, through typedef, integer types of
various sizes. Implementations are free to typedef them as ISO C standard integer types or extensions that they
support. Consistent use of this header will greatly increase the portability of applications across platforms.
RATIONALE
The ISO/IEC 9899:1990 standard specified that the language should support four signed and unsigned integer data
types—char, short, int, and long—but placed very little requirement on their size other than that
int and short be at least 16 bits and long be at least as long as int and not smaller than 32 bits. For
16-bit systems, most implementations assigned 8, 16, 16, and 32 bits to char, short, int, and long,
respectively. For 32-bit systems, the common practice has been to assign 8, 16, 32, and 32 bits to these types. This difference in
int size can create some problems for users who migrate from one system to another which assigns different sizes to integer
types, because the ISO C standard integer promotion rule can produce silent changes unexpectedly. The need for defining an
extended integer type increased with the introduction of 64-bit systems.
FUTURE DIRECTIONS
Macro names beginning with PRI or SCN followed by any lowercase letter or 'X' may be added to the macros defined in the
header.
SEE ALSO
XSH 2.2 The Compilation Environment, imaxabs(), imaxdiv(), strtoimax(), wcstoimax()
CHANGE HISTORY
First released in Issue 5.
Issue 6
The Open Group Base Resolution bwg97-006 is applied.
This reference page is updated to align with the ISO/IEC 9899:1999 standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XBD/TC1-2008/0050 [211] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/wordexp.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wordexp.h — word-expansion types
SYNOPSIS
#include
DESCRIPTION
The  header shall define the structures and symbolic constants used by the wordexp() and wordfree() functions.
The  header shall define the wordexp_t structure type, which shall include at least the following
members:
size_t   we_wordc  Count of words matched by words.
char   **we_wordv  Pointer to list of expanded words.
size_t   we_offs   Slots to reserve at the beginning of we_wordv.
The  header shall define the following symbolic constants for use as flags for the wordexp() function:
WRDE_APPEND
Append words to those previously generated.
WRDE_DOOFFS
Number of null pointers to prepend to we_wordv.
WRDE_NOCMD
Fail if command substitution is requested.
WRDE_REUSE
The pwordexp argument was passed to a previous successful call to wordexp(), and has not been passed to wordfree(). The result is the same as if the application had called wordfree() and then called wordexp() without
WRDE_REUSE.
WRDE_SHOWERR
Do not redirect stderr to /dev/null.
WRDE_UNDEF
Report error on an attempt to expand an undefined shell variable.
The  header shall define the following symbolic constants as error return values:
WRDE_BADCHAR
One of the unquoted characters—, '|', '&', ';', '',
'(', ')', '{', '}'—appears in words in an inappropriate context.
WRDE_BADVAL
Reference to undefined shell variable when WRDE_UNDEF is set in flags.
WRDE_CMDSUB
Command substitution requested when WRDE_NOCMD was set in flags.
WRDE_NOSPACE
Attempt to allocate memory failed.
WRDE_SYNTAX
Shell syntax error, such as unbalanced parentheses or unterminated string.
The  header shall define the size_t type as described in .
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
int  wordexp(const char *restrict, wordexp_t *restrict, int);
void wordfree(wordexp_t *);
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XSH wordexp()
CHANGE HISTORY
First released in Issue 4. Derived from the ISO POSIX-2 standard.
Issue 6
The restrict keyword is added to the prototype for wordexp().
The WRDE_NOSYS constant is marked obsolescent.
Issue 7
The obsolescent WRDE_NOSYS constant is removed.
This reference page is clarified with respect to macros and symbolic constants.
Issue 8
Austin Group Defect 1444 is applied, correcting cross-references to wordexp().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/syslog.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
syslog.h — definitions for system error logging
SYNOPSIS
[XSI]  #include
DESCRIPTION
The  header shall define the following symbolic constants, zero or more of which may be OR'ed together to
form the logopt option of openlog():
LOG_PID
Log the process ID with each message.
LOG_CONS
Log to the system console on error.
LOG_NDELAY
Connect to syslog daemon immediately.
LOG_ODELAY
Delay open until syslog() is called.
LOG_NOWAIT
Do not wait for child processes.
The  header shall define the following symbolic constants for use as the facility argument to
openlog():
LOG_KERN
Reserved for message generated by the system.
LOG_USER
Message generated by a process.
LOG_MAIL
Reserved for message generated by mail system.
LOG_NEWS
Reserved for message generated by news system.
LOG_UUCP
Reserved for message generated by UUCP system.
LOG_DAEMON
Reserved for message generated by system daemon.
LOG_AUTH
Reserved for message generated by authorization daemon.
LOG_CRON
Reserved for message generated by clock daemon.
LOG_LPR
Reserved for message generated by printer system.
LOG_LOCAL0
Reserved for local use.
LOG_LOCAL1
Reserved for local use.
LOG_LOCAL2
Reserved for local use.
LOG_LOCAL3
Reserved for local use.
LOG_LOCAL4
Reserved for local use.
LOG_LOCAL5
Reserved for local use.
LOG_LOCAL6
Reserved for local use.
LOG_LOCAL7
Reserved for local use.
The  header shall define the following macros for constructing the maskpri argument to setlogmask(). The following macros expand to an expression of type int when the
argument pri is an expression of type int:
LOG_MASK(pri)
A mask for priority pri.
LOG_UPTO(pri)
A mask for all priorities from LOG_EMERG through pri inclusive in the order listed in the list of priority symbolic
constants below. Any additional implementation-defined priorities not included in the list below shall not be included in the
mask.
The  header shall define the following symbolic constants for use as the severity level portion of the
priority argument of syslog() and the pri argument of the
LOG_MASK(pri) and LOG_UPTO(pri) macros:
LOG_EMERG
A panic condition was reported to all processes.
LOG_ALERT
A condition that should be corrected immediately.
LOG_CRIT
A critical condition.
LOG_ERR
An error message.
LOG_WARNING
A warning message.
LOG_NOTICE
A condition requiring special handling.
LOG_INFO
A general information message.
LOG_DEBUG
A message useful for debugging programs.
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
void  closelog(void);
void  openlog(const char *, int, int);
int   setlogmask(int);
void  syslog(int, const char *, ...);
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XSH closelog()
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/Open UNIX to BASE.
Issue 7
This reference page is clarified with respect to macros and symbolic constants.
Issue 8
Austin Group Defect 1033 is applied, adding the LOG_UPTO macro.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/pwd.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pwd.h — password structure
SYNOPSIS
#include
DESCRIPTION
The  header shall define the struct passwd, structure, which shall include at least the following
members:
char    *pw_name   User's login name.
uid_t    pw_uid    Numerical user ID.
gid_t    pw_gid    Numerical group ID.
char    *pw_dir    Initial working directory.
char    *pw_shell  Program to use as shell.
The  header shall define the gid_t, uid_t, and size_t types as described in .
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
[XSI]
void           endpwent(void);
struct passwd *getpwent(void);
struct passwd *getpwnam(const char *);
int            getpwnam_r(const char *, struct passwd *, char *,
size_t, struct passwd **);
struct passwd *getpwuid(uid_t);
int            getpwuid_r(uid_t, struct passwd *, char *,
size_t, struct passwd **);
[XSI]
void           setpwent(void);
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XSH endpwent(), getpwnam(),
getpwuid()
CHANGE HISTORY
First released in Issue 1.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Threads Extension.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The gid_t and uid_t types are mandated.
The getpwnam_r() and getpwuid_r() functions are marked as part of the Thread-Safe Functions option.
Issue 7
SD5-XBD-ERN-56 is applied, adding a reference to  for the
size_t type.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/fenv.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fenv.h — floating-point environment
SYNOPSIS
#include
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The  header shall define the following data types through typedef:
fenv_t
Represents the entire floating-point environment. The floating-point environment refers collectively to any floating-point
status flags and control modes supported by the implementation.
fexcept_t
Represents the floating-point status flags collectively, including any status the implementation associates with the flags. A
floating-point status flag is a system variable whose value is set (but never cleared) when a floating-point exception is raised,
which occurs as a side-effect of exceptional floating-point arithmetic to provide auxiliary information. A floating-point control
mode is a system variable whose value may be set by the user to affect the subsequent behavior of floating-point arithmetic.
The  header shall define each of the following macros if and only if the implementation supports the
floating-point exception by means of the floating-point functions feclearexcept(), fegetexceptflag(), feraiseexcept(), fesetexceptflag(), and fetestexcept(). The defined macros shall expand to integer constant expressions with
values that are bitwise-distinct.
FE_DIVBYZERO
FE_INEXACT
FE_INVALID
FE_OVERFLOW
FE_UNDERFLOW
[MX]  If
the implementation supports the IEC 60559 Floating-Point option, all five macros shall be defined.   Additional implementation-defined floating-point exceptions with macros beginning with FE_ and
an uppercase letter may also be specified by the implementation.
The  header shall define the macro FE_ALL_EXCEPT as the bitwise-inclusive OR of all floating-point
exception macros defined by the implementation, if any. If no such macros are defined, then the macro FE_ALL_EXCEPT shall be
defined as zero.
The  header shall define each of the following macros if and only if the implementation supports getting
and setting the represented rounding direction by means of the fegetround() and
fesetround() functions. The defined macros shall expand to integer constant
expressions whose values are distinct non-negative values.
FE_DOWNWARD
FE_TONEAREST
FE_TOWARDZERO
FE_UPWARD
[MX]  If
the implementation supports the IEC 60559 Floating-Point option, all four macros shall be defined.   Additional implementation-defined rounding directions with macros beginning with FE_ and an
uppercase letter may also be specified by the implementation.
The  header shall define the following macro, which represents the default floating-point environment (that
is, the one installed at program startup) and has type pointer to const-qualified fenv_t. It can be used as an argument to
the functions within the  header that manage the floating-point environment.
FE_DFL_ENV
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
int  feclearexcept(int);
int  fegetenv(fenv_t *);
int  fegetexceptflag(fexcept_t *, int);
int  fegetround(void);
int  feholdexcept(fenv_t *);
int  feraiseexcept(int);
int  fesetenv(const fenv_t *);
int  fesetexceptflag(const fexcept_t *, int);
int  fesetround(int);
int  fetestexcept(int);
int  feupdateenv(const fenv_t *);
The FENV_ACCESS pragma provides a means to inform the implementation when an application might access the floating-point
environment to test floating-point status flags or run under non-default floating-point control modes. The pragma shall occur
either outside external declarations or preceding all explicit declarations and statements inside a compound statement. When
outside external declarations, the pragma takes effect from its occurrence until another FENV_ACCESS pragma is encountered, or
until the end of the translation unit. When inside a compound statement, the pragma takes effect from its occurrence until another
FENV_ACCESS pragma is encountered (including within a nested compound statement), or until the end of the compound statement; at
the end of a compound statement the state for the pragma is restored to its condition just before the compound statement. If this
pragma is used in any other context, the behavior is undefined. If part of an application tests floating-point status flags, sets
floating-point control modes, or runs under non-default mode settings, but was translated with the state for the FENV_ACCESS pragma
off, the behavior is undefined. The default state (on or off) for the pragma is implementation-defined. (When execution passes from
a part of the application translated with FENV_ACCESS off to a part translated with FENV_ACCESS on, the state of the floating-point
status flags is unspecified and the floating-point control modes have their default settings.)
The following sections are informative.
APPLICATION USAGE
This header is designed to support the floating-point exception status flags and directed-rounding control modes required by the
IEC 60559:1989 standard, and other similar floating-point state information. Also it is designed to facilitate code
portability among all systems.
Certain application programming conventions support the intended model of use for the floating-point environment:
A function call does not alter its caller's floating-point control modes, clear its caller's floating-point status flags, nor
depend on the state of its caller's floating-point status flags unless the function is so documented.
A function call is assumed to require default floating-point control modes, unless its documentation promises otherwise.
A function call is assumed to have the potential for raising floating-point exceptions, unless its documentation promises
otherwise.
With these conventions, an application can safely assume default floating-point control modes (or be unaware of them). The
responsibilities associated with accessing the floating-point environment fall on the application that does so explicitly.
Even though the rounding direction macros may expand to constants corresponding to the values of FLT_ROUNDS, they are not
required to do so.
For example:
#include
void f(double x)
{
#pragma STDC FENV_ACCESS ON
void g(double);
void h(double);
/* ... */
g(x + 1);
h(x + 1);
/* ... */
}
If the function g() might depend on status flags set as a side-effect of the first x+1, or if the second
x+1 might depend on control modes set as a side-effect of the call to function g(), then the application shall
contain an appropriately placed invocation as follows:
#pragma STDC FENV_ACCESS ON
RATIONALE
The fexcept_t Type
fexcept_t does not have to be an integer type. Its values must be obtained by a call to fegetexceptflag(), and cannot be created by logical operations from the exception
macros. An implementation might simply implement fexcept_t as an int and use the representations reflected by the
exception macros, but is not required to; other representations might contain extra information about the exceptions.
fexcept_t might be a struct with a member for each exception (that might hold the address of the first or last
floating-point instruction that caused that exception). The ISO C standard makes no claims about the internals of an
fexcept_t, and so the user cannot inspect it.
Exception and Rounding Macros
Macros corresponding to unsupported modes and rounding directions are not defined by the implementation and must not be defined
by the application. An application might use #ifdef to test for this.
FUTURE DIRECTIONS
None.
SEE ALSO
XSH feclearexcept(), fegetenv(), fegetexceptflag(),
fegetround(), feholdexcept(), feraiseexcept()
, fetestexcept(), feupdateenv()
CHANGE HISTORY
First released in Issue 6. Included for alignment with the ISO/IEC 9899:1999 standard.
The return types for feclearexcept(), fegetexceptflag(), feraiseexcept(), fesetexceptflag(), fegetenv(),
fesetenv(), and feupdateenv()
are changed from void to int for alignment with the ISO/IEC 9899:1999 standard, Defect Report 202.
Issue 7
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #37 (SD5-XBD-ERN-49) is applied.
ISO/IEC 9899:1999 standard, Technical Corrigendum 3 #36 is applied.
SD5-XBD-ERN-48 and SD5-XBD-ERN-69 are applied.
This reference page is clarified with respect to macros and symbolic constants.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/math.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
math.h — mathematical declarations
SYNOPSIS
#include
DESCRIPTION
[CX]  Some of the functionality described on this reference page extends the ISO C standard. Applications shall define
the appropriate feature test macro (see XSH 2.2 The Compilation
Environment) to enable the visibility of these symbols in this header.
The  header shall define at least the following types:
float_t
A real-floating type at least as wide as float.
double_t
A real-floating type at least as wide as double, and at least as wide as float_t.
If FLT_EVAL_METHOD equals 0, float_t and double_t shall be float and double, respectively; if
FLT_EVAL_METHOD equals 1, they shall both be double; if FLT_EVAL_METHOD equals 2, they shall both be long double; for
other values of FLT_EVAL_METHOD, they are otherwise implementation-defined.
The  header shall define the following macros, where real-floating indicates that the argument shall be an
expression of real-floating type:
int fpclassify(real-floating x);
int isfinite(real-floating x);
int isgreater(real-floating x, real-floating y);
int isgreaterequal(real-floating x, real-floating y);
int isinf(real-floating x);
int isless(real-floating x, real-floating y);
int islessequal(real-floating x, real-floating y);
int islessgreater(real-floating x, real-floating y);
int isnan(real-floating x);
int isnormal(real-floating x);
int isunordered(real-floating x, real-floating y);
int signbit(real-floating x);
[XSI]
The  header shall define the following symbolic constants. Where the constant name ends in 'l' (lower
case ell), the values shall have type long double; otherwise the values shall have type double. The values shall be
accurate to the precision of their type. If the implementation supports FLT_EVAL_METHOD values other than 0 or 1, the values shall
either include an explicit cast for that type, or be expressed as hexadecimal floating constants.
Double
Long Double
Value
M_E
M_El
Value of \(e\)
M_EGAMMA
M_EGAMMAl
Value of \(\gamma\), Euler-Mascheroni constant
M_LOG2E
M_LOG2El
Value of \(\log _2 e\)
M_LOG10E
M_LOG10El
Value of \(log _{10} e\)
M_LN2
M_LN2l
Value of \(log _e 2\)
M_LN10
M_LN10l
Value of \(log _e 10\)
M_PHI
M_PHIl
Value of \(\phi,(1+\sqrt{5}) / 2\) golden ratio constant, golden ratio constant
M_PI
M_PIl
Value of \(\pi\)
M_PI_2
M_PI_2l
Value of \(\pi /2\)
M_PI_4
M_PI_4l
Value of \(\pi /4\)
M_1_PI
M_1_PIl
Value of \(1/ \pi\)
M_1_SQRTPI
M_1_SQRTPIl
Value of \(1/ \sqrt \pi\)
M_2_PI
M_2_PIl
Value of \(2/ \pi\)
M_2_SQRTPI
M_2_SQRTPIl
Value of \(2/ \sqrt \pi\)
M_SQRT2
M_SQRT2l
Value of \(\sqrt 2\)
M_SQRT3
M_SQRT3l
Value of \(\sqrt 3\)
M_SQRT1_2
M_SQRT1_2l
Value of \(1/ \sqrt 2\)
M_SQRT1_3
M_SQRT1_3l
Value of \(1/ \sqrt 3\)
The  header shall define the following macros:
HUGE_VAL
A positive double constant expression, not necessarily representable as a float. Used as an error value returned
by the mathematics library. HUGE_VAL evaluates to +infinity on systems supporting IEEE Std 754-1985.
HUGE_VALF
A positive float constant expression. Used as an error value returned by the mathematics library. HUGE_VALF evaluates to
+infinity on systems supporting IEEE Std 754-1985.
HUGE_VALL
A positive long double constant expression. Used as an error value returned by the mathematics library. HUGE_VALL
evaluates to +infinity on systems supporting IEEE Std 754-1985.
INFINITY
A constant expression of type float representing positive or unsigned infinity, if available; else a positive constant
of type float that overflows at translation time.
NAN
A constant expression of type float representing a quiet NaN. This macro is only defined if the implementation supports
quiet NaNs for the float type.
The following macros shall be defined for number classification. They represent the mutually-exclusive kinds of
floating-point values. They expand to integer constant expressions with distinct values. Additional implementation-defined
floating-point classifications, with macro definitions beginning with FP_ and an uppercase letter, may also be specified by the
implementation.
FP_INFINITE
FP_NAN
FP_NORMAL
FP_SUBNORMAL
FP_ZERO
The following optional macros indicate whether the fma() family of
functions are fast compared with direct code:
FP_FAST_FMA
FP_FAST_FMAF
FP_FAST_FMAL
If defined, the FP_FAST_FMA macro shall expand to the integer constant 1 and shall indicate that the fma() function generally executes about as fast as, or faster than, a multiply and an add of
double operands. If undefined, the speed of execution is unspecified. The other macros have the equivalent meaning for the
float and long double versions.
The following macros shall expand to integer constant expressions whose values are returned by ilogb(
x) if x is zero or NaN, respectively. The value of FP_ILOGB0 shall be either {INT_MIN} or - {INT_MAX}. The value of
FP_ILOGBNAN shall be either {INT_MAX} or {INT_MIN}.
FP_ILOGB0
FP_ILOGBNAN
The following macros shall expand to the integer constants 1 and 2, respectively;
MATH_ERRNO
MATH_ERREXCEPT
The following macro shall expand to an expression that has type int and the value MATH_ERRNO,
MATH_ERREXCEPT, or the bitwise-inclusive OR of both:
math_errhandling
The value of math_errhandling is constant for the duration of the program. It is unspecified whether
math_errhandling is a macro or an identifier with external linkage. If a macro definition is suppressed or a program defines an
identifier with the name math_errhandling , the behavior is undefined. If the expression (math_errhandling & MATH_ERREXCEPT)
can be non-zero, the implementation shall define the macros FE_DIVBYZERO, FE_INVALID, and FE_OVERFLOW in .
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be
provided.
double      acos(double);
float       acosf(float);
double      acosh(double);
float       acoshf(float);
long double acoshl(long double);
long double acosl(long double);
double      asin(double);
float       asinf(float);
double      asinh(double);
float       asinhf(float);
long double asinhl(long double);
long double asinl(long double);
double      atan(double);
double      atan2(double, double);
float       atan2f(float, float);
long double atan2l(long double, long double);
float       atanf(float);
double      atanh(double);
float       atanhf(float);
long double atanhl(long double);
long double atanl(long double);
double      cbrt(double);
float       cbrtf(float);
long double cbrtl(long double);
double      ceil(double);
float       ceilf(float);
long double ceill(long double);
double      copysign(double, double);
float       copysignf(float, float);
long double copysignl(long double, long double);
double      cos(double);
float       cosf(float);
double      cosh(double);
float       coshf(float);
long double coshl(long double);
long double cosl(long double);
double      erf(double);
double      erfc(double);
float       erfcf(float);
long double erfcl(long double);
float       erff(float);
long double erfl(long double);
double      exp(double);
double      exp2(double);
float       exp2f(float);
long double exp2l(long double);
float       expf(float);
long double expl(long double);
double      expm1(double);
float       expm1f(float);
long double expm1l(long double);
double      fabs(double);
float       fabsf(float);
long double fabsl(long double);
double      fdim(double, double);
float       fdimf(float, float);
long double fdiml(long double, long double);
double      floor(double);
float       floorf(float);
long double floorl(long double);
double      fma(double, double, double);
float       fmaf(float, float, float);
long double fmal(long double, long double, long double);
double      fmax(double, double);
float       fmaxf(float, float);
long double fmaxl(long double, long double);
double      fmin(double, double);
float       fminf(float, float);
long double fminl(long double, long double);
double      fmod(double, double);
float       fmodf(float, float);
long double fmodl(long double, long double);
double      frexp(double, int *);
float       frexpf(float, int *);
long double frexpl(long double, int *);
double      hypot(double, double);
float       hypotf(float, float);
long double hypotl(long double, long double);
int         ilogb(double);
int         ilogbf(float);
int         ilogbl(long double);
[XSI]
double      j0(double);
double      j1(double);
double      jn(int, double);
double      ldexp(double, int);
float       ldexpf(float, int);
long double ldexpl(long double, int);
double      lgamma(double);
float       lgammaf(float);
long double lgammal(long double);
long long   llrint(double);
long long   llrintf(float);
long long   llrintl(long double);
long long   llround(double);
long long   llroundf(float);
long long   llroundl(long double);
double      log(double);
double      log10(double);
float       log10f(float);
long double log10l(long double);
double      log1p(double);
float       log1pf(float);
long double log1pl(long double);
double      log2(double);
float       log2f(float);
long double log2l(long double);
double      logb(double);
float       logbf(float);
long double logbl(long double);
float       logf(float);
long double logl(long double);
long        lrint(double);
long        lrintf(float);
long        lrintl(long double);
long        lround(double);
long        lroundf(float);
long        lroundl(long double);
double      modf(double, double *);
float       modff(float, float *);
long double modfl(long double, long double *);
double      nan(const char *);
float       nanf(const char *);
long double nanl(const char *);
double      nearbyint(double);
float       nearbyintf(float);
long double nearbyintl(long double);
double      nextafter(double, double);
float       nextafterf(float, float);
long double nextafterl(long double, long double);
double      nexttoward(double, long double);
float       nexttowardf(float, long double);
long double nexttowardl(long double, long double);
double      pow(double, double);
float       powf(float, float);
long double powl(long double, long double);
double      remainder(double, double);
float       remainderf(float, float);
long double remainderl(long double, long double);
double      remquo(double, double, int *);
float       remquof(float, float, int *);
long double remquol(long double, long double, int *);
double      rint(double);
float       rintf(float);
long double rintl(long double);
double      round(double);
float       roundf(float);
long double roundl(long double);
double      scalbln(double, long);
float       scalblnf(float, long);
long double scalblnl(long double, long);
double      scalbn(double, int);
float       scalbnf(float, int);
long double scalbnl(long double, int);
double      sin(double);
float       sinf(float);
double      sinh(double);
float       sinhf(float);
long double sinhl(long double);
long double sinl(long double);
double      sqrt(double);
float       sqrtf(float);
long double sqrtl(long double);
double      tan(double);
float       tanf(float);
double      tanh(double);
float       tanhf(float);
long double tanhl(long double);
long double tanl(long double);
double      tgamma(double);
float       tgammaf(float);
long double tgammal(long double);
double      trunc(double);
float       truncf(float);
long double truncl(long double);
[XSI]
double      y0(double);
double      y1(double);
double      yn(int, double);
The following external variable shall be defined:
[XSI]
extern int signgam;
The behavior of each of the functions defined in  is specified in the System Interfaces volume
of POSIX.1-2024 for all representable values of its input arguments, except where stated otherwise. Each function shall execute as
if it were a single operation without generating any externally visible exceptional conditions.
The following sections are informative.
APPLICATION USAGE
The FP_CONTRACT pragma can be used to allow (if the state is on) or disallow (if the state is off) the implementation to
contract expressions. Each pragma can occur either outside external declarations or preceding all explicit declarations and
statements inside a compound statement. When outside external declarations, the pragma takes effect from its occurrence until
another FP_CONTRACT pragma is encountered, or until the end of the translation unit. When inside a compound statement, the pragma
takes effect from its occurrence until another FP_CONTRACT pragma is encountered (including within a nested compound statement), or
until the end of the compound statement; at the end of a compound statement the state for the pragma is restored to its condition
just before the compound statement. If this pragma is used in any other context, the behavior is undefined. The default state (on
or off) for the pragma is implementation-defined.
RATIONALE
Before the ISO/IEC 9899:1999 standard, the math library was defined only for the floating type double. All the names
formed by appending 'f' or 'l' to a name in  were reserved to allow for the definition of
float and long double libraries; and the ISO/IEC 9899:1999 standard provided for all three versions of math
functions.
The functions ecvt(), fcvt(), and gcvt() have been dropped from the ISO C standard since
their capability is available through sprintf().
The requirement for an explicit cast or representation via hexadecimal floating constants is to guarantee that even
when FLT_EVAL_METHOD is neither 0 nor 1, the expression (double)M_PI == M_PI will always hold true. Earlier versions of
this standard did not make this requirement, because they lacked the 'l' (lower case ell) versions of the constants and
were allowed to provide M_PI with long double precision depending on FLT_EVAL_METHOD.
FUTURE DIRECTIONS
None.
SEE ALSO
,
,
XSH 2.2 The Compilation Environment, acos, acosh, asin, asinh, atan, atan2, atanh, cbrt, ceil, copysign, cos, cosh, erf, erfc, exp, exp2, expm1, fabs, fdim, floor, fma, fmax, fmin, fmod, fpclassify, frexp, hypot, ilogb, isfinite, isgreater, isinf, isnan, isnormal, isunordered, j0, ldexp, lgamma, llrint, llround, log, log10, log1p, log2, logb, lrint, lround, modf, nan, nearbyint, nextafter, pow, remainder, remquo, rint, round, scalbln, signbit, sin, sinh, sqrt, tan, tanh, tgamma, trunc, y0
CHANGE HISTORY
First released in Issue 1.
Issue 6
This reference page is updated to align with the ISO/IEC 9899:1999 standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XBD/TC2/D6/21 is applied, making it clear that the meaning of
the FP_FAST_FMA macro is unspecified if the macro is undefined.
Issue 7
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #47 (SD5-XBD-ERN-52) is applied, clarifying the wording of the
FP_FAST_FMA macro.
The MAXFLOAT constant is marked obsolescent.
This reference page is clarified with respect to macros and symbolic constants.
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0063 [801] and XBD/TC2-2008/0064 [801] are applied.
Issue 8
Austin Group Defect 828 is applied, adding long double counterparts with names ending in 'l' to the
double constants whose names begin with "M_" , and changing the representation requirements for those
constants.
Austin Group Defect 1302 is applied, changing "provides" to "provided".
Austin Group Defect 1330 is applied, removing the obsolescent MAXFLOAT.
Austin Group Defect 1503 is applied, adding M_1_SQRTPI, M_EGAMMA, M_PHI, M_SQRT1_3, and M_SQRT3.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/ftw.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ftw.h — file tree traversal
SYNOPSIS
[XSI]  #include
DESCRIPTION
The  header shall define the FTW structure, which shall include at least the following members:
int  base
int  level
The  header shall define the following symbolic constants for use as values of the third argument to the
application-supplied function that is passed as the second argument to nftw():
FTW_F
Non-directory file.
FTW_D
Directory.
FTW_DNR
Directory without read permission.
FTW_DP
Directory with subdirectories visited.
FTW_NS
Unknown type; stat() failed.
FTW_SL
Symbolic link.
FTW_SLN
Symbolic link that names a nonexistent file.
The  header shall define the following symbolic constants for use as values of the fourth argument to
nftw():
FTW_PHYS
Physical walk, does not follow symbolic links. Otherwise, nftw() follows links but
does not walk down any path that crosses itself.
FTW_MOUNT
The walk only reports files that have the same device ID as the starting directory and does not descend below directories that
have a different device ID than the starting directory.
FTW_XDEV
The walk does not descend below directories that have a different device ID than the starting directory.
FTW_DEPTH
All subdirectories are visited before the directory itself.
FTW_CHDIR
The walk changes to each directory before reading it.
The following shall be declared as a function and may also be defined as a macro. A function prototype shall be provided.
int nftw(const char *, int (*)(const char *, const struct stat *,
int, struct FTW *), int, int);
The  header shall define the stat structure and the symbolic names for st_mode and the file
type test macros as described in .
Inclusion of the  header may also make visible all symbols from .
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XSH nftw()
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
A description of FTW_DP is added.
Issue 7
The ftw() function is marked obsolescent.
This reference page is clarified with respect to macros and symbolic constants.
POSIX.1-2008, Technical Corrigendum 1, XBD/TC1-2008/0048 [403] is applied.
Issue 8
Austin Group Defect 1133 is applied, adding FTW_XDEV.
Austin Group Defect 1210 is applied, changing the description of FTW_MOUNT.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/wchar.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wchar.h — wide-character handling
SYNOPSIS
#include
DESCRIPTION
[CX]  Some of the functionality described on this reference page extends the ISO C standard. Applications shall define
the appropriate feature test macro (see XSH 2.2 The Compilation
Environment) to enable the visibility of these symbols in this header.
The  header shall define the following types:
FILE
[CX]  As
described in .
locale_t
[CX]  As
described in .
mbstate_t
A complete object type other than an array type that can hold the conversion state information necessary to convert between
sequences of (possibly multi-byte) characters and wide characters. [CX]
If a codeset is being used such that an mbstate_t
needs to preserve more than two levels of reserved state, the results are unspecified.
size_t
As described in .
va_list
[CX]  As
described in .
wchar_t
As described in .
wint_t
An integer type capable of storing any valid value of wchar_t or WEOF.
The tag tm shall be declared as naming an incomplete structure type, the contents of which are described in the  header.
The implementation shall support one or more programming environments in which the width of wint_t is no greater than the
width of type long. The names of these programming environments can be obtained using the confstr() function or the getconf
utility.
The  header shall define the following macros:
WCHAR_MAX
As described in .
WCHAR_MIN
As described in .
WEOF
Constant expression of type wint_t that is returned by several WP functions to indicate end-of-file.
NULL
As described in .
[CX]
Inclusion of the  header may make visible all symbols from the headers , , , , , , and
.
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided for use
with ISO C standard compilers. Arguments to functions in this list can point to arrays containing wchar_t values that
do not correspond to members of the character set of the current locale. Such values shall be processed according to the specified
semantics, unless otherwise stated.
wint_t        btowc(int);
wint_t        fgetwc(FILE *);
wchar_t      *fgetws(wchar_t *restrict, int, FILE *restrict);
wint_t        fputwc(wchar_t, FILE *);
int           fputws(const wchar_t *restrict, FILE *restrict);
int           fwide(FILE *, int);
int           fwprintf(FILE *restrict, const wchar_t *restrict, ...);
int           fwscanf(FILE *restrict, const wchar_t *restrict, ...);
wint_t        getwc(FILE *);
wint_t        getwchar(void);
size_t        mbrlen(const char *restrict, size_t, mbstate_t *restrict);
size_t        mbrtowc(wchar_t *restrict, const char *restrict, size_t,
mbstate_t *restrict);
int           mbsinit(const mbstate_t *);
[CX]
size_t        mbsnrtowcs(wchar_t *restrict, const char **restrict,
size_t, size_t, mbstate_t *restrict);
size_t        mbsrtowcs(wchar_t *restrict, const char **restrict, size_t,
mbstate_t *restrict);
[CX]
FILE         *open_wmemstream(wchar_t **, size_t *);
wint_t        putwc(wchar_t, FILE *);
wint_t        putwchar(wchar_t);
int           swprintf(wchar_t *restrict, size_t,
const wchar_t *restrict, ...);
int           swscanf(const wchar_t *restrict,
const wchar_t *restrict, ...);
wint_t        ungetwc(wint_t, FILE *);
int           vfwprintf(FILE *restrict, const wchar_t *restrict, va_list);
int           vfwscanf(FILE *restrict, const wchar_t *restrict, va_list);
int           vswprintf(wchar_t *restrict, size_t,
const wchar_t *restrict, va_list);
int           vswscanf(const wchar_t *restrict, const wchar_t *restrict,
va_list);
int           vwprintf(const wchar_t *restrict, va_list);
int           vwscanf(const wchar_t *restrict, va_list);
[CX]
wchar_t      *wcpcpy(wchar_t *restrict, const wchar_t *restrict);
wchar_t      *wcpncpy(wchar_t *restrict, const wchar_t *restrict, size_t);
size_t        wcrtomb(char *restrict, wchar_t, mbstate_t *restrict);
[CX]
int           wcscasecmp(const wchar_t *, const wchar_t *);
int           wcscasecmp_l(const wchar_t *, const wchar_t *, locale_t);
wchar_t      *wcscat(wchar_t *restrict, const wchar_t *restrict);
wchar_t      *wcschr(const wchar_t *, wchar_t);
int           wcscmp(const wchar_t *, const wchar_t *);
int           wcscoll(const wchar_t *, const wchar_t *);
[CX]
int           wcscoll_l(const wchar_t *, const wchar_t *, locale_t);
wchar_t      *wcscpy(wchar_t *restrict, const wchar_t *restrict);
size_t        wcscspn(const wchar_t *, const wchar_t *);
[CX]
wchar_t      *wcsdup(const wchar_t *);
size_t        wcsftime(wchar_t *restrict, size_t,
const wchar_t *restrict, const struct tm *restrict);
[CX]
size_t        wcslcat(wchar_t *restrict, const wchar_t *restrict,
size_t);
size_t        wcslcpy(wchar_t *restrict, const wchar_t *restrict,
size_t);
size_t        wcslen(const wchar_t *);
[CX]
int           wcsncasecmp(const wchar_t *, const wchar_t *, size_t);
int           wcsncasecmp_l(const wchar_t *, const wchar_t *, size_t,
locale_t);
wchar_t      *wcsncat(wchar_t *restrict, const wchar_t *restrict, size_t);
int           wcsncmp(const wchar_t *, const wchar_t *, size_t);
wchar_t      *wcsncpy(wchar_t *restrict, const wchar_t *restrict, size_t);
[CX]
size_t        wcsnlen(const wchar_t *, size_t);
size_t        wcsnrtombs(char *restrict, const wchar_t **restrict, size_t,
size_t, mbstate_t *restrict);
wchar_t      *wcspbrk(const wchar_t *, const wchar_t *);
wchar_t      *wcsrchr(const wchar_t *, wchar_t);
size_t        wcsrtombs(char *restrict, const wchar_t **restrict,
size_t, mbstate_t *restrict);
size_t        wcsspn(const wchar_t *, const wchar_t *);
wchar_t      *wcsstr(const wchar_t *restrict, const wchar_t *restrict);
double        wcstod(const wchar_t *restrict, wchar_t **restrict);
float         wcstof(const wchar_t *restrict, wchar_t **restrict);
wchar_t      *wcstok(wchar_t *restrict, const wchar_t *restrict,
wchar_t **restrict);
long          wcstol(const wchar_t *restrict, wchar_t **restrict, int);
long double   wcstold(const wchar_t *restrict, wchar_t **restrict);
long long     wcstoll(const wchar_t *restrict, wchar_t **restrict, int);
unsigned long wcstoul(const wchar_t *restrict, wchar_t **restrict, int);
unsigned long long
wcstoull(const wchar_t *restrict, wchar_t **restrict, int);
[XSI]
int           wcswidth(const wchar_t *, size_t);
size_t        wcsxfrm(wchar_t *restrict, const wchar_t *restrict, size_t);
[CX]
size_t        wcsxfrm_l(wchar_t *restrict, const wchar_t *restrict,
size_t, locale_t);
int           wctob(wint_t);
[XSI]
int           wcwidth(wchar_t);
wchar_t      *wmemchr(const wchar_t *, wchar_t, size_t);
int           wmemcmp(const wchar_t *, const wchar_t *, size_t);
wchar_t      *wmemcpy(wchar_t *restrict, const wchar_t *restrict, size_t);
wchar_t      *wmemmove(wchar_t *, const wchar_t *, size_t);
wchar_t      *wmemset(wchar_t *, wchar_t, size_t);
int           wprintf(const wchar_t *restrict, ...);
int           wscanf(const wchar_t *restrict, ...);
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
,
, ,
, , ,
, ,
,
XSH 2.2 The Compilation Environment, btowc(), confstr(), fgetwc(), fgetws(), fputwc(), fputws(), fwide(), fwprintf(), fwscanf(), getwc(), getwchar(), iswalnum(), iswalpha(), iswcntrl(), iswctype(), iswdigit(), iswgraph(), iswlower(), iswprint(), iswpunct(), iswspace(), iswupper(), iswxdigit(), mbrlen(), mbrtowc(), mbsinit(), mbsrtowcs(), open_memstream(),
putwc(), putwchar(), towlower(), towupper(), ungetwc(), vfwprintf(), vfwscanf(), wcrtomb(), wcscasecmp(), wcscat(), wcschr(), wcscmp(), wcscoll(), wcscpy(), wcscspn(), wcsdup(), wcsftime(), wcslcat(), wcslen(), wcsncat(), wcsncmp(), wcsncpy(), wcspbrk(), wcsrchr(), wcsrtombs(), wcsspn(), wcsstr(), wcstod(), wcstok(), wcstol(), wcstoul(), wcswidth(), wcsxfrm(), wctob(), wctype(), wcwidth(), wmemchr(), wmemcmp(), wmemcpy(), wmemmove(), wmemset()
XCU getconf
CHANGE HISTORY
First released in Issue 4.
Issue 5
Aligned with the ISO/IEC 9899:1990/Amendment 1:1995 (E).
Issue 6
The Open Group Corrigendum U021/10 is applied. The prototypes for wcswidth() and
wcwidth() are marked as extensions.
The Open Group Corrigendum U028/5 is applied, correcting the prototype for the mbsinit() function.
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
Various function prototypes are updated to add the restrict keyword.
The functions vfwscanf(), vswscanf(), wcstof(), wcstold(), wcstoll(), and wcstoull() are added.
The type wctype_t, the isw*(), to*(), and wctype() functions
are marked as XSI extensions.
IEEE Std 1003.1-2001/Cor 1-2002, item XBD/TC1/D6/26 is applied, adding the APPLICATION USAGE section.
Issue 7
The mbsnrtowcs(), open_wmemstream(), wcpcpy(), wcpncpy(), wcscasecmp(), wcsdup(), wcsncasecmp(), wcsnlen(), and wcsnrtombs() functions are
added from The Open Group Technical Standard, 2006, Extended API Set Part 1.
The wcscasecmp_l(), wcsncasecmp_l(), wcscoll_l(), and
wcsxfrm_l() functions are added from The Open Group Technical Standard, 2006,
Extended API Set Part 4.
The wctype_t type, and the isw*(), towlower(), and towupper() functions are marked obsolescent in  since the ISO C
standard requires the declarations to be in .
This reference page is clarified with respect to macros and symbolic constants, and a declaration for the locale_t type
is added.
POSIX.1-2008, Technical Corrigendum 1, XBD/TC1-2008/0081 [380] is applied.
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0088 [73] is applied.
Issue 8
Austin Group Defect 986 is applied, adding wcslcat() and wcslcpy().
Austin Group Defect 1302 is applied, aligning this header with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
Austin Group Defect 1352 is applied, changing the APPLICATION USAGE and RATIONALE sections.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/sys_msg.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sys/msg.h — XSI message queue structures
SYNOPSIS
[XSI]  #include
DESCRIPTION
The  header shall define the following data types through typedef:
msgqnum_t
Used for the number of messages in the message queue.
msglen_t
Used for the number of bytes allowed in a message queue.
These types shall be unsigned integer types that are able to store values at least as large as a type unsigned short.
The  header shall define the following symbolic constant as a message operation flag:
MSG_NOERROR
No error if big message.
The  header shall define the msqid_ds structure, which shall include the following members:
struct ipc_perm msg_perm   Operation permission structure.
msgqnum_t       msg_qnum   Number of messages currently on queue.
msglen_t        msg_qbytes Maximum number of bytes allowed on queue.
pid_t           msg_lspid  Process ID of last msgsnd().
pid_t           msg_lrpid  Process ID of last msgrcv().
time_t          msg_stime  Time of last msgsnd().
time_t          msg_rtime  Time of last msgrcv().
time_t          msg_ctime  Time of last change.
The  header shall define the pid_t, size_t, ssize_t, and time_t types as
described in .
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
int       msgctl(int, int, struct msqid_ds *);
int       msgget(key_t, int);
ssize_t   msgrcv(int, void *, size_t, long, int);
int       msgsnd(int, const void *, size_t, int);
In addition, the  header shall include the  header.
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
,
XSH msgctl(), msgget(), msgrcv(), msgsnd()
CHANGE HISTORY
First released in Issue 2. Derived from System V Release 2.0.
Issue 7
Austin Group Interpretation 1003.1-2001 #179 is applied.
This reference page is clarified with respect to macros and symbolic constants.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/threads.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
threads.h — ISO C threads
SYNOPSIS
#include
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
Implementations shall not define the macro __STDC_NO_THREADS__, except for profile implementations that define _POSIX_SUBPROFILE
(see 2.1.5.1 Subprofiling Considerations) in , which may define __STDC_NO_THREADS__ and, if they do so, need not provide
this header nor support any of its facilities.
The  header shall define the following macros:
thread_local
Expands to _Thread_local.
ONCE_FLAG_INIT
Expands to a value that can be used to initialize an object of type once_flag.
TSS_DTOR_ITERATIONS
Expands to an integer constant expression representing the maximum number of times that destructors will be called when a thread
terminates and shall be suitable for use in #if preprocessing directives.
[CX]  If
{PTHREAD_DESTRUCTOR_ITERATIONS} is defined in , the value of
TSS_DTOR_ITERATIONS shall be equal to {PTHREAD_DESTRUCTOR_ITERATIONS}; otherwise, the value of TSS_DTOR_ITERATIONS shall be greater
than or equal to the value of {_POSIX_THREAD_DESTRUCTOR_ITERATIONS} and shall be less than or equal to the maximum positive value
that can be returned by a call to sysconf(_SC_THREAD_DESTRUCTOR_ITERATIONS) in any process.
The  header shall define the types cnd_t, mtx_t, once_flag, thrd_t, and
tss_t as complete object types, the type thrd_start_t as the function pointer type int (*)(void*), and the
type tss_dtor_t as the function pointer type void (*)(void*). [CX]  The type
thrd_t shall be defined to be the same type that pthread_t is defined to be in .
The  header shall define the enumeration constants mtx_plain, mtx_recursive,
mtx_timed, thrd_busy, thrd_error, thrd_nomem, thrd_success and
thrd_timedout.
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
void            call_once(once_flag *, void (*)(void));
int             cnd_broadcast(cnd_t *);
void            cnd_destroy(cnd_t *);
int             cnd_init(cnd_t *);
int             cnd_signal(cnd_t *);
int             cnd_timedwait(cnd_t * restrict, mtx_t * restrict,
const struct timespec * restrict);
int             cnd_wait(cnd_t *, mtx_t *);
void            mtx_destroy(mtx_t *);
int             mtx_init(mtx_t *, int);
int             mtx_lock(mtx_t *);
int             mtx_timedlock(mtx_t * restrict,
const struct timespec * restrict);
int             mtx_trylock(mtx_t *);
int             mtx_unlock(mtx_t *);
int             thrd_create(thrd_t *, thrd_start_t, void *);
thrd_t          thrd_current(void);
int             thrd_detach(thrd_t);
int             thrd_equal(thrd_t, thrd_t);
_Noreturn void  thrd_exit(int);
int             thrd_join(thrd_t, int *);
int             thrd_sleep(const struct timespec *, struct timespec *);
void            thrd_yield(void);
int             tss_create(tss_t *, tss_dtor_t);
void            tss_delete(tss_t);
void           *tss_get(tss_t);
int             tss_set(tss_t, void *);
Inclusion of the  header shall make symbols defined in the header  visible.
The following sections are informative.
APPLICATION USAGE
The  header is optional in the ISO C standard but is mandated by POSIX.1-2024. Note however that
subprofiles can choose to make this header optional (see 2.1.5.1
Subprofiling Considerations), and therefore application portability to subprofile implementations would benefit from
checking whether __STDC_NO_THREADS__ is defined before inclusion of .
The features provided by  are not as extensive as those provided by . It is present on POSIX.1 implementations in order to facilitate porting
of ISO C programs that use it. It is recommended that applications intended for use on POSIX.1 implementations use  rather than  even if none of the additional
features are needed initially, to save the need to convert should the need to use them arise later in the application's
lifecycle.
RATIONALE
Although the  header is optional in the ISO C standard, it is mandated by POSIX.1-2024 because  is mandatory and the interfaces in  can easily be
implemented as a thin wrapper for interfaces in .
The type thrd_t is required to be defined as the same type that pthread_t is defined to be in  because thrd_current() and pthread_self()
need to return the same thread ID when called from the initial thread. However, these types are not fully interchangeable (that is,
it is not always possible to pass a thread ID obtained as a thrd_t to a function that takes a pthread_t, and vice
versa) because threads created using thrd_create() have a different exit status
than pthreads threads, which is reflected in differences between the prototypes for thrd_create() and pthread_create(), thrd_exit() and
pthread_exit(), and thrd_join() and pthread_join(); also,
thrd_join() has no way to indicate that a thread was cancelled.
The standard developers considered making it implementation-defined whether the types cnd_t, mtx_t and
tss_t are interchangeable with the corresponding types pthread_cond_t, pthread_mutex_t and
pthread_key_t defined in  (that is, whether any function
that can be called with a valid cnd_t can also be called with a valid pthread_cond_t, and vice versa, and likewise
for the other types). However, this would have meant extending mtx_lock() to
provide a way for it to indicate that the owner of a mutex has terminated (equivalent to [EOWNERDEAD]). It was felt that such an
extension would be invention. Although there was no similar concern for cnd_t and tss_t, they were treated the same
way as mtx_t for consistency. See also the RATIONALE for mtx_lock()
concerning the inability of mtx_t to contain information about whether or not a mutex supports timeout if it is the same
type as pthread_mutex_t.
FUTURE DIRECTIONS
None.
SEE ALSO
, ,
XSH 2.9 Threads, call_once(), cnd_broadcast(),
cnd_destroy(), cnd_timedwait(), mtx_destroy(),
mtx_lock(), sysconf(), thrd_create(), thrd_current(),
thrd_detach(), thrd_equal()
, thrd_exit(), thrd_join(),
thrd_sleep(), thrd_yield(),
tss_create(), tss_delete(),
tss_get()
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/V1_chap10.html =====
Directory Structure and Devices
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
10. Directory Structure and Devices
10.1 Directory Structure and Files
The following directories shall exist on conforming systems and conforming applications shall make use of them only as
described. Strictly conforming applications shall not assume the ability to create files in any of these directories, unless
specified below.
/
The root directory.
/dev
Contains /dev/console, /dev/null, and /dev/tty, described below.
The following directory shall exist on conforming systems and shall be used as described:
/tmp
A directory made available for applications that need a place to create temporary files. Applications shall be allowed to
create files in this directory, but shall not assume that such files are preserved between invocations of the application.
The following files shall exist on conforming systems and shall be both readable and writable:
/dev/null
An empty data source and infinite data sink. Data written to /dev/null shall be discarded. Reads from /dev/null
shall always return end-of-file (EOF).
/dev/tty
In each process, a synonym for the controlling terminal associated with the process group of that process, if any. It is useful
for programs or shell procedures that wish to be sure of writing messages to or reading data from the terminal no matter how output
has been redirected. It can also be used for applications that demand the name of a file for output, when typed output is desired
and it is tiresome to find out what terminal is currently in use.
The following file shall exist on conforming systems and need not be readable or writable:
/dev/console
The /dev/console file is a generic name given to the system console (see 3.376 System Console). It is usually linked to an implementation-defined
special file. It shall provide an interface to the system console conforming to the requirements of 11. General Terminal Interface.
10.2 Output Devices and Terminal Types
The utilities in the Shell and Utilities volume of POSIX.1-2024 historically have been implemented on a wide range of terminal
types, but a conforming implementation need not support all features of all utilities on every conceivable terminal. POSIX.1-2024
states which features are optional for certain classes of terminals in the individual utility description sections. The
implementation shall document in the system documentation which terminal types it supports and which of these features and
utilities are not supported by each terminal.
When a feature or utility is not supported on a specific terminal type, as allowed by POSIX.1-2024, and the implementation
considers such a condition to be an error preventing use of the feature or utility, the implementation shall indicate such
conditions through diagnostic messages or exit status values or both (as appropriate to the specific utility description) that
inform the user that the terminal type lacks the appropriate capability.
POSIX.1-2024 uses a notational convention based on historical practice that identifies some of the control characters defined in
7.3.1 LC_CTYPE in a manner easily remembered by users on many
terminals. The correspondence between this "-char" notation and the actual control characters is shown in
the following table. When POSIX.1-2024 refers to a character by its -name, it is referring to the actual
control character shown in the Value column of the table, which is not necessarily the exact control key sequence on all terminals.
Some terminals have keyboards that do not allow the direct transmission of all the non-alphanumeric characters shown. In such
cases, the system documentation shall describe which data sequences transmitted by the terminal are interpreted by the system as
representing the special characters.
Table: Control Character Names
Name
Value
Name
Value
-A
-Q
-B
-R
-C
-S
-D
-T
-E
-U
-F
-V
-G
-W
-H
-X
-I
-Y
-J
-Z
-K
-[
-L
-\
-M
-]
-N
-^
-O
-_
-P
-?
Note:
The notation uses uppercase letters for arbitrary editorial reasons. There is no implication that the keystrokes represent
control-shift-letter sequences.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/V1_chap06.html =====
Character Set
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
6. Character Set
6.1 Portable Character Set
Conforming implementations shall support one or more coded character sets. Each supported locale shall include the portable
character set, which is the set of symbolic names for characters in Portable Character Set. This is
used to describe characters within the text of POSIX.1-2024. The first eight entries in Portable Character
Set and all characters in Non-Portable Control Characters are defined in the ISO/IEC 6429:1992
standard. The rest of the characters in Portable Character Set are defined in the
ISO/IEC 10646-1:2020 standard.
Table: Portable Character Set
Symbolic Name(s)
Glyph
UCS
Description
NULL (NUL)
,
BELL
,
BACKSPACE
,
CHARACTER TABULATION
,
LINE FEED (LF)
,
LINE TABULATION
,
FORM FEED (FF)
,
CARRIAGE RETURN (CR)
SPACE
!
EXCLAMATION MARK
"
QUOTATION MARK
#
NUMBER SIGN
$
DOLLAR SIGN
%
PERCENT SIGN
&
AMPERSAND
'
APOSTROPHE
(
LEFT PARENTHESIS
)
RIGHT PARENTHESIS
*
ASTERISK
+
PLUS SIGN
,
COMMA
,
-
HYPHEN-MINUS
,
.
FULL STOP
,
/
SOLIDUS
0
DIGIT ZERO
1
DIGIT ONE
2
DIGIT TWO
3
DIGIT THREE
4
DIGIT FOUR
5
DIGIT FIVE
6
DIGIT SIX
7
DIGIT SEVEN
8
DIGIT EIGHT
9
DIGIT NINE
:
COLON
;
SEMICOLON
LESS-THAN SIGN
=
EQUALS SIGN
>
GREATER-THAN SIGN
?
QUESTION MARK
@
COMMERCIAL AT
A
LATIN CAPITAL LETTER A
B
LATIN CAPITAL LETTER B
C
LATIN CAPITAL LETTER C
D
LATIN CAPITAL LETTER D
E
LATIN CAPITAL LETTER E
F
LATIN CAPITAL LETTER F
G
LATIN CAPITAL LETTER G
H
LATIN CAPITAL LETTER H
I
LATIN CAPITAL LETTER I
J
LATIN CAPITAL LETTER J
K
LATIN CAPITAL LETTER K
L
LATIN CAPITAL LETTER L
M
LATIN CAPITAL LETTER M
N
LATIN CAPITAL LETTER N
O
LATIN CAPITAL LETTER O
P
LATIN CAPITAL LETTER P
Q
LATIN CAPITAL LETTER Q
R
LATIN CAPITAL LETTER R
S
LATIN CAPITAL LETTER S
T
LATIN CAPITAL LETTER T
U
LATIN CAPITAL LETTER U
V
LATIN CAPITAL LETTER V
W
LATIN CAPITAL LETTER W
X
LATIN CAPITAL LETTER X
Y
LATIN CAPITAL LETTER Y
Z
LATIN CAPITAL LETTER Z
[
LEFT SQUARE BRACKET
,
\
REVERSE SOLIDUS
]
RIGHT SQUARE BRACKET
,
^
CIRCUMFLEX ACCENT
,
_
LOW LINE
`
GRAVE ACCENT
a
LATIN SMALL LETTER A
b
LATIN SMALL LETTER B
c
LATIN SMALL LETTER C
d
LATIN SMALL LETTER D
e
LATIN SMALL LETTER E
f
LATIN SMALL LETTER F
g
LATIN SMALL LETTER G
h
LATIN SMALL LETTER H
i
LATIN SMALL LETTER I
j
LATIN SMALL LETTER J
k
LATIN SMALL LETTER K
l
LATIN SMALL LETTER L
m
LATIN SMALL LETTER M
n
LATIN SMALL LETTER N
o
LATIN SMALL LETTER O
p
LATIN SMALL LETTER P
q
LATIN SMALL LETTER Q
r
LATIN SMALL LETTER R
s
LATIN SMALL LETTER S
t
LATIN SMALL LETTER T
u
LATIN SMALL LETTER U
v
LATIN SMALL LETTER V
w
LATIN SMALL LETTER W
x
LATIN SMALL LETTER X
y
LATIN SMALL LETTER Y
z
LATIN SMALL LETTER Z
,
{
LEFT CURLY BRACKET
|
VERTICAL LINE
,
}
RIGHT CURLY BRACKET
~
TILDE
POSIX.1-2024 uses character names other than the above, but only in an informative way; for example, in examples to
illustrate the use of characters beyond the portable character set with the facilities of POSIX.1-2024.
Portable Character Set defines the characters in the portable character set and the
corresponding symbolic character names used to identify each character in a character set description file. Characters defined in
Non-Portable Control Characters may also be used in character set description files.
POSIX.1-2024 places only the following requirements on the encoded values of the characters in the portable
character set:
If the encoded values associated with each member of the portable character set are not invariant across all
locales supported by the implementation, if an application uses any pair of locales where the character encodings differ, or
accesses data from an application using a locale which has different encodings from the locales used by the application, the
results are unspecified.
The encoded values associated with the digits 0 to 9 shall be such that the value of each character after 0 shall
be one greater than the value of the previous character.
A null character, NUL, which has all bits set to zero, shall be in the set of characters.
The encoded values associated with , , , and
shall be invariant across all locales supported by the implementation.
The encoded values associated with the members of the portable character set are each represented in a single
byte. Moreover, if the value is stored in an object of C-language type char, it is guaranteed to be positive (except the
NUL, which is always zero).
Conforming implementations shall support certain character and character set attributes, as defined in 7.2 POSIX Locale.
6.2 Character Encoding
The POSIX locale shall contain 256 single-byte characters including the characters in Portable
Character Set and Non-Portable Control Characters, which have the properties listed in 7.3.1 LC_CTYPE. It is unspecified whether characters not listed in those two
tables are classified as punct or cntrl, or neither. Other locales shall contain the characters in Portable Character Set and may contain any or all of the control characters identified in Non-Portable Control Characters; the presence, meaning, and representation of any additional characters are
locale-specific.
In locales other than the POSIX locale, a character may have a state-dependent encoding. There are two types of
these encodings:
A single-shift encoding (where each character not in the initial shift state is preceded by a shift code) can be
defined if each shift-code and character sequence is considered a multi-byte character. This is done using the
concatenated-constant format in a character set description file, as described in 6.4 Character Set
Description File. If the implementation supports a character encoding of this type, all of the standard utilities in the Shell
and Utilities volume of POSIX.1-2024 shall support it. Use of a single-shift encoding with any of the functions in the System
Interfaces volume of POSIX.1-2024 that do not specifically mention the effects of state-dependent encoding is
implementation-defined.
A locking-shift encoding (where the state of the character is determined by a shift code that may affect more than
the single character following it) cannot be defined with the current character set description file format. Use of a locking-shift
encoding with any of the standard utilities in the Shell and Utilities volume of POSIX.1-2024 or with any of the functions in the
System Interfaces volume of POSIX.1-2024 that do not specifically mention the effects of state-dependent encoding is
implementation-defined.
While in the initial shift state, all characters in the portable character set shall retain their usual
interpretation and shall not alter the shift state. The interpretation for subsequent bytes in the sequence shall be a function of
the current shift state. A byte with all bits zero shall be interpreted as the null character independent of shift state. Such a
byte shall not occur as part of any other character. Likewise, the byte values used to encode , ,
, and  shall not occur as part of any other character in any locale.
The maximum allowable number of bytes in a character in the current locale shall be indicated by {MB_CUR_MAX},
defined in the  header and by the  value in
a character set description file; see 6.4 Character Set Description File. The implementation's maximum
number of bytes in a character shall be defined by the C-language macro {MB_LEN_MAX}.
6.3 C Language Wide-Character Codes
In the shell, the standard utilities are written so that the encodings of characters are described by the locale's
LC_CTYPE definition (see 7.3.1 LC_CTYPE) and there is no
differentiation between characters consisting of single octets (8-bit bytes) or multiple bytes. However, in the C language, a
differentiation is made. To ease the handling of variable length characters, the C language has introduced the concept of
wide-character codes.
All wide-character codes in a given process consist of an equal number of bits. This is in contrast to characters,
which can consist of a variable number of bytes. The byte or byte sequence that represents a character can also be represented as a
wide-character code. Wide-character codes thus provide a uniform size for manipulating text data. A wide-character code having all
bits zero is the null wide-character code (see 3.233 Null Wide-Character
Code), and terminates wide-character strings (see 3.417 Wide-Character
Code (C Language)). The wide-character value for each member of the portable character set shall equal its value when used
as the lone character in an integer character constant. Wide-character codes for other characters are locale and
implementation-defined. State shift bytes shall not have a wide-character code representation. POSIX.1-2024 provides no means of
defining a wide-character codeset.
Arguments to the functions declared in the  header can
point to arrays containing wchar_t values that do not correspond to valid wide character codes according to the
LC_CTYPE category of the locale being used. Such values shall be processed according to the specified semantics for the
function in the System Interfaces volume of POSIX.1-2024, except that it is unspecified whether an encoding error occurs if such a
value appears in the format string of a function that has a format string as a parameter and the specified semantics do not require
that value to be processed as if by wcrtomb().
6.4 Character Set Description File
Implementations shall provide a character set description file for at least one coded character set supported by
the implementation. These files are referred to elsewhere in POSIX.1-2024 as charmap files. It is implementation-defined
whether or not users or applications can provide additional character set description files.
POSIX.1-2024 does not require that multiple character sets or codesets be supported. Although multiple charmap
files are supported, it is the responsibility of the implementation to provide the file or files; if only one is provided, only
that one is accessible using the localedef utility's -f option.
Each character set description file, except those that use the ISO/IEC 10646-1:2020 standard position values
as the encoding values, shall define characteristics for the coded character set and the encoding for the characters specified in
Portable Character Set, and may define encoding for additional characters supported by the
implementation. Other information about the coded character set may also be in the file. Coded character set character values shall
be defined using symbolic character names followed by character encoding values.
Each symbolic name specified in Portable Character Set shall be included in the file. Each
character in Portable Character Set (each row in the table) shall be mapped to a unique coding value. For
each character in Non-Portable Control Characters that exists in the character set described by the file,
the character's symbolic name(s) from Non-Portable Control Characters and the character's single-byte
encoding value shall be included in the file.
Table: Non-Portable Control Characters
Symbolic Name(s)
UCS
Description
START OF HEADING
START OF TEXT
END OF TEXT
END OF TRANSMISSION
ENQUIRY
ACKNOWLEDGE
SHIFT OUT
SHIFT IN
DATA LINK ESCAPE
DEVICE CONTROL ONE
DEVICE CONTROL TWO
DEVICE CONTROL THREE
DEVICE CONTROL FOUR
NEGATIVE ACKNOWLEDGE
SYNCHRONOUS IDLE
END OF TRANSMISSION BLOCK
CANCEL
END OF MEDIUM
SUBSTITUTE
ESCAPE
,
INFORMATION SEPARATOR FOUR
,
INFORMATION SEPARATOR THREE
,
INFORMATION SEPARATOR TWO
,
INFORMATION SEPARATOR ONE
DELETE
The following declarations can precede the character definitions. Each shall consist of the symbol shown in the
following list, starting in column 1, including the surrounding brackets, followed by one or more  characters,
followed by the value to be assigned to the symbol.
The name of the coded character set for which the character set description file is defined. The characters of the name shall
be taken from the set of characters with visible glyphs defined in Portable Character Set.
The maximum number of bytes in a multi-byte character. This shall default to 1.
An unsigned positive integer value that defines the minimum number of bytes in a character for the encoded character set.
[XSI]
On XSI-conformant systems,  shall always be 1.
The character used to indicate that the characters following shall be interpreted in a special way, as defined later in this
section. This shall default to  ('\\'), which is the character used in all the following text and
examples, unless otherwise noted.
The character that, when placed in column 1 of a charmap line, is used to indicate that the line shall be ignored. The default
character shall be the  ('#').
The character set mapping definitions shall be all the lines immediately following an identifier line containing
the string "CHARMAP" starting in column 1, and preceding a trailer line containing the string "END CHARMAP"
starting in column 1. Empty lines and lines containing a  in the first column shall be ignored. Each
non-comment line of the character set mapping definition (that is, between the "CHARMAP" and "END CHARMAP" lines
of the file) shall be in either of two forms:
"%s %s %s\n", , ,
or:
"%s...%s %s %s\n", , ,
,
In the first format, the line in the character set mapping definition shall define a single symbolic name and a
corresponding encoding. A symbolic name is one or more characters from the set shown with visible glyphs in Portable Character Set, enclosed between angle brackets. A character following an escape character is interpreted
as itself; for example, the sequence ">" represents the symbolic name "\>" enclosed between
angle brackets.
In the second format, the line in the character set mapping definition shall define a range of one or more symbolic
names. In this form, the symbolic names shall consist of zero or more non-numeric characters from the set shown with visible glyphs
in Portable Character Set, followed by an integer formed by one or more decimal digits. Both integers
shall contain the same number of digits. The characters preceding the integer shall be identical in the two symbolic names, and the
integer formed by the digits in the second symbolic name shall be equal to or greater than the integer formed by the digits in the
first name. This shall be interpreted as a series of symbolic names formed from the common part and each of the integers between
the first and the second integer, inclusive. As an example, ... is interpreted as the symbolic names
, , , and , in that order.
A character set mapping definition line shall exist for all symbolic names specified in Portable Character Set, and shall define the coded character value that corresponds to the character indicated in
the table, or the coded character value that corresponds to the control character symbolic name. If the control characters commonly
associated with the symbolic names in Non-Portable Control Characters are supported by the implementation,
the symbolic name and the corresponding encoding value shall be included in the file. Additional unique symbolic names may be
included. A coded character value can be represented by more than one symbolic name.
The encoding part is expressed as one (for single-byte character values) or more concatenated decimal, octal, or
hexadecimal constants in the following formats:
"%cd%u", ,
"%cx%x", ,
"%c%o", ,
Decimal constants shall be represented by two or three decimal digits, preceded by the escape character and the
lowercase letter 'd'; for example, "\d05", "\d97", or "\d143". Hexadecimal constants shall be
represented by two hexadecimal digits, preceded by the escape character and the lowercase letter 'x'; for example,
"\x05", "\x61", or "\x8f". Octal constants shall be represented by two or three octal digits, preceded
by the escape character; for example, "\05", "\141", or "\217". In a portable charmap file, each
constant represents an 8-bit byte. When constants are concatenated for multi-byte character values, they shall be of the same type,
and interpreted in sequence from from first to last with the first byte of the multi-byte character specified by the first byte in
the sequence. The manner in which these constants are represented in the character stored in the system is implementation-defined.
(This notation was chosen for reasons of portability. There is no requirement that the internal representation in the computer
memory be in this same order.) Omitting bytes from a multi-byte character definition produces undefined results.
In lines defining ranges of symbolic names, the encoded value shall be the value for the first symbolic name in the
range (the symbolic name preceding the ellipsis). Subsequent symbolic names defined by the range shall have encoding values in
increasing order. Bytes shall be treated as unsigned octets, and carry shall be propagated between the bytes as necessary to
represent the range. However, because this causes a null byte in the second or subsequent bytes of a character, such a declaration
should not be specified. For example, the line:
...  \d129\d254
is interpreted as:
\d129\d254
\d129\d255
\d130\d00
\d130\d01
The expanded declaration of the symbol  in the above example is an invalid specification, because it
contains a null byte in the second byte of a character.
The comment is optional.
POSIX.1-2024 provides no means of defining a wide-character codeset.
The following declarations can follow the character set mapping definitions (after the "END CHARMAP"
statement). Each shall consist of the keyword shown in the following list, starting in column 1, followed by the value(s) to be
associated to the keyword, as defined below.
WIDTH
A non-negative integer value defining the column width (see 3.75 Column
Position) for the printable characters in the coded character set specified in Portable Character
Set and Non-Portable Control Characters. Coded character set character values shall be defined using
symbolic character names followed by column width values. Defining a character with more than one WIDTH produces undefined
results. The END WIDTH keyword shall be used to terminate the WIDTH definitions. Specifying the width of a
non-printable character in a WIDTH declaration produces undefined results.
WIDTH_DEFAULT
A non-negative integer value defining the default column width for any printable character not listed by one of the WIDTH
keywords. If no WIDTH_DEFAULT keyword is included in the charmap, the default character width shall be 1.
The following sections are informative.
Example
After the "END CHARMAP" statement, a syntax for a width definition would be:
WIDTH
1
1
... 1
...
... 2
...
END WIDTH
In this example, the numerical code point values represented by the symbols  and
are assigned a width of 1. The code point values  to  inclusive (,
, , and so on) are also assigned a width of 1. Using ... would have
required fewer lines, but the alternative was shown to demonstrate flexibility. The keyword WIDTH_DEFAULT could have been
added as appropriate.
End of informative text.
6.4.1 State-Dependent Character Encodings
This section addresses the use of state-dependent character encodings (that is, those in which the encoding of a
character is dependent on one or more shift codes that may precede it).
A single-shift encoding (where each character not in the initial shift state is preceded by a shift code) can be
defined in the charmap format if each shift-code/character sequence is considered a multi-byte character, defined using the
concatenated-constant format described in 6.4 Character Set Description File. If the implementation
supports a character encoding of this type, all of the standard utilities shall support it. A locking-shift encoding (where the
state of the character is determined by a shift code that may affect more than the single character following it) could be defined
with an extension to the charmap format described in 6.4 Character Set Description File.
If the implementation supports a character encoding of this type, any of the standard utilities that describe
character (versus byte) or text-file manipulation shall have the following characteristics:
The utility shall process the statefully encoded data as a concatenation of state-independent characters. The
presence of redundant locking shifts shall not affect the comparison of two statefully encoded strings.
A utility that divides, truncates, or extracts substrings from statefully encoded data shall produce output that
contains locking shifts at the beginning or end of the resulting data, if appropriate, to retain correct state information.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/semaphore.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
semaphore.h — semaphores
SYNOPSIS
#include
DESCRIPTION
The  header shall define the sem_t type, used in performing semaphore operations. The semaphore
may be implemented using a file descriptor, in which case applications are able to open up at least a total of {OPEN_MAX} files and
semaphores.
The  header shall define the timespec structure as described in .
The  header shall define the symbolic constant SEM_FAILED which shall have type sem_t *.
The  header shall define O_CREAT and O_EXCL as described in .
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
int    sem_clockwait(sem_t *restrict, clockid_t,
const struct timespec *restrict);
int    sem_close(sem_t *);
int    sem_destroy(sem_t *);
int    sem_getvalue(sem_t *restrict, int *restrict);
int    sem_init(sem_t *, int, unsigned);
sem_t *sem_open(const char *, int, ...);
int    sem_post(sem_t *);
int    sem_timedwait(sem_t *restrict, const struct timespec *restrict);
int    sem_trywait(sem_t *);
int    sem_unlink(const char *);
int    sem_wait(sem_t *);
Inclusion of the  header may make visible symbols defined in the  and  headers.
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
, ,
XSH sem_clockwait(), sem_close(), sem_destroy(),
sem_getvalue(), sem_init(),
sem_open(), sem_post(),
sem_trywait(), sem_unlink()
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The  header is marked as part of the Semaphores option.
The Open Group Corrigendum U021/3 is applied, adding a description of SEM_FAILED.
The sem_timedwait() function is added for alignment with
IEEE Std 1003.1d-1999.
The restrict keyword is added to the prototypes for sem_getvalue()
and sem_timedwait().
Issue 7
SD5-XBD-ERN-57 is applied, allowing the header to make visible symbols from the  header.
The  header is moved from the Semaphores option to the Base.
This reference page is clarified with respect to macros and symbolic constants.
Issue 8
Austin Group Defect 592 is applied, requiring  to define the timespec structure.
Austin Group Defect 593 is applied, adding O_CREAT and O_EXCL.
Austin Group Defect 1216 is applied, adding sem_clockwait().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/V1_chap07.html =====
Locale
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
7. Locale
7.1 General
A locale is the definition of the subset of a user's environment that depends on language and cultural conventions. It is made
up from one or more categories. Each category is identified by its name and controls specific aspects of the behavior of components
of the system. Category names correspond to the following environment variable names:
LC_CTYPE
Character classification and case conversion.
LC_COLLATE
Collation order.
LC_MONETARY
Monetary formatting.
LC_NUMERIC
Numeric, non-monetary formatting.
LC_TIME
Date and time formats.
LC_MESSAGES
Formats of informative and diagnostic messages and interactive responses.
The standard utilities in the Shell and Utilities volume of POSIX.1-2024 shall base their behavior on the current locale, as
defined in the ENVIRONMENT VARIABLES section for each utility. The behavior of some of the C-language functions defined in the
System Interfaces volume of POSIX.1-2024 shall also be modified based on a locale selection. The locale to be used by these
functions can be selected in the following ways:
For functions such as isalnum_l() that take a locale object as an argument, a
locale object can be obtained from newlocale() or duplocale() and passed to the function.
For functions that do not take a locale object as an argument, the current locale for the thread can be set by calling uselocale() or the global locale for the process can be set by calling setlocale(). Such functions shall use the current locale of the calling thread if one has
been set for that thread; otherwise, they shall use the global locale.
Some functions, such as catopen() and those related to text domains, may
reference various environment variables and a locale category of a specific locale to access files they need to use.
Locales other than those supplied by the implementation can be created via the localedef utility, provided that the _POSIX2_LOCALEDEF symbol is defined on the system.
Even if localedef is not provided, all implementations conforming to the System
Interfaces volume of POSIX.1-2024 shall provide one or more locales that behave as described in this chapter. The input to the
utility is described in 7.3 Locale Definition. The value that is used to specify a locale when using
environment variables shall be the string specified as the name operand to the localedef utility when the locale was created. The strings "C" and
"POSIX" are reserved as identifiers for the POSIX locale (see 7.2 POSIX Locale). When the value
of a locale environment variable begins with a  ('/'), it shall be interpreted as the pathname of the locale
definition; the type of file (regular, directory, and so on) used to store the locale definition is implementation-defined. If the
value does not begin with a , the mechanism used to locate the locale is implementation-defined.
If incompatible character sets are used by the locale categories, the results achieved by an application utilizing these
categories are undefined. Two locale categories have incompatible character sets if one of the categories is LC_CTYPE and
the locale data associated with the other category includes at least one character that either is not in the character set used by
LC_CTYPE or has a different encoding than the same character in the character set used by LC_CTYPE .
Likewise, unless specified otherwise, if different codesets are used by a particular category of the selected locale and by the
data being processed by an interface whose behavior is dependent on that category of the selected locale, the results are
undefined.
Applications can select the desired locale by calling the newlocale() or
setlocale() function with the appropriate value. If the function is invoked with
an empty string, such as:
newlocale(LC_ALL_MASK, "", (locale_t)0);
or:
setlocale(LC_ALL, "");
the value of the corresponding environment variable is used. If the environment variable is unset or is set to the empty string,
the implementation shall set the appropriate environment as defined in 8.
Environment Variables.
7.2 POSIX Locale
Conforming systems shall provide a POSIX locale, also known as the C locale. In POSIX.1 the requirements for the POSIX locale
are more extensive than the requirements for the C locale as specified in the ISO C standard. However, in a conforming POSIX
implementation, the POSIX locale and the C locale are identical. The behavior of standard utilities and functions in the POSIX
locale shall be as if the locale was defined via the localedef utility with input
data from the POSIX locale tables in 7.3 Locale Definition.
For C-language programs, the POSIX locale shall be the default locale when the setlocale() function is not called.
The POSIX locale can be specified by assigning to the appropriate environment variables the values "C" or
"POSIX".
All implementations shall define a locale as the default locale, to be invoked when no environment variables are set, or set to
the empty string. This default locale can be the POSIX locale or any other implementation-defined locale. Some implementations may
provide facilities for local installation administrators to set the default locale, customizing it for each location. POSIX.1-2024
does not require such a facility.
7.3 Locale Definition
The capability to specify additional locales to those provided by an implementation is optional, denoted by the
_POSIX2_LOCALEDEF symbol. If the option is not supported, only implementation-supplied locales are available. Such locales shall be
documented using the format specified in this section.
Locales can be described with the file format presented in this section. The file format is that accepted by the localedef utility. For the purposes of this section, the file is referred to as the
"locale definition file", but no locales shall be affected by this file unless it is processed by localedef or some similar mechanism. Any requirements in this section imposed upon the
utility shall apply to localedef or to any other similar utility used to install
locale information using the locale definition file format described here.
The locale definition file shall contain one or more locale category source definitions, and shall not contain more than one
definition for the same locale category. If the file contains source definitions for more than one category, implementation-defined
categories, if present, shall appear after the categories defined by 7.1 General. A category source
definition contains either the definition of a category or a copy directive. For a description of the copy directive,
see localedef. In the event that some of the information for a locale category, as
specified in this volume of POSIX.1-2024, is missing from the locale source definition, the behavior of that category, if it is
referenced, is unspecified.
A category source definition shall consist of a category header, a category body, and a category trailer. A category header
shall consist of the character string naming of the category, beginning with the characters LC_ . The category trailer shall
consist of the string "END", followed by one or more  characters and the string used in the corresponding
category header.
The category body shall consist of one or more lines of text. Each line shall contain an identifier, optionally followed by one
or more operands. Identifiers shall be either keywords, identifying a particular locale element, or collating elements. In addition
to the keywords defined in this volume of POSIX.1-2024, the source can contain implementation-defined keywords. Each keyword within
a locale shall have a unique name (that is, two categories cannot have a commonly-named keyword); no keyword shall start with the
characters LC_ . Identifiers shall be separated from the operands by one or more  characters.
Operands shall be characters, collating elements, or strings of characters. Strings shall be enclosed in double-quotes. Literal
double-quotes within strings shall be preceded by the , described below. When a keyword is followed
by more than one operand, the operands shall be separated by  characters;  characters shall be
allowed both before and after a .
The first category header in the file can be preceded by a line modifying the comment character. It shall have the following
format, starting in column 1:
"comment_char %c\n",
The comment character shall default to the  ('#'). Blank lines and lines containing the
in the first position shall be ignored.
The first category header in the file can be preceded by a line modifying the escape character to be used in the file. It shall
have the following format, starting in column 1:
"escape_char %c\n",
The escape character shall default to , which is the character used in all examples shown in this volume of
POSIX.1-2024.
A line can be continued by placing an escape character as the last character on the line; this continuation character shall be
discarded from the input. Although the implementation need not accept any one portion of a continued line with a length exceeding
{LINE_MAX} bytes, it shall place no limits on the accumulated length of the continued line. Comment lines shall not be continued on
a subsequent line using an escaped .
Individual characters, characters in strings, and collating elements shall be represented using symbolic names, as defined
below. In addition, characters can be represented using the characters themselves or as octal, hexadecimal, or decimal constants.
When non-symbolic notation is used, the resultant locale definitions are in many cases not portable between systems. The left angle
bracket (''. The
symbolic name, including the angle brackets, shall exactly match a symbolic name defined in the charmap file specified via the
localedef -f option, and it shall be replaced by a character value
determined from the value associated with the symbolic name in the charmap file. The use of a symbolic name not found in the
charmap file shall constitute an error, unless the category is LC_CTYPE or LC_COLLATE , in which case it shall
constitute a warning condition (see localedef for a description of actions
resulting from errors and warnings). The specification of a symbolic name in a collating-element or collating-symbol
section that duplicates a symbolic name in the charmap file (if present) shall be an error. Use of the escape character or a right
angle bracket within a symbolic name is invalid unless the character is preceded by the escape character.
For example:
;  ""
A character in the portable character set can be represented by the character itself, in which case the value of the character
is implementation-defined. (Implementations may allow other characters to be represented as themselves, but such locale definitions
are not portable.) Within a string, the double-quote character, the escape character, and the right angle bracket character shall
be escaped (preceded by the escape character) to be interpreted as the character itself. Outside strings, the characters:
,    ;        escape_char
shall be escaped to be interpreted as the character itself.
For example:
c    "May"
A character can be represented as an octal constant. An octal constant shall be specified as the escape character followed by
two or three octal digits. Each constant shall represent a byte value. Multi-byte values can be represented by concatenated
constants specified in byte order with the last constant specifying the least significant byte of the character.
For example:
\143;\347;\143\150   "\115\141\171"
A character can be represented as a hexadecimal constant. A hexadecimal constant shall be specified as the escape character
followed by an 'x' followed by two hexadecimal digits. Each constant shall represent a byte value. Multi-byte values can
be represented by concatenated constants specified in byte order with the last constant specifying the least significant byte of
the character.
For example:
\x63;\xe7;\x63\x68   "\x4d\x61\x79"
A character can be represented as a decimal constant. A decimal constant shall be specified as the escape character followed by
a 'd' followed by two or three decimal digits. Each constant represents a byte value. Multi-byte values can be represented
by concatenated constants specified in byte order with the last constant specifying the least significant byte of the
character.
For example:
\d99;\d231;\d99\d104  "\d77\d97\d121"
Implementations may accept single-digit octal, decimal, or hexadecimal constants following the escape character. Only characters
existing in the character set for which the locale definition is created shall be specified, whether using symbolic names, the
characters themselves, or octal, decimal, or hexadecimal constants. If a charmap file is present, only characters defined in the
charmap can be specified using octal, decimal, or hexadecimal constants. Symbolic names not present in the charmap file can be
specified and shall be ignored, as specified under item 1 above.
7.3.1 LC_CTYPE
The LC_CTYPE category shall define character classification, case conversion, and other character attributes. In
addition, a series of characters can be represented by three adjacent  characters representing an ellipsis symbol
("..."). The ellipsis specification shall be interpreted as meaning that all values between the values preceding and
following it represent valid characters. The ellipsis specification shall be valid only within a single encoded character set; that
is, within a group of characters of the same size. An ellipsis shall be interpreted as including in the list all characters with an
encoded value higher than the encoded value of the character preceding the ellipsis and lower than the encoded value of the
character following the ellipsis.
For example:
\x30;...;\x39;
includes in the character class all characters with encoded values between the endpoints.
The following keywords shall be recognized. In the descriptions, the term "automatically included" means that it shall not be
an error either to include or omit any of the referenced characters; the implementation provides them if missing (even if the
entire keyword is missing) and accepts them silently if present. When the implementation automatically includes a missing
character, it shall have an encoded value dependent on the charmap file in effect (see the description of the localedef -f option); otherwise, it shall have a value derived from an
implementation-defined character mapping.
The character classes digit, xdigit, lower, upper, and space have a set of automatically
included characters. It is not possible to define a locale without these automatically included characters unless some
implementation extension is used to prevent their inclusion. Such a definition would not be a proper superset of the C or POSIX
locale and, thus, it might not be possible for conforming applications to work properly.
copy
Specify the name of an existing locale which shall be used as the definition of this category. If this keyword is specified, no
other keyword shall be specified.
upper
Define characters to be classified as uppercase letters.
In the POSIX locale, only:
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
shall be included:
In a locale definition file, no character specified for the keywords cntrl, digit, punct, or space
shall be specified. The uppercase letters  to , as defined in 6.4 Character Set Description File (the portable character set), are
automatically included in this class.
lower
Define characters to be classified as lowercase letters.
In the POSIX locale, only:
a b c d e f g h i j k l m n o p q r s t u v w x y z
shall be included.
In a locale definition file, no character specified for the keywords cntrl, digit, punct, or space
shall be specified. The lowercase letters  to  of the portable character set are automatically included in this
class.
alpha
Define characters to be classified as letters.
In the POSIX locale, only characters in the classes upper and lower shall be included.
In a locale definition file, no character specified for the keywords cntrl, digit, punct, or space
shall be specified. Characters classified as either upper or lower are automatically included in this class.
digit
Define the characters to be classified as numeric digits.
In all locales, only:
0 1 2 3 4 5 6 7 8 9
shall be included.
In a locale definition file, only the digits , , , , , ,
, , , and  shall be specified, and in contiguous ascending sequence by numerical
value. The digits  to  of the portable character set are automatically included in this class.
alnum
Define characters to be classified as letters and numeric digits. Only the characters specified for the alpha and
digit keywords shall be specified. Characters specified for the keywords alpha and digit are automatically
included in this class.
space
Define characters to be classified as white-space characters.
In the POSIX locale, exactly , , , , , and
shall be included.
In a locale definition file, no character specified for the keywords upper, lower, alpha, digit,
graph, or xdigit shall be specified. The , , , ,
, and  of the portable character set, and any characters included in the class blank are
automatically included in this class.
cntrl
Define characters to be classified as control characters.
In the POSIX locale, no characters in classes alpha or print shall be included.
In a locale definition file, no character specified for the keywords upper, lower, alpha, digit,
punct, graph, print, or xdigit shall be specified.
punct
Define characters to be classified as punctuation characters.
In the POSIX locale, neither the  nor any characters in classes alpha, digit, or cntrl shall
be included.
In a locale definition file, no character specified for the keywords upper, lower, alpha, digit,
cntrl, xdigit, or as the  shall be specified.
graph
Define characters to be classified as printable characters, not including the .
In the POSIX locale, all characters in classes alpha, digit, and punct shall be included; no characters in
class cntrl shall be included.
In a locale definition file, characters specified for the keywords upper, lower, alpha, digit,
xdigit, and punct are automatically included in this class. No character specified for the keyword cntrl shall
be specified.
print
Define characters to be classified as printable characters, including the .
In the POSIX locale, all characters in class graph shall be included; no characters in class cntrl shall be
included.
In a locale definition file, characters specified for the keywords upper, lower, alpha, digit,
xdigit, punct, graph, and the  are automatically included in this class. No character specified
for the keyword cntrl shall be specified.
xdigit
Define the characters to be classified as hexadecimal digits.
In all locales, only:
0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f
shall be included.
In a locale definition file, only the characters defined for the class digit shall be specified, in contiguous ascending
sequence by numerical value, followed by two sets, in either order, of six characters representing the hexadecimal digits
corresponding to the decimal numbers 10 to 15 inclusive, with each set in ascending order: , , ,
, ,  and , , , , , . The digits  to
, the uppercase letters  to , and the lowercase letters  to  of the portable
character set are automatically included in this class.
blank
Define characters to be classified as  characters.
In the POSIX locale, only the  and  shall be included.
In a locale definition file, no character specified for the keywords upper, lower, alpha, digit,
graph, or xdigit shall be specified, and none of the characters , ,
, and  of the portable character set shall be specified. The  and
are automatically included in this class.
charclass
Define one or more locale-specific character class names as strings separated by  characters. Each named
character class can then be defined subsequently in the LC_CTYPE definition. A character class name shall consist of at
least one and at most {CHARCLASS_NAME_MAX} bytes of alphanumeric characters from the portable filename character set. The first
character of a character class name shall not be a digit. The name shall not match any of the LC_CTYPE keywords defined in
this volume of POSIX.1-2024. Future versions of this standard will not specify any LC_CTYPE keywords containing uppercase
letters.
charclass-name
Define characters to be classified as belonging to the named locale-specific character class. In the POSIX locale,
locale-specific named character classes need not exist.
If a class name is defined by a charclass keyword, but no characters are subsequently assigned to it, this is not an
error; it represents a class without any characters belonging to it.
The charclass-name can be used as the property argument to the wctype() function, in regular expression and shell pattern-matching bracket expressions, and
by the tr command.
toupper
Define the mapping of lowercase letters to uppercase letters.
In the POSIX locale, the 26 lowercase characters:
a b c d e f g h i j k l m n o p q r s t u v w x y z
shall be mapped to the corresponding 26 uppercase characters:
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
In a locale definition file, the operand shall consist of character pairs, separated by  characters. The
characters in each character pair shall be separated by a  and the pair enclosed by parentheses. The first character
in each pair is the lowercase letter, the second the corresponding uppercase letter. Only characters specified for the keywords
lower and upper shall be specified. The lowercase letters  to , and their corresponding uppercase
letters  to , of the portable character set are automatically included in this mapping, but only when the
toupper keyword is omitted from the locale definition.
tolower
Define the mapping of uppercase letters to lowercase letters.
In the POSIX locale, the 26 uppercase characters:
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
shall be mapped to the corresponding 26 lowercase characters:
a b c d e f g h i j k l m n o p q r s t u v w x y z
In a locale definition file, the operand shall consist of character pairs, separated by  characters. The
characters in each character pair shall be separated by a  and the pair enclosed by parentheses. The first character
in each pair is the uppercase letter, the second the corresponding lowercase letter. Only characters specified for the keywords
lower and upper shall be specified. If the tolower keyword is omitted from the locale definition, the mapping
is the reverse mapping of the one specified for toupper.
The following table shows the character class combinations allowed:
Table: Valid Character Class Combinations
Can Also Belong To
In Class
upper
lower
alpha
digit
space
cntrl
punct
graph
print
xdigit
blank
upper
—
A
x
x
x
x
A
A
—
x
lower
—
A
x
x
x
x
A
A
—
x
alpha
—
—
x
x
x
x
A
A
—
x
digit
x
x
x
x
x
x
A
A
A
x
space
x
x
x
x
—
*
*
*
x
—
cntrl
x
x
x
x
—
x
x
x
x
—
punct
x
x
x
x
—
x
A
A
x
—
graph
—
—
—
—
—
x
—
A
—
—
print
—
—
—
—
—
x
—
—
—
—
xdigit
—
—
—
—
x
x
x
A
A
x
blank
x
x
x
x
A
—
*
*
*
x
Notes:
Explanation of codes:
A
Automatically included; see text.
—
Permitted.
x
Mutually-exclusive.
*
See note 2.
The , which is part of the space and blank classes, cannot belong to punct or
graph, but shall automatically belong to the print class. Other space or blank characters can be
classified as any of punct, graph, or print.
7.3.1.1 LC_CTYPE Category in the POSIX Locale
The minimum character classifications for the POSIX locale follow; the code listing depicts the localedef input, and the table represents the same information, sorted by character.
Implementations may add additional characters to the cntrl and punct classifications but shall not make any other
additions.
LC_CTYPE
# The following is the minimum POSIX locale LC_CTYPE.
# "alpha" is by definition "upper" and "lower"
# "alnum" is by definition "alpha" and "digit"
# "print" is by definition "alnum", "punct", and the
# "graph" is by definition "alnum" and "punct"
#
upper    ;;;;;;;;;;;;;\
;;;;;;;;;;;;
#
lower    ;;;;;;;;;;;;;\
;;;;;;;;;;;;
#
digit    ;;;;;;;\
;;
#
space    ;;;;\
;
#
cntrl    ;;;;;\
;;\
;;;;;;;;\
;;;;;;;;\
;;;;;;;;\
;
#
punct    ;;;\
;;;;\
;;;\
;;;;;\
;;;;\
;;;\
;;;\
;;;;\
;;
#
xdigit   ;;;;;;;;\
;;;;;;;;;;;;;
#
blank    ;
#
toupper (,);(,);(,);(,);(,);\
(,);(,);(,);(,);(,);\
(,);(,);(,);(,);(,);\
(,);(,);(,);(,);(,);\
(,);(,);(,);(,);(,);(,)
#
tolower (,);(,);(,);(,);(,);\
(,);(,);(,);(,);(,);\
(,);(,);(,);(,);(,);\
(,);(,);(,);(,);(,);\
(,);(,);(,);(,);(,);(,)
END LC_CTYPE
Symbolic Name
Other Case
Character Classes
cntrl
cntrl
cntrl
cntrl
cntrl
cntrl
cntrl
cntrl
cntrl
cntrl, space, blank
cntrl, space
cntrl, space
cntrl, space
cntrl, space
cntrl
cntrl
cntrl
cntrl
cntrl
cntrl
cntrl
cntrl
cntrl
cntrl
cntrl
cntrl
cntrl
cntrl
cntrl
cntrl
cntrl
cntrl
space, print, blank
punct, print, graph
punct, print, graph
punct, print, graph
punct, print, graph
punct, print, graph
punct, print, graph
punct, print, graph
punct, print, graph
punct, print, graph
punct, print, graph
punct, print, graph
punct, print, graph
punct, print, graph
punct, print, graph
punct, print, graph
digit, xdigit, print, graph
digit, xdigit, print, graph
digit, xdigit, print, graph
digit, xdigit, print, graph
digit, xdigit, print, graph
digit, xdigit, print, graph
digit, xdigit, print, graph
digit, xdigit, print, graph
digit, xdigit, print, graph
digit, xdigit, print, graph
punct, print, graph
punct, print, graph
punct, print, graph
punct, print, graph
punct, print, graph
punct, print, graph
punct, print, graph
upper, xdigit, alpha, print, graph
upper, xdigit, alpha, print, graph
upper, xdigit, alpha, print, graph
upper, xdigit, alpha, print, graph
upper, xdigit, alpha, print, graph
upper, xdigit, alpha, print, graph
upper, alpha, print, graph
upper, alpha, print, graph
upper, alpha, print, graph
upper, alpha, print, graph
upper, alpha, print, graph
upper, alpha, print, graph
upper, alpha, print, graph
upper, alpha, print, graph
upper, alpha, print, graph
upper, alpha, print, graph
upper, alpha, print, graph
upper, alpha, print, graph
upper, alpha, print, graph
upper, alpha, print, graph
upper, alpha, print, graph
upper, alpha, print, graph
upper, alpha, print, graph
upper, alpha, print, graph
upper, alpha, print, graph
upper, alpha, print, graph
punct, print, graph
punct, print, graph
punct, print, graph
punct, print, graph
punct, print, graph
punct, print, graph
lower, xdigit, alpha, print, graph
lower, xdigit, alpha, print, graph
lower, xdigit, alpha, print, graph
lower, xdigit, alpha, print, graph
lower, xdigit, alpha, print, graph
lower, xdigit, alpha, print, graph
lower, alpha, print, graph
lower, alpha, print, graph
lower, alpha, print, graph
lower, alpha, print, graph
lower, alpha, print, graph
lower, alpha, print, graph
lower, alpha, print, graph
lower, alpha, print, graph
lower, alpha, print, graph
lower, alpha, print, graph
lower, alpha, print, graph
lower, alpha, print, graph
lower, alpha, print, graph
lower, alpha, print, graph
lower, alpha, print, graph
lower, alpha, print, graph
lower, alpha, print, graph
lower, alpha, print, graph
lower, alpha, print, graph
lower, alpha, print, graph
punct, print, graph
punct, print, graph
punct, print, graph
punct, print, graph
cntrl
7.3.2 LC_COLLATE
The LC_COLLATE category provides a collation sequence definition for numerous utilities in the Shell and
Utilities volume of POSIX.1-2024 (ls, sort,
and so on), regular expression matching (see 9. Regular Expressions), and
the strcoll(), strxfrm(), wcscoll(), and wcsxfrm() functions in the
System Interfaces volume of POSIX.1-2024.
A collation sequence definition shall define the relative order between collating elements (characters and
multi-character collating elements) in the locale. This order is expressed in terms of collation values; that is, by assigning each
element one or more collation values (also known as collation weights). This does not imply that implementations shall assign such
values, but that ordering of strings using the resultant collation definition in the locale behaves as if such assignment is done
and used in the collation process. At least the following capabilities are provided:
Multi-character collating elements. Specification of multi-character collating elements (that is, sequences
of two or more characters to be collated as an entity).
User-defined ordering of collating elements. Each collating element shall be assigned a collation value
defining its order in the character (or basic) collation sequence. This ordering is used by regular expressions and pattern
matching and, unless collation weights are explicitly specified, also as the collation weight to be used in sorting.
Multiple weights and equivalence classes. Collating elements can be assigned one or more (up to the limit
{COLL_WEIGHTS_MAX}, as defined in ) collating weights for use in
sorting. The first weight is hereafter referred to as the primary weight.
One-to-many mapping. A single character is mapped into a string of collating elements.
Equivalence class definition. Two or more collating elements have the same collation value (primary
weight).
Ordering by weights. When two strings are compared to determine their relative order, the two strings are
first broken up into a series of collating elements; the elements in each successive pair of elements are then compared according
to the relative primary weights for the elements. If equal, and more than one weight has been assigned, then the pairs of collating
elements are re-compared according to the relative subsequent weights, until either a pair of collating elements compare unequal or
the weights are exhausted.
All implementation-provided locales (either preinstalled or provided as locale definitions which can be installed
later) shall define a collation sequence that has a total ordering of all characters unless the locale name has an '@'
modifier indicating that it has a special collation sequence (for example, @icase could indicate that each upper and
lowercase character pair collates equally).
Note:
Users installing their own locales should ensure that they define a collation sequence with a total ordering of all characters
unless an '@' modifier in the locale name (such as @icase) indicates that it has a special collation sequence. As
is reserved as the string terminator for most usages of LC_COLLATE , it is the responsibility of the locale
writer to ensure  has the lowest primary weight in a collation ordering for the interfaces to behave in the way users
typically expect. Unusual behavior may result if it has any other collation order weighting, or is subject to IGNORE.
The following keywords shall be recognized in a collation sequence definition. They are described in detail in the
following sections.
copy
Specify the name of an existing locale which shall be used as the definition of this category. If this keyword is specified, no
other keyword shall be specified.
collating-element
Define a collating-element symbol representing a multi-character collating element. This keyword is optional.
collating-symbol
Define a collating symbol for use in collation order statements. This keyword is optional.
order_start
Define collation rules. This statement shall be followed by one or more collation order statements, assigning character
collation values and collation weights to collating elements.
order_end
Specify the end of the collation-order statements.
7.3.2.1 The collating-element Keyword
In addition to the collating elements in the character set, the collating-element keyword can be used to
define multi-character collating elements. The syntax is as follows:
"collating-element %s from \"%s\"\n", ,
The  operand shall be a symbolic name, enclosed between angle brackets
(''), and shall not duplicate any symbolic name in the current charmap file (if any), or any other
symbolic name defined in this collation definition. The string operand is a string of two or more characters that collates as an
entity. A  defined via this keyword is only recognized with the LC_COLLATE category.
For example:
collating-element  from ""
collating-element  from ""
collating-element  from "ll"
7.3.2.2 The collating-symbol Keyword
This keyword shall be used to define symbols for use in collation sequence statements; that is, between the
order_start and the order_end keywords. The syntax is as follows:
"collating-symbol %s\n",
The  shall be a symbolic name, enclosed between angle brackets (''), and shall not duplicate any symbolic name in the current charmap file (if any), or any other symbolic name
defined in this collation definition. A  defined via this keyword is only recognized within the
LC_COLLATE category.
For example:
collating-symbol
collating-symbol
The collating-symbol keyword defines a symbolic name that can be associated with a relative position in the
character order sequence. While such a symbolic name does not represent any collating element, it can be used as a weight.
7.3.2.3 The order_start Keyword
The order_start keyword shall precede collation order entries and also define the number of weights for this
collation sequence definition and other collation rules. The syntax is as follows:
"order_start %s;%s;...;%s\n", ,  ...
The operands to the order_start keyword are optional. If present, the operands define rules to be applied
when strings are compared. The number of operands define how many weights each element is assigned; if no operands are present, one
forward operand is assumed. If present, the first operand defines rules to be applied when comparing strings using the first
(primary) weight; the second when comparing strings using the second weight, and so on. Operands shall be separated by
characters (';'). Each operand shall consist of one or more collation directives, separated by
characters (','). If the number of operands exceeds the {COLL_WEIGHTS_MAX} limit, the utility shall issue a
warning message. The following directives shall be supported:
forward
Specifies that comparison operations for the weight level shall proceed from start of string towards the end of string.
backward
Specifies that comparison operations for the weight level shall proceed from end of string towards the beginning of
string.
position
Specifies that comparison operations for the weight level shall consider the relative position of elements in the strings not
subject to IGNORE. The string containing an element not subject to IGNORE after the fewest collating elements subject
to IGNORE from the start of the compare shall collate first. If both strings contain a character not subject to
IGNORE in the same relative position, the collating values assigned to the elements shall determine the ordering. In case of
equality, subsequent characters not subject to IGNORE shall be considered in the same manner.
The directives forward and backward are mutually-exclusive.
If no operands are specified, a single forward operand shall be assumed.
For example:
order_start    forward;backward
7.3.2.4 Collation Order
The order_start keyword shall be followed by collating identifier entries. The syntax for the collating
element entries is as follows:
"%s %s;%s;...;%s\n", , , , ...
Each collating-identifier shall consist of either a character (in any of the forms defined in 7.3 Locale Definition), a , a , an ellipsis, or
the special symbol UNDEFINED. The order in which collating elements are specified determines the character order sequence,
such that each collating element shall compare less than the elements following it.
A  shall be used to specify multi-character collating elements, and indicates that
the character sequence specified via the  is to be collated as a unit and in the relative order
specified by its place.
A  can be used to define a position in the relative order for use in weights. No
weights shall be specified with a .
The ellipsis symbol specifies that a sequence of characters shall collate according to their encoded character
values. It shall be interpreted as indicating that all characters with a coded character set value higher than the value of the
character in the preceding line, and lower than the coded character set value for the character in the following line, in the
current coded character set, shall be placed in the character collation order between the previous and the following character in
ascending order according to their coded character set values. An initial ellipsis shall be interpreted as if the preceding line
specified the NUL character, and a trailing ellipsis as if the following line specified the highest coded character set value in
the current coded character set. An ellipsis shall be treated as invalid if the preceding or following lines do not specify
characters in the current coded character set. The use of the ellipsis symbol ties the definition to a specific coded character set
and may preclude the definition from being portable between implementations.
The symbol UNDEFINED shall be interpreted as including all coded character set values not specified
explicitly or via the ellipsis symbol. Such characters shall be inserted in the character collation order at the point indicated by
the symbol, and in ascending order according to their coded character set values. If no UNDEFINED symbol is specified, and
the current coded character set contains characters not specified in this section, the utility shall issue a warning message and
place such characters at the end of the character collation order.
The optional operands for each collation-element shall be used to define the primary, secondary, or subsequent
weights for the collating element. The first operand specifies the relative primary weight, the second the relative secondary
weight, and so on. Two or more collation-elements can be assigned the same weight; they belong to the same "equivalence class" if
they have the same primary weight. Collation shall behave as if, for each weight level, elements subject to IGNORE are
removed, unless the position collation directive is specified for the corresponding level with the order_start
keyword. Then each successive pair of elements shall be compared according to the relative weights for the elements. If the two
strings compare equal, the process shall be repeated for the next weight level, up to the limit {COLL_WEIGHTS_MAX}.
Weights shall be assigned such that the collation sequence has a total ordering of all characters unless an
'@' modifier in the locale name indicates that it has a special collation sequence.
Weights shall be expressed as characters (in any of the forms specified in 7.3 Locale
Definition), s, s, an ellipsis, or the special symbol
IGNORE. A single character, a , or a  shall represent the
relative position in the character collating sequence of the character or symbol, rather than the character or characters
themselves. Thus, rather than assigning absolute values to weights, a particular weight is expressed using the relative order value
assigned to a collating element based on its order in the character collation sequence.
One-to-many mapping is indicated by specifying two or more concatenated characters or symbolic names. For example,
if the  is given the string "" as a weight, comparisons are performed as if all occurrences
of the  are replaced by "" (assuming that "" has the collating weight
""). If it is necessary to define  and "" as an equivalence class, then a
collating element needs to be defined for the string "ss".
All characters specified via an ellipsis shall by default be assigned unique weights, equal to the relative order
of characters. Characters specified via an explicit or implicit UNDEFINED special symbol shall by default be assigned the
same primary weight (that is, they belong to the same equivalence class) if the collation order has more than one weight level. If
the collation order has only one weight level, these characters shall be assigned unique primary weights, equal to the relative
order of their character in the character collation sequence.
An ellipsis symbol as a weight shall be interpreted to mean that each character in the sequence shall have unique
weights, equal to the relative order of their character in the character collation sequence. The use of the ellipsis as a weight
shall be treated as an error if the collating element is neither an ellipsis nor the special symbol UNDEFINED.
The special keyword IGNORE as a weight shall indicate that when strings are compared using the weights at
the level where IGNORE is specified, the collating element shall be ignored; that is, as if the string did not contain the
collating element. In regular expressions and pattern matching, all characters that are subject to IGNORE in their primary
weight form an equivalence class.
An empty operand shall be interpreted as the collating element itself.
For example, the order statement:
;
is equal to:
An ellipsis can be used as an operand if the collating element was an ellipsis, and shall be interpreted as the
value of each character defined by the ellipsis.
The collation order as defined in this section affects the interpretation of bracket expressions in regular
expressions (see 9.3.5 RE Bracket Expression).
For example:
order_start  forward;backward
;
;
...          ;...
;
;
;
;
;
;
;
;
;
"";""
UNDEFINED    IGNORE;...
order_end
This example is interpreted as follows:
All characters between  and 'a' shall have the same primary equivalence class and individual
secondary weights based on their ordinal encoded values.
All characters based on the uppercase or lowercase character 'a' belong to the same primary equivalence
class.
The multi-character collating element  is represented by the collating symbol  and belongs to
the same primary equivalence class as the multi-character collating element .
The UNDEFINED means that all characters not specified in this definition (explicitly or via the ellipsis)
shall be ignored when comparing primary weights, and have individual secondary weights based on their ordinal encoded values.
7.3.2.5 The order_end Keyword
The collating order entries shall be terminated with an order_end keyword.
7.3.2.6 LC_COLLATE Category in the POSIX Locale
The minimum collation sequence definition of the POSIX locale follows; the code listing depicts the localedef input. All characters not explicitly listed here shall be inserted in the
character collation order after the listed characters and shall be assigned unique primary weights. If the listed characters have
ASCII encoding, the other characters shall be in ascending order according to their coded character set values; otherwise, the
order of the other characters is unspecified. The collation sequence shall not include any multi-character collating elements.
LC_COLLATE
# This is the minimum input for the POSIX locale definition for the
# LC_COLLATE category. Characters in this list are in the same order
# as in the ASCII codeset.
order_start forward
order_end
#
END LC_COLLATE
7.3.3 LC_MONETARY
The LC_MONETARY category shall define the rules and symbols that are used to format monetary numeric
information.
This information is available through the localeconv() function
and is used by the strfmon() function.
Some of the information is also available in an alternative form via the nl_langinfo() function (see CRNCYSTR in ).
The following items are defined in this category of the locale. The item names are the keywords recognized by the
localedef utility when defining a locale. They are also similar to the member
names of the lconv structure defined in ; see  for the exact symbols in the header. The localeconv() function returns {CHAR_MAX} for unavailable integer items and the empty
string ("") for unavailable or size zero string items.
In a locale definition file, the operands are strings, formatted as indicated by the grammar in 7.4 Locale Definition Grammar. For some keywords, the strings can contain only integers. Keywords that are not
provided, or integer keywords set to -1, can be used to indicate that the value is not available in the locale. String values set
to the empty string ("") can be used to indicate that the value is available and is an empty string, or that the value is
not available. The following keywords shall be recognized:
copy
Specify the name of an existing locale which shall be used as the definition of this category. If this keyword is specified, no
other keyword shall be specified.
Note:
This is a localedef utility keyword, unavailable through localeconv().
int_curr_symbol
The international currency symbol. The operand shall be a four-character string, with the first three characters containing the
alphabetic international currency symbol. The international currency symbol should be chosen in accordance with those specified in
the ISO 4217 standard. The fourth character shall be the character used to separate the international currency symbol from the
monetary quantity.
currency_symbol
The string that shall be used as the local currency symbol.
mon_decimal_point
The operand is a string containing the symbol that shall be used as the decimal delimiter (radix character) in monetary
formatted quantities.
mon_thousands_sep
The operand is a string containing the symbol that shall be used as a separator for groups of digits to the left of the decimal
delimiter in formatted monetary quantities.
mon_grouping
Define the size of each group of digits in formatted monetary quantities. The operand is a sequence of integers separated by
characters. Each integer specifies the number of digits in each group, with the initial integer defining the size
of the group immediately preceding the decimal delimiter, and the following integers defining the preceding groups. If the last
integer is not -1, then the size of the previous group (if any) shall be repeatedly used for the remainder of the digits. If the
last integer is -1, then no further grouping shall be performed.
positive_sign
A string that shall be used to indicate a non-negative-valued formatted monetary quantity.
negative_sign
A string that shall be used to indicate a negative-valued formatted monetary quantity.
int_frac_digits
An integer representing the number of fractional digits (those to the right of the decimal delimiter) to be written in a
formatted monetary quantity using int_curr_symbol.
frac_digits
An integer representing the number of fractional digits (those to the right of the decimal delimiter) to be written in a
formatted monetary quantity using currency_symbol.
p_cs_precedes
An integer set to 1 if the currency_symbol precedes the value for a monetary quantity with a non-negative value, and set
to 0 if the symbol succeeds the value.
p_sep_by_space
Set to a value indicating the separation of the currency_symbol, the sign string, and the value for a non-negative
formatted monetary quantity.
The values of p_sep_by_space, n_sep_by_space, int_p_sep_by_space, and
int_n_sep_by_space are interpreted according to the following:
0
No  separates the currency symbol and value.
1
If the currency symbol and sign string are adjacent, a  separates them from the value; otherwise, a
separates the currency symbol from the value.
2
If the currency symbol and sign string are adjacent, a  separates them; otherwise, a  separates the
sign string from the value.
n_cs_precedes
An integer set to 1 if the currency_symbol precedes the value for a monetary quantity with a negative value, and set to
0 if the symbol succeeds the value.
n_sep_by_space
Set to a value indicating the separation of the currency_symbol, the sign string, and the value for a negative formatted
monetary quantity.
p_sign_posn
An integer set to a value indicating the positioning of the positive_sign for a monetary quantity with a non-negative
value. The following integer values shall be recognized for int_n_sign_posn, int_p_sign_posn, n_sign_posn, and
p_sign_posn:
0
Parentheses enclose the quantity and the currency_symbol.
1
The sign string precedes the quantity and the currency_symbol.
2
The sign string succeeds the quantity and the currency_symbol.
3
The sign string precedes the currency_symbol.
4
The sign string succeeds the currency_symbol.
n_sign_posn
An integer set to a value indicating the positioning of the negative_sign for a negative formatted monetary
quantity.
int_p_cs_precedes
An integer set to 1 if the int_curr_symbol precedes the value for a monetary quantity with a non-negative value, and set
to 0 if the symbol succeeds the value.
int_n_cs_precedes
An integer set to 1 if the int_curr_symbol precedes the value for a monetary quantity with a negative value, and set to
0 if the symbol succeeds the value.
int_p_sep_by_space
Set to a value indicating the separation of the int_curr_symbol, the sign string, and the value for a non-negative
internationally formatted monetary quantity.
int_n_sep_by_space
Set to a value indicating the separation of the int_curr_symbol, the sign string, and the value for a negative
internationally formatted monetary quantity.
int_p_sign_posn
An integer set to a value indicating the positioning of the positive_sign for a positive monetary quantity formatted
with the international format.
int_n_sign_posn
An integer set to a value indicating the positioning of the negative_sign for a negative monetary quantity formatted
with the international format.
Certain combinations of the *_sign_posn, positive_sign, and negative_sign values are invalid
and shall not be accepted by localedef:
If p_sign_posn and n_sign_posn are both greater than 0, and positive_sign and
negative_sign have the same value or are both either empty strings or omitted, this combination is invalid because it
requires signs to be used but does not provide the means to distinguish negative from positive values using signs.
Likewise, if int_p_sign_posn and int_n_sign_posn are both greater than 0, and positive_sign
and negative_sign have the same value or are both either empty strings or omitted, this combination is invalid.
If p_sign_posn and n_sign_posn are both 0, this combination is invalid because it requires
parentheses to be used but does not provide the means to distinguish negative from positive values using parentheses.
Likewise, if int_p_sign_posn and int_n_sign_posn are both 0, this combination is invalid.
7.3.3.1 LC_MONETARY Category in the POSIX Locale
The monetary formatting definitions for the POSIX locale follow; the code listing depicting the localedef input, the table representing the same information with the addition of localeconv() and nl_langinfo()
formats. All values shall be unavailable in the POSIX locale.
LC_MONETARY
# This is the POSIX locale definition for
# the LC_MONETARY category.
#
int_curr_symbol      ""
currency_symbol      ""
mon_decimal_point    ""
mon_thousands_sep    ""
mon_grouping         -1
positive_sign        ""
negative_sign        ""
int_frac_digits      -1
frac_digits          -1
p_cs_precedes        -1
p_sep_by_space       -1
n_cs_precedes        -1
n_sep_by_space       -1
p_sign_posn          -1
n_sign_posn          -1
int_p_cs_precedes    -1
int_p_sep_by_space   -1
int_n_cs_precedes    -1
int_n_sep_by_space   -1
int_p_sign_posn      -1
int_n_sign_posn      -1
#
END LC_MONETARY
Item
langinfo Constant
POSIX Locale Value
localeconv() Value
localedef Value
int_curr_symbol
—
N/A
""
""
currency_symbol
CRNCYSTR
N/A
""
""
mon_decimal_point
—
N/A
""
""
mon_thousands_sep
—
N/A
""
""
mon_grouping
—
N/A
""
-1
positive_sign
—
N/A
""
""
negative_sign
—
N/A
""
""
int_frac_digits
—
N/A
{CHAR_MAX}
-1
frac_digits
—
N/A
{CHAR_MAX}
-1
p_cs_precedes
CRNCYSTR
N/A
{CHAR_MAX}
-1
p_sep_by_space
—
N/A
{CHAR_MAX}
-1
n_cs_precedes
CRNCYSTR
N/A
{CHAR_MAX}
-1
n_sep_by_space
—
N/A
{CHAR_MAX}
-1
p_sign_posn
—
N/A
{CHAR_MAX}
-1
n_sign_posn
—
N/A
{CHAR_MAX}
-1
int_p_cs_precedes
—
N/A
{CHAR_MAX}
-1
int_p_sep_by_space
—
N/A
{CHAR_MAX}
-1
int_n_cs_precedes
—
N/A
{CHAR_MAX}
-1
int_n_sep_by_space
—
N/A
{CHAR_MAX}
-1
int_p_sign_posn
—
N/A
{CHAR_MAX}
-1
int_n_sign_posn
—
N/A
{CHAR_MAX}
-1
The entry N/A indicates that the value is not available in the POSIX locale.
7.3.4 LC_NUMERIC
The LC_NUMERIC category shall define the rules and symbols that are used to format non-monetary numeric
information. This information is available through the localeconv() function.
Some of the information is also available in an alternative form via the nl_langinfo() function.
The following items are defined in this category of the locale. The item names are the keywords recognized by the
localedef utility when defining a locale. They are also similar to the member
names of the lconv structure defined in ; see  for the exact symbols in the header. The localeconv() function returns {CHAR_MAX} for unavailable integer items and the empty
string ("") for unavailable or size zero string items.
In a locale definition file, the operands are strings, formatted as indicated by the grammar in 7.4 Locale Definition Grammar. For some keywords, the strings can only contain integers. Keywords that are not
provided, or integer keywords set to -1, can be used to indicate that the value is not available in the locale. String values set
to the empty string ("") can be used to indicate that the value is available and is an empty string, or that the value is
not available. The following keywords shall be recognized:
copy
Specify the name of an existing locale which shall be used as the definition of this category. If this keyword is specified, no
other keyword shall be specified.
Note:
This is a localedef utility keyword, unavailable through localeconv().
decimal_point
The operand is a string containing the symbol that shall be used as the decimal delimiter (radix character) in numeric,
non-monetary formatted quantities. This keyword cannot be omitted and cannot be set to the empty string. In contexts where
standards limit the decimal_point to a single byte, the result of specifying a multi-byte operand shall be unspecified.
thousands_sep
The operand is a string containing the symbol that shall be used as a separator for groups of digits to the left of the decimal
delimiter in numeric, non-monetary formatted monetary quantities. In contexts where standards limit the thousands_sep to a
single byte, the result of specifying a multi-byte operand shall be unspecified.
grouping
Define the size of each group of digits in formatted non-monetary quantities. The operand is a sequence of integers separated
by  characters. Each integer specifies the number of digits in each group, with the initial integer defining the
size of the group immediately preceding the decimal delimiter, and the following integers defining the preceding groups. If the
last integer is not -1, then the size of the previous group (if any) shall be repeatedly used for the remainder of the digits. If
the last integer is -1, then no further grouping shall be performed.
7.3.4.1 LC_NUMERIC Category in the POSIX Locale
The non-monetary numeric formatting definitions for the POSIX locale follow; the code listing depicting the
localedef input, the table representing the same information with the addition of
localeconv() values, and nl_langinfo() constants.
LC_NUMERIC
# This is the POSIX locale definition for
# the LC_NUMERIC category.
#
decimal_point    ""
thousands_sep    ""
grouping         -1
#
END LC_NUMERIC
Item
langinfo Constant
POSIX Locale Value
localeconv() Value
localedef Value
decimal_point
RADIXCHAR
"."
"."
.
thousands_sep
THOUSEP
N/A
""
""
grouping
—
N/A
""
-1
The entry N/A indicates that the value is not available in the POSIX locale.
7.3.5 LC_TIME
The LC_TIME category shall define the interpretation of the conversion specifications supported by the
date utility and shall affect the behavior of the strftime(), wcsftime(), strptime(), and nl_langinfo() functions.
Since the interfaces for C-language access and locale definition differ significantly, they are described separately.
7.3.5.1 LC_TIME Locale Definition
In a locale definition, the following mandatory keywords shall be recognized:
copy
Specify the name of an existing locale which shall be used as the definition of this category. If this keyword is specified, no
other keyword shall be specified.
abday
Define the abbreviated weekday names, corresponding to the %a conversion specification (conversion specification in
the strftime(), wcsftime(), and
strptime() functions). The operand shall consist of seven
-separated strings, each surrounded by double-quotes. The first string shall be the abbreviated name of the day
corresponding to Sunday, the second the abbreviated name of the day corresponding to Monday, and so on.
day
Define the full weekday names, corresponding to the %A conversion specification. The operand shall consist of seven
-separated strings, each surrounded by double-quotes. The first string is the full name of the day corresponding
to Sunday, the second the full name of the day corresponding to Monday, and so on.
abmon
Define the abbreviated month names, corresponding to the %b conversion specification. The operand shall consist of
twelve -separated strings, each surrounded by double-quotes. The first string shall be the abbreviated name of the
first month of the year (January), the second the abbreviated name of the second month, and so on. For languages having both a
genitive (when used with a day number) and a nominative (no day number) case, this operand shall be used to denote the genitive
case.
ab_alt_mon
Define the abbreviated month names, corresponding to the %Ob conversion specification. The operand shall consist of
twelve -separated strings, each surrounded by double-quotes. The first string shall be the abbreviated name of the
first month of the year (January), the second the abbreviated name of the second month, and so on. For languages having both a
genitive (when used with a day number) and a nominative (no day number) case, this operand shall be used to denote the nominative
case.
mon
Define the full month names, corresponding to the %B conversion specification. The operand shall consist of twelve
-separated strings, each surrounded by double-quotes. The first string shall be the full name of the first month
of the year (January), the second the full name of the second month, and so on. For languages having both a genitive (when used
with a day number) and a nominative (no day number) case, this operand shall be used to denote the genitive case.
alt_mon
Define the full month names, corresponding to the %OB conversion specification. The operand shall consist of twelve
-separated strings, each surrounded by double-quotes. The first string shall be the full name of the first month
of the year (January), the second the full name of the second month, and so on. For languages having both a genitive (when used
with a day number) and a nominative (no day number) case, this operand shall be used to denote the nominative case.
d_t_fmt
Define the appropriate date and time representation, corresponding to the %c conversion specification. The operand
shall consist of a string containing any combination of characters and conversion specifications. In addition, the string can
contain escape sequences defined in the table in Escape Sequences and Associated
Actions ('\\', '\a', '\b', '\f', '\n', '\r', '\t',
'\v').
d_fmt
Define the appropriate date representation, corresponding to the %x conversion specification. The operand shall
consist of a string containing any combination of characters and conversion specifications. In addition, the string can contain
escape sequences defined in Escape Sequences and Associated Actions
.
t_fmt
Define the appropriate time representation, corresponding to the %X conversion specification. The operand shall
consist of a string containing any combination of characters and conversion specifications. In addition, the string can contain
escape sequences defined in Escape Sequences and Associated Actions
.
am_pm
Define the appropriate representation of the ante-meridiem and post-meridiem strings, corresponding to the
%p conversion specification. The operand shall consist of two strings, separated by a , each surrounded
by double-quotes; the first string shall represent the ante-meridiem designation, the last string the post-meridiem
designation. If and only if the 12-hour format is not supported in the locale, both strings shall be empty.
t_fmt_ampm
Define the appropriate time representation in the 12-hour clock format with am_pm, corresponding to the %r
conversion specification. The operand shall consist of a string and can contain any combination of characters and conversion
specifications. If and only if the 12-hour format is not supported in the locale, the string shall be empty.
era
Define how years are counted and displayed for each era in a locale. The operand shall consist of -separated
strings. Each string shall be an era description segment with the format:
direction:offset:start_date:end_date:era_name:era_format
according to the definitions below. There can be as many era description segments as are necessary to describe the
different eras.
Note:
The start of an era might not be the earliest point in the era—it may be the latest. For example, the Christian era BC starts
on the day before January 1, AD 1, and increases with earlier time.
direction
Either a '+' or a '-' character. The '+' character shall indicate that years closer to the
start_date have lower numbers than those closer to the end_date. The '-' character shall indicate that years
closer to the start_date have higher numbers than those closer to the end_date.
offset
The number of the year closest to the start_date in the era, corresponding to the %Ey conversion
specification.
start_date
A date in the form yyyy/mm/dd, where yyyy, mm, and dd are the year, month, and day
numbers respectively of the start of the era. Years prior to AD 1 shall be represented as negative numbers.
end_date
The ending date of the era, in the same format as the start_date, or one of the two special values "-*" or
"+*". The value "-*" shall indicate that the ending date is the beginning of time. The value "+*" shall
indicate that the ending date is the end of time.
era_name
A string representing the name of the era, corresponding to the %EC conversion specification.
era_format
A string for formatting the year in the era, corresponding to the %EY conversion specification.
era_d_fmt
Define the format of the date in alternative era notation, corresponding to the %Ex conversion specification.
era_t_fmt
Define the locale's appropriate alternative time format, corresponding to the %EX conversion specification.
era_d_t_fmt
Define the locale's appropriate alternative date and time format, corresponding to the %Ec conversion
specification.
alt_digits
Define alternative symbols for digits, corresponding to the %O modified conversion specification. The operand shall
consist of -separated strings, each surrounded by double-quotes. The first string shall be the alternative symbol
corresponding with zero, the second string the symbol corresponding with one, and so on. Up to 100 alternative symbol strings can
be specified. The %O modifier shall indicate that the string corresponding to the value specified via the conversion
specification shall be used instead of the value.
7.3.5.2 LC_TIME C-Language Access
The following constants used to identify items of langinfo data can be used as arguments to the nl_langinfo() function to access information in the LC_TIME category. These
constants are defined in the  header.
ABDAY_x
The abbreviated weekday names (for example, Sun), where x is a number from 1 to 7.
DAY_x
The full weekday names (for example, Sunday), where x is a number from 1 to 7.
ABMON_x
The abbreviated month names (for example, Jan), where x is a number from 1 to 12.
ABALTMON_x
The alternative abbreviated month names (for example, Jan), where x is a number from 1 to 12.
MON_x
The full month names (for example, January), where x is a number from 1 to 12.
ALTMON_x
The alternative full month names (for example, January), where x is a number from 1 to 12.
D_T_FMT
The appropriate date and time representation.
D_FMT
The appropriate date representation.
T_FMT
The appropriate time representation.
AM_STR
The appropriate ante-meridiem affix; if AM_STR and PM_STR are both empty strings, the 12-hour format is not supported in the
locale.
PM_STR
The appropriate post-meridiem affix; if AM_STR and PM_STR are both empty strings, the 12-hour format is not supported in the
locale.
T_FMT_AMPM
The appropriate time representation in the 12-hour clock format; if the 12-hour format is not supported in the locale, this
shall be either an empty string or a string specifying a 24-hour clock format.
ERA
The era description segments, which describe how years are counted and displayed for each era in a locale. Each era description
segment shall have the format:
direction:offset:start_date:end_date:era_name:era_format
according to the definitions below. There can be as many era description segments as are necessary to describe the
different eras. Era description segments are separated by  characters.
direction
Either a '+' or a '-' character. The '+' character shall indicate that years closer to the
start_date have lower numbers than those closer to the end_date. The '-' character shall indicate that years
closer to the start_date have higher numbers than those closer to the end_date.
offset
The number of the year closest to the start_date in the era.
start_date
A date in the form yyyy/mm/dd, where yyyy, mm, and dd are the year, month, and day
numbers respectively of the start of the era. Years prior to AD 1 shall be represented as negative numbers.
end_date
The ending date of the era, in the same format as the start_date, or one of the two special values "-*" or
"+*". The value "-*" shall indicate that the ending date is the beginning of time. The value "+*" shall
indicate that the ending date is the end of time.
era_name
The era, corresponding to the %EC conversion specification.
era_format
The format of the year in the era, corresponding to the %EY conversion specification.
ERA_D_FMT
The era date format.
ERA_T_FMT
The locale's appropriate alternative time format, corresponding to the %EX conversion specification.
ERA_D_T_FMT
The locale's appropriate alternative date and time format, corresponding to the %Ec conversion specification.
ALT_DIGITS
The alternative symbols for digits, corresponding to the %O conversion specification modifier. The value consists of
-separated symbols. The first is the alternative symbol corresponding to zero, the second is the symbol
corresponding to one, and so on. Up to 100 alternative symbols may be specified.
7.3.5.3 LC_TIME Category in the POSIX Locale
The LC_TIME category definition of the POSIX locale follows; the code listing depicts the localedef input; the table represents the same information with the addition of localedef keywords, conversion specifiers used by the date utility and the strftime(), wcsftime(), and strptime() functions, and
nl_langinfo() constants.
LC_TIME
# This is the POSIX locale definition for
# the LC_TIME category.
#
# Abbreviated weekday names (%a)
abday      "";"";"";"";\
"";"";""
#
# Full weekday names (%A)
day        "";"";\
"";"";\
"";"";\
""
#
# Abbreviated month names (%b)
abmon      "";"";"";\
"";"";"";\
"";"";"";\
"";"";""
#
# Full month names (%B)
mon        "";"";\
"";"";\
"";"";\
"";"";\
"";"";\
"";""
#
# Equivalent of AM/PM (%p)      "AM";"PM"
am_pm      "";""
#
# Appropriate date and time representation (%c)
#    "%a %b %e %H:%M:%S %Y"
d_t_fmt    "\
\
\
"
#
# Appropriate date representation (%x)   "%m/%d/%y"
d_fmt      "\
"
#
# Appropriate time representation (%X)   "%H:%M:%S"
t_fmt      "\
"
#
# Appropriate 12-hour time representation (%r) "%I:%M:%S %p"
t_fmt_ampm "\
"
#
END LC_TIME
localedef Keyword
langinfo Constant
Conversion Specification
POSIX Locale Value
d_t_fmt
D_T_FMT
%c
"%a %b %e %H:%M:%S %Y"
d_fmt
D_FMT
%x
"%m/%d/%y"
t_fmt
T_FMT
%X
"%H:%M:%S"
am_pm
AM_STR
%p
"AM"
am_pm
PM_STR
%p
"PM"
t_fmt_ampm
T_FMT_AMPM
%r
"%I:%M:%S %p"
day
DAY_1
%A
"Sunday"
day
DAY_2
%A
"Monday"
day
DAY_3
%A
"Tuesday"
day
DAY_4
%A
"Wednesday"
day
DAY_5
%A
"Thursday"
day
DAY_6
%A
"Friday"
day
DAY_7
%A
"Saturday"
abday
ABDAY_1
%a
"Sun"
abday
ABDAY_2
%a
"Mon"
abday
ABDAY_3
%a
"Tue"
abday
ABDAY_4
%a
"Wed"
abday
ABDAY_5
%a
"Thu"
abday
ABDAY_6
%a
"Fri"
abday
ABDAY_7
%a
"Sat"
mon
MON_1
%B
"January"
mon
MON_2
%B
"February"
mon
MON_3
%B
"March"
mon
MON_4
%B
"April"
mon
MON_5
%B
"May"
mon
MON_6
%B
"June"
mon
MON_7
%B
"July"
mon
MON_8
%B
"August"
mon
MON_9
%B
"September"
mon
MON_10
%B
"October"
mon
MON_11
%B
"November"
mon
MON_12
%B
"December"
alt_mon
ALTMON_1
%OB
N/A
alt_mon
ALTMON_2
%OB
N/A
alt_mon
ALTMON_3
%OB
N/A
alt_mon
ALTMON_4
%OB
N/A
alt_mon
ALTMON_5
%OB
N/A
alt_mon
ALTMON_6
%OB
N/A
alt_mon
ALTMON_7
%OB
N/A
alt_mon
ALTMON_8
%OB
N/A
alt_mon
ALTMON_9
%OB
N/A
alt_mon
ALTMON_10
%OB
N/A
alt_mon
ALTMON_11
%OB
N/A
alt_mon
ALTMON_12
%OB
N/A
abmon
ABMON_1
%b
"Jan"
abmon
ABMON_2
%b
"Feb"
abmon
ABMON_3
%b
"Mar"
abmon
ABMON_4
%b
"Apr"
abmon
ABMON_5
%b
"May"
abmon
ABMON_6
%b
"Jun"
abmon
ABMON_7
%b
"Jul"
abmon
ABMON_8
%b
"Aug"
abmon
ABMON_9
%b
"Sep"
abmon
ABMON_10
%b
"Oct"
abmon
ABMON_11
%b
"Nov"
abmon
ABMON_12
%b
"Dec"
ab_alt_mon
ABALTMON_1
%Ob
N/A
ab_alt_mon
ABALTMON_2
%Ob
N/A
ab_alt_mon
ABALTMON_3
%Ob
N/A
ab_alt_mon
ABALTMON_4
%Ob
N/A
ab_alt_mon
ABALTMON_5
%Ob
N/A
ab_alt_mon
ABALTMON_6
%Ob
N/A
ab_alt_mon
ABALTMON_7
%Ob
N/A
ab_alt_mon
ABALTMON_8
%Ob
N/A
ab_alt_mon
ABALTMON_9
%Ob
N/A
ab_alt_mon
ABALTMON_10
%Ob
N/A
ab_alt_mon
ABALTMON_11
%Ob
N/A
ab_alt_mon
ABALTMON_12
%Ob
N/A
era
ERA
%EC, %Ey, %EY
N/A
era_d_fmt
ERA_D_FMT
%Ex
N/A
era_t_fmt
ERA_T_FMT
%EX
N/A
era_d_t_fmt
ERA_D_T_FMT
%Ec
N/A
alt_digits
ALT_DIGITS
%O
N/A
The entry N/A indicates the value is not available in the POSIX locale.
7.3.6 LC_MESSAGES
The LC_MESSAGES category shall define the format and values used by various utilities for affirmative and
negative responses. This information is available through the nl_langinfo()
function.
The message catalog used by the standard utilities and selected by the catopen() function shall be determined by the setting of NLSPATH ; see 8. Environment Variables. The LC_MESSAGES category can be specified as part
of an NLSPATH substitution field.
The following keywords shall be recognized as part of the locale definition file.
copy
Specify the name of an existing locale which shall be used as the definition of this category. If this keyword is specified, no
other keyword shall be specified.
Note:
This is a localedef keyword, unavailable through nl_langinfo().
yesexpr
The operand consists of an extended regular expression (see 9.4 Extended
Regular Expressions) that describes acceptable affirmative responses to a question expecting an affirmative or negative
response.
noexpr
The operand consists of an extended regular expression that describes acceptable negative responses to a question expecting an
affirmative or negative response.
7.3.6.1 LC_MESSAGES Category in the POSIX Locale
The format and values for affirmative and negative responses of the POSIX locale follow; the code listing depicting
the localedef input, the table representing the same information with the addition
of nl_langinfo() constants.
LC_MESSAGES
# This is the POSIX locale definition for
# the LC_MESSAGES category.
#
yesexpr ""
#
noexpr  ""
#
END LC_MESSAGES
localedef Keyword
langinfo Constant
POSIX Locale Value
yesexpr
YESEXPR
"^[yY]"
noexpr
NOEXPR
"^[nN]"
7.4 Locale Definition Grammar
The grammar and lexical conventions in this section shall together describe the syntax for the locale definition
source. The general conventions for this style of grammar are described in XCU 1.3 Grammar Conventions. The grammar shall take precedence over the text in
this chapter.
7.4.1 Locale Lexical Conventions
The lexical conventions for the locale definition grammar are described in this section.
The following tokens shall be processed (in addition to those string constants shown in the grammar):
LOC_NAME
A string of characters representing the name of a locale.
CHAR
Any single character.
NUMBER
A decimal number, represented by one or more decimal digits.
COLLSYMBOL
A symbolic name, enclosed between angle brackets. The string cannot duplicate any charmap symbol defined in the current charmap
(if any), or a COLLELEMENT symbol.
COLLELEMENT
A symbolic name, enclosed between angle brackets, which cannot duplicate either any charmap symbol or a COLLSYMBOL
symbol.
CHARCLASS
A string of alphanumeric characters from the portable character set, the first of which is not a digit, consisting of at least
one and at most {CHARCLASS_NAME_MAX} bytes, and optionally surrounded by double-quotes.
CHARSYMBOL
A symbolic name, enclosed between angle brackets, from the current charmap (if any).
OCTAL_CHAR
One or more octal representations of the encoding of each byte in a single character. The octal representation consists of an
escape character (normally a ) followed by two or more octal digits.
HEX_CHAR
One or more hexadecimal representations of the encoding of each byte in a single character. The hexadecimal representation
consists of an escape character followed by the constant x and two or more hexadecimal digits.
DECIMAL_CHAR
One or more decimal representations of the encoding of each byte in a single character. The decimal representation consists of
an escape character followed by a character 'd' and two or more decimal digits.
ELLIPSIS
The string "...".
EXTENDED_REG_EXP
An extended regular expression as defined in the grammar in 9.5 Regular
Expression Grammar.
EOL
The line termination character .
7.4.2 Locale Grammar
This section presents the grammar for the locale definition.
%token              LOC_NAME
%token              CHAR
%token              NUMBER
%token              COLLSYMBOL COLLELEMENT
%token              CHARSYMBOL OCTAL_CHAR HEX_CHAR DECIMAL_CHAR
%token              ELLIPSIS
%token              EXTENDED_REG_EXP
%token              EOL
%start              locale_definition
%%
locale_definition   : global_statements locale_categories
|                   locale_categories
;
global_statements   : global_statements symbol_redefine
| symbol_redefine
;
symbol_redefine     : 'escape_char'  CHAR EOL
| 'comment_char' CHAR EOL
;
locale_categories   : locale_categories locale_category
| locale_category
;
locale_category     : lc_ctype | lc_collate | lc_messages
| lc_monetary | lc_numeric | lc_time
;
/* The following grammar rules are common to all categories */
char_list           : char_list char_symbol
| char_symbol
;
char_symbol         : CHAR | CHARSYMBOL
| OCTAL_CHAR | HEX_CHAR | DECIMAL_CHAR
;
elem_list           : elem_list char_symbol
| elem_list COLLSYMBOL
| elem_list COLLELEMENT
| char_symbol
| COLLSYMBOL
| COLLELEMENT
;
symb_list           : symb_list COLLSYMBOL
| COLLSYMBOL
;
locale_name         : LOC_NAME
| '"' LOC_NAME '"'
;
/* The following is the LC_CTYPE category grammar */
lc_ctype            : ctype_hdr ctype_keywords         ctype_tlr
| ctype_hdr 'copy' locale_name EOL ctype_tlr
;
ctype_hdr           : 'LC_CTYPE' EOL
;
ctype_keywords      : ctype_keywords ctype_keyword
| ctype_keyword
;
ctype_keyword       : charclass_keyword charclass_list EOL
| charconv_keyword charconv_list EOL
| 'charclass' charclass_namelist EOL
;
charclass_namelist  : charclass_namelist ';' CHARCLASS
| CHARCLASS
;
charclass_keyword   : 'upper' | 'lower' | 'alpha' | 'digit'
| 'punct' | 'xdigit' | 'space' | 'print'
| 'graph' | 'blank' | 'cntrl' | 'alnum'
| CHARCLASS
;
charclass_list      : charclass_list ';' char_symbol
| charclass_list ';' ELLIPSIS ';' char_symbol
| char_symbol
;
charconv_keyword    : 'toupper'
| 'tolower'
;
charconv_list       : charconv_list ';' charconv_entry
| charconv_entry
;
charconv_entry      : '(' char_symbol ',' char_symbol ')'
;
ctype_tlr           : 'END' 'LC_CTYPE' EOL
;
/* The following is the LC_COLLATE category grammar */
lc_collate          : collate_hdr collate_keywords       collate_tlr
| collate_hdr 'copy' locale_name EOL collate_tlr
;
collate_hdr         : 'LC_COLLATE' EOL
;
collate_keywords    :                order_statements
| opt_statements order_statements
;
opt_statements      : opt_statements collating_symbols
| opt_statements collating_elements
| collating_symbols
| collating_elements
;
collating_symbols   : 'collating-symbol' COLLSYMBOL EOL
;
collating_elements  : 'collating-element' COLLELEMENT
| 'from' '"' elem_list '"' EOL
;
order_statements    : order_start collation_order order_end
;
order_start         : 'order_start' EOL
| 'order_start' order_opts EOL
;
order_opts          : order_opts ';' order_opt
| order_opt
;
order_opt           : order_opt ',' opt_word
| opt_word
;
opt_word            : 'forward' | 'backward' | 'position'
;
collation_order     : collation_order collation_entry
| collation_entry
;
collation_entry     : COLLSYMBOL EOL
| collation_element weight_list EOL
| collation_element             EOL
;
collation_element   : char_symbol
| COLLELEMENT
| ELLIPSIS
| 'UNDEFINED'
;
weight_list         : weight_list ';' weight_symbol
| weight_list ';'
| weight_symbol
;
weight_symbol       : /* empty */
| char_symbol
| COLLSYMBOL
| '"' elem_list '"'
| '"' symb_list '"'
| ELLIPSIS
| 'IGNORE'
;
order_end           : 'order_end' EOL
;
collate_tlr         : 'END' 'LC_COLLATE' EOL
;
/* The following is the LC_MESSAGES category grammar */
lc_messages         : messages_hdr messages_keywords      messages_tlr
| messages_hdr 'copy' locale_name EOL messages_tlr
;
messages_hdr        : 'LC_MESSAGES' EOL
;
messages_keywords   : messages_keywords messages_keyword
| messages_keyword
;
messages_keyword    : 'yesexpr' '"' EXTENDED_REG_EXP '"' EOL
| 'noexpr'  '"' EXTENDED_REG_EXP '"' EOL
;
messages_tlr        : 'END' 'LC_MESSAGES' EOL
;
/* The following is the LC_MONETARY category grammar */
lc_monetary         : monetary_hdr monetary_keywords       monetary_tlr
| monetary_hdr 'copy' locale_name EOL  monetary_tlr
;
monetary_hdr        : 'LC_MONETARY' EOL
;
monetary_keywords   : monetary_keywords monetary_keyword
| monetary_keyword
;
monetary_keyword    : mon_keyword_string mon_string EOL
| mon_keyword_char NUMBER EOL
| mon_keyword_char '-1'   EOL
| mon_keyword_grouping mon_group_list EOL
;
mon_keyword_string  : 'int_curr_symbol' | 'currency_symbol'
| 'mon_decimal_point' | 'mon_thousands_sep'
| 'positive_sign' | 'negative_sign'
;
mon_string          : '"' char_list '"'
| '""'
;
mon_keyword_char    : 'int_frac_digits' | 'frac_digits'
| 'p_cs_precedes' | 'p_sep_by_space'
| 'n_cs_precedes' | 'n_sep_by_space'
| 'p_sign_posn' | 'n_sign_posn'
| 'int_p_cs_precedes' | 'int_p_sep_by_space'
| 'int_n_cs_precedes' | 'int_n_sep_by_space'
| 'int_p_sign_posn' | 'int_n_sign_posn'
;
mon_keyword_grouping : 'mon_grouping'
;
mon_group_list      : NUMBER
| mon_group_list ';' NUMBER
;
monetary_tlr        : 'END' 'LC_MONETARY' EOL
;
/* The following is the LC_NUMERIC category grammar */
lc_numeric          : numeric_hdr numeric_keywords       numeric_tlr
| numeric_hdr 'copy' locale_name EOL numeric_tlr
;
numeric_hdr         : 'LC_NUMERIC' EOL
;
numeric_keywords    : numeric_keywords numeric_keyword
| numeric_keyword
;
numeric_keyword     : num_keyword_string num_string EOL
| num_keyword_grouping num_group_list EOL
;
num_keyword_string  : 'decimal_point'
| 'thousands_sep'
;
num_string          : '"' char_list '"'
| '""'
;
num_keyword_grouping: 'grouping'
;
num_group_list      : NUMBER
| num_group_list ';' NUMBER
;
numeric_tlr         : 'END' 'LC_NUMERIC' EOL
;
/* The following is the LC_TIME category grammar */
lc_time             : time_hdr time_keywords          time_tlr
| time_hdr 'copy' locale_name EOL time_tlr
;
time_hdr            : 'LC_TIME' EOL
;
time_keywords       : time_keywords time_keyword
| time_keyword
;
time_keyword        : time_keyword_name time_list EOL
| time_keyword_fmt time_string EOL
| time_keyword_opt time_list EOL
;
time_keyword_name   : 'abday' | 'day' | 'abmon' | 'mon'
;
time_keyword_fmt    : 'd_t_fmt' | 'd_fmt' | 't_fmt'
| 'am_pm' | 't_fmt_ampm'
;
time_keyword_opt    : 'era' | 'era_d_fmt' | 'era_t_fmt'
| 'era_d_t_fmt' | 'alt_digits'
| 'ab_alt_mon' | 'alt_mon'
;
time_list           : time_list ';' time_string
| time_string
;
time_string         : '"' char_list '"'
;
time_tlr            : 'END' 'LC_TIME' EOL
;
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/stdatomic.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
stdatomic.h — atomics
SYNOPSIS
#include
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
Implementations that define the macro __STDC_NO_ATOMICS__ need not provide this header nor support any of its facilities.
The  header shall define the atomic_flag type as a structure type. This type provides the
classic test-and-set functionality. It shall have two states, set and clear. Operations on an object of type atomic_flag
shall be lock free.
The  header shall define each of the atomic integer types in the following table as a type that has
the same representation and alignment requirements as the corresponding direct type.
Note:
The same representation and alignment requirements are meant to imply interchangeability as arguments to functions, return
values from functions, and members of unions.
Atomic type name
Direct type
atomic_bool
_Atomic _Bool
atomic_char
_Atomic char
atomic_schar
_Atomic signed char
atomic_uchar
_Atomic unsigned char
atomic_short
_Atomic short
atomic_ushort
_Atomic unsigned short
atomic_int
_Atomic int
atomic_uint
_Atomic unsigned int
atomic_long
_Atomic long
atomic_ulong
_Atomic unsigned long
atomic_llong
_Atomic long long
atomic_ullong
_Atomic unsigned long long
atomic_char16_t
_Atomic char16_t
atomic_char32_t
_Atomic char32_t
atomic_wchar_t
_Atomic wchar_t
atomic_int_least8_t
_Atomic int_least8_t
atomic_uint_least8_t
_Atomic uint_least8_t
atomic_int_least16_t
_Atomic int_least16_t
atomic_uint_least16_t
_Atomic uint_least16_t
atomic_int_least32_t
_Atomic int_least32_t
atomic_uint_least32_t
_Atomic uint_least32_t
atomic_int_least64_t
_Atomic int_least64_t
atomic_uint_least64_t
_Atomic uint_least64_t
atomic_int_fast8_t
_Atomic int_fast8_t
atomic_uint_fast8_t
_Atomic uint_fast8_t
atomic_int_fast16_t
_Atomic int_fast16_t
atomic_uint_fast16_t
_Atomic uint_fast16_t
atomic_int_fast32_t
_Atomic int_fast32_t
atomic_uint_fast32_t
_Atomic uint_fast32_t
atomic_int_fast64_t
_Atomic int_fast64_t
atomic_uint_fast64_t
_Atomic uint_fast64_t
atomic_intptr_t
_Atomic intptr_t
atomic_uintptr_t
_Atomic uintptr_t
atomic_size_t
_Atomic size_t
atomic_ptrdiff_t
_Atomic ptrdiff_t
atomic_intmax_t
_Atomic intmax_t
atomic_uintmax_t
_Atomic uintmax_t
The  header shall define the memory_order type as an enumerated type whose
enumerators shall include at least the following:
memory_order_relaxed
memory_order_consume
memory_order_acquire
memory_order_release
memory_order_acq_rel
memory_order_seq_cst
The  header shall define the following atomic lock-free macros:
ATOMIC_BOOL_LOCK_FREE
ATOMIC_CHAR_LOCK_FREE
ATOMIC_CHAR16_T_LOCK_FREE
ATOMIC_CHAR32_T_LOCK_FREE
ATOMIC_WCHAR_T_LOCK_FREE
ATOMIC_SHORT_LOCK_FREE
ATOMIC_INT_LOCK_FREE
ATOMIC_LONG_LOCK_FREE
ATOMIC_LLONG_LOCK_FREE
ATOMIC_POINTER_LOCK_FREE
which shall expand to constant expressions suitable for use in #if preprocessing directives and which shall
indicate the lock-free property of the corresponding atomic types (both signed and unsigned). A value of 0 shall indicate that the
type is never lock-free; a value of 1 shall indicate that the type is sometimes lock-free; a value of 2 shall indicate that the
type is always lock-free.
The  header shall define the macro ATOMIC_FLAG_INIT which shall expand to an initializer
for an object of type atomic_flag. This macro shall initialize an atomic_flag to the clear state. An
atomic_flag that is not explicitly initialized with ATOMIC_FLAG_INIT is initially in an indeterminate state.
[OB]  The  header shall define the macro ATOMIC_VAR_INIT(value) which shall expand to a
token sequence suitable for initializing an atomic object of a type that is initialization-compatible with the non-atomic type of
its value argument.   An atomic object with automatic
storage duration that is not explicitly initialized is initially in an indeterminate state.
The  header shall define the macro kill_dependency() which shall behave as described in kill_dependency().
The  header shall declare the following generic functions, where A refers to an
atomic type, C refers to its corresponding non-atomic type, and M is C for atomic integer types or
ptrdiff_t for atomic pointer types.
_Bool   atomic_compare_exchange_strong(volatile A *, C *, C);
_Bool   atomic_compare_exchange_strong_explicit(volatile A *, C *, C, memory_order, memory_order);
_Bool   atomic_compare_exchange_weak(volatile A *, C *, C);
_Bool   atomic_compare_exchange_weak_explicit(volatile A *, C *, C, memory_order, memory_order);
C       atomic_exchange(volatile A *, C);
C       atomic_exchange_explicit(volatile A *, C, memory_order);
C       atomic_fetch_add(volatile A *, M);
C       atomic_fetch_add_explicit(volatile A *, M, memory_order);
C       atomic_fetch_and(volatile A *, M);
C       atomic_fetch_and_explicit(volatile A *, M, memory_order);
C       atomic_fetch_or(volatile A *, M);
C       atomic_fetch_or_explicit(volatile A *, M, memory_order);
C       atomic_fetch_sub(volatile A *, M);
C       atomic_fetch_sub_explicit(volatile A *, M, memory_order);
C       atomic_fetch_xor(volatile A *, M);
C       atomic_fetch_xor_explicit(volatile A *, M, memory_order);
void    atomic_init(volatile A *, C);
_Bool   atomic_is_lock_free(const volatile A *);
C       atomic_load(const volatile A *);
C       atomic_load_explicit(const volatile A *, memory_order);
void    atomic_store(volatile A *, C);
void    atomic_store_explicit(volatile A *, C, memory_order);
It is unspecified whether any generic function declared in  is a macro or an identifier
declared with external linkage. If a macro definition is suppressed in order to access an actual function, or a program defines an
external identifier with the name of a generic function, the behavior is undefined.
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be
provided.
void    atomic_flag_clear(volatile atomic_flag *);
void    atomic_flag_clear_explicit(volatile atomic_flag *,
memory_order);
_Bool   atomic_flag_test_and_set(volatile atomic_flag *);
_Bool   atomic_flag_test_and_set_explicit(
volatile atomic_flag *, memory_order);
void    atomic_signal_fence(memory_order);
void    atomic_thread_fence(memory_order);
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
Since operations on the atomic_flag type are lock free, the operations should also be address-free. No other type
requires lock-free operations, so the atomic_flag type is the minimum hardware-implemented type needed to conform to this
standard. The remaining types can be emulated with atomic_flag, though with less than ideal properties.
The representation of atomic integer types need not have the same size as their corresponding regular types. They
should have the same size whenever possible, as it eases effort required to port existing code.
FUTURE DIRECTIONS
The ISO C standard states that the macro ATOMIC_VAR_INIT is an obsolescent feature. This macro may be removed in a future
version of this standard.
SEE ALSO
4.15.1 Memory Ordering
XSH atomic_compare_exchange_strong(),
atomic_exchange(), atomic_fetch_add(), atomic_flag_clear(), atomic_flag_test_and_set(), atomic_init(), atomic_is_lock_free(), atomic_load(), atomic_signal_fence(), atomic_store(), kill_dependency().
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/V1_chap11.html =====
General Terminal Interface
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
11. General Terminal Interface
This chapter describes a general terminal interface that shall be provided. It shall be supported on any asynchronous
communications ports if the implementation provides them. It is implementation-defined whether it supports network connections or
synchronous ports, or both.
11.1 Interface Characteristics
11.1.1 Opening a Terminal Device File
When a terminal device file is opened, it normally causes the thread to wait until a connection is established. In practice,
application programs seldom open these files; they are opened by special programs and become an application's standard input,
output, and error files.
Cases where applications do open a terminal device are as follows:
Opening /dev/tty, or the pathname returned by ctermid(), in order to
obtain a file descriptor for the controlling terminal; see 11.1.3 The Controlling Terminal.
Opening the subsidiary side of a pseudo-terminal; see XSH ptsname().
Opening a modem or similar piece of equipment connected by a serial line. In this case, the terminal parameters (see 11.2 Parameters that Can be Set) may be initialized to default settings by the implementation in between the last
close of the device by any process and the next open of the device, or they may persist from one use to the next. The terminal
parameters can be set to values that ensure the terminal behaves in a conforming manner by means of the O_TTY_INIT open flag when
opening a terminal device that is not already open in any process, or by executing the stty utility with the operand sane.
As described in open(), opening a terminal device file with the O_NONBLOCK flag
clear shall cause the thread to block until the terminal device is ready and available. If CLOCAL mode is not set, this means
blocking until a connection is established. If CLOCAL mode is set in the terminal, or the O_NONBLOCK flag is specified in the
open(), the open() function shall return a
file descriptor without waiting for a connection to be established.
11.1.2 Process Groups
A terminal may have a foreground process group associated with it. This foreground process group plays a special role in
handling signal-generating input characters, as discussed in 11.1.9 Special Characters.
A command interpreter process supporting job control can allocate the terminal to different jobs, or process groups, by placing
related processes in a single process group and associating this process group with the terminal. A terminal's foreground process
group may be set or examined by a process, assuming the permission requirements are met; see tcgetpgrp() and tcsetpgrp(). The terminal
interface aids in this allocation by restricting access to the terminal by processes that are not in the current process group; see
11.1.4 Terminal Access Control.
When there is no longer any process whose process ID or process group ID matches the foreground process group ID, the terminal
shall have no foreground process group. It is unspecified whether the terminal has a foreground process group when there is a
process whose process ID matches the foreground process group ID, but whose process group ID does not. No actions defined in
POSIX.1-2024, other than allocation of a controlling terminal or a successful call to tcsetpgrp(), shall cause a process group to become the foreground process group of the
terminal.
11.1.3 The Controlling Terminal
A terminal may belong to a process as its controlling terminal. Each process of a session that has a controlling terminal has
the same controlling terminal. A terminal may be the controlling terminal for at most one session. The controlling terminal for a
session is allocated by the session leader in an implementation-defined manner. If a session leader has no controlling terminal,
and opens a terminal device file that is not already associated with a session without using the O_NOCTTY option (see open()), it is implementation-defined whether the terminal becomes the controlling terminal of
the session leader. If a process which is not a session leader opens a terminal file, or the O_NOCTTY option is used on open(), then that terminal shall not become the controlling terminal of the calling process.
When a controlling terminal becomes associated with a session, its foreground process group shall be set to the process group of
the session leader.
The controlling terminal is inherited by a child process during a fork() function
call. A process relinquishes its controlling terminal when it creates a new session with the setsid() function; other processes remaining in the old session that had this terminal as
their controlling terminal continue to have it. Upon the close of the last file descriptor in the system (whether or not it is in
the current session) associated with the controlling terminal, it is unspecified whether all processes that had that terminal as
their controlling terminal cease to have any controlling terminal. Whether and how a session leader can reacquire a controlling
terminal after the controlling terminal has been relinquished in this fashion is unspecified. A process does not relinquish its
controlling terminal simply by closing all of its file descriptors associated with the controlling terminal if other processes
continue to have it open.
When a controlling process terminates, the controlling terminal is dissociated from the current session, allowing it to be
acquired by a new session leader. Subsequent access to the terminal by other processes in the earlier session may be denied, with
attempts to access the terminal treated as if a modem disconnect had been sensed.
11.1.4 Terminal Access Control
If a process is in the foreground process group of its controlling terminal, read operations shall be allowed, as described in
11.1.5 Input Processing and Reading Data. Any attempts by a process in a background process group to
read from its controlling terminal cause its process group to be sent a SIGTTIN signal unless one of the following special cases
applies: if the reading process is ignoring the SIGTTIN signal or the reading thread is blocking the SIGTTIN signal, or if the
process group of the reading process is orphaned, the read() shall return -1, with
errno set to [EIO] and no signal shall be sent. The default action of the SIGTTIN signal shall be to stop the process to
which it is sent. See .
If a process is in the foreground process group of its controlling terminal, write operations shall be allowed as described in
11.1.8 Writing Data and Output Processing. Attempts by a process in a background process group to
write to its controlling terminal shall cause the process group to be sent a SIGTTOU signal unless one of the following special
cases applies: if TOSTOP is not set, or if TOSTOP is set and the process is ignoring the SIGTTOU signal or the writing thread is
blocking the SIGTTOU signal, the process is allowed to write to the terminal and the SIGTTOU signal is not sent. If TOSTOP is set,
the process group of the writing process is orphaned, the writing process is not ignoring the SIGTTOU signal, and the writing
thread is not blocking the SIGTTOU signal, the write() shall return -1, with
errno set to [EIO] and no signal shall be sent.
Certain calls that set terminal parameters are treated in the same fashion as write(), except that TOSTOP is ignored; that is, the effect is identical to that of terminal
writes when TOSTOP is set (see 11.2.5 Local Modes, tcdrain(), tcflow(), tcflush(), tcsendbreak(), tcsetattr(), tcsetpgrp(), and tcsetwinsize()).
11.1.5 Input Processing and Reading Data
A terminal device associated with a terminal device file may operate in full-duplex mode, so that data may arrive even while
output is occurring. Each terminal device file has an input queue associated with it, into which incoming data is stored by the
system before being read by a process. The system may impose a limit, {MAX_INPUT}, on the number of bytes that may be stored in the
input queue. The behavior of the system when this limit is exceeded is implementation-defined.
Two general kinds of input processing are available, determined by whether the terminal device file is in canonical mode or
non-canonical mode. These modes are described in 11.1.6 Canonical Mode Input Processing and 11.1.7 Non-Canonical Mode Input Processing. Additionally, input characters are processed according to the
c_iflag (see 11.2.2 Input Modes) and c_lflag (see 11.2.5 Local
Modes) fields. Such processing can include "echoing", which in general means transmitting input characters immediately back
to the terminal when they are received from the terminal. This is useful for terminals that can operate in full-duplex mode.
The manner in which data is provided to a process reading from a terminal device file is dependent on whether the terminal file
is in canonical or non-canonical mode, and on whether or not the O_NONBLOCK flag is set by open() or fcntl().
If the O_NONBLOCK flag is clear, then the read request shall be blocked until data is available or a signal has been received.
If the O_NONBLOCK flag is set, then the read request shall be completed, without blocking, in one of three ways:
If there is enough data available to satisfy the entire request, the read() shall
complete successfully and shall return the number of bytes read.
If there is not enough data available to satisfy the entire request, the read()
shall complete successfully, having read as much data as possible, and shall return the number of bytes it was able to read.
If there is no data available, the read() shall return -1, with errno set to
[EAGAIN].
When data is available depends on whether the input processing mode is canonical or non-canonical. 11.1.6 Canonical Mode Input Processing and 11.1.7 Non-Canonical Mode Input
Processing describe each of these input processing modes.
11.1.6 Canonical Mode Input Processing
In canonical mode input processing, terminal input is processed in units of lines. A line is delimited by a
character (NL), an end-of-file character (EOF), or an end-of-line (EOL) character. See 11.1.9 Special
Characters for more information on EOF and EOL. This means that a read request shall not return until an entire line has been
typed or a signal has been received. Also, no matter how many bytes are requested in the read() call, at most one line shall be returned. It is not, however, necessary to read a whole
line at once; any number of bytes, even one, may be requested in a read() without
losing information.
If {MAX_CANON} is defined for this terminal device, it shall be a limit on the number of bytes in a line. The behavior of the
system when this limit is exceeded is implementation-defined. If {MAX_CANON} is not defined, there shall be no such limit; see
pathconf().
Erase and kill processing occur when either of two special characters, the ERASE and KILL characters (see 11.1.9 Special Characters), is received. This processing shall affect data in the input queue that has not yet
been delimited by an NL, EOF, or EOL character. This un-delimited data makes up the current line. The ERASE character shall delete
the last character in the current line, if there is one. The KILL character shall delete all data in the current line, if there is
any. The ERASE and KILL characters shall have no effect if there is no data in the current line. The ERASE and KILL characters
themselves shall not be placed in the input queue.
11.1.7 Non-Canonical Mode Input Processing
In non-canonical mode input processing, input bytes are not assembled into lines, and erase and kill processing shall not occur.
The values of the MIN and TIME members of the c_cc array are used to determine how to process the bytes received.
POSIX.1-2024 does not specify whether the setting of O_NONBLOCK takes precedence over MIN or TIME settings. Therefore, if
O_NONBLOCK is set, read() may return immediately, regardless of the setting of MIN or
TIME. Also, if no data is available, read() may either return 0, or return -1 with
errno set to [EAGAIN].
MIN represents the minimum number of bytes that should be received when the read()
function returns successfully. TIME is a timer of 0.1 second granularity that is used to time out bursty and short-term data
transmissions. If MIN is greater than {MAX_INPUT}, the response to the request is undefined. The four possible values for MIN and
TIME and their interactions are described below.
Case A: MIN>0, TIME>0
In case A, TIME serves as an inter-byte timer which shall be activated after the first byte is received. Since it is an
inter-byte timer, it shall be reset after a byte is received. The interaction between MIN and TIME is as follows. As soon as one
byte is received, the inter-byte timer shall be started. If MIN bytes are received before the inter-byte timer expires (remember
that the timer is reset upon receipt of each byte), the read shall be satisfied. If the timer expires before MIN bytes are
received, the characters received to that point shall be returned to the user. Note that if TIME expires at least one byte shall be
returned because the timer would not have been enabled unless a byte was received. In this case (MIN>0, TIME>0) the read
shall block until the MIN and TIME mechanisms are activated by the receipt of the first byte, or a signal is received. If data is
in the buffer at the time of the read(), the result shall be as if data has been
received immediately after the read().
Case B: MIN>0, TIME=0
In case B, since the value of TIME is zero, the timer plays no role and only MIN is significant. A pending read shall not be
satisfied until MIN bytes are received (that is, the pending read shall block until MIN bytes are received), or a signal is
received. A program that uses case B to read record-based terminal I/O may block indefinitely in the read operation.
Case C: MIN=0, TIME>0
In case C, since MIN=0, TIME no longer represents an inter-byte timer. It now serves as a read timer that shall be activated as
soon as the read() function is processed. A read shall be satisfied as soon as a single
byte is received or the read timer expires. Note that in case C if the timer expires, no bytes shall be returned. If the timer does
not expire, the only way the read can be satisfied is if a byte is received. If bytes are not received, the read shall not block
indefinitely waiting for a byte; if no byte is received within TIME*0.1 seconds after the read is initiated, the read() shall return a value of zero, having read no data. If data is in the buffer at the time
of the read(), the timer shall be started as if data has been received immediately
after the read().
Case D: MIN=0, TIME=0
The minimum of either the number of bytes requested or the number of bytes currently available shall be returned without waiting
for more bytes to be input. If no characters are available, read() shall return a value
of zero, having read no data.
11.1.8 Writing Data and Output Processing
When a process writes one or more bytes to a terminal device file, they are processed according to the c_oflag field (see
11.2.3 Output Modes). The implementation may provide a buffering mechanism; as such, when a call to
write() completes, all of the bytes written have been scheduled for transmission to
the device, but the transmission has not necessarily completed. See write() for the
effects of O_NONBLOCK on write().
11.1.9 Special Characters
Certain characters have special functions on input or output or both. These functions are summarized as follows:
INTR
Special character on input, which is recognized if the ISIG flag is set. Generates a SIGINT signal which is sent to all
processes in the foreground process group for which the terminal is the controlling terminal. If ISIG is set, the INTR character
shall be discarded when processed.
QUIT
Special character on input, which is recognized if the ISIG flag is set. Generates a SIGQUIT signal which is sent to all
processes in the foreground process group for which the terminal is the controlling terminal. If ISIG is set, the QUIT character
shall be discarded when processed.
ERASE
Special character on input, which is recognized if the ICANON flag is set. Erases the last character in the current line; see
11.1.6 Canonical Mode Input Processing. It shall not erase beyond the start of a line, as delimited by
an NL, EOF, or EOL character. If ICANON is set, the ERASE character shall be discarded when processed.
KILL
Special character on input, which is recognized if the ICANON flag is set. Deletes the entire line, as delimited by an NL, EOF,
or EOL character. If ICANON is set, the KILL character shall be discarded when processed.
EOF
Special character on input, which is recognized if the ICANON flag is set. When received, all the bytes waiting to be read are
immediately passed to the process without waiting for a , and the EOF is discarded. Thus, if there are no bytes
waiting (that is, the EOF occurred at the beginning of a line), a byte count of zero shall be returned from the read(), representing an end-of-file indication. If ICANON is set, the EOF character shall be
discarded when processed.
NL
Special character on input, which is recognized if the ICANON flag is set. It is the line delimiter . It cannot
be changed.
EOL
Special character on input, which is recognized if the ICANON flag is set. It is an additional line delimiter, like NL.
SUSP
If the ISIG flag is set, receipt of the SUSP character shall cause a SIGTSTP signal to be sent to all processes in the
foreground process group for which the terminal is the controlling terminal, and the SUSP character shall be discarded when
processed.
STOP
Special character on both input and output, which is recognized if the IXON (output control) or IXOFF (input control) flag is
set. Can be used to suspend output temporarily. It is useful with CRT terminals to prevent output from disappearing before it can
be read. If IXON is set, the STOP character shall be discarded when processed.
START
Special character on both input and output, which is recognized if the IXON (output control) or IXOFF (input control) flag is
set. Can be used to resume output that has been suspended by a STOP character. If IXON is set, the START character shall be
discarded when processed.
CR
Special character on input, which is recognized if the ICANON flag is set; it is the  character. When
ICANON and ICRNL are set and IGNCR is not set, this character shall be translated into an NL, and shall have the same effect as an
NL character. It cannot be changed.
The NL and CR characters cannot be changed. It is implementation-defined whether the START and STOP characters can be changed.
The values for INTR, QUIT, ERASE, KILL, EOF, EOL, and SUSP shall be changeable to suit individual tastes. Special character
functions associated with changeable special control characters can be disabled individually.
If two or more special characters have the same value, the function performed when that character is received is undefined.
A special character is recognized not only by its value, but also by its context; for example, an implementation may support
multi-byte sequences that have a meaning different from the meaning of the bytes when considered individually. Implementations may
also support additional single-byte functions. These implementation-defined multi-byte or single-byte functions shall be recognized
only if the IEXTEN flag is set; otherwise, data is received without interpretation, except as required to recognize the special
characters defined in this section.
[XSI]
If IEXTEN is set, the ERASE, KILL, and EOF characters can be escaped by a preceding  character, in which case no
special function shall occur.
11.1.10 Modem Disconnect
If a modem disconnect is detected by the terminal interface for a controlling terminal, and if CLOCAL is not set in the
c_cflag field for the terminal (see 11.2.4 Control Modes), the SIGHUP signal shall be sent to
the controlling process for which the terminal is the controlling terminal. Unless other arrangements have been made, this shall
cause the controlling process to terminate (see exit()). Any subsequent read from the
terminal device shall return the value of zero, indicating end-of-file; see read().
Thus, processes that read a terminal file and test for end-of-file can terminate appropriately after a disconnect. If the EIO
condition as specified in read() also exists, it is unspecified whether on EOF
condition or [EIO] is returned. Any subsequent write() to the terminal device shall
return -1, with errno set to [EIO], until the device is closed.
11.1.11 Closing a Terminal Device File
The last process to close a terminal device file shall cause any output to be sent to the device and shall cause any input to be
discarded. If HUPCL is set in the control modes and the communications port supports a disconnect function, the terminal device
shall perform a disconnect.
11.2 Parameters that Can be Set
11.2.1 The termios Structure
Routines that need to control certain terminal I/O characteristics shall do so by using the termios structure as defined
in the  header.
Since the termios structure may include additional members, and the standard members may include both standard and
non-standard modes, the structure should never be initialized directly by the application as this may cause the terminal to behave
in a non-conforming manner. When opening a terminal device (other than a pseudo-terminal) that is not already open in any process,
it should be opened with the O_TTY_INIT flag before initializing the structure using tcgetattr() to ensure that any non-standard elements of the termios structure are
set to values that result in conforming behavior of the terminal interface.
The members of the termios structure include (but are not limited to):
Member Type
Array Size
Member Name
Description
tcflag_t
c_iflag
Input modes.
tcflag_t
c_oflag
Output modes.
tcflag_t
c_cflag
Control modes.
tcflag_t
c_lflag
Local modes.
cc_t
NCCS
c_cc[]
Control characters.
The tcflag_t and cc_t types are defined in the  header. They shall be unsigned integer types.
11.2.2 Input Modes
Values of the c_iflag field describe the basic terminal input control, and are composed of the
bitwise-inclusive OR of the masks shown, which shall be bitwise-distinct. The mask name symbols in this table are defined in
:
Mask Name
Description
BRKINT
Signal interrupt on break.
ICRNL
Map CR to NL on input.
IGNBRK
Ignore break condition.
IGNCR
Ignore CR.
IGNPAR
Ignore characters with parity errors.
INLCR
Map NL to CR on input.
INPCK
Enable input parity check.
ISTRIP
Strip character.
IXANY
Enable any character to restart output.
IXOFF
Enable start/stop input control.
IXON
Enable start/stop output control.
PARMRK
Mark parity errors.
In the context of asynchronous serial data transmission, a break condition shall be defined as a sequence of
zero-valued bits that continues for more than the time to send one byte. The entire sequence of zero-valued bits is interpreted as
a single break condition, even if it continues for a time equivalent to more than one byte. In contexts other than asynchronous
serial data transmission, the definition of a break condition is implementation-defined.
If IGNBRK is set, a break condition detected on input shall be ignored; that is, not put on the input queue and
therefore not read by any process. If IGNBRK is not set and BRKINT is set, the break condition shall flush the input and output
queues, and if the terminal is the controlling terminal of a foreground process group, the break condition shall generate a single
SIGINT signal to that foreground process group. If neither IGNBRK nor BRKINT is set, a break condition shall be read as a single
0x00, or if PARMRK is set, as 0xff 0x00 0x00.
If IGNPAR is set, a byte with a framing or parity error (other than break) shall be ignored.
If PARMRK is set, and IGNPAR is not set, a byte with a framing or parity error (other than break) shall be given to
the application as the three-byte sequence 0xff 0x00 X, where 0xff 0x00 is a two-byte flag preceding each sequence and X is the
data of the byte received in error. To avoid ambiguity in this case, if ISTRIP is not set, a valid byte of 0xff is given to the
application as 0xff 0xff. If neither PARMRK nor IGNPAR is set, a framing or parity error (other than break) shall be given to the
application as a single byte 0x00.
If INPCK is set, input parity checking shall be enabled. If INPCK is not set, input parity checking shall be
disabled, allowing output parity generation without input parity errors. Note that whether input parity checking is enabled or
disabled is independent of whether parity detection is enabled or disabled (see 11.2.4 Control Modes).
If parity detection is enabled but input parity checking is disabled, the hardware to which the terminal is connected shall
recognize the parity bit, but the terminal special file shall not check whether or not this bit is correctly set.
If ISTRIP is set, valid input bytes shall first be stripped to seven bits; otherwise, all eight bits shall be
processed.
If INLCR is set, a received NL character shall be translated into a CR character. If IGNCR is set, a received CR
character shall be ignored (not read). If IGNCR is not set and ICRNL is set, a received CR character shall be translated into an NL
character.
If IXANY is set, any input character shall restart output that has been suspended.
If IXON is set, start/stop output control shall be enabled. A received STOP character shall suspend output and a
received START character shall restart output. When IXON is set, START and STOP characters are not read, but merely perform flow
control functions. When IXON is not set, the START and STOP characters shall be read.
If IXOFF is set, start/stop input control shall be enabled. The system shall transmit STOP characters, which are
intended to cause the terminal device to stop transmitting data, as needed to prevent the input queue from overflowing and causing
implementation-defined behavior, and shall transmit START characters, which are intended to cause the terminal device to resume
transmitting data, as soon as the device can continue transmitting data without risk of overflowing the input queue. The precise
conditions under which STOP and START characters are transmitted are implementation-defined.
The initial input control value after open() is
implementation-defined.
11.2.3 Output Modes
The c_oflag field specifies the terminal interface's treatment of output, and is composed of the
bitwise-inclusive OR of the masks shown, which shall be bitwise-distinct. The mask name symbols in the following table are defined
in :
Mask Name
Description
OPOST
Perform output processing.
[XSI]  ONLCR
Map NL to CR-NL on output.
OCRNL
Map CR to NL on output.
ONOCR
No CR output at column 0.
ONLRET
NL performs CR function.
OFILL
Use fill characters for delay.
OFDEL
Fill is DEL, else NUL.
NLDLY
Select newline delays:
NL0
Newline character type 0.
NL1
Newline character type 1.
CRDLY
Select carriage-return delays:
CR0
Carriage-return delay type 0.
CR1
Carriage-return delay type 1.
CR2
Carriage-return delay type 2.
CR3
Carriage-return delay type 3.
TABDLY
Select horizontal-tab delays:
TAB0
Horizontal-tab delay type 0.
TAB1
Horizontal-tab delay type 1.
TAB2
Horizontal-tab delay type 2.
TAB3
Expand tabs to spaces.
BSDLY
Select backspace delays:
BS0
Backspace-delay type 0.
BS1
Backspace-delay type 1.
VTDLY
Select vertical-tab delays:
VT0
Vertical-tab delay type 0.
VT1
Vertical-tab delay type 1.
FFDLY
Select form-feed delays:
FF0
Form-feed delay type 0.
FF1
Form-feed delay type 1.
If OPOST is set, output data shall be post-processed as described below, so that lines of text are modified to
appear appropriately on the terminal device; otherwise, characters shall be transmitted without change.
[XSI]  If ONLCR is set, the NL character shall be transmitted as the CR-NL character pair. If OCRNL is set, the CR character
shall be transmitted as the NL character. If ONOCR is set, no CR character shall be transmitted when at column 0 (first position).
If ONLRET is set, the NL character is assumed to do the carriage-return function; the column pointer shall be set to 0 and the
delays specified for CR shall be used. Otherwise, the NL character is assumed to do just the line-feed function; the column pointer
remains unchanged. The column pointer shall also be set to 0 if the CR character is actually transmitted.
The delay bits specify how long transmission stops to allow for mechanical or other movement when certain
characters are sent to the terminal. In all cases a value of 0 shall indicate no delay. If OFILL is set, fill characters shall be
transmitted for delay instead of a timed delay. This is useful for high baud rate terminals which need only a minimal delay. If
OFDEL is set, the fill character shall be DEL; otherwise, NUL.
If a  or  delay is specified, it shall last for about 2 seconds.
Newline delay shall last about 0.10 seconds. If ONLRET is set, the carriage-return delays shall be used instead of
the newline delays. If OFILL is set, two fill characters shall be transmitted.
Carriage-return delay type 1 shall be dependent on the current column position, type 2 shall be about 0.10 seconds,
and type 3 shall be about 0.15 seconds. If OFILL is set, delay type 1 shall transmit two fill characters, and type 2 four fill
characters.
Horizontal-tab delay type 1 shall be dependent on the current column position. Type 2 shall be about 0.10 seconds.
Type 3 specifies that  characters shall be expanded into  characters. If OFILL is set, two fill characters
shall be transmitted for any delay.
Backspace delay shall last about 0.05 seconds. If OFILL is set, one fill character shall be transmitted.
The actual delays depend on line speed and system load.
The initial output control value after open() is
implementation-defined.
11.2.4 Control Modes
The c_cflag field describes the hardware control of the terminal, and is composed of the bitwise-inclusive
OR of the masks shown, which shall be bitwise-distinct. The mask name symbols in this table are defined in ; not all values specified are required to be supported by the underlying
hardware (if any). If the terminal is a pseudo-terminal, it is unspecified whether non-default values are unsupported, or are
supported and emulated in software, or are handled by tcsetattr(), tcgetattr(), and the stty utility as if they
are supported but have no effect on the behavior of the terminal interface.
Mask Name
Description
CLOCAL
Ignore modem status lines.
CREAD
Enable receiver.
CSIZE
Number of bits transmitted or received per byte:
CS5
5 bits
CS6
6 bits
CS7
7 bits
CS8
8 bits.
CSTOPB
Send two stop bits, else one.
HUPCL
Hang up on last close.
PARENB
Parity enable.
PARODD
Odd parity, else even.
In addition, the input and output baud rates are stored in the termios structure. The symbols in the
following table are defined in . Not all values specified are
required to be supported by the underlying hardware (if any). For pseudo-terminals, the input and output baud rates set in the
termios structure need not affect the speed of data transmission through the terminal interface.
Note:
The term "baud" is used historically here, but is not technically correct. This is properly "bits per second", which may
not be the same as baud. However, the term is used because of the historical usage and understanding.
Name
Description
Name
Description
B0
Hang up
B600
600 baud
B50
50 baud
B1200
1200 baud
B75
75 baud
B1800
1800 baud
B110
110 baud
B2400
2400 baud
B134
134.5 baud
B4800
4800 baud
B150
150 baud
B9600
9600 baud
B200
200 baud
B19200
19200 baud
B300
300 baud
B38400
38400 baud
The following functions are provided for getting and setting the values of the input and output baud rates in the
termios structure: cfgetispeed(), cfgetospeed(), cfsetispeed(), and
cfsetospeed(). The effects on the terminal device shall not become effective and
not all errors need be detected until the tcsetattr() function is successfully
called.
The CSIZE bits shall specify the number of transmitted or received bits per byte. If ISTRIP is not set, the value
of all the other bits is unspecified. If ISTRIP is set, the value of all but the 7 low-order bits shall be zero, but the value of
any other bits beyond CSIZE is unspecified when read. CSIZE shall not include the parity bit, if any. If CSTOPB is set, two stop
bits shall be used; otherwise, one stop bit. For example, at 110 baud, two stop bits are normally used.
If CREAD is set, the receiver shall be enabled; otherwise, no characters shall be received.
If PARENB is set, parity generation and detection shall be enabled and a parity bit is added to each byte. If
parity is enabled, PARODD shall specify odd parity if set; otherwise, even parity shall be used.
If HUPCL is set, the modem control lines for the port shall be lowered when the last process with the port open
closes the port or the process terminates. The modem connection shall be broken.
If CLOCAL is set, a connection shall not depend on the state of the modem status lines. If CLOCAL is clear, the
modem status lines shall be monitored.
Under normal circumstances, a call to the open() function shall wait
for the modem connection to complete. However, if the O_NONBLOCK flag is set (see open()) or if CLOCAL has been set, the open()
function shall return immediately without waiting for the connection.
If the object for which the control modes are set is not an asynchronous serial connection, some of the modes may
be ignored; for example, if an attempt is made to set the baud rate on a network connection to a terminal on another host, the baud
rate need not be set on the connection between that terminal and the machine to which it is directly connected.
The initial hardware control value after open() is
implementation-defined.
11.2.5 Local Modes
The c_lflag field of the argument structure is used to control various functions. It is composed of the
bitwise-inclusive OR of the masks shown, which shall be bitwise-distinct. The mask name symbols in this table are defined in
.
Mask Name
Description
ECHO
Enable echo.
ECHOE
Echo ERASE as an error correcting backspace.
ECHOK
Echo KILL.
ECHONL
Echo .
ICANON
Canonical input (erase and kill processing).
IEXTEN
Enable extended (implementation-defined) functions.
ISIG
Enable signals.
NOFLSH
Disable flush after interrupt, quit, or suspend.
TOSTOP
Send SIGTTOU for background output.
If ECHO is set, input characters shall be echoed back to the terminal. If ECHO is clear, input characters shall not
be echoed.
If ECHOE and ICANON are set, the ERASE character shall cause the terminal to erase, if possible, the last character
in the current line from the display. If there is no character to erase, an implementation may echo an indication that this was the
case, or do nothing.
If ECHOK and ICANON are set, the KILL character shall either cause the terminal to erase the line from the display
or shall echo the  character after the KILL character.
If ECHONL and ICANON are set, the  character shall be echoed even if ECHO is not set.
If ICANON is set, canonical processing shall be enabled. This enables the erase and kill edit functions, and the
assembly of input characters into lines delimited by NL, EOF, and EOL, as described in 11.1.6 Canonical
Mode Input Processing.
If ICANON is not set, read requests shall be satisfied directly from the input queue. A read shall not be satisfied
until at least MIN bytes have been received or the timeout value TIME expired between bytes. The time value represents tenths of a
second. See 11.1.7 Non-Canonical Mode Input Processing for more details.
If IEXTEN is set, implementation-defined functions shall be recognized from the input data. It is
implementation-defined how IEXTEN being set interacts with ICANON, ISIG, IXON, or IXOFF. If IEXTEN is not set,
implementation-defined functions shall not be recognized and the corresponding input characters are processed as described for
ICANON, ISIG, IXON, and IXOFF.
If ISIG is set, each input character shall be checked against the special control characters INTR, QUIT, and SUSP.
If an input character matches one of these control characters, the function associated with that character shall be performed. If
ISIG is not set, no checking shall be done. Thus these special input functions are possible only if ISIG is set.
If NOFLSH is set, the normal flush of the input and output queues associated with the INTR, QUIT, and SUSP
characters shall not be done.
If TOSTOP is set, the signal SIGTTOU shall be sent to the process group of a process that tries to write to its
controlling terminal if it is not in the foreground process group for that terminal. This signal, by default, stops the members of
the process group. Otherwise, the output generated by that process shall be output to the current output stream. If the writing
process is ignoring the SIGTTOU signal or the writing thread is blocking the SIGTTOU signal, the process is allowed to produce
output, and the SIGTTOU signal shall not be sent.
The initial local control value after open() is
implementation-defined.
11.2.6 Special Control Characters
The special control character values shall be defined by the array c_cc. The subscript name and description
for each element in both canonical and non-canonical modes are as follows:
Subscript Usage
Canonical Mode
Non-Canonical Mode
Description
VEOF
EOF character
VEOL
EOL character
VERASE
ERASE character
VINTR
VINTR
INTR character
VKILL
KILL character
VMIN
MIN value
VQUIT
VQUIT
QUIT character
VSUSP
VSUSP
SUSP character
VTIME
TIME value
VSTART
VSTART
START character
VSTOP
VSTOP
STOP character
The subscript values are unique, except that the VMIN and VTIME subscripts may have the same values as the VEOF and
VEOL subscripts, respectively.
Implementations that do not support changing the START and STOP characters may ignore the character values in the
c_cc array indexed by the VSTART and VSTOP subscripts when tcsetattr() is
called, but shall return the value in use when tcgetattr() is called.
The initial values of all control characters are implementation-defined.
If the value of one of the changeable special control characters (see 11.1.9 Special
Characters) is _POSIX_VDISABLE, that function shall be disabled; that is, no input data is recognized as the disabled special
character. If ICANON is not set, the value of _POSIX_VDISABLE has no special meaning for the VMIN and VTIME entries of the
c_cc array.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/wctype.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wctype.h — wide-character classification and mapping utilities
SYNOPSIS
#include
DESCRIPTION
[CX]  Some of the functionality described on this reference page extends the ISO C standard. Applications shall define
the appropriate feature test macro (see XSH 2.2 The Compilation
Environment) to enable the visibility of these symbols in this header.
The  header shall define the following types:
wint_t
As described in .
wctrans_t
A scalar type that can hold values which represent locale-specific character mappings.
wctype_t
A scalar type of a data object that can hold values which represent locale-specific character classification.
[CX]  The
header shall define the locale_t type as described in .
The  header shall define the following macro:
WEOF
As described in .
For all functions described in this header that accept an argument of type wint_t, the value is representable as a
wchar_t or equals the value of WEOF. If this argument has any other value, the behavior is undefined.
The behavior of these functions shall be affected by the LC_CTYPE category of the current locale.
[CX]
Inclusion of the  header may make visible all symbols from the headers , , , , , , , and .
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided for use
with ISO C standard compilers.
int       iswalnum(wint_t);
[CX]
int       iswalnum_l(wint_t, locale_t);
int       iswalpha(wint_t);
[CX]
int       iswalpha_l(wint_t, locale_t);
int       iswblank(wint_t);
[CX]
int       iswblank_l(wint_t, locale_t);
int       iswcntrl(wint_t);
[CX]
int       iswcntrl_l(wint_t, locale_t);
int       iswctype(wint_t, wctype_t);
[CX]
int       iswctype_l(wint_t, wctype_t, locale_t);
int       iswdigit(wint_t);
[CX]
int       iswdigit_l(wint_t, locale_t);
int       iswgraph(wint_t);
[CX]
int       iswgraph_l(wint_t, locale_t);
int       iswlower(wint_t);
[CX]
int       iswlower_l(wint_t, locale_t);
int       iswprint(wint_t);
[CX]
int       iswprint_l(wint_t, locale_t);
int       iswpunct(wint_t);
[CX]
int       iswpunct_l(wint_t, locale_t);
int       iswspace(wint_t);
[CX]
int       iswspace_l(wint_t, locale_t);
int       iswupper(wint_t);
[CX]
int       iswupper_l(wint_t, locale_t);
int       iswxdigit(wint_t);
[CX]
int       iswxdigit_l(wint_t, locale_t);
wint_t    towctrans(wint_t, wctrans_t);
[CX]
wint_t    towctrans_l(wint_t, wctrans_t, locale_t);
wint_t    towlower(wint_t);
[CX]
wint_t    towlower_l(wint_t, locale_t);
wint_t    towupper(wint_t);
[CX]
wint_t    towupper_l(wint_t, locale_t);
wctrans_t wctrans(const char *);
[CX]
wctrans_t wctrans_l(const char *, locale_t);
wctype_t  wctype(const char *);
[CX]
wctype_t  wctype_l(const char *, locale_t);
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
,
, ,
, , ,
, ,
XSH 2.2 The Compilation Environment, iswalnum(), iswalpha(), iswblank(), iswcntrl(), iswctype(), iswdigit(), iswgraph(), iswlower(), iswprint(), iswpunct(), iswspace(), iswupper(), iswxdigit(), setlocale(), towctrans(), towlower(), towupper(), wctrans(), wctype()
CHANGE HISTORY
First released in Issue 5. Derived from the ISO/IEC 9899:1990/Amendment 1:1995 (E).
Issue 6
The iswblank() function is added for alignment with the ISO/IEC 9899:1999
standard.
Issue 7
SD5-XBD-ERN-6 is applied.
The *_l() functions are added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
This reference page is clarified with respect to macros and symbolic constants.
Issue 8
Austin Group Defect 1330 is applied, moving the description of wctype_t from  to .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/fnmatch.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fnmatch.h — filename-matching types
SYNOPSIS
#include
DESCRIPTION
The  header shall define the following symbolic constants:
FNM_NOMATCH
The string does not match the specified pattern.
FNM_PATHNAME
in string only matches  in pattern.
FNM_PERIOD
Leading  in string only matches  in pattern.
FNM_NOESCAPE
Disable backslash escaping.
FNM_CASEFOLD
Compare string and pattern in a case-insensitive manner. See 4.1 Case Insensitive Comparisons.
FNM_IGNORECASE
Equivalent to FNM_CASEFOLD.
The following shall be declared as a function and may also be defined as a macro. A function prototype shall be provided.
int fnmatch(const char *, const char *, int);
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XSH fnmatch()
CHANGE HISTORY
First released in Issue 4. Derived from the ISO POSIX-2 standard.
Issue 6
The FNM_NOSYS constant is marked obsolescent.
Issue 7
The obsolescent FNM_NOSYS constant is removed.
This reference page is clarified with respect to macros and symbolic constants.
Issue 8
Austin Group Defect 1031 is applied, adding FNM_CASEFOLD and FNM_IGNORECASE.
The description of FNM_PERIOD is updated to eliminate the use of "must".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/arpa_inet.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
arpa/inet.h — definitions for internet operations
SYNOPSIS
#include
DESCRIPTION
The  header shall define the in_port_t and in_addr_t types as described in  and the socklen_t type as defined in .
The  header shall define the in_addr structure as described in .
The  header shall define the INET_ADDRSTRLEN [IP6]   and
INET6_ADDRSTRLEN  macros as described in .
The following shall be declared as functions, or defined as macros, or both. If functions are declared, function prototypes
shall be provided.
uint32_t htonl(uint32_t);
uint16_t htons(uint16_t);
uint32_t ntohl(uint32_t);
uint16_t ntohs(uint16_t);
The  header shall define the uint32_t and uint16_t types as described in .
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
[OB]
in_addr_t    inet_addr(const char *);
char        *inet_ntoa(struct in_addr);
const char  *inet_ntop(int, const void *restrict, char *restrict,
socklen_t);
int          inet_pton(int, const char *restrict, void *restrict);
Inclusion of the  header may also make visible all symbols from  and .
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
, ,
XSH htonl(), inet_addr(),
inet_ntop()
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
The restrict keyword is added to the prototypes for inet_ntop() and
inet_pton().
Issue 7
SD5-XBD-ERN-6 is applied.
Issue 8
Austin Group Defect 162 is applied, adding  to the SEE ALSO
section.
Austin Group Defects 1101 and 1102 are applied, marking inet_addr() and
inet_ntoa() as obsolescent.
Austin Group Defect 1290 is applied, adding a requirement for  to define the socklen_t
type.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/spawn.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
spawn.h — spawn (ADVANCED REALTIME)
SYNOPSIS
[SPN]  #include
DESCRIPTION
The  header shall define the posix_spawnattr_t and posix_spawn_file_actions_t types used in
performing spawn operations.
The  header shall define the mode_t and pid_t types as described in .
The  header shall define the sigset_t type as described in .
The tag sched_param shall be declared as naming an incomplete structure type, the contents of which are described in the
header.
The  header shall define the following symbolic constants for use as the flags that may be set in a
posix_spawnattr_t object using the posix_spawnattr_setflags() function:
POSIX_SPAWN_RESETIDS
POSIX_SPAWN_SETPGROUP
[PS]
POSIX_SPAWN_SETSCHEDPARAM
POSIX_SPAWN_SETSCHEDULER
POSIX_SPAWN_SETSID
POSIX_SPAWN_SETSIGDEF
POSIX_SPAWN_SETSIGMASK
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
int   posix_spawn(pid_t *restrict, const char *restrict,
const posix_spawn_file_actions_t *restrict,
const posix_spawnattr_t *restrict, char *const [restrict],
char *const [restrict]);
int   posix_spawn_file_actions_addchdir(posix_spawn_file_actions_t
*restrict, const char *restrict);
int   posix_spawn_file_actions_addclose(posix_spawn_file_actions_t *,
int);
int   posix_spawn_file_actions_adddup2(posix_spawn_file_actions_t *,
int, int);
int   posix_spawn_file_actions_addfchdir(posix_spawn_file_actions_t *,
int);
int   posix_spawn_file_actions_addopen(posix_spawn_file_actions_t
*restrict, int, const char *restrict, int, mode_t);
int   posix_spawn_file_actions_destroy(posix_spawn_file_actions_t *);
int   posix_spawn_file_actions_init(posix_spawn_file_actions_t *);
int   posix_spawnattr_destroy(posix_spawnattr_t *);
int   posix_spawnattr_getflags(const posix_spawnattr_t *restrict,
short *restrict);
int   posix_spawnattr_getpgroup(const posix_spawnattr_t *restrict,
pid_t *restrict);
[PS]
int   posix_spawnattr_getschedparam(const posix_spawnattr_t *restrict,
struct sched_param *restrict);
int   posix_spawnattr_getschedpolicy(const posix_spawnattr_t *restrict,
int *restrict);
int   posix_spawnattr_getsigdefault(const posix_spawnattr_t *restrict,
sigset_t *restrict);
int   posix_spawnattr_getsigmask(const posix_spawnattr_t *restrict,
sigset_t *restrict);
int   posix_spawnattr_init(posix_spawnattr_t *);
int   posix_spawnattr_setflags(posix_spawnattr_t *, short);
int   posix_spawnattr_setpgroup(posix_spawnattr_t *, pid_t);
[PS]
int   posix_spawnattr_setschedparam(posix_spawnattr_t *restrict,
const struct sched_param *restrict);
int   posix_spawnattr_setschedpolicy(posix_spawnattr_t *, int);
int   posix_spawnattr_setsigdefault(posix_spawnattr_t *restrict,
const sigset_t *restrict);
int   posix_spawnattr_setsigmask(posix_spawnattr_t *restrict,
const sigset_t *restrict);
int   posix_spawnp(pid_t *restrict, const char *restrict,
const posix_spawn_file_actions_t *restrict,
const posix_spawnattr_t *restrict,
char *const [restrict], char *const [restrict]);
Inclusion of the  header may make visible symbols defined in the  and
headers.
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
, , ,
XSH posix_spawn(), posix_spawn_file_actions_addclose(), posix_spawn_file_actions_adddup2(), posix_spawn_file_actions_destroy(), posix_spawnattr_destroy(), posix_spawnattr_getflags(), posix_spawnattr_getpgroup(), posix_spawnattr_getschedparam(), posix_spawnattr_getschedpolicy(), posix_spawnattr_getsigdefault(), posix_spawnattr_getsigmask()
CHANGE HISTORY
First released in Issue 6. Included for alignment with IEEE Std 1003.1d-1999.
The restrict keyword is added to the prototypes for posix_spawn(),
posix_spawn_file_actions_addopen(), posix_spawnattr_getsigdefault(), posix_spawnattr_getflags(), posix_spawnattr_getpgroup(), posix_spawnattr_getschedparam(), posix_spawnattr_getschedpolicy(), posix_spawnattr_getsigmask(), posix_spawnattr_setsigdefault(), posix_spawnattr_setschedparam(), posix_spawnattr_setsigmask(), and posix_spawnp().
Issue 7
This reference page is clarified with respect to macros and symbolic constants, and declarations for the mode_t,
pid_t, and sigset_t types are added.
Issue 8
Austin Group Defect 1044 is applied, adding POSIX_SPAWN_SETSID.
Austin Group Defect 1208 is applied, adding posix_spawn_file_actions_addchdir() and posix_spawn_file_actions_addfchdir().
Austin Group Defect 1328 is applied, adding the restrict keyword to the third parameter of posix_spawn() and posix_spawnp().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/sys_stat.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sys/stat.h — data returned by the stat() function
SYNOPSIS
#include
DESCRIPTION
The  header shall define the structure of the data returned by the fstat(), lstat(), and stat() functions.
The  header shall define the stat structure, which shall include at least the following
members:
dev_t st_dev            Device ID of device containing file.
ino_t st_ino            File serial number.
mode_t st_mode          Mode of file (see below).
nlink_t st_nlink        Number of hard links to the file.
uid_t st_uid            User ID of file.
gid_t st_gid            Group ID of file.
[XSI]
dev_t st_rdev           Device ID (if file is character or block special).
off_t st_size           For regular files, the file size in bytes.
For symbolic links, the length in bytes of the
pathname contained in the symbolic link.
[SHM]
For a shared memory object, the length in bytes.
[TYM]
For a typed memory object, the length in bytes.
For other file types, the use of this field is
unspecified.
struct timespec st_atim Last data access timestamp.
struct timespec st_mtim Last data modification timestamp.
struct timespec st_ctim Last file status change timestamp.
[XSI]
blksize_t st_blksize    A file system-specific preferred I/O block size
for this object. In some file system types, this
may vary from file to file.
blkcnt_t st_blocks      Number of blocks allocated for this object.
A file identity is uniquely determined by the combination of st_dev and st_ino. At any given time in a
system, distinct files shall have distinct file identities; hard links to the same file shall have the same file identity. Over
time, these file identities can be reused for different files. For example, the st_ino value can be reused after the last
link to a file is unlinked and the space occupied by the file has been freed, and the st_dev value associated with a file
system can be reused if that file system is detached ("unmounted") and another is attached ("mounted").
The st_nlink value shall be the number of hard links to the file within the file system in which the file resides.
Note:
The number of links to the file that can be found by traversing the file hierarchy can differ from st_nlink. For
example, it can be less than st_nlink if a link to the file cannot be reached because it is below a directory that has been
overlaid with a mount point for a different file system, and it can be greater than st_nlink on implementations that allow a
file system (or part of one) to be duplicated at additional mount points.
The  header shall define the [XSI]  blkcnt_t, blksize_t,  dev_t, ino_t, mode_t, nlink_t, uid_t, gid_t, off_t, and
time_t types as described in .
The  header shall define the timespec structure as described in . Times shall be given in seconds since the Epoch.
Which structure members have meaningful values depends on the type of file. For further information, see the descriptions of
fstat(), lstat(), and stat() in the System Interfaces volume of POSIX.1-2024.
For compatibility with earlier versions of this standard, the st_atime macro shall be defined with the value
st_atim.tv_sec. Similarly, st_ctime and st_mtime shall be defined as macros with the values
st_ctim.tv_sec and st_mtim.tv_sec, respectively.
The  header shall define the following symbolic constants for the file types encoded in type
mode_t. The values shall be suitable for use in #if preprocessing directives:
S_IFMT
[XSI]
Type of file.
S_IFBLK
Block special.
S_IFCHR
Character special.
S_IFIFO
FIFO special.
S_IFREG
Regular.
S_IFDIR
Directory.
S_IFLNK
Symbolic link.
S_IFSOCK
Socket.
The  header shall define the following symbolic constants for the file mode bits encoded in type
mode_t, with the indicated numeric values. These macros shall expand to an expression which has a type that allows them to
be used, either singly or OR'ed together, as the third argument to open() without the
need for a mode_t cast. The values shall be suitable for use in #if preprocessing directives.
Name
Numeric Value
Description
S_IRWXU
0700
Read, write, execute/search by owner.
S_IRUSR
0400
Read permission, owner.
S_IWUSR
0200
Write permission, owner.
S_IXUSR
0100
Execute/search permission, owner.
S_IRWXG
070
Read, write, execute/search by group.
S_IRGRP
040
Read permission, group.
S_IWGRP
020
Write permission, group.
S_IXGRP
010
Execute/search permission, group.
S_IRWXO
07
Read, write, execute/search by others.
S_IROTH
04
Read permission, others.
S_IWOTH
02
Write permission, others.
S_IXOTH
01
Execute/search permission, others.
S_ISUID
04000
Set-user-ID on execution.
S_ISGID
02000
Set-group-ID on execution.
[XSI]  S_ISVTX
01000
On directories, restricted deletion flag.
The following macros shall be provided to test whether a file is of the specified type. The value m supplied
to the macros is the value of st_mode from a stat structure. The macro shall evaluate to a non-zero value if the test
is true; 0 if the test is false.
S_ISBLK(m)
Test for a block special file.
S_ISCHR(m)
Test for a character special file.
S_ISDIR(m)
Test for a directory.
S_ISFIFO(m)
Test for a pipe or FIFO special file.
S_ISREG(m)
Test for a regular file.
S_ISLNK(m)
Test for a symbolic link.
S_ISSOCK(m)
Test for a socket.
The implementation may implement message queues, semaphores, or shared memory objects as distinct file types, in
which case these file types need not be encoded in type mode_t. The following macros shall be provided to test whether a
file is of the specified type. The value of the buf argument supplied to the macros is a pointer to a stat structure.
The macro shall evaluate to a non-zero value if the specified object is implemented as a distinct file type and the specified file
type is contained in the stat structure referenced by buf. Otherwise, the macro shall evaluate to zero.
S_TYPEISMQ(buf)
Test for a message queue.
S_TYPEISSEM(buf)
Test for a semaphore.
S_TYPEISSHM(buf)
Test for a shared memory object.
[TYM]  The implementation may implement typed memory objects as a distinct file type, in which case this file type need not be
encoded in type mode_t. The following macro shall test whether a file is of the specified type. The value of the buf
argument supplied to the macros is a pointer to a stat structure. The macro shall evaluate to a non-zero value if the
specified object is implemented as a distinct file type and the specified file type is contained in the stat structure
referenced by buf. Otherwise, the macro shall evaluate to zero.
S_TYPEISTMO(buf)
Test macro for a typed memory object.
The  header shall define the following symbolic constants as distinct integer values
outside of the range [0,999999999], for use with the futimens() and utimensat() functions: UTIME_NOW UTIME_OMIT
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be
provided.
int    chmod(const char *, mode_t);
int    fchmod(int, mode_t);
int    fchmodat(int, const char *, mode_t, int);
int    fstat(int, struct stat *);
int    fstatat(int, const char *restrict, struct stat *restrict, int);
int    futimens(int, const struct timespec [2]);
int    lstat(const char *restrict, struct stat *restrict);
int    mkdir(const char *, mode_t);
int    mkdirat(int, const char *, mode_t);
int    mkfifo(const char *, mode_t);
int    mkfifoat(int, const char *, mode_t);
[XSI]
int    mknod(const char *, mode_t, dev_t);
int    mknodat(int, const char *, mode_t, dev_t);
int    stat(const char *restrict, struct stat *restrict);
mode_t umask(mode_t);
int    utimensat(int, const char *, const struct timespec [2], int);
Inclusion of the  header may make visible all symbols from the  header.
The following sections are informative.
APPLICATION USAGE
Use of the macros is recommended for determining the type of a file.
RATIONALE
A conforming C-language application must include  for functions that have arguments or return values of
type mode_t, so that symbolic values for that type can be used. An alternative would be to require that these constants are
also defined by including .
The S_ISUID and S_ISGID bits may be cleared on any write, not just on open(), as some historical implementations do.
System calls that update the time entry fields in the stat structure must be documented by the implementors.
POSIX-conforming systems should not update the time entry fields for functions listed in the System Interfaces volume of
POSIX.1-2024 unless the standard requires that they do, except in the case of documented extensions to the standard.
Upon assignment, file timestamps are immediately converted to the resolution of the file system by truncation
(i.e., the recorded time can be older than the actual time). For example, if the file system resolution is 1 microsecond, then a
conforming stat() must always return an st_mtim.tv_nsec that is a multiple of
1000. Some older implementations returned higher-resolution timestamps while the inode information was cached, and then
spontaneously truncated the tv_nsec fields when they were stored to and retrieved from disk, but this behavior does not
conform.
Note that st_dev must be unique within a Local Area Network (LAN) in a "system" made up of multiple
computers' file systems connected by a LAN.
Networked implementations of a POSIX-conforming system must guarantee that all files visible within the file tree
(including parts of the tree that may be remotely mounted from other machines on the network) on each individual processor are
uniquely identified by the combination of the st_ino and st_dev fields.
The unit for the st_blocks member of the stat structure is not defined within POSIX.1-2024. In some
implementations it is 512 bytes. It may differ on a file system basis. There is no correlation between values of the
st_blocks and st_blksize, and the f_bsize (from ) structure members.
Traditionally, some implementations defined the multiplier for st_blocks in  as
the symbol DEV_BSIZE.
Some earlier versions of this standard did not specify values for the file mode bit macros. The expectation was
that some implementors might choose to use a different encoding for these bits than the traditional one, and that new applications
would use symbolic file modes instead of numeric. This version of the standard specifies the traditional encoding, in recognition
that nearly 20 years after the first publication of this standard numeric file modes are still in widespread use by application
developers, and that all conforming implementations still use the traditional encoding.
FUTURE DIRECTIONS
No new S_IFMT symbolic names for the file type values of mode_t will be defined by POSIX.1-2024; if new file types are
required, they will only be testable through S_ISxx() or S_TYPEISxxx() macros instead.
SEE ALSO
, ,
XSH chmod(), fchmod(), fstat(), fstatat(), futimens(), mkdir(), mkfifo(),
mknod(), umask()
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Realtime Extension.
The type of st_blksize is changed from long to blksize_t; the type of st_blocks is
changed from long to blkcnt_t.
Issue 6
The S_TYPEISMQ(), S_TYPEISSEM(), and S_TYPEISSHM() macros are unconditionally mandated.
The Open Group Corrigendum U035/4 is applied. In the DESCRIPTION, the types blksize_t and blkcnt_t
have been described.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX
Specification:
The dev_t, ino_t, mode_t, nlink_t, uid_t, gid_t, off_t, and
time_t types are mandated.
S_IFSOCK and S_ISSOCK are added for sockets.
The description of stat structure members is changed to reflect contents when file type is a symbolic
link.
The test macro S_TYPEISTMO is added for alignment with IEEE Std 1003.1j-2000.
The restrict keyword is added to the prototypes for lstat() and
stat().
The lstat() function is made mandatory.
IEEE Std 1003.1-2001/Cor 1-2002, item XBD/TC1/D6/17 is applied, adding text regarding the
st_blocks member of the stat structure to the RATIONALE.
IEEE Std 1003.1-2001/Cor 2-2004, item XBD/TC2/D6/25 is applied, adding to the DESCRIPTION that the
timespec structure may be defined as described in the
header.
Issue 7
SD5-XSH-ERN-161 is applied, updating the DESCRIPTION to clarify that the descriptions of the interfaces should be consulted in
order to determine which structure members have meaningful values.
The fchmodat(), fstatat(), mkdirat(), mkfifoat(), mknodat(), and utimensat() functions are added from The Open Group Technical Standard, 2006, Extended API
Set Part 2.
The futimens() function is added.
This reference page is clarified with respect to macros and symbolic constants.
Changes are made related to support for finegrained timestamps and the UTIME_NOW and UTIME_OMIT symbolic constants
are added.
POSIX.1-2008, Technical Corrigendum 1, XBD/TC1-2008/0068 [207] is applied.
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0078 [531] is applied.
Issue 8
Austin Group Defect 732 is applied, clarifying that if message queues, semaphores, shared memory objects, or typed memory
objects are implemented as distinct file types, they need not be encoded in type mode_t.
Austin Group Defect 1314 is applied, clarifying how the st_dev and st_ino values identify files.
Austin Group Defect 1323 is applied, clarifying how the st_nlink value relates to the number of links to the
file that can be found by traversing the file hierarchy.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/sys_sem.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sys/sem.h — XSI semaphore facility
SYNOPSIS
[XSI]  #include
DESCRIPTION
The  header shall define the following symbolic constant for use as a semaphore operation flag:
SEM_UNDO
Set up adjust on exit entry.
The  header shall define the following symbolic constants for use as commands for the semctl() function:
GETNCNT
Get semncnt.
GETPID
Get sempid.
GETVAL
Get semval.
GETALL
Get all cases of semval.
GETZCNT
Get semzcnt.
SETVAL
Set semval.
SETALL
Set all cases of semval.
The  header shall define the semid_ds structure, which shall include the following members:
struct ipc_perm  sem_perm  Operation permission structure.
unsigned short   sem_nsems Number of semaphores in set.
time_t           sem_otime Last semop() time.
time_t           sem_ctime Last time changed by semctl().
The  header shall define the pid_t, size_t, and time_t types as described in
.
A semaphore shall be represented by an anonymous structure, which shall include the following members:
unsigned short  semval   Semaphore value.
pid_t           sempid   Process ID of last operation.
unsigned short  semncnt  Number of processes waiting for semval
to become greater than current value.
unsigned short  semzcnt  Number of processes waiting for semval
to become 0.
The  header shall define the sembuf structure, which shall include the following members:
unsigned short  sem_num   Semaphore number.
short           sem_op    Semaphore operation.
short           sem_flg   Operation flags.
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
int   semctl(int, int, int, ...);
int   semget(key_t, int, int);
int   semop(int, struct sembuf *, size_t);
In addition, the  header shall include the  header.
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
,
XSH semctl(), semget(), semop()
CHANGE HISTORY
First released in Issue 2. Derived from System V Release 2.0.
Issue 7
Austin Group Interpretation 1003.1-2001 #179 is applied.
This reference page is clarified with respect to macros and symbolic constants.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/pthread.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread.h — threads
SYNOPSIS
#include
DESCRIPTION
The  header shall define the following symbolic constants:
PTHREAD_BARRIER_SERIAL_THREAD
PTHREAD_CANCEL_ASYNCHRONOUS
PTHREAD_CANCEL_ENABLE
PTHREAD_CANCEL_DEFERRED
PTHREAD_CANCEL_DISABLE
PTHREAD_CANCELED
PTHREAD_CREATE_DETACHED
PTHREAD_CREATE_JOINABLE
[TPS]
PTHREAD_EXPLICIT_SCHED
PTHREAD_INHERIT_SCHED
PTHREAD_MUTEX_DEFAULT
PTHREAD_MUTEX_ERRORCHECK
PTHREAD_MUTEX_NORMAL
PTHREAD_MUTEX_RECURSIVE
PTHREAD_MUTEX_ROBUST
PTHREAD_MUTEX_STALLED
PTHREAD_ONCE_INIT
[RPI|TPI]
PTHREAD_PRIO_INHERIT
[MC1]
PTHREAD_PRIO_NONE
[RPP|TPP]
PTHREAD_PRIO_PROTECT
PTHREAD_PROCESS_SHARED
PTHREAD_PROCESS_PRIVATE
[TPS]
PTHREAD_SCOPE_PROCESS
PTHREAD_SCOPE_SYSTEM
The  header shall define the following compile-time constant expressions valid as initializers for the
following types:
Name
Initializer for Type
PTHREAD_COND_INITIALIZER
pthread_cond_t
PTHREAD_MUTEX_INITIALIZER
pthread_mutex_t
PTHREAD_RWLOCK_INITIALIZER
pthread_rwlock_t
The  header shall define the following compile-time constant expression, valid as an
initializer for pthread_t, representing a value that shall not compare equal to the thread ID of any existing thread:
PTHREAD_NULL
The  header shall define the pthread_attr_t, pthread_barrier_t,
pthread_barrierattr_t, pthread_cond_t, pthread_condattr_t, pthread_key_t, pthread_mutex_t,
pthread_mutexattr_t, pthread_once_t, pthread_rwlock_t, pthread_rwlockattr_t, pthread_spinlock_t,
and pthread_t types as described in .
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be
provided.
[OB]
int   pthread_atfork(void (*)(void), void (*)(void),
void(*)(void));
int   pthread_attr_destroy(pthread_attr_t *);
int   pthread_attr_getdetachstate(const pthread_attr_t *, int *);
int   pthread_attr_getguardsize(const pthread_attr_t *restrict,
size_t *restrict);
[TPS]
int   pthread_attr_getinheritsched(const pthread_attr_t *restrict,
int *restrict);
int   pthread_attr_getschedparam(const pthread_attr_t *restrict,
struct sched_param *restrict);
[TPS]
int   pthread_attr_getschedpolicy(const pthread_attr_t *restrict,
int *restrict);
int   pthread_attr_getscope(const pthread_attr_t *restrict,
int *restrict);
[TSA TSS]
int   pthread_attr_getstack(const pthread_attr_t *restrict,
void **restrict, size_t *restrict);
[TSS]
int   pthread_attr_getstacksize(const pthread_attr_t *restrict,
size_t *restrict);
int   pthread_attr_init(pthread_attr_t *);
int   pthread_attr_setdetachstate(pthread_attr_t *, int);
int   pthread_attr_setguardsize(pthread_attr_t *, size_t);
[TPS]
int   pthread_attr_setinheritsched(pthread_attr_t *, int);
int   pthread_attr_setschedparam(pthread_attr_t *restrict,
const struct sched_param *restrict);
[TPS]
int   pthread_attr_setschedpolicy(pthread_attr_t *, int);
int   pthread_attr_setscope(pthread_attr_t *, int);
[TSA TSS]
int   pthread_attr_setstack(pthread_attr_t *, void *, size_t);
[TSS]
int   pthread_attr_setstacksize(pthread_attr_t *, size_t);
int   pthread_barrier_destroy(pthread_barrier_t *);
int   pthread_barrier_init(pthread_barrier_t *restrict,
const pthread_barrierattr_t *restrict, unsigned);
int   pthread_barrier_wait(pthread_barrier_t *);
int   pthread_barrierattr_destroy(pthread_barrierattr_t *);
[TSH]
int   pthread_barrierattr_getpshared(
const pthread_barrierattr_t *restrict, int *restrict);
int   pthread_barrierattr_init(pthread_barrierattr_t *);
[TSH]
int   pthread_barrierattr_setpshared(pthread_barrierattr_t *, int);
int   pthread_cancel(pthread_t);
int   pthread_cond_broadcast(pthread_cond_t *);
int   pthread_cond_clockwait(pthread_cond_t *restrict,
pthread_mutex_t *restrict, clockid_t,
const struct timespec *restrict);
int   pthread_cond_destroy(pthread_cond_t *);
int   pthread_cond_init(pthread_cond_t *restrict,
const pthread_condattr_t *restrict);
int   pthread_cond_signal(pthread_cond_t *);
int   pthread_cond_timedwait(pthread_cond_t *restrict,
pthread_mutex_t *restrict, const struct timespec *restrict);
int   pthread_cond_wait(pthread_cond_t *restrict,
pthread_mutex_t *restrict);
int   pthread_condattr_destroy(pthread_condattr_t *);
int   pthread_condattr_getclock(const pthread_condattr_t *restrict,
clockid_t *restrict);
[TSH]
int   pthread_condattr_getpshared(const pthread_condattr_t *restrict,
int *restrict);
int   pthread_condattr_init(pthread_condattr_t *);
int   pthread_condattr_setclock(pthread_condattr_t *, clockid_t);
[TSH]
int   pthread_condattr_setpshared(pthread_condattr_t *, int);
int   pthread_create(pthread_t *restrict, const pthread_attr_t *restrict,
void *(*)(void*), void *restrict);
int   pthread_detach(pthread_t);
int   pthread_equal(pthread_t, pthread_t);
_Noreturn void
pthread_exit(void *);
[TCT]
int   pthread_getcpuclockid(pthread_t, clockid_t *);
[TPS]
int   pthread_getschedparam(pthread_t, int *restrict,
struct sched_param *restrict);
void *pthread_getspecific(pthread_key_t);
int   pthread_join(pthread_t, void **);
int   pthread_key_create(pthread_key_t *, void (*)(void*));
int   pthread_key_delete(pthread_key_t);
int   pthread_mutex_clocklock(pthread_mutex_t *restrict, clockid_t,
const struct timespec *restrict);
int   pthread_mutex_consistent(pthread_mutex_t *);
int   pthread_mutex_destroy(pthread_mutex_t *);
[RPP|TPP]
int   pthread_mutex_getprioceiling(const pthread_mutex_t *restrict,
int *restrict);
int   pthread_mutex_init(pthread_mutex_t *restrict,
const pthread_mutexattr_t *restrict);
int   pthread_mutex_lock(pthread_mutex_t *);
[RPP|TPP]
int   pthread_mutex_setprioceiling(pthread_mutex_t *restrict, int,
int *restrict);
int   pthread_mutex_timedlock(pthread_mutex_t *restrict,
const struct timespec *restrict);
int   pthread_mutex_trylock(pthread_mutex_t *);
int   pthread_mutex_unlock(pthread_mutex_t *);
int   pthread_mutexattr_destroy(pthread_mutexattr_t *);
[RPP|TPP]
int   pthread_mutexattr_getprioceiling(
const pthread_mutexattr_t *restrict, int *restrict);
[MC1]
int   pthread_mutexattr_getprotocol(const pthread_mutexattr_t *restrict,
int *restrict);
[TSH]
int   pthread_mutexattr_getpshared(const pthread_mutexattr_t *restrict,
int *restrict);
int   pthread_mutexattr_getrobust(const pthread_mutexattr_t *restrict,
int *restrict);
int   pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict,
int *restrict);
int   pthread_mutexattr_init(pthread_mutexattr_t *);
[RPP|TPP]
int   pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int);
[MC1]
int   pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int);
[TSH]
int   pthread_mutexattr_setpshared(pthread_mutexattr_t *, int);
int   pthread_mutexattr_setrobust(pthread_mutexattr_t *, int);
int   pthread_mutexattr_settype(pthread_mutexattr_t *, int);
int   pthread_once(pthread_once_t *, void (*)(void));
int   pthread_rwlock_destroy(pthread_rwlock_t *);
int   pthread_rwlock_init(pthread_rwlock_t *restrict,
const pthread_rwlockattr_t *restrict);
int   pthread_rwlock_clockrdlock(pthread_rwlock_t *restrict,
clockid_t, const struct timespec *restrict);
int   pthread_rwlock_clockwrlock(pthread_rwlock_t *restrict,
clockid_t, const struct timespec *restrict);
int   pthread_rwlock_rdlock(pthread_rwlock_t *);
int   pthread_rwlock_timedrdlock(pthread_rwlock_t *restrict,
const struct timespec *restrict);
int   pthread_rwlock_timedwrlock(pthread_rwlock_t *restrict,
const struct timespec *restrict);
int   pthread_rwlock_tryrdlock(pthread_rwlock_t *);
int   pthread_rwlock_trywrlock(pthread_rwlock_t *);
int   pthread_rwlock_unlock(pthread_rwlock_t *);
int   pthread_rwlock_wrlock(pthread_rwlock_t *);
int   pthread_rwlockattr_destroy(pthread_rwlockattr_t *);
[TSH]
int   pthread_rwlockattr_getpshared(
const pthread_rwlockattr_t *restrict, int *restrict);
int   pthread_rwlockattr_init(pthread_rwlockattr_t *);
[TSH]
int   pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int);
pthread_t
pthread_self(void);
int   pthread_setcancelstate(int, int *);
int   pthread_setcanceltype(int, int *);
[TPS]
int   pthread_setschedparam(pthread_t, int,
const struct sched_param *);
int   pthread_setschedprio(pthread_t, int);
int   pthread_setspecific(pthread_key_t, const void *);
int   pthread_spin_destroy(pthread_spinlock_t *);
int   pthread_spin_init(pthread_spinlock_t *, int);
int   pthread_spin_lock(pthread_spinlock_t *);
int   pthread_spin_trylock(pthread_spinlock_t *);
int   pthread_spin_unlock(pthread_spinlock_t *);
void  pthread_testcancel(void);
The following may be declared as functions, or defined as macros, or both. If functions are declared, function
prototypes shall be provided.
pthread_cleanup_pop()
pthread_cleanup_push()
Inclusion of the  header shall make symbols defined in the headers  and  visible.
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
Since pthread_t is an opaque type, a definition of PTHREAD_NULL was added to allow for a null value of that type. Some
conforming definitions of PTHREAD_NULL could be:
For a pointer type:
#define PTHREAD_NULL ((pthread_t)NULL)
For an integer type:
#define PTHREAD_NULL ((pthread_t)-42)
For a struct type:
#define PTHREAD_NULL ((const pthread_t){ .__foo = -1 })
FUTURE DIRECTIONS
None.
SEE ALSO
, ,
XSH pthread_atfork(), pthread_attr_destroy(), pthread_attr_getdetachstate(), pthread_attr_getguardsize(), pthread_attr_getinheritsched(), pthread_attr_getschedparam(), pthread_attr_getschedpolicy(), pthread_attr_getscope(), pthread_attr_getstack(), pthread_attr_getstacksize(), pthread_barrier_destroy(), pthread_barrier_wait(), pthread_barrierattr_destroy(), pthread_barrierattr_getpshared(), pthread_cancel(), pthread_cleanup_pop(), pthread_cond_broadcast(), pthread_cond_clockwait(), pthread_cond_destroy(), pthread_condattr_destroy(), pthread_condattr_getclock(), pthread_condattr_getpshared(), pthread_create(), pthread_detach(), pthread_equal(), pthread_exit()
, pthread_getcpuclockid(), pthread_getschedparam(), pthread_getspecific(), pthread_join(), pthread_key_create(), pthread_key_delete(), pthread_mutex_clocklock(), pthread_mutex_consistent(), pthread_mutex_destroy(), pthread_mutex_getprioceiling(), pthread_mutex_lock(), pthread_mutexattr_destroy(), pthread_mutexattr_getprioceiling(), pthread_mutexattr_getprotocol(), pthread_mutexattr_getpshared(), pthread_mutexattr_getrobust(), pthread_mutexattr_gettype(), pthread_once(), pthread_rwlock_clockrdlock(), pthread_rwlock_clockwrlock(), pthread_rwlock_destroy(), pthread_rwlock_rdlock(), pthread_rwlock_trywrlock(), pthread_rwlock_unlock(), pthread_rwlockattr_destroy(), pthread_rwlockattr_getpshared(), pthread_self(), pthread_setcancelstate(), pthread_setschedprio(), pthread_spin_destroy(), pthread_spin_lock(), pthread_spin_unlock()
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The RTT margin markers are broken out into their POSIX options.
The Open Group Corrigendum U021/9 is applied, correcting the prototype for the pthread_cond_wait() function.
The Open Group Corrigendum U026/2 is applied, correcting the prototype for the pthread_setschedparam() function so that its second argument is of type
int.
The pthread_getcpuclockid() and pthread_mutex_timedlock() functions are added for alignment with
IEEE Std 1003.1d-1999.
The following functions are added for alignment with IEEE Std 1003.1j-2000: pthread_barrier_destroy(), pthread_barrier_init(), pthread_barrier_wait(), pthread_barrierattr_destroy(), pthread_barrierattr_getpshared(), pthread_barrierattr_init(), pthread_barrierattr_setpshared(), pthread_condattr_getclock(), pthread_condattr_setclock(), pthread_rwlock_timedrdlock(), pthread_rwlock_timedwrlock(), pthread_spin_destroy(), pthread_spin_init(), pthread_spin_lock(), pthread_spin_trylock(), and pthread_spin_unlock().
PTHREAD_RWLOCK_INITIALIZER is removed for alignment with IEEE Std 1003.1j-2000.
Functions previously marked as part of the Read-Write Locks option are now moved to the Threads option.
The restrict keyword is added to the prototypes for pthread_attr_getguardsize(), pthread_attr_getinheritsched(), pthread_attr_getschedparam(), pthread_attr_getschedpolicy(), pthread_attr_getscope(), pthread_attr_getstackaddr,() pthread_attr_getstacksize(), pthread_attr_setschedparam(), pthread_barrier_init(), pthread_barrierattr_getpshared(), pthread_cond_init(), pthread_cond_signal(), pthread_cond_timedwait(), pthread_cond_wait(), pthread_condattr_getclock(), pthread_condattr_getpshared(), pthread_create(), pthread_getschedparam(), pthread_mutex_getprioceiling(), pthread_mutex_init(), pthread_mutex_setprioceiling(), pthread_mutexattr_getprioceiling(), pthread_mutexattr_getprotocol(), pthread_mutexattr_getpshared(), pthread_mutexattr_gettype(), pthread_rwlock_init(), pthread_rwlock_timedrdlock(), pthread_rwlock_timedwrlock(), pthread_rwlockattr_getpshared(), and pthread_sigmask().
IEEE PASC Interpretation 1003.1 #86 is applied, allowing the symbols from  and  to be made
visible when  is included. Previously this was an XSI option.
IEEE PASC Interpretation 1003.1c #42 is applied, removing the requirement for prototypes for the pthread_kill() and pthread_sigmask() functions. These are required to be in the  header. They are allowed here through the name space rules.
IEEE PASC Interpretation 1003.1 #96 is applied, adding the pthread_setschedprio() function.
IEEE Std 1003.1-2001/Cor 1-2002, item XBD/TC1/D6/13 is applied, correcting shading errors that were
in contradiction with the System Interfaces volume of POSIX.1-2024.
Issue 7
SD5-XBD-ERN-55 is applied, adding the restrict keyword to the pthread_mutex_timedlock() function prototype.
SD5-XBD-ERN-62 is applied.
Austin Group Interpretation 1003.1-2001 #048 is applied, reinstating the PTHREAD_RWLOCK_INITIALIZER symbol.
The  header is moved from the Threads option to the Base.
The following extended mutex types are moved from the XSI option to the Base:
PTHREAD_MUTEX_NORMAL
PTHREAD_MUTEX_ERRORCHECK
PTHREAD_MUTEX_RECURSIVE
PTHREAD_MUTEX_DEFAULT
The PTHREAD_MUTEX_ROBUST and PTHREAD_MUTEX_STALLED symbols and the pthread_mutex_consistent(), pthread_mutexattr_getrobust(), and pthread_mutexattr_setrobust() functions are added from The Open Group
Technical Standard, 2006, Extended API Set Part 2.
Functionality relating to the Thread Priority Protection and Thread Priority Inheritance options is changed to be
Non-Robust Mutex or Robust Mutex Priority Protection and Non-Robust Mutex or Robust Mutex Priority Inheritance, respectively.
This reference page is clarified with respect to macros and symbolic constants.
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0069 [624] is applied.
Issue 8
Austin Group Defect 599 is applied, adding the PTHREAD_NULL constant.
Austin Group Defect 851 is applied, marking pthread_atfork()
as obsolescent.
Austin Group Defect 1216 is applied, adding pthread_cond_clockwait(), pthread_mutex_clocklock(), pthread_rwlock_clockrdlock(), and pthread_rwlock_clockwrlock().
Austin Group Defect 1302 is applied, adding _Noreturn to pthread_exit().
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/sys_types.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sys/types.h — data types
SYNOPSIS
#include
DESCRIPTION
The  header shall define at least the following types:
blkcnt_t
Used for file block counts.
blksize_t
Used for block sizes.
clock_t
Used for system times in clock ticks or CLOCKS_PER_SEC; see .
clockid_t
Used for clock ID type in the clock and timer functions.
dev_t
Used for device IDs.
fsblkcnt_t
Used for file system block counts.
fsfilcnt_t
Used for file system file counts.
gid_t
Used for group IDs.
id_t
Used as a general identifier; can be used to contain at least a pid_t, uid_t, or gid_t.
ino_t
Used for file serial numbers.
key_t
[XSI]
Used for XSI interprocess communication.
mode_t
Used for some file attributes.
nlink_t
Used for link counts.
off_t
Used for file sizes.
pid_t
Used for process IDs and process group IDs.
pthread_attr_t
Used to identify a thread attribute object.
pthread_barrier_t
Used to identify a barrier.
pthread_barrierattr_t
Used to define a barrier attributes object.
pthread_cond_t
Used for condition variables.
pthread_condattr_t
Used to identify a condition attribute object.
pthread_key_t
Used for thread-specific data keys.
pthread_mutex_t
Used for mutexes.
pthread_mutexattr_t
Used to identify a mutex attribute object.
pthread_once_t
Used for dynamic package initialization.
pthread_rwlock_t
Used for read-write locks.
pthread_rwlockattr_t
Used for read-write lock attributes.
pthread_spinlock_t
Used to identify a spin lock.
pthread_t
Used to identify a thread.
reclen_t
Used for directory entry lengths.
size_t
Used for sizes of objects.
ssize_t
Used for a count of bytes or an error indication.
suseconds_t
Used for time in microseconds.
time_t
Used for time in seconds.
timer_t
Used for timer ID returned by timer_create().
uid_t
Used for user IDs.
All of the types shall be defined as arithmetic types of an appropriate length, with the following exceptions:
pthread_attr_t
pthread_barrier_t
pthread_barrierattr_t
pthread_cond_t
pthread_condattr_t
pthread_key_t
pthread_mutex_t
pthread_mutexattr_t
pthread_once_t
pthread_rwlock_t
pthread_rwlockattr_t
pthread_spinlock_t
pthread_t
timer_t
Additionally:
mode_t shall be an integer type.
dev_t shall be an integer type.
nlink_t, uid_t, gid_t, and id_t shall be integer types.
blkcnt_t and off_t shall be signed integer types.
fsblkcnt_t, fsfilcnt_t, reclen_t, and ino_t shall be defined as unsigned integer types.
size_t shall be an unsigned integer type.
blksize_t, pid_t, and ssize_t shall be signed integer types.
clock_t shall be an integer or real-floating type.
[CX]
time_t shall be an integer type with a width (see ) of at
least 64 bits.
The type ssize_t shall be capable of storing values at least in the range [-1, {SSIZE_MAX}].
[XSI]
The type suseconds_t shall be a signed integer type capable of storing values at least in the range [-1, 1000000].
The implementation shall support one or more programming environments in which the widths of blksize_t, pid_t,
size_t, ssize_t, and suseconds_t are no greater than the width of type long. The names of these
programming environments can be obtained using the confstr() function or the
getconf utility.
There are no defined comparison or assignment operators for the following types:
pthread_attr_t
pthread_barrier_t
pthread_barrierattr_t
pthread_cond_t
pthread_condattr_t
pthread_mutex_t
pthread_mutexattr_t
pthread_rwlock_t
pthread_rwlockattr_t
pthread_spinlock_t
timer_t
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
,
XSH confstr()
XCU getconf
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The clockid_t and timer_t types are defined for alignment with the POSIX Realtime Extension.
The types blkcnt_t, blksize_t, fsblkcnt_t, fsfilcnt_t, and suseconds_t are added.
Large File System extensions are added.
Updated for alignment with the POSIX Threads Extension.
Issue 6
The pthread_barrier_t, pthread_barrierattr_t, and pthread_spinlock_t types are added for alignment with
IEEE Std 1003.1j-2000.
The margin code is changed from XSI to THR for the pthread_rwlock_t and pthread_rwlockattr_t types as Read-Write
Locks have been absorbed into the POSIX Threads option. The threads types are marked THR.
IEEE Std 1003.1-2001/Cor 2-2004, item XBD/TC2/D6/26 is applied, adding pthread_t to the list of types that
are not required to be arithmetic types, thus allowing pthread_t to be defined as a structure.
Issue 7
Austin Group Interpretation 1003.1-2001 #033 is applied, requiring key_t to be an arithmetic type.
The Trace option types are marked obsolescent.
The clock_t and id_t types are moved from the XSI option to the Base.
The pthread_barrier_t and pthread_barrierattr_t types are moved from the Barriers option to the Base.
The pthread_spinlock_t type is moved from the Spin Locks option to the Base.
Functionality relating to the Timers and Threads options is moved to the Base.
POSIX.1-2008, Technical Corrigendum 1, XBD/TC1-2008/0069 [210], XBD/TC1-2008/0070 [28], XBD/TC1-2008/0071 [376],
XBD/TC1-2008/0072 [210], and XBD/TC1-2008/0073 [327] are applied.
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0079 [856] and XBD/TC2-2008/0080 [659] are applied.
Issue 8
Austin Group Defect 697 is applied, adding reclen_t.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
Austin Group Defect 1462 is applied, changing time_t to have a width of at least 64 bits.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/netdb.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
netdb.h — definitions for network database operations
SYNOPSIS
#include
DESCRIPTION
The  header shall define the hostent structure, which shall include at least the following
members:
char   *h_name       Official name of the host.
char  **h_aliases    A pointer to an array of pointers to
alternative host names, terminated by a
null pointer.
int     h_addrtype   Address type.
int     h_length     The length, in bytes, of the address.
char  **h_addr_list  A pointer to an array of pointers to network
addresses (in network byte order) for the host,
terminated by a null pointer.
The  header shall define the netent structure, which shall include at least the following
members:
char     *n_name      Official, fully-qualified (including the
domain) name of the host.
char    **n_aliases   A pointer to an array of pointers to
alternative network names, terminated by a
null pointer.
int       n_addrtype  The address type of the network.
uint32_t  n_net       The network number, in host byte order.
The  header shall define the uint32_t type as described in .
The  header shall define the protoent structure, which shall include at least the following
members:
char   *p_name     Official name of the protocol.
char  **p_aliases  A pointer to an array of pointers to
alternative protocol names, terminated by
a null pointer.
int     p_proto    The protocol number.
The  header shall define the servent structure, which shall include at least the following
members:
char   *s_name     Official name of the service.
char  **s_aliases  A pointer to an array of pointers to
alternative service names, terminated by
a null pointer.
int     s_port     A value which, when converted to uint16_t,
yields the port number in network byte order
at which the service resides.
char   *s_proto    The name of the protocol to use when
contacting the service.
The  header shall define the IPPORT_RESERVED symbolic constant with the value of the highest reserved
Internet port number.
Address Information Structure
The  header shall define the addrinfo structure, which shall include at least the following
members:
int               ai_flags      Input flags.
int               ai_family     Address family of socket.
int               ai_socktype   Socket type.
int               ai_protocol   Protocol of socket.
socklen_t         ai_addrlen    Length of socket address.
struct sockaddr  *ai_addr       Socket address of socket.
char             *ai_canonname  Canonical name of service location.
struct addrinfo  *ai_next       Pointer to next in list.
The addrinfo structure shall not include any additional members which have a floating-point type if an object of that
type with an all-bits-zero representation does not have the value 0.0.
[MX]
Implementations that define __STDC_IEC_559__ are required to treat the all-zero bit pattern for a floating point object as a
representation of 0.0, and may therefore have floating-point type members.
The  header shall define the following symbolic constants that evaluate to bitwise-distinct integer
constants for use in the ai_flags field of the addrinfo structure:
AI_PASSIVE
Socket address is intended for bind().
AI_CANONNAME
Request for canonical name.
AI_NUMERICHOST
Return numeric host address as name.
AI_NUMERICSERV
Inhibit service name resolution.
AI_V4MAPPED
If no IPv6 addresses are found, query for IPv4 addresses and return them to the caller as IPv4-mapped IPv6 addresses.
AI_ALL
Query for both IPv4 and IPv6 addresses.
AI_ADDRCONFIG
Query for IPv4 addresses only when an IPv4 address is configured; query for IPv6 addresses only when an IPv6 address is
configured.
The  header shall define the following symbolic constants that evaluate to bitwise-distinct integer
constants for use in the flags argument to getnameinfo():
NI_NOFQDN
Only the nodename portion of the FQDN is returned for local hosts.
NI_NUMERICHOST
The numeric form of the node's address is returned instead of its name.
NI_NAMEREQD
Return an error if the node's name cannot be located in the database.
NI_NUMERICSERV
The numeric form of the service address is returned instead of its name.
NI_NUMERICSCOPE
For IPv6 addresses, the numeric form of the scope identifier is returned instead of its name.
NI_DGRAM
Indicates that the service is a datagram service (SOCK_DGRAM).
Address Information Errors
The  header shall define the following symbolic constants for use as error values for getaddrinfo() and getnameinfo(). The
values shall be suitable for use in #if preprocessing directives.
EAI_AGAIN
The name could not be resolved at this time. Future attempts may succeed.
EAI_BADFLAGS
The flags had an invalid value.
EAI_FAIL
A non-recoverable error occurred.
EAI_FAMILY
The address family was not recognized or the address length was invalid for the specified family.
EAI_MEMORY
There was a memory allocation failure.
EAI_NONAME
The name does not resolve for the supplied parameters.
NI_NAMEREQD is set and the host's name cannot be located, or both nodename and servname were null.
EAI_SERVICE
The service passed was not recognized for the specified socket type.
EAI_SOCKTYPE
The intended socket type was not recognized.
EAI_SYSTEM
A system error occurred. The error code can be found in errno.
EAI_OVERFLOW
An argument buffer overflowed.
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
void              endhostent(void);
void              endnetent(void);
void              endprotoent(void);
void              endservent(void);
void              freeaddrinfo(struct addrinfo *);
const char       *gai_strerror(int);
int               getaddrinfo(const char *restrict, const char *restrict,
const struct addrinfo *restrict,
struct addrinfo **restrict);
struct hostent   *gethostent(void);
int               getnameinfo(const struct sockaddr *restrict, socklen_t,
char *restrict, socklen_t, char *restrict,
socklen_t, int);
struct netent    *getnetbyaddr(uint32_t, int);
struct netent    *getnetbyname(const char *);
struct netent    *getnetent(void);
struct protoent  *getprotobyname(const char *);
struct protoent  *getprotobynumber(int);
struct protoent  *getprotoent(void);
struct servent   *getservbyname(const char *, const char *);
struct servent   *getservbyport(int, const char *);
struct servent   *getservent(void);
void              sethostent(int);
void              setnetent(int);
void              setprotoent(int);
void              setservent(int);
The  header shall define the socklen_t type through typedef, as described in .
Inclusion of the  header may also make visible all symbols from , , and .
The following sections are informative.
APPLICATION USAGE
The requirement that addrinfo does not include any additional members which have a floating-point type if an object of
that type with an all-bits-zero representation does not have the value 0.0 is to allow initialization of an addrinfo
hints structure (see XSH freeaddrinfo()) using:
struct addrinfo hints;
memset(&hints, 0, sizeof hints);
as an alternative to the use of default initialization.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
, ,
XSH bind(), endhostent(),
endnetent(), endprotoent(),
endservent(), freeaddrinfo(), gai_strerror(),
getnameinfo()
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
The Open Group Base Resolution bwg2001-009 is applied, which changes the return type for gai_strerror() from char * to const char *. This is for coordination with
the IPnG Working Group.
IEEE Std 1003.1-2001/Cor 1-2002, item XBD/TC1/D6/11 is applied, adding a description of the NI_NUMERICSCOPE macro
and correcting the getnameinfo() function prototype. These changes are for
alignment with IPv6.
Issue 7
SD5-XBD-ERN-14 is applied, changing the description of the s_port member of the servent structure.
The obsolescent h_errno external integer, and the obsolescent gethostbyaddr() and gethostbyname() functions
are removed, along with the HOST_NOT_FOUND, NO_DATA, NO_RECOVERY, and TRY_AGAIN macros.
This reference page is clarified with respect to macros and symbolic constants.
Issue 8
Austin Group Defect 940 is applied, requiring that the addrinfo structure does not include any additional members which
have a floating-point type if an object of that type with an all-bits-zero representation does not have the value 0.0.
Austin Group Defect 1289 is applied, removing some redundant text from the DESCRIPTION.
Austin Group Defect 1327 is applied, changing "flags" to "ai_flags".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/signal.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
signal.h — signals
SYNOPSIS
#include
DESCRIPTION
[CX]  Some of the functionality described on this reference page extends the ISO C standard. Applications shall define
the appropriate feature test macro (see XSH 2.2 The Compilation
Environment) to enable the visibility of these symbols in this header.
The  header shall define the following macros, which shall expand to constant expressions with distinct
values that have a type compatible with the second argument to, and the return value of, the signal() function, and whose values shall compare unequal to the address of any declarable
function.
SIG_DFL
Request for default signal handling.
SIG_ERR
Return value from signal() in case of error.
SIG_IGN
Request that signal be ignored.
[CX]  The
header shall define the pthread_t, size_t, and uid_t types as described in .
The  header shall define the timespec structure as described in .
The  header shall define the following data types:
sig_atomic_t
Possibly volatile-qualified integer type of an object that can be accessed as an atomic entity, even in the presence of
asynchronous interrupts.
sigset_t
[CX]
Integer or structure type of an object used to represent sets of signals.
pid_t
[CX]  As
described in .
[CX]  The
header shall define the pthread_attr_t type as described in .
The  header shall define the sigevent structure, which shall include at least the following
members:
int              sigev_notify            Notification type.
int              sigev_signo             Signal number.
union sigval     sigev_value             Signal value.
void           (*sigev_notify_function)(union sigval)
Notification function.
pthread_attr_t *sigev_notify_attributes  Notification attributes.
The  header shall define the following symbolic constants for the values of sigev_notify:
SIGEV_NONE
No asynchronous notification is delivered when the event of interest occurs.
SIGEV_SIGNAL
A queued signal, with an application-defined value, is generated when the event of interest occurs.
SIGEV_THREAD
A notification function is called to perform notification.
The sigval union shall be defined as:
int    sival_int    Integer signal value.
void  *sival_ptr    Pointer signal value.
The  header shall declare the SIGRTMIN and SIGRTMAX macros, which shall expand to positive integer
expressions with type int, but which need not be constant expressions. These macros specify a range of signal numbers that
are reserved for application use and for which the realtime signal behavior specified in this volume of POSIX.1-2024 is supported.
The signal numbers in this range do not overlap any of the signals specified in the following table.
The range SIGRTMIN through SIGRTMAX inclusive shall include at least {RTSIG_MAX} signal numbers. The value of SIGRTMAX shall be
less than the value returned by sysconf(_SC_NSIG).
It is implementation-defined whether realtime signal behavior is supported for other signals.
The  header shall define the following symbolic constant. The value shall be suitable for use in
#if preprocessing directives:
SIG2STR_MAX
Maximum size of a signal name returned by sig2str(), including the terminating
null byte.
The  header shall define the following macros that are used to refer to the signals that occur in the
system. Signals defined here begin with the letters SIG followed by an uppercase letter. The macros shall expand to positive
integer constant expressions with type int and distinct values [CX]
less than the value of {NSIG_MAX} defined in .  The value
0 is reserved for use as the null signal (see kill()). Additional
implementation-defined signals may occur in the system.
The ISO C standard only requires the signal names SIGABRT, SIGFPE, SIGILL, SIGINT, SIGSEGV, and SIGTERM to be defined. An
implementation need not generate any of these six signals, except as a result of explicit use of interfaces that generate signals,
such as raise(), [CX]  kill(), the General Terminal
Interface (see 11.1.9 Special Characters), and the kill utility, unless otherwise stated (see, for example, XSH 2.8.3.3 Memory Protection).
The following signals shall be supported on all implementations (default actions are explained below the table):
Signal
Default Action
Description
SIGABRT
A
Process abort signal.
SIGALRM
T
Alarm clock.
SIGBUS
A
Access to an undefined portion of a memory object.
SIGCHLD
I
Child process terminated, stopped,
[XSI]
or continued.
SIGCONT
C
Continue executing, if stopped.
SIGFPE
A
Erroneous arithmetic operation.
SIGHUP
T
Hangup.
SIGILL
A
Illegal instruction.
SIGINT
T
Terminal interrupt signal.
SIGKILL
T
Kill (cannot be caught or ignored).
SIGPIPE
T
Write on a pipe with no one to read it.
SIGQUIT
A
Terminal quit signal.
SIGSEGV
A
Invalid memory reference.
SIGSTOP
S
Stop executing (cannot be caught or ignored).
SIGTERM
T
Termination signal.
SIGTSTP
S
Terminal stop signal.
SIGTTIN
S
Background process attempting read.
SIGTTOU
S
Background process attempting write.
SIGUSR1
T
User-defined signal 1.
SIGUSR2
T
User-defined signal 2.
SIGWINCH
I
Terminal window size changed.
[XSI]  SIGSYS
A
Bad system call.
SIGTRAP
A
Trace/breakpoint trap.
SIGURG
I
High bandwidth data is available at a socket.
[XSI]  SIGVTALRM
T
Virtual timer expired.
SIGXCPU
A
CPU time limit exceeded.
SIGXFSZ
A
File size limit exceeded.
The default actions are as follows:
T
Abnormal termination of the process.
A
Abnormal termination of the process with additional actions.
I
Ignore the signal.
S
Stop the process.
C
Continue the process, if it is stopped; otherwise, ignore the signal.
The effects on the process in each case are described in XSH 2.4.3 Signal Actions.
[CX]  The  header shall declare the sigaction structure, which shall include at least the
following members:
void   (*sa_handler)(int)  Pointer to a signal-catching function
or one of the SIG_IGN or SIG_DFL.
sigset_t sa_mask           Set of signals to be blocked during execution
of the signal handling function.
int      sa_flags          Special flags.
void   (*sa_sigaction)(int, siginfo_t *, void *)
Pointer to a signal-catching function.
[CX]  The storage occupied by sa_handler and sa_sigaction may overlap, and a conforming application shall not
use both simultaneously.
The  header shall define the following macros which shall expand to integer constant
expressions that need not be usable in #if preprocessing directives:
SIG_BLOCK
[CX]
The resulting set is the union of the current set and the signal set pointed to by the argument set.
SIG_UNBLOCK
[CX]
The resulting set is the intersection of the current set and the complement of the signal set pointed to by the argument
set.
SIG_SETMASK
[CX]
The resulting set is the signal set pointed to by the argument set.
The  header shall also define the following symbolic constants:
SA_NOCLDSTOP
[CX]  Do
not generate SIGCHLD when children stop
[XSI]
or stopped children continue.
SA_ONSTACK
[XSI]
Causes signal delivery to occur on an alternate stack.
SA_RESETHAND
[CX]
Causes signal dispositions to be set to SIG_DFL on entry to signal handlers.
SA_RESTART
[CX]
Causes certain functions to become restartable.
SA_SIGINFO
[CX]
Causes extra information to be passed to signal handlers at the time of receipt of a signal.
SA_NOCLDWAIT
[XSI]
Causes implementations not to create zombie processes or status information on child termination. See sigaction().
SA_NODEFER
[CX]
Causes signal not to be automatically blocked on entry to signal handler.
SS_ONSTACK
[XSI]
Process is executing on an alternate signal stack.
SS_DISABLE
[XSI]
Alternate signal stack is disabled.
MINSIGSTKSZ
[XSI]
Minimum stack size for a signal handler.
SIGSTKSZ
[XSI]
Default size in bytes for the alternate signal stack.
[CX]  The  header shall define the mcontext_t type through typedef.
[CX]  The  header shall define the ucontext_t type as a structure that shall include at least
the following members:
ucontext_t *uc_link     Pointer to the context that is resumed
when this context returns.
sigset_t    uc_sigmask  The set of signals that are blocked when this
context is active.
stack_t     uc_stack    The stack used by this context.
mcontext_t  uc_mcontext A machine-specific representation of the saved
context.
The  header shall define the stack_t type as a structure, which shall include at
least the following members:
void     *ss_sp       Stack base or pointer.
size_t    ss_size     Stack size.
int       ss_flags    Flags.
[CX]  The  header shall define the siginfo_t type as a structure, which shall include at least
the following members:
[CX]
int           si_signo  Signal number.
int           si_code   Signal code.
[XSI]
int           si_errno  If non-zero, an errno value associated with
this signal, as described in .
[CX]
pid_t         si_pid    Sending process ID.
uid_t         si_uid    Real user ID of sending process.
void         *si_addr   Address that caused fault.
int           si_status Exit value or signal.
union sigval  si_value  Signal value.
[CX]  The  header shall define the symbolic constants in the Code column of the following table
for use as values of si_code that are signal-specific or non-signal-specific reasons why the signal was generated.
Signal
Code
Reason
[CX]  SIGILL
ILL_ILLOPC
Illegal opcode.
ILL_ILLOPN
Illegal operand.
ILL_ILLADR
Illegal addressing mode.
ILL_ILLTRP
Illegal trap.
ILL_PRVOPC
Privileged opcode.
ILL_PRVREG
Privileged register.
ILL_COPROC
Coprocessor error.
ILL_BADSTK
Internal stack error.
SIGFPE
FPE_INTDIV
Integer divide by zero.
FPE_INTOVF
Integer overflow.
FPE_FLTDIV
Floating-point divide by zero.
FPE_FLTOVF
Floating-point overflow.
FPE_FLTUND
Floating-point underflow.
FPE_FLTRES
Floating-point inexact result.
FPE_FLTINV
Invalid floating-point operation.
FPE_FLTSUB
Subscript out of range.
SIGSEGV
SEGV_MAPERR
Address not mapped to object.
SEGV_ACCERR
Invalid permissions for mapped object.
SIGBUS
BUS_ADRALN
Invalid address alignment.
BUS_ADRERR
Nonexistent physical address.
BUS_OBJERR
Object-specific hardware error.
[XSI]  SIGTRAP
TRAP_BRKPT
Process breakpoint.
TRAP_TRACE
Process trace trap.
[CX]  SIGCHLD
CLD_EXITED
Child has exited.
CLD_KILLED
Child has terminated abnormally with no additional actions.
CLD_DUMPED
Child has terminated abnormally and additional actions may have been taken.
CLD_TRAPPED
Traced child has trapped.
CLD_STOPPED
Child has stopped.
CLD_CONTINUED
Stopped child has continued.
Any
SI_USER
Signal sent by kill().
SI_QUEUE
Signal sent by sigqueue().
SI_TIMER
Signal generated by expiration of a timer set by timer_settime().
SI_ASYNCIO
Signal generated by completion of an asynchronous I/O
request.
SI_MESGQ
Signal generated by arrival of a message on an empty message
queue.
[CX]  Implementations may support additional si_code values not included in this list, may generate values included in
this list under circumstances other than those described in this list, and may contain extensions or limitations that prevent some
values from being generated. Implementations do not generate a different value from the ones described in this list for
circumstances described in this list.
[CX]  In addition, the following signal-specific information shall be available:
Signal
Member
Value
SIGILL
void * si_addr
Address of faulting instruction.
SIGFPE
SIGSEGV
void * si_addr
Address of faulting memory reference.
SIGBUS
SIGCHLD
pid_t si_pid
Child process ID.
int si_status
If si_code is equal to CLD_EXITED, then si_status holds the exit value of the process; otherwise, it
is equal to the signal that caused the process to change state. The exit value in si_status shall be equal to the full exit
value (that is, the value passed to _exit(), _Exit(), or exit(), or returned from
main()); it shall not be limited to the least significant eight bits of the value.
uid_t si_uid
Real user ID of the process that sent the signal.
For some implementations, the value of si_addr may be inaccurate.
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be
provided.
[CX]
int    kill(pid_t, int);
[XSI]
int    killpg(pid_t, int);
[CX]
void   psiginfo(const siginfo_t *, const char *);
void   psignal(int, const char *);
int    pthread_kill(pthread_t, int);
int    pthread_sigmask(int, const sigset_t *restrict,
sigset_t *restrict);
int    raise(int);
[CX]
int    sig2str(int, char *);
int    sigaction(int, const struct sigaction *restrict,
struct sigaction *restrict);
int    sigaddset(sigset_t *, int);
[XSI]
int    sigaltstack(const stack_t *restrict, stack_t *restrict);
[CX]
int    sigdelset(sigset_t *, int);
int    sigemptyset(sigset_t *);
int    sigfillset(sigset_t *);
int    sigismember(const sigset_t *, int);
void (*signal(int, void (*)(int)))(int);
[CX]
int    sigpending(sigset_t *);
int    sigprocmask(int, const sigset_t *restrict, sigset_t *restrict);
int    sigqueue(pid_t, int, union sigval);
int    sigsuspend(const sigset_t *);
int    sigtimedwait(const sigset_t *restrict, siginfo_t *restrict,
const struct timespec *restrict);
int    sigwait(const sigset_t *restrict, int *restrict);
int    sigwaitinfo(const sigset_t *restrict, siginfo_t *restrict);
int    str2sig(const char *restrict, int *restrict);
[CX]  Inclusion of the  header may make visible all symbols from the  header.
The following sections are informative.
APPLICATION USAGE
On systems not supporting the XSI option, the si_pid and si_uid members of siginfo_t are only required to
be valid when si_code is SI_USER or SI_QUEUE. On XSI-conforming systems, they are also valid for all si_code values
less than or equal to 0; however, it is unspecified whether SI_USER and SI_QUEUE have values less than or equal to zero, and
therefore XSI applications should check whether si_code has the value SI_USER or SI_QUEUE or is less than or equal to 0 to
tell whether si_pid and si_uid are valid.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
,
, ,
XSH 2.2 The Compilation Environment, alarm(), kill(), killpg(), psiginfo(), pthread_kill(), pthread_sigmask(), raise(),
sig2str(), sigaction(),
sigaddset(), sigaltstack(),
sigdelset(), sigemptyset(),
sigfillset(), sigismember()
, signal(), sigpending(),
sigqueue(), sigsuspend(),
sigtimedwait(), sigwait(),
timer_create(), wait()
, waitid()
XCU kill
CHANGE HISTORY
First released in Issue 1.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Realtime Extension and the POSIX Threads Extension.
The default action for SIGURG is changed from i to iii. The function prototype for sigmask() is removed.
Issue 6
The Open Group Corrigendum U035/2 is applied. In the DESCRIPTION, the wording for abnormal termination is clarified.
The Open Group Corrigendum U028/8 is applied, correcting the prototype for the sigset() function.
The Open Group Corrigendum U026/3 is applied, correcting the type of the sigev_notify_function function
member of the sigevent structure.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX
Specification:
The SIGCHLD, SIGCONT, SIGSTOP, SIGTSTP, SIGTTIN, and SIGTTOU signals are now mandated. This is also a FIPS
requirement.
The pid_t definition is mandated.
The RT markings are changed to RTS to denote that the semantics are part of the Realtime Signals Extension
option.
The restrict keyword is added to the prototypes for sigaction(), sigaltstack(), sigprocmask(), sigtimedwait(),
sigwait(), and sigwaitinfo().
IEEE PASC Interpretation 1003.1 #85 is applied, adding the statement that symbols from  may be made visible when  is included.
Extensions beyond the ISO C standard are marked.
IEEE Std 1003.1-2001/Cor 1-2002, item XBD/TC1/D6/14 is applied, changing the descriptive text for
members of the sigaction structure.
IEEE Std 1003.1-2001/Cor 1-2002, item XBD/TC1/D6/15 is applied, correcting the definition of the
sa_sigaction member of the sigaction structure.
IEEE Std 1003.1-2001/Cor 2-2004, item XBD/TC2/D6/24 is applied, reworking the ordering of the
siginfo_t type structure in the DESCRIPTION. This is an editorial change and no normative change is intended.
Issue 7
SD5-XBD-ERN-5 is applied.
SD5-XBD-ERN-39 is applied, removing the sigstack structure which should have been removed at the same time
as the LEGACY sigstack() function.
SD5-XBD-ERN-56 is applied, adding a reference to  for the size_t type.
Austin Group Interpretation 1003.1-2001 #034 is applied.
The ucontext_t and mcontext_t structures are added here from the obsolescent
header.
The psiginfo() and psignal() functions are added from The Open Group Technical Standard, 2006, Extended API Set
Part 1.
The SIGPOLL and SIGPROF signals and text relating to the XSI STREAMS option are marked obsolescent.
The SA_RESETHAND, SA_RESTART, SA_SIGINFO, SA_NOCLDWAIT, and SA_NODEFER constants are moved from the XSI option to
the Base.
Functionality relating to the Realtime Signals Extension option is moved to the Base.
This reference page is clarified with respect to macros and symbolic constants, and declarations for the
pthread_attr_t, pthread_t, and uid_t types and the timespec structure are added.
SIGRTMIN and SIGRTMAX are required to be positive integer expressions.
The APPLICATION USAGE section is updated to describe the si_pid and si_uid members of
siginfo_t.
POSIX.1-2008, Technical Corrigendum 1, XBD/TC1-2008/0062 [208], XBD/TC1-2008/0063 [80], and XBD/TC1-2008/0064 [157]
are applied.
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0070 [536], XBD/TC2-2008/0071 [690], XBD/TC2-2008/0072 [594],
XBD/TC2-2008/0073 [844], and XBD/TC2-2008/0074 [536] are applied.
Issue 8
Austin Group Defect 741 is applied, restricting the value of SIGRTMAX to less than the value returned by
sysconf(_SC_NSIG) and the value of macros that are used to refer to the signals to less than {NSIG_MAX}.
Austin Group Defect 1138 is applied, adding sig2str() and str2sig().
Austin Group Defect 1141 is applied, changing the descriptions of CLD_KILLED and CLD_DUMPED.
Austin Group Defect 1151 is applied, adding SIGWINCH.
Austin Group Defect 1215 is applied, removing XSI shading from text relating to abnormal process termination with
additional actions.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
Austin Group Defect 1775 is applied, changing the description of the si_addr member of siginfo_t.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/regex.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
regex.h — regular expression matching types
SYNOPSIS
#include
DESCRIPTION
The  header shall define the structures and symbolic constants used by the regcomp(), regexec(), regerror(), and regfree() functions.
The  header shall define the regex_t structure type, which shall include at least the following
member:
size_t    re_nsub    Number of parenthesized subexpressions.
The  header shall define the size_t type as described in .
The  header shall define the regoff_t type as a signed integer type that can hold the largest value
that can be stored in either a ptrdiff_t type or a ssize_t type.
The  header shall define the regmatch_t structure type, which shall include at least the following
members:
regoff_t    rm_so    Byte offset from start of string
to start of substring.
regoff_t    rm_eo    Byte offset from start of string of the
first character after the end of substring.
The  header shall define the following symbolic constants for the cflags parameter to the regcomp() function:
REG_EXTENDED
Use Extended Regular Expressions.
REG_ICASE
Perform pattern matching in a case-insensitive manner.
REG_MINIMAL
Change default matching behavior to leftmost shortest possible match. Only applicable to REG_EXTENDED regular expressions.
REG_NOSUB
Report only success or fail in regexec().
REG_NEWLINE
Change the handling of .
The  header shall define the following symbolic constants for the eflags parameter to the regexec() function:
REG_NOTBOL
The  character ('^'), when taken as a special character, does not match the beginning of
string.
REG_NOTEOL
The  ('$'), when taken as a special character, does not match the end of string.
The  header shall define the following symbolic constants as error return values:
REG_NOMATCH
regexec() failed to match.
REG_BADPAT
Invalid regular expression.
REG_ECOLLATE
Invalid collating element referenced.
REG_ECTYPE
Invalid character class type referenced.
REG_EESCAPE
Trailing  character in pattern.
REG_ESUBREG
Number in \digit invalid or in error.
REG_EBRACK
"[]" imbalance.
REG_EPAREN
"\(\)" or "()" imbalance.
REG_EBRACE
"\{\}" imbalance.
REG_BADBR
Content of "\{\}" invalid: not a number, number too large, more than two numbers, first larger than second.
REG_ERANGE
Invalid endpoint in range expression.
REG_ESPACE
Out of memory.
REG_BADRPT
'?', '*', or '+' not preceded by valid regular expression.
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
int    regcomp(regex_t *restrict, const char *restrict, int);
size_t regerror(int, const regex_t *restrict, char *restrict, size_t);
int    regexec(const regex_t *restrict, const char *restrict, size_t,
regmatch_t [restrict], int);
void   regfree(regex_t *);
The implementation may define additional macros or constants using names beginning with REG_.
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XSH regcomp()
CHANGE HISTORY
First released in Issue 4.
Originally derived from the ISO POSIX-2 standard.
Issue 6
The REG_ENOSYS constant is marked obsolescent.
The restrict keyword is added to the prototypes for regcomp(), regerror(), and regexec().
A statement is added that the size_t type is defined as described in .
Issue 7
SD5-XBD-ERN-60 is applied.
The obsolescent REG_ENOSYS constant is removed.
This reference page is clarified with respect to macros and symbolic constants.
Issue 8
Austin Group Defect 793 is applied, adding REG_MINIMAL.
Austin Group Defect 1031 is applied, changing the description of REG_ICASE.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/langinfo.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
langinfo.h — language information constants
SYNOPSIS
#include
DESCRIPTION
The  header shall define the symbolic constants used to identify items of langinfo data (see
nl_langinfo()).
The  header shall define the locale_t type as described in .
The  header shall define the nl_item type as described in .
The  header shall define the following symbolic constants with type nl_item. The entries under
Category indicate in which setlocale() category each item is defined.
Constant
Category
Meaning
CODESET
LC_CTYPE
Codeset name.
D_T_FMT
LC_TIME
String for formatting date and time.
D_FMT
LC_TIME
Date format string.
T_FMT
LC_TIME
Time format string.
T_FMT_AMPM
LC_TIME
Time format string using 12-hour clock format, if supported in the locale; if the 12-hour format is not supported,
this shall be either an empty string or a string specifying a 24-hour clock format.
AM_STR
LC_TIME
Ante-meridiem affix; if AM_STR and PM_STR are both empty strings, the 12-hour format is not supported in the
locale.
PM_STR
LC_TIME
Post-meridiem affix; if AM_STR and PM_STR are both empty strings, the 12-hour format is not supported in the
locale.
DAY_1
LC_TIME
Name of the first day of the week (for example, Sunday).
DAY_2
LC_TIME
Name of the second day of the week (for example, Monday).
DAY_3
LC_TIME
Name of the third day of the week (for example, Tuesday).
DAY_4
LC_TIME
Name of the fourth day of the week (for example, Wednesday).
DAY_5
LC_TIME
Name of the fifth day of the week (for example, Thursday).
DAY_6
LC_TIME
Name of the sixth day of the week (for example, Friday).
DAY_7
LC_TIME
Name of the seventh day of the week (for example, Saturday).
ABDAY_1
LC_TIME
Abbreviated name of the first day of the week.
ABDAY_2
LC_TIME
Abbreviated name of the second day of the week.
ABDAY_3
LC_TIME
Abbreviated name of the third day of the week.
ABDAY_4
LC_TIME
Abbreviated name of the fourth day of the week.
ABDAY_5
LC_TIME
Abbreviated name of the fifth day of the week.
ABDAY_6
LC_TIME
Abbreviated name of the sixth day of the week.
ABDAY_7
LC_TIME
Abbreviated name of the seventh day of the week.
MON_1
LC_TIME
Name of the first month of the year.
MON_2
LC_TIME
Name of the second month.
MON_3
LC_TIME
Name of the third month.
MON_4
LC_TIME
Name of the fourth month.
MON_5
LC_TIME
Name of the fifth month.
MON_6
LC_TIME
Name of the sixth month.
MON_7
LC_TIME
Name of the seventh month.
MON_8
LC_TIME
Name of the eighth month.
MON_9
LC_TIME
Name of the ninth month.
MON_10
LC_TIME
Name of the tenth month.
MON_11
LC_TIME
Name of the eleventh month.
MON_12
LC_TIME
Name of the twelfth month.
ALTMON_1
LC_TIME
Name of the alternative appropriate first month of the year.
ALTMON_2
LC_TIME
Name of the alternative appropriate second month.
ALTMON_3
LC_TIME
Name of the alternative appropriate third month.
ALTMON_4
LC_TIME
Name of the alternative appropriate fourth month.
ALTMON_5
LC_TIME
Name of the alternative appropriate fifth month.
ALTMON_6
LC_TIME
Name of the alternative appropriate sixth month.
ALTMON_7
LC_TIME
Name of the alternative appropriate seventh month.
ALTMON_8
LC_TIME
Name of the alternative appropriate eighth month.
ALTMON_9
LC_TIME
Name of the alternative appropriate ninth month.
ALTMON_10
LC_TIME
Name of the alternative appropriate tenth month.
ALTMON_11
LC_TIME
Name of the alternative appropriate eleventh month.
ALTMON_12
LC_TIME
Name of the alternative appropriate twelfth month.
ABMON_1
LC_TIME
Abbreviated name of the first month.
ABMON_2
LC_TIME
Abbreviated name of the second month.
ABMON_3
LC_TIME
Abbreviated name of the third month.
ABMON_4
LC_TIME
Abbreviated name of the fourth month.
ABMON_5
LC_TIME
Abbreviated name of the fifth month.
ABMON_6
LC_TIME
Abbreviated name of the sixth month.
ABMON_7
LC_TIME
Abbreviated name of the seventh month.
ABMON_8
LC_TIME
Abbreviated name of the eighth month.
ABMON_9
LC_TIME
Abbreviated name of the ninth month.
ABMON_10
LC_TIME
Abbreviated name of the tenth month.
ABMON_11
LC_TIME
Abbreviated name of the eleventh month.
ABMON_12
LC_TIME
Abbreviated name of the twelfth month.
ABALTMON_1
LC_TIME
Abbreviated alternative name of the first month of the year.
ABALTMON_2
LC_TIME
Abbreviated alternative name of the second month.
ABALTMON_3
LC_TIME
Abbreviated alternative name of the third month.
ABALTMON_4
LC_TIME
Abbreviated alternative name of the fourth month.
ABALTMON_5
LC_TIME
Abbreviated alternative name of the fifth month.
ABALTMON_6
LC_TIME
Abbreviated alternative name of the sixth month.
ABALTMON_7
LC_TIME
Abbreviated alternative name of the seventh month.
ABALTMON_8
LC_TIME
Abbreviated alternative name of the eighth month.
ABALTMON_9
LC_TIME
Abbreviated alternative name of the ninth month.
ABALTMON_10
LC_TIME
Abbreviated alternative name of the tenth month.
ABALTMON_11
LC_TIME
Abbreviated alternative name of the eleventh month.
ABALTMON_12
LC_TIME
Abbreviated alternative name of the twelfth month.
ERA
LC_TIME
Era description segments.
ERA_D_FMT
LC_TIME
Era date format string.
ERA_D_T_FMT
LC_TIME
Era date and time format string.
ERA_T_FMT
LC_TIME
Era time format string.
ALT_DIGITS
LC_TIME
Alternative symbols for digits.
RADIXCHAR
LC_NUMERIC
Radix character.
THOUSEP
LC_NUMERIC
Separator for thousands.
YESEXPR
LC_MESSAGES
Affirmative response expression.
NOEXPR
LC_MESSAGES
Negative response expression.
CRNCYSTR
LC_MONETARY
Local currency symbol, preceded by '-' if the symbol should appear before the value, '+' if the
symbol should appear after the value, or '.' if the symbol should replace the radix character. If the local currency
symbol is the empty string, implementations may return the empty string ("").
If the locale's values for p_cs_precedes and n_cs_precedes do not match, the value of
nl_langinfo(CRNCYSTR) and nl_langinfo_l(CRNCYSTR,loc) is unspecified.
The following shall be declared as a function and may also be defined as a macro. A function prototype shall be
provided.
char *nl_langinfo(nl_item);
char *nl_langinfo_l(nl_item, locale_t);
Inclusion of the  header may also make visible all symbols from .
The following sections are informative.
APPLICATION USAGE
Wherever possible, users are advised to use functions compatible with those in the ISO C standard to access items of
langinfo data. In particular, the strftime() function should be used to
access date and time information defined in category LC_TIME . The localeconv() function should be used to access information corresponding to RADIXCHAR,
THOUSEP, and CRNCYSTR.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
7. Locale, ,
XSH nl_langinfo(), localeconv(), strfmon(), strftime()
CHANGE HISTORY
First released in Issue 2.
Issue 5
The constants YESSTR and NOSTR are marked LEGACY.
Issue 6
The constants YESSTR and NOSTR are removed.
IEEE Std 1003.1-2001/Cor 1-2002, item XBD/TC1/D6/9 is applied, adding a sentence to the "Meaning"
column entry for the CRNCYSTR constant. This change is to accommodate historic practice.
Issue 7
The  header is moved from the XSI option to the Base.
The nl_langinfo_l() function is added from The Open Group
Technical Standard, 2006, Extended API Set Part 4.
This reference page is clarified with respect to macros and symbolic constants, and a declaration for the
locale_t type is added.
POSIX.1-2008, Technical Corrigendum 1, XBD/TC1-2008/0051 [107] is applied.
Issue 8
Austin Group Defects 258 and 1166 are applied, adding the ALTMON_x and ABALTMON_x symbolic constants.
Austin Group Defect 1307 is applied, changing the AM_STR, PM_STR, and T_FMT_AMPM constants in relation to locales
that do not support the 12-hour clock format.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/uchar.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
uchar.h — Unicode character handling
SYNOPSIS
#include
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The  header shall define the following types:
mbstate_t
As described in .
size_t
As described in .
char16_t
The same type as uint_least16_t, described in .
char32_t
The same type as uint_least32_t, described in .
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
size_t  c16rtomb(char *restrict, char16_t, mbstate_t *restrict);
size_t  c32rtomb(char *restrict, char32_t, mbstate_t *restrict);
size_t  mbrtoc16(char16_t *restrict, const char *restrict, size_t,
mbstate_t *restrict);
size_t  mbrtoc32(char32_t *restrict, const char *restrict, size_t,
mbstate_t *restrict);
[CX]
Inclusion of the  header may make visible all symbols from the headers , , and
.
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
, ,
XSH c16rtomb(), mbrtoc16()
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/aio.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
aio.h — asynchronous input and output
SYNOPSIS
#include
DESCRIPTION
The  header shall define the aiocb structure, which shall include at least the following members:
int             aio_fildes     File descriptor.
off_t           aio_offset     File offset.
volatile void  *aio_buf        Location of buffer.
size_t          aio_nbytes     Length of transfer.
int             aio_reqprio    Request priority offset.
struct sigevent aio_sigevent   Signal number and value.
int             aio_lio_opcode Operation to be performed.
The  header shall define the off_t, pthread_attr_t, size_t, and ssize_t types as
described in .
The  header shall define the struct timespec structure as described in .
The  header shall define the sigevent structure and sigval union as described in .
The  header shall define the following symbolic constants:
AIO_ALLDONE
A return value indicating that none of the requested operations could be canceled since they are already complete.
AIO_CANCELED
A return value indicating that all requested operations have been canceled.
AIO_NOTCANCELED
A return value indicating that some of the requested operations could not be canceled since they are in progress.
LIO_NOP
A lio_listio() element operation option indicating that no transfer is
requested.
LIO_NOWAIT
A lio_listio() synchronization operation indicating that the calling thread
is to continue execution while the lio_listio() operation is being performed, and
no notification is given when the operation is complete.
LIO_READ
A lio_listio() element operation option requesting a read.
LIO_WAIT
A lio_listio() synchronization operation indicating that the calling thread
is to suspend until the lio_listio() operation is complete.
LIO_WRITE
A lio_listio() element operation option requesting a write.
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
int      aio_cancel(int, struct aiocb *);
int      aio_error(const struct aiocb *);
[FSC|SIO]
int      aio_fsync(int, struct aiocb *);
int      aio_read(struct aiocb *);
ssize_t  aio_return(struct aiocb *);
int      aio_suspend(const struct aiocb *const [], int,
const struct timespec *);
int      aio_write(struct aiocb *);
int      lio_listio(int, struct aiocb *restrict const [restrict], int,
struct sigevent *restrict);
Inclusion of the  header may make visible symbols defined in the headers , , and
.
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
,
, ,
XSH aio_cancel(), aio_error(), aio_fsync(), aio_read(), aio_return(), aio_suspend(), aio_write(),
fsync(), lio_listio(), lseek(), read(), write()
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The  header is marked as part of the Asynchronous Input and Output option.
The description of the constants is expanded.
The restrict keyword is added to the prototype for lio_listio().
Issue 7
The  header is moved from the Asynchronous Input and Output option to the Base.
This reference page is clarified with respect to macros and symbolic constants, and type and structure declarations are
added.
POSIX.1-2008, Technical Corrigendum 1, XBD/TC1-2008/0038 [98] is applied.
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0058 [579] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/dirent.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
dirent.h — format of directory entries
SYNOPSIS
#include
DESCRIPTION
The internal format of directories is unspecified.
The  header shall define the following type:
DIR
A type representing a directory stream. The DIR type may be an incomplete type.
It shall also define the structure dirent which shall include the following members:
ino_t  d_ino       File serial number.
char   d_name[]    Filename string of entry.
and the structure posix_dent which shall include the following members:
ino_t          d_ino      File serial number.
reclen_t       d_reclen   Length of this entry, including trailing
padding if necessary. See posix_getdents().
unsigned char  d_type     File type or unknown-file-type indication.
char           d_name[]   Filename string of this entry.
The array d_name in each of these structures is of unspecified size, but shall contain a filename of at most {NAME_MAX}
bytes followed by a terminating null byte.
The  header shall define the ino_t, reclen_t, size_t, and ssize_t types as
described in .
The  header shall define the following symbolic constants for the file types and unknown-file-type
indicator returned in the d_type member of the posix_dent structure. The values shall be distinct and shall be
suitable for use in #if preprocessing directives:
DT_BLK
Block special.
DT_CHR
Character special.
DT_DIR
Directory.
DT_FIFO
FIFO special.
DT_LNK
Symbolic link.
DT_REG
Regular.
DT_SOCK
Socket.
DT_UNKNOWN
Unknown file type.
The implementation may implement message queues, semaphores, shared memory objects [TYM]   or typed
memory objects   as distinct file types. The following macros
shall be provided to represent these types. The values shall be distinct from each other and from the above symbolic constants
beginning with DT_, except when a distinct file type is not implemented, in which case the corresponding constant shall have a
value that is never returned in d_type by posix_getdents(). The values
shall be suitable for use in #if preprocessing directives:
DT_MQ
Message queue.
DT_SEM
Semaphore.
DT_SHM
Shared memory object.
DT_TMO
[TYM]
Typed memory object.
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
int            alphasort(const struct dirent **, const struct dirent **);
int            closedir(DIR *);
int            dirfd(DIR *);
DIR           *fdopendir(int);
DIR           *opendir(const char *);
ssize_t        posix_getdents(int, void *, size_t, int);
struct dirent *readdir(DIR *);
[OB]
int            readdir_r(DIR *restrict, struct dirent *restrict,
struct dirent **restrict);
void           rewinddir(DIR *);
int            scandir(const char *, struct dirent ***,
int (*)(const struct dirent *),
int (*)(const struct dirent **,
const struct dirent **));
[XSI]
void           seekdir(DIR *, long);
long           telldir(DIR *);
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
Information similar to that in the  header is contained in a file  in 4.2 BSD and
4.3 BSD. The equivalent in these implementations of struct dirent from this volume of POSIX.1-2024 is struct direct.
The filename was changed because the name  was also used in earlier implementations to refer to definitions
related to the older access method; this produced name conflicts. The name of the structure was changed because this volume of
POSIX.1-2024 does not completely define what is in the structure, so it could be different on some implementations from struct
direct.
The posix_dent structure was based on existing structures used by traditional getdents() functions, but the name
was changed because the existing structures differed in name and in their members. Some used the dirent structure but this
is not required to include a d_type member, which is the main advantage of using posix_getdents() over readdir(). The
d_reclen member was included, even though some implementations return fixed-length entries and therefore do not need it, as
almost all existing code that used getdents() used d_reclen to iterate through the returned entries. Implementations
that return fixed-length entries can simply set d_reclen to that length in posix_getdents(). The type reclen_t for d_reclen was introduced,
instead of using unsigned short, so as not to create a requirement that {NAME_MAX} cannot be greater than (a value somewhat
smaller than) {SHRT_MAX}.
Implementations are encouraged to define a DT_FORCE_TYPE symbolic constant for use in the flags argument to posix_getdents(). See the RATIONALE for posix_getdents().
The name of an array of char of an unspecified size should not be used as an lvalue. Use of:
sizeof(d_name)
is incorrect; use:
strlen(d_name)
instead.
The array of char d_name cannot be assumed to have a fixed size. Implementations may define the d_name
array in the dirent and posix_dent structures to have size 1, or size greater than {NAME_MAX}, or use a flexible
array member, but in all cases the actual number of characters used for d_name is at least the length of the filename string
including the terminating NUL byte.
FUTURE DIRECTIONS
A future version of this standard may add a DT_FORCE_TYPE symbolic constant for use as described in the RATIONALE for posix_getdents().
SEE ALSO
XSH alphasort(), closedir()
, dirfd(), fdopendir(), posix_getdents(), readdir(),
rewinddir(), seekdir(),
telldir()
CHANGE HISTORY
First released in Issue 2.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Threads Extension.
Issue 6
The Open Group Corrigendum U026/7 is applied, correcting the prototype for readdir_r().
The restrict keyword is added to the prototype for readdir_r().
Issue 7
The alphasort(), dirfd(), and
scandir() functions are added from The Open Group Technical Standard, 2006, Extended
API Set Part 1.
The fdopendir() function is added from The Open Group Technical Standard, 2006,
Extended API Set Part 2.
Austin Group Interpretation 1003.1-2001 #110 is applied, clarifying the definition of the DIR type.
POSIX.1-2008, Technical Corrigendum 1, XBD/TC1-2008/0039 [291], XBD/TC1-2008/0040 [291], XBD/TC1-2008/0041 [291], and
XBD/TC1-2008/0042 [206] are applied.
Issue 8
Austin Group Defect 696 is applied, making readdir_r() obsolescent.
Austin Group Defect 697 is applied, adding posix_getdents().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/complex.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
complex.h — complex arithmetic
SYNOPSIS
#include
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
Implementations shall not define the macro __STDC_NO_COMPLEX__, except for profile implementations that define _POSIX_SUBPROFILE
(see 2.1.5.1 Subprofiling Considerations) in , which may define __STDC_NO_COMPLEX__ and, if they do so, need not provide
this header nor support any of its facilities.
The  header shall define the following macros:
complex
Expands to _Complex.
_Complex_I
Expands to a constant expression of type const float _Complex, with the value of the imaginary unit (that is, a number
i such that i2=-1).
imaginary
Expands to _Imaginary.
_Imaginary_I
Expands to a constant expression of type const float _Imaginary with the value of the imaginary unit.
I
Expands to either _Imaginary_I or _Complex_I. If _Imaginary_I is not defined, I expands to _Complex_I.
The macros imaginary and _Imaginary_I shall be defined if and only if the implementation supports imaginary types.
[MXC]
Implementations that support the IEC 60559 Complex Floating-Point option shall define the macros imaginary and _Imaginary_I, and
the macro I shall expand to _Imaginary_I.
An application may undefine and then, perhaps, redefine the complex, imaginary, and I macros.
The following shall be defined as macros.
double complex       CMPLX(double x, double y);
float complex        CMPLXF(float x, float y);
long double complex  CMPLXL(long double x, long double y);
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
double               cabs(double complex);
float                cabsf(float complex);
long double          cabsl(long double complex);
double complex       cacos(double complex);
float complex        cacosf(float complex);
double complex       cacosh(double complex);
float complex        cacoshf(float complex);
long double complex  cacoshl(long double complex);
long double complex  cacosl(long double complex);
double               carg(double complex);
float                cargf(float complex);
long double          cargl(long double complex);
double complex       casin(double complex);
float complex        casinf(float complex);
double complex       casinh(double complex);
float complex        casinhf(float complex);
long double complex  casinhl(long double complex);
long double complex  casinl(long double complex);
double complex       catan(double complex);
float complex        catanf(float complex);
double complex       catanh(double complex);
float complex        catanhf(float complex);
long double complex  catanhl(long double complex);
long double complex  catanl(long double complex);
double complex       ccos(double complex);
float complex        ccosf(float complex);
double complex       ccosh(double complex);
float complex        ccoshf(float complex);
long double complex  ccoshl(long double complex);
long double complex  ccosl(long double complex);
double complex       cexp(double complex);
float complex        cexpf(float complex);
long double complex  cexpl(long double complex);
double               cimag(double complex);
float                cimagf(float complex);
long double          cimagl(long double complex);
double complex       clog(double complex);
float complex        clogf(float complex);
long double complex  clogl(long double complex);
double complex       conj(double complex);
float complex        conjf(float complex);
long double complex  conjl(long double complex);
double complex       cpow(double complex, double complex);
float complex        cpowf(float complex, float complex);
long double complex  cpowl(long double complex, long double complex);
double complex       cproj(double complex);
float complex        cprojf(float complex);
long double complex  cprojl(long double complex);
double               creal(double complex);
float                crealf(float complex);
long double          creall(long double complex);
double complex       csin(double complex);
float complex        csinf(float complex);
double complex       csinh(double complex);
float complex        csinhf(float complex);
long double complex  csinhl(long double complex);
long double complex  csinl(long double complex);
double complex       csqrt(double complex);
float complex        csqrtf(float complex);
long double complex  csqrtl(long double complex);
double complex       ctan(double complex);
float complex        ctanf(float complex);
double complex       ctanh(double complex);
float complex        ctanhf(float complex);
long double complex  ctanhl(long double complex);
long double complex  ctanl(long double complex);
The following sections are informative.
APPLICATION USAGE
The  header is optional in the ISO C standard but is mandated by POSIX.1-2024. Note however that
subprofiles can choose to make this header optional (see 2.1.5.1
Subprofiling Considerations), and therefore application portability to subprofile implementations would benefit from
checking whether __STDC_NO_COMPLEX__ is defined before inclusion of .
Values are interpreted as radians, not degrees.
RATIONALE
The choice of I instead of i for the imaginary unit concedes to the widespread use of the identifier i for
other purposes. The application can use a different identifier, say j, for the imaginary unit by following the inclusion of
the  header with:
#undef I
#define j _Imaginary_I
An I suffix to designate imaginary constants is not required, as multiplication by I provides a sufficiently
convenient and more generally useful notation for imaginary terms. The corresponding real type for the imaginary unit is
float, so that use of I for algorithmic or notational convenience will not result in widening types.
On systems with imaginary types, the application has the ability to control whether use of the macro I introduces an imaginary
type, by explicitly defining I to be _Imaginary_I or _Complex_I. Disallowing imaginary types is useful for some applications
intended to run on implementations without support for such types.
The macro _Imaginary_I provides a test for whether imaginary types are supported.
The cis() function (cos(x) + I*sin(x)) was considered but rejected because its
implementation is easy and straightforward, even though some implementations could compute sine and cosine more efficiently in
tandem.
FUTURE DIRECTIONS
The following function names and the same names suffixed with f or l are reserved for future use, and may be added
to the declarations in the  header.
cerf()
cerfc()
cexp2()
cexpm1()
clog10()
clog1p()
clog2()
clgamma()
ctgamma()
SEE ALSO
XSH CMPLX(), cabs(), cacos(), cacosh(), carg(), casin(), casinh(), catan(), catanh(), ccos(), ccosh(), cexp(), cimag(), clog(), conj(), cpow(), cproj(), creal(), csin(), csinh(), csqrt(), ctan(), ctanh()
CHANGE HISTORY
First released in Issue 6. Included for alignment with the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning this header with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/unistd.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
unistd.h — standard symbolic constants and types
SYNOPSIS
#include
DESCRIPTION
The  header defines miscellaneous symbolic constants and types, and declares miscellaneous functions. The
actual values of the constants are unspecified except as shown. The contents of this header are shown below.
Version Test Macros
The  header shall define the following symbolic constants. The values shall be suitable for use in
#if preprocessing directives.
_POSIX_VERSION
Integer value indicating version of this standard (C-language binding) to which the implementation conforms. For implementations
conforming to POSIX.1-2024, the value shall be 202405L.
_POSIX2_VERSION
Integer value indicating version of the Shell and Utilities volume of POSIX.1 to which the implementation conforms. For
implementations conforming to POSIX.1-2024, the value shall be 202405L. For profile implementations that define _POSIX_SUBPROFILE
(see 2.1.5.1 Subprofiling Considerations) in
, _POSIX2_VERSION may be left undefined or be defined with the value -1 to indicate that the Shell and
Utilities volume of POSIX.1 is not supported. In this case, a call to sysconf(_SC_2_VERSION) shall return either 202405L or
-1 indicating that the Shell and Utilities volume of POSIX.1 is or is not, respectively, supported at runtime.
The  header shall define the following symbolic constant only if the implementation supports the XSI
option; see 2.1.4 XSI Conformance. If defined, its value shall be
suitable for use in #if preprocessing directives.
_XOPEN_VERSION
[XSI]
Integer value indicating version of the X/Open Portability Guide to which the implementation conforms. The value shall be 800.
Constants for Options and Option Groups
The following symbolic constants, if defined in , shall have a value of -1, 0, or greater, unless
otherwise specified below. For profile implementations that define _POSIX_SUBPROFILE (see 2.1.5.1 Subprofiling Considerations) in , constants
described below as always having a value greater than zero need not be defined and, if defined, may have a value of -1, 0, or
greater. The values shall be suitable for use in #if preprocessing directives.
If a symbolic constant is not defined or is defined with the value -1, the option is not supported for compilation. If it is
defined with a value greater than zero, the option shall always be supported when the application is executed. If it is defined
with the value zero, the option shall be supported for compilation and might or might not be supported at runtime. See 2.1.6 Options for further information about the conformance requirements of
these three categories of support.
_POSIX_ADVISORY_INFO
[ADV]
The implementation supports the Advisory Information option. If this symbol is defined in , it shall be
defined to be -1, 0, or 202405L. The value of this symbol reported by sysconf()
shall either be -1 or 202405L.
_POSIX_ASYNCHRONOUS_IO
The implementation supports asynchronous input and output. This symbol shall always be set to the value 202405L.
_POSIX_BARRIERS
The implementation supports barriers. This symbol shall always be set to the value 202405L.
_POSIX_CHOWN_RESTRICTED
The use of chown() and fchown() is
restricted to a process with appropriate privileges, and to changing the group ID of a file only to the effective group ID of the
process or to one of its supplementary group IDs. This symbol shall be defined with a value other than -1.
_POSIX_CLOCK_SELECTION
The implementation supports clock selection. This symbol shall always be set to the value 202405L.
_POSIX_CPUTIME
[CPT]
The implementation supports the Process CPU-Time Clocks option. If this symbol is defined in , it shall be
defined to be -1, 0, or 202405L. The value of this symbol reported by sysconf()
shall either be -1 or 202405L.
_POSIX_DEVICE_CONTROL
[DC]
The implementation supports the device control option. If this symbol is defined in , it shall be defined to
be -1, 0, or 202405L. The value of this symbol reported by sysconf() shall either be
-1 or 202405L.
_POSIX_FSYNC
[FSC]
The implementation supports the File Synchronization option. If this symbol is defined in , it shall be
defined to be -1, 0, or 202405L. The value of this symbol reported by sysconf()
shall either be -1 or 202405L.
_POSIX_IPV6
[IP6]
The implementation supports the IPv6 option. If this symbol is defined in , it shall be defined to be -1, 0,
or 202405L. The value of this symbol reported by sysconf() shall either be -1 or
202405L.
_POSIX_JOB_CONTROL
The implementation supports job control. This symbol shall always be set to a value greater than zero.
_POSIX_MAPPED_FILES
The implementation supports memory mapped Files. This symbol shall always be set to the value 202405L.
_POSIX_MEMLOCK
[ML]
The implementation supports the Process Memory Locking option. If this symbol is defined in , it shall be
defined to be -1, 0, or 202405L. The value of this symbol reported by sysconf()
shall either be -1 or 202405L.
_POSIX_MEMLOCK_RANGE
[MLR]
The implementation supports the Range Memory Locking option. If this symbol is defined in , it shall be
defined to be -1, 0, or 202405L. The value of this symbol reported by sysconf()
shall either be -1 or 202405L.
_POSIX_MEMORY_PROTECTION
The implementation supports memory protection. This symbol shall always be set to the value 202405L.
_POSIX_MESSAGE_PASSING
[MSG]
The implementation supports the Message Passing option. If this symbol is defined in , it shall be defined
to be -1, 0, or 202405L. The value of this symbol reported by sysconf() shall either
be -1 or 202405L.
_POSIX_MONOTONIC_CLOCK
The implementation supports a monotonic clock. This symbol shall always be set to the value 202405L.
_POSIX_NO_TRUNC
Pathname components longer than {NAME_MAX} generate an error. This symbol shall be defined with a value other than -1.
_POSIX_PRIORITIZED_IO
[PIO]
The implementation supports the Prioritized Input and Output option. If this symbol is defined in , it shall
be defined to be -1, 0, or 202405L. The value of this symbol reported by sysconf()
shall either be -1 or 202405L.
_POSIX_PRIORITY_SCHEDULING
[PS]
The implementation supports the Process Scheduling option. If this symbol is defined in , it shall be
defined to be -1, 0, or 202405L. The value of this symbol reported by sysconf()
shall either be -1 or 202405L.
_POSIX_RAW_SOCKETS
[RS]
The implementation supports the Raw Sockets option. If this symbol is defined in , it shall be defined to be
-1, 0, or 202405L. The value of this symbol reported by sysconf() shall either be -1
or 202405L.
_POSIX_READER_WRITER_LOCKS
The implementation supports read-write locks. This symbol shall always be set to the value 202405L.
_POSIX_REALTIME_SIGNALS
The implementation supports realtime signals. This symbol shall always be set to the value 202405L.
_POSIX_REGEXP
The implementation supports the Regular Expression Handling option. This symbol shall always be set to a value greater than
zero.
_POSIX_SAVED_IDS
Each process has a saved set-user-ID and a saved set-group-ID. This symbol shall always be set to a value greater than zero.
_POSIX_SEMAPHORES
The implementation supports semaphores. This symbol shall always be set to the value 202405L.
_POSIX_SHARED_MEMORY_OBJECTS
[SHM]
The implementation supports the Shared Memory Objects option. If this symbol is defined in , it shall be
defined to be -1, 0, or 202405L. The value of this symbol reported by sysconf()
shall either be -1 or 202405L.
_POSIX_SHELL
The implementation supports the POSIX shell. This symbol shall always be set to a value greater than zero.
_POSIX_SPAWN
[SPN]
The implementation supports the Spawn option. If this symbol is defined in , it shall be defined to be -1,
0, or 202405L. The value of this symbol reported by sysconf() shall either be -1 or
202405L.
_POSIX_SPIN_LOCKS
The implementation supports spin locks. This symbol shall always be set to the value 202405L.
_POSIX_SPORADIC_SERVER
[SS]
The implementation supports the Process Sporadic Server option. If this symbol is defined in , it shall be
defined to be -1, 0, or 202405L. The value of this symbol reported by sysconf()
shall either be -1 or 202405L.
_POSIX_SYNCHRONIZED_IO
[SIO]
The implementation supports the Synchronized Input and Output option. If this symbol is defined in , it
shall be defined to be -1, 0, or 202405L. The value of this symbol reported by sysconf() shall either be -1 or 202405L.
_POSIX_THREAD_ATTR_STACKADDR
[TSA]
The implementation supports the Thread Stack Address Attribute option. If this symbol is defined in , it
shall be defined to be -1, 0, or 202405L. The value of this symbol reported by sysconf() shall either be -1 or 202405L.
_POSIX_THREAD_ATTR_STACKSIZE
[TSS]
The implementation supports the Thread Stack Size Attribute option. If this symbol is defined in , it shall
be defined to be -1, 0, or 202405L. The value of this symbol reported by sysconf()
shall either be -1 or 202405L.
_POSIX_THREAD_CPUTIME
[TCT]
The implementation supports the Thread CPU-Time Clocks option. If this symbol is defined in , it shall be
defined to be -1, 0, or 202405L. The value of this symbol reported by sysconf()
shall either be -1 or 202405L.
_POSIX_THREAD_PRIO_INHERIT
[TPI]
The implementation supports the Non-Robust Mutex Priority Inheritance option. If this symbol is defined in ,
it shall be defined to be -1, 0, or 202405L. The value of this symbol reported by sysconf() shall either be -1 or 202405L.
_POSIX_THREAD_PRIO_PROTECT
[TPP]
The implementation supports the Non-Robust Mutex Priority Protection option. If this symbol is defined in ,
it shall be defined to be -1, 0, or 202405L. The value of this symbol reported by sysconf() shall either be -1 or 202405L.
_POSIX_THREAD_PRIORITY_SCHEDULING
[TPS]
The implementation supports the Thread Execution Scheduling option. If this symbol is defined in , it shall
be defined to be -1, 0, or 202405L. The value of this symbol reported by sysconf()
shall either be -1 or 202405L.
_POSIX_THREAD_PROCESS_SHARED
[TSH]
The implementation supports the Thread Process-Shared Synchronization option. If this symbol is defined in ,
it shall be defined to be -1, 0, or 202405L. The value of this symbol reported by sysconf() shall either be -1 or 202405L.
_POSIX_THREAD_ROBUST_PRIO_INHERIT
[RPI]
The implementation supports the Robust Mutex Priority Inheritance option. If this symbol is defined in , it
shall be defined to be -1, 0, or 202405L. The value of this symbol reported by sysconf() shall either be -1 or 202405L.
_POSIX_THREAD_ROBUST_PRIO_PROTECT
[RPP]
The implementation supports the Robust Mutex Priority Protection option. If this symbol is defined in , it
shall be defined to be -1, 0, or 202405L. The value of this symbol reported by sysconf() shall either be -1 or 202405L.
_POSIX_THREAD_SAFE_FUNCTIONS
The implementation supports thread-safe functions. This symbol shall always be set to the value 202405L.
_POSIX_THREAD_SPORADIC_SERVER
[TSP]
The implementation supports the Thread Sporadic Server option. If this symbol is defined in , it shall be
defined to be -1, 0, or 202405L. The value of this symbol reported by sysconf()
shall either be -1 or 202405L.
_POSIX_THREADS
The implementation supports threads. This symbol shall always be set to the value 202405L.
_POSIX_TIMEOUTS
The implementation supports timeouts. This symbol shall always be set to the value 202405L.
_POSIX_TIMERS
The implementation supports timers. This symbol shall always be set to the value 202405L.
_POSIX_TYPED_MEMORY_OBJECTS
[TYM]
The implementation supports the Typed Memory Objects option. If this symbol is defined in , it shall be
defined to be -1, 0, or 202405L. The value of this symbol reported by sysconf()
shall either be -1 or 202405L.
_POSIX_V7_ILP32_OFF32
[OB]
The implementation provides a C-language compilation environment with 32-bit int, long, off_t, and all pointer
types.
_POSIX_V7_ILP32_OFFBIG
[OB]
The implementation provides a C-language compilation environment with 32-bit int, long, and all pointer types, and an
off_t type using at least 64 bits.
_POSIX_V7_LP64_OFF64
[OB]
The implementation provides a C-language compilation environment with a 32-bit int type and 64-bit long,
off_t, and all pointer types.
_POSIX_V7_LPBIG_OFFBIG
[OB]
The implementation provides a C-language compilation environment with an int type using at least 32 bits and long,
off_t, and all pointer types using at least 64 bits.
_POSIX_V8_ILP32_OFF32
The implementation provides a C-language compilation environment with 32-bit int, long, off_t, and all pointer
types.
_POSIX_V8_ILP32_OFFBIG
The implementation provides a C-language compilation environment with 32-bit int, long, and all pointer types, and an
off_t type using at least 64 bits.
_POSIX_V8_LP64_OFF64
The implementation provides a C-language compilation environment with a 32-bit int type and 64-bit long,
off_t, and all pointer types.
_POSIX_V8_LPBIG_OFFBIG
The implementation provides a C-language compilation environment with an int type using at least 32 bits and long,
off_t, and all pointer types using at least 64 bits.
_POSIX2_C_BIND
The implementation supports the C-Language Binding option. This symbol shall always have the value 202405L.
_POSIX2_C_DEV
[CD]
The implementation supports the C-Language Development Utilities option. If this symbol is defined in , it
shall be defined to be -1, 0, or 202405L. The value of this symbol reported by sysconf() shall either be -1 or 202405L.
_POSIX2_CHAR_TERM
The implementation supports the Terminal Characteristics option. The value of this symbol reported by sysconf() shall either be -1 or a value greater than zero.
_POSIX2_FORT_RUN
[FR]
The implementation supports the FORTRAN Runtime Utilities option. If this symbol is defined in , it shall be
defined to be -1, 0, or 202405L. The value of this symbol reported by sysconf()
shall either be -1 or 202405L.
_POSIX2_LOCALEDEF
The implementation supports the creation of locales by the localedef utility. If
this symbol is defined in , it shall be defined to be -1, 0, or 202405L. The value of this symbol reported
by sysconf() shall either be -1 or 202405L.
_POSIX2_SW_DEV
[SD]
The implementation supports the Software Development Utilities option. If this symbol is defined in , it
shall be defined to be -1, 0, or 202405L. The value of this symbol reported by sysconf() shall either be -1 or 202405L.
_POSIX2_UPE
[UP]
The implementation supports the User Portability Utilities option. If this symbol is defined in , it shall
be defined to be -1, 0, or 202405L. The value of this symbol reported by sysconf()
shall either be -1 or 202405L.
_XOPEN_CRYPT
[XSI]
The implementation supports the X/Open Encryption Option Group.
_XOPEN_ENH_I18N
The implementation supports the Issue 4, Version 2 Enhanced Internationalization Option Group. This symbol shall always be set to a
value other than -1.
_XOPEN_REALTIME
The implementation supports the X/Open Realtime Option Group.
_XOPEN_REALTIME_THREADS
The implementation supports the X/Open Realtime Threads Option Group.
_XOPEN_SHM
The implementation supports the Issue 4, Version 2 Shared Memory Option Group. This symbol shall always be set to a value other
than -1.
_XOPEN_UNIX
The implementation supports the XSI option.
_XOPEN_UUCP
[UU]
The implementation supports the UUCP Utilities option. If this symbol is defined in , it shall be defined to
be -1, 0, or 202405L. The value of this symbol reported by sysconf() shall be either
-1 or 202405L.
Execution-Time Symbolic Constants
If any of the following symbolic constants are not defined in the  header, the value shall vary depending
on the file to which it is applied. If defined, they shall have values suitable for use in #if preprocessing directives.
If any of the following symbolic constants are defined to have value -1 in the  header, the
implementation shall not provide the option on any file; if any are defined to have a value other than -1 in the
header, the implementation shall provide the option on all applicable files.
All of the following values, whether defined as symbolic constants in  or not, may be queried with
respect to a specific file using the pathconf() or fpathconf() functions:
_POSIX_ASYNC_IO
Asynchronous input or output operations may be performed for the associated file.
_POSIX_FALLOC
The posix_fallocate() function is supported by the associated file.
_POSIX_PRIO_IO
Prioritized input or output operations may be performed for the associated file.
_POSIX_SYNC_IO
Synchronized input or output operations may be performed for the associated file.
If the following symbolic constants are defined in the  header, they apply to files and all paths in all
file systems on the implementation:
_POSIX_TIMESTAMP_RESOLUTION
The resolution in nanoseconds for all file timestamps.
_POSIX2_SYMLINKS
Symbolic links can be created.
Constants for Functions
The  header shall define NULL as described in .
The  header shall define the symbolic constants O_CLOEXEC and O_CLOFORK as described in .
The  header shall define the following symbolic constants for use with the access() function. The values shall be suitable for use in #if preprocessing
directives.
F_OK
Test for existence of file.
R_OK
Test for read permission.
W_OK
Test for write permission.
X_OK
Test for execute (search) permission.
The constants F_OK, R_OK, W_OK, and X_OK and the expressions R_OK|W_OK, R_OK|X_OK, and
R_OK|W_OK|X_OK shall all have distinct values.
The  header shall define the following symbolic constants for the confstr() function:
_CS_PATH
This is the value for the PATH environment variable that finds all of the standard utilities that are provided in a manner
accessible via the exec family of functions.
_CS_POSIX_V8_ILP32_OFF32_CFLAGS
If sysconf(_SC_V8_ILP32_OFF32) returns -1, the meaning of this value is unspecified. Otherwise, this value is the set of
initial options to be given to the c17 utility to build an application using a
programming model with 32-bit int, long, off_t, and all pointer types.
_CS_POSIX_V8_ILP32_OFF32_LDFLAGS
If sysconf(_SC_V8_ILP32_OFF32) returns -1, the meaning of this value is unspecified. Otherwise, this value is the set of
final options to be given to the c17 utility to build an application using a programming
model with 32-bit int, long, off_t, and all pointer types.
_CS_POSIX_V8_ILP32_OFF32_LIBS
If sysconf(_SC_V8_ILP32_OFF32) returns -1, the meaning of this value is unspecified. Otherwise, this value is the set of
libraries to be given to the c17 utility to build an application using a programming
model with 32-bit int, long, off_t, and all pointer types.
_CS_POSIX_V8_ILP32_OFFBIG_CFLAGS
If sysconf(_SC_V8_ILP32_OFFBIG) returns -1, the meaning of this value is unspecified. Otherwise, this value is the set of
initial options to be given to the c17 utility to build an application using a
programming model with 32-bit int, long, and all pointer types, and an off_t type using at least 64 bits.
_CS_POSIX_V8_ILP32_OFFBIG_LDFLAGS
If sysconf(_SC_V8_ILP32_OFFBIG) returns -1, the meaning of this value is unspecified. Otherwise, this value is the set of
final options to be given to the c17 utility to build an application using a programming
model with 32-bit int, long, and all pointer types, and an off_t type using at least 64 bits.
_CS_POSIX_V8_ILP32_OFFBIG_LIBS
If sysconf(_SC_V8_ILP32_OFFBIG) returns -1, the meaning of this value is unspecified. Otherwise, this value is the set of
libraries to be given to the c17 utility to build an application using a programming
model with 32-bit int, long, and all pointer types, and an off_t type using at least 64 bits.
_CS_POSIX_V8_LP64_OFF64_CFLAGS
If sysconf(_SC_V8_LP64_OFF64) returns -1, the meaning of this value is unspecified. Otherwise, this value is the set of
initial options to be given to the c17 utility to build an application using a
programming model with a 32-bit int type and 64-bit long, off_t, and all pointer types.
_CS_POSIX_V8_LP64_OFF64_LDFLAGS
If sysconf(_SC_V8_LP64_OFF64) returns -1, the meaning of this value is unspecified. Otherwise, this value is the set of
final options to be given to the c17 utility to build an application using a programming
model with a 32-bit int type and 64-bit long, off_t, and all pointer types.
_CS_POSIX_V8_LP64_OFF64_LIBS
If sysconf(_SC_V8_LP64_OFF64) returns -1, the meaning of this value is unspecified. Otherwise, this value is the set of
libraries to be given to the c17 utility to build an application using a programming
model with a 32-bit int type and 64-bit long, off_t, and all pointer types.
_CS_POSIX_V8_LPBIG_OFFBIG_CFLAGS
If sysconf(_SC_V8_LPBIG_OFFBIG) returns -1, the meaning of this value is unspecified. Otherwise, this value is the set of
initial options to be given to the c17 utility to build an application using a
programming model with an int type using at least 32 bits and long, off_t, and all pointer types using at
least 64 bits.
_CS_POSIX_V8_LPBIG_OFFBIG_LDFLAGS
If sysconf(_SC_V8_LPBIG_OFFBIG) returns -1, the meaning of this value is unspecified. Otherwise, this value is the set of
final options to be given to the c17 utility to build an application using a programming
model with an int type using at least 32 bits and long, off_t, and all pointer types using at least 64
bits.
_CS_POSIX_V8_LPBIG_OFFBIG_LIBS
If sysconf(_SC_V8_LPBIG_OFFBIG) returns -1, the meaning of this value is unspecified. Otherwise, this value is the set of
libraries to be given to the c17 utility to build an application using a programming
model with an int type using at least 32 bits and long, off_t, and all pointer types using at least 64
bits.
_CS_POSIX_V8_THREADS_CFLAGS
This value is the set of initial options to be given to the c17 utility to build a
multi-threaded application. These flags are in addition to those associated with any of the other _CS_POSIX_V8_*_CFLAGS values used
to specify particular type size programming environments.
_CS_POSIX_V8_THREADS_LDFLAGS
This value is the set of final options to be given to the c17 utility to build a
multi-threaded application. These flags are in addition to those associated with any of the other _CS_POSIX_V8_*_LDFLAGS values
used to specify particular type size programming environments.
_CS_POSIX_V8_WIDTH_RESTRICTED_ENVS
This value is a -separated list of names of programming environments supported by the implementation in which the
widths of the blksize_t, cc_t, mode_t, nfds_t, pid_t, ptrdiff_t, size_t,
speed_t, ssize_t, suseconds_t, tcflag_t, wchar_t, and wint_t types are no greater than
the width of type long. The format of each name shall be suitable for use with the getconf -v option.
_CS_V8_ENV
This is the value that provides the environment variable information (other than that provided by _CS_PATH) that is required by the
implementation to create a conforming environment, as described in the implementation's conformance documentation.
[OB]  The
following symbolic constants are reserved for compatibility with Issue 7:
_CS_POSIX_V7_ILP32_OFF32_CFLAGS
_CS_POSIX_V7_ILP32_OFF32_LDFLAGS
_CS_POSIX_V7_ILP32_OFF32_LIBS
_CS_POSIX_V7_ILP32_OFFBIG_CFLAGS
_CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS
_CS_POSIX_V7_ILP32_OFFBIG_LIBS
_CS_POSIX_V7_LP64_OFF64_CFLAGS
_CS_POSIX_V7_LP64_OFF64_LDFLAGS
_CS_POSIX_V7_LP64_OFF64_LIBS
_CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS
_CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS
_CS_POSIX_V7_LPBIG_OFFBIG_LIBS
_CS_POSIX_V7_THREADS_CFLAGS
_CS_POSIX_V7_THREADS_LDFLAGS
_CS_POSIX_V7_WIDTH_RESTRICTED_ENVS
_CS_V7_ENV
The implementation may define additional symbolic constants beginning with _CS_ for use by confstr().
The  header shall define SEEK_CUR, SEEK_END, and SEEK_SET as described in .
Additionally, it shall define the following macros which shall expand to integer constant expressions with values that are
distinct from each other and from SEEK_CUR, SEEK_END, and SEEK_SET:
SEEK_HOLE
Seek forwards from offset relative to start-of-file for a position within a hole.
SEEK_DATA
Seek forwards from offset relative to start-of-file for a position not within a hole
[XSI]
The  header shall define the following symbolic constants as possible values for the function
argument to the lockf() function:
F_LOCK
Lock a section for exclusive use.
F_TEST
Test section for locks by other processes.
F_TLOCK
Test and lock a section for exclusive use.
F_ULOCK
Unlock locked sections.
The  header shall define the following symbolic constants for pathconf():
_PC_2_SYMLINKS
_PC_ALLOC_SIZE_MIN
_PC_ASYNC_IO
_PC_CHOWN_RESTRICTED
_PC_FALLOC
_PC_FILESIZEBITS
_PC_LINK_MAX
_PC_MAX_CANON
_PC_MAX_INPUT
_PC_NAME_MAX
_PC_NO_TRUNC
_PC_PATH_MAX
_PC_PIPE_BUF
_PC_PRIO_IO
_PC_REC_INCR_XFER_SIZE
_PC_REC_MAX_XFER_SIZE
_PC_REC_MIN_XFER_SIZE
_PC_REC_XFER_ALIGN
_PC_SYMLINK_MAX
_PC_SYNC_IO
_PC_TEXTDOMAIN_MAX
_PC_TIMESTAMP_RESOLUTION
_PC_VDISABLE
The implementation may define additional symbolic constants beginning with _PC_ for use by pathconf().
The  header shall define the following symbolic constants for sysconf():
_SC_2_C_BIND
_SC_2_C_DEV
_SC_2_CHAR_TERM
_SC_2_FORT_RUN
_SC_2_LOCALEDEF
_SC_2_SW_DEV
_SC_2_UPE
_SC_2_VERSION
_SC_ADVISORY_INFO
_SC_AIO_LISTIO_MAX
_SC_AIO_MAX
_SC_AIO_PRIO_DELTA_MAX
_SC_ARG_MAX
_SC_ASYNCHRONOUS_IO
_SC_ATEXIT_MAX
_SC_BARRIERS
_SC_BC_BASE_MAX
_SC_BC_DIM_MAX
_SC_BC_SCALE_MAX
_SC_BC_STRING_MAX
_SC_CHILD_MAX
_SC_CLK_TCK
_SC_CLOCK_SELECTION
_SC_COLL_WEIGHTS_MAX
_SC_CPUTIME
_SC_DELAYTIMER_MAX
_SC_DEVICE_CONTROL
_SC_EXPR_NEST_MAX
_SC_FSYNC
_SC_GETGR_R_SIZE_MAX
_SC_GETPW_R_SIZE_MAX
_SC_HOST_NAME_MAX
_SC_IOV_MAX
_SC_IPV6
_SC_JOB_CONTROL
_SC_LINE_MAX
_SC_LOGIN_NAME_MAX
_SC_MAPPED_FILES
_SC_MEMLOCK
_SC_MEMLOCK_RANGE
_SC_MEMORY_PROTECTION
_SC_MESSAGE_PASSING
_SC_MONOTONIC_CLOCK
_SC_MQ_OPEN_MAX
_SC_MQ_PRIO_MAX
_SC_NGROUPS_MAX
_SC_NPROCESSORS_CONF
_SC_NPROCESSORS_ONLN
_SC_NSIG
_SC_OPEN_MAX
_SC_PAGE_SIZE
_SC_PAGESIZE
_SC_PRIORITIZED_IO
_SC_PRIORITY_SCHEDULING
_SC_RAW_SOCKETS
_SC_RE_DUP_MAX
_SC_READER_WRITER_LOCKS
_SC_REALTIME_SIGNALS
_SC_REGEXP
_SC_RTSIG_MAX
_SC_SAVED_IDS
_SC_SEM_NSEMS_MAX
_SC_SEM_VALUE_MAX
_SC_SEMAPHORES
_SC_SHARED_MEMORY_OBJECTS
_SC_SHELL
_SC_SIGQUEUE_MAX
_SC_SPAWN
_SC_SPIN_LOCKS
_SC_SPORADIC_SERVER
_SC_SS_REPL_MAX
_SC_STREAM_MAX
_SC_SYMLOOP_MAX
_SC_SYNCHRONIZED_IO
_SC_THREAD_ATTR_STACKADDR
_SC_THREAD_ATTR_STACKSIZE
_SC_THREAD_CPUTIME
_SC_THREAD_DESTRUCTOR_ITERATIONS
_SC_THREAD_KEYS_MAX
_SC_THREAD_PRIO_INHERIT
_SC_THREAD_PRIO_PROTECT
_SC_THREAD_PRIORITY_SCHEDULING
_SC_THREAD_PROCESS_SHARED
_SC_THREAD_ROBUST_PRIO_INHERIT
_SC_THREAD_ROBUST_PRIO_PROTECT
_SC_THREAD_SAFE_FUNCTIONS
_SC_THREAD_SPORADIC_SERVER
_SC_THREAD_STACK_MIN
_SC_THREAD_THREADS_MAX
_SC_THREADS
_SC_TIMEOUTS
_SC_TIMER_MAX
_SC_TIMERS
_SC_TTY_NAME_MAX
_SC_TYPED_MEMORY_OBJECTS
_SC_TZNAME_MAX
_SC_V8_ILP32_OFF32
_SC_V8_ILP32_OFFBIG
_SC_V8_LP64_OFF64
_SC_V8_LPBIG_OFFBIG
[OB]
_SC_V7_ILP32_OFF32
_SC_V7_ILP32_OFFBIG
_SC_V7_LP64_OFF64
_SC_V7_LPBIG_OFFBIG
_SC_VERSION
_SC_XOPEN_CRYPT
_SC_XOPEN_ENH_I18N
_SC_XOPEN_REALTIME
_SC_XOPEN_REALTIME_THREADS
_SC_XOPEN_SHM
_SC_XOPEN_UNIX
_SC_XOPEN_UUCP
_SC_XOPEN_VERSION
The two constants _SC_PAGESIZE and _SC_PAGE_SIZE may be defined to have the same value.
The implementation may define additional symbolic constants beginning with _SC_ for use by sysconf().
The  header shall define the following symbolic constants for file streams:
STDERR_FILENO
File number of stderr; 2.
STDIN_FILENO
File number of stdin; 0.
STDOUT_FILENO
File number of stdout; 1.
The  header shall define the following symbolic constant for terminal special character handling:
_POSIX_VDISABLE
This symbol shall be defined to be the value of a character that shall disable terminal special character handling as described
in 11.2.6 Special Control Characters. This symbol shall always be set
to a value other than -1.
The  header shall define the following symbolic constant as a value for the flag used by posix_close():
POSIX_CLOSE_RESTART
Allows restarts if a signal interrupts a close operation. This constant shall not be 0 unless posix_close() never returns -1 with errno set to [EINTR].
Type Definitions
The  header shall define the size_t, ssize_t, uid_t, gid_t, off_t, and
pid_t types as described in .
The  header shall define the intptr_t type as described in .
Declarations
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
int          access(const char *, int);
unsigned     alarm(unsigned);
int          chdir(const char *);
int          chown(const char *, uid_t, gid_t);
int          close(int);
size_t       confstr(int, char *, size_t);
[XSI]
char        *crypt(const char *, const char *);
int          dup(int);
int          dup2(int, int);
int          dup3(int, int, int);
_Noreturn void
_exit(int);
[OB XSI]
void         encrypt(char [64], int);
int          execl(const char *, const char *, ...);
int          execle(const char *, const char *, ...);
int          execlp(const char *, const char *, ...);
int          execv(const char *, char *const []);
int          execve(const char *, char *const [], char *const []);
int          execvp(const char *, char *const []);
int          faccessat(int, const char *, int, int);
int          fchdir(int);
int          fchown(int, uid_t, gid_t);
int          fchownat(int, const char *, uid_t, gid_t, int);
[SIO]
int          fdatasync(int);
int          fexecve(int, char *const [], char *const []);
pid_t        _Fork(void);
pid_t        fork(void);
long         fpathconf(int, int);
[FSC]
int          fsync(int);
int          ftruncate(int, off_t);
char        *getcwd(char *, size_t);
gid_t        getegid(void);
int          getentropy(void *, size_t);
uid_t        geteuid(void);
gid_t        getgid(void);
int          getgroups(int, gid_t []);
[XSI]
long         gethostid(void);
int          gethostname(char *, size_t);
char        *getlogin(void);
int          getlogin_r(char *, size_t);
int          getopt(int, char * const [], const char *);
pid_t        getpgid(pid_t);
pid_t        getpgrp(void);
pid_t        getpid(void);
pid_t        getppid(void);
[XSI]
int          getresgid(gid_t *restrict, gid_t *restrict,
gid_t *restrict);
int          getresuid(uid_t *restrict, uid_t *restrict,
uid_t *restrict);
pid_t        getsid(pid_t);
uid_t        getuid(void);
int          isatty(int);
int          lchown(const char *, uid_t, gid_t);
int          link(const char *, const char *);
int          linkat(int, const char *, int, const char *, int);
[XSI]
int          lockf(int, int, off_t);
off_t        lseek(int, off_t, int);
[XSI]
int          nice(int);
long         pathconf(const char *, int);
int          pause(void);
int          pipe(int [2]);
int          pipe2(int [2], int);
int          posix_close(int, int);
ssize_t      pread(int, void *, size_t, off_t);
ssize_t      pwrite(int, const void *, size_t, off_t);
ssize_t      read(int, void *, size_t);
ssize_t      readlink(const char *restrict, char *restrict, size_t);
ssize_t      readlinkat(int, const char *restrict, char *restrict,
size_t);
int          rmdir(const char *);
int          setegid(gid_t);
int          seteuid(uid_t);
int          setgid(gid_t);
int          setpgid(pid_t, pid_t);
[XSI]
int          setregid(gid_t, gid_t);
int          setresgid(gid_t, gid_t, gid_t);
int          setresuid(uid_t, uid_t, uid_t);
int          setreuid(uid_t, uid_t);
pid_t        setsid(void);
int          setuid(uid_t);
unsigned     sleep(unsigned);
[XSI]
void         swab(const void *restrict, void *restrict, ssize_t);
int          symlink(const char *, const char *);
int          symlinkat(const char *, int, const char *);
[XSI]
void         sync(void);
long         sysconf(int);
pid_t        tcgetpgrp(int);
int          tcsetpgrp(int, pid_t);
int          truncate(const char *, off_t);
char        *ttyname(int);
int          ttyname_r(int, char *, size_t);
int          unlink(const char *);
int          unlinkat(int, const char *, int);
ssize_t      write(int, const void *, size_t);
The  header shall declare the following external variables:
extern char  *optarg;
extern int    opterr, optind, optopt;
Inclusion of the  header may make visible all symbols from the headers , , , and .
The following sections are informative.
APPLICATION USAGE
POSIX.1-2024 only describes the behavior of systems that claim conformance to it. However, application developers who want to
write applications that adapt to other versions of this standard (or to systems that do not conform to any POSIX standard) may find
it useful to code them so as to conditionally compile different code depending on the value of _POSIX_VERSION, for example:
#if _POSIX_VERSION >= 200112L
/* Use the newer function that copes with large files. */
off_t pos=ftello(fp);
#else
/* Either this is an old version of POSIX, or _POSIX_VERSION is
not even defined, so use the traditional function. */
long pos=ftell(fp);
#endif
Earlier versions of POSIX.1-2024 and of the Single UNIX Specification can be identified by the following macros:
POSIX.1-1988 standard
_POSIX_VERSION==198808L
POSIX.1-1990 standard
_POSIX_VERSION==199009L
POSIX.1-1996 standard
_POSIX_VERSION==199506L
Single UNIX Specification, Version 1
_XOPEN_UNIX and _XOPEN_VERSION==4
Single UNIX Specification, Version 2
_XOPEN_UNIX and _XOPEN_VERSION==500
POSIX.1-2001 and Single UNIX Specification, Version 3
_POSIX_VERSION==200112L, plus (if the XSI option is supported) _XOPEN_UNIX and _XOPEN_VERSION==600
POSIX.1-2008, POSIX.1-2017, and Single UNIX Specification, Version 4
_POSIX_VERSION==200809L, plus (if the XSI option is supported) _XOPEN_UNIX and _XOPEN_VERSION==700
Note that _POSIX_VERSION did not change in POSIX.1-2017 as it was technically identical to POSIX.1-2008 with its two technical
corrigenda applied.
POSIX.1-2024 does not make any attempt to define application binary interaction with the underlying operating system. However,
application developers may find it useful to query _SC_VERSION at runtime via sysconf() to determine whether the current version of the operating system supports the
necessary functionality as in the following program fragment:
if (sysconf(_SC_VERSION) , , ,
, , , ,
XSH access(), alarm(), chown(), close(), confstr(), crypt(), ctermid(), dup(), _Exit(), encrypt(), exec, fchdir(), fchown(), fdatasync(), fork(), fpathconf(), fsync(), ftruncate(), getcwd(), getentropy(), getegid(), geteuid(), getgid(), getgroups(), gethostid(), gethostname(),
getlogin(), getopt(), getpgid(), getpgrp(), getpid(), getppid(), getresgid(), getresuid(), getsid(), getuid(), isatty(), lchown(), link(), lockf(), lseek(), nice(), pause(), pipe(), read(), readlink(), rmdir(), setegid(), seteuid(), setgid(), setpgid(), setregid(), setresgid(), setresuid(), setreuid(), setsid(), setuid(), sleep(), swab(), symlink(), sync(), sysconf(), tcgetpgrp(), tcsetpgrp(), truncate(), ttyname(), unlink(), write()
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Realtime Extension and the POSIX Threads Extension.
The symbolic constants _XOPEN_REALTIME and _XOPEN_REALTIME_THREADS are added. _POSIX2_C_BIND, _XOPEN_ENH_I18N, and _XOPEN_SHM
must now be set to a value other than -1 by a conforming implementation.
Large File System extensions are added.
The type of the argument to sbrk() is changed from int to intptr_t.
_XBS_ constants are added to the list of constants for Options and Option Groups, to the list of constants for the confstr() function, and to the list of constants to the sysconf() function. These are all marked EX.
Issue 6
_POSIX2_C_VERSION is removed.
The Open Group Corrigendum U026/4 is applied, adding the prototype for fdatasync().
The Open Group Corrigendum U026/1 is applied, adding the symbols _SC_XOPEN_LEGACY, _SC_XOPEN_REALTIME, and
_SC_XOPEN_REALTIME_THREADS.
The symbols _XOPEN_STREAMS and _SC_XOPEN_STREAMS are added to support the XSI STREAMS Option Group.
Text in the DESCRIPTION relating to conformance requirements is moved elsewhere in IEEE Std 1003.1-2001.
The LEGACY symbol _SC_PASS_MAX is removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The _CS_POSIX_* and _CS_XBS5_* constants are added for the confstr()
function.
The _SC_XBS5_* constants are added for the sysconf() function.
The symbolic constants F_ULOCK, F_LOCK, F_TLOCK, and F_TEST are added.
The uid_t, gid_t, off_t, pid_t, and useconds_t types are mandated.
The gethostname() prototype is added for sockets.
A new section is added for System-Wide Options.
Function prototypes for setegid() and seteuid() are added.
Option symbolic constants are added for _POSIX_ADVISORY_INFO, _POSIX_CPUTIME, _POSIX_SPAWN, _POSIX_SPORADIC_SERVER,
_POSIX_THREAD_CPUTIME, _POSIX_THREAD_SPORADIC_SERVER, and _POSIX_TIMEOUTS, and pathconf() variables are added for _PC_ALLOC_SIZE_MIN, _PC_REC_INCR_XFER_SIZE,
_PC_REC_MAX_XFER_SIZE, _PC_REC_MIN_XFER_SIZE, and _PC_REC_XFER_ALIGN for alignment with IEEE Std 1003.1d-1999.
The following are added for alignment with IEEE Std 1003.1j-2000:
Option symbolic constants _POSIX_BARRIERS, _POSIX_CLOCK_SELECTION, _POSIX_MONOTONIC_CLOCK, _POSIX_READER_WRITER_LOCKS,
_POSIX_SPIN_LOCKS, and _POSIX_TYPED_MEMORY_OBJECTS
sysconf() variables _SC_BARRIERS, _SC_CLOCK_SELECTION, _SC_MONOTONIC_CLOCK,
_SC_READER_WRITER_LOCKS, _SC_SPIN_LOCKS, and _SC_TYPED_MEMORY_OBJECTS
The _SC_XBS5 macros associated with the ISO/IEC 9899:1990 standard are marked LEGACY, and new equivalent _SC_V6 macros
associated with the ISO/IEC 9899:1999 standard are introduced.
The getwd() function is marked LEGACY.
The restrict keyword is added to the prototypes for readlink() and
swab().
Constants for options are now harmonized, so when supported they take the year of approval of IEEE Std 1003.1-2001 as
the value.
The following are added for alignment with IEEE Std 1003.1q-2000:
Optional symbolic constants _POSIX_TRACE, _POSIX_TRACE_EVENT_FILTER, _POSIX_TRACE_LOG, and _POSIX_TRACE_INHERIT
The sysconf() symbolic constants _SC_TRACE, _SC_TRACE_EVENT_FILTER,
_SC_TRACE_LOG, and _SC_TRACE_INHERIT
The brk() and sbrk() LEGACY functions are removed.
The Open Group Base Resolution bwg2001-006 is applied, which reworks the XSI versioning information.
The Open Group Base Resolution bwg2001-008 is applied, changing the namelen parameter for gethostname() from socklen_t to size_t.
IEEE Std 1003.1-2001/Cor 1-2002, item XBD/TC1/D6/2 is applied, changing "Thread Stack Address Size" to "Thread
Stack Size Attribute".
IEEE Std 1003.1-2001/Cor 1-2002, item XBD/TC1/D6/20 is applied, adding the _POSIX_IPV6, _SC_V6, and
_SC_RAW_SOCKETS symbols.
IEEE Std 1003.1-2001/Cor 1-2002, item XBD/TC1/D6/21 is applied, correcting the description in "Constants for
Functions" for the _CS_POSIX_V6_LP64_OFF64_CFLAGS, _CS_POSIX_V6_LP64_OFF64_LDFLAGS, and _CS_POSIX_V6_LP64_OFF64_LIBS symbols.
IEEE Std 1003.1-2001/Cor 1-2002, item XBD/TC1/D6/22 is applied, removing the shading for the _PC* and _SC*
constants, since these are mandatory on all implementations.
IEEE Std 1003.1-2001/Cor 1-2002, item XBD/TC1/D6/23 is applied, adding the _PC_SYMLINK_MAX and _SC_SYMLOOP_MAX
constants.
IEEE Std 1003.1-2001/Cor 1-2002, item XBD/TC1/D6/24 is applied, correcting the shading and margin code for the
fsync() function.
IEEE Std 1003.1-2001/Cor 1-2002, item XBD/TC1/D6/25 is applied, adding the following text to the APPLICATION
USAGE section: "New applications should not use _XOPEN_SHM or _XOPEN_ENH_I18N.".
IEEE Std 1003.1-2001/Cor 2-2004, item XBD/TC2/D6/29 is applied, clarifying the requirements for when constants
for Options and Option Groups can be defined or undefined.
IEEE Std 1003.1-2001/Cor 2-2004, item XBD/TC2/D6/30 is applied, changing the _V6_ILP32_OFF32, _V6_ILP32_OFFBIG,
_V6_LP64_OFF64, and _V6_LPBIG_OFFBIG symbols to _POSIX_V6_ILP32_OFF32, _POSIX_V6_ILP32_OFFBIG, _POSIX_V6_LP64_OFF64, and
_POSIX_V6_LPBIG_OFFBIG, respectively. This is for consistency with the sysconf() and
c99 reference pages.
IEEE Std 1003.1-2001/Cor 2-2004, item XBD/TC2/D6/31 is applied, adding that the format of names of programming
environments can be obtained using the getconf -v option.
IEEE Std 1003.1-2001/Cor 2-2004, item XBD/TC2/D6/32 is applied, deleting the _SC_FILE_LOCKING, _SC_2_C_VERSION,
and _SC_XOPEN_XCU_VERSION constants.
IEEE Std 1003.1-2001/Cor 2-2004, item XBD/TC2/D6/33 is applied, adding _SC_SS_REPL_MAX, _SC_TRACE_EVENT_NAME_MAX,
_SC_TRACE_NAME_MAX, _SC_TRACE_SYS_MAX, and _SC_TRACE_USER_EVENT_MAX to the list of symbolic constants for sysconf().
IEEE Std 1003.1-2001/Cor 2-2004, item XBD/TC2/D6/34 is applied, updating the prototype for the symlink() function to match that in the System Interfaces volume of
IEEE Std 1003.1-2001.
IEEE Std 1003.1-2001/Cor 2-2004, item XBD/TC2/D6/35 is applied, adding _PC_2_SYMLINKS to the symbolic constants
list for pathconf(). This corresponds to the definition of POSIX2_SYMLINKS in the
Shell and Utilities volume of IEEE Std 1003.1-2001.
Issue 7
Austin Group Interpretations 1003.1-2001 #026 and #047 are applied.
Austin Group Interpretation 1003.1-2001 #166 is applied to permit an additional compiler flag to enable threads.
Austin Group Interpretation 1003.1-2001 #178 is applied, clarifying the values allowed for _POSIX2_CHAR_TERM.
SD5-XBD-ERN-41 is applied, adding the _POSIX2_SYMLINKS constant.
SD5-XBD-ERN-76 and SD5-XBD-ERN-77 are applied.
Symbols to support the UUCP Utilities option are added.
The variables for the supported programming environments are updated to be V7.
The LEGACY and obsolescent symbols are removed.
The faccessat(), fchownat(),
fexecve(), linkat(), readlinkat(), symlinkat(), and unlinkat() functions are added from The Open Group Technical Standard, 2006, Extended API
Set Part 2.
The _POSIX_TRACE* constants from the Trace option are marked obsolescent.
The _POSIX2_PBS* constants from the Batch Environment Services and Utilities option are marked obsolescent.
Functionality relating to the Asynchronous Input and Output, Barriers, Clock Selection, Memory Mapped Files, Memory Protection,
Realtime Signals Extension, Semaphores, Spin Locks, Threads, Timeouts, and Timers options is moved to the Base.
Functionality relating to the Thread Priority Protection and Thread Priority Inheritance options is changed to be Non-Robust
Mutex or Robust Mutex Priority Protection and Non-Robust Mutex or Robust Mutex Priority Inheritance, respectively.
This reference page is clarified with respect to macros and symbolic constants.
Changes are made related to support for finegrained timestamps and the _POSIX_TIMESTAMP_RESOLUTION constant is added.
The _SC_THREAD_ROBUST_PRIO_INHERIT and _SC_THREAD_ROBUST_PRIO_PROTECT symbolic constants are added.
POSIX.1-2008, Technical Corrigendum 1, XBD/TC1-2008/0078 [311], XBD/TC1-2008/0079 [209], and XBD/TC1-2008/0080 [360] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0085 [783], XBD/TC2-2008/0086 [911], and XBD/TC2-2008/0087 [566] are
applied.
Issue 8
Austin Group Defect 62 is applied, adding the _Fork() function.
Austin Group Defect 339 is applied, adding _SC_NPROCESSORS_CONF and _SC_NPROCESSORS_ONLN.
Austin Group Defects 411 and 598 are applied, adding dup3() and pipe2().
Austin Group Defects 415 and 1357 are applied, adding SEEK_HOLE and SEEK_DATA.
Austin Group Defect 529 is applied, adding the POSIX_CLOSE_RESTART symbolic constant and the posix_close() function.
Austin Group Defect 687 is applied, adding _POSIX_FALLOC and _PC_FALLOC.
Austin Group Defect 729 is applied, adding _POSIX_DEVICE_CONTROL and _SC_DEVICE_CONTROL.
Austin Group Defect 741 is applied, adding _SC_NSIG.
Austin Group Defects 1074 and 1116 are applied, changing the descriptions of _CS_POSIX_V8_THREADS_CFLAGS and
_CS_POSIX_V8_THREADS_LDFLAGS.
Austin Group Defect 1122 is applied, adding _PC_TEXTDOMAIN_MAX.
Austin Group Defect 1134 is applied, adding getentropy().
Austin Group Defect 1141 is applied, changing the RATIONALE section.
Austin Group Defect 1192 is applied, marking the encrypt() function as
obsolescent.
Austin Group Defect 1302 is applied, adding _Noreturn to _exit().
Austin Group Defects 1330 and 1595 are applied, removing obsolescent interfaces and changing "_V7_" to "_V8_" and "_V6_"
to "_V7_".
Austin Group Defects 1344 and 1666 are applied, adding getresgid(), getresuid(), setresgid(), and setresuid().
Austin Group Defect 1346 is applied, requiring support for Monotonic Clock.
Austin Group Defect 1456 is applied, clarifying the reservation of symbolic constants with the prefix _CS_, _PC_, and _SC_.
Austin Group Defect 1462 is applied, adding a paragraph to APPLICATION USAGE about conformance of supported programming
environments.
Austin Group Defect 1473 is applied, updating the list of earlier versions of this standard in the APPLICATION USAGE
section.
Austin Group Defect 1518 is applied, correcting the spelling of "programming".
Austin Group Defect 1569 is applied, changing references to a pointer type to "all pointer types".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/sys_un.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sys/un.h — definitions for UNIX domain sockets
SYNOPSIS
#include
DESCRIPTION
The  header shall define the sockaddr_un structure, which shall include at least the following
members:
sa_family_t  sun_family      Address family.
char         sun_path[size]  Socket pathname storage.
The sun_path member shall be the last member of the sockaddr_un structure, where size shall be an
implementation-provided constant size of at least 92 bytes. This size value need not be accessible as a constant available
for use in the application namespace.
The sockaddr_un structure is used to store addresses for UNIX domain sockets. Pointers to this type shall be cast by
applications to struct sockaddr * for use with socket functions.
The  header shall define the sa_family_t type as described in .
The following sections are informative.
APPLICATION USAGE
The size of sun_path is required to be constant, but intentionally does not have a specified name for that constant.
Historically, different implementations used different sizes. For example, 4.3 BSD used a size of 108, and 4.4 BSD used a size of
104. Since most implementations originate from BSD versions, the size is typically in the range 92 to 108. An application can
deduce the size by using sizeof(((struct sockaddr_un *)0)->sun_path).
Applications should not assume a particular length for sun_path or assume that it can hold {_POSIX_PATH_MAX} bytes
(256).
Although applications are required to initialize all members (including any non-standard ones) of a sockaddr_in6
structure (see ), the same is not required for the
sockaddr_un structure, since historically many applications only initialized the standard members. Despite this,
applications are encouraged to initialize sockaddr_un structures in a manner similar to the required initialization of
sockaddr_in6 structures.
RATIONALE
Some implementations expose a macro SUN_LEN for the size of a pathname stored in sun_path. However, this was not widely
adopted, and differences on how a terminating null byte is interpreted between implementations did not make it worth
standardizing.
FUTURE DIRECTIONS
None.
SEE ALSO
,
XSH bind(), socket(), socketpair()
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
Issue 7
The value for {_POSIX_PATH_MAX} is updated to 256.
POSIX.1-2008, Technical Corrigendum 1, XBD/TC1-2008/0074 [355] is applied.
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0081 [934] is applied.
Issue 8
Austin Group Defect 561 is applied, changing the requirements for the sun_path member of the sockaddr_un
structure.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/dlfcn.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
dlfcn.h — dynamic linking
SYNOPSIS
#include
DESCRIPTION
The  header shall define the Dl_info_t structure type, which shall include at least the following
members:
const char *dli_fname     Pathname of mapped object file.
void       *dli_fbase     Base of mapped address range.
const char *dli_sname     Symbol name or null pointer.
void       *dli_saddr     Symbol address or null pointer.
The  header shall define at least the following symbolic constants for use in the construction of a
dlopen() mode argument:
RTLD_LAZY
Relocations are performed at an implementation-defined time.
RTLD_NOW
Relocations are performed when the object is loaded.
RTLD_GLOBAL
All symbols are available for relocation processing of other modules.
RTLD_LOCAL
All symbols are not made available for relocation processing by other modules.
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
int    dladdr(const void *restrict, Dl_info_t *restrict);
int    dlclose(void *);
char  *dlerror(void);
void  *dlopen(const char *, int);
void  *dlsym(void *restrict, const char *restrict);
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XSH dladdr(), dlclose(),
dlerror(), dlopen(), dlsym()
CHANGE HISTORY
First released in Issue 5.
Issue 6
The restrict keyword is added to the prototype for dlsym().
Issue 7
The  header is moved from the XSI option to the Base.
This reference page is clarified with respect to macros and symbolic constants.
Issue 8
Austin Group Defect 993 is applied, adding dladdr().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/nl_types.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
nl_types.h — data types
SYNOPSIS
#include
DESCRIPTION
The  header shall define at least the following types:
nl_catd
Used by the message catalog functions catopen(), catgets(), and catclose() to identify a
catalog descriptor.
nl_item
Used by nl_langinfo() to identify items of langinfo data. Values of
objects of type nl_item are defined in .
The  header shall define at least the following symbolic constants:
NL_SETD
Used by gencat when no $set directive is specified in a message text source file. This constant can be passed as
the value of set_id on subsequent calls to catgets() (that is, to retrieve
messages from the default message set). The value of NL_SETD is implementation-defined.
NL_CAT_LOCALE
Value that can be passed as the oflag argument to catopen() to request
that message catalog selection depends on the LC_MESSAGES locale category, rather than directly on the LANG
environment variable.
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
int       catclose(nl_catd);
char     *catgets(nl_catd, int, int, const char *);
nl_catd   catopen(const char *, int);
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XSH catclose(), catgets(),
catopen(), nl_langinfo()
XCU gencat
CHANGE HISTORY
First released in Issue 2.
Issue 7
The  header is moved from the XSI option to the Base.
This reference page is clarified with respect to macros and symbolic constants.
Issue 8
The description of NL_CAT_LOCALE is updated to eliminate the use of "must".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/sys_times.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sys/times.h — file access and modification times structure
SYNOPSIS
#include
DESCRIPTION
The  header shall define the tms structure, which is returned by times() and shall include at least the following members:
clock_t  tms_utime  User CPU time.
clock_t  tms_stime  System CPU time.
clock_t  tms_cutime User CPU time of terminated child processes.
clock_t  tms_cstime System CPU time of terminated child processes.
The  header shall define the clock_t type as described in .
The following shall be declared as a function and may also be defined as a macro. A function prototype shall be provided.
clock_t times(struct tms *);
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XSH times()
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/search.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
search.h — search tables
SYNOPSIS
[XSI]  #include
DESCRIPTION
The  header shall define the ENTRY type for structure entry which shall include the
following members:
char    *key
void    *data
and shall define ACTION and VISIT as enumeration data types through type definitions as follows:
enum { FIND, ENTER } ACTION;
enum { preorder, postorder, endorder, leaf } VISIT;
The  header shall define the size_t type as described in .
The  header shall define via typedef the posix_tnode type as an alias for void.
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
int          hcreate(size_t);
void         hdestroy(void);
ENTRY       *hsearch(ENTRY, ACTION);
void         insque(void *, void *);
void        *lfind(const void *, const void *, size_t *,
size_t, int (*)(const void *, const void *));
void        *lsearch(const void *, void *, size_t *,
size_t, int (*)(const void *, const void *));
void         remque(void *);
void        *tdelete(const void *restrict, posix_tnode **restrict,
int(*)(const void *, const void *));
posix_tnode *tfind(const void *, posix_tnode *const *,
int(*)(const void *, const void *));
posix_tnode *tsearch(const void *, posix_tnode **,
int(*)(const void *, const void *));
void         twalk(const posix_tnode *,
void (*)(const posix_tnode *, VISIT, int));
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
Earlier versions of this standard explicitly used void for both node and key references where this version now uses
posix_tnode for nodes and keeps void in the text referring only to keys. In order to preserve backwards
compatibility, this version defines posix_tnode as an alias for void. The change was made to make the function
prototypes more easily understandable.
FUTURE DIRECTIONS
None.
SEE ALSO
XSH hcreate(), insque(),
lsearch(), tdelete()
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The Open Group Corrigendum U021/6 is applied, updating the prototypes for tdelete() and tsearch().
The restrict keyword is added to the prototype for tdelete().
Issue 8
Austin Group Defect 1011 is applied, adding the posix_tnode type and changing some prototypes to use it instead of
void.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/sys_statvfs.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sys/statvfs.h — VFS File System information structure
SYNOPSIS
#include
DESCRIPTION
The  header shall define the statvfs structure, which shall include at least the following
members:
unsigned long f_bsize    File system block size.
unsigned long f_frsize   Fundamental file system block size.
fsblkcnt_t    f_blocks   Total number of blocks on file system in units of f_frsize.
fsblkcnt_t    f_bfree    Total number of free blocks.
fsblkcnt_t    f_bavail   Number of free blocks available to
non-privileged process.
fsfilcnt_t    f_files    Total number of file serial numbers.
fsfilcnt_t    f_ffree    Total number of free file serial numbers.
fsfilcnt_t    f_favail   Number of file serial numbers available to
non-privileged process.
unsigned long f_fsid     File system ID.
unsigned long f_flag     Bit mask of f_flag values.
unsigned long f_namemax  Maximum filename length.
The  header shall define the fsblkcnt_t and fsfilcnt_t types as described in .
The  header shall define the following symbolic constants for the f_flag member:
ST_RDONLY
Read-only file system.
ST_NOSUID
Does not support the semantics of the ST_ISUID and ST_ISGID file mode bits.
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
int fstatvfs(int, struct statvfs *);
int statvfs(const char *restrict, struct statvfs *restrict);
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XSH fstatvfs()
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
The type of f_blocks, f_bfree, and f_bavail is changed from unsigned long to fsblkcnt_t; the
type of f_files, f_ffree, and f_favail is changed from unsigned long to fsfilcnt_t.
Issue 6
The Open Group Corrigendum U035/5 is applied. In the DESCRIPTION, the types fsblkcnt_t and fsfilcnt_t have been
described.
The restrict keyword is added to the prototype for statvfs().
IEEE Std 1003.1-2001/Cor 1-2002, item XBD/TC1/D6/18 is applied, changing the description of ST_NOSUID from "Does
not support setuid()/setgid()
semantics" to "Does not support the semantics of the ST_ISUID and ST_ISGID file mode bits".
Issue 7
The  header is moved from the XSI option to the Base.
This reference page is clarified with respect to macros and symbolic constants.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/stdbool.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
stdbool.h — boolean type and values
SYNOPSIS
#include
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The  header shall define the following macros:
bool
Expands to _Bool.
true
Expands to the integer constant 1.
false
Expands to the integer constant 0.
__bool_true_false_are_defined
Expands to the integer constant 1.
The macros true, false and __bool_true_false_are_defined shall be suitable for use in #if preprocessing directives.
[OB]  An
application can undefine and then possibly redefine the macros bool, true, and false.
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
The ability to undefine and redefine the macros bool, true, and false is an obsolescent feature and may be removed in a future
version.
SEE ALSO
None.
CHANGE HISTORY
First released in Issue 6. Included for alignment with the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1257 is applied, correcting a mismatch with the ISO C standard by adding the requirement for the
integer-valued macros to be suitable for use in #if preprocessing directives.
Austin Group Defect 1302 is applied, adding OB shading to the statement that an application can "undefine and then possibly
redefine the macros bool, true, and false".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/monetary.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
monetary.h — monetary types
SYNOPSIS
#include
DESCRIPTION
The  header shall define the locale_t type as described in .
The  header shall define the size_t type as described in .
The  header shall define the ssize_t type as described in .
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided for use
with ISO C standard compilers.
ssize_t  strfmon(char *restrict, size_t, const char *restrict, ...);
ssize_t  strfmon_l(char *restrict, size_t, locale_t,
const char *restrict, ...);
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
, ,
XSH strfmon()
CHANGE HISTORY
First released in Issue 4.
Issue 6
The restrict keyword is added to the prototype for strfmon().
Issue 7
The  header is moved from the XSI option to the Base.
The strfmon_l() function is added from The Open Group Technical Standard, 2006,
Extended API Set Part 4.
A declaration for the locale_t type is added.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/sys_select.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sys/select.h — select types
SYNOPSIS
#include
DESCRIPTION
The  header shall define the timeval structure, which shall include at least the following
members:
time_t         tv_sec      Seconds.
suseconds_t    tv_usec     Microseconds.
The  header shall define the time_t and suseconds_t types as described in .
The  header shall define the sigset_t type as described in .
The  header shall define the timespec structure as described in .
The  header shall define the fd_set type as a structure.
The  header shall define the following symbolic constant, which shall have a value suitable for use
in #if preprocessing directives:
FD_SETSIZE
Maximum number of file descriptors in an fd_set structure.
The following shall be declared as functions, defined as macros, or both. If functions are declared, function prototypes shall
be provided.
void FD_CLR(int, fd_set *);
int  FD_ISSET(int, const fd_set *);
void FD_SET(int, fd_set *);
void FD_ZERO(fd_set *);
If implemented as macros, these may evaluate their arguments more than once, so applications should ensure that the arguments
they supply are never expressions with side-effects.
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
int  pselect(int, fd_set *restrict, fd_set *restrict, fd_set *restrict,
const struct timespec *restrict, const sigset_t *restrict);
int  select(int, fd_set *restrict, fd_set *restrict, fd_set *restrict,
struct timeval *restrict);
Inclusion of the  header may make visible all symbols from the headers  and .
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
, ,
,
XSH pselect()
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1g-2000.
The requirement for the fd_set structure to have a member fds_bits has been removed as per The Open Group Base
Resolution bwg2001-005.
Issue 7
SD5-XBD-ERN-6 is applied, reordering the DESCRIPTION.
This reference page is clarified with respect to macros and symbolic constants.
Issue 8
Austin Group Defect 220 is applied, adding const to the second parameter of FD_ISSET().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/grp.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
grp.h — group structure
SYNOPSIS
#include
DESCRIPTION
The  header shall declare the group structure, which shall include the following members:
char   *gr_name The name of the group.
gid_t   gr_gid  Numerical group ID.
char  **gr_mem  Pointer to a null-terminated array of character
pointers to member names.
The  header shall define the gid_t and size_t types as described in .
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
[XSI]
void           endgrent(void);
struct group  *getgrent(void);
struct group  *getgrgid(gid_t);
int            getgrgid_r(gid_t, struct group *, char *,
size_t, struct group **);
struct group  *getgrnam(const char *);
int            getgrnam_r(const char *, struct group *, char *,
size_t , struct group **);
[XSI]
void           setgrent(void);
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XSH endgrent(), getgrgid(),
getgrnam()
CHANGE HISTORY
First released in Issue 1.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Threads Extension.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The definition of gid_t is mandated.
The getgrgid_r() and getgrnam_r() functions are marked as part of the Thread-Safe Functions option.
Issue 7
SD5-XBD-ERN-56 is applied, adding a reference to  for the
size_t type.
POSIX.1-2008, Technical Corrigendum 1, XBD/TC1-2008/0049 [24] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/sys_mman.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sys/mman.h — memory management declarations
SYNOPSIS
#include
DESCRIPTION
The  header shall define the following symbolic constants for use as protection options:
PROT_EXEC
Page can be executed.
PROT_NONE
Page cannot be accessed.
PROT_READ
Page can be read.
PROT_WRITE
Page can be written.
The  header shall define the following symbolic constants for use as flag options:
MAP_ANON
Synonym for MAP_ANONYMOUS. MAP_ANON shall have the same value as MAP_ANONYMOUS.
MAP_ANONYMOUS
Map anonymous memory.
MAP_FIXED
Interpret addr exactly.
MAP_PRIVATE
Changes are private.
MAP_SHARED
Share changes.
[XSI|SIO]  The  header shall define the following symbolic constants for the msync() function:
MS_ASYNC
Perform asynchronous writes.
MS_INVALIDATE
Invalidate mappings.
MS_SYNC
Perform synchronous writes.
[ML]  The
header shall define the following symbolic constants for the mlockall() function:
MCL_CURRENT
Lock currently mapped pages.
MCL_FUTURE
Lock pages that become mapped.
The  header shall define the symbolic constant MAP_FAILED which shall have type void * and shall
be used to indicate a failure from the mmap() function .
[ADV]
If the Advisory Information option is supported, the  header shall define symbolic constants for the
advice argument to the posix_madvise() function as follows:
POSIX_MADV_DONTNEED
The application expects that it will not access the specified range in the near future.
POSIX_MADV_NORMAL
The application has no advice to give on its behavior with respect to the specified range. It is the default characteristic if no
advice is given for a range of memory.
POSIX_MADV_RANDOM
The application expects to access the specified range in a random order.
POSIX_MADV_SEQUENTIAL
The application expects to access the specified range sequentially from lower addresses to higher addresses.
POSIX_MADV_WILLNEED
The application expects to access the specified range in the near future.
[TYM]
The  header shall define the following symbolic constants for use as flags for the posix_typed_mem_open() function:
POSIX_TYPED_MEM_ALLOCATE
Allocate on mmap().
POSIX_TYPED_MEM_ALLOCATE_CONTIG
Allocate contiguously on mmap().
POSIX_TYPED_MEM_MAP_ALLOCATABLE
Map on mmap(), without affecting allocatability.
The  header shall define the mode_t, off_t, and size_t types as described in
.
[TYM]
The  header shall define the posix_typed_mem_info structure, which shall include at least the
following member:
size_t  posix_tmi_length  Maximum length which may be allocated
from a typed memory object.
The  header shall define the following symbolic constants as described in :
[SHM|TYM]
O_RDONLY
O_RDWR
[TYM]
O_WRONLY
O_CLOEXEC
O_CLOFORK
[SHM]
O_CREAT
O_EXCL
O_TRUNC
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
[MLR]
int    mlock(const void *, size_t);
[ML]
int    mlockall(int);
void  *mmap(void *, size_t, int, int, int, off_t);
int    mprotect(void *, size_t, int);
[XSI|SIO]
int    msync(void *, size_t, int);
[MLR]
int    munlock(const void *, size_t);
[ML]
int    munlockall(void);
int    munmap(void *, size_t);
[ADV]
int    posix_madvise(void *, size_t, int);
[TYM]
int    posix_mem_offset(const void *restrict, size_t, off_t *restrict,
size_t *restrict, int *restrict);
int    posix_typed_mem_get_info(int, struct posix_typed_mem_info *);
int    posix_typed_mem_open(const char *, int, int);
[SHM]
int    shm_open(const char *, int, mode_t);
int    shm_unlink(const char *);
Inclusion of the  header may make visible all symbols from the  header.
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XSH mlock(), mlockall(),
mmap(), mprotect(), msync(), munmap(), posix_madvise(), posix_mem_offset(), posix_typed_mem_get_info(), posix_typed_mem_open(), shm_open(), shm_unlink()
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Updated for alignment with the POSIX Realtime Extension.
Issue 6
The  header is marked as dependent on support for either the Memory Mapped Files, Process Memory
Locking, or Shared Memory Objects options.
The following changes are made for alignment with IEEE Std 1003.1j-2000:
The TYM margin code is added to the list of margin codes for the  header line, as well as for other
lines.
The POSIX_TYPED_MEM_ALLOCATE, POSIX_TYPED_MEM_ALLOCATE_CONTIG, and POSIX_TYPED_MEM_MAP_ALLOCATABLE flags are added.
The posix_tmi_length structure is added.
The posix_mem_offset(), posix_typed_mem_get_info(), and posix_typed_mem_open() functions are added.
The restrict keyword is added to the prototype for posix_mem_offset().
IEEE PASC Interpretation 1003.1 #102 is applied, adding the prototype for posix_madvise().
IEEE Std 1003.1-2001/Cor 1-2002, item XBD/TC1/D6/16 is applied, correcting margin code and shading errors for the
mlock() and munlock() functions.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/34 is applied, changing the margin code for the mmap() function from MF|SHM to MC3 (notation for MF|SHM|TYM).
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/36 is applied, changing the margin code for the munmap() function from MF|SHM to MC3 (notation for MF|SHM|TYM).
Issue 7
SD5-XBD-ERN-5 is applied, rewriting the DESCRIPTION.
Functionality relating to the Memory Protection and Memory Mapped Files options is moved to the Base.
This reference page is clarified with respect to macros and symbolic constants.
Issue 8
Austin Group Defect 593 is applied, adding O_RDONLY, O_RDWR, O_WRONLY, O_CLOEXEC, O_CLOFORK, O_CREAT, O_EXCL, and O_TRUNC, and
allowing  to make visible all symbols from .
Austin Group Defect 850 is applied, adding MAP_ANON and MAP_ANONYMOUS.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/sched.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sched.h — execution scheduling
SYNOPSIS
#include
DESCRIPTION
[PS]  The
header shall define the pid_t type as described in .
[SS|TSP]
The  header shall define the time_t type as described in .
The  header shall define the timespec structure as described in .
The  header shall define the sched_param structure, which shall include the scheduling parameters
required for implementation of each supported scheduling policy. This structure shall include at least the following member:
int       sched_priority        Process or thread execution scheduling priority.
[SS|TSP]
The sched_param structure defined in  shall include the following members in addition to those
specified above:
int             sched_ss_low_priority Low scheduling priority for
sporadic server.
struct timespec sched_ss_repl_period  Replenishment period for
sporadic server.
struct timespec sched_ss_init_budget  Initial budget for sporadic server.
int             sched_ss_max_repl     Maximum pending replenishments for
sporadic server.
Each process or thread is controlled by an associated scheduling policy and priority. Associated with each policy is a priority
range. Each policy definition specifies the minimum priority range for that policy. The priority ranges for each policy may overlap
the priority ranges of other policies.
Four scheduling policies are defined; others may be defined by the implementation. The four standard policies are indicated by
the values of the following symbolic constants:
SCHED_FIFO
[PS|TPS]  First in-first out (FIFO) scheduling policy.
SCHED_RR
[PS|TPS]  Round robin scheduling policy.
SCHED_SPORADIC
[SS|TSP]  Sporadic server scheduling policy.
SCHED_OTHER
[PS|TPS]  Another scheduling policy.
The values of these constants are distinct.
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
[PS|TPS]
int    sched_get_priority_max(int);
int    sched_get_priority_min(int);
[PS]
int    sched_getparam(pid_t, struct sched_param *);
int    sched_getscheduler(pid_t);
[PS|TPS]
int    sched_rr_get_interval(pid_t, struct timespec *);
[PS]
int    sched_setparam(pid_t, const struct sched_param *);
int    sched_setscheduler(pid_t, int, const struct sched_param *);
int    sched_yield(void);
Inclusion of the  header may make visible all symbols from the  header.
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
,
XSH sched_get_priority_max(), sched_getparam(), sched_getscheduler(), sched_rr_get_interval(), sched_setparam(), sched_setscheduler(), sched_yield()
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The  header is marked as part of the Process Scheduling option.
Sporadic server members are added to the sched_param structure, and the SCHED_SPORADIC scheduling policy is added for
alignment with IEEE Std 1003.1d-1999.
IEEE PASC Interpretation 1003.1 #108 is applied, correcting the sched_param structure whose members
sched_ss_repl_period and sched_ss_init_budget should be type struct timespec and not timespec.
Symbols from  may be made visible when  is
included.
IEEE Std 1003.1-2001/Cor 1-2002, items XSH/TC1/D6/52 and XSH/TC1/D6/53 are applied, aligning the function
prototype shading and margin codes with the System Interfaces volume of IEEE Std 1003.1-2001.
IEEE Std 1003.1-2001/Cor 2-2004, item XBD/TC2/D6/23 is applied, updating the DESCRIPTION to differentiate between
thread and process execution.
Issue 7
SD5-XBD-ERN-13 is applied.
Austin Group Interpretation 1003.1-2001 #064 is applied, correcting the options markings.
The  headers is moved from the Threads option to the Base.
Declarations for the pid_t and time_t types and the timespec structure are added.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/fcntl.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fcntl.h — file control options
SYNOPSIS
#include
DESCRIPTION
The  header shall define the f_owner_ex structure, which shall include at least the following
members:
int   type      Discriminator for pid.
pid_t pid       Process ID or process group ID.
The  header shall define the flock structure describing a file lock. It shall include the following
members:
short  l_type   Type of lock; F_RDLCK, F_WRLCK, F_UNLCK.
short  l_whence Flag for starting offset.
off_t  l_start  Relative offset in bytes.
off_t  l_len    Size; if 0 then until EOF.
pid_t  l_pid    For a process-owned file lock, ignored on input or the process ID of the
owning process on output; for an OFD-owned file lock, zero on input or
(pid_t)-1 on output.
The  header shall define the mode_t, off_t, and pid_t types as described in .
The  header shall define the following symbolic constants for the cmd argument used by fcntl(). The values shall be unique and shall be suitable for use in #if preprocessing
directives.
F_DUPFD
Duplicate file descriptor.
F_DUPFD_CLOEXEC
Duplicate file descriptor with the close-on-exec flag FD_CLOEXEC set.
F_DUPFD_CLOFORK
Duplicate file descriptor with the close-on-fork flag FD_CLOFORK set.
F_GETFD
Get file descriptor flags.
F_SETFD
Set file descriptor flags.
F_GETFL
Get file status flags and file access modes.
F_SETFL
Set file status flags.
F_GETLK
Get information about file locks.
F_SETLK
Set a process-owned file lock.
F_SETLKW
Set a process-owned file lock; wait if blocked.
F_OFD_GETLK
Get information about file locks.
F_OFD_SETLK
Set an OFD-owned file lock.
F_OFD_SETLKW
Set an OFD-owned file lock; wait if blocked.
F_GETOWN
Get process or process group ID to receive SIGURG signals, via int type.
F_GETOWN_EX
Get process or process group ID to receive SIGURG signals, via pid_t type.
F_SETOWN
Set process or process group ID to receive SIGURG signals, via int type.
F_SETOWN_EX
Set process or process group ID to receive SIGURG signals, via pid_t type.
The  header shall define the following symbolic constants used for the fcntl() file descriptor flags. The values shall be bitwise-distinct and shall be suitable for
use in #if preprocessing directives.
FD_CLOEXEC
Close the file descriptor upon execution of an exec family function [SPN]   and in the
new process image created by posix_spawn() or posix_spawnp().
FD_CLOFORK
Close the file descriptor in any child process created from a process that has the file descriptor open; that is, the child
shall not inherit the file descriptor.
The  header shall also define the following symbolic constants for the l_type argument used for
record locking with fcntl(). The values shall be unique and shall be suitable for use
in #if preprocessing directives.
F_RDLCK
Shared or read lock.
F_UNLCK
Unlock.
F_WRLCK
Exclusive or write lock.
The  header shall also define the following symbolic constants for the type member of the
f_owner_ex structure. The values shall be unique.
F_OWNER_PID
The pid member of f_owner_ex holds a process ID.
F_OWNER_PGRP
The pid member of f_owner_ex holds a process group ID.
The  header shall define the values used for l_whence, SEEK_SET, SEEK_CUR, and SEEK_END as
described in .
The  header shall define the following symbolic constants as file creation flags for use in the
oflag value to open() and openat(). The values shall be bitwise-distinct and shall be suitable for use in #if
preprocessing directives.
O_CLOEXEC
Atomically set the FD_CLOEXEC flag on the new file descriptor.
O_CLOFORK
Atomically set the FD_CLOFORK flag on the new file descriptor.
O_CREAT
Create file if it does not exist.
O_DIRECTORY
Fail if file is a non-directory file.
O_EXCL
Exclusive use flag.
O_NOCTTY
Do not assign controlling terminal.
O_NOFOLLOW
Do not follow symbolic links.
O_TRUNC
Truncate flag.
O_TTY_INIT
Set the termios structure terminal parameters to a state that provides conforming behavior; see 11.2 Parameters that Can be Set.
The O_TTY_INIT flag can have the value zero and in this case it need not be bitwise-distinct from the other flags.
The  header shall define the following symbolic constants for use as file status flags for open(), openat(), and fcntl(). The values shall be suitable for use in #if preprocessing directives.
O_APPEND
Set append mode.
O_DSYNC
[SIO]
Write according to synchronized I/O data integrity completion.
O_NONBLOCK
Non-blocking mode.
O_RSYNC
[SIO]
Synchronized read I/O operations.
O_SYNC
Write according to synchronized I/O file integrity completion.
The  header shall define the following symbolic constant for use as the mask for file access modes. The
value shall be suitable for use in #if preprocessing directives.
O_ACCMODE
Mask for file access modes.
The  header shall define the following symbolic constants for use as the file access modes for open(), openat(), and fcntl(). The values shall be unique, except that O_EXEC and O_SEARCH may have equal values.
The values shall be suitable for use in #if preprocessing directives.
O_EXEC
Open for execute only (non-directory files). The result is unspecified if this flag is applied to a directory.
O_RDONLY
Open for reading only.
O_RDWR
Open for reading and writing.
O_SEARCH
Open directory for search only. The result is unspecified if this flag is applied to a non-directory file.
O_WRONLY
Open for writing only.
The  header shall define the symbolic constants for file modes for use as values of mode_t as
described in .
The  header shall define the following symbolic constant as a special value used in place of a file
descriptor for the *at() functions which take a directory file descriptor as a parameter:
AT_FDCWD
Use the current working directory to determine the target of relative file paths.
The  header shall define the following symbolic constant as a value for the flag used by faccessat():
AT_EACCESS
Check access using effective user and group ID.
The  header shall define the following symbolic constant as a value for the flag used by fstatat(), fchmodat(), fchownat(), and utimensat():
AT_SYMLINK_NOFOLLOW
Do not follow symbolic links.
The  header shall define the following symbolic constant as a value for the flag used by linkat():
AT_SYMLINK_FOLLOW
Follow symbolic link.
The  header shall define the following symbolic constant as a value for the flag used by unlinkat():
AT_REMOVEDIR
Remove directory instead of file.
[ADV]
The  header shall define the following symbolic constants for the advice argument used by posix_fadvise():
POSIX_FADV_DONTNEED
The application expects that it will not access the specified data in the near future.
POSIX_FADV_NOREUSE
The application expects to access the specified data once and then not reuse it thereafter.
POSIX_FADV_NORMAL
The application has no advice to give on its behavior with respect to the specified data. It is the default characteristic if no
advice is given for an open file.
POSIX_FADV_RANDOM
The application expects to access the specified data in a random order.
POSIX_FADV_SEQUENTIAL
The application expects to access the specified data sequentially from lower offsets to higher offsets.
POSIX_FADV_WILLNEED
The application expects to access the specified data in the near future.
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.
int  creat(const char *, mode_t);
int  fcntl(int, int, ...);
int  open(const char *, int, ...);
int  openat(int, const char *, int, ...);
[ADV]
int  posix_fadvise(int, off_t, off_t, int);
int  posix_fallocate(int, off_t, off_t);
Inclusion of the  header may also make visible all symbols from  and .
The following sections are informative.
APPLICATION USAGE
Although no existing implementation defines AT_SYMLINK_FOLLOW and AT_SYMLINK_NOFOLLOW as the same numeric value, POSIX.1-2024
does not prohibit that as the two constants are not used with the same interfaces.
RATIONALE
While many of the symbolic constants introduced in the  header do not strictly need to be used in
#if preprocessor directives, widespread historic practice has defined them as macros that are usable in such constructs, and
examination of existing applications has shown that they are occasionally used in such a way. Therefore it was decided to retain
this requirement on an implementation in POSIX.1-2024.
FUTURE DIRECTIONS
A future version of this standard may add an O_NOCLOBBER file creation flag. See the FUTURE DIRECTIONS section for open().
SEE ALSO
, ,
,
XSH creat(), exec,
fcntl(), futimens(), open(), posix_fadvise(), posix_fallocate(), posix_madvise()
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Realtime Extension.
Issue 6
The following changes are made for alignment with the ISO POSIX-1:1996 standard:
O_DSYNC and O_RSYNC are marked as part of the Synchronized Input and Output option.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The definition of the mode_t, off_t, and pid_t types is mandated.
The F_GETOWN and F_SETOWN values are added for sockets.
The posix_fadvise(), posix_fallocate(), and posix_madvise() functions are added for alignment with
IEEE Std 1003.1d-1999.
IEEE PASC Interpretation 1003.1 #102 is applied, moving the prototype for posix_madvise() to .
IEEE Std 1003.1-2001/Cor 2-2004, item XBD/TC2/D6/18 is applied, updating the prototypes for posix_fadvise() and posix_fallocate() to be large file-aware, using off_t instead of
size_t.
Issue 7
Austin Group Interpretation 1003.1-2001 #144 is applied, adding the O_TTY_INIT flag.
Austin Group Interpretation 1003.1-2001 #171 is applied, adding support to set the FD_CLOEXEC flag atomically at open(), and adding the F_DUPFD_CLOEXEC flag.
The openat() function is added from The Open Group Technical Standard, 2006,
Extended API Set Part 2.
Additional flags are added to support faccessat(), fchmodat(), fchownat(), fstatat(), linkat(), open(), openat(), and unlinkat().
This reference page is clarified with respect to macros and symbolic constants.
Changes are made related to support for finegrained timestamps.
Changes are made to allow a directory to be opened for searching.
POSIX.1-2008, Technical Corrigendum 1, XBD/TC1-2008/0044 [274] and XBD/TC1-2008/0045 [78,432] are applied.
POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0060 [847] is applied.
Issue 8
Austin Group Defect 768 is applied, adding OFD-owned file locks.
Austin Group Defect 1016 is applied, changing the FUTURE DIRECTIONS section.
Austin Group Defect 1274 is applied, adding the f_owner_ex structure and related symbolic constants.
Austin Group Defect 1318 is applied, adding FD_CLOFORK and O_CLOFORK, and changing O_CLOEXEC.
Austin Group Defect 1351 is applied, adding F_DUPFD_CLOFORK.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/V1_chap01.html =====
Introduction
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
1. Introduction
1.1 Scope
POSIX.1-2024 defines a standard operating system interface and environment, including a command interpreter (or "shell"), and
common utility programs to support applications portability at the source code level. It is intended to be used by both application
developers and system implementors.
POSIX.1-2024 comprises four major components (each in an associated volume):
General terms, concepts, and interfaces common to all volumes of POSIX.1-2024, including utility conventions and C-language
header definitions, are included in the Base Definitions volume of POSIX.1-2024.
Definitions for system service functions and subroutines, language-specific system services for the C programming language,
function issues, including portability, error handling, and error recovery, are included in the System Interfaces volume of
POSIX.1-2024.
Definitions for a standard source code-level interface to command interpretation services (a "shell") and common utility
programs for application programs are included in the Shell and Utilities volume of POSIX.1-2024.
Extended rationale that did not fit well into the rest of the document structure, containing historical information concerning
the contents of POSIX.1-2024 and why features were included or discarded by the standard developers, is included in the Rationale
(Informative) volume of POSIX.1-2024.
The following areas are outside of the scope of POSIX.1-2024:
Graphics interfaces
Database management system interfaces
Record I/O considerations
Object or binary code portability
System configuration and resource availability
POSIX.1-2024 describes the external characteristics and facilities that are of importance to application developers, rather than
the internal construction techniques employed to achieve these capabilities. Special emphasis is placed on those functions and
facilities that are needed in a wide variety of commercial applications.
The facilities provided in POSIX.1-2024 are drawn from the following base documents:
IEEE Std 1003.1-2017 (POSIX.1-2017)
IEEE Std 1003.26-2003 (POSIX.26-2003)
ISO/IEC 9899:2018, Programming Languages — C (C17)
ISO/IEC TR 24731-2:2010, Programming languages, their environments and system software interfaces — Extensions to the C library
— Part 2: Dynamic Allocation Functions
The Open Group Standard, 2021, Additional APIs for the Base Specifications Issue 8, Part 1
The Open Group Standard, 2022, Additional APIs for the Base Specifications Issue 8, Part 2
Emphasis has been placed on standardizing existing practice for existing users, with changes and additions limited to correcting
deficiencies in the following areas:
Issues raised by Austin Group defect reports and IEEE Interpretations against IEEE Std 1003.1.
Issues raised in corrigenda for The Open Group Standards and working group resolutions from The Open Group
Changes to make the text self-consistent with the additional material merged
Features, marked obsolescent in the base documents, have been considered for removal in this version
Alignment with the ISO/IEC 9899:2018 standard
1.2 Word Usage
The word shall indicates mandatory requirements strictly to be followed in order to conform to the standard and from
which no deviation is permitted (shall equals is required to). 1, 2
The word should indicates that among several possibilities one is recommended as particularly suitable, without
mentioning or excluding others; or that a certain course of action is preferred but not necessarily required (should equals
is recommended that).
The word may is used to indicate a course of action permissible within the limits of the standard (may equals
is permitted to).
The word can is used for statements of possibility and capability, whether material, physical, or causal (can
equals is able to).
1.3 Conformance
Conformance requirements for POSIX.1-2024 are defined in 2. Conformance
.
1.4 Normative References
The following standards contain provisions which, through references in POSIX.1-2024, constitute provisions of POSIX.1-2024. At
the time of publication, the editions indicated were valid. All standards are subject to revision, and parties to agreements based
on POSIX.1-2024 are encouraged to investigate the possibility of applying the most recent editions of the standards listed below.
Members of IEC and ISO maintain registers of currently valid International Standards.
ISO/IEC 646:1991
ISO/IEC 646:1991, Information Processing — ISO 7-Bit Coded Character Set for Information Interchange.3
ISO 4217:2015
ISO 4217:2015, Codes for the representation of currencies.
ISO 8601-1:2019
ISO 8601-1:2019, Date and time — Representations for information interchange — Part 1: Basic rules.
ISO C (C17)
ISO/IEC 9899:2018, Programming Languages — C.
ISO/IEC 10646:2020
ISO/IEC 10646:2020, Information Technology — Universal coded character set (UCS).
1.5 Change History
Change history is described in the Rationale (Informative) volume of POSIX.1-2024, and in the CHANGE HISTORY section of
reference pages.
1.6 Terminology
For the purposes of POSIX.1-2024, the following terminology definitions apply:
can
Describes a permissible optional feature or behavior available to the user or application. The feature or behavior is mandatory
for an implementation that conforms to POSIX.1-2024. An application can rely on the existence of the feature or behavior.
implementation-defined
Describes a value or behavior that is not defined by POSIX.1-2024 but is selected by an implementor. The value or behavior may
vary among implementations that conform to POSIX.1-2024. An application should not rely on the existence of the value or behavior.
An application that relies on such a value or behavior cannot be assured to be portable across conforming implementations.
The implementor shall document such a value or behavior so that it can be used correctly by an application.
legacy
Describes a feature or behavior that is being retained for compatibility with older applications, but which has limitations
which make it inappropriate for developing portable applications. New applications should use alternative means of obtaining
equivalent functionality.
may
Describes a feature or behavior that is optional for an implementation that conforms to POSIX.1-2024. An application should not
rely on the existence of the feature or behavior. An application that relies on such a feature or behavior cannot be assured to be
portable across conforming implementations.
To avoid ambiguity, the opposite of may is expressed as need not, instead of may not.
shall
For an implementation that conforms to POSIX.1-2024, describes a feature or behavior that is mandatory. An application can rely
on the existence of the feature or behavior.
For an application or user, describes a behavior that is mandatory.
should
For an implementation that conforms to POSIX.1-2024, describes a feature or behavior that is recommended but not mandatory. An
application should not rely on the existence of the feature or behavior. An application that relies on such a feature or behavior
cannot be assured to be portable across conforming implementations.
For an application, describes a feature or behavior that is recommended programming practice for optimum portability.
undefined
Describes the nature of a value or behavior not defined by POSIX.1-2024 which results from use of an invalid program construct
or invalid data input.
The value or behavior may vary among implementations that conform to POSIX.1-2024. An application should not rely on the
existence or validity of the value or behavior. An application that relies on any particular value or behavior cannot be assured to
be portable across conforming implementations.
unspecified
Describes the nature of a value or behavior not specified by POSIX.1-2024 which results from use of a valid program construct or
valid data input.
The value or behavior may vary among implementations that conform to POSIX.1-2024. An application should not rely on the
existence or validity of the value or behavior. An application that relies on any particular value or behavior cannot be assured to
be portable across conforming implementations.
1.7 Definitions and Concepts
Definitions and concepts are defined in 3. Definitions and 4. General Concepts.
1.8 Portability
Some of the utilities in the Shell and Utilities volume of POSIX.1-2024 and functions in the System Interfaces volume of
POSIX.1-2024 describe functionality that might not be fully portable to systems meeting the requirements for POSIX conformance (see
2. Conformance).
Where optional, enhanced, or reduced functionality is specified, the text is shaded and a code in the margin identifies the
nature of the option, extension, or warning (see 1.8.1 Codes). For maximum portability, an application
should avoid such functionality.
Unless the primary task of a utility is to produce textual material on its standard output, application developers should not
rely on the format or content of any such material that may be produced. Where the primary task is to provide such material,
but the output format is incompletely specified, the description is marked with the OF margin code and shading. Application
developers are warned not to expect that the output of such an interface on one system is any guide to its behavior on another
system.
1.8.1 Codes
The codes and their meanings are as follows. See also 1.8.2 Margin Code Notation.
[ADV]
Advisory Information
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the ADV margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the ADV margin legend.
[CD]
C-Language Development Utilities
The functionality described is optional.
Where applicable, utilities are marked with the CD margin legend in the SYNOPSIS section. Where additional semantics apply to a
utility, the material is identified by use of the CD margin legend.
[CPT]
Process CPU-Time Clocks
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the CPT margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the CPT margin legend.
[CX]
Extension to the ISO C standard
The functionality described is an extension to the ISO C standard or a deviation from it. Application developers can make use
of the functionality as it is supported on all POSIX.1-2024-conforming systems.
With each function or header from the ISO C standard, a statement is included to the effect that "any conflict is
unintentional", or "any other conflict is unintentional" if there is an intentional conflict (deviation). That is intended to
refer to a direct conflict. POSIX.1-2024 acts in part as a profile of the ISO C standard, and it may choose to further
constrain behaviors allowed to vary by the ISO C standard. Such limitations and other compatible differences are not
considered conflicts, even if a CX mark is missing. The markings are for information only.
Where additional semantics apply to a function or header, the material is identified by use of the CX margin legend.
[DC]
Device Control
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the DC margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the DC margin legend.
[FR]
FORTRAN Runtime Utilities
The functionality described is optional.
Where applicable, utilities are marked with the FR margin legend in the SYNOPSIS section. Where additional semantics apply to a
utility, the material is identified by use of the FR margin legend.
[FSC]
File Synchronization
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the FSC margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the FSC margin legend.
[IP6]
IPV6
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the IP6 margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the IP6 margin legend.
[MC1]
Non-Robust Mutex Priority Protection or Non-Robust Mutex Priority Inheritance or Robust Mutex Priority Protection or Robust Mutex
Priority Inheritance
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
This is a shorthand notation for combinations of multiple option codes.
Where applicable, functions are marked with the MC1 margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the MC1 margin legend.
Refer to 1.8.2 Margin Code Notation.
[ML]
Process Memory Locking
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the ML margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the ML margin legend.
[MLR]
Range Memory Locking
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the MLR margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the MLR margin legend.
[MSG]
Message Passing
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the MSG margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the MSG margin legend.
[MX]  IEC
60559 Floating-Point
The functionality described is optional. The functionality described is mandated by the ISO C standard only for
implementations that define __STDC_IEC_559__.
[MXC]
IEC 60559 Complex Floating-Point
The functionality described is optional. The functionality described is mandated by the ISO C standard only for
implementations that define __STDC_IEC_559_COMPLEX__.
[MXX]
IEC 60559 Floating-Point Extension
The functionality described is optional. The functionality described is part of the IEC 60559 Floating-Point option, but is an
extension to the ISO C standard.
[OB]
Obsolescent
The functionality described may be removed in a future version of this volume of POSIX.1-2024. Strictly Conforming POSIX
Applications and Strictly Conforming XSI Applications shall not use obsolescent features.
Where applicable, the material is identified by use of the OB margin legend.
[OF]
Output Format Incompletely Specified
The functionality described is an XSI extension. The format of the output produced by the utility is not fully specified. It is
therefore not possible to post-process this output in a consistent fashion. Typical problems include unknown length of strings and
unspecified field delimiters.
Where applicable, the material is identified by use of the OF margin legend.
[OH]
Optional Header
In the SYNOPSIS section of some interfaces in the System Interfaces volume of POSIX.1-2024 an included header is marked as in the
following example:
[OH]
#include
#include
int open(const char *path, int oflag, ...);
The OH margin legend indicates that the optional header defines constants that will be needed if the function is called with
certain flag arguments; thus it may be required for some of the functionality described, but is not needed otherwise.
[PIO]
Prioritized Input and Output
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the PIO margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the PIO margin legend.
[PS]
Process Scheduling
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the PS margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the PS margin legend.
[RPI]
Robust Mutex Priority Inheritance
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the RPI margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the RPI margin legend.
[RPP]
Robust Mutex Priority Protection
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the RPP margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the RPP margin legend.
[RS]  Raw
Sockets
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the RS margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the RS margin legend.
[SD]
Software Development Utilities
The functionality described is optional.
Where applicable, utilities are marked with the SD margin legend in the SYNOPSIS section. Where additional semantics apply to a
utility, the material is identified by use of the SD margin legend.
[SHM]
Shared Memory Objects
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the SHM margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the SHM margin legend.
[SIO]
Synchronized Input and Output
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the SIO margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the SIO margin legend.
[SPN]
Spawn
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the SPN margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the SPN margin legend.
[SS]
Process Sporadic Server
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the SS margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the SS margin legend.
[TCT]
Thread CPU-Time Clocks
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the TCT margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the TCT margin legend.
[TPI]
Non-Robust Mutex Priority Inheritance
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the TPI margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the TPI margin legend.
[TPP]
Non-Robust Mutex Priority Protection
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the TPP margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the TPP margin legend.
[TPS]
Thread Execution Scheduling
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the TPS margin legend for the SYNOPSIS section. Where additional semantics apply to
a function, the material is identified by use of the TPS margin legend.
[TSA]
Thread Stack Address Attribute
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the TSA margin legend for the SYNOPSIS section. Where additional semantics apply to
a function, the material is identified by use of the TSA margin legend.
[TSH]
Thread Process-Shared Synchronization
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the TSH margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the TSH margin legend.
[TSP]
Thread Sporadic Server
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the TSP margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the TSP margin legend.
[TSS]
Thread Stack Size Attribute
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the TSS margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the TSS margin legend.
[TYM]
Typed Memory Objects
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the TYM margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the TYM margin legend.
[UP]
User Portability Utilities
The functionality described is optional.
Where applicable, utilities are marked with the UP margin legend in the SYNOPSIS section. Where additional semantics apply to a
utility, the material is identified by use of the UP margin legend.
[UU]
UUCP Utilities
The functionality described is optional. The functionality described is also an extension to the ISO C standard.
Where applicable, functions are marked with the UU margin legend in the SYNOPSIS section. Where additional semantics apply to a
function, the material is identified by use of the UU margin legend.
[XSI]
X/Open System Interfaces
The functionality described is part of the X/Open Systems Interfaces option. Functionality marked XSI is an extension to the
ISO C standard. Application developers may confidently make use of such extensions on all systems supporting the X/Open System
Interfaces option.
If an entire SYNOPSIS section is shaded and marked XSI, all the functionality described in that reference page is an extension.
See 2.1.4 XSI Conformance.
1.8.2 Margin Code Notation
Some of the functionality described in POSIX.1-2024 depends on support of more than one option, or independently may depend on
several options. The following notation for margin codes is used to denote the following cases.
A Feature Dependent on One or Two Options
In this case, margin codes have a  separator; for example:
[SHM]
This feature requires support for only the Shared Memory Objects option.
[SHM TYM]  This feature requires support for both the Shared Memory Objects option and the Typed Memory Objects option; that is,
an application which uses this feature is portable only between implementations that provide both options.
A Feature Dependent on Either of the Options Denoted
In this case, margin codes have a '|' separator to denote the logical OR; for example:
[SHM|TYM]  This feature is dependent on support for either the Shared Memory Objects option or the Typed Memory Objects option; that is,
an application which uses this feature is portable between implementations that provide any (or all) of the options.
A Feature Dependent on More than Two Options
The following shorthand notations are used:
[MC1]
The MC1 margin code is shorthand for TPP|TPI|RPP|RPI. Features which are shaded with this margin code require support of either the
Non-Robust Mutex Priority Protection option or the Non-Robust Mutex Priority Inheritance option or the Robust Mutex Priority
Protection option or the Robust Mutex Priority Inheritance option.
Large Sections Dependent on an Option
Where large sections of text are dependent on support for an option, a lead-in text block is provided and shaded accordingly;
for example:
[XSI]
This section describes extensions to support interprocess communication. The functionality described in this section shall be
provided on implementations that support the XSI option (and the rest of this section is not further marked).
Footnotes
1. The use of the word must is deprecated and cannot be used when stating
mandatory requirements; must is used only to describe unavoidable situations.
2. The use of will is deprecated and cannot be used when stating mandatory
requirements; will is only used in statements of fact.
3. ISO/IEC documents can be obtained from https://www.iso.org/store.html.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
===== susv5-html/basedefs/fmtmsg.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fmtmsg.h — message display structures
SYNOPSIS
[XSI]  #include
DESCRIPTION
The  header shall define the following symbolic constants:
MM_HARD
Source of the condition is hardware.
MM_SOFT
Source of the condition is software.
MM_FIRM
Source of the condition is firmware.
MM_APPL
Condition detected by application.
MM_UTIL
Condition detected by utility.
MM_OPSYS
Condition detected by operating system.
MM_RECOVER
Recoverable error.
MM_NRECOV
Non-recoverable error.
MM_HALT
Error causing application to halt.
MM_ERROR
Application has encountered a non-fatal fault.
MM_WARNING
Application has detected unusual non-error condition.
MM_INFO
Informative message.
MM_NOSEV
No severity level provided for the message.
MM_PRINT
Display message on standard error.
MM_CONSOLE
Display message on system console.
The table below indicates the null values and identifiers for fmtmsg() arguments.
The  header shall define the symbolic constants in the Identifier column, which shall have the type
indicated in the Type column:
Argument
Type
Null-Value
Identifier
label
char *
(char*)0
MM_NULLLBL
severity
int
0
MM_NULLSEV
class
long
0L
MM_NULLMC
text
char *
(char*)0
MM_NULLTXT
action
char *
(char*)0
MM_NULLACT
tag
char *
(char*)0
MM_NULLTAG
The  header shall also define the following symbolic constants for use as return values for
fmtmsg():
MM_OK
The function succeeded.
MM_NOTOK
The function failed completely.
MM_NOMSG
The function was unable to generate a message on standard error, but otherwise succeeded.
MM_NOCON
The function was unable to generate a console message, but otherwise succeeded.
The following shall be declared as a function and may also be defined as a macro. A function prototype shall be
provided.
int fmtmsg(long, const char *, int,
const char *, const char *, const char *);
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XSH fmtmsg()
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 7
This reference page is clarified with respect to macros and symbolic constants.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/basedefs/ctype.h.html =====
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ctype.h — character types
SYNOPSIS
#include
DESCRIPTION
[CX]  Some of the functionality described on this reference page extends the ISO C standard. Applications shall define
the appropriate feature test macro (see XSH 2.2 The Compilation
Environment) to enable the visibility of these symbols in this header.
The  header shall define the locale_t type as described in , representing a locale object.
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided for use
with ISO C standard compilers.
int   isalnum(int);
[CX]
int   isalnum_l(int, locale_t);
int   isalpha(int);
[CX]
int   isalpha_l(int, locale_t);
int   isblank(int);
[CX]
int   isblank_l(int, locale_t);
int   iscntrl(int);
[CX]
int   iscntrl_l(int, locale_t);
int   isdigit(int);
[CX]
int   isdigit_l(int, locale_t);
int   isgraph(int);
[CX]
int   isgraph_l(int, locale_t);
int   islower(int);
[CX]
int   islower_l(int, locale_t);
int   isprint(int);
[CX]
int   isprint_l(int, locale_t);
int   ispunct(int);
[CX]
int   ispunct_l(int, locale_t);
int   isspace(int);
[CX]
int   isspace_l(int, locale_t);
int   isupper(int);
[CX]
int   isupper_l(int, locale_t);
int   isxdigit(int);
[CX]
int   isxdigit_l(int, locale_t);
int   tolower(int);
[CX]
int   tolower_l(int, locale_t);
int   toupper(int);
[CX]
int   toupper_l(int, locale_t);
The following sections are informative.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XSH 2.2 The Compilation Environment, isalnum(), isalpha(), isblank(), iscntrl(), isdigit(), isgraph(), islower(), isprint(), ispunct(), isspace(), isupper(), isxdigit(), mblen(), mbstowcs(), mbtowc(), setlocale(), tolower(), toupper(), wcstombs(), wctomb()
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
Extensions beyond the ISO C standard are marked.
Issue 7
SD5-XBD-ERN-6 is applied, updating the wording regarding the function declarations for consistency.
The *_l() functions are added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
Issue 8
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/idx/ii.html =====
Alphabetical Index - I
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2024 The IEEE and The Open Group, All Rights reserved.
[
A
|
B
|
C
|
D
|
E
|
F
|
G
|
H
|
I
|
J
|
K
|
L
|
M
|
N
|
O
|
P
|
Q
|
R
|
S
|
T
|
U
|
V
|
W
|
X
|
Y
|
Z
| Index  ]
I
iconv — codeset conversion
iconv() — codeset conversion function
iconv.h — codeset conversion facility
iconv_close() — codeset conversion deallocation function
iconv_open() — codeset conversion allocation function
id — return user identity
if_freenameindex() — free memory allocated by if_nameindex
if_indextoname() — map a network interface index to its corresponding name
if_nameindex() — return all network interface names and indexes
if_nametoindex() — map a network interface name to its corresponding index
ilogb(), ilogbf, ilogbl — return an unbiased exponent
ilogbf(), ilogb, ilogbl — return an unbiased exponent
ilogbl(), ilogb, ilogbf — return an unbiased exponent
imaxabs() — return absolute value
imaxdiv() — return quotient and remainder
in6addr_any, in6addr_loopback — IPv6 address variables
in6addr_loopback, in6addr_any — IPv6 address variables
inet_addr(), inet_ntoa — IPv4 address manipulation
inet_ntoa(), inet_addr — IPv4 address manipulation
inet_ntop(), inet_pton — convert IPv4 and IPv6 addresses between binary and text form
inet_pton(), inet_ntop — convert IPv4 and IPv6 addresses between binary and text form
initstate(), random, setstate, srandom — pseudo-random number functions
insque(), remque — insert or remove an element in a queue
inttypes.h — fixed size integer types
ipcrm — remove an XSI message queue, semaphore set, or shared memory segment identifier
ipcs — report XSI interprocess communication facilities status
isalnum(), isalnum_l — test for an alphanumeric character
isalnum_l(), isalnum — test for an alphanumeric character
isalpha(), isalpha_l — test for an alphabetic character
isalpha_l(), isalpha — test for an alphabetic character
isatty() — test for a terminal device
isblank(), isblank_l — test for a blank character
isblank_l(), isblank — test for a blank character
iscntrl(), iscntrl_l — test for a control character
iscntrl_l(), iscntrl — test for a control character
isdigit(), isdigit_l — test for a decimal digit
isdigit_l(), isdigit — test for a decimal digit
isfinite() — test for finite value
isgraph(), isgraph_l — test for a visible character
isgraph_l(), isgraph — test for a visible character
isgreater(), isgreaterequal, isless, islessequal, islessgreater — real-floating relational tests
isgreaterequal(), isgreater, isless, islessequal, islessgreater — real-floating relational tests
isinf() — test for infinity
isless(), isgreater, isgreaterequal, islessequal, islessgreater — real-floating relational tests
islessequal(), isgreater, isgreaterequal, isless, islessgreater — real-floating relational tests
islessgreater(), isgreater, isgreaterequal, isless, islessequal — real-floating relational tests
islower(), islower_l — test for a lowercase letter
islower_l(), islower — test for a lowercase letter
isnan() — test for a NaN
isnormal() — test for a normal value
iso646.h — alternative spellings
isprint(), isprint_l — test for a printable character
isprint_l(), isprint — test for a printable character
ispunct(), ispunct_l — test for a punctuation character
ispunct_l(), ispunct — test for a punctuation character
isspace(), isspace_l — test for a white-space character
isspace_l(), isspace — test for a white-space character
isunordered() — test if arguments are unordered
isupper(), isupper_l — test for an uppercase letter
isupper_l(), isupper — test for an uppercase letter
iswalnum(), iswalnum_l — test for an alphanumeric wide-character code
iswalnum_l(), iswalnum — test for an alphanumeric wide-character code
iswalpha(), iswalpha_l — test for an alphabetic wide-character code
iswalpha_l(), iswalpha — test for an alphabetic wide-character code
iswblank(), iswblank_l — test for a blank wide-character code
iswblank_l(), iswblank — test for a blank wide-character code
iswcntrl(), iswcntrl_l — test for a control wide-character code
iswcntrl_l(), iswcntrl — test for a control wide-character code
iswctype(), iswctype_l — test character for a specified class
iswctype_l(), iswctype — test character for a specified class
iswdigit(), iswdigit_l — test for a decimal digit wide-character code
iswdigit_l(), iswdigit — test for a decimal digit wide-character code
iswgraph(), iswgraph_l — test for a visible wide-character code
iswgraph_l(), iswgraph — test for a visible wide-character code
iswlower(), iswlower_l — test for a lowercase letter wide-character code
iswlower_l(), iswlower — test for a lowercase letter wide-character code
iswprint(), iswprint_l — test for a printable wide-character code
iswprint_l(), iswprint — test for a printable wide-character code
iswpunct(), iswpunct_l — test for a punctuation wide-character code
iswpunct_l(), iswpunct — test for a punctuation wide-character code
iswspace(), iswspace_l — test for a white-space wide-character code
iswspace_l(), iswspace — test for a white-space wide-character code
iswupper(), iswupper_l — test for an uppercase letter wide-character code
iswupper_l(), iswupper — test for an uppercase letter wide-character code
iswxdigit(), iswxdigit_l — test for a hexadecimal digit wide-character code
iswxdigit_l(), iswxdigit — test for a hexadecimal digit wide-character code
isxdigit(), isxdigit_l — test for a hexadecimal digit
isxdigit_l(), isxdigit — test for a hexadecimal digit
Topics
2.1 Implementation Conformance
3.172 Incomplete Line
3.173 Inf
3.174 Interactive Device
3.175 Interactive Shell
3.176 Internationalization
3.177 Interprocess Communication
3.178 Intrinsic Utility
3.179 Invoke
8.2 Internationalization Variables
11.1 Interface Characteristics
Copyright © 2024 The IEEE and The Open Group, All Rights Reserved
===== susv5-html/idx/ie.html =====
Alphabetical Index - E
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2024 The IEEE and The Open Group, All Rights reserved.
[
A
|
B
|
C
|
D
|
E
|
F
|
G
|
H
|
I
|
J
|
K
|
L
|
M
|
N
|
O
|
P
|
Q
|
R
|
S
|
T
|
U
|
V
|
W
|
X
|
Y
|
Z
| Index  ]
E
_Exit(), _exit — terminate a process
echo — write arguments to standard output
ed — edit text
encrypt() — encoding function (CRYPT)
endgrent(), getgrent, setgrent — group database entry functions
endhostent(), gethostent, sethostent — network host database functions
endian.h — system endianness
endnetent(), getnetbyaddr, getnetbyname, getnetent, setnetent — network database functions
endprotoent(), getprotobyname, getprotobynumber, getprotoent, setprotoent — network protocol database functions
endpwent(), getpwent, setpwent — user database functions
endservent(), getservbyname, getservbyport, getservent, setservent — network services database functions
endutxent(), getutxent, getutxid, getutxline, pututxline, setutxent — user accounting database functions
env — set the environment for command invocation
environ, execl, execle, execlp, execv, execve, execvp, fexecve — execute a file
erand48(), drand48, jrand48, lcong48, lrand48, mrand48, nrand48, seed48, srand48 — generate uniformly distributed pseudo-random numbers
erf(), erff, erfl — error functions
erfc(), erfcf, erfcl — complementary error functions
erfcf(), erfc, erfcl — complementary error functions
erfcl(), erfc, erfcf — complementary error functions
erff(), erf, erfl — error functions
erfl(), erf, erff — error functions
errno — error return value
errno.h — system error numbers
eval — construct command by concatenating arguments
ex — text editor
exec — perform redirections in the current shell or execute a utility
execl(), environ, execle, execlp, execv, execve, execvp, fexecve — execute a file
execle(), environ, execl, execlp, execv, execve, execvp, fexecve — execute a file
execlp(), environ, execl, execle, execv, execve, execvp, fexecve — execute a file
execv(), environ, execl, execle, execlp, execve, execvp, fexecve — execute a file
execve(), environ, execl, execle, execlp, execv, execvp, fexecve — execute a file
execvp(), environ, execl, execle, execlp, execv, execve, fexecve — execute a file
exit — cause the shell to exit
exit() — terminate a process
exp(), expf, expl — exponential function
exp2(), exp2f, exp2l — exponential base 2 functions
exp2f(), exp2, exp2l — exponential base 2 functions
exp2l(), exp2, exp2f — exponential base 2 functions
expand — convert tabs to spaces
expf(), exp, expl — exponential function
expl(), exp, expf — exponential function
expm1(), expm1f, expm1l — compute exponential functions
expm1f(), expm1, expm1l — compute exponential functions
expm1l(), expm1, expm1f — compute exponential functions
export — set the export attribute for variables
expr — evaluate arguments as an expression
Topics
3.116 Effective Group ID
3.117 Effective User ID
3.118 Eight-Bit Transparency
3.119 Empty Directory
3.120 Empty Line
3.121 Empty String (or Null String)
3.122 Empty Wide-Character String
3.123 Encoding Rule
3.124 Entire Regular Expression
3.125 Epoch
3.126 Equivalence Class
3.127 Era
3.128 Event Management
3.129 Executable File
3.130 Execute
3.131 Execution Time
3.132 Execution Time Monitoring
3.133 Expand
3.134 Extended Regular Expression (ERE)
3.135 Extended Security Controls
4.6 Extended Security Controls
8. Environment Variables
8.1 Environment Variable Definition
9.4 Extended Regular Expressions
Copyright © 2024 The IEEE and The Open Group, All Rights Reserved
===== susv5-html/idx/sbi.html =====
Special Built-in Utilities
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024 Edition
Copyright © 2024 The IEEE and The Open Group, All Rights reserved.
Special Built-in Utilities
break - exit from for, while, or until loop
colon - null utility
continue - continue for, while or until loop
dot - execute commands in current environment
eval - construct command by concatenating arguments
exec - execute commands and open, close, or copy file descriptors
exit - cause the shell to exit
export - set export attribute for variables
readonly - set read-only attribute for variables
return - return from a function
set - set or unset options and positional parameters
shift - shift positional parameters
times - write process times
trap - trap signals
unset - unset values and attributes of variables and functions
===== susv5-html/idx/ip.html =====
Alphabetical Index - P
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2024 The IEEE and The Open Group, All Rights reserved.
[
A
|
B
|
C
|
D
|
E
|
F
|
G
|
H
|
I
|
J
|
K
|
L
|
M
|
N
|
O
|
P
|
Q
|
R
|
S
|
T
|
U
|
V
|
W
|
X
|
Y
|
Z
| Index  ]
P
paste — merge corresponding or subsequent lines of files
patch — apply changes to files
pathchk — check pathnames
pathconf(), fpathconf — get configurable pathname variables
pause() — suspend the thread until a signal is received
pax — portable archive interchange
pclose() — close a pipe stream to or from a process
perror() — write error messages to standard error
pipe(), pipe2 — create an interprocess channel
pipe2(), pipe — create an interprocess channel
poll(), ppoll — input/output multiplexing
poll.h — definitions for the poll() function
popen() — initiate pipe streams to or from a process
posix_close(), close — close a file descriptor
posix_devctl() — device control
posix_fadvise() — file advisory information (ADVANCED REALTIME)
posix_fallocate() — file space control (ADVANCED REALTIME)
posix_getdents() — read directory entries
posix_madvise() — memory advisory information and alignment control (ADVANCED REALTIME)
posix_memalign() — aligned memory allocation (ADVANCED REALTIME)
posix_mem_offset() — find offset and length of a mapped typed memory block (ADVANCED REALTIME)
posix_openpt() — open a pseudo-terminal device
posix_spawn(), posix_spawnp — spawn a process (ADVANCED REALTIME)
posix_spawnattr_destroy(), posix_spawnattr_init — destroy and initialize spawn attributes object (ADVANCED REALTIME)
posix_spawnattr_getflags(), posix_spawnattr_setflags — get and set the spawn-flags attribute of a spawn attributes object (ADVANCED REALTIME)
posix_spawnattr_getpgroup(), posix_spawnattr_setpgroup — get and set the spawn-pgroup attribute of a spawn attributes object (ADVANCED REALTIME)
posix_spawnattr_getschedparam(), posix_spawnattr_setschedparam — get and set the spawn-schedparam attribute of a spawn attributes object (ADVANCED REALTIME)
posix_spawnattr_getschedpolicy(), posix_spawnattr_setschedpolicy — get and set the spawn-schedpolicy attribute of a spawn attributes object (ADVANCED REALTIME)
posix_spawnattr_getsigdefault(), posix_spawnattr_setsigdefault — get and set the spawn-sigdefault attribute of a spawn attributes object (ADVANCED REALTIME)
posix_spawnattr_getsigmask(), posix_spawnattr_setsigmask — get and set the spawn-sigmask attribute of a spawn attributes object (ADVANCED REALTIME)
posix_spawnattr_init(), posix_spawnattr_destroy — destroy and initialize spawn attributes object (ADVANCED REALTIME)
posix_spawnattr_setflags(), posix_spawnattr_getflags — get and set the spawn-flags attribute of a spawn attributes object (ADVANCED REALTIME)
posix_spawnattr_setpgroup(), posix_spawnattr_getpgroup — get and set the spawn-pgroup attribute of a spawn attributes object (ADVANCED REALTIME)
posix_spawnattr_setschedparam(), posix_spawnattr_getschedparam — get and set the spawn-schedparam attribute of a spawn attributes object (ADVANCED REALTIME)
posix_spawnattr_setschedpolicy(), posix_spawnattr_getschedpolicy — get and set the spawn-schedpolicy attribute of a spawn attributes object (ADVANCED REALTIME)
posix_spawnattr_setsigdefault(), posix_spawnattr_getsigdefault — get and set the spawn-sigdefault attribute of a spawn attributes object (ADVANCED REALTIME)
posix_spawnattr_setsigmask(), posix_spawnattr_getsigmask — get and set the spawn-sigmask attribute of a spawn attributes object (ADVANCED REALTIME)
posix_spawnp(), posix_spawn — spawn a process (ADVANCED REALTIME)
posix_spawn_file_actions_addchdir(), posix_spawn_file_actions_addfchdir — add chdir or fchdir action to spawn file actions object (ADVANCED REALTIME)
posix_spawn_file_actions_addclose(), posix_spawn_file_actions_addopen — add close or open action to spawn file actions object (ADVANCED REALTIME)
posix_spawn_file_actions_adddup2() — add dup2 action to spawn file actions object (ADVANCED REALTIME)
posix_spawn_file_actions_addfchdir(), posix_spawn_file_actions_addchdir — add chdir or fchdir action to spawn file actions object (ADVANCED REALTIME)
posix_spawn_file_actions_addopen(), posix_spawn_file_actions_addclose — add close or open action to spawn file actions object (ADVANCED REALTIME)
posix_spawn_file_actions_destroy(), posix_spawn_file_actions_init — destroy and initialize spawn file actions object (ADVANCED REALTIME)
posix_spawn_file_actions_init(), posix_spawn_file_actions_destroy — destroy and initialize spawn file actions object (ADVANCED REALTIME)
posix_typed_mem_get_info() — query typed memory information (ADVANCED REALTIME)
posix_typed_mem_open() — open a typed memory object (ADVANCED REALTIME)
pow(), powf, powl — power function
powf(), pow, powl — power function
powl(), pow, powf — power function
ppoll(), poll — input/output multiplexing
pr — print files
pread(), read — read from a file
printf — write formatted output
printf(), asprintf, dprintf, fprintf, snprintf, sprintf — print formatted output
prs — print an SCCS file (DEVELOPMENT)
ps — report process status
pselect(), select — synchronous I/O multiplexing
psiginfo(), psignal — write signal information to standard error
psignal(), psiginfo — write signal information to standard error
pthread.h — threads
pthread_atfork() — register fork handlers
pthread_attr_destroy(), pthread_attr_init — destroy and initialize the thread attributes object
pthread_attr_getdetachstate(), pthread_attr_setdetachstate — get and set the detachstate attribute
pthread_attr_getguardsize(), pthread_attr_setguardsize — get and set the thread guardsize attribute
pthread_attr_getinheritsched(), pthread_attr_setinheritsched — get and set the inheritsched attribute (REALTIME THREADS)
pthread_attr_getschedparam(), pthread_attr_setschedparam — get and set the schedparam attribute
pthread_attr_getschedpolicy(), pthread_attr_setschedpolicy — get and set the schedpolicy attribute (REALTIME THREADS)
pthread_attr_getscope(), pthread_attr_setscope — get and set the contentionscope attribute (REALTIME THREADS)
pthread_attr_getstack(), pthread_attr_setstack — get and set stack attributes
pthread_attr_getstacksize(), pthread_attr_setstacksize — get and set the stacksize attribute
pthread_attr_init(), pthread_attr_destroy — destroy and initialize the thread attributes object
pthread_attr_setdetachstate(), pthread_attr_getdetachstate — get and set the detachstate attribute
pthread_attr_setguardsize(), pthread_attr_getguardsize — get and set the thread guardsize attribute
pthread_attr_setinheritsched(), pthread_attr_getinheritsched — get and set the inheritsched attribute (REALTIME THREADS)
pthread_attr_setschedparam(), pthread_attr_getschedparam — get and set the schedparam attribute
pthread_attr_setschedpolicy(), pthread_attr_getschedpolicy — get and set the schedpolicy attribute (REALTIME THREADS)
pthread_attr_setscope(), pthread_attr_getscope — get and set the contentionscope attribute (REALTIME THREADS)
pthread_attr_setstack(), pthread_attr_getstack — get and set stack attributes
pthread_attr_setstacksize(), pthread_attr_getstacksize — get and set the stacksize attribute
pthread_barrierattr_destroy(), pthread_barrierattr_init — destroy and initialize the barrier attributes object
pthread_barrierattr_getpshared(), pthread_barrierattr_setpshared — get and set the process-shared attribute of the barrier attributes object
pthread_barrierattr_init(), pthread_barrierattr_destroy — destroy and initialize the barrier attributes object
pthread_barrierattr_setpshared(), pthread_barrierattr_getpshared — get and set the process-shared attribute of the barrier attributes object
pthread_barrier_destroy(), pthread_barrier_init — destroy and initialize a barrier object
pthread_barrier_init(), pthread_barrier_destroy — destroy and initialize a barrier object
pthread_barrier_wait() — synchronize at a barrier
pthread_cancel() — cancel execution of a thread
pthread_cleanup_pop(), pthread_cleanup_push — establish cancellation handlers
pthread_cleanup_push(), pthread_cleanup_pop — establish cancellation handlers
pthread_condattr_destroy(), pthread_condattr_init — destroy and initialize the condition variable attributes object
pthread_condattr_getclock(), pthread_condattr_setclock — get and set the clock selection condition variable attribute
pthread_condattr_getpshared(), pthread_condattr_setpshared — get and set the process-shared condition variable attributes
pthread_condattr_init(), pthread_condattr_destroy — destroy and initialize the condition variable attributes object
pthread_condattr_setclock(), pthread_condattr_getclock — get and set the clock selection condition variable attribute
pthread_condattr_setpshared(), pthread_condattr_getpshared — get and set the process-shared condition variable attributes
pthread_cond_broadcast(), pthread_cond_signal — broadcast or signal a condition
pthread_cond_clockwait(), pthread_cond_timedwait, pthread_cond_wait — wait on a condition
pthread_cond_destroy(), pthread_cond_init — destroy and initialize condition variables
pthread_cond_init(), pthread_cond_destroy — destroy and initialize condition variables
pthread_cond_signal(), pthread_cond_broadcast — broadcast or signal a condition
pthread_cond_timedwait(), pthread_cond_clockwait, pthread_cond_wait — wait on a condition
pthread_cond_wait(), pthread_cond_clockwait, pthread_cond_timedwait — wait on a condition
pthread_create() — thread creation
pthread_detach() — detach a thread
pthread_equal() — compare thread IDs
pthread_exit() — thread termination
pthread_getcpuclockid() — access a thread CPU-time clock (ADVANCED REALTIME THREADS)
pthread_getschedparam(), pthread_setschedparam — dynamic thread scheduling parameters access (REALTIME THREADS)
pthread_getspecific(), pthread_setspecific — thread-specific data management
pthread_join() — wait for thread termination
pthread_key_create() — thread-specific data key creation
pthread_key_delete() — thread-specific data key deletion
pthread_kill() — send a signal to a thread
pthread_mutexattr_destroy(), pthread_mutexattr_init — destroy and initialize the mutex attributes object
pthread_mutexattr_getprioceiling(), pthread_mutexattr_setprioceiling — get and set the prioceiling attribute of the mutex attributes object (REALTIME THREADS)
pthread_mutexattr_getprotocol(), pthread_mutexattr_setprotocol — get and set the protocol attribute of the mutex attributes object (REALTIME THREADS)
pthread_mutexattr_getpshared(), pthread_mutexattr_setpshared — get and set the process-shared attribute
pthread_mutexattr_getrobust(), pthread_mutexattr_setrobust — get and set the mutex robust attribute
pthread_mutexattr_gettype(), pthread_mutexattr_settype — get and set the mutex type attribute
pthread_mutexattr_init(), pthread_mutexattr_destroy — destroy and initialize the mutex attributes object
pthread_mutexattr_setprioceiling(), pthread_mutexattr_getprioceiling — get and set the prioceiling attribute of the mutex attributes object (REALTIME THREADS)
pthread_mutexattr_setprotocol(), pthread_mutexattr_getprotocol — get and set the protocol attribute of the mutex attributes object (REALTIME THREADS)
pthread_mutexattr_setpshared(), pthread_mutexattr_getpshared — get and set the process-shared attribute
pthread_mutexattr_setrobust(), pthread_mutexattr_getrobust — get and set the mutex robust attribute
pthread_mutexattr_settype(), pthread_mutexattr_gettype — get and set the mutex type attribute
pthread_mutex_clocklock(), pthread_mutex_timedlock — lock a mutex
pthread_mutex_consistent() — mark state protected by robust mutex as consistent
pthread_mutex_destroy(), pthread_mutex_init — destroy and initialize a mutex
pthread_mutex_getprioceiling(), pthread_mutex_setprioceiling — get and set the priority ceiling of a mutex (REALTIME THREADS)
pthread_mutex_init(), pthread_mutex_destroy — destroy and initialize a mutex
pthread_mutex_lock(), pthread_mutex_trylock, pthread_mutex_unlock — lock and unlock a mutex
pthread_mutex_setprioceiling(), pthread_mutex_getprioceiling — get and set the priority ceiling of a mutex (REALTIME THREADS)
pthread_mutex_timedlock(), pthread_mutex_clocklock — lock a mutex
pthread_mutex_trylock(), pthread_mutex_lock, pthread_mutex_unlock — lock and unlock a mutex
pthread_mutex_unlock(), pthread_mutex_lock, pthread_mutex_trylock — lock and unlock a mutex
pthread_once() — dynamic package initialization
pthread_rwlockattr_destroy(), pthread_rwlockattr_init — destroy and initialize the read-write lock attributes object
pthread_rwlockattr_getpshared(), pthread_rwlockattr_setpshared — get and set the process-shared attribute of the read-write lock attributes object
pthread_rwlockattr_init(), pthread_rwlockattr_destroy — destroy and initialize the read-write lock attributes object
pthread_rwlockattr_setpshared(), pthread_rwlockattr_getpshared — get and set the process-shared attribute of the read-write lock attributes object
pthread_rwlock_clockrdlock(), pthread_rwlock_timedrdlock — lock a read-write lock for reading
pthread_rwlock_clockwrlock(), pthread_rwlock_timedwrlock — lock a read-write lock for writing
pthread_rwlock_destroy(), pthread_rwlock_init — destroy and initialize a read-write lock object
pthread_rwlock_init(), pthread_rwlock_destroy — destroy and initialize a read-write lock object
pthread_rwlock_rdlock(), pthread_rwlock_tryrdlock — lock a read-write lock object for reading
pthread_rwlock_timedrdlock(), pthread_rwlock_clockrdlock — lock a read-write lock for reading
pthread_rwlock_timedwrlock(), pthread_rwlock_clockwrlock — lock a read-write lock for writing
pthread_rwlock_tryrdlock(), pthread_rwlock_rdlock — lock a read-write lock object for reading
pthread_rwlock_trywrlock(), pthread_rwlock_wrlock — lock a read-write lock object for writing
pthread_rwlock_unlock() — unlock a read-write lock object
pthread_rwlock_wrlock(), pthread_rwlock_trywrlock — lock a read-write lock object for writing
pthread_self() — get the calling thread ID
pthread_setcancelstate(), pthread_setcanceltype, pthread_testcancel — set cancelability state
pthread_setcanceltype(), pthread_setcancelstate, pthread_testcancel — set cancelability state
pthread_setschedparam(), pthread_getschedparam — dynamic thread scheduling parameters access (REALTIME THREADS)
pthread_setschedprio() — dynamic thread scheduling parameters access (REALTIME THREADS)
pthread_setspecific(), pthread_getspecific — thread-specific data management
pthread_sigmask(), sigprocmask — examine and change blocked signals
pthread_spin_destroy(), pthread_spin_init — destroy or initialize a spin lock object
pthread_spin_init(), pthread_spin_destroy — destroy or initialize a spin lock object
pthread_spin_lock(), pthread_spin_trylock — lock a spin lock object
pthread_spin_trylock(), pthread_spin_lock — lock a spin lock object
pthread_spin_unlock() — unlock a spin lock object
pthread_testcancel(), pthread_setcancelstate, pthread_setcanceltype — set cancelability state
ptsname(), ptsname_r — get name of the subsidiary pseudo-terminal device
ptsname_r(), ptsname — get name of the subsidiary pseudo-terminal device
putc() — put a byte on a stream
putchar() — put a byte on a stdout stream
putchar_unlocked(), getc_unlocked, getchar_unlocked, putc_unlocked — stdio with explicit client locking
putc_unlocked(), getc_unlocked, getchar_unlocked, putchar_unlocked — stdio with explicit client locking
putenv() — change or add a value to an environment
puts() — put a string on standard output
pututxline(), endutxent, getutxent, getutxid, getutxline, setutxent — user accounting database functions
putwc() — put a wide character on a stream
putwchar() — put a wide character on a stdout stream
pwd — return working directory name
pwd.h — password structure
pwrite(), write — write on a file
Topics
3.248 Page
3.249 Page Size
3.250 Parameter
3.251 Parent Directory
3.252 Parent Process
3.253 Parent Process ID
3.254 Pathname
3.255 Pathname Component
3.256 Path Prefix
3.257 Pattern
3.258 Period Character ()
3.259 Permissions
3.260 Persistence
3.261 Pipe
3.262 Polling
3.263 Portable Character Set
3.264 Portable Filename
3.265 Portable Filename Character Set
3.266 Portable Messages Object Source File (or Dot-Po File)
3.267 Positional Parameter
3.268 Positive
3.269 Preallocation
3.270 Preempted Process (or Thread)
3.271 Previous Job
3.272 Printable Character
3.273 Printable File
3.274 Priority
3.275 Priority Inversion
3.276 Priority Scheduling
3.277 Priority-Based Scheduling
3.278 Privilege
3.279 Process
3.280 Process Group
3.281 Process Group ID
3.282 Process Group Leader
3.283 Process Group Lifetime
3.284 Process ID
3.285 Process Lifetime
3.286 Process Memory Locking
3.287 Process Termination
3.288 Process Virtual Time
3.289 Process-Owned File Lock
3.290 Process-To-Process Communication
3.291 Program
3.292 Protocol
3.293 Pseudo-Terminal
4.16 Pathname Resolution
4.17 Process ID Reuse
6.1 Portable Character Set
7.2 POSIX Locale
11.2 Parameters that Can be Set
Copyright © 2024 The IEEE and The Open Group, All Rights Reserved
===== susv5-html/idx/iq.html =====
Alphabetical Index - Q
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2024 The IEEE and The Open Group, All Rights reserved.
[
A
|
B
|
C
|
D
|
E
|
F
|
G
|
H
|
I
|
J
|
K
|
L
|
M
|
N
|
O
|
P
|
Q
|
R
|
S
|
T
|
U
|
V
|
W
|
X
|
Y
|
Z
| Index  ]
Q
qsort(), qsort_r — sort a table of data
qsort_r(), qsort — sort a table of data
quick_exit() — terminate a process
Topics
Copyright © 2024 The IEEE and The Open Group, All Rights Reserved
===== susv5-html/idx/index.html =====
Alphabetical Index
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024 Edition
Copyright © 2024 The IEEE and The Open Group, All Rights reserved.
INDEX
Select a letter to display all entries in the Index
which begin with that letter.
[
A
|
B
|
C
|
D
|
E
|
F
|
G
|
H
|
I
|
J
|
K
|
L
|
M
|
N
|
O
|
P
|
Q
|
R
|
S
|
T
|
U
|
V
|
W
|
X
|
Y
|
Z ]
[Topic Index ]
[Main Index ]
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a registered Trademark of The IEEE.
HTML Translation by The Open Group
===== susv5-html/idx/functions.html =====
System Interfaces
System Interfaces
CMPLX()
CMPLXF()
CMPLXL()
FD_CLR()
FD_ISSET()
FD_SET()
FD_ZERO()
_Exit()
_Fork()
_exit()
a64l()
abort()
abs()
accept()
accept4()
access()
acos()
acosf()
acosh()
acoshf()
acoshl()
acosl()
aio_cancel()
aio_error()
aio_fsync()
aio_read()
aio_return()
aio_suspend()
aio_write()
alarm()
aligned_alloc()
alphasort()
asctime()
asctime_r()
asin()
asinf()
asinh()
asinhf()
asinhl()
asinl()
asprintf()
assert()
at_quick_exit()
atan()
atan2()
atan2f()
atan2l()
atanf()
atanh()
atanhf()
atanhl()
atanl()
atexit()
atof()
atoi()
atol()
atoll()
atomic_compare_exchange_strong()
atomic_compare_exchange_strong_explicit()
atomic_compare_exchange_weak()
atomic_compare_exchange_weak_explicit()
atomic_exchange()
atomic_exchange_explicit()
atomic_fetch_add()
atomic_fetch_add_explicit()
atomic_fetch_and()
atomic_fetch_and_explicit()
atomic_fetch_or()
atomic_fetch_or_explicit()
atomic_fetch_sub()
atomic_fetch_sub_explicit()
atomic_fetch_xor()
atomic_fetch_xor_explicit()
atomic_flag_clear()
atomic_flag_clear_explicit()
atomic_flag_test_and_set()
atomic_flag_test_and_set_explicit()
atomic_init()
atomic_is_lock_free()
atomic_load()
atomic_load_explicit()
atomic_signal_fence()
atomic_store()
atomic_store_explicit()
atomic_thread_fence()
basename()
be16toh()
be32toh()
be64toh()
bind()
bind_textdomain_codeset()
bindtextdomain()
bsearch()
btowc()
c16rtomb()
c32rtomb()
cabs()
cabsf()
cabsl()
cacos()
cacosf()
cacosh()
cacoshf()
cacoshl()
cacosl()
call_once()
calloc()
carg()
cargf()
cargl()
casin()
casinf()
casinh()
casinhf()
casinhl()
casinl()
catan()
catanf()
catanh()
catanhf()
catanhl()
catanl()
catclose()
catgets()
catopen()
cbrt()
cbrtf()
cbrtl()
ccos()
ccosf()
ccosh()
ccoshf()
ccoshl()
ccosl()
ceil()
ceilf()
ceill()
cexp()
cexpf()
cexpl()
cfgetispeed()
cfgetospeed()
cfsetispeed()
cfsetospeed()
chdir()
chmod()
chown()
cimag()
cimagf()
cimagl()
clearerr()
clock()
clock_getcpuclockid()
clock_getres()
clock_gettime()
clock_nanosleep()
clock_settime()
clog()
clogf()
clogl()
close()
closedir()
closelog()
cnd_broadcast()
cnd_destroy()
cnd_init()
cnd_signal()
cnd_timedwait()
cnd_wait()
confstr()
conj()
conjf()
conjl()
connect()
copysign()
copysignf()
copysignl()
cos()
cosf()
cosh()
coshf()
coshl()
cosl()
cpow()
cpowf()
cpowl()
cproj()
cprojf()
cprojl()
creal()
crealf()
creall()
creat()
crypt()
csin()
csinf()
csinh()
csinhf()
csinhl()
csinl()
csqrt()
csqrtf()
csqrtl()
ctan()
ctanf()
ctanh()
ctanhf()
ctanhl()
ctanl()
ctermid()
ctime()
ctime_r()
daylight
dbm_clearerr()
dbm_close()
dbm_delete()
dbm_error()
dbm_fetch()
dbm_firstkey()
dbm_nextkey()
dbm_open()
dbm_store()
dcgettext()
dcgettext_l()
dcngettext()
dcngettext_l()
dgettext()
dgettext_l()
difftime()
dirfd()
dirname()
div()
dladdr()
dlclose()
dlerror()
dlopen()
dlsym()
dngettext()
dngettext_l()
dprintf()
drand48()
dup()
dup2()
dup3()
duplocale()
encrypt()
endgrent()
endhostent()
endnetent()
endprotoent()
endpwent()
endservent()
endutxent()
environ
erand48()
erf()
erfc()
erfcf()
erfcl()
erff()
erfl()
errno
execl()
execle()
execlp()
execv()
execve()
execvp()
exit()
exp()
exp2()
exp2f()
exp2l()
expf()
expl()
expm1()
expm1f()
expm1l()
fabs()
fabsf()
fabsl()
faccessat()
fchdir()
fchmod()
fchmodat()
fchown()
fchownat()
fclose()
fcntl()
fdatasync()
fdim()
fdimf()
fdiml()
fdopen()
fdopendir()
feclearexcept()
fegetenv()
fegetexceptflag()
fegetround()
feholdexcept()
feof()
feraiseexcept()
ferror()
fesetenv()
fesetexceptflag()
fesetround()
fetestexcept()
feupdateenv()
fexecve()
fflush()
ffs()
ffsl()
ffsll()
fgetc()
fgetpos()
fgets()
fgetwc()
fgetws()
fileno()
flockfile()
floor()
floorf()
floorl()
fma()
fmaf()
fmal()
fmax()
fmaxf()
fmaxl()
fmemopen()
fmin()
fminf()
fminl()
fmod()
fmodf()
fmodl()
fmtmsg()
fnmatch()
fopen()
fork()
fpathconf()
fpclassify()
fprintf()
fputc()
fputs()
fputwc()
fputws()
fread()
free()
freeaddrinfo()
freelocale()
freopen()
frexp()
frexpf()
frexpl()
fscanf()
fseek()
fseeko()
fsetpos()
fstat()
fstatat()
fstatvfs()
fsync()
ftell()
ftello()
ftok()
ftruncate()
ftrylockfile()
funlockfile()
futimens()
fwide()
fwprintf()
fwrite()
fwscanf()
gai_strerror()
getaddrinfo()
getc()
getc_unlocked()
getchar()
getchar_unlocked()
getcwd()
getdate()
getdate_err
getdelim()
getegid()
getentropy()
getenv()
geteuid()
getgid()
getgrent()
getgrgid()
getgrgid_r()
getgrnam()
getgrnam_r()
getgroups()
gethostent()
gethostid()
gethostname()
getline()
getlocalename_l()
getlogin()
getlogin_r()
getnameinfo()
getnetbyaddr()
getnetbyname()
getnetent()
getopt()
getpeername()
getpgid()
getpgrp()
getpid()
getppid()
getpriority()
getprotobyname()
getprotobynumber()
getprotoent()
getpwent()
getpwnam()
getpwnam_r()
getpwuid()
getpwuid_r()
getresgid()
getresuid()
getrlimit()
getrusage()
getservbyname()
getservbyport()
getservent()
getsid()
getsockname()
getsockopt()
getsubopt()
gettext()
gettext_l()
getuid()
getutxent()
getutxid()
getutxline()
getwc()
getwchar()
glob()
globfree()
gmtime()
gmtime_r()
grantpt()
hcreate()
hdestroy()
hsearch()
htobe16()
htobe32()
htobe64()
htole16()
htole32()
htole64()
htonl()
htons()
hypot()
hypotf()
hypotl()
iconv()
iconv_close()
iconv_open()
if_freenameindex()
if_indextoname()
if_nameindex()
if_nametoindex()
ilogb()
ilogbf()
ilogbl()
imaxabs()
imaxdiv()
in6addr_any
in6addr_loopback
inet_addr()
inet_ntoa()
inet_ntop()
inet_pton()
initstate()
insque()
isalnum()
isalnum_l()
isalpha()
isalpha_l()
isatty()
isblank()
isblank_l()
iscntrl()
iscntrl_l()
isdigit()
isdigit_l()
isfinite()
isgraph()
isgraph_l()
isgreater()
isgreaterequal()
isinf()
isless()
islessequal()
islessgreater()
islower()
islower_l()
isnan()
isnormal()
isprint()
isprint_l()
ispunct()
ispunct_l()
isspace()
isspace_l()
isunordered()
isupper()
isupper_l()
iswalnum()
iswalnum_l()
iswalpha()
iswalpha_l()
iswblank()
iswblank_l()
iswcntrl()
iswcntrl_l()
iswctype()
iswctype_l()
iswdigit()
iswdigit_l()
iswgraph()
iswgraph_l()
iswlower()
iswlower_l()
iswprint()
iswprint_l()
iswpunct()
iswpunct_l()
iswspace()
iswspace_l()
iswupper()
iswupper_l()
iswxdigit()
iswxdigit_l()
isxdigit()
isxdigit_l()
j0()
j1()
jn()
jrand48()
kill()
killpg()
kill_dependency()
l64a()
labs()
lchown()
lcong48()
ldexp()
ldexpf()
ldexpl()
ldiv()
le16toh()
le32toh()
le64toh()
lfind()
lgamma()
lgammaf()
lgammal()
link()
linkat()
lio_listio()
listen()
llabs()
lldiv()
llrint()
llrintf()
llrintl()
llround()
llroundf()
llroundl()
localeconv()
localtime()
localtime_r()
lockf()
log()
log10()
log10f()
log10l()
log1p()
log1pf()
log1pl()
log2()
log2f()
log2l()
logb()
logbf()
logbl()
logf()
logl()
longjmp()
lrand48()
lrint()
lrintf()
lrintl()
lround()
lroundf()
lroundl()
lsearch()
lseek()
lstat()
malloc()
mblen()
mbrlen()
mbrtoc16()
mbrtoc32()
mbrtowc()
mbsinit()
mbsnrtowcs()
mbsrtowcs()
mbstowcs()
mbtowc()
memccpy()
memchr()
memcmp()
memcpy()
memmem()
memmove()
memset()
mkdir()
mkdirat()
mkdtemp()
mkfifo()
mkfifoat()
mknod()
mknodat()
mkostemp()
mkstemp()
mktime()
mlock()
mlockall()
mmap()
modf()
modff()
modfl()
mprotect()
mq_close()
mq_getattr()
mq_notify()
mq_open()
mq_receive()
mq_send()
mq_setattr()
mq_timedreceive()
mq_timedsend()
mq_unlink()
mrand48()
msgctl()
msgget()
msgrcv()
msgsnd()
msync()
mtx_destroy()
mtx_init()
mtx_lock()
mtx_timedlock()
mtx_trylock()
mtx_unlock()
munlock()
munlockall()
munmap()
nan()
nanf()
nanl()
nanosleep()
nearbyint()
nearbyintf()
nearbyintl()
newlocale()
nextafter()
nextafterf()
nextafterl()
nexttoward()
nexttowardf()
nexttowardl()
nftw()
ngettext()
ngettext_l()
nice()
nl_langinfo()
nl_langinfo_l()
nrand48()
ntohl()
ntohs()
open()
open_memstream()
open_wmemstream()
openat()
opendir()
openlog()
optarg
opterr
optind
optopt
pathconf()
pause()
pclose()
perror()
pipe()
pipe2()
poll()
popen()
posix_close()
posix_devctl()
posix_fadvise()
posix_fallocate()
posix_getdents()
posix_madvise()
posix_mem_offset()
posix_memalign()
posix_openpt()
posix_spawn()
posix_spawn_file_actions_addchdir()
posix_spawn_file_actions_addclose()
posix_spawn_file_actions_adddup2()
posix_spawn_file_actions_addfchdir()
posix_spawn_file_actions_addopen()
posix_spawn_file_actions_destroy()
posix_spawn_file_actions_init()
posix_spawnattr_destroy()
posix_spawnattr_getflags()
posix_spawnattr_getpgroup()
posix_spawnattr_getschedparam()
posix_spawnattr_getschedpolicy()
posix_spawnattr_getsigdefault()
posix_spawnattr_getsigmask()
posix_spawnattr_init()
posix_spawnattr_setflags()
posix_spawnattr_setpgroup()
posix_spawnattr_setschedparam()
posix_spawnattr_setschedpolicy()
posix_spawnattr_setsigdefault()
posix_spawnattr_setsigmask()
posix_spawnp()
posix_typed_mem_get_info()
posix_typed_mem_open()
pow()
powf()
powl()
ppoll()
pread()
printf()
pselect()
psiginfo()
psignal()
pthread_atfork()
pthread_attr_destroy()
pthread_attr_getdetachstate()
pthread_attr_getguardsize()
pthread_attr_getinheritsched()
pthread_attr_getschedparam()
pthread_attr_getschedpolicy()
pthread_attr_getscope()
pthread_attr_getstack()
pthread_attr_getstacksize()
pthread_attr_init()
pthread_attr_setdetachstate()
pthread_attr_setguardsize()
pthread_attr_setinheritsched()
pthread_attr_setschedparam()
pthread_attr_setschedpolicy()
pthread_attr_setscope()
pthread_attr_setstack()
pthread_attr_setstacksize()
pthread_barrier_destroy()
pthread_barrier_init()
pthread_barrier_wait()
pthread_barrierattr_destroy()
pthread_barrierattr_getpshared()
pthread_barrierattr_init()
pthread_barrierattr_setpshared()
pthread_cancel()
pthread_cleanup_pop()
pthread_cleanup_push()
pthread_cond_broadcast()
pthread_cond_clockwait()
pthread_cond_destroy()
pthread_cond_init()
pthread_cond_signal()
pthread_cond_timedwait()